public void startVisitingObject(Object node) { [EOL]     assignToRoot(new JsonObject()); [EOL] }
public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (isFieldNull(f, obj)) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]         } else { [EOL]             Object fieldValue = getFieldValue(f, obj); [EOL]             addAsChildOfObject(f, new ObjectTypePair(fieldValue, typeOfF, false)); [EOL]         } [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (isFieldNull(f, obj)) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]         } else { [EOL]             Object fieldValue = getFieldValue(f, obj); [EOL]             addAsChildOfObject(f, new ObjectTypePair(fieldValue, typeOfF, false)); [EOL]         } [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (isFieldNull(f, obj)) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]         } else { [EOL]             Object fieldValue = getFieldValue(f, obj); [EOL]             addAsChildOfObject(f, new ObjectTypePair(fieldValue, typeOfF, false)); [EOL]         } [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (isFieldNull(f, obj)) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]         } else { [EOL]             Object fieldValue = getFieldValue(f, obj); [EOL]             addAsChildOfObject(f, new ObjectTypePair(fieldValue, typeOfF, false)); [EOL]         } [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
private void addChildAsElement(FieldAttributes f, JsonElement childElement) { [EOL]     FieldNamingStrategy2 namingPolicy = factory.getFieldNamingPolicy(); [EOL]     root.getAsJsonObject().add(namingPolicy.translateName(f), childElement); [EOL] }
private void addChildAsElement(FieldAttributes f, JsonElement childElement) { [EOL]     FieldNamingStrategy2 namingPolicy = factory.getFieldNamingPolicy(); [EOL]     root.getAsJsonObject().add(namingPolicy.translateName(f), childElement); [EOL] }
private void addChildAsElement(FieldAttributes f, JsonElement childElement) { [EOL]     FieldNamingStrategy2 namingPolicy = factory.getFieldNamingPolicy(); [EOL]     root.getAsJsonObject().add(namingPolicy.translateName(f), childElement); [EOL] }
private void addAsArrayElement(ObjectTypePair elementTypePair) { [EOL]     if (elementTypePair.getObject() == null) { [EOL]         root.getAsJsonArray().add(JsonNull.createJsonNull()); [EOL]     } else { [EOL]         JsonElement childElement = getJsonElementForChild(elementTypePair); [EOL]         root.getAsJsonArray().add(childElement); [EOL]     } [EOL] }
private void addAsArrayElement(ObjectTypePair elementTypePair) { [EOL]     if (elementTypePair.getObject() == null) { [EOL]         root.getAsJsonArray().add(JsonNull.createJsonNull()); [EOL]     } else { [EOL]         JsonElement childElement = getJsonElementForChild(elementTypePair); [EOL]         root.getAsJsonArray().add(childElement); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         Preconditions.checkState(root.isJsonObject()); [EOL]         Object obj = f.get(parent); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(obj, declaredTypeOfField, false); [EOL]         JsonElement child = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (child != null) { [EOL]             addChildAsElement(f, child); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         Preconditions.checkState(root.isJsonObject()); [EOL]         Object obj = f.get(parent); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(obj, declaredTypeOfField, false); [EOL]         JsonElement child = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (child != null) { [EOL]             addChildAsElement(f, child); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         Preconditions.checkState(root.isJsonObject()); [EOL]         Object obj = f.get(parent); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(obj, declaredTypeOfField, false); [EOL]         JsonElement child = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (child != null) { [EOL]             addChildAsElement(f, child); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         Preconditions.checkState(root.isJsonObject()); [EOL]         Object obj = f.get(parent); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(obj, declaredTypeOfField, false); [EOL]         JsonElement child = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (child != null) { [EOL]             addChildAsElement(f, child); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         Preconditions.checkState(root.isJsonObject()); [EOL]         Object obj = f.get(parent); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(obj, declaredTypeOfField, false); [EOL]         JsonElement child = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (child != null) { [EOL]             addChildAsElement(f, child); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         Preconditions.checkState(root.isJsonObject()); [EOL]         Object obj = f.get(parent); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 addChildAsElement(f, JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(obj, declaredTypeOfField, false); [EOL]         JsonElement child = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (child != null) { [EOL]             addChildAsElement(f, child); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(f); [EOL]     } [EOL] }
public void setLenient(boolean lenient) { [EOL]     this.lenient = lenient; [EOL] }
public void setLenient(boolean lenient) { [EOL]     this.lenient = lenient; [EOL] }
public boolean isLenient() { [EOL]     return lenient; [EOL] }
public boolean isLenient() { [EOL]     return lenient; [EOL] }
public void setHtmlSafe(boolean htmlSafe) { [EOL]     this.htmlSafe = htmlSafe; [EOL] }
public void setHtmlSafe(boolean htmlSafe) { [EOL]     this.htmlSafe = htmlSafe; [EOL] }
public boolean isHtmlSafe() { [EOL]     return htmlSafe; [EOL] }
public boolean isHtmlSafe() { [EOL]     return htmlSafe; [EOL] }
public JsonWriter beginObject() throws IOException { [EOL]     return open(JsonScope.EMPTY_OBJECT, "{"); [EOL] }
public JsonWriter beginObject() throws IOException { [EOL]     return open(JsonScope.EMPTY_OBJECT, "{"); [EOL] }
public JsonWriter endObject() throws IOException { [EOL]     return close(JsonScope.EMPTY_OBJECT, JsonScope.NONEMPTY_OBJECT, "}"); [EOL] }
public boolean shouldSkipField(FieldAttributes f) { [EOL]     return skipSyntheticFields && f.isSynthetic(); [EOL] }
public boolean shouldSkipField(FieldAttributes f) { [EOL]     return skipSyntheticFields && f.isSynthetic(); [EOL] }
public boolean shouldSkipField(FieldAttributes f) { [EOL]     return skipSyntheticFields && f.isSynthetic(); [EOL] }
public boolean shouldSkipField(FieldAttributes f) { [EOL]     for (int modifier : modifiers) { [EOL]         if (f.hasModifier(modifier)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean shouldSkipField(FieldAttributes f) { [EOL]     for (int modifier : modifiers) { [EOL]         if (f.hasModifier(modifier)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException { [EOL]     int pos = 0; [EOL]     int len = plainText.length(); [EOL]     for (int charCount, i = 0; i < len; i += charCount) { [EOL]         int codePoint = Character.codePointAt(plainText, i); [EOL]         charCount = Character.charCount(codePoint); [EOL]         if (!isControlCharacter(codePoint) && !mustEscapeCharInJsString(codePoint)) { [EOL]             continue; [EOL]         } [EOL]         out.append(plainText, pos, i); [EOL]         pos = i + charCount; [EOL]         switch(codePoint) { [EOL]             case '\b': [EOL]                 out.append("\\b"); [EOL]                 break; [EOL]             case '\t': [EOL]                 out.append("\\t"); [EOL]                 break; [EOL]             case '\n': [EOL]                 out.append("\\n"); [EOL]                 break; [EOL]             case '\f': [EOL]                 out.append("\\f"); [EOL]                 break; [EOL]             case '\r': [EOL]                 out.append("\\r"); [EOL]                 break; [EOL]             case '\\': [EOL]                 out.append("\\\\"); [EOL]                 break; [EOL]             case '/': [EOL]                 out.append("\\/"); [EOL]                 break; [EOL]             case '"': [EOL]                 out.append("\\\""); [EOL]                 break; [EOL]             default: [EOL]                 appendHexJavaScriptRepresentation(codePoint, out); [EOL]                 break; [EOL]         } [EOL]     } [EOL]     out.append(plainText, pos, len); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException { [EOL]     if (Character.isSupplementaryCodePoint(codePoint)) { [EOL]         char[] surrogates = Character.toChars(codePoint); [EOL]         appendHexJavaScriptRepresentation(surrogates[0], out); [EOL]         appendHexJavaScriptRepresentation(surrogates[1], out); [EOL]         return; [EOL]     } [EOL]     out.append("\\u").append(HEX_CHARS[(codePoint >>> 12) & 0xf]).append(HEX_CHARS[(codePoint >>> 8) & 0xf]).append(HEX_CHARS[(codePoint >>> 4) & 0xf]).append(HEX_CHARS[codePoint & 0xf]); [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
@Override [EOL] public int hashCode() { [EOL]     return 17 * ((first != null) ? first.hashCode() : 0) + 17 * ((second != null) ? second.hashCode() : 0); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return 17 * ((first != null) ? first.hashCode() : 0) + 17 * ((second != null) ? second.hashCode() : 0); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return 17 * ((first != null) ? first.hashCode() : 0) + 17 * ((second != null) ? second.hashCode() : 0); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return 17 * ((first != null) ? first.hashCode() : 0) + 17 * ((second != null) ? second.hashCode() : 0); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (!(o instanceof Pair<?, ?>)) { [EOL]         return false; [EOL]     } [EOL]     Pair<?, ?> that = (Pair<?, ?>) o; [EOL]     return equal(this.first, that.first) && equal(this.second, that.second); [EOL] }
private static boolean equal(Object a, Object b) { [EOL]     return a == b || (a != null && a.equals(b)); [EOL] }
private static boolean equal(Object a, Object b) { [EOL]     return a == b || (a != null && a.equals(b)); [EOL] }
private static boolean equal(Object a, Object b) { [EOL]     return a == b || (a != null && a.equals(b)); [EOL] }
private static boolean equal(Object a, Object b) { [EOL]     return a == b || (a != null && a.equals(b)); [EOL] }
private static boolean equal(Object a, Object b) { [EOL]     return a == b || (a != null && a.equals(b)); [EOL] }
private static boolean equal(Object a, Object b) { [EOL]     return a == b || (a != null && a.equals(b)); [EOL] }
public JsonReader(Reader in) { [EOL]     if (in == null) { [EOL]         throw new NullPointerException("in == null"); [EOL]     } [EOL]     this.in = in; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public JsonReader(Reader in) { [EOL]     if (in == null) { [EOL]         throw new NullPointerException("in == null"); [EOL]     } [EOL]     this.in = in; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public void setLenient(boolean lenient) { [EOL]     this.lenient = lenient; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public void beginArray() throws IOException { [EOL]     expect(JsonToken.BEGIN_ARRAY); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public void beginArray() throws IOException { [EOL]     expect(JsonToken.BEGIN_ARRAY); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public void beginArray() throws IOException { [EOL]     expect(JsonToken.BEGIN_ARRAY); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public void endArray() throws IOException { [EOL]     expect(JsonToken.END_ARRAY); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public void endArray() throws IOException { [EOL]     expect(JsonToken.END_ARRAY); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public void beginObject() throws IOException { [EOL]     expect(JsonToken.BEGIN_OBJECT); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public void beginObject() throws IOException { [EOL]     expect(JsonToken.BEGIN_OBJECT); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public void beginObject() throws IOException { [EOL]     expect(JsonToken.BEGIN_OBJECT); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public void endObject() throws IOException { [EOL]     expect(JsonToken.END_OBJECT); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private void expect(JsonToken expected) throws IOException { [EOL]     quickPeek(); [EOL]     if (token != expected) { [EOL]         throw new IllegalStateException("Expected " + expected + " but was " + peek()); [EOL]     } [EOL]     advance(); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public boolean hasNext() throws IOException { [EOL]     quickPeek(); [EOL]     return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public boolean hasNext() throws IOException { [EOL]     quickPeek(); [EOL]     return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public boolean hasNext() throws IOException { [EOL]     quickPeek(); [EOL]     return token != JsonToken.END_OBJECT && token != JsonToken.END_ARRAY; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken quickPeek() throws IOException { [EOL]     if (hasToken) { [EOL]         return token; [EOL]     } [EOL]     switch(peekStack()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (lenient) { [EOL]                 consumeNonExecutePrefix(); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             JsonToken firstToken = nextValue(); [EOL]             if (!lenient && firstToken != JsonToken.BEGIN_ARRAY && firstToken != JsonToken.BEGIN_OBJECT) { [EOL]                 syntaxError("Expected JSON document to start with '[' or '{'"); [EOL]             } [EOL]             return firstToken; [EOL]         case EMPTY_ARRAY: [EOL]             return nextInArray(true); [EOL]         case NONEMPTY_ARRAY: [EOL]             return nextInArray(false); [EOL]         case EMPTY_OBJECT: [EOL]             return nextInObject(true); [EOL]         case DANGLING_NAME: [EOL]             return objectValue(); [EOL]         case NONEMPTY_OBJECT: [EOL]             return nextInObject(false); [EOL]         case NONEMPTY_DOCUMENT: [EOL]             try { [EOL]                 JsonToken token = nextValue(); [EOL]                 if (lenient) { [EOL]                     return token; [EOL]                 } [EOL]                 throw syntaxError("Expected EOF"); [EOL]             } catch (EOFException e) { [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_DOCUMENT; [EOL]             } [EOL]         case CLOSED: [EOL]             throw new IllegalStateException("JsonReader is closed"); [EOL]         default: [EOL]             throw new AssertionError(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private void consumeNonExecutePrefix() throws IOException { [EOL]     nextNonWhitespace(); [EOL]     pos--; [EOL]     if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) { [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) { [EOL]         if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     pos += NON_EXECUTE_PREFIX.length; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private void consumeNonExecutePrefix() throws IOException { [EOL]     nextNonWhitespace(); [EOL]     pos--; [EOL]     if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) { [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) { [EOL]         if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     pos += NON_EXECUTE_PREFIX.length; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private void consumeNonExecutePrefix() throws IOException { [EOL]     nextNonWhitespace(); [EOL]     pos--; [EOL]     if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) { [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) { [EOL]         if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     pos += NON_EXECUTE_PREFIX.length; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private void consumeNonExecutePrefix() throws IOException { [EOL]     nextNonWhitespace(); [EOL]     pos--; [EOL]     if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) { [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) { [EOL]         if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     pos += NON_EXECUTE_PREFIX.length; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken advance() throws IOException { [EOL]     quickPeek(); [EOL]     JsonToken result = token; [EOL]     hasToken = false; [EOL]     token = null; [EOL]     value = null; [EOL]     name = null; [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public String nextName() throws IOException { [EOL]     quickPeek(); [EOL]     if (token != JsonToken.NAME) { [EOL]         throw new IllegalStateException("Expected a name but was " + peek()); [EOL]     } [EOL]     String result = name; [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public String nextName() throws IOException { [EOL]     quickPeek(); [EOL]     if (token != JsonToken.NAME) { [EOL]         throw new IllegalStateException("Expected a name but was " + peek()); [EOL]     } [EOL]     String result = name; [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public boolean nextBoolean() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null || token == JsonToken.STRING) { [EOL]         throw new IllegalStateException("Expected a boolean but was " + peek()); [EOL]     } [EOL]     boolean result; [EOL]     if (value.equalsIgnoreCase("true")) { [EOL]         result = true; [EOL]     } else if (value.equalsIgnoreCase("false")) { [EOL]         result = false; [EOL]     } else { [EOL]         throw new IllegalStateException("Not a boolean: " + value); [EOL]     } [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public boolean nextBoolean() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null || token == JsonToken.STRING) { [EOL]         throw new IllegalStateException("Expected a boolean but was " + peek()); [EOL]     } [EOL]     boolean result; [EOL]     if (value.equalsIgnoreCase("true")) { [EOL]         result = true; [EOL]     } else if (value.equalsIgnoreCase("false")) { [EOL]         result = false; [EOL]     } else { [EOL]         throw new IllegalStateException("Not a boolean: " + value); [EOL]     } [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public boolean nextBoolean() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null || token == JsonToken.STRING) { [EOL]         throw new IllegalStateException("Expected a boolean but was " + peek()); [EOL]     } [EOL]     boolean result; [EOL]     if (value.equalsIgnoreCase("true")) { [EOL]         result = true; [EOL]     } else if (value.equalsIgnoreCase("false")) { [EOL]         result = false; [EOL]     } else { [EOL]         throw new IllegalStateException("Not a boolean: " + value); [EOL]     } [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public boolean nextBoolean() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null || token == JsonToken.STRING) { [EOL]         throw new IllegalStateException("Expected a boolean but was " + peek()); [EOL]     } [EOL]     boolean result; [EOL]     if (value.equalsIgnoreCase("true")) { [EOL]         result = true; [EOL]     } else if (value.equalsIgnoreCase("false")) { [EOL]         result = false; [EOL]     } else { [EOL]         throw new IllegalStateException("Not a boolean: " + value); [EOL]     } [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public void nextNull() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null || token == JsonToken.STRING) { [EOL]         throw new IllegalStateException("Expected null but was " + peek()); [EOL]     } [EOL]     if (!value.equalsIgnoreCase("null")) { [EOL]         throw new IllegalStateException("Not a null: " + value); [EOL]     } [EOL]     advance(); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public void nextNull() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null || token == JsonToken.STRING) { [EOL]         throw new IllegalStateException("Expected null but was " + peek()); [EOL]     } [EOL]     if (!value.equalsIgnoreCase("null")) { [EOL]         throw new IllegalStateException("Not a null: " + value); [EOL]     } [EOL]     advance(); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public void nextNull() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null || token == JsonToken.STRING) { [EOL]         throw new IllegalStateException("Expected null but was " + peek()); [EOL]     } [EOL]     if (!value.equalsIgnoreCase("null")) { [EOL]         throw new IllegalStateException("Not a null: " + value); [EOL]     } [EOL]     advance(); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public double nextDouble() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null) { [EOL]         throw new IllegalStateException("Expected a double but was " + peek()); [EOL]     } [EOL]     double result = Double.parseDouble(value); [EOL]     if ((result >= 1.0d && value.startsWith("0"))) { [EOL]         throw new NumberFormatException("JSON forbids octal prefixes: " + value); [EOL]     } [EOL]     if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) { [EOL]         throw new NumberFormatException("JSON forbids NaN and infinities: " + value); [EOL]     } [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public double nextDouble() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null) { [EOL]         throw new IllegalStateException("Expected a double but was " + peek()); [EOL]     } [EOL]     double result = Double.parseDouble(value); [EOL]     if ((result >= 1.0d && value.startsWith("0"))) { [EOL]         throw new NumberFormatException("JSON forbids octal prefixes: " + value); [EOL]     } [EOL]     if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) { [EOL]         throw new NumberFormatException("JSON forbids NaN and infinities: " + value); [EOL]     } [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public double nextDouble() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null) { [EOL]         throw new IllegalStateException("Expected a double but was " + peek()); [EOL]     } [EOL]     double result = Double.parseDouble(value); [EOL]     if ((result >= 1.0d && value.startsWith("0"))) { [EOL]         throw new NumberFormatException("JSON forbids octal prefixes: " + value); [EOL]     } [EOL]     if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) { [EOL]         throw new NumberFormatException("JSON forbids NaN and infinities: " + value); [EOL]     } [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public double nextDouble() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null) { [EOL]         throw new IllegalStateException("Expected a double but was " + peek()); [EOL]     } [EOL]     double result = Double.parseDouble(value); [EOL]     if ((result >= 1.0d && value.startsWith("0"))) { [EOL]         throw new NumberFormatException("JSON forbids octal prefixes: " + value); [EOL]     } [EOL]     if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) { [EOL]         throw new NumberFormatException("JSON forbids NaN and infinities: " + value); [EOL]     } [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public double nextDouble() throws IOException { [EOL]     quickPeek(); [EOL]     if (value == null) { [EOL]         throw new IllegalStateException("Expected a double but was " + peek()); [EOL]     } [EOL]     double result = Double.parseDouble(value); [EOL]     if ((result >= 1.0d && value.startsWith("0"))) { [EOL]         throw new NumberFormatException("JSON forbids octal prefixes: " + value); [EOL]     } [EOL]     if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) { [EOL]         throw new NumberFormatException("JSON forbids NaN and infinities: " + value); [EOL]     } [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public void close() throws IOException { [EOL]     hasToken = false; [EOL]     value = null; [EOL]     token = null; [EOL]     stack.clear(); [EOL]     stack.add(JsonScope.CLOSED); [EOL]     in.close(); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public void close() throws IOException { [EOL]     hasToken = false; [EOL]     value = null; [EOL]     token = null; [EOL]     stack.clear(); [EOL]     stack.add(JsonScope.CLOSED); [EOL]     in.close(); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonScope peekStack() { [EOL]     return stack.get(stack.size() - 1); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonScope peekStack() { [EOL]     return stack.get(stack.size() - 1); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonScope pop() { [EOL]     return stack.remove(stack.size() - 1); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private void push(JsonScope newTop) { [EOL]     stack.add(newTop); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private void replaceTop(JsonScope newTop) { [EOL]     stack.set(stack.size() - 1, newTop); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private void replaceTop(JsonScope newTop) { [EOL]     stack.set(stack.size() - 1, newTop); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextInArray(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case ']': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             case ';': [EOL]                 checkLenient(); [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated array"); [EOL]         } [EOL]     } [EOL]     switch(nextNonWhitespace()) { [EOL]         case ']': [EOL]             if (firstElement) { [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             } [EOL]         case ';': [EOL]         case ',': [EOL]             checkLenient(); [EOL]             pos--; [EOL]             hasToken = true; [EOL]             value = "null"; [EOL]             return token = JsonToken.NULL; [EOL]         default: [EOL]             pos--; [EOL]             return nextValue(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextInArray(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case ']': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             case ';': [EOL]                 checkLenient(); [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated array"); [EOL]         } [EOL]     } [EOL]     switch(nextNonWhitespace()) { [EOL]         case ']': [EOL]             if (firstElement) { [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             } [EOL]         case ';': [EOL]         case ',': [EOL]             checkLenient(); [EOL]             pos--; [EOL]             hasToken = true; [EOL]             value = "null"; [EOL]             return token = JsonToken.NULL; [EOL]         default: [EOL]             pos--; [EOL]             return nextValue(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextInArray(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case ']': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             case ';': [EOL]                 checkLenient(); [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated array"); [EOL]         } [EOL]     } [EOL]     switch(nextNonWhitespace()) { [EOL]         case ']': [EOL]             if (firstElement) { [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             } [EOL]         case ';': [EOL]         case ',': [EOL]             checkLenient(); [EOL]             pos--; [EOL]             hasToken = true; [EOL]             value = "null"; [EOL]             return token = JsonToken.NULL; [EOL]         default: [EOL]             pos--; [EOL]             return nextValue(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextInArray(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case ']': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             case ';': [EOL]                 checkLenient(); [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated array"); [EOL]         } [EOL]     } [EOL]     switch(nextNonWhitespace()) { [EOL]         case ']': [EOL]             if (firstElement) { [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             } [EOL]         case ';': [EOL]         case ',': [EOL]             checkLenient(); [EOL]             pos--; [EOL]             hasToken = true; [EOL]             value = "null"; [EOL]             return token = JsonToken.NULL; [EOL]         default: [EOL]             pos--; [EOL]             return nextValue(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextInArray(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case ']': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             case ';': [EOL]                 checkLenient(); [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated array"); [EOL]         } [EOL]     } [EOL]     switch(nextNonWhitespace()) { [EOL]         case ']': [EOL]             if (firstElement) { [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             } [EOL]         case ';': [EOL]         case ',': [EOL]             checkLenient(); [EOL]             pos--; [EOL]             hasToken = true; [EOL]             value = "null"; [EOL]             return token = JsonToken.NULL; [EOL]         default: [EOL]             pos--; [EOL]             return nextValue(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextInArray(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case ']': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             case ';': [EOL]                 checkLenient(); [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated array"); [EOL]         } [EOL]     } [EOL]     switch(nextNonWhitespace()) { [EOL]         case ']': [EOL]             if (firstElement) { [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             } [EOL]         case ';': [EOL]         case ',': [EOL]             checkLenient(); [EOL]             pos--; [EOL]             hasToken = true; [EOL]             value = "null"; [EOL]             return token = JsonToken.NULL; [EOL]         default: [EOL]             pos--; [EOL]             return nextValue(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextInObject(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             default: [EOL]                 pos--; [EOL]         } [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             case ';': [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated object"); [EOL]         } [EOL]     } [EOL]     int quote = nextNonWhitespace(); [EOL]     switch(quote) { [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             name = nextString((char) quote); [EOL]             break; [EOL]         default: [EOL]             checkLenient(); [EOL]             pos--; [EOL]             name = nextLiteral(); [EOL]             if (name.length() == 0) { [EOL]                 throw syntaxError("Expected name"); [EOL]             } [EOL]     } [EOL]     replaceTop(JsonScope.DANGLING_NAME); [EOL]     hasToken = true; [EOL]     return token = JsonToken.NAME; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextValue() throws IOException { [EOL]     int c = nextNonWhitespace(); [EOL]     switch(c) { [EOL]         case '{': [EOL]             push(JsonScope.EMPTY_OBJECT); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_OBJECT; [EOL]         case '[': [EOL]             push(JsonScope.EMPTY_ARRAY); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_ARRAY; [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             value = nextString((char) c); [EOL]             hasToken = true; [EOL]             return token = JsonToken.STRING; [EOL]         default: [EOL]             pos--; [EOL]             return readLiteral(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextValue() throws IOException { [EOL]     int c = nextNonWhitespace(); [EOL]     switch(c) { [EOL]         case '{': [EOL]             push(JsonScope.EMPTY_OBJECT); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_OBJECT; [EOL]         case '[': [EOL]             push(JsonScope.EMPTY_ARRAY); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_ARRAY; [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             value = nextString((char) c); [EOL]             hasToken = true; [EOL]             return token = JsonToken.STRING; [EOL]         default: [EOL]             pos--; [EOL]             return readLiteral(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextValue() throws IOException { [EOL]     int c = nextNonWhitespace(); [EOL]     switch(c) { [EOL]         case '{': [EOL]             push(JsonScope.EMPTY_OBJECT); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_OBJECT; [EOL]         case '[': [EOL]             push(JsonScope.EMPTY_ARRAY); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_ARRAY; [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             value = nextString((char) c); [EOL]             hasToken = true; [EOL]             return token = JsonToken.STRING; [EOL]         default: [EOL]             pos--; [EOL]             return readLiteral(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextValue() throws IOException { [EOL]     int c = nextNonWhitespace(); [EOL]     switch(c) { [EOL]         case '{': [EOL]             push(JsonScope.EMPTY_OBJECT); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_OBJECT; [EOL]         case '[': [EOL]             push(JsonScope.EMPTY_ARRAY); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_ARRAY; [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             value = nextString((char) c); [EOL]             hasToken = true; [EOL]             return token = JsonToken.STRING; [EOL]         default: [EOL]             pos--; [EOL]             return readLiteral(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextValue() throws IOException { [EOL]     int c = nextNonWhitespace(); [EOL]     switch(c) { [EOL]         case '{': [EOL]             push(JsonScope.EMPTY_OBJECT); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_OBJECT; [EOL]         case '[': [EOL]             push(JsonScope.EMPTY_ARRAY); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_ARRAY; [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             value = nextString((char) c); [EOL]             hasToken = true; [EOL]             return token = JsonToken.STRING; [EOL]         default: [EOL]             pos--; [EOL]             return readLiteral(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private boolean fillBuffer(int minimum) throws IOException { [EOL]     if (limit != pos) { [EOL]         limit -= pos; [EOL]         System.arraycopy(buffer, pos, buffer, 0, limit); [EOL]     } else { [EOL]         limit = 0; [EOL]     } [EOL]     pos = 0; [EOL]     int total; [EOL]     while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) { [EOL]         limit += total; [EOL]         if (limit >= minimum) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private boolean fillBuffer(int minimum) throws IOException { [EOL]     if (limit != pos) { [EOL]         limit -= pos; [EOL]         System.arraycopy(buffer, pos, buffer, 0, limit); [EOL]     } else { [EOL]         limit = 0; [EOL]     } [EOL]     pos = 0; [EOL]     int total; [EOL]     while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) { [EOL]         limit += total; [EOL]         if (limit >= minimum) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private boolean fillBuffer(int minimum) throws IOException { [EOL]     if (limit != pos) { [EOL]         limit -= pos; [EOL]         System.arraycopy(buffer, pos, buffer, 0, limit); [EOL]     } else { [EOL]         limit = 0; [EOL]     } [EOL]     pos = 0; [EOL]     int total; [EOL]     while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) { [EOL]         limit += total; [EOL]         if (limit >= minimum) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private int nextNonWhitespace() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         int c = buffer[pos++]; [EOL]         switch(c) { [EOL]             case '\t': [EOL]             case ' ': [EOL]             case '\n': [EOL]             case '\r': [EOL]                 continue; [EOL]             case '/': [EOL]                 if (pos == limit && !fillBuffer(1)) { [EOL]                     return c; [EOL]                 } [EOL]                 checkLenient(); [EOL]                 char peek = buffer[pos]; [EOL]                 switch(peek) { [EOL]                     case '*': [EOL]                         pos++; [EOL]                         if (!skipTo("*/")) { [EOL]                             throw syntaxError("Unterminated comment"); [EOL]                         } [EOL]                         pos += 2; [EOL]                         continue; [EOL]                     case '/': [EOL]                         pos++; [EOL]                         skipToEndOfLine(); [EOL]                         continue; [EOL]                     default: [EOL]                         return c; [EOL]                 } [EOL]             case '#': [EOL]                 checkLenient(); [EOL]                 skipToEndOfLine(); [EOL]                 continue; [EOL]             default: [EOL]                 return c; [EOL]         } [EOL]     } [EOL]     throw new EOFException("End of input"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private int nextNonWhitespace() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         int c = buffer[pos++]; [EOL]         switch(c) { [EOL]             case '\t': [EOL]             case ' ': [EOL]             case '\n': [EOL]             case '\r': [EOL]                 continue; [EOL]             case '/': [EOL]                 if (pos == limit && !fillBuffer(1)) { [EOL]                     return c; [EOL]                 } [EOL]                 checkLenient(); [EOL]                 char peek = buffer[pos]; [EOL]                 switch(peek) { [EOL]                     case '*': [EOL]                         pos++; [EOL]                         if (!skipTo("*/")) { [EOL]                             throw syntaxError("Unterminated comment"); [EOL]                         } [EOL]                         pos += 2; [EOL]                         continue; [EOL]                     case '/': [EOL]                         pos++; [EOL]                         skipToEndOfLine(); [EOL]                         continue; [EOL]                     default: [EOL]                         return c; [EOL]                 } [EOL]             case '#': [EOL]                 checkLenient(); [EOL]                 skipToEndOfLine(); [EOL]                 continue; [EOL]             default: [EOL]                 return c; [EOL]         } [EOL]     } [EOL]     throw new EOFException("End of input"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private int nextNonWhitespace() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         int c = buffer[pos++]; [EOL]         switch(c) { [EOL]             case '\t': [EOL]             case ' ': [EOL]             case '\n': [EOL]             case '\r': [EOL]                 continue; [EOL]             case '/': [EOL]                 if (pos == limit && !fillBuffer(1)) { [EOL]                     return c; [EOL]                 } [EOL]                 checkLenient(); [EOL]                 char peek = buffer[pos]; [EOL]                 switch(peek) { [EOL]                     case '*': [EOL]                         pos++; [EOL]                         if (!skipTo("*/")) { [EOL]                             throw syntaxError("Unterminated comment"); [EOL]                         } [EOL]                         pos += 2; [EOL]                         continue; [EOL]                     case '/': [EOL]                         pos++; [EOL]                         skipToEndOfLine(); [EOL]                         continue; [EOL]                     default: [EOL]                         return c; [EOL]                 } [EOL]             case '#': [EOL]                 checkLenient(); [EOL]                 skipToEndOfLine(); [EOL]                 continue; [EOL]             default: [EOL]                 return c; [EOL]         } [EOL]     } [EOL]     throw new EOFException("End of input"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private int nextNonWhitespace() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         int c = buffer[pos++]; [EOL]         switch(c) { [EOL]             case '\t': [EOL]             case ' ': [EOL]             case '\n': [EOL]             case '\r': [EOL]                 continue; [EOL]             case '/': [EOL]                 if (pos == limit && !fillBuffer(1)) { [EOL]                     return c; [EOL]                 } [EOL]                 checkLenient(); [EOL]                 char peek = buffer[pos]; [EOL]                 switch(peek) { [EOL]                     case '*': [EOL]                         pos++; [EOL]                         if (!skipTo("*/")) { [EOL]                             throw syntaxError("Unterminated comment"); [EOL]                         } [EOL]                         pos += 2; [EOL]                         continue; [EOL]                     case '/': [EOL]                         pos++; [EOL]                         skipToEndOfLine(); [EOL]                         continue; [EOL]                     default: [EOL]                         return c; [EOL]                 } [EOL]             case '#': [EOL]                 checkLenient(); [EOL]                 skipToEndOfLine(); [EOL]                 continue; [EOL]             default: [EOL]                 return c; [EOL]         } [EOL]     } [EOL]     throw new EOFException("End of input"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private int nextNonWhitespace() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         int c = buffer[pos++]; [EOL]         switch(c) { [EOL]             case '\t': [EOL]             case ' ': [EOL]             case '\n': [EOL]             case '\r': [EOL]                 continue; [EOL]             case '/': [EOL]                 if (pos == limit && !fillBuffer(1)) { [EOL]                     return c; [EOL]                 } [EOL]                 checkLenient(); [EOL]                 char peek = buffer[pos]; [EOL]                 switch(peek) { [EOL]                     case '*': [EOL]                         pos++; [EOL]                         if (!skipTo("*/")) { [EOL]                             throw syntaxError("Unterminated comment"); [EOL]                         } [EOL]                         pos += 2; [EOL]                         continue; [EOL]                     case '/': [EOL]                         pos++; [EOL]                         skipToEndOfLine(); [EOL]                         continue; [EOL]                     default: [EOL]                         return c; [EOL]                 } [EOL]             case '#': [EOL]                 checkLenient(); [EOL]                 skipToEndOfLine(); [EOL]                 continue; [EOL]             default: [EOL]                 return c; [EOL]         } [EOL]     } [EOL]     throw new EOFException("End of input"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private void checkLenient() throws IOException { [EOL]     if (!lenient) { [EOL]         throw syntaxError("Use JsonReader.setLenient(true) to accept malformed JSON"); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private String nextLiteral() throws IOException { [EOL]     StringBuilder builder = null; [EOL]     do { [EOL]         int start = pos; [EOL]         while (pos < limit) { [EOL]             int c = buffer[pos++]; [EOL]             switch(c) { [EOL]                 case '/': [EOL]                 case '\\': [EOL]                 case ';': [EOL]                 case '#': [EOL]                 case '=': [EOL]                     checkLenient(); [EOL]                 case '{': [EOL]                 case '}': [EOL]                 case '[': [EOL]                 case ']': [EOL]                 case ':': [EOL]                 case ',': [EOL]                 case ' ': [EOL]                 case '\t': [EOL]                 case '\f': [EOL]                 case '\r': [EOL]                 case '\n': [EOL]                     pos--; [EOL]                     if (skipping) { [EOL]                         return "skipped!"; [EOL]                     } else if (builder == null) { [EOL]                         return new String(buffer, start, pos - start); [EOL]                     } else { [EOL]                         builder.append(buffer, start, pos - start); [EOL]                         return builder.toString(); [EOL]                     } [EOL]             } [EOL]         } [EOL]         if (builder == null) { [EOL]             builder = new StringBuilder(); [EOL]         } [EOL]         builder.append(buffer, start, pos - start); [EOL]     } while (fillBuffer(1)); [EOL]     return builder.toString(); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken readLiteral() throws IOException { [EOL]     String literal = nextLiteral(); [EOL]     if (literal.length() == 0) { [EOL]         throw syntaxError("Expected literal value"); [EOL]     } [EOL]     value = literal; [EOL]     hasToken = true; [EOL]     return token = null; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken readLiteral() throws IOException { [EOL]     String literal = nextLiteral(); [EOL]     if (literal.length() == 0) { [EOL]         throw syntaxError("Expected literal value"); [EOL]     } [EOL]     value = literal; [EOL]     hasToken = true; [EOL]     return token = null; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private void decodeLiteral() throws IOException { [EOL]     if (value.equalsIgnoreCase("null")) { [EOL]         token = JsonToken.NULL; [EOL]     } else if (value.equalsIgnoreCase("true") || value.equalsIgnoreCase("false")) { [EOL]         token = JsonToken.BOOLEAN; [EOL]     } else { [EOL]         try { [EOL]             Double.parseDouble(value); [EOL]             token = JsonToken.NUMBER; [EOL]         } catch (NumberFormatException ignored) { [EOL]             checkLenient(); [EOL]             token = JsonToken.STRING; [EOL]         } [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public boolean shouldSkipField(FieldAttributes f) { [EOL]     return isAnonymousOrLocal(f.getDeclaredClass()); [EOL] }
public MalformedJsonException(String s) { [EOL]     super(s); [EOL] }
FieldNamingStrategy2 getFieldNamingPolicy() { [EOL]     return fieldNamingPolicy; [EOL] }
DefaultDateTypeAdapter(final String datePattern) { [EOL]     this.format = new SimpleDateFormat(datePattern); [EOL] }
DefaultDateTypeAdapter(final String datePattern) { [EOL]     this.format = new SimpleDateFormat(datePattern); [EOL] }
public JsonElement serialize(Date src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     synchronized (format) { [EOL]         String dateFormatAsString = format.format(src); [EOL]         return new JsonPrimitive(dateFormatAsString); [EOL]     } [EOL] }
public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (!(json instanceof JsonPrimitive)) { [EOL]         throw new JsonParseException("The date should be a string value"); [EOL]     } [EOL]     try { [EOL]         synchronized (format) { [EOL]             Date date = format.parse(json.getAsString()); [EOL]             return new java.sql.Date(date.getTime()); [EOL]         } [EOL]     } catch (ParseException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (!(json instanceof JsonPrimitive)) { [EOL]         throw new JsonParseException("The date should be a string value"); [EOL]     } [EOL]     try { [EOL]         synchronized (format) { [EOL]             Date date = format.parse(json.getAsString()); [EOL]             return new java.sql.Date(date.getTime()); [EOL]         } [EOL]     } catch (ParseException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
public java.sql.Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (!(json instanceof JsonPrimitive)) { [EOL]         throw new JsonParseException("The date should be a string value"); [EOL]     } [EOL]     try { [EOL]         synchronized (format) { [EOL]             Date date = format.parse(json.getAsString()); [EOL]             return new java.sql.Date(date.getTime()); [EOL]         } [EOL]     } catch (ParseException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
public JsonElement serialize(Time src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     synchronized (format) { [EOL]         String dateFormatAsString = format.format(src); [EOL]         return new JsonPrimitive(dateFormatAsString); [EOL]     } [EOL] }
public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (json.isJsonNull()) { [EOL]         return null; [EOL]     } [EOL]     Collection collection = constructCollectionType(typeOfT, context); [EOL]     Type childType = new TypeInfoCollection(typeOfT).getElementType(); [EOL]     for (JsonElement childElement : json.getAsJsonArray()) { [EOL]         if (childElement == null || childElement.isJsonNull()) { [EOL]             collection.add(null); [EOL]         } else { [EOL]             Object value = context.deserialize(childElement, childType); [EOL]             collection.add(value); [EOL]         } [EOL]     } [EOL]     return collection; [EOL] }
public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (json.isJsonNull()) { [EOL]         return null; [EOL]     } [EOL]     Collection collection = constructCollectionType(typeOfT, context); [EOL]     Type childType = new TypeInfoCollection(typeOfT).getElementType(); [EOL]     for (JsonElement childElement : json.getAsJsonArray()) { [EOL]         if (childElement == null || childElement.isJsonNull()) { [EOL]             collection.add(null); [EOL]         } else { [EOL]             Object value = context.deserialize(childElement, childType); [EOL]             collection.add(value); [EOL]         } [EOL]     } [EOL]     return collection; [EOL] }
public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (json.isJsonNull()) { [EOL]         return null; [EOL]     } [EOL]     Collection collection = constructCollectionType(typeOfT, context); [EOL]     Type childType = new TypeInfoCollection(typeOfT).getElementType(); [EOL]     for (JsonElement childElement : json.getAsJsonArray()) { [EOL]         if (childElement == null || childElement.isJsonNull()) { [EOL]             collection.add(null); [EOL]         } else { [EOL]             Object value = context.deserialize(childElement, childType); [EOL]             collection.add(value); [EOL]         } [EOL]     } [EOL]     return collection; [EOL] }
public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsBigDecimal(); [EOL] }
public BigDecimal deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsBigDecimal(); [EOL] }
@Override [EOL] public String toString() { [EOL]     return BigDecimalTypeAdapter.class.getSimpleName(); [EOL] }
public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src); [EOL] }
public JsonElement serialize(BigInteger src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src); [EOL] }
public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src); [EOL] }
public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src); [EOL] }
public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src); [EOL] }
public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src); [EOL] }
CircularReferenceException(Object offendingNode) { [EOL]     super("circular reference error"); [EOL]     this.offendingNode = offendingNode; [EOL] }
public IllegalStateException createDetailedException(FieldAttributes offendingField) { [EOL]     StringBuilder msg = new StringBuilder(getMessage()); [EOL]     if (offendingField != null) { [EOL]         msg.append("\n  ").append("Offending field: ").append(offendingField.getName() + "\n"); [EOL]     } [EOL]     if (offendingNode != null) { [EOL]         msg.append("\n  ").append("Offending object: ").append(offendingNode); [EOL]     } [EOL]     return new IllegalStateException(msg.toString(), this); [EOL] }
public IllegalStateException createDetailedException(FieldAttributes offendingField) { [EOL]     StringBuilder msg = new StringBuilder(getMessage()); [EOL]     if (offendingField != null) { [EOL]         msg.append("\n  ").append("Offending field: ").append(offendingField.getName() + "\n"); [EOL]     } [EOL]     if (offendingNode != null) { [EOL]         msg.append("\n  ").append("Offending object: ").append(offendingNode); [EOL]     } [EOL]     return new IllegalStateException(msg.toString(), this); [EOL] }
public IllegalStateException createDetailedException(FieldAttributes offendingField) { [EOL]     StringBuilder msg = new StringBuilder(getMessage()); [EOL]     if (offendingField != null) { [EOL]         msg.append("\n  ").append("Offending field: ").append(offendingField.getName() + "\n"); [EOL]     } [EOL]     if (offendingNode != null) { [EOL]         msg.append("\n  ").append("Offending object: ").append(offendingNode); [EOL]     } [EOL]     return new IllegalStateException(msg.toString(), this); [EOL] }
public IllegalStateException createDetailedException(FieldAttributes offendingField) { [EOL]     StringBuilder msg = new StringBuilder(getMessage()); [EOL]     if (offendingField != null) { [EOL]         msg.append("\n  ").append("Offending field: ").append(offendingField.getName() + "\n"); [EOL]     } [EOL]     if (offendingNode != null) { [EOL]         msg.append("\n  ").append("Offending object: ").append(offendingNode); [EOL]     } [EOL]     return new IllegalStateException(msg.toString(), this); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected TypeToken() { [EOL]     this.type = getSuperclassTypeParameter(getClass()); [EOL]     this.rawType = (Class<? super T>) getRawType(type); [EOL] }
static Type getSuperclassTypeParameter(Class<?> subclass) { [EOL]     Type superclass = subclass.getGenericSuperclass(); [EOL]     if (superclass instanceof Class<?>) { [EOL]         throw new RuntimeException("Missing type parameter."); [EOL]     } [EOL]     return ((ParameterizedType) superclass).getActualTypeArguments()[0]; [EOL] }
static Type getSuperclassTypeParameter(Class<?> subclass) { [EOL]     Type superclass = subclass.getGenericSuperclass(); [EOL]     if (superclass instanceof Class<?>) { [EOL]         throw new RuntimeException("Missing type parameter."); [EOL]     } [EOL]     return ((ParameterizedType) superclass).getActualTypeArguments()[0]; [EOL] }
private static Class<?> getRawType(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         ParameterizedType parameterizedType = (ParameterizedType) type; [EOL]         Type rawType = parameterizedType.getRawType(); [EOL]         if (rawType instanceof Class<?>) { [EOL]             return (Class<?>) rawType; [EOL]         } [EOL]         throw buildUnexpectedTypeError(rawType, Class.class); [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         GenericArrayType genericArrayType = (GenericArrayType) type; [EOL]         Object rawArrayType = Array.newInstance(getRawType(genericArrayType.getGenericComponentType()), 0); [EOL]         return rawArrayType.getClass(); [EOL]     } else { [EOL]         throw buildUnexpectedTypeError(type, ParameterizedType.class, GenericArrayType.class); [EOL]     } [EOL] }
private static Class<?> getRawType(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         ParameterizedType parameterizedType = (ParameterizedType) type; [EOL]         Type rawType = parameterizedType.getRawType(); [EOL]         if (rawType instanceof Class<?>) { [EOL]             return (Class<?>) rawType; [EOL]         } [EOL]         throw buildUnexpectedTypeError(rawType, Class.class); [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         GenericArrayType genericArrayType = (GenericArrayType) type; [EOL]         Object rawArrayType = Array.newInstance(getRawType(genericArrayType.getGenericComponentType()), 0); [EOL]         return rawArrayType.getClass(); [EOL]     } else { [EOL]         throw buildUnexpectedTypeError(type, ParameterizedType.class, GenericArrayType.class); [EOL]     } [EOL] }
private static Class<?> getRawType(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         ParameterizedType parameterizedType = (ParameterizedType) type; [EOL]         Type rawType = parameterizedType.getRawType(); [EOL]         if (rawType instanceof Class<?>) { [EOL]             return (Class<?>) rawType; [EOL]         } [EOL]         throw buildUnexpectedTypeError(rawType, Class.class); [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         GenericArrayType genericArrayType = (GenericArrayType) type; [EOL]         Object rawArrayType = Array.newInstance(getRawType(genericArrayType.getGenericComponentType()), 0); [EOL]         return rawArrayType.getClass(); [EOL]     } else { [EOL]         throw buildUnexpectedTypeError(type, ParameterizedType.class, GenericArrayType.class); [EOL]     } [EOL] }
private static Class<?> getRawType(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         ParameterizedType parameterizedType = (ParameterizedType) type; [EOL]         Type rawType = parameterizedType.getRawType(); [EOL]         if (rawType instanceof Class<?>) { [EOL]             return (Class<?>) rawType; [EOL]         } [EOL]         throw buildUnexpectedTypeError(rawType, Class.class); [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         GenericArrayType genericArrayType = (GenericArrayType) type; [EOL]         Object rawArrayType = Array.newInstance(getRawType(genericArrayType.getGenericComponentType()), 0); [EOL]         return rawArrayType.getClass(); [EOL]     } else { [EOL]         throw buildUnexpectedTypeError(type, ParameterizedType.class, GenericArrayType.class); [EOL]     } [EOL] }
public Type getType() { [EOL]     return type; [EOL] }
public TypeInfoMap(Type mapType) { [EOL]     if (mapType instanceof Class<?> && Properties.class.isAssignableFrom((Class<?>) mapType)) { [EOL]         keyType = String.class; [EOL]         valueType = String.class; [EOL]     } else if (mapType instanceof ParameterizedType) { [EOL]         TypeInfo rawType = new TypeInfo(mapType); [EOL]         Preconditions.checkArgument(Map.class.isAssignableFrom(rawType.getRawClass())); [EOL]         ParameterizedType paramType = (ParameterizedType) mapType; [EOL]         keyType = paramType.getActualTypeArguments()[0]; [EOL]         valueType = paramType.getActualTypeArguments()[1]; [EOL]     } else { [EOL]         throw new IllegalArgumentException("Map objects need to be parameterized unless you use a custom serializer. " + "Use the com.google.gson.reflect.TypeToken to extract the ParameterizedType."); [EOL]     } [EOL] }
public TypeInfoMap(Type mapType) { [EOL]     if (mapType instanceof Class<?> && Properties.class.isAssignableFrom((Class<?>) mapType)) { [EOL]         keyType = String.class; [EOL]         valueType = String.class; [EOL]     } else if (mapType instanceof ParameterizedType) { [EOL]         TypeInfo rawType = new TypeInfo(mapType); [EOL]         Preconditions.checkArgument(Map.class.isAssignableFrom(rawType.getRawClass())); [EOL]         ParameterizedType paramType = (ParameterizedType) mapType; [EOL]         keyType = paramType.getActualTypeArguments()[0]; [EOL]         valueType = paramType.getActualTypeArguments()[1]; [EOL]     } else { [EOL]         throw new IllegalArgumentException("Map objects need to be parameterized unless you use a custom serializer. " + "Use the com.google.gson.reflect.TypeToken to extract the ParameterizedType."); [EOL]     } [EOL] }
public TypeInfoMap(Type mapType) { [EOL]     if (mapType instanceof Class<?> && Properties.class.isAssignableFrom((Class<?>) mapType)) { [EOL]         keyType = String.class; [EOL]         valueType = String.class; [EOL]     } else if (mapType instanceof ParameterizedType) { [EOL]         TypeInfo rawType = new TypeInfo(mapType); [EOL]         Preconditions.checkArgument(Map.class.isAssignableFrom(rawType.getRawClass())); [EOL]         ParameterizedType paramType = (ParameterizedType) mapType; [EOL]         keyType = paramType.getActualTypeArguments()[0]; [EOL]         valueType = paramType.getActualTypeArguments()[1]; [EOL]     } else { [EOL]         throw new IllegalArgumentException("Map objects need to be parameterized unless you use a custom serializer. " + "Use the com.google.gson.reflect.TypeToken to extract the ParameterizedType."); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
public static void checkArgument(boolean condition) { [EOL]     if (!condition) { [EOL]         throw new IllegalArgumentException("condition failed: " + condition); [EOL]     } [EOL] }
public static void checkArgument(boolean condition) { [EOL]     if (!condition) { [EOL]         throw new IllegalArgumentException("condition failed: " + condition); [EOL]     } [EOL] }
public static void checkState(boolean condition) { [EOL]     if (!condition) { [EOL]         throw new IllegalArgumentException("condition failed: " + condition); [EOL]     } [EOL] }
public static void checkState(boolean condition) { [EOL]     if (!condition) { [EOL]         throw new IllegalArgumentException("condition failed: " + condition); [EOL]     } [EOL] }
@Override [EOL] public BigInteger getAsBigInteger() { [EOL]     if (elements.size() == 1) { [EOL]         return elements.get(0).getAsBigInteger(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
@Override [EOL] public BigInteger getAsBigInteger() { [EOL]     if (elements.size() == 1) { [EOL]         return elements.get(0).getAsBigInteger(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public JsonStreamParser(Reader reader) { [EOL]     parser = new JsonReader(reader); [EOL]     parser.setLenient(true); [EOL]     lock = new Object(); [EOL] }
public JsonStreamParser(Reader reader) { [EOL]     parser = new JsonReader(reader); [EOL]     parser.setLenient(true); [EOL]     lock = new Object(); [EOL] }
public synchronized void register(Type typeOfT, T value) { [EOL]     if (!modifiable) { [EOL]         throw new IllegalStateException("Attempted to modify an unmodifiable map."); [EOL]     } [EOL]     if (hasSpecificHandlerFor(typeOfT)) { [EOL]         logger.log(Level.WARNING, "Overriding the existing type handler for {0}", typeOfT); [EOL]     } [EOL]     map.put(typeOfT, value); [EOL] }
public synchronized void register(Type typeOfT, T value) { [EOL]     if (!modifiable) { [EOL]         throw new IllegalStateException("Attempted to modify an unmodifiable map."); [EOL]     } [EOL]     if (hasSpecificHandlerFor(typeOfT)) { [EOL]         logger.log(Level.WARNING, "Overriding the existing type handler for {0}", typeOfT); [EOL]     } [EOL]     map.put(typeOfT, value); [EOL] }
public synchronized void register(Type typeOfT, T value) { [EOL]     if (!modifiable) { [EOL]         throw new IllegalStateException("Attempted to modify an unmodifiable map."); [EOL]     } [EOL]     if (hasSpecificHandlerFor(typeOfT)) { [EOL]         logger.log(Level.WARNING, "Overriding the existing type handler for {0}", typeOfT); [EOL]     } [EOL]     map.put(typeOfT, value); [EOL] }
public synchronized void makeUnmodifiable() { [EOL]     modifiable = false; [EOL] }
static Class<?> toRawClass(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         ParameterizedType actualType = (ParameterizedType) type; [EOL]         return toRawClass(actualType.getRawType()); [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         GenericArrayType actualType = (GenericArrayType) type; [EOL]         Class<?> rawClass = toRawClass(actualType.getGenericComponentType()); [EOL]         return wrapWithArray(rawClass); [EOL]     } else if (type instanceof WildcardType) { [EOL]         WildcardType castedType = (WildcardType) type; [EOL]         return toRawClass(castedType.getUpperBounds()[0]); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + type + "\' is not a Class, " + "ParameterizedType, or GenericArrayType. Can't extract class."); [EOL]     } [EOL] }
static Class<?> toRawClass(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         ParameterizedType actualType = (ParameterizedType) type; [EOL]         return toRawClass(actualType.getRawType()); [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         GenericArrayType actualType = (GenericArrayType) type; [EOL]         Class<?> rawClass = toRawClass(actualType.getGenericComponentType()); [EOL]         return wrapWithArray(rawClass); [EOL]     } else if (type instanceof WildcardType) { [EOL]         WildcardType castedType = (WildcardType) type; [EOL]         return toRawClass(castedType.getUpperBounds()[0]); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + type + "\' is not a Class, " + "ParameterizedType, or GenericArrayType. Can't extract class."); [EOL]     } [EOL] }
static Class<?> toRawClass(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         ParameterizedType actualType = (ParameterizedType) type; [EOL]         return toRawClass(actualType.getRawType()); [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         GenericArrayType actualType = (GenericArrayType) type; [EOL]         Class<?> rawClass = toRawClass(actualType.getGenericComponentType()); [EOL]         return wrapWithArray(rawClass); [EOL]     } else if (type instanceof WildcardType) { [EOL]         WildcardType castedType = (WildcardType) type; [EOL]         return toRawClass(castedType.getUpperBounds()[0]); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + type + "\' is not a Class, " + "ParameterizedType, or GenericArrayType. Can't extract class."); [EOL]     } [EOL] }
static Class<?> toRawClass(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         ParameterizedType actualType = (ParameterizedType) type; [EOL]         return toRawClass(actualType.getRawType()); [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         GenericArrayType actualType = (GenericArrayType) type; [EOL]         Class<?> rawClass = toRawClass(actualType.getGenericComponentType()); [EOL]         return wrapWithArray(rawClass); [EOL]     } else if (type instanceof WildcardType) { [EOL]         WildcardType castedType = (WildcardType) type; [EOL]         return toRawClass(castedType.getUpperBounds()[0]); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + type + "\' is not a Class, " + "ParameterizedType, or GenericArrayType. Can't extract class."); [EOL]     } [EOL] }
static Class<?> toRawClass(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return (Class<?>) type; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         ParameterizedType actualType = (ParameterizedType) type; [EOL]         return toRawClass(actualType.getRawType()); [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         GenericArrayType actualType = (GenericArrayType) type; [EOL]         Class<?> rawClass = toRawClass(actualType.getGenericComponentType()); [EOL]         return wrapWithArray(rawClass); [EOL]     } else if (type instanceof WildcardType) { [EOL]         WildcardType castedType = (WildcardType) type; [EOL]         return toRawClass(castedType.getUpperBounds()[0]); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + type + "\' is not a Class, " + "ParameterizedType, or GenericArrayType. Can't extract class."); [EOL]     } [EOL] }
public final String translateName(FieldAttributes f) { [EOL]     Preconditions.checkNotNull(f); [EOL]     return translateName(f.getName(), f.getDeclaredType(), f.getAnnotations()); [EOL] }
public final String translateName(FieldAttributes f) { [EOL]     Preconditions.checkNotNull(f); [EOL]     return translateName(f.getName(), f.getDeclaredType(), f.getAnnotations()); [EOL] }
public Gson() { [EOL]     this(DEFAULT_EXCLUSION_STRATEGY, DEFAULT_EXCLUSION_STRATEGY, DEFAULT_NAMING_POLICY, new MappedObjectConstructor(DefaultTypeAdapters.getDefaultInstanceCreators()), false, DefaultTypeAdapters.getDefaultSerializers(), DefaultTypeAdapters.getDefaultDeserializers(), DEFAULT_JSON_NON_EXECUTABLE, true, false); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public Gson() { [EOL]     this(DEFAULT_EXCLUSION_STRATEGY, DEFAULT_EXCLUSION_STRATEGY, DEFAULT_NAMING_POLICY, new MappedObjectConstructor(DefaultTypeAdapters.getDefaultInstanceCreators()), false, DefaultTypeAdapters.getDefaultSerializers(), DefaultTypeAdapters.getDefaultDeserializers(), DEFAULT_JSON_NON_EXECUTABLE, true, false); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public Gson() { [EOL]     this(DEFAULT_EXCLUSION_STRATEGY, DEFAULT_EXCLUSION_STRATEGY, DEFAULT_NAMING_POLICY, new MappedObjectConstructor(DefaultTypeAdapters.getDefaultInstanceCreators()), false, DefaultTypeAdapters.getDefaultSerializers(), DefaultTypeAdapters.getDefaultDeserializers(), DEFAULT_JSON_NON_EXECUTABLE, true, false); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public <T> T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException { [EOL]     Object object = fromJson(json, (Type) classOfT); [EOL]     return Primitives.wrap(classOfT).cast(object); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public <T> T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException { [EOL]     Object object = fromJson(json, (Type) classOfT); [EOL]     return Primitives.wrap(classOfT).cast(object); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public <T> T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException { [EOL]     Object object = fromJson(json, (Type) classOfT); [EOL]     return Primitives.wrap(classOfT).cast(object); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public static boolean isWrapperType(Class<?> type) { [EOL]     return WRAPPER_TO_PRIMITIVE_TYPE.containsKey(checkNotNull(type)); [EOL] }
public T deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     try { [EOL]         return delegate.deserialize(json, typeOfT, context); [EOL]     } catch (JsonParseException e) { [EOL]         throw e; [EOL]     } catch (Exception e) { [EOL]         StringBuilder errorMsg = new StringBuilder().append("The JsonDeserializer ").append(delegate).append(" failed to deserialized json object ").append(json).append(" given the type ").append(typeOfT); [EOL]         throw new JsonParseException(errorMsg.toString(), e); [EOL]     } [EOL] }
public T deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     try { [EOL]         return delegate.deserialize(json, typeOfT, context); [EOL]     } catch (JsonParseException e) { [EOL]         throw e; [EOL]     } catch (Exception e) { [EOL]         StringBuilder errorMsg = new StringBuilder().append("The JsonDeserializer ").append(delegate).append(" failed to deserialized json object ").append(json).append(" given the type ").append(typeOfT); [EOL]         throw new JsonParseException(errorMsg.toString(), e); [EOL]     } [EOL] }
public JsonParseException(String msg, Throwable cause) { [EOL]     super(msg, cause); [EOL] }
public boolean shouldSkipClass(Class<?> clazz) { [EOL]     return false; [EOL] }
public ModifyFirstLetterNamingPolicy(LetterModifier modifier) { [EOL]     Preconditions.checkNotNull(modifier); [EOL]     this.letterModifier = modifier; [EOL] }
public ModifyFirstLetterNamingPolicy(LetterModifier modifier) { [EOL]     Preconditions.checkNotNull(modifier); [EOL]     this.letterModifier = modifier; [EOL] }
@Override [EOL] protected String translateName(String target, Type fieldType, Collection<Annotation> annotations) { [EOL]     StringBuilder fieldNameBuilder = new StringBuilder(); [EOL]     int index = 0; [EOL]     char firstCharacter = target.charAt(index); [EOL]     while (index < target.length() - 1) { [EOL]         if (Character.isLetter(firstCharacter)) { [EOL]             break; [EOL]         } [EOL]         fieldNameBuilder.append(firstCharacter); [EOL]         firstCharacter = target.charAt(++index); [EOL]     } [EOL]     if (index == target.length()) { [EOL]         return fieldNameBuilder.toString(); [EOL]     } [EOL]     boolean capitalizeFirstLetter = (letterModifier == LetterModifier.UPPER); [EOL]     if (capitalizeFirstLetter && !Character.isUpperCase(firstCharacter)) { [EOL]         String modifiedTarget = modifyString(Character.toUpperCase(firstCharacter), target, ++index); [EOL]         return fieldNameBuilder.append(modifiedTarget).toString(); [EOL]     } else if (!capitalizeFirstLetter && Character.isUpperCase(firstCharacter)) { [EOL]         String modifiedTarget = modifyString(Character.toLowerCase(firstCharacter), target, ++index); [EOL]         return fieldNameBuilder.append(modifiedTarget).toString(); [EOL]     } else { [EOL]         return target; [EOL]     } [EOL] }
@Override [EOL] protected String translateName(String target, Type fieldType, Collection<Annotation> annotations) { [EOL]     StringBuilder fieldNameBuilder = new StringBuilder(); [EOL]     int index = 0; [EOL]     char firstCharacter = target.charAt(index); [EOL]     while (index < target.length() - 1) { [EOL]         if (Character.isLetter(firstCharacter)) { [EOL]             break; [EOL]         } [EOL]         fieldNameBuilder.append(firstCharacter); [EOL]         firstCharacter = target.charAt(++index); [EOL]     } [EOL]     if (index == target.length()) { [EOL]         return fieldNameBuilder.toString(); [EOL]     } [EOL]     boolean capitalizeFirstLetter = (letterModifier == LetterModifier.UPPER); [EOL]     if (capitalizeFirstLetter && !Character.isUpperCase(firstCharacter)) { [EOL]         String modifiedTarget = modifyString(Character.toUpperCase(firstCharacter), target, ++index); [EOL]         return fieldNameBuilder.append(modifiedTarget).toString(); [EOL]     } else if (!capitalizeFirstLetter && Character.isUpperCase(firstCharacter)) { [EOL]         String modifiedTarget = modifyString(Character.toLowerCase(firstCharacter), target, ++index); [EOL]         return fieldNameBuilder.append(modifiedTarget).toString(); [EOL]     } else { [EOL]         return target; [EOL]     } [EOL] }
@Override [EOL] protected String translateName(String target, Type fieldType, Collection<Annotation> annotations) { [EOL]     StringBuilder fieldNameBuilder = new StringBuilder(); [EOL]     int index = 0; [EOL]     char firstCharacter = target.charAt(index); [EOL]     while (index < target.length() - 1) { [EOL]         if (Character.isLetter(firstCharacter)) { [EOL]             break; [EOL]         } [EOL]         fieldNameBuilder.append(firstCharacter); [EOL]         firstCharacter = target.charAt(++index); [EOL]     } [EOL]     if (index == target.length()) { [EOL]         return fieldNameBuilder.toString(); [EOL]     } [EOL]     boolean capitalizeFirstLetter = (letterModifier == LetterModifier.UPPER); [EOL]     if (capitalizeFirstLetter && !Character.isUpperCase(firstCharacter)) { [EOL]         String modifiedTarget = modifyString(Character.toUpperCase(firstCharacter), target, ++index); [EOL]         return fieldNameBuilder.append(modifiedTarget).toString(); [EOL]     } else if (!capitalizeFirstLetter && Character.isUpperCase(firstCharacter)) { [EOL]         String modifiedTarget = modifyString(Character.toLowerCase(firstCharacter), target, ++index); [EOL]         return fieldNameBuilder.append(modifiedTarget).toString(); [EOL]     } else { [EOL]         return target; [EOL]     } [EOL] }
@Override [EOL] protected String translateName(String target, Type fieldType, Collection<Annotation> annotations) { [EOL]     StringBuilder fieldNameBuilder = new StringBuilder(); [EOL]     int index = 0; [EOL]     char firstCharacter = target.charAt(index); [EOL]     while (index < target.length() - 1) { [EOL]         if (Character.isLetter(firstCharacter)) { [EOL]             break; [EOL]         } [EOL]         fieldNameBuilder.append(firstCharacter); [EOL]         firstCharacter = target.charAt(++index); [EOL]     } [EOL]     if (index == target.length()) { [EOL]         return fieldNameBuilder.toString(); [EOL]     } [EOL]     boolean capitalizeFirstLetter = (letterModifier == LetterModifier.UPPER); [EOL]     if (capitalizeFirstLetter && !Character.isUpperCase(firstCharacter)) { [EOL]         String modifiedTarget = modifyString(Character.toUpperCase(firstCharacter), target, ++index); [EOL]         return fieldNameBuilder.append(modifiedTarget).toString(); [EOL]     } else if (!capitalizeFirstLetter && Character.isUpperCase(firstCharacter)) { [EOL]         String modifiedTarget = modifyString(Character.toLowerCase(firstCharacter), target, ++index); [EOL]         return fieldNameBuilder.append(modifiedTarget).toString(); [EOL]     } else { [EOL]         return target; [EOL]     } [EOL] }
@Override [EOL] protected String translateName(String target, Type fieldType, Collection<Annotation> annotations) { [EOL]     StringBuilder fieldNameBuilder = new StringBuilder(); [EOL]     int index = 0; [EOL]     char firstCharacter = target.charAt(index); [EOL]     while (index < target.length() - 1) { [EOL]         if (Character.isLetter(firstCharacter)) { [EOL]             break; [EOL]         } [EOL]         fieldNameBuilder.append(firstCharacter); [EOL]         firstCharacter = target.charAt(++index); [EOL]     } [EOL]     if (index == target.length()) { [EOL]         return fieldNameBuilder.toString(); [EOL]     } [EOL]     boolean capitalizeFirstLetter = (letterModifier == LetterModifier.UPPER); [EOL]     if (capitalizeFirstLetter && !Character.isUpperCase(firstCharacter)) { [EOL]         String modifiedTarget = modifyString(Character.toUpperCase(firstCharacter), target, ++index); [EOL]         return fieldNameBuilder.append(modifiedTarget).toString(); [EOL]     } else if (!capitalizeFirstLetter && Character.isUpperCase(firstCharacter)) { [EOL]         String modifiedTarget = modifyString(Character.toLowerCase(firstCharacter), target, ++index); [EOL]         return fieldNameBuilder.append(modifiedTarget).toString(); [EOL]     } else { [EOL]         return target; [EOL]     } [EOL] }
private String modifyString(char firstCharacter, String srcString, int indexOfSubstring) { [EOL]     return indexOfSubstring < srcString.length() ? firstCharacter + srcString.substring(indexOfSubstring) : String.valueOf(firstCharacter); [EOL] }
private String modifyString(char firstCharacter, String srcString, int indexOfSubstring) { [EOL]     return indexOfSubstring < srcString.length() ? firstCharacter + srcString.substring(indexOfSubstring) : String.valueOf(firstCharacter); [EOL] }
private String modifyString(char firstCharacter, String srcString, int indexOfSubstring) { [EOL]     return indexOfSubstring < srcString.length() ? firstCharacter + srcString.substring(indexOfSubstring) : String.valueOf(firstCharacter); [EOL] }
private String modifyString(char firstCharacter, String srcString, int indexOfSubstring) { [EOL]     return indexOfSubstring < srcString.length() ? firstCharacter + srcString.substring(indexOfSubstring) : String.valueOf(firstCharacter); [EOL] }
public MappedObjectConstructor(ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators) { [EOL]     instanceCreatorMap = instanceCreators; [EOL] }
public MappedObjectConstructor(ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators) { [EOL]     instanceCreatorMap = instanceCreators; [EOL] }
public void accept(Visitor visitor) { [EOL]     TypeInfo objTypeInfo = new TypeInfo(objTypePair.type); [EOL]     if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) { [EOL]         return; [EOL]     } [EOL]     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair); [EOL]     if (!visitedWithCustomHandler) { [EOL]         Object obj = objTypePair.getObject(); [EOL]         Object objectToVisit = (obj == null) ? visitor.getTarget() : obj; [EOL]         if (objectToVisit == null) { [EOL]             return; [EOL]         } [EOL]         objTypePair.setObject(objectToVisit); [EOL]         visitor.start(objTypePair); [EOL]         try { [EOL]             if (objTypeInfo.isArray()) { [EOL]                 visitor.visitArray(objectToVisit, objTypePair.type); [EOL]             } else if (objTypeInfo.getActualType() == Object.class && isPrimitiveOrString(objectToVisit)) { [EOL]                 visitor.visitPrimitive(objectToVisit); [EOL]                 objectToVisit = visitor.getTarget(); [EOL]             } else { [EOL]                 visitor.startVisitingObject(objectToVisit); [EOL]                 ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType(); [EOL]                 Class<?> topLevelClass = new TypeInfo(currObjTypePair.type).getRawClass(); [EOL]                 for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr = curr.getSuperclass()) { [EOL]                     if (!curr.isSynthetic()) { [EOL]                         navigateClassFields(objectToVisit, curr, visitor); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } finally { [EOL]             visitor.end(objTypePair); [EOL]         } [EOL]     } [EOL] }
public void accept(Visitor visitor) { [EOL]     TypeInfo objTypeInfo = new TypeInfo(objTypePair.type); [EOL]     if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) { [EOL]         return; [EOL]     } [EOL]     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair); [EOL]     if (!visitedWithCustomHandler) { [EOL]         Object obj = objTypePair.getObject(); [EOL]         Object objectToVisit = (obj == null) ? visitor.getTarget() : obj; [EOL]         if (objectToVisit == null) { [EOL]             return; [EOL]         } [EOL]         objTypePair.setObject(objectToVisit); [EOL]         visitor.start(objTypePair); [EOL]         try { [EOL]             if (objTypeInfo.isArray()) { [EOL]                 visitor.visitArray(objectToVisit, objTypePair.type); [EOL]             } else if (objTypeInfo.getActualType() == Object.class && isPrimitiveOrString(objectToVisit)) { [EOL]                 visitor.visitPrimitive(objectToVisit); [EOL]                 objectToVisit = visitor.getTarget(); [EOL]             } else { [EOL]                 visitor.startVisitingObject(objectToVisit); [EOL]                 ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType(); [EOL]                 Class<?> topLevelClass = new TypeInfo(currObjTypePair.type).getRawClass(); [EOL]                 for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr = curr.getSuperclass()) { [EOL]                     if (!curr.isSynthetic()) { [EOL]                         navigateClassFields(objectToVisit, curr, visitor); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } finally { [EOL]             visitor.end(objTypePair); [EOL]         } [EOL]     } [EOL] }
public void accept(Visitor visitor) { [EOL]     TypeInfo objTypeInfo = new TypeInfo(objTypePair.type); [EOL]     if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) { [EOL]         return; [EOL]     } [EOL]     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair); [EOL]     if (!visitedWithCustomHandler) { [EOL]         Object obj = objTypePair.getObject(); [EOL]         Object objectToVisit = (obj == null) ? visitor.getTarget() : obj; [EOL]         if (objectToVisit == null) { [EOL]             return; [EOL]         } [EOL]         objTypePair.setObject(objectToVisit); [EOL]         visitor.start(objTypePair); [EOL]         try { [EOL]             if (objTypeInfo.isArray()) { [EOL]                 visitor.visitArray(objectToVisit, objTypePair.type); [EOL]             } else if (objTypeInfo.getActualType() == Object.class && isPrimitiveOrString(objectToVisit)) { [EOL]                 visitor.visitPrimitive(objectToVisit); [EOL]                 objectToVisit = visitor.getTarget(); [EOL]             } else { [EOL]                 visitor.startVisitingObject(objectToVisit); [EOL]                 ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType(); [EOL]                 Class<?> topLevelClass = new TypeInfo(currObjTypePair.type).getRawClass(); [EOL]                 for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr = curr.getSuperclass()) { [EOL]                     if (!curr.isSynthetic()) { [EOL]                         navigateClassFields(objectToVisit, curr, visitor); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } finally { [EOL]             visitor.end(objTypePair); [EOL]         } [EOL]     } [EOL] }
public void accept(Visitor visitor) { [EOL]     TypeInfo objTypeInfo = new TypeInfo(objTypePair.type); [EOL]     if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) { [EOL]         return; [EOL]     } [EOL]     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair); [EOL]     if (!visitedWithCustomHandler) { [EOL]         Object obj = objTypePair.getObject(); [EOL]         Object objectToVisit = (obj == null) ? visitor.getTarget() : obj; [EOL]         if (objectToVisit == null) { [EOL]             return; [EOL]         } [EOL]         objTypePair.setObject(objectToVisit); [EOL]         visitor.start(objTypePair); [EOL]         try { [EOL]             if (objTypeInfo.isArray()) { [EOL]                 visitor.visitArray(objectToVisit, objTypePair.type); [EOL]             } else if (objTypeInfo.getActualType() == Object.class && isPrimitiveOrString(objectToVisit)) { [EOL]                 visitor.visitPrimitive(objectToVisit); [EOL]                 objectToVisit = visitor.getTarget(); [EOL]             } else { [EOL]                 visitor.startVisitingObject(objectToVisit); [EOL]                 ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType(); [EOL]                 Class<?> topLevelClass = new TypeInfo(currObjTypePair.type).getRawClass(); [EOL]                 for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr = curr.getSuperclass()) { [EOL]                     if (!curr.isSynthetic()) { [EOL]                         navigateClassFields(objectToVisit, curr, visitor); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } finally { [EOL]             visitor.end(objTypePair); [EOL]         } [EOL]     } [EOL] }
public void accept(Visitor visitor) { [EOL]     TypeInfo objTypeInfo = new TypeInfo(objTypePair.type); [EOL]     if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) { [EOL]         return; [EOL]     } [EOL]     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair); [EOL]     if (!visitedWithCustomHandler) { [EOL]         Object obj = objTypePair.getObject(); [EOL]         Object objectToVisit = (obj == null) ? visitor.getTarget() : obj; [EOL]         if (objectToVisit == null) { [EOL]             return; [EOL]         } [EOL]         objTypePair.setObject(objectToVisit); [EOL]         visitor.start(objTypePair); [EOL]         try { [EOL]             if (objTypeInfo.isArray()) { [EOL]                 visitor.visitArray(objectToVisit, objTypePair.type); [EOL]             } else if (objTypeInfo.getActualType() == Object.class && isPrimitiveOrString(objectToVisit)) { [EOL]                 visitor.visitPrimitive(objectToVisit); [EOL]                 objectToVisit = visitor.getTarget(); [EOL]             } else { [EOL]                 visitor.startVisitingObject(objectToVisit); [EOL]                 ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType(); [EOL]                 Class<?> topLevelClass = new TypeInfo(currObjTypePair.type).getRawClass(); [EOL]                 for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr = curr.getSuperclass()) { [EOL]                     if (!curr.isSynthetic()) { [EOL]                         navigateClassFields(objectToVisit, curr, visitor); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } finally { [EOL]             visitor.end(objTypePair); [EOL]         } [EOL]     } [EOL] }
public void accept(Visitor visitor) { [EOL]     TypeInfo objTypeInfo = new TypeInfo(objTypePair.type); [EOL]     if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) { [EOL]         return; [EOL]     } [EOL]     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair); [EOL]     if (!visitedWithCustomHandler) { [EOL]         Object obj = objTypePair.getObject(); [EOL]         Object objectToVisit = (obj == null) ? visitor.getTarget() : obj; [EOL]         if (objectToVisit == null) { [EOL]             return; [EOL]         } [EOL]         objTypePair.setObject(objectToVisit); [EOL]         visitor.start(objTypePair); [EOL]         try { [EOL]             if (objTypeInfo.isArray()) { [EOL]                 visitor.visitArray(objectToVisit, objTypePair.type); [EOL]             } else if (objTypeInfo.getActualType() == Object.class && isPrimitiveOrString(objectToVisit)) { [EOL]                 visitor.visitPrimitive(objectToVisit); [EOL]                 objectToVisit = visitor.getTarget(); [EOL]             } else { [EOL]                 visitor.startVisitingObject(objectToVisit); [EOL]                 ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType(); [EOL]                 Class<?> topLevelClass = new TypeInfo(currObjTypePair.type).getRawClass(); [EOL]                 for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr = curr.getSuperclass()) { [EOL]                     if (!curr.isSynthetic()) { [EOL]                         navigateClassFields(objectToVisit, curr, visitor); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } finally { [EOL]             visitor.end(objTypePair); [EOL]         } [EOL]     } [EOL] }
private void navigateClassFields(Object obj, Class<?> clazz, Visitor visitor) { [EOL]     Field[] fields = clazz.getDeclaredFields(); [EOL]     AccessibleObject.setAccessible(fields, true); [EOL]     for (Field f : fields) { [EOL]         FieldAttributes fieldAttributes = new FieldAttributes(clazz, f); [EOL]         if (exclusionStrategy.shouldSkipField(fieldAttributes) || exclusionStrategy.shouldSkipClass(fieldAttributes.getDeclaredClass())) { [EOL]             continue; [EOL]         } [EOL]         TypeInfo fieldTypeInfo = TypeInfoFactory.getTypeInfoForField(f, objTypePair.type); [EOL]         Type declaredTypeOfField = fieldTypeInfo.getActualType(); [EOL]         boolean visitedWithCustomHandler = visitor.visitFieldUsingCustomHandler(fieldAttributes, declaredTypeOfField, obj); [EOL]         if (!visitedWithCustomHandler) { [EOL]             if (fieldTypeInfo.isArray()) { [EOL]                 visitor.visitArrayField(fieldAttributes, declaredTypeOfField, obj); [EOL]             } else { [EOL]                 visitor.visitObjectField(fieldAttributes, declaredTypeOfField, obj); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void navigateClassFields(Object obj, Class<?> clazz, Visitor visitor) { [EOL]     Field[] fields = clazz.getDeclaredFields(); [EOL]     AccessibleObject.setAccessible(fields, true); [EOL]     for (Field f : fields) { [EOL]         FieldAttributes fieldAttributes = new FieldAttributes(clazz, f); [EOL]         if (exclusionStrategy.shouldSkipField(fieldAttributes) || exclusionStrategy.shouldSkipClass(fieldAttributes.getDeclaredClass())) { [EOL]             continue; [EOL]         } [EOL]         TypeInfo fieldTypeInfo = TypeInfoFactory.getTypeInfoForField(f, objTypePair.type); [EOL]         Type declaredTypeOfField = fieldTypeInfo.getActualType(); [EOL]         boolean visitedWithCustomHandler = visitor.visitFieldUsingCustomHandler(fieldAttributes, declaredTypeOfField, obj); [EOL]         if (!visitedWithCustomHandler) { [EOL]             if (fieldTypeInfo.isArray()) { [EOL]                 visitor.visitArrayField(fieldAttributes, declaredTypeOfField, obj); [EOL]             } else { [EOL]                 visitor.visitObjectField(fieldAttributes, declaredTypeOfField, obj); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void navigateClassFields(Object obj, Class<?> clazz, Visitor visitor) { [EOL]     Field[] fields = clazz.getDeclaredFields(); [EOL]     AccessibleObject.setAccessible(fields, true); [EOL]     for (Field f : fields) { [EOL]         FieldAttributes fieldAttributes = new FieldAttributes(clazz, f); [EOL]         if (exclusionStrategy.shouldSkipField(fieldAttributes) || exclusionStrategy.shouldSkipClass(fieldAttributes.getDeclaredClass())) { [EOL]             continue; [EOL]         } [EOL]         TypeInfo fieldTypeInfo = TypeInfoFactory.getTypeInfoForField(f, objTypePair.type); [EOL]         Type declaredTypeOfField = fieldTypeInfo.getActualType(); [EOL]         boolean visitedWithCustomHandler = visitor.visitFieldUsingCustomHandler(fieldAttributes, declaredTypeOfField, obj); [EOL]         if (!visitedWithCustomHandler) { [EOL]             if (fieldTypeInfo.isArray()) { [EOL]                 visitor.visitArrayField(fieldAttributes, declaredTypeOfField, obj); [EOL]             } else { [EOL]                 visitor.visitObjectField(fieldAttributes, declaredTypeOfField, obj); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void navigateClassFields(Object obj, Class<?> clazz, Visitor visitor) { [EOL]     Field[] fields = clazz.getDeclaredFields(); [EOL]     AccessibleObject.setAccessible(fields, true); [EOL]     for (Field f : fields) { [EOL]         FieldAttributes fieldAttributes = new FieldAttributes(clazz, f); [EOL]         if (exclusionStrategy.shouldSkipField(fieldAttributes) || exclusionStrategy.shouldSkipClass(fieldAttributes.getDeclaredClass())) { [EOL]             continue; [EOL]         } [EOL]         TypeInfo fieldTypeInfo = TypeInfoFactory.getTypeInfoForField(f, objTypePair.type); [EOL]         Type declaredTypeOfField = fieldTypeInfo.getActualType(); [EOL]         boolean visitedWithCustomHandler = visitor.visitFieldUsingCustomHandler(fieldAttributes, declaredTypeOfField, obj); [EOL]         if (!visitedWithCustomHandler) { [EOL]             if (fieldTypeInfo.isArray()) { [EOL]                 visitor.visitArrayField(fieldAttributes, declaredTypeOfField, obj); [EOL]             } else { [EOL]                 visitor.visitObjectField(fieldAttributes, declaredTypeOfField, obj); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public GsonBuilder serializeNulls() { [EOL]     this.serializeNulls = true; [EOL]     return this; [EOL] }
public GsonBuilder setExclusionStrategies(ExclusionStrategy... strategies) { [EOL]     for (ExclusionStrategy strategy : strategies) { [EOL]         exclusionStrategies.add(strategy); [EOL]     } [EOL]     return this; [EOL] }
public final boolean isPrimitive() { [EOL]     return Primitives.isWrapperType(Primitives.wrap(rawClass)); [EOL] }
public final boolean isPrimitive() { [EOL]     return Primitives.isWrapperType(Primitives.wrap(rawClass)); [EOL] }
public final boolean isPrimitive() { [EOL]     return Primitives.isWrapperType(Primitives.wrap(rawClass)); [EOL] }
public boolean contains(ObjectTypePair obj) { [EOL]     if (obj == null) { [EOL]         return false; [EOL]     } [EOL]     for (ObjectTypePair stackObject : stack) { [EOL]         if (stackObject.getObject() == obj.getObject() && stackObject.type.equals(obj.type)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean contains(ObjectTypePair obj) { [EOL]     if (obj == null) { [EOL]         return false; [EOL]     } [EOL]     for (ObjectTypePair stackObject : stack) { [EOL]         if (stackObject.getObject() == obj.getObject() && stackObject.type.equals(obj.type)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean contains(ObjectTypePair obj) { [EOL]     if (obj == null) { [EOL]         return false; [EOL]     } [EOL]     for (ObjectTypePair stackObject : stack) { [EOL]         if (stackObject.getObject() == obj.getObject() && stackObject.type.equals(obj.type)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
FieldAttributes(final Class<?> declaringClazz, final Field f) { [EOL]     Preconditions.checkNotNull(declaringClazz); [EOL]     this.declaringClazz = declaringClazz; [EOL]     name = f.getName(); [EOL]     declaredType = f.getType(); [EOL]     isSynthetic = f.isSynthetic(); [EOL]     modifiers = f.getModifiers(); [EOL]     field = f; [EOL] }
FieldAttributes(final Class<?> declaringClazz, final Field f) { [EOL]     Preconditions.checkNotNull(declaringClazz); [EOL]     this.declaringClazz = declaringClazz; [EOL]     name = f.getName(); [EOL]     declaredType = f.getType(); [EOL]     isSynthetic = f.isSynthetic(); [EOL]     modifiers = f.getModifiers(); [EOL]     field = f; [EOL] }
FieldAttributes(final Class<?> declaringClazz, final Field f) { [EOL]     Preconditions.checkNotNull(declaringClazz); [EOL]     this.declaringClazz = declaringClazz; [EOL]     name = f.getName(); [EOL]     declaredType = f.getType(); [EOL]     isSynthetic = f.isSynthetic(); [EOL]     modifiers = f.getModifiers(); [EOL]     field = f; [EOL] }
Object get(Object instance) throws IllegalAccessException { [EOL]     return field.get(instance); [EOL] }
Object get(Object instance) throws IllegalAccessException { [EOL]     return field.get(instance); [EOL] }
Object get(Object instance) throws IllegalAccessException { [EOL]     return field.get(instance); [EOL] }
public JsonPrimitive(Character c) { [EOL]     setValue(c); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonPrimitive(Character c) { [EOL]     setValue(c); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonPrimitive(Character c) { [EOL]     setValue(c); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonPrimitive(Character c) { [EOL]     setValue(c); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonPrimitive(Character c) { [EOL]     setValue(c); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonPrimitive(Character c) { [EOL]     setValue(c); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonPrimitive(Character c) { [EOL]     setValue(c); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
JsonPrimitive(Object primitive) { [EOL]     setValue(primitive); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
JsonPrimitive(Object primitive) { [EOL]     setValue(primitive); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
JsonPrimitive(Object primitive) { [EOL]     setValue(primitive); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
JsonPrimitive(Object primitive) { [EOL]     setValue(primitive); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
JsonPrimitive(Object primitive) { [EOL]     setValue(primitive); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
JsonPrimitive(Object primitive) { [EOL]     setValue(primitive); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
JsonPrimitive(Object primitive) { [EOL]     setValue(primitive); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
JsonPrimitive(Object primitive) { [EOL]     setValue(primitive); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
JsonPrimitive(Object primitive) { [EOL]     setValue(primitive); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
JsonPrimitive(Object primitive) { [EOL]     setValue(primitive); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
JsonPrimitive(Object primitive) { [EOL]     setValue(primitive); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
JsonPrimitive(Object primitive) { [EOL]     setValue(primitive); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
void setValue(Object primitive) { [EOL]     if (primitive instanceof Character) { [EOL]         char c = ((Character) primitive).charValue(); [EOL]         this.value = String.valueOf(c); [EOL]     } else { [EOL]         Preconditions.checkArgument(primitive instanceof Number || isPrimitiveOrString(primitive)); [EOL]         this.value = primitive; [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
void setValue(Object primitive) { [EOL]     if (primitive instanceof Character) { [EOL]         char c = ((Character) primitive).charValue(); [EOL]         this.value = String.valueOf(c); [EOL]     } else { [EOL]         Preconditions.checkArgument(primitive instanceof Number || isPrimitiveOrString(primitive)); [EOL]         this.value = primitive; [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
void setValue(Object primitive) { [EOL]     if (primitive instanceof Character) { [EOL]         char c = ((Character) primitive).charValue(); [EOL]         this.value = String.valueOf(c); [EOL]     } else { [EOL]         Preconditions.checkArgument(primitive instanceof Number || isPrimitiveOrString(primitive)); [EOL]         this.value = primitive; [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
void setValue(Object primitive) { [EOL]     if (primitive instanceof Character) { [EOL]         char c = ((Character) primitive).charValue(); [EOL]         this.value = String.valueOf(c); [EOL]     } else { [EOL]         Preconditions.checkArgument(primitive instanceof Number || isPrimitiveOrString(primitive)); [EOL]         this.value = primitive; [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
void setValue(Object primitive) { [EOL]     if (primitive instanceof Character) { [EOL]         char c = ((Character) primitive).charValue(); [EOL]         this.value = String.valueOf(c); [EOL]     } else { [EOL]         Preconditions.checkArgument(primitive instanceof Number || isPrimitiveOrString(primitive)); [EOL]         this.value = primitive; [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
void setValue(Object primitive) { [EOL]     if (primitive instanceof Character) { [EOL]         char c = ((Character) primitive).charValue(); [EOL]         this.value = String.valueOf(c); [EOL]     } else { [EOL]         Preconditions.checkArgument(primitive instanceof Number || isPrimitiveOrString(primitive)); [EOL]         this.value = primitive; [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public boolean isString() { [EOL]     return value instanceof String; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public boolean isString() { [EOL]     return value instanceof String; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public boolean isString() { [EOL]     return value instanceof String; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public boolean isString() { [EOL]     return value instanceof String; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public char getAsCharacter() { [EOL]     return getAsString().charAt(0); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public char getAsCharacter() { [EOL]     return getAsString().charAt(0); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public char getAsCharacter() { [EOL]     return getAsString().charAt(0); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public char getAsCharacter() { [EOL]     return getAsString().charAt(0); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public char getAsCharacter() { [EOL]     return getAsString().charAt(0); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public char getAsCharacter() { [EOL]     return getAsString().charAt(0); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] protected void toString(Appendable sb, Escaper escaper) throws IOException { [EOL]     if (isString()) { [EOL]         sb.append('"'); [EOL]         sb.append(escaper.escapeJsonString(value.toString())); [EOL]         sb.append('"'); [EOL]     } else { [EOL]         sb.append(value.toString()); [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] protected void toString(Appendable sb, Escaper escaper) throws IOException { [EOL]     if (isString()) { [EOL]         sb.append('"'); [EOL]         sb.append(escaper.escapeJsonString(value.toString())); [EOL]         sb.append('"'); [EOL]     } else { [EOL]         sb.append(value.toString()); [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] protected void toString(Appendable sb, Escaper escaper) throws IOException { [EOL]     if (isString()) { [EOL]         sb.append('"'); [EOL]         sb.append(escaper.escapeJsonString(value.toString())); [EOL]         sb.append('"'); [EOL]     } else { [EOL]         sb.append(value.toString()); [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] protected void toString(Appendable sb, Escaper escaper) throws IOException { [EOL]     if (isString()) { [EOL]         sb.append('"'); [EOL]         sb.append(escaper.escapeJsonString(value.toString())); [EOL]         sb.append('"'); [EOL]     } else { [EOL]         sb.append(value.toString()); [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public int hashCode() { [EOL]     if (value == null) { [EOL]         return 31; [EOL]     } [EOL]     if (isIntegral(this)) { [EOL]         long value = getAsNumber().longValue(); [EOL]         return (int) (value ^ (value >>> 32)); [EOL]     } [EOL]     if (isFloatingPoint(this)) { [EOL]         long value = Double.doubleToLongBits(getAsNumber().doubleValue()); [EOL]         return (int) (value ^ (value >>> 32)); [EOL]     } [EOL]     return value.hashCode(); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public int hashCode() { [EOL]     if (value == null) { [EOL]         return 31; [EOL]     } [EOL]     if (isIntegral(this)) { [EOL]         long value = getAsNumber().longValue(); [EOL]         return (int) (value ^ (value >>> 32)); [EOL]     } [EOL]     if (isFloatingPoint(this)) { [EOL]         long value = Double.doubleToLongBits(getAsNumber().doubleValue()); [EOL]         return (int) (value ^ (value >>> 32)); [EOL]     } [EOL]     return value.hashCode(); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public int hashCode() { [EOL]     if (value == null) { [EOL]         return 31; [EOL]     } [EOL]     if (isIntegral(this)) { [EOL]         long value = getAsNumber().longValue(); [EOL]         return (int) (value ^ (value >>> 32)); [EOL]     } [EOL]     if (isFloatingPoint(this)) { [EOL]         long value = Double.doubleToLongBits(getAsNumber().doubleValue()); [EOL]         return (int) (value ^ (value >>> 32)); [EOL]     } [EOL]     return value.hashCode(); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public int hashCode() { [EOL]     if (value == null) { [EOL]         return 31; [EOL]     } [EOL]     if (isIntegral(this)) { [EOL]         long value = getAsNumber().longValue(); [EOL]         return (int) (value ^ (value >>> 32)); [EOL]     } [EOL]     if (isFloatingPoint(this)) { [EOL]         long value = Double.doubleToLongBits(getAsNumber().doubleValue()); [EOL]         return (int) (value ^ (value >>> 32)); [EOL]     } [EOL]     return value.hashCode(); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public int hashCode() { [EOL]     if (value == null) { [EOL]         return 31; [EOL]     } [EOL]     if (isIntegral(this)) { [EOL]         long value = getAsNumber().longValue(); [EOL]         return (int) (value ^ (value >>> 32)); [EOL]     } [EOL]     if (isFloatingPoint(this)) { [EOL]         long value = Double.doubleToLongBits(getAsNumber().doubleValue()); [EOL]         return (int) (value ^ (value >>> 32)); [EOL]     } [EOL]     return value.hashCode(); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public int hashCode() { [EOL]     if (value == null) { [EOL]         return 31; [EOL]     } [EOL]     if (isIntegral(this)) { [EOL]         long value = getAsNumber().longValue(); [EOL]         return (int) (value ^ (value >>> 32)); [EOL]     } [EOL]     if (isFloatingPoint(this)) { [EOL]         long value = Double.doubleToLongBits(getAsNumber().doubleValue()); [EOL]         return (int) (value ^ (value >>> 32)); [EOL]     } [EOL]     return value.hashCode(); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj == null || getClass() != obj.getClass()) { [EOL]         return false; [EOL]     } [EOL]     JsonPrimitive other = (JsonPrimitive) obj; [EOL]     if (value == null) { [EOL]         return other.value == null; [EOL]     } [EOL]     if (isIntegral(this) && isIntegral(other)) { [EOL]         return getAsNumber().longValue() == other.getAsNumber().longValue(); [EOL]     } [EOL]     if (isFloatingPoint(this) && isFloatingPoint(other)) { [EOL]         return getAsNumber().doubleValue() == other.getAsNumber().doubleValue(); [EOL]     } [EOL]     return value.equals(other.value); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
private static boolean isFloatingPoint(JsonPrimitive primitive) { [EOL]     if (primitive.value instanceof Number) { [EOL]         Number number = (Number) primitive.value; [EOL]         return number instanceof BigDecimal || number instanceof Double || number instanceof Float; [EOL]     } [EOL]     return false; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonElement serialize(Long value) { [EOL]     return strategy.serialize(value); [EOL] }
public JsonElement serialize(Long value) { [EOL]     return new JsonPrimitive(String.valueOf(value)); [EOL] }
public JsonElement serialize(Long value) { [EOL]     return new JsonPrimitive(String.valueOf(value)); [EOL] }
public JsonElement serialize(Long value) { [EOL]     return new JsonPrimitive(String.valueOf(value)); [EOL] }
public JsonElement serialize(Long value) { [EOL]     return new JsonPrimitive(String.valueOf(value)); [EOL] }
void setObject(Object obj) { [EOL]     this.obj = obj; [EOL] }
<HANDLER> Pair<HANDLER, ObjectTypePair> getMatchingHandler(ParameterizedTypeHandlerMap<HANDLER> handlers) { [EOL]     HANDLER handler = null; [EOL]     if (!preserveType && obj != null) { [EOL]         ObjectTypePair moreSpecificType = toMoreSpecificType(); [EOL]         handler = handlers.getHandlerFor(moreSpecificType.type); [EOL]         if (handler != null) { [EOL]             return new Pair<HANDLER, ObjectTypePair>(handler, moreSpecificType); [EOL]         } [EOL]     } [EOL]     handler = handlers.getHandlerFor(type); [EOL]     return handler == null ? null : new Pair<HANDLER, ObjectTypePair>(handler, this); [EOL] }
<HANDLER> Pair<HANDLER, ObjectTypePair> getMatchingHandler(ParameterizedTypeHandlerMap<HANDLER> handlers) { [EOL]     HANDLER handler = null; [EOL]     if (!preserveType && obj != null) { [EOL]         ObjectTypePair moreSpecificType = toMoreSpecificType(); [EOL]         handler = handlers.getHandlerFor(moreSpecificType.type); [EOL]         if (handler != null) { [EOL]             return new Pair<HANDLER, ObjectTypePair>(handler, moreSpecificType); [EOL]         } [EOL]     } [EOL]     handler = handlers.getHandlerFor(type); [EOL]     return handler == null ? null : new Pair<HANDLER, ObjectTypePair>(handler, this); [EOL] }
<HANDLER> Pair<HANDLER, ObjectTypePair> getMatchingHandler(ParameterizedTypeHandlerMap<HANDLER> handlers) { [EOL]     HANDLER handler = null; [EOL]     if (!preserveType && obj != null) { [EOL]         ObjectTypePair moreSpecificType = toMoreSpecificType(); [EOL]         handler = handlers.getHandlerFor(moreSpecificType.type); [EOL]         if (handler != null) { [EOL]             return new Pair<HANDLER, ObjectTypePair>(handler, moreSpecificType); [EOL]         } [EOL]     } [EOL]     handler = handlers.getHandlerFor(type); [EOL]     return handler == null ? null : new Pair<HANDLER, ObjectTypePair>(handler, this); [EOL] }
<HANDLER> Pair<HANDLER, ObjectTypePair> getMatchingHandler(ParameterizedTypeHandlerMap<HANDLER> handlers) { [EOL]     HANDLER handler = null; [EOL]     if (!preserveType && obj != null) { [EOL]         ObjectTypePair moreSpecificType = toMoreSpecificType(); [EOL]         handler = handlers.getHandlerFor(moreSpecificType.type); [EOL]         if (handler != null) { [EOL]             return new Pair<HANDLER, ObjectTypePair>(handler, moreSpecificType); [EOL]         } [EOL]     } [EOL]     handler = handlers.getHandlerFor(type); [EOL]     return handler == null ? null : new Pair<HANDLER, ObjectTypePair>(handler, this); [EOL] }
ObjectTypePair toMoreSpecificType() { [EOL]     if (preserveType || obj == null) { [EOL]         return this; [EOL]     } [EOL]     Type actualType = getActualTypeIfMoreSpecific(type, obj.getClass()); [EOL]     if (actualType == type) { [EOL]         return this; [EOL]     } [EOL]     return new ObjectTypePair(obj, actualType, preserveType); [EOL] }
ObjectTypePair toMoreSpecificType() { [EOL]     if (preserveType || obj == null) { [EOL]         return this; [EOL]     } [EOL]     Type actualType = getActualTypeIfMoreSpecific(type, obj.getClass()); [EOL]     if (actualType == type) { [EOL]         return this; [EOL]     } [EOL]     return new ObjectTypePair(obj, actualType, preserveType); [EOL] }
ObjectTypePair toMoreSpecificType() { [EOL]     if (preserveType || obj == null) { [EOL]         return this; [EOL]     } [EOL]     Type actualType = getActualTypeIfMoreSpecific(type, obj.getClass()); [EOL]     if (actualType == type) { [EOL]         return this; [EOL]     } [EOL]     return new ObjectTypePair(obj, actualType, preserveType); [EOL] }
static Type getActualTypeIfMoreSpecific(Type type, Class<?> actualClass) { [EOL]     if (type instanceof Class<?>) { [EOL]         Class<?> typeAsClass = (Class<?>) type; [EOL]         if (typeAsClass.isAssignableFrom(actualClass)) { [EOL]             type = actualClass; [EOL]         } [EOL]         if (type == Object.class) { [EOL]             type = actualClass; [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
public JsonObject() { [EOL]     members = new LinkedHashMap<String, JsonElement>(); [EOL] }
public void addProperty(String property, Number value) { [EOL]     add(property, createJsonElement(value)); [EOL] }
public void addProperty(String property, Number value) { [EOL]     add(property, createJsonElement(value)); [EOL] }
public void addProperty(String property, Number value) { [EOL]     add(property, createJsonElement(value)); [EOL] }
public void addProperty(String property, Boolean value) { [EOL]     add(property, createJsonElement(value)); [EOL] }
public void addProperty(String property, Boolean value) { [EOL]     add(property, createJsonElement(value)); [EOL] }
public void addProperty(String property, Boolean value) { [EOL]     add(property, createJsonElement(value)); [EOL] }
private JsonElement createJsonElement(Object value) { [EOL]     return value == null ? JsonNull.createJsonNull() : new JsonPrimitive(value); [EOL] }
private JsonElement createJsonElement(Object value) { [EOL]     return value == null ? JsonNull.createJsonNull() : new JsonPrimitive(value); [EOL] }
public Set<Map.Entry<String, JsonElement>> entrySet() { [EOL]     return members.entrySet(); [EOL] }
public Set<Map.Entry<String, JsonElement>> entrySet() { [EOL]     return members.entrySet(); [EOL] }
@Override [EOL] protected String translateName(String target, Type fieldType, Collection<Annotation> annotations) { [EOL]     return target.toUpperCase(); [EOL] }
@Override [EOL] protected String translateName(String target, Type fieldType, Collection<Annotation> annotations) { [EOL]     return target.toUpperCase(); [EOL] }
@Override [EOL] protected String translateName(String target, Type fieldType, Collection<Annotation> annotations) { [EOL]     return target.toUpperCase(); [EOL] }
@Override [EOL] protected String translateName(String target, Type fieldType, Collection<Annotation> annotations) { [EOL]     return target.toUpperCase(); [EOL] }
