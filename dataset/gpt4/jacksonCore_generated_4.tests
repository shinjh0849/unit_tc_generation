public void testGetOriginalMessage() { [EOL] JsonProcessingException exception = new JsonProcessingException("Test message") {}; [EOL] String originalMessage = exception.getOriginalMessage(); [EOL] assertEquals("Test message", originalMessage); [EOL] }
public void testHasTextCharacters_ValueString() { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_STRING); [EOL] boolean result = parser.hasTextCharacters(); [EOL] assertTrue(result); [EOL] }
public void testHasTextCharacters_FieldName_NameCopiedTrue() { [EOL] JsonParser parser = createParserWithTokenAndNameCopied(JsonToken.FIELD_NAME, true); [EOL] boolean result = parser.hasTextCharacters(); [EOL] assertTrue(result); [EOL] }
public void testHasTextCharacters_FieldName_NameCopiedFalse() { [EOL] JsonParser parser = createParserWithTokenAndNameCopied(JsonToken.FIELD_NAME, false); [EOL] boolean result = parser.hasTextCharacters(); [EOL] assertFalse(result); [EOL] }
public void testHasTextCharacters_OtherToken() { [EOL] JsonParser parser = createParserWithToken(JsonToken.START_OBJECT); [EOL] boolean result = parser.hasTextCharacters(); [EOL] assertFalse(result); [EOL] }
public void testReportMismatchedEndMarker_ExpectedChar() throws JsonParseException { [EOL] JsonParser parser = createParserWithMismatchedEndMarker(); // Mock or create a parser instance with a mismatched end marker [EOL] try { [EOL] parser.nextToken(); // Advance to the mismatched end marker [EOL] parser.close(); [EOL] fail("Should have thrown JsonParseException due to mismatched end marker"); [EOL] } catch (JsonParseException e) { [EOL] String expectedMessage = "Unexpected close marker ']'"; // Replace ']' with the actual mismatched character [EOL] assertTrue(e.getMessage().contains(expectedMessage)); [EOL] } [EOL] }
public void testReportMismatchedEndMarker_ActualChar() throws JsonParseException { [EOL] JsonParser parser = createParserWithMismatchedEndMarker(); // Mock or create a parser instance with a mismatched end marker [EOL] try { [EOL] parser.nextToken(); // Advance to the mismatched end marker [EOL] parser.close(); [EOL] fail("Should have thrown JsonParseException due to mismatched end marker"); [EOL] } catch (JsonParseException e) { [EOL] String expectedMessage = "expected '}'"; // Replace '}' with the expected character [EOL] assertTrue(e.getMessage().contains(expectedMessage)); [EOL] } [EOL] }
public void testReportMismatchedEndMarker_TypeDesc() throws JsonParseException { [EOL] JsonParser parser = createParserWithMismatchedEndMarker(); // Mock or create a parser instance with a mismatched end marker [EOL] try { [EOL] parser.nextToken(); // Advance to the mismatched end marker [EOL] parser.close(); [EOL] fail("Should have thrown JsonParseException due to mismatched end marker"); [EOL] } catch (JsonParseException e) { [EOL] String expectedMessage = "(for Object starting at"; // Replace 'Object' with the actual type description [EOL] assertTrue(e.getMessage().contains(expectedMessage)); [EOL] } [EOL] }
public void testGetByteArrayBuilder_WhenBuilderIsNull_ShouldCreateNewBuilder() { [EOL] YourClass instance = new YourClass(); // Replace 'YourClass' with the actual class name that contains the _getByteArrayBuilder method [EOL] ByteArrayBuilder result = instance._getByteArrayBuilder(); [EOL] assertNotNull(result); [EOL] }
public void testGetByteArrayBuilder_WhenBuilderIsNotNull_ShouldResetBuilder() { [EOL] YourClass instance = new YourClass(); // Replace 'YourClass' with the actual class name that contains the _getByteArrayBuilder method [EOL] ByteArrayBuilder firstCallResult = instance._getByteArrayBuilder(); [EOL] ByteArrayBuilder secondCallResult = instance._getByteArrayBuilder(); [EOL] assertNotNull(secondCallResult); [EOL] assertSame(firstCallResult, secondCallResult); // This checks if the same builder is returned [EOL] }
public void testGetNumberTypeWhenNumTypesValidIsUnknown() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_UNKNOWN; // Assuming NR_UNKNOWN is a constant defined elsewhere [EOL] _parseNumericValue(NR_UNKNOWN); // Assuming this method is defined elsewhere and sets _numTypesValid appropriately [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; // Set to a number type that will not match any condition [EOL] NumberType result = getNumberType(); [EOL] assertEquals(NumberType.DOUBLE, result); // Assuming DOUBLE is the default type [EOL] }
public void testGetNumberTypeWhenValueIsInt() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_INT; // Assuming NR_INT is a constant defined elsewhere [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] NumberType result = getNumberType(); [EOL] assertEquals(NumberType.INT, result); [EOL] }
public void testGetNumberTypeWhenValueIsLong() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_LONG; // Assuming NR_LONG is a constant defined elsewhere [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] NumberType result = getNumberType(); [EOL] assertEquals(NumberType.LONG, result); [EOL] }
public void testGetNumberTypeWhenValueIsBigInteger() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_INT | NR_LONG; // Assuming bitwise OR will result in a value that does not match INT or LONG [EOL] _currToken = JsonToken.VALUE_NUMBER_INT; [EOL] NumberType result = getNumberType(); [EOL] assertEquals(NumberType.BIG_INTEGER, result); [EOL] }
public void testGetNumberTypeWhenValueIsBigDecimal() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_BIGDECIMAL; // Assuming NR_BIGDECIMAL is a constant defined elsewhere [EOL] NumberType result = getNumberType(); [EOL] assertEquals(NumberType.BIG_DECIMAL, result); [EOL] }
public void testFindNameWithNonExistentQuad() { [EOL] int firstQuad = 123456; // A quad value that does not exist in the hash or names [EOL] Name result = findName(firstQuad); [EOL] assertNull(result); [EOL] }
public void testFindNameWithExistentQuadMatchingHash() { [EOL] int firstQuad = 123; // A quad value that exists and matches the hash [EOL] Name expectedName = new Name(firstQuad); // Assuming Name has a constructor that accepts int [EOL] int hash = calcHash(firstQuad); [EOL] int ix = (hash & _mainHashMask); [EOL] _mainHash[ix] = (hash << 8); // Set the hash so that it matches the condition [EOL] _mainNames[ix] = expectedName; // Set the name at the index [EOL] Name result = findName(firstQuad); [EOL] assertEquals(expectedName, result); [EOL] }
public void testFindNameWithExistentQuadNotMatchingHash() { [EOL] int firstQuad = 789; // A quad value that exists but does not match the hash [EOL] Name expectedName = new Name(firstQuad); // Assuming Name has a constructor that accepts int [EOL] int hash = calcHash(firstQuad); [EOL] int wrongHash = hash + 1; // A different hash value [EOL] int ix = (hash & _mainHashMask); [EOL] _mainHash[ix] = (wrongHash << 8); // Set a different hash so that it does not match [EOL] _mainNames[ix] = expectedName; // Set the name at the index [EOL] Name result = findName(firstQuad); [EOL] assertNull(result); [EOL] }
public void testFindNameWithCollision() { [EOL] int firstQuad = 456; // A quad value that exists and causes a collision [EOL] Name expectedName = new Name(firstQuad); // Assuming Name has a constructor that accepts int [EOL] int hash = calcHash(firstQuad); [EOL] int ix = (hash & _mainHashMask); [EOL] _mainHash[ix] = (hash << 8) | 1; // Set the hash with a collision marker [EOL] _mainNames[ix] = null; // No direct match at the index [EOL] Bucket bucket = new Bucket(); // Assuming Bucket is a class with a find method [EOL] bucket.add(expectedName, hash); // Add the name to the bucket [EOL] _collList[0] = bucket; // Assuming the collision list index is calculated as shown [EOL] Name result = findName(firstQuad); [EOL] assertEquals(expectedName, result); [EOL] }
public void testFindNameWithSecondQuadZeroAndNameNotFound() { [EOL] int firstQuad = 1; [EOL] int secondQuad = 0; [EOL] Name result = findName(firstQuad, secondQuad); [EOL] assertNull(result); [EOL] }
public void testFindNameWithSecondQuadNonZeroAndNameFound() { [EOL] int firstQuad = 1; [EOL] int secondQuad = 2; [EOL] Name result = findName(firstQuad, secondQuad); [EOL] assertNotNull(result); [EOL] assertTrue(result.equals(firstQuad, secondQuad)); [EOL] }
public void testFindNameWithSecondQuadNonZeroAndNameNotFoundInMainNamesButFoundInBucket() { [EOL] int firstQuad = 1; [EOL] int secondQuad = 2; [EOL] Name result = findName(firstQuad, secondQuad); [EOL] assertNotNull(result); [EOL] assertTrue(result.equals(firstQuad, secondQuad)); [EOL] }
public void testFindNameWithSecondQuadNonZeroAndNameNotFoundAtAll() { [EOL] int firstQuad = 1; [EOL] int secondQuad = 2; [EOL] Name result = findName(firstQuad, secondQuad); [EOL] assertNull(result); [EOL] }
public void testOutputIntWithNegativeMinValue() { [EOL] byte[] buffer = new byte[12]; [EOL] int offset = 0; [EOL] int result = outputInt(Integer.MIN_VALUE, buffer, offset); [EOL] int expectedLength = Integer.toString(Integer.MIN_VALUE).length(); [EOL] assertEquals(expectedLength, result); [EOL] }
public void testOutputIntWithNegativeValue() { [EOL] byte[] buffer = new byte[12]; [EOL] int offset = 0; [EOL] int result = outputInt(-1, buffer, offset); [EOL] assertEquals('-', buffer[0]); [EOL] assertEquals('1', buffer[1]); [EOL] assertEquals(2, result); [EOL] }
public void testOutputIntWithSmallPositiveValue() { [EOL] byte[] buffer = new byte[12]; [EOL] int offset = 0; [EOL] int result = outputInt(5, buffer, offset); [EOL] assertEquals('5', buffer[0]); [EOL] assertEquals(1, result); [EOL] }
public void testOutputIntWithThreeDigitValue() { [EOL] byte[] buffer = new byte[12]; [EOL] int offset = 0; [EOL] int result = outputInt(123, buffer, offset); [EOL] assertEquals('1', buffer[0]); [EOL] assertEquals('2', buffer[1]); [EOL] assertEquals('3', buffer[2]); [EOL] assertEquals(3, result); [EOL] }
public void testOutputIntWithSixDigitValue() { [EOL] byte[] buffer = new byte[12]; [EOL] int offset = 0; [EOL] int result = outputInt(123456, buffer, offset); [EOL] assertEquals('1', buffer[0]); [EOL] assertEquals('2', buffer[1]); [EOL] assertEquals('3', buffer[2]); [EOL] assertEquals('4', buffer[3]); [EOL] assertEquals('5', buffer[4]); [EOL] assertEquals('6', buffer[5]); [EOL] assertEquals(6, result); [EOL] }
public void testOutputIntWithNineDigitValue() { [EOL] byte[] buffer = new byte[12]; [EOL] int offset = 0; [EOL] int result = outputInt(123456789, buffer, offset); [EOL] assertEquals('1', buffer[0]); [EOL] assertEquals('2', buffer[1]); [EOL] assertEquals('3', buffer[2]); [EOL] assertEquals('4', buffer[3]); [EOL] assertEquals('5', buffer[4]); [EOL] assertEquals('6', buffer[5]); [EOL] assertEquals('7', buffer[6]); [EOL] assertEquals('8', buffer[7]); [EOL] assertEquals('9', buffer[8]); [EOL] assertEquals(9, result); [EOL] }
public void testOutputIntWithBillionValue() { [EOL] byte[] buffer = new byte[12]; [EOL] int offset = 0; [EOL] int result = outputInt(1000000000, buffer, offset); [EOL] assertEquals('1', buffer[0]); [EOL] assertEquals(10, result); [EOL] }
public void testOutputIntWithMaxValue() { [EOL] byte[] buffer = new byte[12]; [EOL] int offset = 0; [EOL] int result = outputInt(Integer.MAX_VALUE, buffer, offset); [EOL] int expectedLength = Integer.toString(Integer.MAX_VALUE).length(); [EOL] assertEquals(expectedLength, result); [EOL] }
public void testByteArrayBuilderWithNullBufferRecycler() { [EOL] ByteArrayBuilder builder = new ByteArrayBuilder(null); [EOL] assertNotNull(builder); [EOL] }
public void testByteArrayBuilderWithNonNullBufferRecycler() { [EOL] BufferRecycler br = new BufferRecycler(); [EOL] ByteArrayBuilder builder = new ByteArrayBuilder(br); [EOL] assertNotNull(builder); [EOL] }
public void testByteArrayBuilderWithNullRecycler() { [EOL] int firstBlockSize = 256; [EOL] ByteArrayBuilder byteArrayBuilder = new ByteArrayBuilder(null, firstBlockSize); [EOL] assertNotNull(byteArrayBuilder); [EOL] assertEquals(firstBlockSize, byteArrayBuilder.getCurrentSegmentSize()); [EOL] }
public void testByteArrayBuilderWithNonNullRecycler() { [EOL] int firstBlockSize = 256; [EOL] BufferRecycler br = new BufferRecycler(); [EOL] ByteArrayBuilder byteArrayBuilder = new ByteArrayBuilder(br, firstBlockSize); [EOL] assertNotNull(byteArrayBuilder); [EOL] assertNotNull(byteArrayBuilder.getCurrentSegment()); [EOL] }
public void testResetWhenPastBlocksIsEmpty() { [EOL] TextBuffer textBuffer = new TextBuffer(); [EOL] textBuffer.reset(); [EOL] assertEquals(0, textBuffer._pastLen); [EOL] assertEquals(0, textBuffer._currBlockPtr); [EOL] assertTrue(textBuffer._pastBlocks.isEmpty()); [EOL] }
public void testResetWhenPastBlocksIsNotEmpty() { [EOL] TextBuffer textBuffer = new TextBuffer(); [EOL] textBuffer._pastBlocks.add(new char[10]); [EOL] textBuffer._pastLen = 10; [EOL] textBuffer._currBlockPtr = 5; [EOL] textBuffer.reset(); [EOL] assertEquals(0, textBuffer._pastLen); [EOL] assertEquals(0, textBuffer._currBlockPtr); [EOL] assertTrue(textBuffer._pastBlocks.isEmpty()); [EOL] }
public void testAppendWithRoomInCurrentBlock() { [EOL] TextBuffer testBuffer = new TextBuffer(); // Replace with actual constructor [EOL] int initialPtr = testBuffer._currBlockPtr; [EOL] testBuffer.append(97); // ASCII code for 'a' [EOL] assertEquals(initialPtr + 1, testBuffer._currBlockPtr); [EOL] assertEquals((byte) 97, testBuffer._currBlock[initialPtr]); [EOL] }
public void testAppendWithNoRoomInCurrentBlock() { [EOL] TextBuffer testBuffer = new TextBuffer(); // Replace with actual constructor [EOL] testBuffer._currBlock = new byte[1]; // Set current block to be full [EOL] testBuffer._currBlockPtr = 1; [EOL] testBuffer.append(98); // ASCII code for 'b' [EOL] assertTrue(testBuffer._currBlockPtr > 1); // Check if _currBlockPtr was incremented [EOL] assertTrue(testBuffer._currBlock.length >= 2); // Check if a new block was allocated [EOL] assertEquals((byte) 98, testBuffer._currBlock[0]); // Check if 'b' was added to the new block [EOL] }
public void testAppendThreeBytesWithEnoughSpace() { [EOL] int initialPtr = 0; // Example starting pointer [EOL] int b24 = 0x123456; // Example input [EOL] byte[] _currBlock = new byte[10]; // Example block with enough space [EOL] int _currBlockPtr = initialPtr; [EOL] appendThreeBytes(b24); [EOL] assertEquals((byte) (b24 >> 16), _currBlock[initialPtr]); [EOL] assertEquals((byte) (b24 >> 8), _currBlock[initialPtr + 1]); [EOL] assertEquals((byte) b24, _currBlock[initialPtr + 2]); [EOL] assertEquals(initialPtr + 3, _currBlockPtr); [EOL] }
public void testAppendThreeBytesWithoutEnoughSpace() { [EOL] int initialPtr = 8; // Example starting pointer near the end of the block [EOL] int b24 = 0x123456; // Example input [EOL] byte[] _currBlock = new byte[10]; // Example block with not enough space [EOL] int _currBlockPtr = initialPtr; [EOL] appendThreeBytes(b24); [EOL] }
public void testToByteArrayWithEmptyBlocks() { [EOL] _pastLen = 0; [EOL] _currBlockPtr = 0; [EOL] _pastBlocks.clear(); // Assuming this is a List<byte[]> [EOL] _currBlock = new byte[0]; // Assuming this is the current block byte array [EOL] byte[] result = toByteArray(); [EOL] assertTrue(result.length == 0); [EOL] assertArrayEquals(NO_BYTES, result); [EOL] }
public void testToByteArrayWithNonEmptyBlocks() { [EOL] _pastLen = 5; [EOL] _currBlockPtr = 3; [EOL] _pastBlocks.add(new byte[]{1, 2, 3, 4, 5}); // Assuming this is a List<byte[]> [EOL] _currBlock = new byte[]{6, 7, 8}; // Assuming this is the current block byte array [EOL] byte[] result = toByteArray(); [EOL] assertEquals(8, result.length); [EOL] assertArrayEquals(new byte[]{1, 2, 3, 4, 5, 6, 7, 8}, result); [EOL] }
public void testToByteArrayWithIncorrectTotalLength() { [EOL] _pastLen = 5; [EOL] _currBlockPtr = 3; [EOL] _pastBlocks.add(new byte[]{1, 2, 3, 4, 5}); // Assuming this is a List<byte[]> [EOL] _currBlock = new byte[]{6, 7, 8}; // Assuming this is the current block byte array [EOL] _pastLen = 4; // This should cause the RuntimeException to be thrown [EOL] try { [EOL] toByteArray(); [EOL] fail("Expected a RuntimeException to be thrown due to incorrect total length"); [EOL] } catch (RuntimeException e) { [EOL] assertEquals("Internal error: total len assumed to be 7, copied 8 bytes", e.getMessage()); [EOL] } [EOL] }
public void testToByteArrayWithReset() { [EOL] _pastLen = 5; [EOL] _currBlockPtr = 3; [EOL] _pastBlocks.add(new byte[]{1, 2, 3, 4, 5}); // Assuming this is a List<byte[]> [EOL] _currBlock = new byte[]{6, 7, 8}; // Assuming this is the current block byte array [EOL] byte[] result = toByteArray(); [EOL] assertEquals(8, result.length); [EOL] assertArrayEquals(new byte[]{1, 2, 3, 4, 5, 6, 7, 8}, result); [EOL] assertTrue(_pastBlocks.isEmpty()); [EOL] assertEquals(0, _currBlockPtr); [EOL] assertEquals(0, _pastLen); [EOL] }
public void testResetAndGetFirstSegment_NewBuffer() { [EOL] ByteArrayBuilder bab = new ByteArrayBuilder(); [EOL] byte[] result = bab.resetAndGetFirstSegment(); [EOL] assertNotNull(result); [EOL] assertEquals(0, bab.getCurrentSegmentSize()); [EOL] } [EOL] public void testResetAndGetFirstSegment_AfterAppending() { [EOL] ByteArrayBuilder bab = new ByteArrayBuilder(); [EOL] bab.append(1); [EOL] bab.append(2); [EOL] byte[] result = bab.resetAndGetFirstSegment(); [EOL] assertNotNull(result); [EOL] assertEquals(0, bab.getCurrentSegmentSize()); [EOL] }

public void testCompleteAndCoalesce() { [EOL] _currBlockPtr = 0; // Resetting _currBlockPtr to ensure a clean state. [EOL] int lastBlockLength = 10; // Example block length. [EOL] byte[] result = instanceUnderTest.completeAndCoalesce(lastBlockLength); [EOL] assertNotNull(result); // Asserting the result is not null. [EOL] assertEquals(lastBlockLength, _currBlockPtr); // Asserting _currBlockPtr is set correctly. [EOL] byte[] expected = getExpectedByteArray(lastBlockLength); [EOL] assertArrayEquals(expected, result); // Asserting the returned byte array is as expected. [EOL] }

public void testCreateParserWithMatch_MatchIsNull() throws IOException { [EOL] _match = null; [EOL] JsonParser result = createParserWithMatch(); [EOL] assertNull(result); [EOL] }
public void testCreateParserWithMatch_OriginalStreamIsNull() throws IOException { [EOL] _match = mock(MatchType.class); // Assuming MatchType is the type of _match [EOL] _originalStream = null; [EOL] _bufferedData = new byte[]{/* some test data */}; [EOL] _bufferedStart = 0; [EOL] _bufferedLength = _bufferedData.length; [EOL] when(_match.createParser(_bufferedData, _bufferedStart, _bufferedLength)).thenReturn(mock(JsonParser.class)); [EOL] JsonParser result = createParserWithMatch(); [EOL] assertNotNull(result); [EOL] verify(_match).createParser(_bufferedData, _bufferedStart, _bufferedLength); [EOL] }
public void testCreateParserWithMatch_OriginalStreamIsNotNull() throws IOException { [EOL] _match = mock(MatchType.class); // Assuming MatchType is the type of _match [EOL] _originalStream = mock(InputStream.class); // Assuming _originalStream is of type InputStream [EOL] _bufferedData = new byte[]{/* some test data */}; [EOL] _bufferedStart = 0; [EOL] _bufferedLength = _bufferedData.length; [EOL] when(_match.createParser(any(InputStream.class))).thenReturn(mock(JsonParser.class)); [EOL] JsonParser result = createParserWithMatch(); [EOL] assertNotNull(result); [EOL] verify(_match).createParser(any(InputStream.class)); [EOL] }
public void testInLongRangeLessThanCmpLen() { [EOL] char[] digitChars = {'1', '2', '3'}; [EOL] int offset = 0; [EOL] int len = 2; [EOL] boolean negative = false; [EOL] boolean result = inLongRange(digitChars, offset, len, negative); [EOL] assertTrue(result); [EOL] }
public void testInLongRangeGreaterThanCmpLen() { [EOL] char[] digitChars = {'1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '1'}; [EOL] int offset = 0; [EOL] int len = 11; [EOL] boolean negative = false; [EOL] boolean result = inLongRange(digitChars, offset, len, negative); [EOL] assertFalse(result); [EOL] }
public void testInLongRangeEqualCmpLenNegativeLess() { [EOL] char[] digitChars = "-9223372036854775808".toCharArray(); [EOL] int offset = 1; [EOL] int len = 19; [EOL] boolean negative = true; [EOL] boolean result = inLongRange(digitChars, offset, len, negative); [EOL] assertTrue(result); [EOL] }
public void testInLongRangeEqualCmpLenNegativeMore() { [EOL] char[] digitChars = "-9223372036854775809".toCharArray(); [EOL] int offset = 1; [EOL] int len = 19; [EOL] boolean negative = true; [EOL] boolean result = inLongRange(digitChars, offset, len, negative); [EOL] assertFalse(result); [EOL] }
public void testInLongRangeEqualCmpLenPositiveLess() { [EOL] char[] digitChars = "9223372036854775806".toCharArray(); [EOL] int offset = 0; [EOL] int len = 19; [EOL] boolean negative = false; [EOL] boolean result = inLongRange(digitChars, offset, len, negative); [EOL] assertTrue(result); [EOL] }
public void testInLongRangeEqualCmpLenPositiveMore() { [EOL] char[] digitChars = "9223372036854775808".toCharArray(); [EOL] int offset = 0; [EOL] int len = 19; [EOL] boolean negative = false; [EOL] boolean result = inLongRange(digitChars, offset, len, negative); [EOL] assertFalse(result); [EOL] }
public void testInLongRangeWithNegativeNumberShorterThanMinLong() { [EOL] boolean result = inLongRange("-1", true); [EOL] assertTrue(result); [EOL] } [EOL] public void testInLongRangeWithPositiveNumberShorterThanMaxLong() { [EOL] boolean result = inLongRange("1", false); [EOL] assertTrue(result); [EOL] }
public void testInLongRangeWithNegativeNumberLongerThanMinLong() { [EOL] boolean result = inLongRange("-92233720368547758070", true); [EOL] assertFalse(result); [EOL] } [EOL] public void testInLongRangeWithPositiveNumberLongerThanMaxLong() { [EOL] boolean result = inLongRange("92233720368547758070", false); [EOL] assertFalse(result); [EOL] }
public void testInLongRangeWithNegativeNumberEqualToMinLong() { [EOL] boolean result = inLongRange("-9223372036854775808", true); [EOL] assertTrue(result); [EOL] } [EOL] public void testInLongRangeWithPositiveNumberEqualToMaxLong() { [EOL] boolean result = inLongRange("9223372036854775807", false); [EOL] assertTrue(result); [EOL] }
public void testInLongRangeWithNegativeNumberJustBelowMinLong() { [EOL] boolean result = inLongRange("-9223372036854775809", true); [EOL] assertFalse(result); [EOL] } [EOL] public void testInLongRangeWithPositiveNumberJustAboveMaxLong() { [EOL] boolean result = inLongRange("9223372036854775808", false); [EOL] assertFalse(result); [EOL] }
public void testParseDoubleWithNastySmallDouble() { [EOL] String numStr = "0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 carat" { [EOL] double result = JacksonCore.parseDouble(numStr); [EOL] assertEquals(Double.MIN_VALUE, result, 0.0); [EOL] } [EOL] } [EOL] public void testParseDoubleWithRegularNumber() { [EOL] String numStr = "123.456"; [EOL] double result = JacksonCore.parseDouble(numStr); [EOL] assertEquals(123.456, result, 0.0); [EOL] } [EOL] public void testParseDoubleWithInfinity() { [EOL] String numStr = "Infinity"; [EOL] double result = JacksonCore.parseDouble(numStr); [EOL] assertEquals(Double.POSITIVE_INFINITY, result, 0.0); [EOL] } [EOL] public void testParseDoubleWithNegativeInfinity() { [EOL] String numStr = "-Infinity"; [EOL] double result = JacksonCore.parseDouble(numStr); [EOL] assertEquals(Double.NEGATIVE_INFINITY, result, 0.0); [EOL] } [EOL] public void testParseDoubleWithNaN() { [EOL] String numStr = "NaN"; [EOL] double result = JacksonCore.parseDouble(numStr); [EOL] assertEquals(Double.NaN, result, 0.0); [EOL] } [EOL] public void testParseDoubleWithInvalidNumber() { [EOL] String numStr = "not a number"; [EOL] try { [EOL] JacksonCore.parseDouble(numStr); [EOL] fail("Expected NumberFormatException to be thrown"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testGetText2WithNullToken() { [EOL] setupContext(); [EOL] String result = _getText2(null); [EOL] assertNull(result); [EOL] }
public void testGetText2WithFieldNameToken() { [EOL] setupContext(); [EOL] when(_parsingContext.getCurrentName()).thenReturn("fieldName"); [EOL] String result = _getText2(JsonToken.FIELD_NAME); [EOL] assertEquals("fieldName", result); [EOL] }
public void testGetText2WithValueStringToken() { [EOL] setupContext(); [EOL] when(_textBuffer.contentsAsString()).thenReturn("stringValue"); [EOL] String result = _getText2(JsonToken.VALUE_STRING); [EOL] assertEquals("stringValue", result); [EOL] }
public void testGetText2WithValueNumberIntToken() { [EOL] setupContext(); [EOL] when(_textBuffer.contentsAsString()).thenReturn("intValue"); [EOL] String result = _getText2(JsonToken.VALUE_NUMBER_INT); [EOL] assertEquals("intValue", result); [EOL] }
public void testGetText2WithValueNumberFloatToken() { [EOL] setupContext(); [EOL] when(_textBuffer.contentsAsString()).thenReturn("floatValue"); [EOL] String result = _getText2(JsonToken.VALUE_NUMBER_FLOAT); [EOL] assertEquals("floatValue", result); [EOL] }
public void testGetText2WithDefaultToken() { [EOL] setupContext(); [EOL] String result = _getText2(JsonToken.VALUE_TRUE); [EOL] assertEquals("true", result); [EOL] }
public void testGetBinaryValueWithNonStringValueToken() throws IOException { [EOL] JsonParser parser = createParserWithToken(JsonToken.FIELD_NAME); // Assuming createParserWithToken is a helper method [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] try { [EOL] parser.getBinaryValue(b64variant); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testGetBinaryValueWithIncompleteToken() throws IOException { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_STRING); // Assuming createParserWithToken is a helper method [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] setTokenIncomplete(parser, true); // Assuming setTokenIncomplete is a helper method to set _tokenIncomplete [EOL] byte[] result = parser.getBinaryValue(b64variant); [EOL] assertNotNull(result); [EOL] assertFalse(getTokenIncomplete(parser)); // Assuming getTokenIncomplete is a helper method to get _tokenIncomplete [EOL] }
public void testGetBinaryValueWithCompleteTokenNullBinaryValue() throws IOException { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_STRING); // Assuming createParserWithToken is a helper method [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] setTokenIncomplete(parser, false); // Assuming setTokenIncomplete is a helper method to set _tokenIncomplete [EOL] setBinaryValue(parser, null); // Assuming setBinaryValue is a helper method to set _binaryValue [EOL] byte[] result = parser.getBinaryValue(b64variant); [EOL] assertNotNull(result); [EOL] }
public void testGetBinaryValueWithCompleteTokenNonNullBinaryValue() throws IOException { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_STRING); // Assuming createParserWithToken is a helper method [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] setTokenIncomplete(parser, false); // Assuming setTokenIncomplete is a helper method to set _tokenIncomplete [EOL] byte[] expectedBinaryValue = new byte[]{1, 2, 3}; [EOL] setBinaryValue(parser, expectedBinaryValue); // Assuming setBinaryValue is a helper method to set _binaryValue [EOL] byte[] result = parser.getBinaryValue(b64variant); [EOL] assertArrayEquals(expectedBinaryValue, result); [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_UNKNOWN; [EOL] if (_currToken == JsonToken.FIELD_NAME) { [EOL] return _nextAfterName(); [EOL] } [EOL] if (_tokenIncomplete) { [EOL] _skipString(); [EOL] } [EOL] int i = _skipWSOrEnd(); [EOL] if (i < 0) { [EOL] close(); [EOL] return (_currToken = null); [EOL] } [EOL] _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL] _tokenInputRow = _currInputRow; [EOL] _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL] _binaryValue = null; [EOL] if (i == INT_RBRACKET) { [EOL] if (!_parsingContext.inArray()) { [EOL] _reportMismatchedEndMarker(i, '}'); [EOL] } [EOL] _parsingContext = _parsingContext.getParent(); [EOL] return (_currToken = JsonToken.END_ARRAY); [EOL] } [EOL] if (i == INT_RCURLY) { [EOL] if (!_parsingContext.inObject()) { [EOL] _reportMismatchedEndMarker(i, ']'); [EOL] } [EOL] _parsingContext = _parsingContext.getParent(); [EOL] return (_currToken = JsonToken.END_OBJECT); [EOL] } [EOL] if (_parsingContext.expectComma()) { [EOL] if (i != INT_COMMA) { [EOL] _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL] } [EOL] i = _skipWS(); [EOL] } [EOL] if (!_parsingContext.inObject()) { [EOL] return _nextTokenNotInObject(i); [EOL] } [EOL] Name n = _parseFieldName(i); [EOL] _parsingContext.setCurrentName(n.getName()); [EOL] _currToken = JsonToken.FIELD_NAME; [EOL] i = _skipWS(); [EOL] if (i != INT_COLON) { [EOL] _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL] } [EOL] i = _skipWS(); [EOL] if (i == INT_QUOTE) { [EOL] _tokenIncomplete = true; [EOL] _nextToken = JsonToken.VALUE_STRING; [EOL] return _currToken; [EOL] } [EOL] JsonToken t; [EOL] switch(i) { [EOL] case INT_LBRACKET: [EOL] t = JsonToken.START_ARRAY; [EOL] break; [EOL] case INT_LCURLY: [EOL] t = JsonToken.START_OBJECT; [EOL] break; [EOL] case INT_RBRACKET: [EOL] case INT_RCURLY: [EOL] _reportUnexpectedChar(i, "expected a value"); [EOL] case INT_t: [EOL] _matchToken("true", 1); [EOL] t = JsonToken.VALUE_TRUE; [EOL] break; [EOL] case INT_f: [EOL] _matchToken("false", 1); [EOL] t = JsonToken.VALUE_FALSE; [EOL] break; [EOL] case INT_n: [EOL] _matchToken("null", 1); [EOL] t = JsonToken.VALUE_NULL; [EOL] break; [EOL] case INT_MINUS: [EOL] case INT_0: [EOL] case INT_1: [EOL] case INT_2: [EOL] case INT_3: [EOL] case INT_4: [EOL] case INT_5: [EOL] case INT_6: [EOL] case INT_7: [EOL] case INT_8: [EOL] case INT_9: [EOL] t = parseNumberText(i); [EOL] break; [EOL] default: [EOL] t = _handleUnexpectedValue(i); [EOL] } [EOL] _nextToken = t; [EOL] return _currToken; [EOL] }
public void testNextTokenNotInObjectWithQuote() throws IOException, JsonParseException { [EOL] int i = INT_QUOTE; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertTrue(_tokenIncomplete); [EOL] assertEquals(JsonToken.VALUE_STRING, result); [EOL] }
public void testNextTokenNotInObjectWithLBracket() throws IOException, JsonParseException { [EOL] int i = INT_LBRACKET; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertNotNull(_parsingContext); [EOL] assertEquals(JsonToken.START_ARRAY, result); [EOL] }
public void testNextTokenNotInObjectWithLCurly() throws IOException, JsonParseException { [EOL] int i = INT_LCURLY; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertNotNull(_parsingContext); [EOL] assertEquals(JsonToken.START_OBJECT, result); [EOL] }
public void testNextTokenNotInObjectWithRBracket() { [EOL] int i = INT_RBRACKET; [EOL] try { [EOL] _nextTokenNotInObject(i); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } catch (IOException e) { [EOL] fail("IOException should not be thrown"); [EOL] } [EOL] }
public void testNextTokenNotInObjectWithRCurly() { [EOL] int i = INT_RCURLY; [EOL] try { [EOL] _nextTokenNotInObject(i); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } catch (IOException e) { [EOL] fail("IOException should not be thrown"); [EOL] } [EOL] }
public void testNextTokenNotInObjectWithTrue() throws IOException, JsonParseException { [EOL] int i = INT_t; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertEquals(JsonToken.VALUE_TRUE, result); [EOL] }
public void testNextTokenNotInObjectWithFalse() throws IOException, JsonParseException { [EOL] int i = INT_f; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertEquals(JsonToken.VALUE_FALSE, result); [EOL] }
public void testNextTokenNotInObjectWithNull() throws IOException, JsonParseException { [EOL] int i = INT_n; [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertEquals(JsonToken.VALUE_NULL, result); [EOL] }
public void testNextTokenNotInObjectWithNumber() throws IOException, JsonParseException { [EOL] int[] numbers = new int[]{INT_MINUS, INT_0, INT_1, INT_2, INT_3, INT_4, INT_5, INT_6, INT_7, INT_8, INT_9}; [EOL] for (int i : numbers) { [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertNotNull(result); [EOL] assertTrue(result.isNumeric()); [EOL] } [EOL] }
public void testNextTokenNotInObjectWithUnexpectedValue() throws IOException, JsonParseException { [EOL] int i = INT_UNKNOWN; // Assuming INT_UNKNOWN is a constant for an unexpected value [EOL] JsonToken result = _nextTokenNotInObject(i); [EOL] assertEquals(_handleUnexpectedValue(i), result); [EOL] }
public void testNextFieldNameWithFieldNameToken() throws IOException, JsonParseException { [EOL] SerializableString str = createMockSerializableString(); [EOL] JsonParserImpl parser = createParserWithFieldNameToken(); [EOL] boolean result = parser.nextFieldName(str); [EOL] assertFalse(result); [EOL] assertNull(parser.getCurrentToken()); [EOL] } [EOL] public void testNextFieldNameWithIncompleteToken() throws IOException, JsonParseException { [EOL] SerializableString str = createMockSerializableString(); [EOL] JsonParserImpl parser = createParserWithIncompleteToken(); [EOL] boolean result = parser.nextFieldName(str); [EOL] assertFalse(result); [EOL] assertNotNull(parser.getCurrentToken()); [EOL] } [EOL] public void testNextFieldNameWithEndArrayToken() throws IOException, JsonParseException { [EOL] SerializableString str = createMockSerializableString(); [EOL] JsonParserImpl parser = createParserWithEndArrayToken(); [EOL] boolean result = parser.nextFieldName(str); [EOL] assertFalse(result); [EOL] assertEquals(JsonToken.END_ARRAY, parser.getCurrentToken()); [EOL] } [EOL] public void testNextFieldNameWithEndObjectToken() throws IOException, JsonParseException { [EOL] SerializableString str = createMockSerializableString(); [EOL] JsonParserImpl parser = createParserWithEndObjectToken(); [EOL] boolean result = parser.nextFieldName(str); [EOL] assertFalse(result); [EOL] assertEquals(JsonToken.END_OBJECT, parser.getCurrentToken()); [EOL] } [EOL] public void testNextFieldNameWithCommaExpected() throws IOException, JsonParseException { [EOL] SerializableString str = createMockSerializableString(); [EOL] JsonParserImpl parser = createParserWithCommaExpected(); [EOL] boolean result = parser.nextFieldName(str); [EOL] assertFalse(result); [EOL] assertNotNull(parser.getCurrentToken()); [EOL] } [EOL] public void testNextFieldNameWithNotInObject() throws IOException, JsonParseException { [EOL] SerializableString str = createMockSerializableString(); [EOL] JsonParserImpl parser = createParserNotInObject(); [EOL] boolean result = parser.nextFieldName(str); [EOL] assertFalse(result); [EOL] assertNull(parser.getCurrentToken()); [EOL] } [EOL] public void testNextFieldNameWithMatchingName() throws IOException, JsonParseException { [EOL] SerializableString str = createMockSerializableString(); [EOL] JsonParserImpl parser = createParserWithMatchingName(str); [EOL] boolean result = parser.nextFieldName(str); [EOL] assertTrue(result); [EOL] assertEquals(JsonToken.FIELD_NAME, parser.getCurrentToken()); [EOL] } [EOL] public void testNextFieldNameWithNonMatchingName() throws IOException, JsonParseException { [EOL] SerializableString str = createMockSerializableString(); [EOL] JsonParserImpl parser = createParserWithNonMatchingName(str); [EOL] boolean result = parser.nextFieldName(str); [EOL] assertFalse(result); [EOL] assertNull(parser.getCurrentToken()); [EOL] }

private void _isNextTokenNameYes() throws IOException, JsonParseException { [EOL] int i; [EOL] if (_inputPtr < (_inputEnd - 1) && _inputBuffer[_inputPtr] == INT_COLON) { [EOL] i = _inputBuffer[++_inputPtr]; [EOL] ++_inputPtr; [EOL] if (i == INT_QUOTE) { [EOL] _tokenIncomplete = true; [EOL] _nextToken = JsonToken.VALUE_STRING; [EOL] return; [EOL] } [EOL] if (i == INT_LCURLY) { [EOL] _nextToken = JsonToken.START_OBJECT; [EOL] return; [EOL] } [EOL] if (i == INT_LBRACKET) { [EOL] _nextToken = JsonToken.START_ARRAY; [EOL] return; [EOL] } [EOL] i &= 0xFF; [EOL] if (i <= INT_SPACE || i == INT_SLASH) { [EOL] --_inputPtr; [EOL] i = _skipWS(); [EOL] } [EOL] } else { [EOL] i = _skipColon(); [EOL] } [EOL] switch(i) { [EOL] case INT_QUOTE: [EOL] _tokenIncomplete = true; [EOL] _nextToken = JsonToken.VALUE_STRING; [EOL] return; [EOL] case INT_LBRACKET: [EOL] _nextToken = JsonToken.START_ARRAY; [EOL] return; [EOL] case INT_LCURLY: [EOL] _nextToken = JsonToken.START_OBJECT; [EOL] return; [EOL] case INT_RBRACKET: [EOL] case INT_RCURLY: [EOL] _reportUnexpectedChar(i, "expected a value"); [EOL] case INT_t: [EOL] _matchToken("true", 1); [EOL] _nextToken = JsonToken.VALUE_TRUE; [EOL] return; [EOL] case INT_f: [EOL] _matchToken("false", 1); [EOL] _nextToken = JsonToken.VALUE_FALSE; [EOL] return; [EOL] case INT_n: [EOL] _matchToken("null", 1); [EOL] _nextToken = JsonToken.VALUE_NULL; [EOL] return; [EOL] case INT_MINUS: [EOL] case INT_0: [EOL] case INT_1: [EOL] case INT_2: [EOL] case INT_3: [EOL] case INT_4: [EOL] case INT_5: [EOL] case INT_6: [EOL] case INT_7: [EOL] case INT_8: [EOL] case INT_9: [EOL] _nextToken = parseNumberText(i); [EOL] return; [EOL] } [EOL] _nextToken = _handleUnexpectedValue(i); [EOL] }
public void testIsNextTokenNameMaybeWithFieldNameMatch() throws IOException, JsonParseException { [EOL] int i = INT_SOME_VALUE; // Replace with actual int constant for field name [EOL] SerializableString str = new SerializableStringImpl("fieldName"); // Replace with actual implementation [EOL] Name n = new Name("fieldName", 0, 0); // Replace with actual Name object creation [EOL] JsonParserContext _parsingContext = new JsonParserContext(); // Replace with actual context initialization [EOL] JsonToken _currToken; [EOL] boolean _tokenIncomplete; [EOL] JsonToken _nextToken; [EOL] boolean match = _isNextTokenNameMaybe(i, str); [EOL] assertTrue(match); [EOL] assertEquals(JsonToken.FIELD_NAME, _currToken); [EOL] assertFalse(_tokenIncomplete); [EOL] }
public void testIsNextTokenNameMaybeWithFieldNameMismatch() throws IOException, JsonParseException { [EOL] int i = INT_SOME_VALUE; // Replace with actual int constant for field name [EOL] SerializableString str = new SerializableStringImpl("differentName"); // Replace with actual implementation [EOL] Name n = new Name("fieldName", 0, 0); // Replace with actual Name object creation [EOL] JsonParserContext _parsingContext = new JsonParserContext(); // Replace with actual context initialization [EOL] JsonToken _currToken; [EOL] boolean _tokenIncomplete; [EOL] JsonToken _nextToken; [EOL] boolean match = _isNextTokenNameMaybe(i, str); [EOL] assertFalse(match); [EOL] assertEquals(JsonToken.FIELD_NAME, _currToken); [EOL] assertFalse(_tokenIncomplete); [EOL] }
public void testIsNextTokenNameMaybeWithUnexpectedChar() throws IOException, JsonParseException { [EOL] int i = INT_SOME_VALUE; // Replace with actual int constant for field name [EOL] SerializableString str = new SerializableStringImpl("fieldName"); // Replace with actual implementation [EOL] Name n = new Name("fieldName", 0, 0); // Replace with actual Name object creation [EOL] JsonParserContext _parsingContext = new JsonParserContext(); // Replace with actual context initialization [EOL] JsonToken _currToken; [EOL] boolean _tokenIncomplete; [EOL] JsonToken _nextToken; [EOL] try { [EOL] _isNextTokenNameMaybe(i, str); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testIsNextTokenNameMaybeWithValueString() throws IOException, JsonParseException { [EOL] int i = INT_SOME_VALUE; // Replace with actual int constant for field name [EOL] SerializableString str = new SerializableStringImpl("fieldName"); // Replace with actual implementation [EOL] Name n = new Name("fieldName", 0, 0); // Replace with actual Name object creation [EOL] JsonParserContext _parsingContext = new JsonParserContext(); // Replace with actual context initialization [EOL] JsonToken _currToken; [EOL] boolean _tokenIncomplete; [EOL] JsonToken _nextToken; [EOL] boolean match = _isNextTokenNameMaybe(i, str); [EOL] assertTrue(match); [EOL] assertEquals(JsonToken.FIELD_NAME, _currToken); [EOL] assertTrue(_tokenIncomplete); [EOL] assertEquals(JsonToken.VALUE_STRING, _nextToken); [EOL] }

public void testNextLongValueWithFieldNameTokenAndValueNumberInt() throws IOException { [EOL] _currToken = JsonToken.FIELD_NAME; [EOL] _nextToken = JsonToken.VALUE_NUMBER_INT; [EOL] long expectedValue = 123L; [EOL] Mockito.when(getLongValue()).thenReturn(expectedValue); [EOL] long actualValue = nextLongValue(0L); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testNextLongValueWithFieldNameTokenAndNotValueNumberInt() throws IOException { [EOL] _currToken = JsonToken.FIELD_NAME; [EOL] _nextToken = JsonToken.START_OBJECT; // Could be any non VALUE_NUMBER_INT token [EOL] long defaultValue = 456L; [EOL] long actualValue = nextLongValue(defaultValue); [EOL] assertEquals(defaultValue, actualValue); [EOL] }
public void testNextLongValueWithoutFieldNameTokenAndNextTokenIsValueNumberInt() throws IOException { [EOL] _currToken = JsonToken.NOT_AVAILABLE; // Could be any non FIELD_NAME token [EOL] _nextToken = JsonToken.VALUE_NUMBER_INT; [EOL] Mockito.when(nextToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] long expectedValue = 789L; [EOL] Mockito.when(getLongValue()).thenReturn(expectedValue); [EOL] long actualValue = nextLongValue(0L); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testNextLongValueWithoutFieldNameTokenAndNextTokenIsNotValueNumberInt() throws IOException { [EOL] _currToken = JsonToken.NOT_AVAILABLE; // Could be any non FIELD_NAME token [EOL] _nextToken = JsonToken.START_OBJECT; // Could be any non VALUE_NUMBER_INT token [EOL] long defaultValue = 101112L; [EOL] Mockito.when(nextToken()).thenReturn(JsonToken.START_OBJECT); [EOL] long actualValue = nextLongValue(defaultValue); [EOL] assertEquals(defaultValue, actualValue); [EOL] }
public void testParseNumberTextNegative() throws IOException, JsonParseException { [EOL] int c = INT_MINUS; [EOL] JsonToken result = parseNumberText(c); [EOL] }
public void testParseNumberTextNonDigitStart() throws IOException, JsonParseException { [EOL] int c = INT_MINUS; [EOL] JsonToken result = parseNumberText(c); [EOL] }
public void testParseNumberTextLeadingZero() throws IOException, JsonParseException { [EOL] int c = INT_0; [EOL] JsonToken result = parseNumberText(c); [EOL] }
public void testParseNumberTextLoopExitByNonDigit() throws IOException, JsonParseException { [EOL] int c = INT_1; // Assuming INT_1 is a valid digit other than 0 [EOL] JsonToken result = parseNumberText(c); [EOL] }
public void testParseNumberTextLoopExitByBufferEnd() throws IOException, JsonParseException { [EOL] int c = INT_1; // Assuming INT_1 is a valid digit other than 0 [EOL] JsonToken result = parseNumberText(c); [EOL] }
public void testParseNumberTextWithDot() throws IOException, JsonParseException { [EOL] int c = '.'; [EOL] JsonToken result = parseNumberText(c); [EOL] }
public void testParseNumberTextWithExponent() throws IOException, JsonParseException { [EOL] int c = 'e'; [EOL] JsonToken result = parseNumberText(c); [EOL] }
public void testVerifyNoLeadingZeroesInputPtrAtEndAndLoadMoreFails() throws IOException, JsonParseException { [EOL] _inputPtr = _inputEnd; [EOL] when(loadMore()).thenReturn(false); [EOL] int result = _verifyNoLeadingZeroes(); [EOL] assertEquals(INT_0, result); [EOL] }
public void testVerifyNoLeadingZeroesInputPtrBeforeEndNonZero() throws IOException, JsonParseException { [EOL] _inputPtr = _inputEnd - 1; [EOL] _inputBuffer[_inputPtr] = (byte) '5'; [EOL] when(loadMore()).thenReturn(true); [EOL] when(isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)).thenReturn(true); [EOL] int result = _verifyNoLeadingZeroes(); [EOL] assertEquals('5', result); [EOL] }
public void testVerifyNoLeadingZeroesInputPtrBeforeEndLeadingZeroNotAllowed() throws IOException, JsonParseException { [EOL] _inputPtr = _inputEnd - 1; [EOL] _inputBuffer[_inputPtr] = (byte) '0'; [EOL] when(loadMore()).thenReturn(true); [EOL] when(isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)).thenReturn(false); [EOL] try { [EOL] _verifyNoLeadingZeroes(); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testVerifyNoLeadingZeroesInputPtrBeforeEndLeadingZeroAllowed() throws IOException, JsonParseException { [EOL] _inputPtr = _inputEnd - 1; [EOL] _inputBuffer[_inputPtr] = (byte) '0'; [EOL] when(loadMore()).thenReturn(true).thenReturn(false); [EOL] when(isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)).thenReturn(true); [EOL] int result = _verifyNoLeadingZeroes(); [EOL] assertEquals(INT_0, result); [EOL] }
public void testVerifyNoLeadingZeroesInputPtrBeforeEndLeadingZeroFollowedByNonZero() throws IOException, JsonParseException { [EOL] _inputPtr = _inputEnd - 2; [EOL] _inputBuffer[_inputPtr] = (byte) '0'; [EOL] _inputBuffer[_inputPtr + 1] = (byte) '1'; [EOL] when(loadMore()).thenReturn(true); [EOL] when(isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)).thenReturn(true); [EOL] int result = _verifyNoLeadingZeroes(); [EOL] assertEquals('1', result); [EOL] }
public void testParseFloatTextWithDotAndNoFraction() throws IOException, JsonParseException { [EOL] char[] outBuf = new char[100]; [EOL] int outPtr = 0; [EOL] int c = '.'; [EOL] boolean negative = false; [EOL] int integerPartLength = 1; [EOL] try { [EOL] _parseFloatText(outBuf, outPtr, c, negative, integerPartLength); [EOL] fail("Should not pass: decimal point not followed by a digit"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testParseFloatTextWithDotAndFraction() throws IOException, JsonParseException { [EOL] char[] outBuf = new char[100]; [EOL] int outPtr = 0; [EOL] int c = '.'; [EOL] boolean negative = false; [EOL] int integerPartLength = 1; [EOL] _inputPtr = 0; [EOL] _inputEnd = 3; // Simulate 3 more characters available [EOL] _inputBuffer = new char[] {'1', '1', '1'}; [EOL] JsonToken result = _parseFloatText(outBuf, outPtr, c, negative, integerPartLength); [EOL] assertEquals("Should parse the number correctly", JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
public void testParseFloatTextWithExponentNoSign() throws IOException, JsonParseException { [EOL] char[] outBuf = new char[100]; [EOL] int outPtr = 0; [EOL] int c = 'e'; [EOL] boolean negative = false; [EOL] int integerPartLength = 1; [EOL] _inputPtr = 0; [EOL] _inputEnd = 3; // Simulate 3 more characters available [EOL] _inputBuffer = new char[] {'2', '2', '2'}; [EOL] JsonToken result = _parseFloatText(outBuf, outPtr, c, negative, integerPartLength); [EOL] assertEquals("Should parse the number with exponent correctly", JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
public void testParseFloatTextWithExponentAndSign() throws IOException, JsonParseException { [EOL] char[] outBuf = new char[100]; [EOL] int outPtr = 0; [EOL] int c = 'e'; [EOL] boolean negative = false; [EOL] int integerPartLength = 1; [EOL] _inputPtr = 0; [EOL] _inputEnd = 4; // Simulate 4 more characters available [EOL] _inputBuffer = new char[] {'+', '3', '3', '3'}; [EOL] JsonToken result = _parseFloatText(outBuf, outPtr, c, negative, integerPartLength); [EOL] assertEquals("Should parse the number with signed exponent correctly", JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
public void testParseFloatTextWithInvalidExponent() throws IOException, JsonParseException { [EOL] char[] outBuf = new char[100]; [EOL] int outPtr = 0; [EOL] int c = 'e'; [EOL] boolean negative = false; [EOL] int integerPartLength = 1; [EOL] try { [EOL] _parseFloatText(outBuf, outPtr, c, negative, integerPartLength); [EOL] fail("Should not pass: exponent indicator not followed by a digit"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
protected Name _parseFieldName(int i) throws IOException, JsonParseException { [EOL] if (i != INT_QUOTE) { [EOL] return _handleUnusualFieldName(i); [EOL] } [EOL] if ((_inputPtr + 9) > _inputEnd) { [EOL] return slowParseFieldName(); [EOL] } [EOL] final byte[] input = _inputBuffer; [EOL] final int[] codes = sInputCodesLatin1; [EOL] int q = input[_inputPtr++] & 0xFF; [EOL] if (codes[q] == 0) { [EOL] i = input[_inputPtr++] & 0xFF; [EOL] if (codes[i] == 0) { [EOL] q = (q << 8) | i; [EOL] i = input[_inputPtr++] & 0xFF; [EOL] if (codes[i] == 0) { [EOL] q = (q << 8) | i; [EOL] i = input[_inputPtr++] & 0xFF; [EOL] if (codes[i] == 0) { [EOL] q = (q << 8) | i; [EOL] i = input[_inputPtr++] & 0xFF; [EOL] if (codes[i] == 0) { [EOL] _quad1 = q; [EOL] return parseMediumFieldName(i, codes); [EOL] } [EOL] if (i == INT_QUOTE) { [EOL] return findName(q, 4); [EOL] } [EOL] return parseFieldName(q, i, 4); [EOL] } [EOL] if (i == INT_QUOTE) { [EOL] return findName(q, 3); [EOL] } [EOL] return parseFieldName(q, i, 3); [EOL] } [EOL] if (i == INT_QUOTE) { [EOL] return findName(q, 2); [EOL] } [EOL] return parseFieldName(q, i, 2); [EOL] } [EOL] if (i == INT_QUOTE) { [EOL] return findName(q, 1); [EOL] } [EOL] return parseFieldName(q, i, 1); [EOL] } [EOL] if (q == INT_QUOTE) { [EOL] return BytesToNameCanonicalizer.getEmptyName(); [EOL] } [EOL] return parseFieldName(0, q, 0); [EOL] }
public void testSlowParseFieldNameInputPtrAtInputEndAndLoadMoreFails() throws IOException { [EOL] try { [EOL] slowParseFieldName(); [EOL] fail("Expected an IOException for end of input"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testSlowParseFieldNameInputPtrAtInputEndAndLoadMoreSucceeds() throws IOException { [EOL] try { [EOL] Name result = slowParseFieldName(); [EOL] assertNotNull(result); [EOL] } catch (IOException e) { [EOL] fail("Did not expect an IOException"); [EOL] } [EOL] }
public void testSlowParseFieldNameInputPtrNotAtInputEndAndNextCharIsQuote() throws IOException { [EOL] Name result = slowParseFieldName(); [EOL] assertNotNull(result); [EOL] }
private Name parseFieldName(int q1, int ch, int lastQuadBytes) throws IOException, JsonParseException { [EOL] return parseEscapedFieldName(_quadBuffer, 0, q1, ch, lastQuadBytes); [EOL] }
protected Name parseEscapedFieldName(int[] quads, int qlen, int currQuad, int ch, int currQuadBytes) throws IOException, JsonParseException { [EOL] final int[] codes = sInputCodesLatin1; [EOL] while (true) { [EOL] if (codes[ch] != 0) { [EOL] if (ch == INT_QUOTE) { [EOL] break; [EOL] } [EOL] if (ch != INT_BACKSLASH) { [EOL] _throwUnquotedSpace(ch, "name"); [EOL] } else { [EOL] ch = _decodeEscaped(); [EOL] } [EOL] if (ch > 127) { [EOL] if (currQuadBytes >= 4) { [EOL] if (qlen >= quads.length) { [EOL] _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL] } [EOL] quads[qlen++] = currQuad; [EOL] currQuad = 0; [EOL] currQuadBytes = 0; [EOL] } [EOL] if (ch < 0x800) { [EOL] currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); [EOL] ++currQuadBytes; [EOL] } else { [EOL] currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); [EOL] ++currQuadBytes; [EOL] if (currQuadBytes >= 4) { [EOL] if (qlen >= quads.length) { [EOL] _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL] } [EOL] quads[qlen++] = currQuad; [EOL] currQuad = 0; [EOL] currQuadBytes = 0; [EOL] } [EOL] currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); [EOL] ++currQuadBytes; [EOL] } [EOL] ch = 0x80 | (ch & 0x3f); [EOL] } [EOL] } [EOL] if (currQuadBytes < 4) { [EOL] ++currQuadBytes; [EOL] currQuad = (currQuad << 8) | ch; [EOL] } else { [EOL] if (qlen >= quads.length) { [EOL] _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL] } [EOL] quads[qlen++] = currQuad; [EOL] currQuad = ch; [EOL] currQuadBytes = 1; [EOL] } [EOL] if (_inputPtr >= _inputEnd) { [EOL] if (!loadMore()) { [EOL] _reportInvalidEOF(" in field name"); [EOL] } [EOL] } [EOL] ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL] } [EOL] if (currQuadBytes > 0) { [EOL] if (qlen >= quads.length) { [EOL] _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL] } [EOL] quads[qlen++] = currQuad; [EOL] } [EOL] Name name = _symbols.findName(quads, qlen); [EOL] if (name == null) { [EOL] name = addName(quads, qlen, currQuadBytes); [EOL] } [EOL] return name; [EOL] }
public void testFinishStringWithPtrAtInputEnd() throws IOException, JsonParseException { [EOL] _inputPtr = _inputEnd; [EOL] _finishString(); [EOL] }
public void testFinishStringWithPtrBeforeInputEnd() throws IOException, JsonParseException { [EOL] _inputPtr = _inputEnd - 1; [EOL] _inputBuffer[_inputPtr] = (byte) 'a'; // Non-special character that does not trigger any condition [EOL] _finishString(); [EOL] }
public void testFinishStringWithSpecialCharacter() throws IOException, JsonParseException { [EOL] _inputPtr = _inputEnd - 1; [EOL] _inputBuffer[_inputPtr] = INT_QUOTE; // Special character that triggers the condition [EOL] _finishString(); [EOL] }
private void _finishString2(char[] outBuf, int outPtr) throws IOException, JsonParseException { [EOL] int c; [EOL] final int[] codes = sInputCodesUtf8; [EOL] final byte[] inputBuffer = _inputBuffer; [EOL] main_loop: while (true) { [EOL] ascii_loop: while (true) { [EOL] int ptr = _inputPtr; [EOL] if (ptr >= _inputEnd) { [EOL] loadMoreGuaranteed(); [EOL] ptr = _inputPtr; [EOL] } [EOL] if (outPtr >= outBuf.length) { [EOL] outBuf = _textBuffer.finishCurrentSegment(); [EOL] outPtr = 0; [EOL] } [EOL] final int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr))); [EOL] while (ptr < max) { [EOL] c = (int) inputBuffer[ptr++] & 0xFF; [EOL] if (codes[c] != 0) { [EOL] _inputPtr = ptr; [EOL] break ascii_loop; [EOL] } [EOL] outBuf[outPtr++] = (char) c; [EOL] } [EOL] _inputPtr = ptr; [EOL] } [EOL] if (c == INT_QUOTE) { [EOL] break main_loop; [EOL] } [EOL] switch(codes[c]) { [EOL] case 1: [EOL] c = _decodeEscaped(); [EOL] break; [EOL] case 2: [EOL] c = _decodeUtf8_2(c); [EOL] break; [EOL] case 3: [EOL] if ((_inputEnd - _inputPtr) >= 2) { [EOL] c = _decodeUtf8_3fast(c); [EOL] } else { [EOL] c = _decodeUtf8_3(c); [EOL] } [EOL] break; [EOL] case 4: [EOL] c = _decodeUtf8_4(c); [EOL] outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL] if (outPtr >= outBuf.length) { [EOL] outBuf = _textBuffer.finishCurrentSegment(); [EOL] outPtr = 0; [EOL] } [EOL] c = 0xDC00 | (c & 0x3FF); [EOL] break; [EOL] default: [EOL] if (c < INT_SPACE) { [EOL] _throwUnquotedSpace(c, "string value"); [EOL] } else { [EOL] _reportInvalidChar(c); [EOL] } [EOL] } [EOL] if (outPtr >= outBuf.length) { [EOL] outBuf = _textBuffer.finishCurrentSegment(); [EOL] outPtr = 0; [EOL] } [EOL] outBuf[outPtr++] = (char) c; [EOL] } [EOL] _textBuffer.setCurrentLength(outPtr); [EOL] }
public void testHandleUnexpectedValueWithSingleQuoteAllowed() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFeatureEnabled(Feature.ALLOW_SINGLE_QUOTES); [EOL] JsonToken result = parser._handleUnexpectedValue('\''); [EOL] assertEquals(JsonToken.VALUE_STRING, result); [EOL] }
public void testHandleUnexpectedValueWithNaNAllowed() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFeatureEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS); [EOL] JsonToken result = parser._handleUnexpectedValue('N'); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
public void testHandleUnexpectedValueWithInfinityAllowed() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFeatureEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS); [EOL] JsonToken result = parser._handleUnexpectedValue('I'); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
public void testHandleUnexpectedValueWithPlusSignAndNoMoreInput() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithInputEndingWith('+'); [EOL] try { [EOL] parser._handleUnexpectedValue('+'); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleUnexpectedValueWithJavaIdentifierStart() throws IOException, JsonParseException { [EOL] JsonParser parser = createParser(); [EOL] char javaIdentifierStartChar = 'a'; // Assuming 'a' is a valid Java identifier start character [EOL] try { [EOL] parser._handleUnexpectedValue(javaIdentifierStartChar); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleUnexpectedValueWithUnexpectedChar() throws IOException, JsonParseException { [EOL] JsonParser parser = createParser(); [EOL] int unexpectedChar = '%'; // Assuming '%' is not a valid Java identifier start character [EOL] try { [EOL] parser._handleUnexpectedValue(unexpectedChar); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleInvalidNumberStartWithIAndN() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithContent("IN"); [EOL] int ch = 'I'; [EOL] boolean neg = false; [EOL] JsonToken result = parser._handleInvalidNumberStart(ch, neg); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] assertEquals("+INF", parser.getText()); [EOL] }
public void testHandleInvalidNumberStartWithIAndLowerN() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithContent("In"); [EOL] int ch = 'I'; [EOL] boolean neg = false; [EOL] JsonToken result = parser._handleInvalidNumberStart(ch, neg); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] assertEquals("+Infinity", parser.getText()); [EOL] }
public void testHandleInvalidNumberStartWithIAndNAndNegative() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithContent("-IN"); [EOL] int ch = 'I'; [EOL] boolean neg = true; [EOL] JsonToken result = parser._handleInvalidNumberStart(ch, neg); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] assertEquals("-INF", parser.getText()); [EOL] }
public void testHandleInvalidNumberStartWithIAndLowerNAndNegative() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithContent("-In"); [EOL] int ch = 'I'; [EOL] boolean neg = true; [EOL] JsonToken result = parser._handleInvalidNumberStart(ch, neg); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] assertEquals("-Infinity", parser.getText()); [EOL] }
public void testHandleInvalidNumberStartWithNonINorN() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithContent("IA"); [EOL] int ch = 'I'; [EOL] boolean neg = false; [EOL] try { [EOL] parser._handleInvalidNumberStart(ch, neg); [EOL] fail("Should throw JsonParseException for non-matching character after 'I'"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleInvalidNumberStartWithNonINorNAndNegative() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithContent("-IA"); [EOL] int ch = 'I'; [EOL] boolean neg = true; [EOL] try { [EOL] parser._handleInvalidNumberStart(ch, neg); [EOL] fail("Should throw JsonParseException for non-matching character after 'I'"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleInvalidNumberStartWithEOF() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithContent(""); [EOL] int ch = 'I'; [EOL] boolean neg = false; [EOL] try { [EOL] parser._handleInvalidNumberStart(ch, neg); [EOL] fail("Should throw IOException for EOF"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testHandleInvalidNumberStartWithUnexpectedChar() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithContent("A"); [EOL] int ch = 'A'; [EOL] boolean neg = false; [EOL] try { [EOL] parser._handleInvalidNumberStart(ch, neg); [EOL] fail("Should throw JsonParseException for unexpected character"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
private int _skipColon() throws IOException, JsonParseException { [EOL] if (_inputPtr >= _inputEnd) { [EOL] loadMoreGuaranteed(); [EOL] } [EOL] int i = _inputBuffer[_inputPtr++]; [EOL] if (i == INT_COLON) { [EOL] if (_inputPtr < _inputEnd) { [EOL] i = _inputBuffer[_inputPtr] & 0xFF; [EOL] if (i > INT_SPACE && i != INT_SLASH) { [EOL] ++_inputPtr; [EOL] return i; [EOL] } [EOL] } [EOL] } else { [EOL] i &= 0xFF; [EOL] space_loop: while (true) { [EOL] switch(i) { [EOL] case INT_SPACE: [EOL] case INT_TAB: [EOL] break; [EOL] case INT_CR: [EOL] _skipCR(); [EOL] break; [EOL] case INT_LF: [EOL] _skipLF(); [EOL] break; [EOL] case INT_SLASH: [EOL] _skipComment(); [EOL] break; [EOL] default: [EOL] if (i < INT_SPACE) { [EOL] _throwInvalidSpace(i); [EOL] } [EOL] break space_loop; [EOL] } [EOL] if (_inputPtr >= _inputEnd) { [EOL] loadMoreGuaranteed(); [EOL] } [EOL] i = _inputBuffer[_inputPtr++] & 0xFF; [EOL] } [EOL] if (i != INT_COLON) { [EOL] _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL] } [EOL] } [EOL] while (_inputPtr < _inputEnd || loadMore()) { [EOL] i = _inputBuffer[_inputPtr++] & 0xFF; [EOL] if (i > INT_SPACE) { [EOL] if (i != INT_SLASH) { [EOL] return i; [EOL] } [EOL] _skipComment(); [EOL] } else if (i != INT_SPACE) { [EOL] if (i == INT_LF) { [EOL] _skipLF(); [EOL] } else if (i == INT_CR) { [EOL] _skipCR(); [EOL] } else if (i != INT_TAB) { [EOL] _throwInvalidSpace(i); [EOL] } [EOL] } [EOL] } [EOL] throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
public void testDecodeEscapedInputPtrAtOrBeyondInputEndAndLoadMoreFails() throws IOException { [EOL] _inputPtr = 10; [EOL] _inputEnd = 10; [EOL] Mockito.when(loadMore()).thenReturn(false); [EOL] try { [EOL] char result = _decodeEscaped(); [EOL] fail("Expected an IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testDecodeEscapedWithRecognizedEscapeCharacter() throws IOException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 2; [EOL] _inputBuffer = new char[]{'\\', 'n'}; [EOL] char result = _decodeEscaped(); [EOL] assertEquals('\n', result); [EOL] }
public void testDecodeEscapedWithUnrecognizedEscapeCharacter() throws IOException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 2; [EOL] _inputBuffer = new char[]{'\\', 'x'}; [EOL] char expectedChar = 'X'; [EOL] Mockito.when(_handleUnrecognizedCharacterEscape((char) _decodeCharForError('x'))).thenReturn(expectedChar); [EOL] char result = _decodeEscaped(); [EOL] assertEquals(expectedChar, result); [EOL] }
public void testDecodeEscapedWithUnicodeEscapeSequence() throws IOException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 6; [EOL] _inputBuffer = new char[]{'\\', 'u', '0', '0', '2', '0'}; [EOL] char result = _decodeEscaped(); [EOL] assertEquals(' ', result); [EOL] }
public void testDecodeEscapedWithIncompleteUnicodeEscapeSequence() throws IOException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 3; [EOL] _inputBuffer = new char[]{'\\', 'u', '0'}; [EOL] Mockito.when(loadMore()).thenReturn(false); [EOL] try { [EOL] char result = _decodeEscaped(); [EOL] fail("Expected an IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException { [EOL] ByteArrayBuilder builder = _getByteArrayBuilder(); [EOL] while (true) { [EOL] int ch; [EOL] do { [EOL] if (_inputPtr >= _inputEnd) { [EOL] loadMoreGuaranteed(); [EOL] } [EOL] ch = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL] } while (ch <= INT_SPACE); [EOL] int bits = b64variant.decodeBase64Char(ch); [EOL] if (bits < 0) { [EOL] if (ch == INT_QUOTE) { [EOL] return builder.toByteArray(); [EOL] } [EOL] bits = _decodeBase64Escape(b64variant, ch, 0); [EOL] if (bits < 0) { [EOL] continue; [EOL] } [EOL] } [EOL] int decodedData = bits; [EOL] if (_inputPtr >= _inputEnd) { [EOL] loadMoreGuaranteed(); [EOL] } [EOL] ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL] bits = b64variant.decodeBase64Char(ch); [EOL] if (bits < 0) { [EOL] bits = _decodeBase64Escape(b64variant, ch, 1); [EOL] } [EOL] decodedData = (decodedData << 6) | bits; [EOL] if (_inputPtr >= _inputEnd) { [EOL] loadMoreGuaranteed(); [EOL] } [EOL] ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL] bits = b64variant.decodeBase64Char(ch); [EOL] if (bits < 0) { [EOL] if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL] if (ch == '"' && !b64variant.usesPadding()) { [EOL] decodedData >>= 4; [EOL] builder.append(decodedData); [EOL] return builder.toByteArray(); [EOL] } [EOL] bits = _decodeBase64Escape(b64variant, ch, 2); [EOL] } [EOL] if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL] if (_inputPtr >= _inputEnd) { [EOL] loadMoreGuaranteed(); [EOL] } [EOL] ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL] if (!b64variant.usesPaddingChar(ch)) { [EOL] throw reportInvalidBase64Char(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL] } [EOL] decodedData >>= 4; [EOL] builder.append(decodedData); [EOL] continue; [EOL] } [EOL] } [EOL] decodedData = (decodedData << 6) | bits; [EOL] if (_inputPtr >= _inputEnd) { [EOL] loadMoreGuaranteed(); [EOL] } [EOL] ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL] bits = b64variant.decodeBase64Char(ch); [EOL] if (bits < 0) { [EOL] if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL] if (ch == '"' && !b64variant.usesPadding()) { [EOL] decodedData >>= 2; [EOL] builder.appendTwoBytes(decodedData); [EOL] return builder.toByteArray(); [EOL] } [EOL] bits = _decodeBase64Escape(b64variant, ch, 3); [EOL] } [EOL] if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL] decodedData >>= 2; [EOL] builder.appendTwoBytes(decodedData); [EOL] continue; [EOL] } [EOL] } [EOL] decodedData = (decodedData << 6) | bits; [EOL] builder.appendThreeBytes(decodedData); [EOL] } [EOL] }
public void testUTF32ReaderWithBigEndian() { [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), new File("test"), false); [EOL] InputStream in = new ByteArrayInputStream(new byte[0]); [EOL] byte[] buf = new byte[8]; [EOL] int ptr = 0; [EOL] int len = buf.length; [EOL] boolean isBigEndian = true; [EOL] UTF32Reader reader = new UTF32Reader(ctxt, in, buf, ptr, len, isBigEndian); [EOL] assertTrue(reader._bigEndian); [EOL] assertTrue(reader._managedBuffers); [EOL] }
public void testUTF32ReaderWithLittleEndian() { [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), new File("test"), false); [EOL] InputStream in = new ByteArrayInputStream(new byte[0]); [EOL] byte[] buf = new byte[8]; [EOL] int ptr = 0; [EOL] int len = buf.length; [EOL] boolean isBigEndian = false; [EOL] UTF32Reader reader = new UTF32Reader(ctxt, in, buf, ptr, len, isBigEndian); [EOL] assertFalse(reader._bigEndian); [EOL] assertTrue(reader._managedBuffers); [EOL] }
public void testUTF32ReaderWithNullInputStream() { [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), new File("test"), false); [EOL] InputStream in = null; [EOL] byte[] buf = new byte[8]; [EOL] int ptr = 0; [EOL] int len = buf.length; [EOL] boolean isBigEndian = true; [EOL] UTF32Reader reader = new UTF32Reader(ctxt, in, buf, ptr, len, isBigEndian); [EOL] assertTrue(reader._bigEndian); [EOL] assertFalse(reader._managedBuffers); [EOL] }
public void testReadWithNullBuffer() throws IOException { [EOL] char[] cbuf = new char[10]; [EOL] int start = 0; [EOL] int len = 5; [EOL] YourReaderClass reader = new YourReaderClass(null); [EOL] int result = reader.read(cbuf, start, len); [EOL] assertEquals(-1, result); [EOL] }
public void testReadWithNegativeLength() throws IOException { [EOL] char[] cbuf = new char[10]; [EOL] int start = 0; [EOL] int len = -1; [EOL] YourReaderClass reader = new YourReaderClass(new byte[10]); [EOL] int result = reader.read(cbuf, start, len); [EOL] assertEquals(len, result); [EOL] }
public void testReadWithOutOfBounds() throws IOException { [EOL] char[] cbuf = new char[10]; [EOL] int start = 11; [EOL] int len = 1; [EOL] YourReaderClass reader = new YourReaderClass(new byte[10]); [EOL] try { [EOL] reader.read(cbuf, start, len); [EOL] fail("Should have thrown an exception due to out of bounds"); [EOL] } catch (ArrayIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testReadWithSurrogateHandling() throws IOException { [EOL] char[] cbuf = new char[10]; [EOL] int start = 0; [EOL] int len = 5; [EOL] YourReaderClass reader = new YourReaderClass(new byte[10]); [EOL] reader.setSurrogate('a'); [EOL] int result = reader.read(cbuf, start, len); [EOL] assertEquals(1, result); [EOL] assertEquals('a', cbuf[start]); [EOL] }
public void testReadWithInsufficientBufferLength() throws IOException { [EOL] char[] cbuf = new char[10]; [EOL] int start = 0; [EOL] int len = 10; [EOL] YourReaderClass reader = new YourReaderClass(new byte[3]); [EOL] int result = reader.read(cbuf, start, len); [EOL] assertEquals(-1, result); [EOL] }
public void testReadWithBigEndianTrue() throws IOException { [EOL] char[] cbuf = new char[10]; [EOL] int start = 0; [EOL] int len = 10; [EOL] byte[] buffer = new byte[] {0, 0, 0, 1, 0, 0, 0, 2}; [EOL] YourReaderClass reader = new YourReaderClass(buffer); [EOL] reader.setBigEndian(true); [EOL] int result = reader.read(cbuf, start, len); [EOL] assertTrue(result > 0); [EOL] assertEquals(1, cbuf[start]); [EOL] assertEquals(2, cbuf[start + 1]); [EOL] }
public void testReadWithBigEndianFalse() throws IOException { [EOL] char[] cbuf = new char[10]; [EOL] int start = 0; [EOL] int len = 10; [EOL] byte[] buffer = new byte[] {1, 0, 0, 0, 2, 0, 0, 0}; [EOL] YourReaderClass reader = new YourReaderClass(buffer); [EOL] reader.setBigEndian(false); [EOL] int result = reader.read(cbuf, start, len); [EOL] assertTrue(result > 0); [EOL] assertEquals(1, cbuf[start]); [EOL] assertEquals(2, cbuf[start + 1]); [EOL] }
public void testReadWithInvalidUnicodeChar() throws IOException { [EOL] char[] cbuf = new char[10]; [EOL] int start = 0; [EOL] int len = 10; [EOL] byte[] buffer = new byte[] {(byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF}; [EOL] YourReaderClass reader = new YourReaderClass(buffer); [EOL] reader.setBigEndian(true); [EOL] try { [EOL] reader.read(cbuf, start, len); [EOL] fail("Should have thrown an exception due to invalid unicode character"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testReadWithEndOfBuffer() throws IOException { [EOL] char[] cbuf = new char[10]; [EOL] int start = 0; [EOL] int len = 10; [EOL] byte[] buffer = new byte[] {0, 0, 0, 1}; [EOL] YourReaderClass reader = new YourReaderClass(buffer); [EOL] reader.setBigEndian(true); [EOL] int result = reader.read(cbuf, start, len); [EOL] assertEquals(1, result); [EOL] assertEquals(1, cbuf[start]); [EOL] }
public void testLoadMoreWithAvailableGreaterThanZeroAndPtrGreaterThanZero() throws IOException { [EOL] _buffer = new byte[10]; [EOL] _ptr = 1; [EOL] _length = 5; [EOL] _byteCount = 0; [EOL] int available = 3; [EOL] boolean result = loadMore(available); [EOL] assertEquals("The byte count should be increased by the difference of _length and available", _length - available, _byteCount); [EOL] assertEquals("The _ptr should be reset to 0", 0, _ptr); [EOL] assertEquals("The _length should be set to available", available, _length); [EOL] assertTrue("The result should be true when available is greater than 0", result); [EOL] }
public void testLoadMoreWithAvailableEqualToZeroAndInputStreamIsNull() throws IOException { [EOL] _buffer = new byte[10]; [EOL] _ptr = 0; [EOL] _length = 5; [EOL] _byteCount = 0; [EOL] _managedBuffers = false; [EOL] _in = null; [EOL] int available = 0; [EOL] boolean result = loadMore(available); [EOL] assertEquals("The _ptr should be reset to 0", 0, _ptr); [EOL] assertEquals("The _length should be set to 0", 0, _length); [EOL] assertFalse("The result should be false when _in is null and available is 0", result); [EOL] }
public void testLoadMoreWithAvailableEqualToZeroAndInputStreamReadReturnsNegative() throws IOException { [EOL] _buffer = new byte[10]; [EOL] _ptr = 0; [EOL] _length = 5; [EOL] _byteCount = 0; [EOL] _managedBuffers = true; [EOL] _in = mock(InputStream.class); [EOL] when(_in.read(_buffer)).thenReturn(-1); [EOL] int available = 0; [EOL] boolean result = loadMore(available); [EOL] assertEquals("The _ptr should be reset to 0", 0, _ptr); [EOL] assertEquals("The _length should be set to 0", 0, _length); [EOL] assertFalse("The result should be false when read returns negative", result); [EOL] verify(freeBuffers(), times(1)); [EOL] }
public void testLoadMoreWithLengthLessThanFourAndInputStreamReadReturnsNegative() throws IOException { [EOL] _buffer = new byte[10]; [EOL] _ptr = 0; [EOL] _length = 3; [EOL] _byteCount = 0; [EOL] _managedBuffers = true; [EOL] _in = mock(InputStream.class); [EOL] when(_in.read(_buffer, _length, _buffer.length - _length)).thenReturn(-1); [EOL] int available = 0; [EOL] boolean result = loadMore(available); [EOL] assertEquals("The _length should not reach 4", 3, _length); [EOL] assertFalse("The result should be false when read returns negative and _length is less than 4", result); [EOL] verify(freeBuffers(), times(1)); [EOL] verify(reportUnexpectedEOF(_length, 4), times(1)); [EOL] }
public void testAsQuotedUTF8WhenCached() { [EOL] JsonStringEncoderTestClass jsonStringEncoder = new JsonStringEncoderTestClass("testValue"); [EOL] byte[] expected = new byte[]{/* some byte array representing "testValue" in UTF-8 */}; [EOL] jsonStringEncoder._quotedUTF8Ref = expected; [EOL] byte[] result = jsonStringEncoder.asQuotedUTF8(); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testAsQuotedUTF8WhenNotCached() { [EOL] JsonStringEncoderTestClass jsonStringEncoder = new JsonStringEncoderTestClass("testValue"); [EOL] byte[] expected = new byte[]{/* some byte array representing "testValue" in UTF-8 */}; [EOL] byte[] result = jsonStringEncoder.asQuotedUTF8(); [EOL] assertArrayEquals(expected, result); [EOL] assertNotNull(jsonStringEncoder._quotedUTF8Ref); [EOL] assertArrayEquals(expected, jsonStringEncoder._quotedUTF8Ref); [EOL] }
public void testGetEncoding() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonEncoding encoding = factory.getEncoding(); [EOL] assertNull(encoding); [EOL] }
public void testFindFormat_NoDetectors() throws IOException { [EOL] InputAccessor.Std acc = mock(InputAccessor.Std.class); [EOL] DataFormatMatcher matcher = _findFormat(acc); [EOL] assertNull(matcher.getMatchedFormat()); [EOL] }
public void testFindFormat_WithDetectors_NoMatch() throws IOException { [EOL] InputAccessor.Std acc = mock(InputAccessor.Std.class); [EOL] JsonFactory factory = mock(JsonFactory.class); [EOL] when(factory.hasFormat(acc)).thenReturn(null); [EOL] _detectors.add(factory); [EOL] DataFormatMatcher matcher = _findFormat(acc); [EOL] assertNull(matcher.getMatchedFormat()); [EOL] }
public void testFindFormat_WithDetectors_BelowMinimalMatch() throws IOException { [EOL] InputAccessor.Std acc = mock(InputAccessor.Std.class); [EOL] JsonFactory factory = mock(JsonFactory.class); [EOL] when(factory.hasFormat(acc)).thenReturn(MatchStrength.WEAK); [EOL] _detectors.add(factory); [EOL] _minimalMatch = MatchStrength.SOLID_MATCH; [EOL] DataFormatMatcher matcher = _findFormat(acc); [EOL] assertNull(matcher.getMatchedFormat()); [EOL] }
public void testFindFormat_WithDetectors_AboveMinimalMatch() throws IOException { [EOL] InputAccessor.Std acc = mock(InputAccessor.Std.class); [EOL] JsonFactory factory = mock(JsonFactory.class); [EOL] when(factory.hasFormat(acc)).thenReturn(MatchStrength.SOLID_MATCH); [EOL] _detectors.add(factory); [EOL] _minimalMatch = MatchStrength.WEAK; [EOL] DataFormatMatcher matcher = _findFormat(acc); [EOL] assertNotNull(matcher.getMatchedFormat()); [EOL] }
public void testFindFormat_WithMultipleDetectors_SelectBestMatch() throws IOException { [EOL] InputAccessor.Std acc = mock(InputAccessor.Std.class); [EOL] JsonFactory factory1 = mock(JsonFactory.class); [EOL] JsonFactory factory2 = mock(JsonFactory.class); [EOL] when(factory1.hasFormat(acc)).thenReturn(MatchStrength.SOLID_MATCH); [EOL] when(factory2.hasFormat(acc)).thenReturn(MatchStrength.FULL_MATCH); [EOL] _detectors.add(factory1); [EOL] _detectors.add(factory2); [EOL] _minimalMatch = MatchStrength.WEAK; [EOL] _optimalMatch = MatchStrength.FULL_MATCH; [EOL] DataFormatMatcher matcher = _findFormat(acc); [EOL] assertEquals(factory2, matcher.getMatchedFactory()); [EOL] }
public void testFindFormat_WithMultipleDetectors_StopAtOptimalMatch() throws IOException { [EOL] InputAccessor.Std acc = mock(InputAccessor.Std.class); [EOL] JsonFactory factory1 = mock(JsonFactory.class); [EOL] JsonFactory factory2 = mock(JsonFactory.class); [EOL] when(factory1.hasFormat(acc)).thenReturn(MatchStrength.FULL_MATCH); [EOL] when(factory2.hasFormat(acc)).thenReturn(MatchStrength.FULL_MATCH); [EOL] _detectors.add(factory1); [EOL] _detectors.add(factory2); [EOL] _minimalMatch = MatchStrength.WEAK; [EOL] _optimalMatch = MatchStrength.FULL_MATCH; [EOL] DataFormatMatcher matcher = _findFormat(acc); [EOL] assertEquals(factory1, matcher.getMatchedFactory()); [EOL] }
public void testEnableFeature() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser parser = factory.createParser("{}"); [EOL] int initialFeatures = parser.getFeatureMask(); [EOL] JsonParser.Feature featureToEnable = JsonParser.Feature.AUTO_CLOSE_SOURCE; [EOL] parser.enable(featureToEnable); [EOL] int newFeatures = parser.getFeatureMask(); [EOL] assertTrue((newFeatures & featureToEnable.getMask()) != 0); [EOL] assertTrue((initialFeatures & featureToEnable.getMask()) == 0); [EOL] }
public void testEnableFeatureAlreadyEnabled() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser parser = factory.createParser("{}"); [EOL] JsonParser.Feature featureToEnable = JsonParser.Feature.AUTO_CLOSE_SOURCE; [EOL] parser.enable(featureToEnable); [EOL] int featuresAfterFirstEnable = parser.getFeatureMask(); [EOL] parser.enable(featureToEnable); [EOL] int featuresAfterSecondEnable = parser.getFeatureMask(); [EOL] assertEquals(featuresAfterFirstEnable, featuresAfterSecondEnable); [EOL] }
public void testDisableFeatureWhenFeatureIsEnabled() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser parser = factory.createParser("{}"); [EOL] Feature featureToDisable = Feature.AUTO_CLOSE_SOURCE; [EOL] parser.enable(featureToDisable); [EOL] parser.disable(featureToDisable); [EOL] int expectedFeatures = parser.getFeatureMask() & ~featureToDisable.getMask(); [EOL] assertEquals(expectedFeatures, parser.getFeatureMask()); [EOL] }
public void testDisableFeatureWhenFeatureIsAlreadyDisabled() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser parser = factory.createParser("{}"); [EOL] Feature featureToDisable = Feature.AUTO_CLOSE_SOURCE; [EOL] parser.disable(featureToDisable); [EOL] int expectedFeatures = parser.getFeatureMask() & ~featureToDisable.getMask(); [EOL] assertEquals(expectedFeatures, parser.getFeatureMask()); [EOL] }
public void testConfigureEnableFeature() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser parser = factory.createParser(""); [EOL] assertFalse(parser.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL] parser.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, true); [EOL] assertTrue(parser.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL] }
public void testConfigureDisableFeature() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser parser = factory.createParser(""); [EOL] parser.enable(JsonParser.Feature.AUTO_CLOSE_SOURCE); [EOL] assertTrue(parser.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL] parser.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, false); [EOL] assertFalse(parser.isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)); [EOL] }
public void testIsEnabledWithFeatureEnabled() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] Feature feature = Feature.AUTO_CLOSE_TARGET; [EOL] factory.enable(feature); [EOL] assertTrue(factory.isEnabled(feature)); [EOL] }
public void testIsEnabledWithFeatureDisabled() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] Feature feature = Feature.AUTO_CLOSE_TARGET; [EOL] factory.disable(feature); [EOL] assertFalse(factory.isEnabled(feature)); [EOL] }
public void testGetBinaryValue() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithBinaryContent(); [EOL] parser.nextToken(); // Assuming the binary content is the first token [EOL] byte[] binaryValue = parser.getBinaryValue(); [EOL] assertNotNull(binaryValue); [EOL] }
private JsonParser createParserWithBinaryContent() { [EOL] return null; // Placeholder for actual implementation [EOL] }
public void testSetHighestNonEscapedChar_NegativeValue() { [EOL] JsonGenerator gen = createJsonGenerator(); [EOL] gen.setHighestNonEscapedChar(-1); [EOL] assertEquals(0, gen.getHighestNonEscapedChar()); [EOL] }
public void testSetHighestNonEscapedChar_PositiveValue() { [EOL] JsonGenerator gen = createJsonGenerator(); [EOL] gen.setHighestNonEscapedChar(127); [EOL] assertEquals(127, gen.getHighestNonEscapedChar()); [EOL] }
public void testTextBufferConstructorWithNullAllocator() { [EOL] TextBuffer textBuffer = new TextBuffer(null); [EOL] assertNull(textBuffer.getAllocator()); [EOL] }
public void testTextBufferConstructorWithNonNullAllocator() { [EOL] BufferRecycler allocator = new BufferRecycler(); [EOL] TextBuffer textBuffer = new TextBuffer(allocator); [EOL] assertSame(allocator, textBuffer.getAllocator()); [EOL] }
public void testFindBufferWithAllocator() { [EOL] BufferRecycler recycler = Mockito.mock(BufferRecycler.class); [EOL] char[] mockBuffer = new char[10]; [EOL] Mockito.when(recycler.allocCharBuffer(BufferRecycler.CharBufferType.TEXT_BUFFER, 5)).thenReturn(mockBuffer); [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory._allocator = recycler; [EOL] char[] buffer = factory.findBuffer(5); [EOL] assertSame("Buffer should come from allocator", mockBuffer, buffer); [EOL] }
public void testFindBufferWithoutAllocator() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory._allocator = null; [EOL] char[] buffer = factory.findBuffer(5); [EOL] assertNotNull("Buffer should not be null", buffer); [EOL] assertTrue("Buffer length should be at least 5", buffer.length >= 5); [EOL] }
public void testFindBufferWithMinimumSegmentLength() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory._allocator = null; [EOL] final int MIN_SEGMENT_LEN = 1000; // Assuming MIN_SEGMENT_LEN is a static final int in the JsonFactory class [EOL] char[] buffer = factory.findBuffer(5); [EOL] assertTrue("Buffer length should be at least MIN_SEGMENT_LEN", buffer.length >= MIN_SEGMENT_LEN); [EOL] }
public void testSizeWithInputStartGreaterThanOrEqualToZero() { [EOL] MyClass instance = new MyClass(0, 10); // _inputStart >= 0, _inputLen = 10 [EOL] int result = instance.size(); [EOL] assert result == 10; // Assert that the size is equal to _inputLen [EOL] }
public void testSizeWithResultArrayNotNull() { [EOL] MyClass instance = new MyClass(); [EOL] instance.setResultArray(new int[5]); // _resultArray.length = 5 [EOL] int result = instance.size(); [EOL] assert result == 5; // Assert that the size is equal to _resultArray.length [EOL] }
public void testSizeWithResultStringNotNull() { [EOL] MyClass instance = new MyClass(); [EOL] instance.setResultString("Hello"); // _resultString.length() = 5 [EOL] int result = instance.size(); [EOL] assert result == 5; // Assert that the size is equal to _resultString.length() [EOL] }
public void testSizeWithSegmentSizeAndCurrentSize() { [EOL] MyClass instance = new MyClass(); [EOL] instance.setSegmentSizeAndCurrentSize(3, 7); // _segmentSize = 3, _currentSize = 7 [EOL] int result = instance.size(); [EOL] assert result == 10; // Assert that the size is equal to _segmentSize + _currentSize [EOL] }
public void testContentsAsString_ResultStringNullAndResultArrayNotNull() { [EOL] instance._resultString = null; [EOL] instance._resultArray = new char[]{'a', 'b', 'c'}; [EOL] String result = instance.contentsAsString(); [EOL] assertEquals("abc", result); [EOL] }
public void testContentsAsString_ResultStringNullAndInputStartNotNegative() { [EOL] instance._resultString = null; [EOL] instance._resultArray = null; [EOL] instance._inputStart = 0; [EOL] instance._inputBuffer = new char[]{'x', 'y', 'z'}; [EOL] instance._inputLen = 3; [EOL] String result = instance.contentsAsString(); [EOL] assertEquals("xyz", result); [EOL] }
public void testContentsAsString_ResultStringNullAndInputLenLessThanOne() { [EOL] instance._resultString = null; [EOL] instance._resultArray = null; [EOL] instance._inputStart = 0; [EOL] instance._inputLen = 0; [EOL] String result = instance.contentsAsString(); [EOL] assertEquals("", result); [EOL] }
public void testContentsAsString_ResultStringNullAndSegmentSizeZeroAndCurrentSizeZero() { [EOL] instance._resultString = null; [EOL] instance._resultArray = null; [EOL] instance._inputStart = -1; [EOL] instance._segmentSize = 0; [EOL] instance._currentSize = 0; [EOL] String result = instance.contentsAsString(); [EOL] assertEquals("", result); [EOL] }
public void testContentsAsString_ResultStringNullAndSegmentSizeZeroAndCurrentSizeNotZero() { [EOL] instance._resultString = null; [EOL] instance._resultArray = null; [EOL] instance._inputStart = -1; [EOL] instance._segmentSize = 0; [EOL] instance._currentSize = 2; [EOL] instance._currentSegment = new char[]{'u', 'v'}; [EOL] String result = instance.contentsAsString(); [EOL] assertEquals("uv", result); [EOL] }
public void testContentsAsString_ResultStringNullAndSegmentsNotNull() { [EOL] instance._resultString = null; [EOL] instance._resultArray = null; [EOL] instance._inputStart = -1; [EOL] instance._segmentSize = 1; [EOL] instance._currentSize = 1; [EOL] instance._currentSegment = new char[]{'w'}; [EOL] instance._segments = new ArrayList<>(); [EOL] instance._segments.add(new char[]{'t'}); [EOL] String result = instance.contentsAsString(); [EOL] assertEquals("tw", result); [EOL] }
public void testContentsAsString_ResultStringNotNull() { [EOL] instance._resultString = "precomputed"; [EOL] String result = instance.contentsAsString(); [EOL] assertEquals("precomputed", result); [EOL] }
public void testContentsAsArrayWhenResultArrayIsNull() { [EOL] instance._resultArray = null; [EOL] char[] result = instance.contentsAsArray(); [EOL] assertNotNull(result); [EOL] char[] expected = instance.buildResultArray(); [EOL] assertArrayEquals(expected, result); [EOL] }
public void testContentsAsArrayWhenResultArrayIsNotNull() { [EOL] char[] initialArray = new char[]{'a', 'b', 'c'}; [EOL] instance._resultArray = initialArray; [EOL] char[] result = instance.contentsAsArray(); [EOL] assertSame(initialArray, result); [EOL] }
public void testAppendWithInputStartNegative() { [EOL] TextBuffer buffer = new TextBuffer(null); // Assuming constructor exists [EOL] buffer._inputStart = -1; // Assuming _inputStart is accessible or use a setter [EOL] buffer._currentSegment = new char[10]; // Assuming _currentSegment is accessible or use a setter [EOL] buffer._currentSize = 5; // Assuming _currentSize is accessible or use a setter [EOL] buffer.append('a'); [EOL] assertEquals(6, buffer._currentSize); [EOL] assertEquals('a', buffer._currentSegment[5]); [EOL] }
public void testAppendWithInputStartNonNegative() { [EOL] TextBuffer buffer = new TextBuffer(null); // Assuming constructor exists [EOL] buffer._inputStart = 1; // Assuming _inputStart is accessible or use a setter [EOL] buffer._currentSegment = new char[10]; // Assuming _currentSegment is accessible or use a setter [EOL] buffer._currentSize = 5; // Assuming _currentSize is accessible or use a setter [EOL] buffer.append('a'); [EOL] assertEquals(-1, buffer._inputStart); [EOL] assertEquals(null, buffer._resultString); [EOL] assertEquals(null, buffer._resultArray); [EOL] assertEquals(6, buffer._currentSize); [EOL] assertEquals('a', buffer._currentSegment[5]); [EOL] }
public void testAppendWithCurrentSegmentFull() { [EOL] TextBuffer buffer = new TextBuffer(null); // Assuming constructor exists [EOL] buffer._inputStart = -1; // Assuming _inputStart is accessible or use a setter [EOL] buffer._currentSegment = new char[1]; // Assuming _currentSegment is accessible or use a setter [EOL] buffer._currentSize = 1; // Assuming _currentSize is accessible or use a setter [EOL] buffer.append('a'); [EOL] assertTrue(buffer._currentSize > 1); [EOL] assertEquals('a', buffer._currentSegment[buffer._currentSize - 1]); [EOL] }
public void testAppendWithInputStartNegative() { [EOL] TextBuffer buffer = new TextBuffer(-1, new char[10], 0, null, null); [EOL] char[] input = new char[]{'a', 'b', 'c'}; [EOL] buffer.append(input, 0, 3); [EOL] assertEquals("abc", new String(buffer.getCurrentSegment(), 0, buffer.getCurrentSize())); [EOL] }
public void testAppendWithInputStartNonNegativeAndEnoughSpace() { [EOL] TextBuffer buffer = new TextBuffer(0, new char[10], 0, null, null); [EOL] char[] input = new char[]{'a', 'b', 'c'}; [EOL] buffer.append(input, 0, 3); [EOL] assertEquals("abc", new String(buffer.getCurrentSegment(), 0, buffer.getCurrentSize())); [EOL] }
public void testAppendWithInputStartNonNegativeAndPartialSpace() { [EOL] TextBuffer buffer = new TextBuffer(0, new char[5], 3, null, null); [EOL] buffer.getCurrentSegment()[0] = 'x'; [EOL] buffer.getCurrentSegment()[1] = 'y'; [EOL] buffer.getCurrentSegment()[2] = 'z'; [EOL] char[] input = new char[]{'a', 'b', 'c', 'd', 'e', 'f'}; [EOL] buffer.append(input, 0, 6); [EOL] assertEquals("xyzab", new String(buffer.getCurrentSegment(), 0, 5)); [EOL] assertEquals(5, buffer.getCurrentSize()); [EOL] assertEquals("cdef", new String(buffer.getCurrentSegment(), 0, buffer.getCurrentSize())); [EOL] }
public void testAppendWithInputStartNonNegativeAndNoSpace() { [EOL] TextBuffer buffer = new TextBuffer(0, new char[3], 3, null, null); [EOL] buffer.getCurrentSegment()[0] = 'x'; [EOL] buffer.getCurrentSegment()[1] = 'y'; [EOL] buffer.getCurrentSegment()[2] = 'z'; [EOL] char[] input = new char[]{'a', 'b', 'c', 'd'}; [EOL] buffer.append(input, 0, 4); [EOL] assertEquals("xyz", new String(buffer.getCurrentSegment(), 0, 3)); [EOL] assertEquals(3, buffer.getCurrentSize()); [EOL] assertEquals("abcd", new String(buffer.getCurrentSegment(), 0, buffer.getCurrentSize())); [EOL] }
public void testAppendWithInputStartNegative() { [EOL] TextBuffer testBuffer = new TextBuffer(-1, new char[10], 0, null, null); [EOL] String input = "hello"; [EOL] testBuffer.append(input, 0, input.length()); [EOL] assertEquals("Buffer should contain the input string", "hello", new String(testBuffer._currentSegment, 0, testBuffer._currentSize)); [EOL] }
public void testAppendWithExactSpaceInBuffer() { [EOL] TextBuffer testBuffer = new TextBuffer(-1, new char[10], 5, null, null); [EOL] String input = "world"; [EOL] testBuffer.append(input, 0, input.length()); [EOL] assertEquals("Buffer should contain the concatenated string", "helloworld", new String(testBuffer._currentSegment, 0, testBuffer._currentSize)); [EOL] }
public void testAppendWithInsufficientSpaceInBuffer() { [EOL] TextBuffer testBuffer = new TextBuffer(-1, new char[10], 8, null, null); [EOL] String input = "java"; [EOL] testBuffer.append(input, 0, input.length()); [EOL] assertEquals("Buffer should contain the concatenated string", "hellojava", new String(testBuffer._currentSegment, 0, testBuffer._currentSize)); [EOL] }
public void testAppendWithInputStartNonNegative() { [EOL] TextBuffer testBuffer = new TextBuffer(0, new char[10], 5, null, null); [EOL] String input = "world"; [EOL] testBuffer.append(input, 0, input.length()); [EOL] assertEquals("Buffer should have called unshare and contain the input string", "world", new String(testBuffer._currentSegment, 0, testBuffer._currentSize)); [EOL] }
public void testExpandCurrentSegmentAtMaxSegmentLen() { [EOL] _currentSegment = new char[MAX_SEGMENT_LEN]; [EOL] char[] expanded = expandCurrentSegment(); [EOL] assertEquals(MAX_SEGMENT_LEN + 1, expanded.length); [EOL] }
public void testExpandCurrentSegmentBelowMaxSegmentLen() { [EOL] _currentSegment = new char[MAX_SEGMENT_LEN / 2]; [EOL] char[] expanded = expandCurrentSegment(); [EOL] int expectedLength = Math.min(MAX_SEGMENT_LEN, _currentSegment.length + (_currentSegment.length >> 1)); [EOL] assertEquals(expectedLength, expanded.length); [EOL] }
public void testToStringReturnsContentsAsString() { [EOL] JsonContent jsonContent = new JsonContent(); [EOL] String expected = jsonContent.contentsAsString(); [EOL] String actual = jsonContent.toString(); [EOL] assertEquals(expected, actual); [EOL] }
public void testUnshareWithNoNeedExtraAndEmptyCurrentSegment() { [EOL] int needExtra = 0; [EOL] unshare(needExtra); [EOL] assertEquals(0, _inputLen); [EOL] assertNull(_inputBuffer); [EOL] assertEquals(-1, _inputStart); [EOL] assertNotNull(_currentSegment); [EOL] assertEquals(0, _segmentSize); [EOL] assertEquals(_inputLen, _currentSize); [EOL] }
public void testUnshareWithNeedExtraAndEmptyCurrentSegment() { [EOL] int needExtra = 5; [EOL] unshare(needExtra); [EOL] assertEquals(0, _inputLen); [EOL] assertNull(_inputBuffer); [EOL] assertEquals(-1, _inputStart); [EOL] assertNotNull(_currentSegment); [EOL] assertTrue(_currentSegment.length >= needExtra); [EOL] assertEquals(0, _segmentSize); [EOL] assertEquals(_inputLen, _currentSize); [EOL] }
public void testUnshareWithNoNeedExtraAndSufficientCurrentSegment() { [EOL] int needExtra = 0; [EOL] _currentSegment = new char[10]; // Assuming _inputLen is less than 10 [EOL] int originalLength = _currentSegment.length; [EOL] unshare(needExtra); [EOL] assertEquals(0, _inputLen); [EOL] assertNull(_inputBuffer); [EOL] assertEquals(-1, _inputStart); [EOL] assertEquals(originalLength, _currentSegment.length); [EOL] assertEquals(0, _segmentSize); [EOL] assertEquals(_inputLen, _currentSize); [EOL] }
public void testUnshareWithNeedExtraAndInsufficientCurrentSegment() { [EOL] int needExtra = 5; [EOL] _currentSegment = new char[3]; // Assuming _inputLen is greater than 3 [EOL] unshare(needExtra); [EOL] assertEquals(0, _inputLen); [EOL] assertNull(_inputBuffer); [EOL] assertEquals(-1, _inputStart); [EOL] assertTrue(_currentSegment.length >= (_inputLen + needExtra)); [EOL] assertEquals(0, _segmentSize); [EOL] assertEquals(_inputLen, _currentSize); [EOL] }
public void testBuildResultArray_ResultStringNotNull() { [EOL] TextBuffer testInstance = new TextBuffer(); [EOL] testInstance._resultString = "test"; [EOL] char[] result = testInstance.buildResultArray(); [EOL] assertArrayEquals("test".toCharArray(), result); [EOL] }
public void testBuildResultArray_InputStartNonNegativeInputLenZero() { [EOL] TextBuffer testInstance = new TextBuffer(); [EOL] testInstance._inputStart = 0; [EOL] testInstance._inputLen = 0; [EOL] char[] result = testInstance.buildResultArray(); [EOL] assertArrayEquals(TextBuffer.NO_CHARS, result); [EOL] }
public void testBuildResultArray_InputStartNonNegativeInputLenPositiveStartZero() { [EOL] TextBuffer testInstance = new TextBuffer(); [EOL] testInstance._inputStart = 0; [EOL] testInstance._inputLen = 3; [EOL] testInstance._inputBuffer = new char[]{'a', 'b', 'c'}; [EOL] char[] result = testInstance.buildResultArray(); [EOL] assertArrayEquals(new char[]{'a', 'b', 'c'}, result); [EOL] }
public void testBuildResultArray_InputStartNonNegativeInputLenPositiveStartNonZero() { [EOL] TextBuffer testInstance = new TextBuffer(); [EOL] testInstance._inputStart = 1; [EOL] testInstance._inputLen = 2; [EOL] testInstance._inputBuffer = new char[]{'a', 'b', 'c'}; [EOL] char[] result = testInstance.buildResultArray(); [EOL] assertArrayEquals(new char[]{'b', 'c'}, result); [EOL] }
public void testBuildResultArray_SizeZero() { [EOL] TextBuffer testInstance = new TextBuffer(); [EOL] testInstance._inputStart = -1; [EOL] testInstance._inputLen = 0; [EOL] char[] result = testInstance.buildResultArray(); [EOL] assertArrayEquals(TextBuffer.NO_CHARS, result); [EOL] }
public void testBuildResultArray_SegmentsNotNull() { [EOL] TextBuffer testInstance = new TextBuffer(); [EOL] testInstance._inputStart = -1; [EOL] testInstance._segments = new ArrayList<>(); [EOL] testInstance._segments.add(new char[]{'a', 'b'}); [EOL] testInstance._segments.add(new char[]{'c', 'd'}); [EOL] testInstance._currentSegment = new char[]{'e', 'f'}; [EOL] testInstance._currentSize = 2; [EOL] char[] result = testInstance.buildResultArray(); [EOL] assertArrayEquals(new char[]{'a', 'b', 'c', 'd', 'e', 'f'}, result); [EOL] }
public void testBuildResultArray_CurrentSegmentCopied() { [EOL] TextBuffer testInstance = new TextBuffer(); [EOL] testInstance._inputStart = -1; [EOL] testInstance._segments = null; [EOL] testInstance._currentSegment = new char[]{'x', 'y', 'z'}; [EOL] testInstance._currentSize = 3; [EOL] char[] result = testInstance.buildResultArray(); [EOL] assertArrayEquals(new char[]{'x', 'y', 'z'}, result); [EOL] }
public void testCharArrayWithZeroLength() { [EOL] int len = 0; [EOL] char[] result = _charArray(len); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testCharArrayWithPositiveLength() { [EOL] int len = 10; [EOL] char[] result = _charArray(len); [EOL] assertNotNull(result); [EOL] assertEquals(10, result.length); [EOL] }
public void testEnableFeature_WRITE_NUMBERS_AS_STRINGS() { [EOL] JsonGenerator generator = createGenerator(); // Replace with actual generator creation [EOL] generator.enable(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS); [EOL] assertTrue(generator.isEnabled(JsonGenerator.Feature.WRITE_NUMBERS_AS_STRINGS)); [EOL] assertTrue(generator.isCfgNumbersAsStrings()); [EOL] }
public void testEnableFeature_ESCAPE_NON_ASCII() { [EOL] JsonGenerator generator = createGenerator(); // Replace with actual generator creation [EOL] generator.enable(JsonGenerator.Feature.ESCAPE_NON_ASCII); [EOL] assertTrue(generator.isEnabled(JsonGenerator.Feature.ESCAPE_NON_ASCII)); [EOL] assertEquals(127, generator.getHighestNonEscapedChar()); [EOL] }
public void testEnableFeature_Other() { [EOL] JsonGenerator generator = createGenerator(); // Replace with actual generator creation [EOL] JsonGenerator.Feature otherFeature = JsonGenerator.Feature.AUTO_CLOSE_TARGET; // Replace with a feature other than WRITE_NUMBERS_AS_STRINGS and ESCAPE_NON_ASCII [EOL] generator.enable(otherFeature); [EOL] assertTrue(generator.isEnabled(otherFeature)); [EOL] assertFalse(generator.isCfgNumbersAsStrings()); [EOL] assertNotEquals(127, generator.getHighestNonEscapedChar()); [EOL] }
public void testIsClosedWhenClosed() { [EOL] JsonParser jp = createParserWithClosedState(true); [EOL] assertTrue(jp.isClosed()); [EOL] }
public void testIsClosedWhenNotClosed() { [EOL] JsonParser jp = createParserWithClosedState(false); [EOL] assertFalse(jp.isClosed()); [EOL] }
public void testCopyCurrentEventWithNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(null); [EOL] try { [EOL] copyCurrentEvent(jp); [EOL] fail("Should have thrown JsonProcessingException"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testCopyCurrentEventWithStartObject() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeStartObject(); [EOL] }
public void testCopyCurrentEventWithEndObject() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_OBJECT); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeEndObject(); [EOL] }
public void testCopyCurrentEventWithStartArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeStartArray(); [EOL] }
public void testCopyCurrentEventWithEndArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_ARRAY); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeEndArray(); [EOL] }
public void testCopyCurrentEventWithFieldName() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.getCurrentName()).thenReturn("fieldName"); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeFieldName("fieldName"); [EOL] }
public void testCopyCurrentEventWithValueStringUsingTextCharacters() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.hasTextCharacters()).thenReturn(true); [EOL] when(jp.getTextCharacters()).thenReturn(new char[]{'t', 'e', 'x', 't'}); [EOL] when(jp.getTextOffset()).thenReturn(0); [EOL] when(jp.getTextLength()).thenReturn(4); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeString(new char[]{'t', 'e', 'x', 't'}, 0, 4); [EOL] }
public void testCopyCurrentEventWithValueStringWithoutUsingTextCharacters() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.hasTextCharacters()).thenReturn(false); [EOL] when(jp.getText()).thenReturn("text"); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeString("text"); [EOL] }
public void testCopyCurrentEventWithValueNumberIntTypeInt() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.INT); [EOL] when(jp.getIntValue()).thenReturn(123); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeNumber(123); [EOL] }
public void testCopyCurrentEventWithValueNumberIntTypeBigInteger() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.BIG_INTEGER); [EOL] when(jp.getBigIntegerValue()).thenReturn(BigInteger.valueOf(123)); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeNumber(BigInteger.valueOf(123)); [EOL] }
public void testCopyCurrentEventWithValueNumberIntTypeLong() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.LONG); [EOL] when(jp.getLongValue()).thenReturn(123L); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeNumber(123L); [EOL] }
public void testCopyCurrentEventWithValueNumberFloatTypeBigDecimal() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.BIG_DECIMAL); [EOL] when(jp.getDecimalValue()).thenReturn(BigDecimal.valueOf(123.45)); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeNumber(BigDecimal.valueOf(123.45)); [EOL] }
public void testCopyCurrentEventWithValueNumberFloatTypeFloat() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.FLOAT); [EOL] when(jp.getFloatValue()).thenReturn(123.45f); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeNumber(123.45f); [EOL] }
public void testCopyCurrentEventWithValueNumberFloatTypeDouble() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.DOUBLE); [EOL] when(jp.getDoubleValue()).thenReturn(123.45); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeNumber(123.45); [EOL] }
public void testCopyCurrentEventWithValueTrue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeBoolean(true); [EOL] }
public void testCopyCurrentEventWithValueFalse() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeBoolean(false); [EOL] }
public void testCopyCurrentEventWithValueNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeNull(); [EOL] }
public void testCopyCurrentEventWithValueEmbeddedObject() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] Object embeddedObject = new Object(); [EOL] when(jp.getEmbeddedObject()).thenReturn(embeddedObject); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeObject(embeddedObject); [EOL] }
public void testCopyCurrentEventWithUnrecognizedToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] try { [EOL] copyCurrentEvent(jp); [EOL] fail("Should have thrown IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testCopyCurrentStructureWithFieldName() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.getCurrentName()).thenReturn("fieldName"); [EOL] when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY).thenReturn(JsonToken.END_ARRAY); [EOL] copyCurrentStructure(jp); [EOL] verify(jp).getCurrentToken(); [EOL] verify(jp).getCurrentName(); [EOL] verify(jp, times(2)).nextToken(); [EOL] verify(this).writeFieldName("fieldName"); [EOL] verify(this).writeStartArray(); [EOL] verify(this).writeEndArray(); [EOL] }
public void testCopyCurrentStructureWithStartArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] copyCurrentStructure(jp); [EOL] verify(jp).getCurrentToken(); [EOL] verify(jp, times(2)).nextToken(); [EOL] verify(this).writeStartArray(); [EOL] verify(this).writeEndArray(); [EOL] }
public void testCopyCurrentStructureWithStartObject() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] copyCurrentStructure(jp); [EOL] verify(jp).getCurrentToken(); [EOL] verify(jp, times(2)).nextToken(); [EOL] verify(this).writeStartObject(); [EOL] verify(this).writeEndObject(); [EOL] }
public void testCopyCurrentStructureWithOtherToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] copyCurrentStructure(jp); [EOL] verify(jp).getCurrentToken(); [EOL] verify(this).copyCurrentEvent(jp); [EOL] }
public void testGetStartLocationWithNullSrcRef() { [EOL] JsonParser jp = createParserWithContent("{}"); [EOL] JsonLocation location = jp.getStartLocation(null); [EOL] assertEquals(-1L, location.getByteOffset()); [EOL] assertEquals(-1L, location.getCharOffset()); [EOL] assertEquals(jp.getCurrentLocation().getLineNr(), location.getLineNr()); [EOL] assertEquals(jp.getCurrentLocation().getColumnNr(), location.getColumnNr()); [EOL] }
public void testGetStartLocationWithNonNullSrcRef() { [EOL] Object srcRef = new Object(); [EOL] JsonParser jp = createParserWithContent("{}"); [EOL] JsonLocation location = jp.getStartLocation(srcRef); [EOL] assertEquals(srcRef, location.getSourceRef()); [EOL] assertEquals(-1L, location.getByteOffset()); [EOL] assertEquals(-1L, location.getCharOffset()); [EOL] assertEquals(jp.getCurrentLocation().getLineNr(), location.getLineNr()); [EOL] assertEquals(jp.getCurrentLocation().getColumnNr(), location.getColumnNr()); [EOL] }
public void testWriteStringWithNull() throws IOException { [EOL] UTF8JsonGenerator generator = createGenerator(); [EOL] generator.writeString(null); [EOL] }
public void testWriteStringWithEmpty() throws IOException { [EOL] UTF8JsonGenerator generator = createGenerator(); [EOL] generator.writeString(""); [EOL] }
public void testWriteStringWithLongText() throws IOException { [EOL] UTF8JsonGenerator generator = createGenerator(); [EOL] String longText = createLongText(); [EOL] generator.writeString(longText); [EOL] }
public void testWriteStringWithMaxLengthText() throws IOException { [EOL] UTF8JsonGenerator generator = createGenerator(); [EOL] String maxLengthText = createMaxLengthText(); [EOL] generator.writeString(maxLengthText); [EOL] }
public void testWriteStringWithTextCausingBufferFlush() throws IOException { [EOL] UTF8JsonGenerator generator = createGenerator(); [EOL] String textCausingFlush = createTextCausingFlush(); [EOL] generator.writeString(textCausingFlush); [EOL] }
public void testWriteStringWithRegularText() throws IOException { [EOL] UTF8JsonGenerator generator = createGenerator(); [EOL] generator.writeString("regular text"); [EOL] } [EOL] private UTF8JsonGenerator createGenerator() { [EOL] } [EOL] private String createLongText() { [EOL] } [EOL] private String createMaxLengthText() { [EOL] } [EOL] private String createTextCausingFlush() { [EOL] }
public void testWriteNumberWithNumbersAsStringsEnabled() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithNumbersAsStringsEnabled(); [EOL] generator.writeNumber(123); [EOL] assertEquals("\"123\"", generator.getOutputTarget()); [EOL] }
public void testWriteNumberWithBufferFlush() throws IOException { [EOL] UTF8JsonGenerator generator = createGeneratorWithSmallBuffer(); [EOL] generator.writeNumber(123); [EOL] assertTrue(generator.getOutputTarget() instanceof ByteArrayOutputStream); [EOL] assertEquals(123, ((ByteArrayOutputStream) generator.getOutputTarget()).size()); [EOL] }
public void testWriteNumberWithoutNumbersAsStrings() throws IOException { [EOL] UTF8JsonGenerator generator = createGenerator(); [EOL] generator.writeNumber(123); [EOL] assertEquals("123", generator.getOutputTarget()); [EOL] }
public void testWriteBooleanTrue() throws IOException, JsonGenerationException { [EOL] UTF8JsonGenerator generator = createGeneratorWithMockedOutputStream(); [EOL] generator.writeBoolean(true); [EOL] assertOutputBufferContains(generator, TRUE_BYTES); [EOL] } [EOL] public void testWriteBooleanFalse() throws IOException, JsonGenerationException { [EOL] UTF8JsonGenerator generator = createGeneratorWithMockedOutputStream(); [EOL] generator.writeBoolean(false); [EOL] assertOutputBufferContains(generator, FALSE_BYTES); [EOL] } [EOL] public void testWriteBooleanWithBufferFlush() throws IOException, JsonGenerationException { [EOL] UTF8JsonGenerator generator = createGeneratorWithMockedOutputStream(); [EOL] fillOutputBufferToTriggerFlush(generator); [EOL] generator.writeBoolean(true); [EOL] assertOutputBufferContains(generator, TRUE_BYTES); [EOL] }
private UTF8JsonGenerator createGeneratorWithMockedOutputStream() { [EOL] OutputStream out = new ByteArrayOutputStream(); [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), out, false); [EOL] return new UTF8JsonGenerator(ctxt, 0, null, out); [EOL] } [EOL] private void fillOutputBufferToTriggerFlush(UTF8JsonGenerator generator) throws IOException { [EOL] while ((generator._outputTail + 5) < generator._outputEnd) { [EOL] generator.writeNumber(0); [EOL] } [EOL] } [EOL] private void assertOutputBufferContains(UTF8JsonGenerator generator, byte[] expectedBytes) { [EOL] byte[] outputBuffer = generator._outputBuffer; [EOL] int start = generator._outputTail - expectedBytes.length; [EOL] for (int i = 0; i < expectedBytes.length; i++) { [EOL] assertEquals("Output buffer does not contain the expected byte sequence", expectedBytes[i], outputBuffer[start + i]); [EOL] } [EOL] }
@Override [EOL] protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL] int status = _writeContext.writeValue(); [EOL] if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL] _reportError("Can not " + typeMsg + ", expecting field name"); [EOL] } [EOL] if (_cfgPrettyPrinter == null) { [EOL] byte b; [EOL] switch(status) { [EOL] case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL] b = BYTE_COMMA; [EOL] break; [EOL] case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL] b = BYTE_COLON; [EOL] break; [EOL] case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL] if (_rootValueSeparator != null) { [EOL] byte[] raw = _rootValueSeparator.asUnquotedUTF8(); [EOL] if (raw.length > 0) { [EOL] _writeBytes(raw); [EOL] } [EOL] } [EOL] return; [EOL] case JsonWriteContext.STATUS_OK_AS_IS: [EOL] default: [EOL] return; [EOL] } [EOL] if (_outputTail >= _outputEnd) { [EOL] _flushBuffer(); [EOL] } [EOL] _outputBuffer[_outputTail] = b; [EOL] ++_outputTail; [EOL] return; [EOL] } [EOL] _verifyPrettyValueWrite(typeMsg, status); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }];
private final void _writeBytes(byte[] bytes) throws IOException { [EOL] final int len = bytes.length; [EOL] if ((_outputTail + len) > _outputEnd) { [EOL] _flushBuffer(); [EOL] if (len > MAX_BYTES_TO_BUFFER) { [EOL] _outputStream.write(bytes, 0, len); [EOL] return; [EOL] } [EOL] } [EOL] System.arraycopy(bytes, 0, _outputBuffer, _outputTail, len); [EOL] _outputTail += len; [EOL] }
public void testWriteStringSegmentWithNonEscapedCharacters() throws IOException, JsonGenerationException { [EOL] char[] cbuf = new char[]{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k'}; [EOL] int offset = 0; [EOL] int len = cbuf.length; [EOL] _writeStringSegment(cbuf, offset, len); [EOL] assertEquals(_outputTail, len); [EOL] for (int i = 0; i < len; i++) { [EOL] assertEquals(_outputBuffer[i], (byte) cbuf[i]); [EOL] } [EOL] }
public void testWriteStringSegmentWithEscapedCharacters() throws IOException, JsonGenerationException { [EOL] char[] cbuf = new char[]{'a', 'b', 'c', (char) 0x80, 'e', 'f', 'g', 'h', 'i', 'j', 'k'}; [EOL] int offset = 0; [EOL] int len = 3; // Only up to 'c' should be written without escaping [EOL] _writeStringSegment(cbuf, offset, len); [EOL] assertEquals(_outputTail, len); [EOL] for (int i = 0; i < len; i++) { [EOL] assertEquals(_outputBuffer[i], (byte) cbuf[i]); [EOL] } [EOL] assertTrue(_outputTail < cbuf.length); [EOL] }
public void testWriteStringSegmentWithCustomEscapes() throws IOException, JsonGenerationException { [EOL] char[] cbuf = new char[]{'a', 'b', 'c', (char) 0x80, 'e', 'f', 'g', 'h', 'i', 'j', 'k'}; [EOL] int offset = 0; [EOL] int len = cbuf.length; [EOL] _characterEscapes = new CustomCharacterEscapes(); // Assuming CustomCharacterEscapes is a valid implementation [EOL] _writeStringSegment(cbuf, offset, len); [EOL] }
public void testWriteStringSegmentWithMaximumNonEscapedChar() throws IOException, JsonGenerationException { [EOL] char[] cbuf = new char[]{'a', 'b', 'c', (char) 0x80, 'e', 'f', 'g', 'h', 'i', 'j', 'k'}; [EOL] int offset = 0; [EOL] int len = cbuf.length; [EOL] _maximumNonEscapedChar = 0x7F; // Assuming this means all chars <= 0x7F are not escaped [EOL] _writeStringSegment(cbuf, offset, len); [EOL] }
private void test_writeStringSegment2_flushBuffer() throws IOException, JsonGenerationException { [EOL] _outputTail = 0; [EOL] _outputEnd = 10; // Small buffer size to trigger flush [EOL] char[] cbuf = new char[]{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k'}; [EOL] int offset = 0; [EOL] int end = cbuf.length; [EOL] _writeStringSegment2(cbuf, offset, end); [EOL] }
private void test_writeStringSegment2_noEscapes() throws IOException, JsonGenerationException { [EOL] _outputTail = 0; [EOL] _outputEnd = 100; // Large enough buffer [EOL] _outputEscapes = new int[128]; // No escapes [EOL] char[] cbuf = new char[]{'a', 'b', 'c'}; [EOL] int offset = 0; [EOL] int end = cbuf.length; [EOL] _writeStringSegment2(cbuf, offset, end); [EOL] }
private void test_writeStringSegment2_withEscapes() throws IOException, JsonGenerationException { [EOL] _outputTail = 0; [EOL] _outputEnd = 100; // Large enough buffer [EOL] _outputEscapes = new int[128]; [EOL] _outputEscapes['b'] = 'B'; // Escape for 'b' [EOL] char[] cbuf = new char[]{'a', 'b', 'c'}; [EOL] int offset = 0; [EOL] int end = cbuf.length; [EOL] _writeStringSegment2(cbuf, offset, end); [EOL] }
private void test_writeStringSegment2_withMultiByteChar() throws IOException, JsonGenerationException { [EOL] _outputTail = 0; [EOL] _outputEnd = 100; // Large enough buffer [EOL] char[] cbuf = new char[]{'a', '', 'c'}; // '' is a multi-byte char [EOL] int offset = 0; [EOL] int end = cbuf.length; [EOL] _writeStringSegment2(cbuf, offset, end); [EOL] }
private void test_writeStringSegmentASCII2_flushBuffer() throws IOException, JsonGenerationException { [EOL] UTF8JsonGenerator generator = createGeneratorWithSmallBuffer(); [EOL] char[] cbuf = new char[]{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k'}; [EOL] int offset = 0; [EOL] int end = cbuf.length; [EOL] generator._writeStringSegmentASCII2(cbuf, offset, end); [EOL] verify(generator)._flushBuffer(); [EOL] } [EOL] private void test_writeStringSegmentASCII2_noEscaping() throws IOException, JsonGenerationException { [EOL] UTF8JsonGenerator generator = createGeneratorWithSufficientBuffer(); [EOL] char[] cbuf = new char[]{'a', 'b', 'c'}; [EOL] int offset = 0; [EOL] int end = cbuf.length; [EOL] generator._writeStringSegmentASCII2(cbuf, offset, end); [EOL] byte[] expectedOutput = new byte[]{'a', 'b', 'c'}; [EOL] assertArrayEquals(expectedOutput, generator.getOutputBuffer()); [EOL] } [EOL] private void test_writeStringSegmentASCII2_withEscaping() throws IOException, JsonGenerationException { [EOL] UTF8JsonGenerator generator = createGeneratorWithSufficientBuffer(); [EOL] char[] cbuf = new char[]{'a', '\\', 'n', 'b', 'c'}; [EOL] int offset = 0; [EOL] int end = cbuf.length; [EOL] generator._writeStringSegmentASCII2(cbuf, offset, end); [EOL] byte[] expectedOutput = new byte[]{'a', BYTE_BACKSLASH, 'n', 'b', 'c'}; [EOL] assertArrayEquals(expectedOutput, generator.getOutputBuffer()); [EOL] } [EOL] private void test_writeStringSegmentASCII2_withNonEscapedChars() throws IOException, JsonGenerationException { [EOL] UTF8JsonGenerator generator = createGeneratorWithSufficientBuffer(); [EOL] char[] cbuf = new char[]{'a', 'b', 'c', 200}; // 200 is a non-ASCII character [EOL] int offset = 0; [EOL] int end = cbuf.length; [EOL] generator._writeStringSegmentASCII2(cbuf, offset, end); [EOL] byte[] expectedOutput = new byte[]{'a', 'b', 'c', (byte) (0xc0 | (200 >> 6)), (byte) (0x80 | (200 & 0x3f))}; [EOL] assertArrayEquals(expectedOutput, generator.getOutputBuffer()); [EOL] } [EOL] private void test_writeStringSegmentASCII2_withHighUnicode() throws IOException, JsonGenerationException { [EOL] UTF8JsonGenerator generator = createGeneratorWithSufficientBuffer(); [EOL] char[] cbuf = new char[]{'a', 'b', 'c', 0x1F600}; // 0x1F600 is a high Unicode character (Emoji) [EOL] int offset = 0; [EOL] int end = cbuf.length; [EOL] generator._writeStringSegmentASCII2(cbuf, offset, end); [EOL] byte[] expectedOutput = new byte[]{'a', 'b', 'c', (byte) (0xf0 | (0x1F600 >> 18)), (byte) (0x80 | ((0x1F600 >> 12) & 0x3f)), (byte) (0x80 | ((0x1F600 >> 6) & 0x3f)), (byte) (0x80 | (0x1F600 & 0x3f))}; [EOL] assertArrayEquals(expectedOutput, generator.getOutputBuffer()); [EOL] } [EOL] private UTF8JsonGenerator createGeneratorWithSmallBuffer() { [EOL] } [EOL] private UTF8JsonGenerator createGeneratorWithSufficientBuffer() { [EOL] }
public void testOutputMultiByteCharWithSurrogate() throws IOException { [EOL] UTF8JsonGenerator gen = createGenerator(); // Assuming createGenerator() properly initializes UTF8JsonGenerator [EOL] int outputPtr = 0; [EOL] int ch = 0xD800; // SURR1_FIRST [EOL] outputPtr = gen._outputMultiByteChar(ch, outputPtr); [EOL] assertEquals(6, outputPtr); // 6 bytes for surrogate pair encoding [EOL] ch = 0xDFFF; // SURR2_LAST [EOL] outputPtr = gen._outputMultiByteChar(ch, outputPtr); [EOL] assertEquals(12, outputPtr); // 6 more bytes for the second surrogate pair encoding [EOL] }
public void testOutputMultiByteCharWithoutSurrogate() throws IOException { [EOL] UTF8JsonGenerator gen = createGenerator(); // Assuming createGenerator() properly initializes UTF8JsonGenerator [EOL] int outputPtr = 0; [EOL] int ch = 0x007F; // A char that is not a surrogate [EOL] outputPtr = gen._outputMultiByteChar(ch, outputPtr); [EOL] assertEquals(3, outputPtr); // 3 bytes for non-surrogate multi-byte char encoding [EOL] }
private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException { [EOL] final byte[] bbuf = _outputBuffer; [EOL] bbuf[outputPtr++] = BYTE_BACKSLASH; [EOL] bbuf[outputPtr++] = BYTE_u; [EOL] if (charToEscape > 0xFF) { [EOL] int hi = (charToEscape >> 8) & 0xFF; [EOL] bbuf[outputPtr++] = HEX_CHARS[hi >> 4]; [EOL] bbuf[outputPtr++] = HEX_CHARS[hi & 0xF]; [EOL] charToEscape &= 0xFF; [EOL] } else { [EOL] bbuf[outputPtr++] = BYTE_0; [EOL] bbuf[outputPtr++] = BYTE_0; [EOL] } [EOL] bbuf[outputPtr++] = HEX_CHARS[charToEscape >> 4]; [EOL] bbuf[outputPtr++] = HEX_CHARS[charToEscape & 0xF]; [EOL] return outputPtr; [EOL] }
public void testGetTypeDesc_ROOT() { [EOL] JsonToken token = JsonToken.START_OBJECT; // Assuming JsonToken is the class and TYPE_ROOT is a constant [EOL] token._type = JsonToken.TYPE_ROOT; // Assuming _type is the field that stores the type [EOL] String desc = token.getTypeDesc(); [EOL] assertEquals("ROOT", desc); [EOL] }
public void testGetTypeDesc_ARRAY() { [EOL] JsonToken token = JsonToken.START_ARRAY; // Assuming JsonToken is the class and TYPE_ARRAY is a constant [EOL] token._type = JsonToken.TYPE_ARRAY; // Assuming _type is the field that stores the type [EOL] String desc = token.getTypeDesc(); [EOL] assertEquals("ARRAY", desc); [EOL] }
public void testGetTypeDesc_OBJECT() { [EOL] JsonToken token = JsonToken.START_OBJECT; // Assuming JsonToken is the class and TYPE_OBJECT is a constant [EOL] token._type = JsonToken.TYPE_OBJECT; // Assuming _type is the field that stores the type [EOL] String desc = token.getTypeDesc(); [EOL] assertEquals("OBJECT", desc); [EOL] }
public void testGetTypeDesc_UNKNOWN() { [EOL] JsonToken token = JsonToken.NOT_AVAILABLE; // Assuming JsonToken is the class and NOT_AVAILABLE is a constant for unknown type [EOL] token._type = -1; // Assuming -1 is not a valid type and would result in "?" [EOL] String desc = token.getTypeDesc(); [EOL] assertEquals("?", desc); [EOL] }
public void testHasJSONFormatWithNoMoreBytesInitially() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(false); [EOL] assertEquals(MatchStrength.INCONCLUSIVE, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithUTF8BOM() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) 0xEF).thenReturn((byte) 0xBB).thenReturn((byte) 0xBF).thenReturn((byte) '{'); [EOL] assertEquals(MatchStrength.SOLID_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithNoMatchOnBOM() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) 0xEF).thenReturn((byte) 0xBB); [EOL] assertEquals(MatchStrength.NO_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithInconclusiveAfterBOM() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true).thenReturn(false); [EOL] when(acc.nextByte()).thenReturn((byte) 0xEF).thenReturn((byte) 0xBB); [EOL] assertEquals(MatchStrength.INCONCLUSIVE, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithNonBOMAndObjectStart() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) '{').thenReturn((byte) '"'); [EOL] assertEquals(MatchStrength.SOLID_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithNonBOMAndArrayStart() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) '[').thenReturn((byte) ']'); [EOL] assertEquals(MatchStrength.SOLID_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithNonBOMAndNumber() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) '1'); [EOL] assertEquals(MatchStrength.WEAK_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithNonBOMAndNegativeNumber() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) '-').thenReturn((byte) '1'); [EOL] assertEquals(MatchStrength.WEAK_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithNonBOMAndFalseLiteral() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(true).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) 'f').thenReturn((byte) 'a').thenReturn((byte) 'l').thenReturn((byte) 's').thenReturn((byte) 'e'); [EOL] assertEquals(MatchStrength.WEAK_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testHasJSONFormatWithNonBOMAndNoMatch() throws IOException { [EOL] InputAccessor acc = mock(InputAccessor.class); [EOL] when(acc.hasMoreBytes()).thenReturn(true); [EOL] when(acc.nextByte()).thenReturn((byte) 'x'); [EOL] assertEquals(MatchStrength.NO_MATCH, JsonFactory.hasJSONFormat(acc)); [EOL] }
public void testMinimalPrettyPrinterDefaultConstructor() { [EOL] MinimalPrettyPrinter prettyPrinter = new MinimalPrettyPrinter(); [EOL] assertNotNull(prettyPrinter); [EOL] assertEquals(MinimalPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR, prettyPrinter.getRootValueSeparator()); [EOL] }
public void testMinimalPrettyPrinterWithNullRootValueSeparator() { [EOL] MinimalPrettyPrinter printer = new MinimalPrettyPrinter(null); [EOL] assertNull(printer._rootValueSeparator); [EOL] }
public void testMinimalPrettyPrinterWithNonNullRootValueSeparator() { [EOL] String separator = " "; [EOL] MinimalPrettyPrinter printer = new MinimalPrettyPrinter(separator); [EOL] assertEquals(separator, printer._rootValueSeparator); [EOL] }
public void testWriteStartObject() throws IOException, JsonGenerationException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] JsonWriter writer = new JsonWriter(); [EOL] writer.writeStartObject(mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeRaw('{'); [EOL] }
It appears that the provided method `beforeObjectEntries` is empty and does not contain any executable code. Since there are no lines of code within the method body, there is no need to generate unit test cases for line coverage, as there is nothing to cover. Therefore, no test cases will be generated for this method. If the method had contained executable code, I would have provided test cases to cover those lines.
public void testWriteObjectFieldValueSeparator() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] JsonWriteContext jsonWriteContext = new JsonWriteContext(1, null, null); [EOL] jsonWriteContext.writeObjectFieldValueSeparator(mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeRaw(':'); [EOL] }
public void testWriteObjectEntrySeparator() throws IOException, JsonGenerationException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] JsonWriteContext jsonWriteContext = new JsonWriteContext(1, null, null); [EOL] jsonWriteContext.writeObjectEntrySeparator(mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeRaw(','); [EOL] }
public void testWriteEndObject() throws IOException, JsonGenerationException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] JsonWriteContext testInstance = new JsonWriteContext(1, null, null); [EOL] testInstance.writeEndObject(mockJsonGenerator, 0); [EOL] verify(mockJsonGenerator).writeRaw('}'); [EOL] }
public void testWriteStartArray() throws IOException, JsonGenerationException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] JsonWriter underTest = new JsonWriter(); [EOL] underTest.writeStartArray(mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeRaw('['); [EOL] }
public void testBeforeArrayValues() throws IOException, JsonGenerationException { [EOL] JsonGenerator jg = mock(JsonGenerator.class); [EOL] MyClass myClass = new MyClass(); [EOL] myClass.beforeArrayValues(jg); [EOL] }
public void testWriteArrayValueSeparator() throws IOException, JsonGenerationException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] JsonWriteContext jsonWriteContext = new JsonWriteContext(1, null, null); [EOL] jsonWriteContext.writeArrayValueSeparator(mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeRaw(','); [EOL] }
public void testWriteEndArray() throws IOException, JsonGenerationException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] JsonWriteContext testInstance = new JsonWriteContext(1, null, null); [EOL] testInstance.writeEndArray(mockJsonGenerator, 0); [EOL] verify(mockJsonGenerator).writeRaw(']'); [EOL] }
public void testGetColumnNr() { [EOL] JsonLocation location = new JsonLocation(null, -1, 1, 2); [EOL] int columnNr = location.getColumnNr(); [EOL] assertEquals(2, columnNr); [EOL] }
public void testWriteBinaryWithNullData() throws IOException, JsonGenerationException { [EOL] try { [EOL] writeBinary(null); [EOL] fail("Expected an exception due to null data"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testWriteBinaryWithEmptyData() throws IOException, JsonGenerationException { [EOL] byte[] data = new byte[0]; [EOL] writeBinary(data); [EOL] }
public void testWriteBinaryWithNonEmptyData() throws IOException, JsonGenerationException { [EOL] byte[] data = new byte[]{1, 2, 3, 4}; [EOL] writeBinary(data); [EOL] }
public void testEncodeBase64PartialWithPaddingTwoBytes() { [EOL] int bits = 0x00FC0000; // Arbitrary bits with non-zero values for the first two 6-bit groups [EOL] int outputBytes = 2; [EOL] char[] buffer = new char[4]; [EOL] int outPtr = 0; [EOL] int result = encodeBase64Partial(bits, outputBytes, buffer, outPtr); [EOL] assertEquals(4, result); [EOL] assertEquals('w', buffer[0]); // Asserting the first 6-bit group [EOL] assertEquals('/', buffer[1]); // Asserting the second 6-bit group [EOL] assertEquals('A', buffer[2]); // Asserting the third 6-bit group (should be padding if usesPadding is false) [EOL] assertEquals('=', buffer[3]); // Asserting the fourth 6-bit group (should always be padding) [EOL] }
public void testEncodeBase64PartialWithPaddingOneByte() { [EOL] int bits = 0x00FC0000; // Arbitrary bits with non-zero values for the first 6-bit group [EOL] int outputBytes = 1; [EOL] char[] buffer = new char[4]; [EOL] int outPtr = 0; [EOL] int result = encodeBase64Partial(bits, outputBytes, buffer, outPtr); [EOL] assertEquals(4, result); [EOL] assertEquals('w', buffer[0]); // Asserting the first 6-bit group [EOL] assertEquals('/', buffer[1]); // Asserting the second 6-bit group (should be padding if usesPadding is true) [EOL] assertEquals('=', buffer[2]); // Asserting the third 6-bit group (should always be padding) [EOL] assertEquals('=', buffer[3]); // Asserting the fourth 6-bit group (should always be padding) [EOL] }
public void testEncodeBase64PartialWithoutPaddingTwoBytes() { [EOL] int bits = 0x00FC0000; // Arbitrary bits with non-zero values for the first two 6-bit groups [EOL] int outputBytes = 2; [EOL] char[] buffer = new char[3]; [EOL] int outPtr = 0; [EOL] _usesPadding = false; // Assuming this is a class variable that can be set [EOL] int result = encodeBase64Partial(bits, outputBytes, buffer, outPtr); [EOL] assertEquals(3, result); [EOL] assertEquals('w', buffer[0]); // Asserting the first 6-bit group [EOL] assertEquals('/', buffer[1]); // Asserting the second 6-bit group [EOL] assertEquals('A', buffer[2]); // Asserting the third 6-bit group (should not be padding) [EOL] }
public void testEncodeBase64PartialWithoutPaddingOneByte() { [EOL] int bits = 0x00FC0000; // Arbitrary bits with non-zero values for the first 6-bit group [EOL] int outputBytes = 1; [EOL] char[] buffer = new char[2]; [EOL] int outPtr = 0; [EOL] _usesPadding = false; // Assuming this is a class variable that can be set [EOL] int result = encodeBase64Partial(bits, outputBytes, buffer, outPtr); [EOL] assertEquals(2, result); [EOL] assertEquals('w', buffer[0]); // Asserting the first 6-bit group [EOL] assertEquals('/', buffer[1]); // Asserting the second 6-bit group (should not be padding) [EOL] }
public void testGetTextCharactersWithFieldNameAndNameNotCopied() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFieldNameToken(); [EOL] JsonToken currentToken = JsonToken.FIELD_NAME; [EOL] boolean nameCopied = false; [EOL] char[] result = parser.getTextCharacters(); [EOL] assertNotNull(result); [EOL] assertEquals(parser.getParsingContext().getCurrentName(), new String(result)); [EOL] }
public void testGetTextCharactersWithFieldNameAndNameCopied() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithFieldNameToken(); [EOL] JsonToken currentToken = JsonToken.FIELD_NAME; [EOL] boolean nameCopied = true; [EOL] char[] result = parser.getTextCharacters(); [EOL] assertNotNull(result); [EOL] assertEquals(parser.getParsingContext().getCurrentName(), new String(result)); [EOL] }
public void testGetTextCharactersWithValueStringIncomplete() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithValueStringToken(); [EOL] JsonToken currentToken = JsonToken.VALUE_STRING; [EOL] boolean tokenIncomplete = true; [EOL] char[] result = parser.getTextCharacters(); [EOL] assertNotNull(result); [EOL] assertEquals(parser.getTextBuffer().toString(), new String(result)); [EOL] }
public void testGetTextCharactersWithValueStringComplete() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithValueStringToken(); [EOL] JsonToken currentToken = JsonToken.VALUE_STRING; [EOL] boolean tokenIncomplete = false; [EOL] char[] result = parser.getTextCharacters(); [EOL] assertNotNull(result); [EOL] assertEquals(parser.getTextBuffer().toString(), new String(result)); [EOL] }
public void testGetTextCharactersWithValueNumberInt() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithValueNumberIntToken(); [EOL] JsonToken currentToken = JsonToken.VALUE_NUMBER_INT; [EOL] char[] result = parser.getTextCharacters(); [EOL] assertNotNull(result); [EOL] assertEquals(parser.getTextBuffer().toString(), new String(result)); [EOL] }
public void testGetTextCharactersWithValueNumberFloat() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithValueNumberFloatToken(); [EOL] JsonToken currentToken = JsonToken.VALUE_NUMBER_FLOAT; [EOL] char[] result = parser.getTextCharacters(); [EOL] assertNotNull(result); [EOL] assertEquals(parser.getTextBuffer().toString(), new String(result)); [EOL] }
public void testGetTextCharactersWithOtherToken() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithOtherToken(); [EOL] JsonToken currentToken = JsonToken.NOT_AVAILABLE; // Assuming NOT_AVAILABLE is a valid token that is not covered by the switch cases [EOL] char[] result = parser.getTextCharacters(); [EOL] assertNotNull(result); [EOL] assertEquals(currentToken.asCharArray(), result); [EOL] }
public void testGetTextCharactersWithNullToken() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithNullToken(); [EOL] JsonToken currentToken = null; [EOL] char[] result = parser.getTextCharacters(); [EOL] assertNull(result); [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL] _numTypesValid = NR_UNKNOWN; [EOL] if (_currToken == JsonToken.FIELD_NAME) { [EOL] return _nextAfterName(); [EOL] } [EOL] if (_tokenIncomplete) { [EOL] _skipString(); [EOL] } [EOL] int i = _skipWSOrEnd(); [EOL] if (i < 0) { [EOL] close(); [EOL] return (_currToken = null); [EOL] } [EOL] _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL] _tokenInputRow = _currInputRow; [EOL] _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL] _binaryValue = null; [EOL] if (i == INT_RBRACKET) { [EOL] if (!_parsingContext.inArray()) { [EOL] _reportMismatchedEndMarker(i, '}'); [EOL] } [EOL] _parsingContext = _parsingContext.getParent(); [EOL] return (_currToken = JsonToken.END_ARRAY); [EOL] } [EOL] if (i == INT_RCURLY) { [EOL] if (!_parsingContext.inObject()) { [EOL] _reportMismatchedEndMarker(i, ']'); [EOL] } [EOL] _parsingContext = _parsingContext.getParent(); [EOL] return (_currToken = JsonToken.END_OBJECT); [EOL] } [EOL] if (_parsingContext.expectComma()) { [EOL] if (i != INT_COMMA) { [EOL] _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL] } [EOL] i = _skipWS(); [EOL] } [EOL] boolean inObject = _parsingContext.inObject(); [EOL] if (inObject) { [EOL] String name = _parseFieldName(i); [EOL] _parsingContext.setCurrentName(name); [EOL] _currToken = JsonToken.FIELD_NAME; [EOL] i = _skipWS(); [EOL] if (i != INT_COLON) { [EOL] _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL] } [EOL] i = _skipWS(); [EOL] } [EOL] JsonToken t; [EOL] switch(i) { [EOL] case INT_QUOTE: [EOL] _tokenIncomplete = true; [EOL] t = JsonToken.VALUE_STRING; [EOL] break; [EOL] case INT_LBRACKET: [EOL] if (!inObject) { [EOL] _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL] } [EOL] t = JsonToken.START_ARRAY; [EOL] break; [EOL] case INT_LCURLY: [EOL] if (!inObject) { [EOL] _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL] } [EOL] t = JsonToken.START_OBJECT; [EOL] break; [EOL] case INT_RBRACKET: [EOL] case INT_RCURLY: [EOL] _reportUnexpectedChar(i, "expected a value"); [EOL] case INT_t: [EOL] _matchToken("true", 1); [EOL] t = JsonToken.VALUE_TRUE; [EOL] break; [EOL] case INT_f: [EOL] _matchToken("false", 1); [EOL] t = JsonToken.VALUE_FALSE; [EOL] break; [EOL] case INT_n: [EOL] _matchToken("null", 1); [EOL] t = JsonToken.VALUE_NULL; [EOL] break; [EOL] case INT_MINUS: [EOL] case INT_0: [EOL] case INT_1: [EOL] case INT_2: [EOL] case INT_3: [EOL] case INT_4: [EOL] case INT_5: [EOL] case INT_6: [EOL] case INT_7: [EOL] case INT_8: [EOL] case INT_9: [EOL] t = parseNumberText(i); [EOL] break; [EOL] default: [EOL] t = _handleUnexpectedValue(i); [EOL] break; [EOL] } [EOL] if (inObject) { [EOL] _nextToken = t; [EOL] return _currToken; [EOL] } [EOL] _currToken = t; [EOL] return t; [EOL] }
protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException { [EOL] boolean negative = (ch == INT_MINUS); [EOL] int ptr = _inputPtr; [EOL] int startPtr = ptr - 1; [EOL] final int inputLen = _inputEnd; [EOL] dummy_loop: do { [EOL] if (negative) { [EOL] if (ptr >= _inputEnd) { [EOL] break dummy_loop; [EOL] } [EOL] ch = _inputBuffer[ptr++]; [EOL] if (ch > INT_9 || ch < INT_0) { [EOL] _inputPtr = ptr; [EOL] return _handleInvalidNumberStart(ch, true); [EOL] } [EOL] } [EOL] if (ch == INT_0) { [EOL] break dummy_loop; [EOL] } [EOL] int intLen = 1; [EOL] int_loop: while (true) { [EOL] if (ptr >= _inputEnd) { [EOL] break dummy_loop; [EOL] } [EOL] ch = (int) _inputBuffer[ptr++]; [EOL] if (ch < INT_0 || ch > INT_9) { [EOL] break int_loop; [EOL] } [EOL] ++intLen; [EOL] } [EOL] int fractLen = 0; [EOL] if (ch == INT_DECIMAL_POINT) { [EOL] fract_loop: while (true) { [EOL] if (ptr >= inputLen) { [EOL] break dummy_loop; [EOL] } [EOL] ch = (int) _inputBuffer[ptr++]; [EOL] if (ch < INT_0 || ch > INT_9) { [EOL] break fract_loop; [EOL] } [EOL] ++fractLen; [EOL] } [EOL] if (fractLen == 0) { [EOL] reportUnexpectedNumberChar(ch, "Decimal point not followed by a digit"); [EOL] } [EOL] } [EOL] int expLen = 0; [EOL] if (ch == INT_e || ch == INT_E) { [EOL] if (ptr >= inputLen) { [EOL] break dummy_loop; [EOL] } [EOL] ch = (int) _inputBuffer[ptr++]; [EOL] if (ch == INT_MINUS || ch == INT_PLUS) { [EOL] if (ptr >= inputLen) { [EOL] break dummy_loop; [EOL] } [EOL] ch = (int) _inputBuffer[ptr++]; [EOL] } [EOL] while (ch <= INT_9 && ch >= INT_0) { [EOL] ++expLen; [EOL] if (ptr >= inputLen) { [EOL] break dummy_loop; [EOL] } [EOL] ch = (int) _inputBuffer[ptr++]; [EOL] } [EOL] if (expLen == 0) { [EOL] reportUnexpectedNumberChar(ch, "Exponent indicator not followed by a digit"); [EOL] } [EOL] } [EOL] --ptr; [EOL] _inputPtr = ptr; [EOL] int len = ptr - startPtr; [EOL] _textBuffer.resetWithShared(_inputBuffer, startPtr, len); [EOL] return reset(negative, intLen, fractLen, expLen); [EOL] } while (false); [EOL] _inputPtr = negative ? (startPtr + 1) : startPtr; [EOL] return parseNumberText2(negative); [EOL] }
private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException { [EOL] char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL] int outPtr = 0; [EOL] if (negative) { [EOL] outBuf[outPtr++] = '-'; [EOL] } [EOL] int intLen = 0; [EOL] char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar("No digit following minus sign"); [EOL] if (c == '0') { [EOL] c = _verifyNoLeadingZeroes(); [EOL] } [EOL] boolean eof = false; [EOL] int_loop: while (c >= '0' && c <= '9') { [EOL] ++intLen; [EOL] if (outPtr >= outBuf.length) { [EOL] outBuf = _textBuffer.finishCurrentSegment(); [EOL] outPtr = 0; [EOL] } [EOL] outBuf[outPtr++] = c; [EOL] if (_inputPtr >= _inputEnd && !loadMore()) { [EOL] c = CHAR_NULL; [EOL] eof = true; [EOL] break int_loop; [EOL] } [EOL] c = _inputBuffer[_inputPtr++]; [EOL] } [EOL] if (intLen == 0) { [EOL] reportInvalidNumber("Missing integer part (next char " + _getCharDesc(c) + ")"); [EOL] } [EOL] int fractLen = 0; [EOL] if (c == '.') { [EOL] outBuf[outPtr++] = c; [EOL] fract_loop: while (true) { [EOL] if (_inputPtr >= _inputEnd && !loadMore()) { [EOL] eof = true; [EOL] break fract_loop; [EOL] } [EOL] c = _inputBuffer[_inputPtr++]; [EOL] if (c < INT_0 || c > INT_9) { [EOL] break fract_loop; [EOL] } [EOL] ++fractLen; [EOL] if (outPtr >= outBuf.length) { [EOL] outBuf = _textBuffer.finishCurrentSegment(); [EOL] outPtr = 0; [EOL] } [EOL] outBuf[outPtr++] = c; [EOL] } [EOL] if (fractLen == 0) { [EOL] reportUnexpectedNumberChar(c, "Decimal point not followed by a digit"); [EOL] } [EOL] } [EOL] int expLen = 0; [EOL] if (c == 'e' || c == 'E') { [EOL] if (outPtr >= outBuf.length) { [EOL] outBuf = _textBuffer.finishCurrentSegment(); [EOL] outPtr = 0; [EOL] } [EOL] outBuf[outPtr++] = c; [EOL] c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar("expected a digit for number exponent"); [EOL] if (c == '-' || c == '+') { [EOL] if (outPtr >= outBuf.length) { [EOL] outBuf = _textBuffer.finishCurrentSegment(); [EOL] outPtr = 0; [EOL] } [EOL] outBuf[outPtr++] = c; [EOL] c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar("expected a digit for number exponent"); [EOL] } [EOL] exp_loop: while (c <= INT_9 && c >= INT_0) { [EOL] ++expLen; [EOL] if (outPtr >= outBuf.length) { [EOL] outBuf = _textBuffer.finishCurrentSegment(); [EOL] outPtr = 0; [EOL] } [EOL] outBuf[outPtr++] = c; [EOL] if (_inputPtr >= _inputEnd && !loadMore()) { [EOL] eof = true; [EOL] break exp_loop; [EOL] } [EOL] c = _inputBuffer[_inputPtr++]; [EOL] } [EOL] if (expLen == 0) { [EOL] reportUnexpectedNumberChar(c, "Exponent indicator not followed by a digit"); [EOL] } [EOL] } [EOL] if (!eof) { [EOL] --_inputPtr; [EOL] } [EOL] _textBuffer.setCurrentLength(outPtr); [EOL] return reset(negative, intLen, fractLen, expLen); [EOL] }
public void testHandleInvalidNumberStartWithIAndLoadMoreFails() throws IOException { [EOL] JsonParser jp = createParserWithContent("I"); [EOL] try { [EOL] jp._handleInvalidNumberStart('I', false); [EOL] fail("Should throw JsonParseException due to invalid EOF"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleInvalidNumberStartWithINegative() throws IOException { [EOL] JsonParser jp = createParserWithContent("-INF"); [EOL] jp.enable(Feature.ALLOW_NON_NUMERIC_NUMBERS); [EOL] JsonToken result = jp._handleInvalidNumberStart('I', true); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] assertEquals(Double.NEGATIVE_INFINITY, jp.getDoubleValue(), 0.0); [EOL] }
public void testHandleInvalidNumberStartWithIPositive() throws IOException { [EOL] JsonParser jp = createParserWithContent("+INF"); [EOL] jp.enable(Feature.ALLOW_NON_NUMERIC_NUMBERS); [EOL] JsonToken result = jp._handleInvalidNumberStart('I', false); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] assertEquals(Double.POSITIVE_INFINITY, jp.getDoubleValue(), 0.0); [EOL] }
public void testHandleInvalidNumberStartWithNonNumericNumbersDisabled() throws IOException { [EOL] JsonParser jp = createParserWithContent("I"); [EOL] try { [EOL] jp._handleInvalidNumberStart('I', false); [EOL] fail("Should throw JsonParseException due to non-numeric numbers disabled"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleInvalidNumberStartWithLowercaseNAndLoadMoreFails() throws IOException { [EOL] JsonParser jp = createParserWithContent("n"); [EOL] try { [EOL] jp._handleInvalidNumberStart('n', false); [EOL] fail("Should throw JsonParseException due to invalid EOF"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleInvalidNumberStartWithLowercaseNNegative() throws IOException { [EOL] JsonParser jp = createParserWithContent("-Infinity"); [EOL] jp.enable(Feature.ALLOW_NON_NUMERIC_NUMBERS); [EOL] JsonToken result = jp._handleInvalidNumberStart('n', true); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] assertEquals(Double.NEGATIVE_INFINITY, jp.getDoubleValue(), 0.0); [EOL] }
public void testHandleInvalidNumberStartWithLowercaseNPositive() throws IOException { [EOL] JsonParser jp = createParserWithContent("+Infinity"); [EOL] jp.enable(Feature.ALLOW_NON_NUMERIC_NUMBERS); [EOL] JsonToken result = jp._handleInvalidNumberStart('n', false); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] assertEquals(Double.POSITIVE_INFINITY, jp.getDoubleValue(), 0.0); [EOL] }
public void testHandleInvalidNumberStartWithUnexpectedChar() throws IOException { [EOL] JsonParser jp = createParserWithContent("a"); [EOL] try { [EOL] jp._handleInvalidNumberStart('a', false); [EOL] fail("Should throw JsonParseException due to unexpected character"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testParseFieldNameWithNonQuoteChar() throws IOException, JsonParseException { [EOL] final int NON_QUOTE_INT = 65; // 'A' for example, which is not a quote [EOL] String result = _parseFieldName(NON_QUOTE_INT); [EOL] assertNotNull(result); [EOL] }
public void testParseFieldNameWithQuoteCharAtBufferEnd() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 0; // Simulate end of buffer [EOL] _hashSeed = 1; // Some hash seed value [EOL] String result = _parseFieldName(INT_QUOTE); [EOL] assertNotNull(result); [EOL] }
public void testParseFieldNameWithQuoteCharBeforeBufferEnd() throws IOException, JsonParseException { [EOL] _inputPtr = 0; [EOL] _inputEnd = 10; // Simulate buffer with enough space [EOL] _inputBuffer = new int[]{34, 0, 0, 0, 0, 0, 0, 0, 0, 0}; // 34 is the ASCII code for quote [EOL] _hashSeed = 1; // Some hash seed value [EOL] String result = _parseFieldName(INT_QUOTE); [EOL] assertNotNull(result); [EOL] }
public void testParseFieldName2_EndOfInput() throws IOException, JsonParseException { [EOL] }
public void testParseFieldName2_DecodeEscaped() throws IOException, JsonParseException { [EOL] }
public void testParseFieldName2_EndChar() throws IOException, JsonParseException { [EOL] }
public void testParseFieldName2_ThrowUnquotedSpace() throws IOException, JsonParseException { [EOL] }
public void testParseFieldName2_BufferExpansion() throws IOException, JsonParseException { [EOL] }
public void testParseFieldName2_SymbolFinding() throws IOException, JsonParseException { [EOL] }
public void testHandleUnexpectedValueSingleQuoteAllowed() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithFeatureEnabled(Feature.ALLOW_SINGLE_QUOTES); [EOL] JsonToken result = parser._handleUnexpectedValue('\''); [EOL] assertEquals(JsonToken.VALUE_STRING, result); [EOL] }
public void testHandleUnexpectedValueSingleQuoteNotAllowed() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithFeatureDisabled(Feature.ALLOW_SINGLE_QUOTES); [EOL] try { [EOL] parser._handleUnexpectedValue('\''); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleUnexpectedValueNaNAllowed() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithFeatureEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS); [EOL] JsonToken result = parser._handleUnexpectedValue('N'); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
public void testHandleUnexpectedValueNaNNotAllowed() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithFeatureDisabled(Feature.ALLOW_NON_NUMERIC_NUMBERS); [EOL] try { [EOL] parser._handleUnexpectedValue('N'); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleUnexpectedValueInfinityAllowed() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithFeatureEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS); [EOL] JsonToken result = parser._handleUnexpectedValue('I'); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
public void testHandleUnexpectedValueInfinityNotAllowed() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithFeatureDisabled(Feature.ALLOW_NON_NUMERIC_NUMBERS); [EOL] try { [EOL] parser._handleUnexpectedValue('I'); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleUnexpectedValuePlusWithNoMoreInput() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserAtEndOfInput(); [EOL] try { [EOL] parser._handleUnexpectedValue('+'); [EOL] fail("Expected JsonParseException for invalid EOF"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleUnexpectedValuePlusWithMoreInput() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParserWithAdditionalInput(); [EOL] JsonToken result = parser._handleUnexpectedValue('+'); [EOL] assertEquals(JsonToken.VALUE_NUMBER_INT, result); [EOL] }
public void testHandleUnexpectedValueJavaIdentifierStart() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParser(); [EOL] try { [EOL] parser._handleUnexpectedValue('a'); [EOL] fail("Expected JsonParseException for invalid token"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testHandleUnexpectedValueInvalidChar() throws IOException, JsonParseException { [EOL] JsonParserImpl parser = createParser(); [EOL] try { [EOL] parser._handleUnexpectedValue('%'); [EOL] fail("Expected JsonParseException for unexpected character"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
protected void _finishString2() throws IOException, JsonParseException { [EOL] char[] outBuf = _textBuffer.getCurrentSegment(); [EOL] int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL] while (true) { [EOL] if (_inputPtr >= _inputEnd) { [EOL] if (!loadMore()) { [EOL] _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL] } [EOL] } [EOL] char c = _inputBuffer[_inputPtr++]; [EOL] int i = (int) c; [EOL] if (i <= INT_BACKSLASH) { [EOL] if (i == INT_BACKSLASH) { [EOL] c = _decodeEscaped(); [EOL] } else if (i <= INT_QUOTE) { [EOL] if (i == INT_QUOTE) { [EOL] break; [EOL] } [EOL] if (i < INT_SPACE) { [EOL] _throwUnquotedSpace(i, "string value"); [EOL] } [EOL] } [EOL] } [EOL] if (outPtr >= outBuf.length) { [EOL] outBuf = _textBuffer.finishCurrentSegment(); [EOL] outPtr = 0; [EOL] } [EOL] outBuf[outPtr++] = c; [EOL] } [EOL] _textBuffer.setCurrentLength(outPtr); [EOL] }
public void testDecodeEscapedInputPtrAtInputEndAndLoadMoreFails() throws IOException, JsonParseException { [EOL] _inputPtr = _inputEnd; [EOL] try { [EOL] char result = _decodeEscaped(); [EOL] fail("Expected JsonParseException due to invalid EOF"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testDecodeEscapedWithRecognizedEscapeCharacter() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[] {'\\', 'n'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = 2; [EOL] char result = _decodeEscaped(); [EOL] assertEquals('\n', result); [EOL] }
public void testDecodeEscapedWithUnrecognizedEscapeCharacter() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[] {'\\', 'x'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = 2; [EOL] char result = _decodeEscaped(); [EOL] assertEquals('x', result); [EOL] }
public void testDecodeEscapedWithHexadecimalSequence() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[] {'\\', 'u', '0', '0', '4', '1'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = 6; [EOL] char result = _decodeEscaped(); [EOL] assertEquals('A', result); [EOL] }
public void testDecodeEscapedWithInvalidHexadecimalSequence() throws IOException, JsonParseException { [EOL] _inputBuffer = new char[] {'\\', 'u', '0', '0', 'Z', 'G'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = 6; [EOL] try { [EOL] char result = _decodeEscaped(); [EOL] fail("Expected JsonParseException due to invalid hexadecimal sequence"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testDecodeBase64WithPadding() throws IOException, JsonParseException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] _inputBuffer = new char[]{'a', 'B', 'c', '=', '='}; [EOL] _inputPtr = 0; [EOL] _inputEnd = 5; [EOL] byte[] result = _decodeBase64(b64variant); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.length); [EOL] }
public void testDecodeBase64WithoutPadding() throws IOException, JsonParseException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] _inputBuffer = new char[]{'a', 'B', 'c', '"'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = 4; [EOL] byte[] result = _decodeBase64(b64variant); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.length); [EOL] }
public void testDecodeBase64WithInvalidChar() throws IOException, JsonParseException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] _inputBuffer = new char[]{'a', 'B', '!', 'd', 'e', 'f'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = 6; [EOL] try { [EOL] _decodeBase64(b64variant); [EOL] fail("Should throw JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testDecodeBase64WithIncompleteQuartet() throws IOException, JsonParseException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] _inputBuffer = new char[]{'a', 'B', 'c'}; [EOL] _inputPtr = 0; [EOL] _inputEnd = 3; [EOL] try { [EOL] _decodeBase64(b64variant); [EOL] fail("Should throw JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testWriteStartArrayWithPrettyPrinter() throws IOException { [EOL] JsonGeneratorImpl generator = createGeneratorWithPrettyPrinter(); [EOL] generator.writeStartArray(); [EOL] assertTrue(generator.getOutputContext().inArray()); [EOL] } [EOL] public void testWriteStartArrayWithoutPrettyPrinter() throws IOException { [EOL] JsonGeneratorImpl generator = createGeneratorWithoutPrettyPrinter(); [EOL] generator.writeStartArray(); [EOL] assertTrue(generator.getOutputContext().inArray()); [EOL] assertEquals('[', generator.getOutputBuffer()[generator.getOutputTail() - 1]); [EOL] } [EOL] public void testWriteStartArrayWithBufferFlush() throws IOException { [EOL] JsonGeneratorImpl generator = createGeneratorWithFullBuffer(); [EOL] generator.writeStartArray(); [EOL] assertEquals('[', generator.getOutputBuffer()[0]); [EOL] }

public void testWriteEndArrayNotInArrayContext() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGeneratorImpl(); [EOL] setWriteContextNotInArray(generator); [EOL] try { [EOL] generator.writeEndArray(); [EOL] fail("Should not pass, as the current context is not an array."); [EOL] } catch (JsonGenerationException e) { [EOL] } [EOL] } [EOL] public void testWriteEndArrayWithPrettyPrinter() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGeneratorImpl(); [EOL] setPrettyPrinter(generator); [EOL] enterArrayContext(generator); [EOL] generator.writeEndArray(); [EOL] assertTrue("Pretty printer should be called.", wasPrettyPrinterInvoked(generator)); [EOL] } [EOL] public void testWriteEndArrayWithoutPrettyPrinter() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGeneratorImpl(); [EOL] unsetPrettyPrinter(generator); [EOL] enterArrayContext(generator); [EOL] generator.writeEndArray(); [EOL] assertTrue("Output buffer should contain end array character.", isEndArrayCharWritten(generator)); [EOL] } [EOL] public void testWriteEndArrayOutputBufferFull() throws IOException { [EOL] JsonGeneratorImpl generator = createJsonGeneratorImpl(); [EOL] unsetPrettyPrinter(generator); [EOL] enterArrayContext(generator); [EOL] fillOutputBuffer(generator); [EOL] generator.writeEndArray(); [EOL] assertTrue("Output buffer should be flushed and contain end array character.", isEndArrayCharWrittenAfterFlush(generator)); [EOL] }
public void testWriteBinaryWithEnoughSpace() throws IOException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] byte[] data = "TestData".getBytes(); [EOL] int offset = 0; [EOL] int len = data.length; [EOL] JsonGeneratorImpl generator = createGeneratorWithMockedBuffer(); [EOL] generator.writeBinary(b64variant, data, offset, len); [EOL] assertEquals('"', generator._outputBuffer[generator._outputTail - len - 2]); [EOL] assertEquals('"', generator._outputBuffer[generator._outputTail - 1]); [EOL] } [EOL] public void testWriteBinaryWithBufferFlush() throws IOException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] byte[] data = "TestData".getBytes(); [EOL] int offset = 0; [EOL] int len = data.length; [EOL] JsonGeneratorImpl generator = createGeneratorWithMockedBuffer(); [EOL] generator._outputTail = generator._outputEnd - 1; [EOL] generator.writeBinary(b64variant, data, offset, len); [EOL] assertEquals('"', generator._outputBuffer[1]); // After flush, it should write at the start [EOL] assertEquals('"', generator._outputBuffer[generator._outputTail - 1]); [EOL] }
public void testWriteNumberWithNumbersAsStringsTrue() throws IOException { [EOL] JsonGeneratorImpl generator = createGeneratorWithNumbersAsStringsConfig(true); [EOL] generator.writeNumber(123); [EOL] assertEquals("\"123\"", generator.getOutput()); [EOL] }
public void testWriteNumberWithNumbersAsStringsFalseBufferNotFull() throws IOException { [EOL] JsonGeneratorImpl generator = createGeneratorWithNumbersAsStringsConfig(false); [EOL] generator.writeNumber(123); [EOL] assertEquals("123", generator.getOutput()); [EOL] assertTrue(generator.getOutputTail() > 0); [EOL] }
public void testWriteNumberWithNumbersAsStringsFalseBufferFull() throws IOException { [EOL] JsonGeneratorImpl generator = createGeneratorWithNumbersAsStringsConfig(false); [EOL] generator.fillBufferToForceFlush(); [EOL] generator.writeNumber(123); [EOL] assertEquals("123", generator.getOutput()); [EOL] assertTrue(generator.getOutputTail() > 0); [EOL] }
public void testCloseWithAutoCloseJsonContentEnabledAndInArray() throws IOException { [EOL] JsonGenerator g = createGenerator(); // Assume this method properly creates a JsonGenerator [EOL] g.writeStartArray(); [EOL] g.enable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT); [EOL] g.close(); [EOL] } [EOL] public void testCloseWithAutoCloseJsonContentEnabledAndInObject() throws IOException { [EOL] JsonGenerator g = createGenerator(); // Assume this method properly creates a JsonGenerator [EOL] g.writeStartObject(); [EOL] g.enable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT); [EOL] g.close(); [EOL] } [EOL] public void testCloseWithAutoCloseJsonContentDisabled() throws IOException { [EOL] JsonGenerator g = createGenerator(); // Assume this method properly creates a JsonGenerator [EOL] g.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT); [EOL] g.close(); [EOL] } [EOL] public void testCloseWithAutoCloseTargetEnabled() throws IOException { [EOL] JsonGenerator g = createGenerator(); // Assume this method properly creates a JsonGenerator [EOL] g.enable(JsonGenerator.Feature.AUTO_CLOSE_TARGET); [EOL] g.close(); [EOL] } [EOL] public void testCloseWithAutoCloseTargetDisabled() throws IOException { [EOL] JsonGenerator g = createGenerator(); // Assume this method properly creates a JsonGenerator [EOL] g.disable(JsonGenerator.Feature.AUTO_CLOSE_TARGET); [EOL] g.close(); [EOL] } [EOL] public void testCloseWithFlushPassedToStreamEnabled() throws IOException { [EOL] JsonGenerator g = createGenerator(); // Assume this method properly creates a JsonGenerator [EOL] g.enable(JsonGenerator.Feature.FLUSH_PASSED_TO_STREAM); [EOL] g.close(); [EOL] } [EOL] public void testCloseWithFlushPassedToStreamDisabled() throws IOException { [EOL] JsonGenerator g = createGenerator(); // Assume this method properly creates a JsonGenerator [EOL] g.disable(JsonGenerator.Feature.FLUSH_PASSED_TO_STREAM); [EOL] g.close(); [EOL] } [EOL] public void testCloseWithResourceManaged() throws IOException { [EOL] JsonGenerator g = createGenerator(); // Assume this method properly creates a JsonGenerator [EOL] g.getOutputContext().setResourceManaged(true); [EOL] g.close(); [EOL] } [EOL] public void testCloseWithResourceNotManaged() throws IOException { [EOL] JsonGenerator g = createGenerator(); // Assume this method properly creates a JsonGenerator [EOL] g.getOutputContext().setResourceManaged(false); [EOL] g.close(); [EOL] }
public void testWriteStringWithLongText() throws IOException, JsonGenerationException { [EOL] String longText = createLongText(); // Assume createLongText() creates a string longer than _outputEnd [EOL] _writeString(longText); [EOL] } [EOL] public void testWriteStringWithFlushBuffer() throws IOException, JsonGenerationException { [EOL] String text = "short text"; [EOL] _outputTail = _outputEnd - text.length() + 1; // Set _outputTail such that (_outputTail + len) > _outputEnd [EOL] _writeString(text); [EOL] } [EOL] public void testWriteStringWithCharacterEscapes() throws IOException, JsonGenerationException { [EOL] String text = "text with escapes"; [EOL] _characterEscapes = createCharacterEscapes(); // Assume createCharacterEscapes() creates a non-null _characterEscapes [EOL] _writeString(text); [EOL] } [EOL] public void testWriteStringWithMaximumNonEscapedChar() throws IOException, JsonGenerationException { [EOL] String text = "text"; [EOL] _maximumNonEscapedChar = 127; // ASCII value less than text characters [EOL] _writeString(text); [EOL] } [EOL] public void testWriteStringWithNoEscaping() throws IOException, JsonGenerationException { [EOL] String text = "text"; [EOL] _maximumNonEscapedChar = 0; [EOL] _characterEscapes = null; [EOL] _writeString(text); [EOL] }
public void testWriteLongStringWithNoEscapes() throws IOException, JsonGenerationException { [EOL] String text = "This is a long string without any special characters that need to be escaped."; [EOL] _writeLongString(text); [EOL] }
public void testWriteLongStringWithCharacterEscapes() throws IOException, JsonGenerationException { [EOL] String text = "String with escape characters, e.g., \t or \n."; [EOL] _writeLongString(text); [EOL] }
public void testWriteLongStringWithNonEscapedChars() throws IOException, JsonGenerationException { [EOL] String text = "String with non-escaped characters that exceed the _maximumNonEscapedChar value."; [EOL] _writeLongString(text); [EOL] }
public void testWriteLongStringEmpty() throws IOException, JsonGenerationException { [EOL] String text = ""; [EOL] _writeLongString(text); [EOL] }
public void testWriteSegmentWithNoEscapes() throws IOException, JsonGenerationException { [EOL] _outputBuffer = new char[]{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}; [EOL] _outputEscapes = new int[128]; // Assuming ASCII, no escapes by default [EOL] StringWriter _writer = new StringWriter(); [EOL] int end = _outputBuffer.length; [EOL] _writeSegment(end); [EOL] assertEquals("abcdefghij", _writer.toString()); [EOL] }
public void testWriteSegmentWithEscapes() throws IOException, JsonGenerationException { [EOL] _outputBuffer = new char[]{'a', 'b', '<', 'd', 'e', '>', 'g', 'h', 'i', 'j'}; [EOL] _outputEscapes = new int[128]; [EOL] _outputEscapes['<'] = 1; // Setting escape code for '<' [EOL] _outputEscapes['>'] = 1; // Setting escape code for '>' [EOL] StringWriter _writer = new StringWriter(); [EOL] int end = _outputBuffer.length; [EOL] _prependOrWriteCharacterEscape = (buffer, ptr, end, c, escCode) -> { [EOL] _writer.write("\\u00" + Integer.toHexString(c)); [EOL] return ptr; [EOL] }; [EOL] _writeSegment(end); [EOL] assertEquals("ab\\u003cd\\u003eefghij", _writer.toString()); [EOL] }
public void testWriteStringWithCharacterEscapes() throws IOException, JsonGenerationException { [EOL] char[] text = new char[]{'a', 'b', 'c', '\\', 'n'}; [EOL] int offset = 0; [EOL] int len = text.length; [EOL] _characterEscapes = mock(CharacterEscapes.class); [EOL] _writeString(text, offset, len); [EOL] verify(this, times(1))._writeStringCustom(text, offset, len); [EOL] }
public void testWriteStringWithMaximumNonEscapedChar() throws IOException, JsonGenerationException { [EOL] char[] text = new char[]{'a', 'b', 'c', 'd', 'e'}; [EOL] int offset = 0; [EOL] int len = text.length; [EOL] _maximumNonEscapedChar = 127; [EOL] _writeString(text, offset, len); [EOL] verify(this, times(1))._writeStringASCII(text, offset, len, _maximumNonEscapedChar); [EOL] }
public void testWriteStringWithoutEscaping() throws IOException, JsonGenerationException { [EOL] char[] text = new char[]{'a', 'b', 'c', 'd', 'e'}; [EOL] int offset = 0; [EOL] int len = 3; [EOL] _characterEscapes = null; [EOL] _maximumNonEscapedChar = 0; [EOL] _outputEscapes = new int[128]; [EOL] Arrays.fill(_outputEscapes, 0); [EOL] _outputBuffer = new char[10]; [EOL] _outputTail = 0; [EOL] _outputEnd = 10; [EOL] _writeString(text, offset, len); [EOL] assertEquals("abc", new String(_outputBuffer).trim()); [EOL] }
public void testWriteStringWithEscaping() throws IOException, JsonGenerationException { [EOL] char[] text = new char[]{'a', 'b', 'c', '<', 'd', 'e'}; [EOL] int offset = 0; [EOL] int len = text.length; [EOL] _characterEscapes = null; [EOL] _maximumNonEscapedChar = 0; [EOL] _outputEscapes = new int[128]; [EOL] Arrays.fill(_outputEscapes, 0); [EOL] _outputEscapes['<'] = CharacterEscapes.ESCAPE_STANDARD; [EOL] _outputBuffer = new char[10]; [EOL] _outputTail = 0; [EOL] _outputEnd = 10; [EOL] _writeString(text, offset, len); [EOL] assertTrue(new String(_outputBuffer).contains("<")); // Assuming _appendCharacterEscape does the escaping [EOL] }
public void testWriteStringNeedingFlush() throws IOException, JsonGenerationException { [EOL] char[] text = new char[]{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k'}; [EOL] int offset = 0; [EOL] int len = text.length; [EOL] _characterEscapes = null; [EOL] _maximumNonEscapedChar = 0; [EOL] _outputEscapes = new int[128]; [EOL] Arrays.fill(_outputEscapes, 0); [EOL] _outputBuffer = new char[10]; [EOL] _outputTail = 0; [EOL] _outputEnd = 10; [EOL] _writeString(text, offset, len); [EOL] verify(this, atLeastOnce())._flushBuffer(); [EOL] }
public void testWriteSegmentCustomWithNonEscapedChars() throws IOException, JsonGenerationException { [EOL] _writeSegmentCustom(10); [EOL] }
public void testWriteSegmentCustomWithEscapedChars() throws IOException, JsonGenerationException { [EOL] _outputEscapes['a'] = 1; // Assuming 'a' is within the escLimit [EOL] _writeSegmentCustom(10); [EOL] }
public void testWriteSegmentCustomWithCustomEscapes() throws IOException, JsonGenerationException { [EOL] when(_characterEscapes.getEscapeSequence(anyChar())).thenReturn(new SerializableString() { [EOL] @Override [EOL] public String getValue() { [EOL] return "custom_escape"; [EOL] } [EOL] @Override [EOL] public int charLength() { [EOL] return "custom_escape".length(); [EOL] } [EOL] @Override [EOL] public char[] asQuotedChars() { [EOL] return "custom_escape".toCharArray(); [EOL] } [EOL] @Override [EOL] public byte[] asUnquotedUTF8() { [EOL] return "custom_escape".getBytes(); [EOL] } [EOL] @Override [EOL] public byte[] asQuotedUTF8() { [EOL] return "custom_escape".getBytes(); [EOL] } [EOL] }); [EOL] _writeSegmentCustom(10); [EOL] }
public void testWriteSegmentCustomWithHighNonEscapedChar() throws IOException, JsonGenerationException { [EOL] _maximumNonEscapedChar = 0x10FFFF; // Setting to the maximum possible unicode value [EOL] _writeSegmentCustom(10); [EOL] }
public void testWriteBinaryWithEmptyInput() throws IOException, JsonGenerationException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] byte[] input = new byte[0]; [EOL] int inputPtr = 0; [EOL] int inputEnd = 0; [EOL] _writeBinary(b64variant, input, inputPtr, inputEnd); [EOL] }
public void testWriteBinaryWithExactSafeInputEnd() throws IOException, JsonGenerationException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] byte[] input = new byte[3]; // Assuming _outputEnd is more than 6 for this test [EOL] int inputPtr = 0; [EOL] int inputEnd = 3; [EOL] _writeBinary(b64variant, input, inputPtr, inputEnd); [EOL] }
public void testWriteBinaryWithInputRequiringFlush() throws IOException, JsonGenerationException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] byte[] input = new byte[9]; // Assuming _outputEnd is less than 6 for this test [EOL] int inputPtr = 0; [EOL] int inputEnd = 9; [EOL] _writeBinary(b64variant, input, inputPtr, inputEnd); [EOL] }
public void testWriteBinaryWithInputAndNewLine() throws IOException, JsonGenerationException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] b64variant.setMaxLineLength(4); // Setting max line length to 1 chunk [EOL] byte[] input = new byte[12]; // 3 chunks of data [EOL] int inputPtr = 0; [EOL] int inputEnd = 12; [EOL] _writeBinary(b64variant, input, inputPtr, inputEnd); [EOL] }
public void testWriteBinaryWithPartialChunkAtEnd() throws IOException, JsonGenerationException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] byte[] input = new byte[5]; // 1 full chunk and a partial chunk [EOL] int inputPtr = 0; [EOL] int inputEnd = 5; [EOL] _writeBinary(b64variant, input, inputPtr, inputEnd); [EOL] }
public void testWriteBinaryWithTwoBytePartialChunkAtEnd() throws IOException, JsonGenerationException { [EOL] Base64Variant b64variant = Base64Variants.getDefaultVariant(); [EOL] byte[] input = new byte[4]; // Only a two-byte partial chunk at the end [EOL] int inputPtr = 0; [EOL] int inputEnd = 4; [EOL] _writeBinary(b64variant, input, inputPtr, inputEnd); [EOL] }
public void testPrependOrWriteCharacterEscape_escCodePositive_bufferHasRoom() throws IOException, JsonGenerationException { [EOL] char[] buffer = new char[10]; [EOL] int ptr = 5; [EOL] int end = 10; [EOL] char ch = 'a'; [EOL] int escCode = 1; // Positive escCode, buffer has room [EOL] int result = _prependOrWriteCharacterEscape(buffer, ptr, end, ch, escCode); [EOL] assertEquals(3, result); [EOL] assertEquals('\\', buffer[3]); [EOL] assertEquals((char) escCode, buffer[4]); [EOL] }
public void testPrependOrWriteCharacterEscape_escCodePositive_bufferNoRoom() throws IOException, JsonGenerationException { [EOL] char[] buffer = new char[10]; [EOL] int ptr = 1; [EOL] int end = 10; [EOL] char ch = 'a'; [EOL] int escCode = 1; // Positive escCode, buffer doesn't have room [EOL] int result = _prependOrWriteCharacterEscape(buffer, ptr, end, ch, escCode); [EOL] }
public void testPrependOrWriteCharacterEscape_escCodeNotEscapeCustom_bufferHasRoom() throws IOException, JsonGenerationException { [EOL] char[] buffer = new char[10]; [EOL] int ptr = 7; [EOL] int end = 10; [EOL] char ch = 0x1234; // Character that will result in a unicode escape [EOL] int escCode = -1; // Not ESCAPE_CUSTOM [EOL] int result = _prependOrWriteCharacterEscape(buffer, ptr, end, ch, escCode); [EOL] assertEquals(1, result); [EOL] assertEquals('\\', buffer[1]); [EOL] assertEquals('u', buffer[2]); [EOL] }
public void testPrependOrWriteCharacterEscape_escCodeNotEscapeCustom_bufferNoRoom() throws IOException, JsonGenerationException { [EOL] char[] buffer = new char[10]; [EOL] int ptr = 5; [EOL] int end = 10; [EOL] char ch = 0x1234; // Character that will result in a unicode escape [EOL] int escCode = -1; // Not ESCAPE_CUSTOM [EOL] int result = _prependOrWriteCharacterEscape(buffer, ptr, end, ch, escCode); [EOL] }
public void testPrependOrWriteCharacterEscape_escCodeEscapeCustom_currentEscapeNull() throws IOException, JsonGenerationException { [EOL] char[] buffer = new char[10]; [EOL] int ptr = 9; [EOL] int end = 10; [EOL] char ch = 'a'; [EOL] int escCode = CharacterEscapes.ESCAPE_CUSTOM; [EOL] int result = _prependOrWriteCharacterEscape(buffer, ptr, end, ch, escCode); [EOL] }
public void testPrependOrWriteCharacterEscape_escCodeEscapeCustom_currentEscapeNotNull() throws IOException, JsonGenerationException { [EOL] char[] buffer = new char[10]; [EOL] int ptr = 9; [EOL] int end = 10; [EOL] char ch = 'a'; [EOL] int escCode = CharacterEscapes.ESCAPE_CUSTOM; [EOL] int result = _prependOrWriteCharacterEscape(buffer, ptr, end, ch, escCode); [EOL] }
public void testAppendCharacterEscapeWithPositiveEscCode() throws IOException, JsonGenerationException { [EOL] char ch = 'a'; [EOL] int escCode = 1; // Positive escCode to enter the first if condition [EOL] _appendCharacterEscape(ch, escCode); [EOL] }
public void testAppendCharacterEscapeWithNonCustomNegativeEscCodeAndCharLessThan256() throws IOException, JsonGenerationException { [EOL] char ch = 'b'; // Character less than 256 to enter the else branch and the inner else branch [EOL] int escCode = -1; // Negative escCode, not ESCAPE_CUSTOM to enter the second if condition [EOL] _appendCharacterEscape(ch, escCode); [EOL] }
public void testAppendCharacterEscapeWithNonCustomNegativeEscCodeAndCharMoreThan255() throws IOException, JsonGenerationException { [EOL] char ch = 300; // Character more than 255 to enter the else branch and the inner if branch [EOL] int escCode = -1; // Negative escCode, not ESCAPE_CUSTOM to enter the second if condition [EOL] _appendCharacterEscape(ch, escCode); [EOL] }
public void testAppendCharacterEscapeWithCustomEscCode() throws IOException, JsonGenerationException { [EOL] char ch = 'c'; [EOL] int escCode = CharacterEscapes.ESCAPE_CUSTOM; // ESCAPE_CUSTOM to enter the third if condition [EOL] _appendCharacterEscape(ch, escCode); [EOL] }
public void testAppendCharacterEscapeWithCurrentEscapeNonNull() throws IOException, JsonGenerationException { [EOL] char ch = 'd'; [EOL] int escCode = CharacterEscapes.ESCAPE_CUSTOM; // ESCAPE_CUSTOM to enter the third if condition [EOL] _currentEscape = new SerializedString("\\u1234"); // Non-null _currentEscape to enter the else branch in the third if condition [EOL] _appendCharacterEscape(ch, escCode); [EOL] }
public void testAppendCharacterEscapeWithEscapeLengthGreaterThanOutputEnd() throws IOException, JsonGenerationException { [EOL] char ch = 'e'; [EOL] int escCode = CharacterEscapes.ESCAPE_CUSTOM; // ESCAPE_CUSTOM to enter the third if condition [EOL] _currentEscape = new SerializedString(new String(new char[_outputEnd + 1]).replace("\0", "e")); // Escape length greater than _outputEnd to enter the if condition [EOL] _appendCharacterEscape(ch, escCode); [EOL] }
public void testAllocateEntityBuffer() { [EOL] char[] entityBuffer = _allocateEntityBuffer(); [EOL] assertNotNull(entityBuffer); [EOL] assertEquals(14, entityBuffer.length); [EOL] assertEquals('\\', entityBuffer[0]); [EOL] assertEquals('\\', entityBuffer[2]); [EOL] assertEquals('u', entityBuffer[3]); [EOL] assertEquals('0', entityBuffer[4]); [EOL] assertEquals('0', entityBuffer[5]); [EOL] assertEquals('\\', entityBuffer[8]); [EOL] assertEquals('u', entityBuffer[9]); [EOL] for (int i = 1; i < entityBuffer.length; i++) { [EOL] if (i != 2 && i != 3 && i != 4 && i != 5 && i != 8 && i != 9) { [EOL] assertEquals('\u0000', entityBuffer[i]); [EOL] } [EOL] } [EOL] }
public void testAppendQuotedWithNoEscaping() { [EOL] StringBuilder sb = new StringBuilder(); [EOL] String content = "normalText"; [EOL] appendQuoted(sb, content); [EOL] assertEquals("normalText", sb.toString()); [EOL] } [EOL] public void testAppendQuotedWithEscaping() { [EOL] StringBuilder sb = new StringBuilder(); [EOL] String content = "textWith\"Quotes\""; [EOL] appendQuoted(sb, content); [EOL] assertEquals("textWith\\\"Quotes\\\"", sb.toString()); [EOL] } [EOL] public void testAppendQuotedWithSpecialCharacters() { [EOL] StringBuilder sb = new StringBuilder(); [EOL] String content = "textWith\nNewLine"; [EOL] appendQuoted(sb, content); [EOL] assertEquals("textWith\\nNewLine", sb.toString()); [EOL] } [EOL] public void testAppendQuotedWithUnicodeEscaping() { [EOL] StringBuilder sb = new StringBuilder(); [EOL] String content = "textWithSpecialChar\u0001"; [EOL] appendQuoted(sb, content); [EOL] assertTrue(sb.toString().contains("\\u0001")); [EOL] }
public void testAppendQuotedWithAllEscapableCharacters() { [EOL] StringBuilder sb = new StringBuilder(); [EOL] String content = "\"\\\b\f\n\r\t"; [EOL] appendQuoted(sb, content); [EOL] assertEquals("\\\"\\\\\\b\\f\\n\\r\\t", sb.toString()); [EOL] }
public void testQuoteAsUTF8WithEmptyString() { [EOL] JsonStringEncoder encoder = new JsonStringEncoder(); [EOL] byte[] result = encoder.quoteAsUTF8(""); [EOL] assertEquals(0, result.length); [EOL] }
public void testQuoteAsUTF8WithAscii() { [EOL] JsonStringEncoder encoder = new JsonStringEncoder(); [EOL] String text = "abc"; [EOL] byte[] result = encoder.quoteAsUTF8(text); [EOL] byte[] expected = new byte[]{'a', 'b', 'c'}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testQuoteAsUTF8WithEscapeChars() { [EOL] JsonStringEncoder encoder = new JsonStringEncoder(); [EOL] String text = "\"abc\""; [EOL] byte[] result = encoder.quoteAsUTF8(text); [EOL] byte[] expected = new byte[]{/* appropriate escape sequence for double quote */, 'a', 'b', 'c', /* appropriate escape sequence for double quote */}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testQuoteAsUTF8WithHighAscii() { [EOL] JsonStringEncoder encoder = new JsonStringEncoder(); [EOL] String text = "abc\u007F"; [EOL] byte[] result = encoder.quoteAsUTF8(text); [EOL] byte[] expected = new byte[]{'a', 'b', 'c', /* appropriate escape sequence for 0x7F */}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testQuoteAsUTF8WithUtf8Multibyte() { [EOL] JsonStringEncoder encoder = new JsonStringEncoder(); [EOL] String text = ""; [EOL] byte[] result = encoder.quoteAsUTF8(text); [EOL] byte[] expected = new byte[]{(byte) 0xC3, (byte) 0xB1}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testQuoteAsUTF8WithSurrogatePair() { [EOL] JsonStringEncoder encoder = new JsonStringEncoder(); [EOL] String text = "\uD83D\uDE00"; // U+1F600: GRINNING FACE [EOL] byte[] result = encoder.quoteAsUTF8(text); [EOL] byte[] expected = new byte[]{(byte) 0xF0, (byte) 0x9F, (byte) 0x98, (byte) 0x80}; [EOL] assertArrayEquals(expected, result); [EOL] }
public void testQuoteAsUTF8WithInvalidSurrogate() { [EOL] JsonStringEncoder encoder = new JsonStringEncoder(); [EOL] String text = "\uDC00"; // Unpaired low surrogate [EOL] try { [EOL] encoder.quoteAsUTF8(text); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public JsonToken testNextValueWithFieldNameToken() throws IOException, JsonParseException { [EOL] JsonParser parser = Mockito.mock(JsonParser.class); [EOL] Mockito.when(parser.nextToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.VALUE_STRING); [EOL] JsonToken result = parser.nextValue(); [EOL] assertEquals(JsonToken.VALUE_STRING, result); [EOL] }
public JsonToken testNextValueWithNonFieldNameToken() throws IOException, JsonParseException { [EOL] JsonParser parser = Mockito.mock(JsonParser.class); [EOL] Mockito.when(parser.nextToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] JsonToken result = parser.nextValue(); [EOL] assertEquals(JsonToken.VALUE_NUMBER_INT, result); [EOL] }
protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException { [EOL] if (isEnabled(Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER)) { [EOL] return ch; [EOL] } [EOL] if (ch == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL] return ch; [EOL] } [EOL] _reportError("Unrecognized character escape " + _getCharDesc(ch)); [EOL] return ch; [EOL] } [EOL] protected ParserMinimalBase(); [EOL] protected ParserMinimalBase(int features); [EOL] public Version version(); [EOL] public abstract JsonToken nextToken() throws IOException, JsonParseException; [EOL] public JsonToken getCurrentToken(); [EOL] public boolean hasCurrentToken(); [EOL] public JsonToken nextValue() throws IOException, JsonParseException; [EOL] public JsonParser skipChildren() throws IOException, JsonParseException; [EOL] protected abstract void _handleEOF() throws JsonParseException; [EOL] public abstract String getCurrentName() throws IOException, JsonParseException; [EOL] public abstract void close() throws IOException; [EOL] public abstract boolean isClosed(); [EOL] public abstract JsonStreamContext getParsingContext(); [EOL] public void clearCurrentToken(); [EOL] public JsonToken getLastClearedToken(); [EOL] public abstract void overrideCurrentName(String name); [EOL] public abstract String getText() throws IOException, JsonParseException; [EOL] public abstract char[] getTextCharacters() throws IOException, JsonParseException; [EOL] public abstract boolean hasTextCharacters(); [EOL] public abstract int getTextLength() throws IOException, JsonParseException; [EOL] public abstract int getTextOffset() throws IOException, JsonParseException; [EOL] public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; [EOL] public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; [EOL] public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; [EOL] public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; [EOL] public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; [EOL] public String getValueAsString(String defaultValue) throws IOException, JsonParseException; [EOL] protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; [EOL] protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; [EOL] protected void _reportBase64EOF() throws JsonParseException; [EOL] protected boolean _hasTextualNull(String value); [EOL] protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; [EOL] protected void _reportInvalidEOF() throws JsonParseException; [EOL] protected void _reportInvalidEOF(String msg) throws JsonParseException; [EOL] protected void _reportInvalidEOFInValue() throws JsonParseException; [EOL] protected void _throwInvalidSpace(int i) throws JsonParseException; [EOL] protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; [EOL] protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; [EOL] protected static final String _getCharDesc(int ch); [EOL] protected final void _reportError(String msg) throws JsonParseException; [EOL] protected final void _wrapError(String msg, Throwable t) throws JsonParseException; [EOL] protected final void _throwInternal(); [EOL] protected final JsonParseException _constructError(String msg, Throwable t); [EOL] int INT_TAB=Optional['\t']; [EOL] int INT_LF=Optional['\n']; [EOL] int INT_CR=Optional['\r']; [EOL] int INT_SPACE=Optional[0x0020]; [EOL] int INT_LBRACKET=Optional['[']; [EOL] int INT_RBRACKET=Optional[']']; [EOL] int INT_LCURLY=Optional['{']; [EOL] int INT_RCURLY=Optional['}'];
public void testCreateChildArrayContext_WhenChildIsNull() { [EOL] JsonWriteContext parentContext = JsonWriteContext.createRootContext(null); [EOL] JsonWriteContext childContext = parentContext.createChildArrayContext(); [EOL] assertNotNull(childContext); [EOL] assertEquals(JsonWriteContext.TYPE_ARRAY, childContext.type()); [EOL] }
public void testCreateChildArrayContext_WhenChildIsNotNull() { [EOL] JsonWriteContext parentContext = JsonWriteContext.createRootContext(null); [EOL] JsonWriteContext existingChildContext = parentContext.createChildArrayContext(); [EOL] JsonWriteContext newChildContext = parentContext.createChildArrayContext(); [EOL] assertSame(existingChildContext, newChildContext); [EOL] assertEquals(JsonWriteContext.TYPE_ARRAY, newChildContext.type()); [EOL] }
public void testGetParent() { [EOL] JsonWriteContext context = new JsonWriteContext(1, null, null); [EOL] JsonWriteContext parent = new JsonWriteContext(1, null, context); [EOL] assertEquals(parent, parent.getParent()); [EOL] }
public void testWriteValueWithObjectExpectingName() { [EOL] JsonGeneratorImpl gen = new JsonGeneratorImpl(TYPE_OBJECT, null); [EOL] int status = gen.writeValue(); [EOL] assertEquals(STATUS_EXPECT_NAME, status); [EOL] }
public void testWriteValueWithObjectAfterNameSet() { [EOL] JsonGeneratorImpl gen = new JsonGeneratorImpl(TYPE_OBJECT, "name"); [EOL] int status = gen.writeValue(); [EOL] assertEquals(STATUS_OK_AFTER_COLON, status); [EOL] assertNull(gen.getCurrentName()); [EOL] assertEquals(1, gen.getIndex()); [EOL] }
public void testWriteValueWithArrayBeforeFirstElement() { [EOL] JsonGeneratorImpl gen = new JsonGeneratorImpl(TYPE_ARRAY, null); [EOL] gen.setIndex(-1); [EOL] int status = gen.writeValue(); [EOL] assertEquals(STATUS_OK_AS_IS, status); [EOL] assertEquals(0, gen.getIndex()); [EOL] }
public void testWriteValueWithArrayAfterFirstElement() { [EOL] JsonGeneratorImpl gen = new JsonGeneratorImpl(TYPE_ARRAY, null); [EOL] gen.setIndex(0); [EOL] int status = gen.writeValue(); [EOL] assertEquals(STATUS_OK_AFTER_COMMA, status); [EOL] assertEquals(1, gen.getIndex()); [EOL] }
public void testWriteValueWithNonArrayOrObject() { [EOL] JsonGeneratorImpl gen = new JsonGeneratorImpl(TYPE_OTHER, null); [EOL] int status = gen.writeValue(); [EOL] assertEquals(STATUS_OK_AS_IS, status); [EOL] assertEquals(0, gen.getIndex()); [EOL] }
public void testWriteValueWithNonArrayOrObjectAfterFirstElement() { [EOL] JsonGeneratorImpl gen = new JsonGeneratorImpl(TYPE_OTHER, null); [EOL] gen.setIndex(1); [EOL] int status = gen.writeValue(); [EOL] assertEquals(STATUS_OK_AFTER_SPACE, status); [EOL] assertEquals(2, gen.getIndex()); [EOL] }
public void testBaseReaderConstructor() { [EOL] IOContext context = new IOContext(new BufferRecycler(), new File("test"), false); [EOL] InputStream in = new ByteArrayInputStream(new byte[]{}); [EOL] byte[] buf = new byte[10]; [EOL] int ptr = 5; [EOL] int len = 10; [EOL] BaseReader reader = new BaseReader(context, in, buf, ptr, len); [EOL] assertNotNull(reader._context); [EOL] assertEquals(context, reader._context); [EOL] assertNotNull(reader._in); [EOL] assertEquals(in, reader._in); [EOL] assertNotNull(reader._buffer); [EOL] assertEquals(buf, reader._buffer); [EOL] assertEquals(ptr, reader._ptr); [EOL] assertEquals(len, reader._length); [EOL] }
public void testCloseWhenStreamIsNull() throws IOException { [EOL] MyInputStreamWrapper wrapper = new MyInputStreamWrapper(null); [EOL] wrapper.close(); [EOL] } [EOL] public void testCloseWhenStreamIsNotNull() throws IOException { [EOL] InputStream mockStream = mock(InputStream.class); [EOL] MyInputStreamWrapper wrapper = new MyInputStreamWrapper(mockStream); [EOL] wrapper.close(); [EOL] verify(mockStream).close(); [EOL] }
public void testConfigureEnableFeature() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] assertFalse(factory.isEnabled(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES)); [EOL] factory = factory.configure(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES, true); [EOL] assertTrue(factory.isEnabled(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES)); [EOL] }
public void testConfigureDisableFeature() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory = factory.configure(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES, true); [EOL] assertTrue(factory.isEnabled(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES)); [EOL] factory = factory.configure(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES, false); [EOL] assertFalse(factory.isEnabled(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES)); [EOL] }
public void testEnableFeature() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] int initialFeatures = factory._factoryFeatures; [EOL] JsonFactory.Feature featureToEnable = JsonFactory.Feature.CANONICALIZE_FIELD_NAMES; [EOL] factory.enable(featureToEnable); [EOL] int updatedFeatures = factory._factoryFeatures; [EOL] assertTrue((initialFeatures | featureToEnable.getMask()) == updatedFeatures); [EOL] }
public void testEnableFeatureAlreadyEnabled() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonFactory.Feature featureToEnable = JsonFactory.Feature.CANONICALIZE_FIELD_NAMES; [EOL] factory._factoryFeatures |= featureToEnable.getMask(); [EOL] int initialFeatures = factory._factoryFeatures; [EOL] factory.enable(featureToEnable); [EOL] int updatedFeatures = factory._factoryFeatures; [EOL] assertEquals(initialFeatures, updatedFeatures); [EOL] }
public void testDisableFeature() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] int initialFeatures = factory._factoryFeatures; [EOL] JsonFactory.Feature featureToDisable = JsonFactory.Feature.INTERN_FIELD_NAMES; [EOL] factory.disable(featureToDisable); [EOL] int featuresAfterDisable = factory._factoryFeatures; [EOL] assertNotEquals(initialFeatures, featuresAfterDisable); [EOL] assertFalse((featuresAfterDisable & featureToDisable.getMask()) != 0); [EOL] }
public void testDisableAlreadyDisabledFeature() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonFactory.Feature featureToDisable = JsonFactory.Feature.INTERN_FIELD_NAMES; [EOL] factory.disable(featureToDisable); [EOL] int featuresAfterFirstDisable = factory._factoryFeatures; [EOL] factory.disable(featureToDisable); [EOL] int featuresAfterSecondDisable = factory._factoryFeatures; [EOL] assertEquals(featuresAfterFirstDisable, featuresAfterSecondDisable); [EOL] }
public void testSetOutputDecoratorWithNull() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] OutputDecorator decorator = null; [EOL] JsonFactory result = factory.setOutputDecorator(decorator); [EOL] assertNull(factory._outputDecorator); [EOL] assertSame(factory, result); [EOL] }
public void testSetOutputDecoratorWithNonNull() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] OutputDecorator decorator = new OutputDecorator() { [EOL] }; [EOL] JsonFactory result = factory.setOutputDecorator(decorator); [EOL] assertSame(decorator, factory._outputDecorator); [EOL] assertSame(factory, result); [EOL] }
public void testGetCodec_WhenCodecIsNull() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] assertNull(factory.getCodec()); [EOL] }
public void testGetCodec_WhenCodecIsNotNull() { [EOL] JsonFactory factory = new JsonFactory(); [EOL] ObjectCodec codec = new ObjectMapper(); [EOL] factory.setCodec(codec); [EOL] assertSame(codec, factory.getCodec()); [EOL] }
public void testCreateParserWithExistingFile() throws IOException, JsonParseException { [EOL] File tempFile = File.createTempFile("test", null); [EOL] tempFile.deleteOnExit(); [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser parser = factory.createParser(tempFile); [EOL] assertNotNull(parser); [EOL] parser.close(); [EOL] }
public void testCreateParserWithInputDecorator() throws IOException, JsonParseException { [EOL] File tempFile = File.createTempFile("test", null); [EOL] tempFile.deleteOnExit(); [EOL] JsonFactory factory = new JsonFactory() { [EOL] @Override [EOL] public InputDecorator getInputDecorator() { [EOL] return new InputDecorator() { [EOL] @Override [EOL] public InputStream decorate(IOContext ctxt, InputStream in) throws IOException { [EOL] return new ByteArrayInputStream(new byte[0]); [EOL] } [EOL] }; [EOL] } [EOL] }; [EOL] JsonParser parser = factory.createParser(tempFile); [EOL] assertNotNull(parser); [EOL] parser.close(); [EOL] }
public void testCreateParserWithNullURL() throws IOException, JsonParseException { [EOL] try { [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory.createParser((URL) null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCreateParserWithValidURL() throws IOException, JsonParseException { [EOL] URL url = new URL("http://example.com"); [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser parser = factory.createParser(url); [EOL] assertNotNull(parser); [EOL] parser.close(); [EOL] }
public void testCreateParserWithInputDecorator() throws IOException, JsonParseException { [EOL] URL url = new URL("http://example.com"); [EOL] JsonFactory factory = new JsonFactory() { [EOL] @Override [EOL] protected InputStream _optimizedStreamFromURL(URL url) { [EOL] return new ByteArrayInputStream(new byte[0]); [EOL] } [EOL] }; [EOL] factory.setInputDecorator(new InputDecorator() { [EOL] @Override [EOL] public InputStream decorate(IOContext ctxt, InputStream in) { [EOL] return new ByteArrayInputStream("decorated".getBytes()); [EOL] } [EOL] }); [EOL] JsonParser parser = factory.createParser(url); [EOL] assertNotNull(parser); [EOL] parser.close(); [EOL] }
public void testCreateParserWithNullDecorator() throws IOException { [EOL] JsonFactory factory = new JsonFactory(); [EOL] byte[] data = new byte[] {1, 2, 3, 4}; [EOL] int offset = 0; [EOL] int len = data.length; [EOL] JsonParser parser = factory.createParser(data, offset, len); [EOL] assertNotNull(parser); [EOL] parser.close(); [EOL] } [EOL] public void testCreateParserWithNonNullDecorator() throws IOException { [EOL] JsonFactory factory = new JsonFactory() { [EOL] @Override [EOL] protected InputStreamDecorator _inputDecorator() { [EOL] return new InputStreamDecorator() { [EOL] @Override [EOL] public InputStream decorate(IOContext ctxt, byte[] src, int offset, int length) { [EOL] return new ByteArrayInputStream(src, offset, length); [EOL] } [EOL] }; [EOL] } [EOL] }; [EOL] byte[] data = new byte[] {1, 2, 3, 4}; [EOL] int offset = 0; [EOL] int len = data.length; [EOL] JsonParser parser = factory.createParser(data, offset, len); [EOL] assertNotNull(parser); [EOL] parser.close(); [EOL] }
public void testCreateParserWithDecoratorReturningNull() throws IOException { [EOL] JsonFactory factory = new JsonFactory() { [EOL] @Override [EOL] protected InputStreamDecorator _inputDecorator() { [EOL] return new InputStreamDecorator() { [EOL] @Override [EOL] public InputStream decorate(IOContext ctxt, byte[] src, int offset, int length) { [EOL] return null; [EOL] } [EOL] }; [EOL] } [EOL] }; [EOL] byte[] data = new byte[] {1, 2, 3, 4}; [EOL] int offset = 0; [EOL] int len = data.length; [EOL] JsonParser parser = factory.createParser(data, offset, len); [EOL] assertNotNull(parser); [EOL] parser.close(); [EOL] }
public void testCreateGeneratorWithUTF8EncodingAndNoDecorator() throws IOException { [EOL] JsonFactory factory = new JsonFactory(); [EOL] ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL] JsonGenerator generator = factory.createGenerator(outputStream, JsonEncoding.UTF8); [EOL] assertNotNull(generator); [EOL] assertTrue(generator instanceof UTF8JsonGenerator); [EOL] }
public void testCreateGeneratorWithUTF8EncodingAndDecorator() throws IOException { [EOL] JsonFactory factory = new JsonFactory() { [EOL] @Override [EOL] protected OutputDecorator outputDecorator() { [EOL] return new OutputDecorator() { [EOL] @Override [EOL] public OutputStream decorate(IOContext ctxt, OutputStream out) throws IOException { [EOL] return new BufferedOutputStream(out); [EOL] } [EOL] }; [EOL] } [EOL] }; [EOL] ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL] JsonGenerator generator = factory.createGenerator(outputStream, JsonEncoding.UTF8); [EOL] assertNotNull(generator); [EOL] assertTrue(generator instanceof UTF8JsonGenerator); [EOL] assertTrue(outputStream instanceof BufferedOutputStream); [EOL] }
public void testCreateGeneratorWithNonUTF8EncodingAndNoDecorator() throws IOException { [EOL] JsonFactory factory = new JsonFactory(); [EOL] ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL] JsonGenerator generator = factory.createGenerator(outputStream, JsonEncoding.UTF16_BE); [EOL] assertNotNull(generator); [EOL] assertFalse(generator instanceof UTF8JsonGenerator); [EOL] }
public void testCreateGeneratorWithNonUTF8EncodingAndDecorator() throws IOException { [EOL] JsonFactory factory = new JsonFactory() { [EOL] @Override [EOL] protected OutputDecorator outputDecorator() { [EOL] return new OutputDecorator() { [EOL] @Override [EOL] public Writer decorate(IOContext ctxt, Writer w) throws IOException { [EOL] return new BufferedWriter(w); [EOL] } [EOL] }; [EOL] } [EOL] }; [EOL] ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); [EOL] JsonGenerator generator = factory.createGenerator(outputStream, JsonEncoding.UTF16_BE); [EOL] assertNotNull(generator); [EOL] assertFalse(generator instanceof UTF8JsonGenerator); [EOL] }
public void testCreateGeneratorWithNullOutputDecorator() throws IOException { [EOL] JsonFactory factory = new JsonFactory(); [EOL] Writer out = new StringWriter(); [EOL] JsonGenerator generator = factory.createGenerator(out); [EOL] assertNotNull(generator); [EOL] }
public void testCreateGeneratorWithNonNullOutputDecorator() throws IOException { [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory.setOutputDecorator(new OutputDecorator() { [EOL] @Override [EOL] public Writer decorate(IOContext ctxt, Writer writer) throws IOException { [EOL] return new BufferedWriter(writer); [EOL] } [EOL] }); [EOL] Writer out = new StringWriter(); [EOL] JsonGenerator generator = factory.createGenerator(out); [EOL] assertNotNull(generator); [EOL] assertTrue(generator instanceof WriterBasedJsonGenerator); [EOL] }
public void testCreateGeneratorWithUTF8Encoding() throws IOException { [EOL] File tempFile = File.createTempFile("test", null); [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonGenerator generator = factory.createGenerator(tempFile, JsonEncoding.UTF8); [EOL] assertNotNull(generator); [EOL] assertTrue(generator instanceof UTF8JsonGenerator); [EOL] tempFile.deleteOnExit(); [EOL] }
public void testCreateGeneratorWithNonUTF8Encoding() throws IOException { [EOL] File tempFile = File.createTempFile("test", null); [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonGenerator generator = factory.createGenerator(tempFile, JsonEncoding.UTF16_BE); [EOL] assertNotNull(generator); [EOL] assertFalse(generator instanceof UTF8JsonGenerator); [EOL] tempFile.deleteOnExit(); [EOL] }
public void testCreateGeneratorWithOutputDecorator() throws IOException { [EOL] File tempFile = File.createTempFile("test", null); [EOL] JsonFactory factory = new JsonFactory() { [EOL] @Override [EOL] protected IOContext _createContext(Object srcRef, boolean resourceManaged) { [EOL] return new IOContext(_getBufferRecycler(), srcRef, resourceManaged) { [EOL] @Override [EOL] public OutputStream decorate(IOContext context, OutputStream out) throws IOException { [EOL] return new BufferedOutputStream(out); [EOL] } [EOL] @Override [EOL] public Writer decorate(IOContext context, Writer w) throws IOException { [EOL] return new BufferedWriter(w); [EOL] } [EOL] }; [EOL] } [EOL] }; [EOL] JsonGenerator generator = factory.createGenerator(tempFile, JsonEncoding.UTF8); [EOL] assertNotNull(generator); [EOL] assertTrue(generator.getOutputTarget() instanceof BufferedOutputStream); [EOL] tempFile.deleteOnExit(); [EOL] }
public void testCreateParserWithCanonicalizeFieldNamesEnabled() throws IOException { [EOL] InputStream in = new ByteArrayInputStream(new byte[0]); [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), in, false); [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory.enable(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES); [EOL] JsonParser parser = factory._createParser(in, ctxt); [EOL] assertTrue(parser.getParsingContext().inRoot()); [EOL] }
public void testCreateParserWithInternFieldNamesEnabled() throws IOException { [EOL] InputStream in = new ByteArrayInputStream(new byte[0]); [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), in, false); [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory.enable(JsonFactory.Feature.INTERN_FIELD_NAMES); [EOL] JsonParser parser = factory._createParser(in, ctxt); [EOL] assertTrue(parser.getParsingContext().inRoot()); [EOL] }
public void testCreateParserWithBothFeaturesDisabled() throws IOException { [EOL] InputStream in = new ByteArrayInputStream(new byte[0]); [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), in, false); [EOL] JsonFactory factory = new JsonFactory(); [EOL] factory.disable(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES); [EOL] factory.disable(JsonFactory.Feature.INTERN_FIELD_NAMES); [EOL] JsonParser parser = factory._createParser(in, ctxt); [EOL] assertTrue(parser.getParsingContext().inRoot()); [EOL] }
public void testCreateWriterWithUTF8Encoding() throws IOException { [EOL] OutputStream out = new ByteArrayOutputStream(); [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), out, false); [EOL] Writer writer = _createWriter(out, JsonEncoding.UTF8, ctxt); [EOL] assertTrue(writer instanceof UTF8Writer); [EOL] }
public void testCreateWriterWithNonUTF8Encoding() throws IOException { [EOL] OutputStream out = new ByteArrayOutputStream(); [EOL] IOContext ctxt = new IOContext(new BufferRecycler(), out, false); [EOL] Writer writer = _createWriter(out, JsonEncoding.UTF16_BE, ctxt); [EOL] assertTrue(writer instanceof OutputStreamWriter); [EOL] assertEquals("UTF-16BE", writer.getEncoding()); [EOL] }
public void testOptimizedStreamFromURL_FileProtocolNoHostNoEncodedChars() throws IOException { [EOL] URL fileUrl = new URL("file:///path/to/file"); [EOL] InputStream stream = _optimizedStreamFromURL(fileUrl); [EOL] assertTrue(stream instanceof FileInputStream); [EOL] }
public void testOptimizedStreamFromURL_FileProtocolWithHost() throws IOException { [EOL] URL fileUrlWithHost = new URL("file://localhost/path/to/file"); [EOL] InputStream stream = _optimizedStreamFromURL(fileUrlWithHost); [EOL] assertFalse(stream instanceof FileInputStream); [EOL] }
public void testOptimizedStreamFromURL_FileProtocolWithEncodedChars() throws IOException { [EOL] URL fileUrlEncoded = new URL("file:///path/to/fi%20le"); [EOL] InputStream stream = _optimizedStreamFromURL(fileUrlEncoded); [EOL] assertFalse(stream instanceof FileInputStream); [EOL] }
public void testOptimizedStreamFromURL_NonFileProtocol() throws IOException { [EOL] URL httpUrl = new URL("http://example.com"); [EOL] InputStream stream = _optimizedStreamFromURL(httpUrl); [EOL] assertNotNull(stream); [EOL] }
public void testEquals_BothQuadsEqual() { [EOL] int quad1 = 1; [EOL] int quad2 = 2; [EOL] MyClass myClass = new MyClass(quad1, quad2); [EOL] boolean result = myClass.equals(quad1, quad2); [EOL] assertTrue(result); [EOL] }
public void testEquals_FirstQuadNotEqual() { [EOL] int quad1 = 1; [EOL] int quad2 = 2; [EOL] MyClass myClass = new MyClass(quad1, quad2); [EOL] boolean result = myClass.equals(3, quad2); [EOL] assertFalse(result); [EOL] }
public void testEquals_SecondQuadNotEqual() { [EOL] int quad1 = 1; [EOL] int quad2 = 2; [EOL] MyClass myClass = new MyClass(quad1, quad2); [EOL] boolean result = myClass.equals(quad1, 3); [EOL] assertFalse(result); [EOL] }
public void testEquals_BothQuadsNotEqual() { [EOL] int quad1 = 1; [EOL] int quad2 = 2; [EOL] MyClass myClass = new MyClass(quad1, quad2); [EOL] boolean result = myClass.equals(3, 4); [EOL] assertFalse(result); [EOL] }
