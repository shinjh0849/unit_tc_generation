public void testFindInjectableValueIdWithNoAnnotation() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(member.getAnnotation(JacksonInject.class)).thenReturn(null); [EOL] Object result = findInjectableValueId(member); [EOL] assertNull(result); [EOL] }
public void testFindInjectableValueIdWithEmptyId() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] JacksonInject inject = mock(JacksonInject.class); [EOL] when(member.getAnnotation(JacksonInject.class)).thenReturn(inject); [EOL] when(inject.value()).thenReturn(""); [EOL] when(member.getRawType()).thenReturn((Class) String.class); [EOL] when(member instanceof AnnotatedMethod).thenReturn(false); [EOL] Object result = findInjectableValueId(member); [EOL] assertEquals(String.class.getName(), result); [EOL] }
public void testFindInjectableValueIdWithEmptyIdAndAnnotatedMethod() { [EOL] AnnotatedMethod member = mock(AnnotatedMethod.class); [EOL] JacksonInject inject = mock(JacksonInject.class); [EOL] when(member.getAnnotation(JacksonInject.class)).thenReturn(inject); [EOL] when(inject.value()).thenReturn(""); [EOL] when(member.getParameterCount()).thenReturn(1); [EOL] when(member.getRawParameterType(0)).thenReturn((Class) String.class); [EOL] Object result = findInjectableValueId(member); [EOL] assertEquals(String.class.getName(), result); [EOL] }
public void testFindInjectableValueIdWithNonEmptyId() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] JacksonInject inject = mock(JacksonInject.class); [EOL] when(member.getAnnotation(JacksonInject.class)).thenReturn(inject); [EOL] when(inject.value()).thenReturn("customId"); [EOL] Object result = findInjectableValueId(member); [EOL] assertEquals("customId", result); [EOL] }
public void testFindKeyDeserializerWithNonNullAnnotationAndValidKeyDeserializer() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonDeserialize jsonDeserialize = mock(JsonDeserialize.class); [EOL] when(annotated.getAnnotation(JsonDeserialize.class)).thenReturn(jsonDeserialize); [EOL] when(jsonDeserialize.keyUsing()).thenReturn((Class)SomeKeyDeserializer.class); [EOL] Class<? extends KeyDeserializer> result = findKeyDeserializer(annotated); [EOL] assertNotNull(result); [EOL] assertEquals(SomeKeyDeserializer.class, result); [EOL] }
public void testFindKeyDeserializerWithNonNullAnnotationAndNoneKeyDeserializer() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] JsonDeserialize jsonDeserialize = mock(JsonDeserialize.class); [EOL] when(annotated.getAnnotation(JsonDeserialize.class)).thenReturn(jsonDeserialize); [EOL] when(jsonDeserialize.keyUsing()).thenReturn((Class)KeyDeserializer.None.class); [EOL] Class<? extends KeyDeserializer> result = findKeyDeserializer(annotated); [EOL] assertNull(result); [EOL] }
public void testFindKeyDeserializerWithNullAnnotation() { [EOL] Annotated annotated = mock(Annotated.class); [EOL] when(annotated.getAnnotation(JsonDeserialize.class)).thenReturn(null); [EOL] Class<? extends KeyDeserializer> result = findKeyDeserializer(annotated); [EOL] assertNull(result); [EOL] }
public void testFindDeserializationKeyTypeWithNonNullAnnotationAndKeyAsNoClass() { [EOL] Annotated am = createMockAnnotatedWithJsonDeserializeKeyAs(NoClass.class); [EOL] JavaType baseKeyType = createDummyJavaType(); [EOL] Class<?> result = findDeserializationKeyType(am, baseKeyType); [EOL] assertNull(result); [EOL] } [EOL] public void testFindDeserializationKeyTypeWithNonNullAnnotationAndValidKeyAs() { [EOL] Class<?> expectedClass = String.class; [EOL] Annotated am = createMockAnnotatedWithJsonDeserializeKeyAs(expectedClass); [EOL] JavaType baseKeyType = createDummyJavaType(); [EOL] Class<?> result = findDeserializationKeyType(am, baseKeyType); [EOL] assertEquals(expectedClass, result); [EOL] } [EOL] public void testFindDeserializationKeyTypeWithNullAnnotation() { [EOL] Annotated am = createMockAnnotatedWithNoJsonDeserialize(); [EOL] JavaType baseKeyType = createDummyJavaType(); [EOL] Class<?> result = findDeserializationKeyType(am, baseKeyType); [EOL] assertNull(result); [EOL] }
private Annotated createMockAnnotatedWithJsonDeserializeKeyAs(Class<?> keyAs) { [EOL] Annotated am = mock(Annotated.class); [EOL] JsonDeserialize ann = mock(JsonDeserialize.class); [EOL] when(am.getAnnotation(JsonDeserialize.class)).thenReturn(ann); [EOL] when(ann.keyAs()).thenReturn(keyAs); [EOL] return am; [EOL] } [EOL] private Annotated createMockAnnotatedWithNoJsonDeserialize() { [EOL] Annotated am = mock(Annotated.class); [EOL] when(am.getAnnotation(JsonDeserialize.class)).thenReturn(null); [EOL] return am; [EOL] } [EOL] private JavaType createDummyJavaType() { [EOL] return mock(JavaType.class); [EOL] }
public void testFindDeserializationNameWithJsonSetter() { [EOL] AnnotatedMethod am = mock(AnnotatedMethod.class); [EOL] JsonSetter jsonSetter = mock(JsonSetter.class); [EOL] when(am.getAnnotation(JsonSetter.class)).thenReturn(jsonSetter); [EOL] when(jsonSetter.value()).thenReturn("setterValue"); [EOL] String result = findDeserializationName(am); [EOL] assertEquals("setterValue", result); [EOL] }
public void testFindDeserializationNameWithJsonProperty() { [EOL] AnnotatedMethod am = mock(AnnotatedMethod.class); [EOL] when(am.getAnnotation(JsonSetter.class)).thenReturn(null); [EOL] JsonProperty jsonProperty = mock(JsonProperty.class); [EOL] when(am.getAnnotation(JsonProperty.class)).thenReturn(jsonProperty); [EOL] when(jsonProperty.value()).thenReturn("propertyValue"); [EOL] String result = findDeserializationName(am); [EOL] assertEquals("propertyValue", result); [EOL] }
public void testFindDeserializationNameWithOtherAnnotations() { [EOL] AnnotatedMethod am = mock(AnnotatedMethod.class); [EOL] when(am.getAnnotation(JsonSetter.class)).thenReturn(null); [EOL] when(am.getAnnotation(JsonProperty.class)).thenReturn(null); [EOL] when(am.hasAnnotation(JsonDeserialize.class)).thenReturn(true); [EOL] String result = findDeserializationName(am); [EOL] assertEquals("", result); [EOL] }
public void testFindDeserializationNameWithNoAnnotations() { [EOL] AnnotatedMethod am = mock(AnnotatedMethod.class); [EOL] when(am.getAnnotation(JsonSetter.class)).thenReturn(null); [EOL] when(am.getAnnotation(JsonProperty.class)).thenReturn(null); [EOL] when(am.hasAnnotation(JsonDeserialize.class)).thenReturn(false); [EOL] when(am.hasAnnotation(JsonView.class)).thenReturn(false); [EOL] when(am.hasAnnotation(JsonBackReference.class)).thenReturn(false); [EOL] when(am.hasAnnotation(JsonManagedReference.class)).thenReturn(false); [EOL] String result = findDeserializationName(am); [EOL] assertNull(result); [EOL] }
public void testFindDeserializationNameWithJsonProperty() { [EOL] AnnotatedField af = mock(AnnotatedField.class); [EOL] JsonProperty pann = mock(JsonProperty.class); [EOL] when(af.getAnnotation(JsonProperty.class)).thenReturn(pann); [EOL] when(pann.value()).thenReturn("testName"); [EOL] String result = findDeserializationName(af); [EOL] assertEquals("testName", result); [EOL] }
public void testFindDeserializationNameWithOtherAnnotations() { [EOL] AnnotatedField af = mock(AnnotatedField.class); [EOL] when(af.getAnnotation(JsonProperty.class)).thenReturn(null); [EOL] when(af.hasAnnotation(JsonDeserialize.class)).thenReturn(true); [EOL] String result = findDeserializationName(af); [EOL] assertEquals("", result); [EOL] }
public void testFindDeserializationNameWithNoAnnotations() { [EOL] AnnotatedField af = mock(AnnotatedField.class); [EOL] when(af.getAnnotation(JsonProperty.class)).thenReturn(null); [EOL] when(af.hasAnnotation(JsonDeserialize.class)).thenReturn(false); [EOL] when(af.hasAnnotation(JsonView.class)).thenReturn(false); [EOL] when(af.hasAnnotation(JsonBackReference.class)).thenReturn(false); [EOL] when(af.hasAnnotation(JsonManagedReference.class)).thenReturn(false); [EOL] String result = findDeserializationName(af); [EOL] assertNull(result); [EOL] }
public void testDeserializationContextConstruction() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] JsonParser jp = new JsonParser(...); // Provide actual initialization [EOL] InjectableValues injectableValues = new InjectableValues.Std(); // Provide actual initialization [EOL] DeserializationContext src = new DeserializationContext(...); // Provide actual initialization [EOL] DeserializationContext context = new DeserializationContext(src, config, jp, injectableValues); [EOL] assertNotNull(context._cache); [EOL] assertSame(src._factory, context._factory); [EOL] assertSame(config, context._config); [EOL] assertEquals(config.getDeserializationFeatures(), context._featureFlags); [EOL] assertEquals(config.getActiveView(), context._view); [EOL] assertSame(jp, context._parser); [EOL] assertSame(injectableValues, context._injectableValues); [EOL] }
public void testGetConfig() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationConfig config = mapper.getDeserializationConfig(); [EOL] assertNotNull(config); [EOL] }
public void testGetAnnotationIntrospector() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] AnnotationIntrospector introspector = mapper.getSerializationConfig().getAnnotationIntrospector(); [EOL] assertNotNull(introspector); [EOL] }
public void testGetParser() { [EOL] MyClass instance = new MyClass(); [EOL] JsonParser result = instance.getParser(); [EOL] assertNotNull(result); [EOL] }
public void testFindInjectableValueWithNullInjectableValues() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DeserializationContext context = mapper.getDeserializationContext(); [EOL] Object valueId = "myValueId"; [EOL] BeanProperty forProperty = null; [EOL] Object beanInstance = new Object(); [EOL] try { [EOL] context.findInjectableValue(valueId, forProperty, beanInstance); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("No 'injectableValues' configured, can not inject value with id [" + valueId + "]", e.getMessage()); [EOL] } [EOL] }
public void testFindInjectableValueWithNonNullInjectableValues() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] InjectableValues.Std injectableValues = new InjectableValues.Std(); [EOL] injectableValues.addValue("myValueId", "myInjectedValue"); [EOL] mapper.setInjectableValues(injectableValues); [EOL] DeserializationContext context = mapper.getDeserializationContext(); [EOL] Object valueId = "myValueId"; [EOL] BeanProperty forProperty = null; [EOL] Object beanInstance = new Object(); [EOL] Object result = context.findInjectableValue(valueId, forProperty, beanInstance); [EOL] assertEquals("myInjectedValue", result); [EOL] }
public void testGetBase64Variant() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Base64Variant result = mapper.getBase64Variant(); [EOL] assertNotNull(result); [EOL] assertEquals(result, Base64Variants.getDefaultVariant()); [EOL] }
public void testFindRootValueDeserializerWithNullDeserializer() throws JsonMappingException { [EOL] DeserializationContext context = mock(DeserializationContext.class); [EOL] DeserializerCache cache = mock(DeserializerCache.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] when(cache.findValueDeserializer(context, factory, type)).thenReturn(null); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] setField(mapper, "_cache", cache); [EOL] setField(mapper, "_factory", factory); [EOL] setField(mapper, "_config", new DeserializationConfig(null, null, null, null, null, null, null)); [EOL] JsonDeserializer<Object> result = mapper.findRootValueDeserializer(type); [EOL] assertNull(result); [EOL] }
public void testFindRootValueDeserializerWithContextualDeserializer() throws JsonMappingException { [EOL] DeserializationContext context = mock(DeserializationContext.class); [EOL] DeserializerCache cache = mock(DeserializerCache.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] ContextualDeserializer contextualDeserializer = mock(ContextualDeserializer.class); [EOL] JsonDeserializer<Object> baseDeserializer = mock(JsonDeserializer.class); [EOL] when(cache.findValueDeserializer(context, factory, type)).thenReturn((JsonDeserializer<Object>) contextualDeserializer); [EOL] when(contextualDeserializer.createContextual(context, null)).thenReturn(baseDeserializer); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] setField(mapper, "_cache", cache); [EOL] setField(mapper, "_factory", factory); [EOL] setField(mapper, "_config", new DeserializationConfig(null, null, null, null, null, null, null)); [EOL] JsonDeserializer<Object> result = mapper.findRootValueDeserializer(type); [EOL] assertSame(baseDeserializer, result); [EOL] }
public void testFindRootValueDeserializerWithTypeDeserializer() throws JsonMappingException { [EOL] DeserializationContext context = mock(DeserializationContext.class); [EOL] DeserializerCache cache = mock(DeserializerCache.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] JsonDeserializer<Object> baseDeserializer = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] when(cache.findValueDeserializer(context, factory, type)).thenReturn(baseDeserializer); [EOL] when(factory.findTypeDeserializer(context.getConfig(), type)).thenReturn(typeDeserializer); [EOL] when(typeDeserializer.forProperty(null)).thenReturn(typeDeserializer); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] setField(mapper, "_cache", cache); [EOL] setField(mapper, "_factory", factory); [EOL] setField(mapper, "_config", new DeserializationConfig(null, null, null, null, null, null, null)); [EOL] JsonDeserializer<Object> result = mapper.findRootValueDeserializer(type); [EOL] assertTrue(result instanceof TypeWrappedDeserializer); [EOL] }
public JsonMappingException mappingException(Class<?> targetClass) { [EOL] return mappingException(targetClass, _parser.getCurrentToken()); [EOL] }
public void testMappingExceptionWithNullClassAndNullToken() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonMappingException exception = mapper.mappingException(null, null); [EOL] assertNotNull(exception); [EOL] assertTrue(exception.getMessage().contains("Can not deserialize instance of")); [EOL] assertTrue(exception.getMessage().contains("out of null token")); [EOL] }
public void testMappingExceptionWithNonNullClassAndNullToken() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonMappingException exception = mapper.mappingException(Object.class, null); [EOL] assertNotNull(exception); [EOL] assertTrue(exception.getMessage().contains("Can not deserialize instance of java.lang.Object")); [EOL] assertTrue(exception.getMessage().contains("out of null token")); [EOL] }
public void testMappingExceptionWithNullClassAndNonNullToken() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonMappingException exception = mapper.mappingException(null, JsonToken.START_OBJECT); [EOL] assertNotNull(exception); [EOL] assertTrue(exception.getMessage().contains("Can not deserialize instance of")); [EOL] assertTrue(exception.getMessage().contains("out of START_OBJECT token")); [EOL] }
public void testMappingExceptionWithNonNullClassAndNonNullToken() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonMappingException exception = mapper.mappingException(Object.class, JsonToken.START_OBJECT); [EOL] assertNotNull(exception); [EOL] assertTrue(exception.getMessage().contains("Can not deserialize instance of java.lang.Object")); [EOL] assertTrue(exception.getMessage().contains("out of START_OBJECT token")); [EOL] }
public void testMappingExceptionWithNullMessage() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonMappingException exception = mapper.mappingException(null); [EOL] assertNull(exception.getMessage()); [EOL] assertNull(exception.getParser()); [EOL] }
public void testMappingExceptionWithEmptyMessage() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonMappingException exception = mapper.mappingException(""); [EOL] assertEquals("", exception.getMessage()); [EOL] assertNull(exception.getParser()); [EOL] }
public void testMappingExceptionWithNonEmptyMessage() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String testMessage = "Test message"; [EOL] JsonMappingException exception = mapper.mappingException(testMessage); [EOL] assertEquals(testMessage, exception.getMessage()); [EOL] assertNull(exception.getParser()); [EOL] }
public void test_calcName_withArrayClass() { [EOL] String result = _calcName(String[].class); [EOL] assertEquals("java.lang.String[]", result); [EOL] }
public void test_calcName_withNonArrayClass() { [EOL] String result = _calcName(String.class); [EOL] assertEquals("java.lang.String", result); [EOL] }
protected DefaultDeserializationContext(DefaultDeserializationContext src, DeserializationConfig config, JsonParser jp, InjectableValues values) { [EOL] super(src, config, jp, values); [EOL] }
public void testFindObjectIdWithNewId() { [EOL] ObjectIdResolver underTest = new ObjectIdResolver(); [EOL] Object id = new Object(); [EOL] ObjectIdGenerator<?> generator = new ObjectIdGenerator<Object>() { [EOL] @Override [EOL] public boolean canUseFor(ObjectIdGenerator<?> gen) { [EOL] return gen.getClass() == this.getClass(); [EOL] } [EOL] @Override [EOL] public ObjectIdGenerator<Object> forScope(Class<?> scope) { [EOL] return this; [EOL] } [EOL] @Override [EOL] public ObjectIdGenerator<Object> newForSerialization(Object context) { [EOL] return this; [EOL] } [EOL] @Override [EOL] public IdKey key(Object key) { [EOL] return new IdKey(getClass(), null, key); [EOL] } [EOL] @Override [EOL] public Object generateId(Object forPojo) { [EOL] return new Object(); [EOL] } [EOL] }; [EOL] ReadableObjectId result = underTest.findObjectId(id, generator); [EOL] assertNotNull(result); [EOL] assertSame(id, result.getItem()); [EOL] }
public void testFindObjectIdWithExistingId() { [EOL] ObjectIdResolver underTest = new ObjectIdResolver(); [EOL] Object id = new Object(); [EOL] ObjectIdGenerator<?> generator = new ObjectIdGenerator<Object>() { [EOL] @Override [EOL] public boolean canUseFor(ObjectIdGenerator<?> gen) { [EOL] return gen.getClass() == this.getClass(); [EOL] } [EOL] @Override [EOL] public ObjectIdGenerator<Object> forScope(Class<?> scope) { [EOL] return this; [EOL] } [EOL] @Override [EOL] public ObjectIdGenerator<Object> newForSerialization(Object context) { [EOL] return this; [EOL] } [EOL] @Override [EOL] public IdKey key(Object key) { [EOL] return new IdKey(getClass(), null, key); [EOL] } [EOL] @Override [EOL] public Object generateId(Object forPojo) { [EOL] return new Object(); [EOL] } [EOL] }; [EOL] ReadableObjectId firstResult = underTest.findObjectId(id, generator); [EOL] ReadableObjectId secondResult = underTest.findObjectId(id, generator); [EOL] assertNotNull(secondResult); [EOL] assertSame(firstResult, secondResult); [EOL] }
public void testImplConstructor() { [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] InjectableValues values = mock(InjectableValues.class); [EOL] Impl src = mock(Impl.class); [EOL] Impl instance = new Impl(src, config, jp, values); [EOL] assertNotNull(instance); [EOL] }
public void testCreateInstanceWithNonNullValues() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] JsonParser jp = new JsonParser(...); // Provide actual initialization [EOL] InjectableValues values = new InjectableValues.Std(); // Provide actual initialization [EOL] DefaultDeserializationContext context = new DefaultDeserializationContext.Impl(...); // Provide actual initialization [EOL] DefaultDeserializationContext result = context.createInstance(config, jp, values); [EOL] assertNotNull(result); [EOL] assertSame(config, result.getConfig()); [EOL] assertSame(jp, result.getParser()); [EOL] assertSame(values, result.getInjectableValues()); [EOL] }
public void testCreateInstanceWithNullValues() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] JsonParser jp = null; [EOL] InjectableValues values = null; [EOL] DefaultDeserializationContext context = new DefaultDeserializationContext.Impl(...); // Provide actual initialization [EOL] DefaultDeserializationContext result = context.createInstance(config, jp, values); [EOL] assertNotNull(result); [EOL] assertSame(config, result.getConfig()); [EOL] assertNull(result.getParser()); [EOL] assertNull(result.getInjectableValues()); [EOL] }
public void testPropertyBasedCreatorWithEmptyProps() { [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] SettableBeanProperty[] creatorProps = new SettableBeanProperty[0]; [EOL] Object[] defaultValues = new Object[0]; [EOL] PropertyBasedCreator propertyBasedCreator = new PropertyBasedCreator(valueInstantiator, creatorProps, defaultValues); [EOL] assertNotNull(propertyBasedCreator); [EOL] assertEquals(0, propertyBasedCreator._propertyCount); [EOL] assertTrue(propertyBasedCreator._properties.isEmpty()); [EOL] assertNull(propertyBasedCreator._propertiesWithInjectables); [EOL] }
public void testPropertyBasedCreatorWithNonEmptyPropsNoInjectables() { [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] SettableBeanProperty prop1 = mock(SettableBeanProperty.class); [EOL] when(prop1.getName()).thenReturn("prop1"); [EOL] when(prop1.getInjectableValueId()).thenReturn(null); [EOL] SettableBeanProperty prop2 = mock(SettableBeanProperty.class); [EOL] when(prop2.getName()).thenReturn("prop2"); [EOL] when(prop2.getInjectableValueId()).thenReturn(null); [EOL] SettableBeanProperty[] creatorProps = new SettableBeanProperty[]{prop1, prop2}; [EOL] Object[] defaultValues = new Object[2]; [EOL] PropertyBasedCreator propertyBasedCreator = new PropertyBasedCreator(valueInstantiator, creatorProps, defaultValues); [EOL] assertNotNull(propertyBasedCreator); [EOL] assertEquals(2, propertyBasedCreator._propertyCount); [EOL] assertEquals(2, propertyBasedCreator._properties.size()); [EOL] assertNull(propertyBasedCreator._propertiesWithInjectables); [EOL] }
public void testPropertyBasedCreatorWithInjectables() { [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] SettableBeanProperty prop1 = mock(SettableBeanProperty.class); [EOL] when(prop1.getName()).thenReturn("prop1"); [EOL] when(prop1.getInjectableValueId()).thenReturn(null); [EOL] SettableBeanProperty prop2 = mock(SettableBeanProperty.class); [EOL] when(prop2.getName()).thenReturn("prop2"); [EOL] Object injectableId = new Object(); [EOL] when(prop2.getInjectableValueId()).thenReturn(injectableId); [EOL] SettableBeanProperty[] creatorProps = new SettableBeanProperty[]{prop1, prop2}; [EOL] Object[] defaultValues = new Object[2]; [EOL] PropertyBasedCreator propertyBasedCreator = new PropertyBasedCreator(valueInstantiator, creatorProps, defaultValues); [EOL] assertNotNull(propertyBasedCreator); [EOL] assertEquals(2, propertyBasedCreator._propertyCount); [EOL] assertEquals(2, propertyBasedCreator._properties.size()); [EOL] assertNotNull(propertyBasedCreator._propertiesWithInjectables); [EOL] assertSame(prop2, propertyBasedCreator._propertiesWithInjectables[1]); [EOL] }
public void testStartBuildingWithInjectables() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ObjectIdReader oir = mock(ObjectIdReader.class); [EOL] Map<Object, Object> injectables = new HashMap<>(); [EOL] injectables.put("key", "value"); [EOL] YourClass instance = new YourClass(2, injectables); // Assuming constructor takes propertyCount and propertiesWithInjectables [EOL] PropertyValueBuffer result = instance.startBuilding(jp, ctxt, oir); [EOL] assertNotNull(result); [EOL] assertEquals("value", result.getInjectableValue("key")); [EOL] }
public void testStartBuildingWithoutInjectables() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ObjectIdReader oir = mock(ObjectIdReader.class); [EOL] YourClass instance = new YourClass(2, null); // Assuming constructor takes propertyCount and propertiesWithInjectables [EOL] PropertyValueBuffer result = instance.startBuilding(jp, ctxt, oir); [EOL] assertNotNull(result); [EOL] assertNull(result.getInjectableValue("key")); [EOL] }
public void testStdConstructor() { [EOL] Std stdInstance = new Std(); [EOL] assertNotNull(stdInstance); [EOL] assertTrue(stdInstance.getMap() instanceof HashMap); [EOL] assertTrue(stdInstance.getMap().isEmpty()); [EOL] }
public void testStdConstructorWithNullValues() { [EOL] Std stdInstance = new Std(null); [EOL] assertNull(stdInstance._values); [EOL] }
public void testStdConstructorWithEmptyMap() { [EOL] Map<String, Object> values = new HashMap<>(); [EOL] Std stdInstance = new Std(values); [EOL] assertTrue(stdInstance._values.isEmpty()); [EOL] }
public void testStdConstructorWithNonEmptyMap() { [EOL] Map<String, Object> values = new HashMap<>(); [EOL] values.put("key", "value"); [EOL] Std stdInstance = new Std(values); [EOL] assertFalse(stdInstance._values.isEmpty()); [EOL] assertEquals("value", stdInstance._values.get("key")); [EOL] }
public void testAddValueWithNonNullKeyAndValue() { [EOL] Std std = new Std(); [EOL] String key = "testKey"; [EOL] Object value = new Object(); [EOL] Std result = std.addValue(key, value); [EOL] assertEquals(std, result); [EOL] assertTrue(std._values.containsKey(key)); [EOL] assertEquals(value, std._values.get(key)); [EOL] }
public void testAddValueWithNullKey() { [EOL] Std std = new Std(); [EOL] String key = null; [EOL] Object value = new Object(); [EOL] try { [EOL] std.addValue(key, value); [EOL] fail("Should throw NullPointerException for null key"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testAddValueWithNullValue() { [EOL] Std std = new Std(); [EOL] String key = "testKey"; [EOL] Object value = null; [EOL] Std result = std.addValue(key, value); [EOL] assertEquals(std, result); [EOL] assertTrue(std._values.containsKey(key)); [EOL] assertNull(std._values.get(key)); [EOL] }
public void testAddValueWithNonNullClassAndValue() { [EOL] Std std = new Std(); [EOL] Class<?> classKey = String.class; [EOL] Object value = "testValue"; [EOL] Std result = std.addValue(classKey, value); [EOL] assertEquals("testValue", result._values.get("java.lang.String")); [EOL] }
public void testAddValueWithNullClass() { [EOL] Std std = new Std(); [EOL] Object value = "testValue"; [EOL] try { [EOL] std.addValue(null, value); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testAddValueWithNullValue() { [EOL] Std std = new Std(); [EOL] Class<?> classKey = String.class; [EOL] Std result = std.addValue(classKey, null); [EOL] assertNull(result._values.get("java.lang.String")); [EOL] }
public void testFindInjectableValueWithNonStringId() { [EOL] InjectableValues.Std injectableValues = new InjectableValues.Std(); [EOL] DeserializationContext ctxt = null; // Mock or create an instance as per your context [EOL] BeanProperty forProperty = null; // Mock or create an instance as per your context [EOL] Object beanInstance = null; // Mock or create an instance as per your context [EOL] Object nonStringId = new Object(); [EOL] try { [EOL] injectableValues.findInjectableValue(nonStringId, ctxt, forProperty, beanInstance); [EOL] fail("Expected IllegalArgumentException for non-string id"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testFindInjectableValueWithNullId() { [EOL] InjectableValues.Std injectableValues = new InjectableValues.Std(); [EOL] DeserializationContext ctxt = null; // Mock or create an instance as per your context [EOL] BeanProperty forProperty = null; // Mock or create an instance as per your context [EOL] Object beanInstance = null; // Mock or create an instance as per your context [EOL] try { [EOL] injectableValues.findInjectableValue(null, ctxt, forProperty, beanInstance); [EOL] fail("Expected IllegalArgumentException for null id"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testFindInjectableValueWithUnknownStringId() { [EOL] InjectableValues.Std injectableValues = new InjectableValues.Std(); [EOL] DeserializationContext ctxt = null; // Mock or create an instance as per your context [EOL] BeanProperty forProperty = mock(BeanProperty.class); // Mock or create an instance as per your context [EOL] when(forProperty.getName()).thenReturn("testProperty"); [EOL] Object beanInstance = null; // Mock or create an instance as per your context [EOL] String unknownId = "unknownId"; [EOL] try { [EOL] injectableValues.findInjectableValue(unknownId, ctxt, forProperty, beanInstance); [EOL] fail("Expected IllegalArgumentException for unknown string id"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testFindInjectableValueWithKnownStringId() { [EOL] InjectableValues.Std injectableValues = new InjectableValues.Std(); [EOL] DeserializationContext ctxt = null; // Mock or create an instance as per your context [EOL] BeanProperty forProperty = null; // Mock or create an instance as per your context [EOL] Object beanInstance = null; // Mock or create an instance as per your context [EOL] String knownId = "knownId"; [EOL] Object expectedValue = new Object(); [EOL] injectableValues.addValue(knownId, expectedValue); [EOL] Object actualValue = injectableValues.findInjectableValue(knownId, ctxt, forProperty, beanInstance); [EOL] assertEquals("The returned value should be the one associated with 'knownId'", expectedValue, actualValue); [EOL] }
public void testIsIntegralNumber() { [EOL] JsonNode node = new NumericNode(); [EOL] assertFalse(node.isIntegralNumber()); [EOL] }
public void testIsInt() { [EOL] JsonNode node = new TextNode("test"); [EOL] assertFalse(node.isInt()); [EOL] }
public void testIsBoolean_NodeTypeBoolean() { [EOL] JsonNode node = new BooleanNode(true); [EOL] assertTrue(node.isBoolean()); [EOL] }
public void testIsBoolean_NodeTypeNotBoolean() { [EOL] JsonNode node = new TextNode("not a boolean"); [EOL] assertFalse(node.isBoolean()); [EOL] }
public void testBooleanValueReturnsFalse() { [EOL] JsonNode node = new BooleanNode(false); [EOL] assertFalse(node.booleanValue()); [EOL] }
public void testHasWithValidIndex() { [EOL] JsonNode node = new ArrayNode(JsonNodeFactory.instance); [EOL] ((ArrayNode) node).add(1); [EOL] boolean result = node.has(0); [EOL] assertTrue(result); [EOL] }
public void testHasWithInvalidIndex() { [EOL] JsonNode node = new ArrayNode(JsonNodeFactory.instance); [EOL] boolean result = node.has(-1); [EOL] assertFalse(result); [EOL] }
public void testHasWithIndexOutOfBounds() { [EOL] JsonNode node = new ArrayNode(JsonNodeFactory.instance); [EOL] boolean result = node.has(1); [EOL] assertFalse(result); [EOL] }
public void testHasNonNullWithExistingNonNullField() { [EOL] ObjectNode objectNode = JsonNodeFactory.instance.objectNode(); [EOL] objectNode.put("field", "value"); [EOL] boolean result = objectNode.hasNonNull("field"); [EOL] assertTrue(result); [EOL] }
public void testHasNonNullWithExistingNullField() { [EOL] ObjectNode objectNode = JsonNodeFactory.instance.objectNode(); [EOL] objectNode.putNull("field"); [EOL] boolean result = objectNode.hasNonNull("field"); [EOL] assertFalse(result); [EOL] }
public void testHasNonNullWithNonExistingField() { [EOL] ObjectNode objectNode = JsonNodeFactory.instance.objectNode(); [EOL] boolean result = objectNode.hasNonNull("field"); [EOL] assertFalse(result); [EOL] }
public void testHasNonNullWithNonNullValue() { [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] arrayNode.add(1); // Adding a non-null value [EOL] boolean result = arrayNode.hasNonNull(0); // Index 0 should have a non-null value [EOL] assertTrue(result); // The assertion checks if the result is true [EOL] }
public void testHasNonNullWithNullValue() { [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] arrayNode.add((JsonNode) null); // Adding a null value [EOL] boolean result = arrayNode.hasNonNull(0); // Index 0 should be null [EOL] assertFalse(result); // The assertion checks if the result is false [EOL] }
public void testHasNonNullWithNoValue() { [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] boolean result = arrayNode.hasNonNull(0); // Index 0 should not exist [EOL] assertFalse(result); // The assertion checks if the result is false [EOL] }
public void testHasNonNullWithNullNode() { [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] arrayNode.add(NullNode.getInstance()); // Adding a NullNode [EOL] boolean result = arrayNode.hasNonNull(0); // Index 0 should have a NullNode, which is considered null [EOL] assertFalse(result); // The assertion checks if the result is false [EOL] }
public void testWithUnsupportedOperationException() { [EOL] JsonNode node = JsonNodeFactory.instance.objectNode(); [EOL] try { [EOL] node.with("propertyName"); [EOL] fail("Expected UnsupportedOperationException to be thrown"); [EOL] } catch (UnsupportedOperationException e) { [EOL] assertEquals("JsonNode not of type ObjectNode (but " + node.getClass().getName() + "), can not call with() on it", e.getMessage()); [EOL] } [EOL] }
public void testWithArrayThrowsUnsupportedOperationException() { [EOL] JsonNode node = JsonNodeFactory.instance.objectNode(); [EOL] try { [EOL] node.withArray("propertyName"); [EOL] fail("Expected UnsupportedOperationException to be thrown"); [EOL] } catch (UnsupportedOperationException e) { [EOL] assertEquals("JsonNode not of type ObjectNode (but " + node.getClass().getName() + "), can not call withArray() on it", e.getMessage()); [EOL] } [EOL] }
public void testAddSuperTypesWithNullClass() { [EOL] Collection<Class<?>> result = new HashSet<>(); [EOL] _addSuperTypes(null, Object.class, result, true); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testAddSuperTypesWithObjectClass() { [EOL] Collection<Class<?>> result = new HashSet<>(); [EOL] _addSuperTypes(Object.class, null, result, true); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testAddSuperTypesWithEndBefore() { [EOL] Collection<Class<?>> result = new HashSet<>(); [EOL] _addSuperTypes(String.class, String.class, result, true); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testAddSuperTypesAddClassItself() { [EOL] Collection<Class<?>> result = new HashSet<>(); [EOL] _addSuperTypes(String.class, Object.class, result, true); [EOL] assertTrue(result.contains(String.class)); [EOL] }
public void testAddSuperTypesDoNotAddClassItself() { [EOL] Collection<Class<?>> result = new HashSet<>(); [EOL] _addSuperTypes(String.class, Object.class, result, false); [EOL] assertFalse(result.contains(String.class)); [EOL] }
public void testAddSuperTypesWithInterface() { [EOL] Collection<Class<?>> result = new HashSet<>(); [EOL] _addSuperTypes(ArrayList.class, Object.class, result, true); [EOL] assertTrue(result.contains(List.class)); [EOL] }
public void testAddSuperTypesWithSuperclass() { [EOL] Collection<Class<?>> result = new HashSet<>(); [EOL] _addSuperTypes(ArrayList.class, Object.class, result, true); [EOL] assertTrue(result.contains(AbstractList.class)); [EOL] }
public void testGetOuterClassWithEnclosingMethod() { [EOL] class InnerClass { [EOL] public void innerMethod() { [EOL] } [EOL] } [EOL] Class<?> result = JacksonDatabindUtils.getOuterClass(InnerClass.class.getDeclaredMethod("innerMethod").getDeclaringClass()); [EOL] assertNull(result); [EOL] }
public void testGetOuterClassWithNoEnclosingMethodNonStatic() { [EOL] class OuterClass { [EOL] class InnerClass { [EOL] } [EOL] } [EOL] Class<?> result = JacksonDatabindUtils.getOuterClass(OuterClass.InnerClass.class); [EOL] assertNotNull(result); [EOL] assertEquals(OuterClass.class, result); [EOL] }
public void testGetOuterClassWithNoEnclosingMethodStatic() { [EOL] class OuterClass { [EOL] static class InnerClass { [EOL] } [EOL] } [EOL] Class<?> result = JacksonDatabindUtils.getOuterClass(OuterClass.InnerClass.class); [EOL] assertNull(result); [EOL] }
public void testGetOuterClassWithSecurityException() { [EOL] Class<?> type = new Class<?>(){ [EOL] public Class<?> getEnclosingClass() throws SecurityException { [EOL] throw new SecurityException(); [EOL] } [EOL] }; [EOL] Class<?> result = JacksonDatabindUtils.getOuterClass(type); [EOL] assertNull(result); [EOL] }
public void testGetOuterClassWithNullPointerException() { [EOL] Class<?> type = new Class<?>(){ [EOL] public Class<?> getEnclosingClass() throws NullPointerException { [EOL] throw new NullPointerException(); [EOL] } [EOL] }; [EOL] Class<?> result = JacksonDatabindUtils.getOuterClass(type); [EOL] assertNull(result); [EOL] }
public void testNarrowContentsBy_SameClass() { [EOL] Class<?> contentClass = String.class; [EOL] JavaType elementType = TypeFactory.defaultInstance().constructType(String.class); [EOL] CollectionType collectionType = TypeFactory.defaultInstance().constructCollectionType(ArrayList.class, String.class); [EOL] JavaType result = collectionType.narrowContentsBy(contentClass); [EOL] assertSame(collectionType, result); [EOL] }
public void testNarrowContentsBy_DifferentClass() { [EOL] Class<?> contentClass = Integer.class; [EOL] JavaType elementType = TypeFactory.defaultInstance().constructType(String.class); [EOL] CollectionType collectionType = TypeFactory.defaultInstance().constructCollectionType(ArrayList.class, String.class); [EOL] JavaType result = collectionType.narrowContentsBy(contentClass); [EOL] assertNotSame(collectionType, result); [EOL] assertTrue(result instanceof CollectionType); [EOL] assertEquals(Integer.class, result.getContentType().getRawClass()); [EOL] }
public void testWithContentValueHandlerNonNull() { [EOL] CollectionType original = new CollectionType(Collection.class, SimpleType.constructUnsafe(String.class), null, null, false); [EOL] Object contentValueHandler = new Object(); [EOL] CollectionType newType = original.withContentValueHandler(contentValueHandler); [EOL] assertNotNull(newType); [EOL] assertSame(contentValueHandler, newType.getContentType().getValueHandler()); [EOL] }
public void testWithContentValueHandlerNull() { [EOL] CollectionType original = new CollectionType(Collection.class, SimpleType.constructUnsafe(String.class), null, null, false); [EOL] CollectionType newType = original.withContentValueHandler(null); [EOL] assertNotNull(newType); [EOL] assertNull(newType.getContentType().getValueHandler()); [EOL] }
public void testWithStaticTyping_AlreadyStatic() { [EOL] CollectionType original = new CollectionType(String.class, new SimpleType(Integer.class), null, null, true); [EOL] CollectionType result = original.withStaticTyping(); [EOL] assertSame("Should return the same object if already static", original, result); [EOL] }
public void testWithStaticTyping_NotStatic() { [EOL] CollectionType original = new CollectionType(String.class, new SimpleType(Integer.class), null, null, false); [EOL] CollectionType result = original.withStaticTyping(); [EOL] assertNotSame("Should not return the same object if not static", original, result); [EOL] assertTrue("Resulting CollectionType should have static typing enabled", result.isStaticTyping()); [EOL] }
public void testFindReferenceTypeReturnsNull() { [EOL] ExampleClass example = new ExampleClass(); [EOL] assertNull("ReferenceType should be null", example.findReferenceType()); [EOL] }
public void testIsRequired() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonNode node = mapper.createObjectNode(); [EOL] assertFalse(node.isRequired()); [EOL] }
public void testEnumMapSerializerWithStaticTyping() { [EOL] JavaType valueType = mock(JavaType.class); [EOL] when(valueType.isFinal()).thenReturn(false); [EOL] EnumValues keyEnums = mock(EnumValues.class); [EOL] TypeSerializer vts = mock(TypeSerializer.class); [EOL] JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); [EOL] EnumMapSerializer serializer = new EnumMapSerializer(valueType, true, keyEnums, vts, valueSerializer); [EOL] assertNotNull(serializer); [EOL] assertTrue(serializer._staticTyping); [EOL] assertEquals(valueType, serializer._valueType); [EOL] assertEquals(keyEnums, serializer._keyEnums); [EOL] assertEquals(vts, serializer._valueTypeSerializer); [EOL] assertEquals(valueSerializer, serializer._valueSerializer); [EOL] }
public void testEnumMapSerializerWithFinalValueType() { [EOL] JavaType valueType = mock(JavaType.class); [EOL] when(valueType.isFinal()).thenReturn(true); [EOL] EnumValues keyEnums = mock(EnumValues.class); [EOL] TypeSerializer vts = mock(TypeSerializer.class); [EOL] JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); [EOL] EnumMapSerializer serializer = new EnumMapSerializer(valueType, false, keyEnums, vts, valueSerializer); [EOL] assertNotNull(serializer); [EOL] assertTrue(serializer._staticTyping); [EOL] assertEquals(valueType, serializer._valueType); [EOL] assertEquals(keyEnums, serializer._keyEnums); [EOL] assertEquals(vts, serializer._valueTypeSerializer); [EOL] assertEquals(valueSerializer, serializer._valueSerializer); [EOL] }
public void testEnumMapSerializerWithoutStaticTypingAndNonFinalValueType() { [EOL] JavaType valueType = mock(JavaType.class); [EOL] when(valueType.isFinal()).thenReturn(false); [EOL] EnumValues keyEnums = mock(EnumValues.class); [EOL] TypeSerializer vts = mock(TypeSerializer.class); [EOL] JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); [EOL] EnumMapSerializer serializer = new EnumMapSerializer(valueType, false, keyEnums, vts, valueSerializer); [EOL] assertNotNull(serializer); [EOL] assertFalse(serializer._staticTyping); [EOL] assertEquals(valueType, serializer._valueType); [EOL] assertEquals(keyEnums, serializer._keyEnums); [EOL] assertEquals(vts, serializer._valueTypeSerializer); [EOL] assertEquals(valueSerializer, serializer._valueSerializer); [EOL] }
public void testEnumMapSerializerCopyConstructor() { [EOL] EnumMap<SomeEnum, String> enumMap = new EnumMap<>(SomeEnum.class); [EOL] enumMap.put(SomeEnum.VALUE1, "one"); [EOL] JsonSerializer<Object> valueSerializer = new StdSerializer<Object>(Object.class) { [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException { [EOL] gen.writeString(value.toString()); [EOL] } [EOL] }; [EOL] EnumMapSerializer original = new EnumMapSerializer(enumMap.getClass(), false, null, null, valueSerializer); [EOL] BeanProperty property = new BeanProperty.Bogus(); [EOL] JsonSerializer<?> newSerializer = new StdSerializer<Object>(Object.class) { [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException { [EOL] gen.writeString("new " + value.toString()); [EOL] } [EOL] }; [EOL] EnumMapSerializer copy = new EnumMapSerializer(original, property, newSerializer); [EOL] assertNotNull(copy); [EOL] assertEquals(property, copy.getProperty()); [EOL] assertEquals(original._staticTyping, copy._staticTyping); [EOL] assertEquals(original._valueType, copy._valueType); [EOL] assertEquals(original._keyEnums, copy._keyEnums); [EOL] assertEquals(original._valueTypeSerializer, copy._valueTypeSerializer); [EOL] assertNotSame(original._valueSerializer, copy._valueSerializer); [EOL] assertTrue(copy._valueSerializer instanceof StdSerializer); [EOL] }
public void testWithSameValueSerializer() { [EOL] EnumMapSerializer original = new EnumMapSerializer(null, null, null); [EOL] BeanProperty prop = null; [EOL] JsonSerializer<?> ser = null; [EOL] EnumMapSerializer result = original.withValueSerializer(prop, ser); [EOL] assertSame("Should return the same EnumMapSerializer instance", original, result); [EOL] }
public void testWithDifferentValueSerializer() { [EOL] EnumMapSerializer original = new EnumMapSerializer(null, null, null); [EOL] BeanProperty prop = null; [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] EnumMapSerializer result = original.withValueSerializer(prop, ser); [EOL] assertNotSame("Should return a new EnumMapSerializer instance", original, result); [EOL] }
public void testWithDifferentProperty() { [EOL] EnumMapSerializer original = new EnumMapSerializer(null, null, null); [EOL] BeanProperty prop = mock(BeanProperty.class); [EOL] JsonSerializer<?> ser = null; [EOL] EnumMapSerializer result = original.withValueSerializer(prop, ser); [EOL] assertNotSame("Should return a new EnumMapSerializer instance", original, result); [EOL] }
public void testCreateContextualWithNullProperty() throws JsonMappingException { [EOL] JsonSerializer<?> result = createContextual(null, null); [EOL] assertSame(_valueSerializer, result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMemberButNullSerializerDef() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(null); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertSame(_valueSerializer, result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMemberAndNonNullSerializerDef() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] Object serDef = new Object(); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(serDef); [EOL] when(provider.serializerInstance(member, serDef)).thenReturn(mock(JsonSerializer.class)); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotSame(_valueSerializer, result); [EOL] }
public void testCreateContextualWithStaticTyping() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] _staticTyping = true; [EOL] when(provider.findValueSerializer(_valueType, property)).thenReturn(mock(JsonSerializer.class)); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotSame(this, result); [EOL] }
public void testCreateContextualWithValueSerializerBeingContextualSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] ContextualSerializer valueSerializer = mock(ContextualSerializer.class); [EOL] _valueSerializer = valueSerializer; [EOL] when(valueSerializer.createContextual(provider, property)).thenReturn(mock(JsonSerializer.class)); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotSame(_valueSerializer, result); [EOL] }
public void testSerializeEmptyEnumMap() throws IOException { [EOL] EnumMap<AnEnum, String> enumMap = new EnumMap<>(AnEnum.class); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] new EnumMapSerializer(null, null).serialize(enumMap, jgen, provider); [EOL] verify(jgen).writeStartObject(); [EOL] verify(jgen).writeEndObject(); [EOL] verifyNoMoreInteractions(jgen); [EOL] }
public void testSerializeNonEmptyEnumMap() throws IOException { [EOL] EnumMap<AnEnum, String> enumMap = new EnumMap<>(AnEnum.class); [EOL] enumMap.put(AnEnum.VALUE1, "value1"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] new EnumMapSerializer(null, null).serialize(enumMap, jgen, provider); [EOL] verify(jgen).writeStartObject(); [EOL] verify(jgen, times(1)).writeFieldName(anyString()); [EOL] verify(jgen, times(1)).writeString(anyString()); [EOL] verify(jgen).writeEndObject(); [EOL] verifyNoMoreInteractions(jgen); [EOL] }
protected void serializeContents(EnumMap<? extends Enum<?>, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL] if (_valueSerializer != null) { [EOL] serializeContentsUsing(value, jgen, provider, _valueSerializer); [EOL] return; [EOL] } [EOL] JsonSerializer<Object> prevSerializer = null; [EOL] Class<?> prevClass = null; [EOL] EnumValues keyEnums = _keyEnums; [EOL] final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES); [EOL] final TypeSerializer vts = _valueTypeSerializer; [EOL] for (Map.Entry<? extends Enum<?>, ?> entry : value.entrySet()) { [EOL] final Object valueElem = entry.getValue(); [EOL] if (skipNulls && valueElem == null) { [EOL] continue; [EOL] } [EOL] Enum<?> key = entry.getKey(); [EOL] if (keyEnums == null) { [EOL] StdSerializer<?> ser = (StdSerializer<?>) provider.findValueSerializer(key.getDeclaringClass(), _property); [EOL] keyEnums = ((EnumSerializer) ser).getEnumValues(); [EOL] } [EOL] jgen.writeFieldName(keyEnums.serializedValueFor(key)); [EOL] if (valueElem == null) { [EOL] provider.defaultSerializeNull(jgen); [EOL] continue; [EOL] } [EOL] Class<?> cc = valueElem.getClass(); [EOL] JsonSerializer<Object> currSerializer; [EOL] if (cc == prevClass) { [EOL] currSerializer = prevSerializer; [EOL] } else { [EOL] currSerializer = provider.findValueSerializer(cc, _property); [EOL] prevSerializer = currSerializer; [EOL] prevClass = cc; [EOL] } [EOL] try { [EOL] if (vts == null) { [EOL] currSerializer.serialize(valueElem, jgen, provider); [EOL] } else { [EOL] currSerializer.serializeWithType(valueElem, jgen, provider, vts); [EOL] } [EOL] } catch (Exception e) { [EOL] wrapAndThrow(provider, e, value, entry.getKey().name()); [EOL] } [EOL] } [EOL] }
public void testWithAdditionalKeySerializersWithNonNull() { [EOL] Serializers additional = Mockito.mock(Serializers.class); [EOL] SerializerFactoryConfig config = new SerializerFactoryConfig(); [EOL] SerializerFactoryConfig newConfig = config.withAdditionalKeySerializers(additional); [EOL] assertNotNull(newConfig); [EOL] assertNotSame(config, newConfig); [EOL] }
public void testWithAdditionalKeySerializersWithNull() { [EOL] try { [EOL] new SerializerFactoryConfig().withAdditionalKeySerializers(null); [EOL] fail("Expected IllegalArgumentException not thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Can not pass null Serializers", e.getMessage()); [EOL] } [EOL] }
public void testKeySerializersWithNonNullAdditionalKeySerializers() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SimpleModule module = new SimpleModule(); [EOL] JsonSerializer<?> serializer = new JsonSerializer<Object>() { [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider serializers) throws IOException { [EOL] } [EOL] }; [EOL] module.addKeySerializer(Object.class, serializer); [EOL] mapper.registerModule(module); [EOL] SerializerProvider provider = mapper.getSerializerProviderInstance(); [EOL] Iterable<Serializers> serializersIterable = provider.keySerializers(); [EOL] assertNotNull(serializersIterable); [EOL] assertTrue(serializersIterable.iterator().hasNext()); [EOL] assertEquals(serializer, serializersIterable.iterator().next().findSerializer(null, null, null)); [EOL] }
public void testKeySerializersWithNullAdditionalKeySerializers() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializerProvider provider = mapper.getSerializerProviderInstance(); [EOL] Iterable<Serializers> serializersIterable = provider.keySerializers(); [EOL] assertNotNull(serializersIterable); [EOL] assertFalse(serializersIterable.iterator().hasNext()); [EOL] }
public void testFindSerializerWithInterface() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType type = new JavaType(MyInterface.class); [EOL] BeanDescription beanDesc = new BeanDescription(MyInterface.class); [EOL] JsonSerializer<?> serializer = findSerializer(config, type, beanDesc); [EOL] assertNotNull(serializer); [EOL] }
public void testFindSerializerWithClass() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType type = new JavaType(MyClass.class); [EOL] BeanDescription beanDesc = new BeanDescription(MyClass.class); [EOL] JsonSerializer<?> serializer = findSerializer(config, type, beanDesc); [EOL] assertNotNull(serializer); [EOL] }
public void testFindSerializerWithSuperclass() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType type = new JavaType(MySubclass.class); [EOL] BeanDescription beanDesc = new BeanDescription(MySubclass.class); [EOL] JsonSerializer<?> serializer = findSerializer(config, type, beanDesc); [EOL] assertNotNull(serializer); [EOL] }
public void testFindSerializerWithNoMapping() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType type = new JavaType(UnmappedClass.class); [EOL] BeanDescription beanDesc = new BeanDescription(UnmappedClass.class); [EOL] JsonSerializer<?> serializer = findSerializer(config, type, beanDesc); [EOL] assertNull(serializer); [EOL] }
public void testFindInterfaceMappingWithDirectMapping() { [EOL] ClassKey key = new ClassKey(MyInterface.class); [EOL] JsonSerializer<?> expectedSerializer = new MySerializer(); [EOL] _interfaceMappings.put(key, expectedSerializer); [EOL] JsonSerializer<?> result = _findInterfaceMapping(MyClass.class, key); [EOL] assertSame("Should find the direct mapping for interface", expectedSerializer, result); [EOL] }
public void testFindInterfaceMappingWithInheritedMapping() { [EOL] ClassKey key = new ClassKey(MyInterface.class); [EOL] JsonSerializer<?> expectedSerializer = new MySerializer(); [EOL] _interfaceMappings.put(key, expectedSerializer); [EOL] JsonSerializer<?> result = _findInterfaceMapping(MySubClass.class, key); [EOL] assertSame("Should find the inherited mapping for interface", expectedSerializer, result); [EOL] }
public void testFindInterfaceMappingWithNoMapping() { [EOL] ClassKey key = new ClassKey(MyInterface.class); [EOL] JsonSerializer<?> result = _findInterfaceMapping(MyClassWithoutMapping.class, key); [EOL] assertNull("Should not find any mapping for interface", result); [EOL] }
public void testCreateContextualWithNonNullTypeSerializerAndProperty() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] TypeSerializer typeSerializer = mock(TypeSerializer.class); [EOL] JsonSerializer<Object> elementSerializer = mock(JsonSerializer.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] Object serDef = new Object(); [EOL] when(_valueTypeSerializer).thenReturn(typeSerializer); [EOL] when(typeSerializer.forProperty(property)).thenReturn(typeSerializer); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(serDef); [EOL] when(provider.serializerInstance(member, serDef)).thenReturn(elementSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotSame(this, result); [EOL] }
public void testCreateContextualWithNullProperty() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<?> result = createContextual(provider, null); [EOL] assertSame(this, result); [EOL] }
public void testCreateContextualWithNonNullPropertyButNullMember() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] when(property.getMember()).thenReturn(null); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertSame(this, result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMemberButNullSerDef() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(null); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertSame(this, result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMemberAndSerDefButNullSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] Object serDef = new Object(); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(provider.getAnnotationIntrospector().findContentSerializer(member)).thenReturn(serDef); [EOL] when(provider.serializerInstance(member, serDef)).thenReturn(null); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertSame(this, result); [EOL] }
public void testCreateContextualWithStaticTyping() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); [EOL] when(_elementType).thenReturn(Object.class); [EOL] when(_staticTyping).thenReturn(true); [EOL] when(provider.findValueSerializer(Object.class, property)).thenReturn(valueSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotSame(this, result); [EOL] }
public void testCreateContextualWithContentTypeAnnotation() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<Object> valueSerializer = mock(JsonSerializer.class); [EOL] when(_elementType).thenReturn(Object.class); [EOL] when(_staticTyping).thenReturn(false); [EOL] when(hasContentTypeAnnotation(provider, property)).thenReturn(true); [EOL] when(provider.findValueSerializer(Object.class, property)).thenReturn(valueSerializer); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotSame(this, result); [EOL] }
public void testCreateContextualWithExistingContextualSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] ContextualSerializer contextualSerializer = mock(ContextualSerializer.class); [EOL] JsonSerializer<Object> contextualInstance = mock(JsonSerializer.class); [EOL] when(_elementSerializer).thenReturn(contextualSerializer); [EOL] when(contextualSerializer.createContextual(provider, property)).thenReturn(contextalInstance); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotSame(this, result); [EOL] }
public void testSerializeWithSingleElementArrayUnwrapped() throws IOException { [EOL] T value = createValueWithSingleElement(); // Implement createValueWithSingleElement to return a single-element array [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)).thenReturn(true); [EOL] serialize(value, jgen, provider); [EOL] verify(jgen, never()).writeStartArray(); [EOL] verify(jgen, never()).writeEndArray(); [EOL] verify(provider).isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL] verifySerializeContentsCalled(value, jgen, provider); // Implement verifySerializeContentsCalled to check serializeContents was called [EOL] }
public void testSerializeWithNonSingleElementArray() throws IOException { [EOL] T value = createValueWithMultipleElements(); // Implement createValueWithMultipleElements to return a multi-element array [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)).thenReturn(false); [EOL] serialize(value, jgen, provider); [EOL] verify(jgen).writeStartArray(); [EOL] verify(jgen).writeEndArray(); [EOL] verify(provider).isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL] verifySerializeContentsCalled(value, jgen, provider); // Implement verifySerializeContentsCalled to check serializeContents was called [EOL] }
public void testSerializeWithSingleElementArrayWrapped() throws IOException { [EOL] T value = createValueWithSingleElement(); // Implement createValueWithSingleElement to return a single-element array [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)).thenReturn(false); [EOL] serialize(value, jgen, provider); [EOL] verify(jgen).writeStartArray(); [EOL] verify(jgen).writeEndArray(); [EOL] verify(provider).isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL] verifySerializeContentsCalled(value, jgen, provider); // Implement verifySerializeContentsCalled to check serializeContents was called [EOL] }
public void testWithNoFeatures() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // provide necessary arguments [EOL] DeserializationConfig newConfig = config.with(); [EOL] assertSame("Should be the same config as no features were added", config, newConfig); [EOL] }
public void testWithOneFeature() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // provide necessary arguments [EOL] MapperFeature feature = MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES; [EOL] DeserializationConfig newConfig = config.with(feature); [EOL] assertNotSame("Should not be the same config as a feature was added", config, newConfig); [EOL] assertTrue("New config should have the feature enabled", newConfig.isEnabled(feature)); [EOL] }
public void testWithMultipleFeatures() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // provide necessary arguments [EOL] MapperFeature feature1 = MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES; [EOL] MapperFeature feature2 = MapperFeature.AUTO_DETECT_FIELDS; [EOL] DeserializationConfig newConfig = config.with(feature1, feature2); [EOL] assertNotSame("Should not be the same config as features were added", config, newConfig); [EOL] assertTrue("New config should have feature1 enabled", newConfig.isEnabled(feature1)); [EOL] assertTrue("New config should have feature2 enabled", newConfig.isEnabled(feature2)); [EOL] }
public void testWithBase64Variant() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Base64Variant originalVariant = mapper.getDeserializationConfig().getBase64Variant(); [EOL] Base64Variant newVariant = Base64Variants.MODIFIED_FOR_URL; [EOL] DeserializationConfig originalConfig = mapper.getDeserializationConfig(); [EOL] DeserializationConfig newConfig = originalConfig.with(newVariant); [EOL] assertNotSame(originalConfig, newConfig); [EOL] assertNotSame(originalVariant, newConfig.getBase64Variant()); [EOL] assertEquals(newVariant, newConfig.getBase64Variant()); [EOL] }
public void testGetAnnotationIntrospectorWhenUseAnnotationsEnabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.enable(MapperFeature.USE_ANNOTATIONS); [EOL] AnnotationIntrospector result = mapper.getAnnotationIntrospector(); [EOL] assertNotNull(result); [EOL] assertNotSame(NopAnnotationIntrospector.instance, result); [EOL] }
public void testGetAnnotationIntrospectorWhenUseAnnotationsDisabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.disable(MapperFeature.USE_ANNOTATIONS); [EOL] AnnotationIntrospector result = mapper.getAnnotationIntrospector(); [EOL] assertNotNull(result); [EOL] assertSame(NopAnnotationIntrospector.instance, result); [EOL] }
public void testIntrospectClassAnnotationsWithNonNullType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType type = mapper.constructType(Object.class); [EOL] BeanDescription result = mapper.getSerializationConfig().introspectClassAnnotations(type); [EOL] assertNotNull(result); [EOL] assertEquals(type, result.getType()); [EOL] }
public void testIntrospectClassAnnotationsWithNullType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.getSerializationConfig().introspectClassAnnotations(null); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDefaultVisibilityChecker_AllFeaturesEnabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.enable(MapperFeature.AUTO_DETECT_SETTERS); [EOL] mapper.enable(MapperFeature.AUTO_DETECT_CREATORS); [EOL] mapper.enable(MapperFeature.AUTO_DETECT_FIELDS); [EOL] VisibilityChecker<?> vchecker = mapper.getSerializationConfig().getDefaultVisibilityChecker(); [EOL] assertEquals(JsonAutoDetect.Visibility.DEFAULT, vchecker.getSetterVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.DEFAULT, vchecker.getCreatorVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.DEFAULT, vchecker.getFieldVisibility()); [EOL] }
public void testGetDefaultVisibilityChecker_NoAutoDetectSetters() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.disable(MapperFeature.AUTO_DETECT_SETTERS); [EOL] mapper.enable(MapperFeature.AUTO_DETECT_CREATORS); [EOL] mapper.enable(MapperFeature.AUTO_DETECT_FIELDS); [EOL] VisibilityChecker<?> vchecker = mapper.getSerializationConfig().getDefaultVisibilityChecker(); [EOL] assertEquals(JsonAutoDetect.Visibility.NONE, vchecker.getSetterVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.DEFAULT, vchecker.getCreatorVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.DEFAULT, vchecker.getFieldVisibility()); [EOL] }
public void testGetDefaultVisibilityChecker_NoAutoDetectCreators() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.enable(MapperFeature.AUTO_DETECT_SETTERS); [EOL] mapper.disable(MapperFeature.AUTO_DETECT_CREATORS); [EOL] mapper.enable(MapperFeature.AUTO_DETECT_FIELDS); [EOL] VisibilityChecker<?> vchecker = mapper.getSerializationConfig().getDefaultVisibilityChecker(); [EOL] assertEquals(JsonAutoDetect.Visibility.DEFAULT, vchecker.getSetterVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.NONE, vchecker.getCreatorVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.DEFAULT, vchecker.getFieldVisibility()); [EOL] }
public void testGetDefaultVisibilityChecker_NoAutoDetectFields() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.enable(MapperFeature.AUTO_DETECT_SETTERS); [EOL] mapper.enable(MapperFeature.AUTO_DETECT_CREATORS); [EOL] mapper.disable(MapperFeature.AUTO_DETECT_FIELDS); [EOL] VisibilityChecker<?> vchecker = mapper.getSerializationConfig().getDefaultVisibilityChecker(); [EOL] assertEquals(JsonAutoDetect.Visibility.DEFAULT, vchecker.getSetterVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.DEFAULT, vchecker.getCreatorVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.NONE, vchecker.getFieldVisibility()); [EOL] }
public void testGetDefaultVisibilityChecker_AllFeaturesDisabled() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.disable(MapperFeature.AUTO_DETECT_SETTERS); [EOL] mapper.disable(MapperFeature.AUTO_DETECT_CREATORS); [EOL] mapper.disable(MapperFeature.AUTO_DETECT_FIELDS); [EOL] VisibilityChecker<?> vchecker = mapper.getSerializationConfig().getDefaultVisibilityChecker(); [EOL] assertEquals(JsonAutoDetect.Visibility.NONE, vchecker.getSetterVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.NONE, vchecker.getCreatorVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.NONE, vchecker.getFieldVisibility()); [EOL] }
public void testGetDeserializationFeatures() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] int features = mapper.getDeserializationConfig().getDeserializationFeatures(); [EOL] assertEquals(0, features); // Assuming default is 0 [EOL] }
public void testIntrospectWithValidType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType type = mapper.constructType(MyBean.class); [EOL] BeanDescription beanDesc = mapper.getSerializationConfig().introspect(type); [EOL] assertNotNull(beanDesc); [EOL] } [EOL] public void testIntrospectWithNullType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.getSerializationConfig().introspect(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseTypeWithEndOfString() { [EOL] MyTokenizer tokens = new MyTokenizer(""); [EOL] try { [EOL] parseType(tokens); [EOL] fail("Expected IllegalArgumentException for end-of-string"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseTypeWithValidClass() { [EOL] MyTokenizer tokens = new MyTokenizer("java.lang.String"); [EOL] JavaType result = parseType(tokens); [EOL] assertNotNull(result); [EOL] assertEquals(String.class, result.getRawClass()); [EOL] }
public void testParseTypeWithParameterizedType() { [EOL] MyTokenizer tokens = new MyTokenizer("java.util.List<java.lang.String>"); [EOL] JavaType result = parseType(tokens); [EOL] assertNotNull(result); [EOL] assertEquals(List.class, result.getRawClass()); [EOL] assertEquals(String.class, result.containedType(0).getRawClass()); [EOL] }
public void testParseTypeWithExtraTokens() { [EOL] MyTokenizer tokens = new MyTokenizer("java.lang.String extraToken"); [EOL] JavaType result = parseType(tokens); [EOL] assertNotNull(result); [EOL] assertEquals(String.class, result.getRawClass()); [EOL] assertTrue(tokens.hasMoreTokens()); [EOL] }
public void testParseTypesWithNoTokens() { [EOL] MyTokenizer tokens = new MyTokenizer(""); [EOL] try { [EOL] parseTypes(tokens); [EOL] fail("Expected IllegalArgumentException for empty token stream"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testParseTypesWithValidTokens() { [EOL] MyTokenizer tokens = new MyTokenizer("int,java.lang.String>"); [EOL] try { [EOL] List<JavaType> types = parseTypes(tokens); [EOL] assertEquals(2, types.size()); [EOL] assertEquals("int", types.get(0).toString()); [EOL] assertEquals("java.lang.String", types.get(1).toString()); [EOL] } catch (IllegalArgumentException e) { [EOL] fail("Did not expect IllegalArgumentException for valid token stream"); [EOL] } [EOL] } [EOL] public void testParseTypesWithUnexpectedToken() { [EOL] MyTokenizer tokens = new MyTokenizer("int;java.lang.String>"); [EOL] try { [EOL] parseTypes(tokens); [EOL] fail("Expected IllegalArgumentException for unexpected token"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testParseTypesWithMissingGreaterThanToken() { [EOL] MyTokenizer tokens = new MyTokenizer("int,java.lang.String"); [EOL] try { [EOL] parseTypes(tokens); [EOL] fail("Expected IllegalArgumentException for missing '>' token"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseTypesWithOnlyGreaterThanToken() { [EOL] MyTokenizer tokens = new MyTokenizer(">"); [EOL] try { [EOL] List<JavaType> types = parseTypes(tokens); [EOL] assertTrue(types.isEmpty()); [EOL] } catch (IllegalArgumentException e) { [EOL] fail("Did not expect IllegalArgumentException for '>' token"); [EOL] } [EOL] }
public void testNextTokenWithPushbackTokenNotNull() { [EOL] YourObject obj = new YourObject(); [EOL] obj._pushbackToken = "testToken"; [EOL] String result = obj.nextToken(); [EOL] assertEquals("testToken", result); [EOL] assertNull(obj._pushbackToken); [EOL] assertEquals("testToken".length(), obj._index); [EOL] }
public void testNextTokenWithPushbackTokenNull() { [EOL] YourObject obj = new YourObject(); [EOL] obj._pushbackToken = null; [EOL] mockSuperNextToken("superToken"); [EOL] String result = obj.nextToken(); [EOL] assertEquals("superToken", result); [EOL] assertEquals("superToken".length(), obj._index); [EOL] }
public void testPushBackWithNonNullToken() { [EOL] JsonParserSequence parserSequence = new JsonParserSequence(); // Assuming this is the class where pushBack is defined [EOL] String token = "token"; [EOL] parserSequence.pushBack(token); [EOL] assertEquals("token", parserSequence._pushbackToken); // Assuming _pushbackToken is accessible for testing [EOL] assertEquals(-5, parserSequence._index); // Assuming _index is accessible and its initial value was 0 [EOL] }
public void testPushBackWithEmptyToken() { [EOL] JsonParserSequence parserSequence = new JsonParserSequence(); [EOL] String token = ""; [EOL] parserSequence.pushBack(token); [EOL] assertEquals("", parserSequence._pushbackToken); [EOL] assertEquals(0, parserSequence._index); // No change in index as token length is 0 [EOL] }
public void testDeserializeWithNonNullText() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsString()).thenReturn("testString"); [EOL] String result = deserialize(jp, ctxt); [EOL] assertEquals("testString", result); [EOL] }
public void testDeserializeWithEmbeddedObjectNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsString()).thenReturn(null); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(null); [EOL] String result = deserialize(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithEmbeddedObjectByteArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] byte[] bytes = new byte[] { 1, 2, 3 }; [EOL] when(jp.getValueAsString()).thenReturn(null); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(bytes); [EOL] String result = deserialize(jp, ctxt); [EOL] String expected = Base64Variants.getDefaultVariant().encode(bytes, false); [EOL] assertEquals(expected, result); [EOL] }
public void testDeserializeWithEmbeddedObjectNonByteArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object ob = new Object(); [EOL] when(jp.getValueAsString()).thenReturn(null); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(ob); [EOL] String result = deserialize(jp, ctxt); [EOL] assertEquals(ob.toString(), result); [EOL] }
public void testDeserializeWithInvalidToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getValueAsString()).thenReturn(null); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] deserialize(jp, ctxt); [EOL] }); [EOL] }
public void testDeserializeTypedFromScalar() throws IOException, JsonProcessingException { [EOL] JsonParser mockJsonParser = mock(JsonParser.class); [EOL] DeserializationContext mockDeserializationContext = mock(DeserializationContext.class); [EOL] Object expectedObject = new Object(); [EOL] when(this._deserialize(mockJsonParser, mockDeserializationContext)).thenReturn(expectedObject); [EOL] Object result = this.deserializeTypedFromScalar(mockJsonParser, mockDeserializationContext); [EOL] assertEquals(expectedObject, result); [EOL] }
public void testGetRawTypeWithClassType() { [EOL] _type = String.class; // Use any class for testing [EOL] Class<?> result = getRawType(); [EOL] assertEquals(String.class, result); [EOL] }
public void testGetRawTypeWithNonClassType() { [EOL] _type = new TypeReference<List<String>>() {}.getType(); [EOL] Class<?> result = getRawType(); [EOL] assertEquals(List.class, result.getRawClass()); [EOL] }
public void testClone() { [EOL] StdDateFormat original = new StdDateFormat(); [EOL] StdDateFormat clone = original.clone(); [EOL] assertNotNull(clone); [EOL] assertNotSame(original, clone); [EOL] }
public void testStdDateFormatDefaultConstructor() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] assertNotNull(format); [EOL] }
public void testStdDateFormatTimeZoneConstructor() { [EOL] TimeZone tz = TimeZone.getDefault(); [EOL] StdDateFormat format = new StdDateFormat(tz); [EOL] assertEquals(tz, format.getTimeZone()); [EOL] }
public void testGetDefaultTimeZone() { [EOL] TimeZone defaultTZ = StdDateFormat.getDefaultTimeZone(); [EOL] assertNotNull(defaultTZ); [EOL] }
public void testWithTimeZone() { [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] StdDateFormat format = new StdDateFormat(); [EOL] StdDateFormat formatWithTz = format.withTimeZone(tz); [EOL] assertNotNull(formatWithTz); [EOL] assertEquals(tz, formatWithTz.getTimeZone()); [EOL] }
public void testGetBlueprintISO8601Format() { [EOL] DateFormat blueprint = StdDateFormat.getBlueprintISO8601Format(); [EOL] assertNotNull(blueprint); [EOL] }
public void testGetISO8601Format() { [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] DateFormat iso8601Format = StdDateFormat.getISO8601Format(tz); [EOL] assertNotNull(iso8601Format); [EOL] }
public void testGetBlueprintRFC1123Format() { [EOL] DateFormat blueprint = StdDateFormat.getBlueprintRFC1123Format(); [EOL] assertNotNull(blueprint); [EOL] }
public void testGetRFC1123Format() { [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] DateFormat rfc1123Format = StdDateFormat.getRFC1123Format(tz); [EOL] assertNotNull(rfc1123Format); [EOL] }
public void testSetTimeZone() { [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] StdDateFormat format = new StdDateFormat(); [EOL] format.setTimeZone(tz); [EOL] assertEquals(tz, format.getTimeZone()); [EOL] }
public void testParseString() throws ParseException { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String dateStr = "2023-01-01T00:00:00.000Z"; [EOL] Date date = format.parse(dateStr); [EOL] assertNotNull(date); [EOL] }
public void testParseStringParsePosition() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String dateStr = "2023-01-01T00:00:00.000Z"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date date = format.parse(dateStr, pos); [EOL] assertNotNull(date); [EOL] }
public void testFormat() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] Date date = new Date(); [EOL] StringBuffer toAppendTo = new StringBuffer(); [EOL] FieldPosition fieldPosition = new FieldPosition(0); [EOL] StringBuffer result = format.format(date, toAppendTo, fieldPosition); [EOL] assertNotNull(result); [EOL] }
public void testLooksLikeISO8601() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String dateStr = "2023-01-01T00:00:00.000Z"; [EOL] boolean result = format.looksLikeISO8601(dateStr); [EOL] assertTrue(result); [EOL] }
public void testParseAsISO8601() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String dateStr = "2023-01-01T00:00:00.000Z"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date date = format.parseAsISO8601(dateStr, pos); [EOL] assertNotNull(date); [EOL] }
public void testParseAsRFC1123() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String dateStr = "Sun, 01 Jan 2023 00:00:00 GMT"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date date = format.parseAsRFC1123(dateStr, pos); [EOL] assertNotNull(date); [EOL] }
public void testHasTimeZone() { [EOL] String dateStr = "2023-01-01T00:00:00.000+0100"; [EOL] boolean result = StdDateFormat.hasTimeZone(dateStr); [EOL] assertTrue(result); [EOL] }
public void testCloneFormat() { [EOL] DateFormat original = new SimpleDateFormat(); [EOL] DateFormat clone = StdDateFormat._cloneFormat(original); [EOL] assertNotNull(clone); [EOL] assertNotSame(original, clone); [EOL] }
public void testCloneFormatWithTimeZone() { [EOL] DateFormat original = new SimpleDateFormat(); [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] DateFormat clone = StdDateFormat._cloneFormat(original, tz); [EOL] assertNotNull(clone); [EOL] assertNotSame(original, clone); [EOL] assertEquals(tz, clone.getTimeZone()); [EOL] }
public void testParseValidDateISO8601() throws ParseException { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String validISO8601Date = "2020-01-01T12:00:00.000+0000"; [EOL] Date result = format.parse(validISO8601Date); [EOL] assertNotNull(result); [EOL] }
public void testParseValidDateISO8601Z() throws ParseException { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String validISO8601ZDate = "2020-01-01T12:00:00.000Z"; [EOL] Date result = format.parse(validISO8601ZDate); [EOL] assertNotNull(result); [EOL] }
public void testParseValidDateRFC1123() throws ParseException { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String validRFC1123Date = "Wed, 01 Jan 2020 12:00:00 GMT"; [EOL] Date result = format.parse(validRFC1123Date); [EOL] assertNotNull(result); [EOL] }
public void testParseValidDatePlain() throws ParseException { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String validPlainDate = "2020-01-01"; [EOL] Date result = format.parse(validPlainDate); [EOL] assertNotNull(result); [EOL] }
public void testParseInvalidDate() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String invalidDate = "not-a-date"; [EOL] try { [EOL] format.parse(invalidDate); [EOL] fail("Should have thrown ParseException"); [EOL] } catch (ParseException e) { [EOL] } [EOL] }
public void testParseWithISO8601Format() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String iso8601DateStr = "2023-03-15T16:42:00.000+0000"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date result = format.parse(iso8601DateStr, pos); [EOL] assertNotNull(result); [EOL] }
public void testParseWithNonISO8601Format() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String nonISO8601DateStr = "Wed, 15 Mar 2023 16:42:00 GMT"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date result = format.parse(nonISO8601DateStr, pos); [EOL] assertNotNull(result); [EOL] }
public void testParseWithAllDigits() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String allDigitsDateStr = "1234567890123"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date result = format.parse(allDigitsDateStr, pos); [EOL] assertNotNull(result); [EOL] }
public void testParseWithInvalidFormat() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] String invalidDateStr = "not-a-date"; [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date result = format.parse(invalidDateStr, pos); [EOL] assertNull(result); [EOL] }
public void testLooksLikeISO8601_ValidFormat() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] String validISO8601Date = "2023-03-15"; [EOL] boolean result = stdDateFormat.looksLikeISO8601(validISO8601Date); [EOL] assertTrue(result); [EOL] }
public void testLooksLikeISO8601_TooShort() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] String tooShortDate = "1234"; [EOL] boolean result = stdDateFormat.looksLikeISO8601(tooShortDate); [EOL] assertFalse(result); [EOL] }
public void testLooksLikeISO8601_InvalidCharacter() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] String invalidCharacterDate = "2023/03-15"; [EOL] boolean result = stdDateFormat.looksLikeISO8601(invalidCharacterDate); [EOL] assertFalse(result); [EOL] }
public void testLooksLikeISO8601_InvalidDigit() { [EOL] StdDateFormat stdDateFormat = new StdDateFormat(); [EOL] String invalidDigitDate = "20X3-03-15"; [EOL] boolean result = stdDateFormat.looksLikeISO8601(invalidDigitDate); [EOL] assertFalse(result); [EOL] }
public void testParseAsISO8601WithShortDateAndDigit() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date result = format.parseAsISO8601("2023-03-15", pos); [EOL] assertNotNull(result); [EOL] }
public void testParseAsISO8601WithZSuffix() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date result = format.parseAsISO8601("2023-03-15T00:00:00Z", pos); [EOL] assertNotNull(result); [EOL] }
public void testParseAsISO8601WithZSuffixAndColonInTimeZone() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date result = format.parseAsISO8601("2023-03-15T00:00:00.000Z", pos); [EOL] assertNotNull(result); [EOL] }
public void testParseAsISO8601WithTimeZoneAndColon() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date result = format.parseAsISO8601("2023-03-15T00:00:00+01:00", pos); [EOL] assertNotNull(result); [EOL] }
public void testParseAsISO8601WithTimeZoneWithoutColon() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date result = format.parseAsISO8601("2023-03-15T00:00:00+0100", pos); [EOL] assertNotNull(result); [EOL] }
public void testParseAsISO8601WithTimeZoneAndAdditionalZeroes() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date result = format.parseAsISO8601("2023-03-15T00:00:00+01", pos); [EOL] assertNotNull(result); [EOL] }
public void testParseAsISO8601WithNoTimeZoneAndShortTime() { [EOL] StdDateFormat format = new StdDateFormat(); [EOL] ParsePosition pos = new ParsePosition(0); [EOL] Date result = format.parseAsISO8601("2023-03-15T00:00Z", pos); [EOL] assertNotNull(result); [EOL] }
public void testHasTimeZoneWithPlusSign() { [EOL] assertTrue(hasTimeZone("2023-03-15T00:00:00+0100")); [EOL] }
public void testHasTimeZoneWithMinusSign() { [EOL] assertTrue(hasTimeZone("2023-03-15T00:00:00-0700")); [EOL] }
public void testHasTimeZoneWithoutTimeZone() { [EOL] assertFalse(hasTimeZone("2023-03-15T00:00:00")); [EOL] }
public void testHasTimeZoneWithZ() { [EOL] assertFalse(hasTimeZone("2023-03-15T00:00:00Z")); [EOL] }
public void testHasTimeZoneWithShortInput() { [EOL] assertFalse(hasTimeZone("12345")); [EOL] }
public void testHasTimeZoneWithInvalidPositionPlus() { [EOL] assertFalse(hasTimeZone("2023-03-15T00:00+00:00")); [EOL] }
public void testHasTimeZoneWithInvalidPositionMinus() { [EOL] assertFalse(hasTimeZone("2023-03-15T00:00-00:00")); [EOL] }
public void testSettableBeanPropertyWithEmptyPropName() { [EOL] String propName = ""; [EOL] JavaType type = mock(JavaType.class); [EOL] PropertyName wrapper = mock(PropertyName.class); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] Annotations contextAnnotations = mock(Annotations.class); [EOL] boolean isRequired = false; [EOL] SettableBeanProperty property = new SettableBeanProperty(propName, type, wrapper, typeDeser, contextAnnotations, isRequired); [EOL] assertEquals("", property.getName()); [EOL] assertEquals(type, property.getType()); [EOL] assertEquals(wrapper, property.getWrapperName()); [EOL] assertEquals(isRequired, property.isRequired()); [EOL] assertNull(property.getValueTypeDeserializer()); [EOL] assertNotNull(property.getValueDeserializer()); [EOL] }
public void testSettableBeanPropertyWithNonNullPropName() { [EOL] String propName = "testProperty"; [EOL] JavaType type = mock(JavaType.class); [EOL] PropertyName wrapper = mock(PropertyName.class); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] Annotations contextAnnotations = mock(Annotations.class); [EOL] boolean isRequired = true; [EOL] SettableBeanProperty property = new SettableBeanProperty(propName, type, wrapper, typeDeser, contextAnnotations, isRequired); [EOL] assertEquals("testProperty", property.getName()); [EOL] assertEquals(type, property.getType()); [EOL] assertEquals(wrapper, property.getWrapperName()); [EOL] assertEquals(isRequired, property.isRequired()); [EOL] assertNotNull(property.getValueTypeDeserializer()); [EOL] assertNotNull(property.getValueDeserializer()); [EOL] }
public void testSettableBeanPropertyWithTypeDeserializerNull() { [EOL] String propName = "testProperty"; [EOL] JavaType type = mock(JavaType.class); [EOL] PropertyName wrapper = mock(PropertyName.class); [EOL] TypeDeserializer typeDeser = null; [EOL] Annotations contextAnnotations = mock(Annotations.class); [EOL] boolean isRequired = true; [EOL] SettableBeanProperty property = new SettableBeanProperty(propName, type, wrapper, typeDeser, contextAnnotations, isRequired); [EOL] assertEquals("testProperty", property.getName()); [EOL] assertEquals(type, property.getType()); [EOL] assertEquals(wrapper, property.getWrapperName()); [EOL] assertEquals(isRequired, property.isRequired()); [EOL] assertNull(property.getValueTypeDeserializer()); [EOL] assertNotNull(property.getValueDeserializer()); [EOL] }
public void testThrowableDeserializerWithNonNullBaseDeserializer() { [EOL] BeanDeserializer baseDeserializer = new BeanDeserializer(); // Assuming BeanDeserializer is a valid class [EOL] ThrowableDeserializer throwableDeserializer = new ThrowableDeserializer(baseDeserializer); [EOL] assertNotNull(throwableDeserializer); [EOL] assertFalse(throwableDeserializer._vanillaProcessing); [EOL] }
public void testDeserializeFromObjectWithPropertyBasedCreator() throws IOException, JsonProcessingException { [EOL] when(_propertyBasedCreator.deserializeFromObject(any(JsonParser.class), any(DeserializationContext.class))) [EOL] .thenReturn(new Object()); [EOL] Object result = deserializeFromObject(mock(JsonParser.class), mock(DeserializationContext.class)); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromObjectWithDelegateDeserializer() throws IOException, JsonProcessingException { [EOL] when(_delegateDeserializer.deserialize(any(JsonParser.class), any(DeserializationContext.class))) [EOL] .thenReturn(new Object()); [EOL] when(_valueInstantiator.createUsingDelegate(any(DeserializationContext.class), any())) [EOL] .thenReturn(new Object()); [EOL] Object result = deserializeFromObject(mock(JsonParser.class), mock(DeserializationContext.class)); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromObjectWithAbstractBeanType() { [EOL] when(_beanType.isAbstract()).thenReturn(true); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] deserializeFromObject(mock(JsonParser.class), mock(DeserializationContext.class)); [EOL] }); [EOL] }
public void testDeserializeFromObjectWithoutStringCreatorAndDefaultCtor() { [EOL] when(_valueInstantiator.canCreateFromString()).thenReturn(false); [EOL] when(_valueInstantiator.canCreateUsingDefault()).thenReturn(false); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] deserializeFromObject(mock(JsonParser.class), mock(DeserializationContext.class)); [EOL] }); [EOL] }
public void testDeserializeFromObjectWithPendingProperties() throws IOException, JsonProcessingException { [EOL] when(_beanProperties.find(anyString())).thenReturn(mock(SettableBeanProperty.class)); [EOL] when(_beanProperties.size()).thenReturn(1); [EOL] when(mock(JsonParser.class).getCurrentToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.END_OBJECT); [EOL] when(mock(JsonParser.class).getCurrentName()).thenReturn("propName"); [EOL] when(mock(JsonParser.class).getText()).thenReturn("text"); [EOL] Object result = deserializeFromObject(mock(JsonParser.class), mock(DeserializationContext.class)); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromObjectWithIgnorableProps() throws IOException, JsonProcessingException { [EOL] when(_ignorableProps.contains(anyString())).thenReturn(true); [EOL] when(mock(JsonParser.class).getCurrentToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.END_OBJECT); [EOL] when(mock(JsonParser.class).getCurrentName()).thenReturn("ignorableProp"); [EOL] Object result = deserializeFromObject(mock(JsonParser.class), mock(DeserializationContext.class)); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromObjectWithAnySetter() throws IOException, JsonProcessingException { [EOL] when(_anySetter.deserializeAndSet(any(JsonParser.class), any(DeserializationContext.class), any(), anyString())) [EOL] .thenReturn(null); [EOL] when(mock(JsonParser.class).getCurrentToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.END_OBJECT); [EOL] when(mock(JsonParser.class).getCurrentName()).thenReturn("anySetterProp"); [EOL] Object result = deserializeFromObject(mock(JsonParser.class), mock(DeserializationContext.class)); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromObjectHandleUnknownProperty() throws IOException, JsonProcessingException { [EOL] doNothing().when(this).handleUnknownProperty(any(JsonParser.class), any(DeserializationContext.class), any(), anyString()); [EOL] when(mock(JsonParser.class).getCurrentToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.END_OBJECT); [EOL] when(mock(JsonParser.class).getCurrentName()).thenReturn("unknownProp"); [EOL] Object result = deserializeFromObject(mock(JsonParser.class), mock(DeserializationContext.class)); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromObjectWithThrowableCreationFromString() throws IOException, JsonProcessingException { [EOL] when(_valueInstantiator.canCreateFromString()).thenReturn(true); [EOL] when(_valueInstantiator.createFromString(any(DeserializationContext.class), anyString())) [EOL] .thenReturn(new Object()); [EOL] when(mock(JsonParser.class).getCurrentToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.VALUE_STRING, JsonToken.END_OBJECT); [EOL] when(mock(JsonParser.class).getCurrentName()).thenReturn("PROP_NAME_MESSAGE"); [EOL] when(mock(JsonParser.class).getText()).thenReturn("message"); [EOL] Object result = deserializeFromObject(mock(JsonParser.class), mock(DeserializationContext.class)); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeFromObjectWithThrowableCreationUsingDefault() throws IOException, JsonProcessingException { [EOL] when(_valueInstantiator.canCreateUsingDefault()).thenReturn(true); [EOL] when(_valueInstantiator.createUsingDefault(any(DeserializationContext.class))) [EOL] .thenReturn(new Object()); [EOL] when(mock(JsonParser.class).getCurrentToken()).thenReturn(JsonToken.END_OBJECT); [EOL] Object result = deserializeFromObject(mock(JsonParser.class), mock(DeserializationContext.class)); [EOL] assertNotNull(result); [EOL] }
public void testGetValueWithValidPojo() { [EOL] Object pojo = new SomePojoClass(); [EOL] SomePojoClass expectedValue = new SomePojoClass(); // Assuming the field is of type SomePojoClass [EOL] expectedValue.setSomeField(value); // Assuming there's a setter for the field we're trying to get [EOL] Object actualValue = getValue(pojo); [EOL] assertEquals("The value returned was not as expected", expectedValue.getSomeField(), actualValue); [EOL] }
public void testGetValueWithInaccessibleField() { [EOL] Object pojo = new SomeOtherPojoClass(); [EOL] _field.setAccessible(false); // Make the field inaccessible [EOL] try { [EOL] Object value = getValue(pojo); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue("The exception message should contain the field name", e.getMessage().contains(_field.getName())); [EOL] } [EOL] }
public void testManagedReferencePropertyWithNonNullValues() { [EOL] SettableBeanProperty forward = mock(SettableBeanProperty.class); [EOL] SettableBeanProperty backward = mock(SettableBeanProperty.class); [EOL] Annotations contextAnnotations = mock(Annotations.class); [EOL] String refName = "testRef"; [EOL] boolean isContainer = true; [EOL] ManagedReferenceProperty property = new ManagedReferenceProperty(forward, refName, backward, contextAnnotations, isContainer); [EOL] assertEquals("testRef", property.getReferenceName()); [EOL] assertSame(forward, property.getManagedProperty()); [EOL] assertSame(backward, property.getBackProperty()); [EOL] assertTrue(property.isContainer()); [EOL] }
public void testManagedReferencePropertyWithNullValues() { [EOL] SettableBeanProperty forward = mock(SettableBeanProperty.class); [EOL] SettableBeanProperty backward = null; [EOL] Annotations contextAnnotations = null; [EOL] String refName = null; [EOL] boolean isContainer = false; [EOL] ManagedReferenceProperty property = new ManagedReferenceProperty(forward, refName, backward, contextAnnotations, isContainer); [EOL] assertNull(property.getReferenceName()); [EOL] assertSame(forward, property.getManagedProperty()); [EOL] assertNull(property.getBackProperty()); [EOL] assertFalse(property.isContainer()); [EOL] }
public void testGetMemberWhenManagedPropertyHasMember() { [EOL] ManagedProperty managedProperty = mock(ManagedProperty.class); [EOL] AnnotatedMember annotatedMember = mock(AnnotatedMember.class); [EOL] when(managedProperty.getMember()).thenReturn(annotatedMember); [EOL] PropertyBasedCreator propertyBasedCreator = new PropertyBasedCreator(null, null, null); [EOL] propertyBasedCreator._managedProperty = managedProperty; [EOL] AnnotatedMember result = propertyBasedCreator.getMember(); [EOL] assertNotNull(result); [EOL] assertEquals(annotatedMember, result); [EOL] }
public void testGetMemberWhenManagedPropertyHasNoMember() { [EOL] ManagedProperty managedProperty = mock(ManagedProperty.class); [EOL] when(managedProperty.getMember()).thenReturn(null); [EOL] PropertyBasedCreator propertyBasedCreator = new PropertyBasedCreator(null, null, null); [EOL] propertyBasedCreator._managedProperty = managedProperty; [EOL] AnnotatedMember result = propertyBasedCreator.getMember(); [EOL] assertNull(result); [EOL] }
public void testDeserializeAndSet_NullInstance() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object instance = null; [EOL] ManagedProperty _managedProperty = mock(ManagedProperty.class); [EOL] when(_managedProperty.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] try { [EOL] deserializeAndSet(jp, ctxt, instance); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testDeserializeAndSet_ValidInstance() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object instance = new Object(); [EOL] ManagedProperty _managedProperty = mock(ManagedProperty.class); [EOL] Object expectedValue = new Object(); [EOL] when(_managedProperty.deserialize(jp, ctxt)).thenReturn(expectedValue); [EOL] deserializeAndSet(jp, ctxt, instance); [EOL] verify(_managedProperty).deserialize(jp, ctxt); [EOL] }
public void testSetWithValidInstanceAndValue() throws IOException { [EOL] TestClass instance = new TestClass(); [EOL] Object value = "someValue"; [EOL] setter.set(instance, value); [EOL] assertEquals("Value should be set to 'someValue'", "someValue", instance.getProperty()); [EOL] }
public void testSetWithNullInstance() throws IOException { [EOL] Object instance = null; [EOL] Object value = "someValue"; [EOL] try { [EOL] setter.set(instance, value); [EOL] fail("Should have thrown an exception when instance is null"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testSetWithNullValue() throws IOException { [EOL] TestClass instance = new TestClass(); [EOL] Object value = null; [EOL] setter.set(instance, value); [EOL] assertNull("Property should be set to null", instance.getProperty()); [EOL] }
public void testSetAndReturnWithNonNullValueAndIsContainerTrueAndValueIsArray() throws IOException { [EOL] Object instance = new Object(); [EOL] Object[] value = new Object[] { new Object(), null }; [EOL] ManagedPropertyStub _managedProperty = new ManagedPropertyStub(); [EOL] BackPropertyStub _backProperty = new BackPropertyStub(); [EOL] boolean _isContainer = true; [EOL] String _referenceName = "testReference"; [EOL] Object result = _managedProperty.setAndReturn(instance, value); [EOL] for (Object ob : value) { [EOL] if (ob != null) { [EOL] _backProperty.set(ob, instance); [EOL] } [EOL] } [EOL] assertEquals(result, instance); [EOL] }
public void testSetAndReturnWithNonNullValueAndIsContainerTrueAndValueIsCollection() throws IOException { [EOL] Object instance = new Object(); [EOL] Collection<Object> value = Arrays.asList(new Object(), null); [EOL] ManagedPropertyStub _managedProperty = new ManagedPropertyStub(); [EOL] BackPropertyStub _backProperty = new BackPropertyStub(); [EOL] boolean _isContainer = true; [EOL] String _referenceName = "testReference"; [EOL] Object result = _managedProperty.setAndReturn(instance, value); [EOL] for (Object ob : value) { [EOL] if (ob != null) { [EOL] _backProperty.set(ob, instance); [EOL] } [EOL] } [EOL] assertEquals(result, instance); [EOL] }
public void testSetAndReturnWithNonNullValueAndIsContainerTrueAndValueIsMap() throws IOException { [EOL] Object instance = new Object(); [EOL] Map<Object, Object> value = new HashMap<>(); [EOL] value.put("key1", new Object()); [EOL] value.put("key2", null); [EOL] ManagedPropertyStub _managedProperty = new ManagedPropertyStub(); [EOL] BackPropertyStub _backProperty = new BackPropertyStub(); [EOL] boolean _isContainer = true; [EOL] String _referenceName = "testReference"; [EOL] Object result = _managedProperty.setAndReturn(instance, value); [EOL] for (Object ob : value.values()) { [EOL] if (ob != null) { [EOL] _backProperty.set(ob, instance); [EOL] } [EOL] } [EOL] assertEquals(result, instance); [EOL] }
public void testSetAndReturnWithNonNullValueAndIsContainerFalse() throws IOException { [EOL] Object instance = new Object(); [EOL] Object value = new Object(); [EOL] ManagedPropertyStub _managedProperty = new ManagedPropertyStub(); [EOL] BackPropertyStub _backProperty = new BackPropertyStub(); [EOL] boolean _isContainer = false; [EOL] String _referenceName = "testReference"; [EOL] Object result = _managedProperty.setAndReturn(instance, value); [EOL] _backProperty.set(value, instance); [EOL] assertEquals(result, instance); [EOL] }
public void testSetAndReturnWithNullValue() throws IOException { [EOL] Object instance = new Object(); [EOL] Object value = null; [EOL] ManagedPropertyStub _managedProperty = new ManagedPropertyStub(); [EOL] BackPropertyStub _backProperty = new BackPropertyStub(); [EOL] boolean _isContainer = false; [EOL] String _referenceName = "testReference"; [EOL] Object result = _managedProperty.setAndReturn(instance, value); [EOL] assertEquals(result, instance); [EOL] }
public void testSetAndReturnWithUnsupportedContainerType() throws IOException { [EOL] Object instance = new Object(); [EOL] Object value = new UnsupportedContainerType(); [EOL] ManagedPropertyStub _managedProperty = new ManagedPropertyStub(); [EOL] BackPropertyStub _backProperty = new BackPropertyStub(); [EOL] boolean _isContainer = true; [EOL] String _referenceName = "testReference"; [EOL] try { [EOL] _managedProperty.setAndReturn(instance, value); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Unsupported container type (" + value.getClass().getName() + ") when resolving reference '" + _referenceName + "'", e.getMessage()); [EOL] } [EOL] }
public void testBeanSerializerWithNonNullProperties() { [EOL] JavaType type = mock(JavaType.class); [EOL] BeanSerializerBuilder builder = mock(BeanSerializerBuilder.class); [EOL] BeanPropertyWriter[] properties = new BeanPropertyWriter[0]; [EOL] BeanPropertyWriter[] filteredProperties = new BeanPropertyWriter[0]; [EOL] BeanSerializer serializer = new BeanSerializer(type, builder, properties, filteredProperties); [EOL] assertNotNull(serializer); [EOL] }
public void testBeanSerializerWithNullProperties() { [EOL] JavaType type = mock(JavaType.class); [EOL] BeanSerializerBuilder builder = mock(BeanSerializerBuilder.class); [EOL] BeanSerializer serializer = new BeanSerializer(type, builder, null, null); [EOL] assertNotNull(serializer); [EOL] }
public void testCreateDummyWithNonNullType() { [EOL] JavaType forType = new SimpleType(String.class); // Assuming SimpleType is a valid subtype of JavaType [EOL] BeanSerializer result = BeanSerializer.createDummy(forType); [EOL] assertNotNull(result); [EOL] assertEquals(forType, result.handledType()); [EOL] }
public void testCreateDummyWithNullType() { [EOL] try { [EOL] BeanSerializer.createDummy(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testUnwrappingSerializerWithNonNullUnwrapper() { [EOL] NameTransformer unwrapper = mock(NameTransformer.class); [EOL] BeanSerializerBase beanSerializerBase = mock(BeanSerializerBase.class); [EOL] JsonSerializer<Object> result = beanSerializerBase.unwrappingSerializer(unwrapper); [EOL] assertTrue(result instanceof UnwrappingBeanSerializer); [EOL] }
public void testUnwrappingSerializerWithNullUnwrapper() { [EOL] BeanSerializerBase beanSerializerBase = mock(BeanSerializerBase.class); [EOL] JsonSerializer<Object> result = beanSerializerBase.unwrappingSerializer(null); [EOL] assertNull(result); [EOL] }
public void testSerializeWithObjectId() throws IOException { [EOL] BeanSerializerBase serializer = createSerializerWithObjectId(); [EOL] JsonGenerator jgen = createJsonGenerator(); [EOL] SerializerProvider provider = createProvider(); [EOL] Object bean = new Object(); [EOL] serializer.serialize(bean, jgen, provider); [EOL] } [EOL] public void testSerializeFieldsFiltered() throws IOException { [EOL] BeanSerializerBase serializer = createSerializerWithPropertyFilterId(); [EOL] JsonGenerator jgen = createJsonGenerator(); [EOL] SerializerProvider provider = createProvider(); [EOL] Object bean = new Object(); [EOL] serializer.serialize(bean, jgen, provider); [EOL] } [EOL] public void testSerializeFields() throws IOException { [EOL] BeanSerializerBase serializer = createSerializerWithoutPropertyFilterId(); [EOL] JsonGenerator jgen = createJsonGenerator(); [EOL] SerializerProvider provider = createProvider(); [EOL] Object bean = new Object(); [EOL] serializer.serialize(bean, jgen, provider); [EOL] }
public void testHandleTypePropertyValueWithUnknownProperty() throws IOException, JsonProcessingException { [EOL] boolean result = handleTypePropertyValue(jp, ctxt, propName, bean); [EOL] assertFalse(result); [EOL] }
public void testHandleTypePropertyValueWithKnownPropertyButNoTypePropertyName() throws IOException, JsonProcessingException { [EOL] boolean result = handleTypePropertyValue(jp, ctxt, propName, bean); [EOL] assertFalse(result); [EOL] }
public void testHandleTypePropertyValueWithBeanNull() throws IOException, JsonProcessingException { [EOL] boolean result = handleTypePropertyValue(jp, ctxt, propName, null); [EOL] assertTrue(result); [EOL] }
public void testHandleTypePropertyValueWithCanDeserialize() throws IOException, JsonProcessingException { [EOL] boolean result = handleTypePropertyValue(jp, ctxt, propName, bean); [EOL] assertTrue(result); [EOL] }
public void testGetBase64VariantWhenBaseIsNotNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Base64Variant result = mapper.getSerializationConfig().getBase64Variant(); [EOL] assertNotNull(result); [EOL] }
public void testGetBase64VariantWhenBaseHasCustomBase64Variant() { [EOL] Base64Variant customVariant = new Base64Variant("CUSTOM", "ABC", false, '=', 123); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.getSerializationConfig().with(customVariant); [EOL] Base64Variant result = mapper.getSerializationConfig().getBase64Variant(); [EOL] assertEquals(customVariant, result); [EOL] }
public void testNullValueWithPrimitiveAndFailOnNullForPrimitivesEnabled() throws JsonProcessingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)).thenReturn(true); [EOL] try { [EOL] new MyValueDeserializer(true, int.class, 0).nullValue(ctxt); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals("Can not map JSON null into type int (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to 'false' to allow)", e.getMessage()); [EOL] } [EOL] }
public void testNullValueWithPrimitiveAndFailOnNullForPrimitivesDisabled() throws JsonProcessingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)).thenReturn(false); [EOL] Object result = new MyValueDeserializer(true, int.class, 0).nullValue(ctxt); [EOL] assertEquals(0, result); [EOL] }
public void testNullValueWithNonPrimitive() throws JsonProcessingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)).thenReturn(false); [EOL] Object result = new MyValueDeserializer(false, Object.class, null).nullValue(ctxt); [EOL] assertNull(result); [EOL] }
public void testToStringReturnsAsText() { [EOL] JsonNode node = new JsonNode(); [EOL] String expected = node.asText(); [EOL] String actual = node.toString(); [EOL] assertEquals(expected, actual); [EOL] }
public void testFindValueWhenFieldNameIsNull() { [EOL] JsonNode node = new TestJsonNode(); [EOL] String fieldName = null; [EOL] JsonNode result = node.findValue(fieldName); [EOL] assertNull(result); [EOL] } [EOL] public void testFindValueWhenFieldNameIsNotEmpty() { [EOL] JsonNode node = new TestJsonNode(); [EOL] String fieldName = "someFieldName"; [EOL] JsonNode result = node.findValue(fieldName); [EOL] assertNull(result); [EOL] }
public void testFindParentWithNonNullFieldName() { [EOL] ObjectNode objectNode = new ObjectNode(JsonNodeFactory.instance); [EOL] String fieldName = "testField"; [EOL] assertNull(objectNode.findParent(fieldName)); [EOL] } [EOL] public void testFindParentWithNullFieldName() { [EOL] ObjectNode objectNode = new ObjectNode(JsonNodeFactory.instance); [EOL] assertNull(objectNode.findParent(null)); [EOL] }
public void testCollectAndResolveSubtypesWithNullBaseTypeAndNoRegisteredSubtypes() { [EOL] AnnotatedMember property = mock(AnnotatedMember.class); [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] JavaType baseType = null; [EOL] when(property.getRawType()).thenReturn(Object.class); [EOL] Collection<NamedType> result = collectAndResolveSubtypes(property, config, ai, baseType); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testCollectAndResolveSubtypesWithNonNullBaseTypeAndNoRegisteredSubtypes() { [EOL] AnnotatedMember property = mock(AnnotatedMember.class); [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] when(baseType.getRawClass()).thenReturn(Object.class); [EOL] Collection<NamedType> result = collectAndResolveSubtypes(property, config, ai, baseType); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testCollectAndResolveSubtypesWithRegisteredSubtypes() { [EOL] AnnotatedMember property = mock(AnnotatedMember.class); [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Class<?> rawBase = Object.class; [EOL] NamedType registeredSubtype = new NamedType(String.class); [EOL] HashSet<NamedType> registeredSubtypes = new HashSet<>(Collections.singletonList(registeredSubtype)); [EOL] when(baseType.getRawClass()).thenReturn(rawBase); [EOL] when(property.getRawType()).thenReturn(rawBase); [EOL] setRegisteredSubtypes(registeredSubtypes); // Assuming there's a method to set private field _registeredSubtypes [EOL] Collection<NamedType> result = collectAndResolveSubtypes(property, config, ai, baseType); [EOL] assertFalse(result.isEmpty()); [EOL] assertTrue(result.contains(new NamedType(String.class))); [EOL] }
public void testCollectAndResolveSubtypesWithPropertySubtypes() { [EOL] AnnotatedMember property = mock(AnnotatedMember.class); [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] JavaType baseType = mock(JavaType.class); [EOL] Class<?> rawBase = Object.class; [EOL] NamedType propertySubtype = new NamedType(String.class); [EOL] Collection<NamedType> propertySubtypes = Collections.singletonList(propertySubtype); [EOL] when(baseType.getRawClass()).thenReturn(rawBase); [EOL] when(property.getRawType()).thenReturn(rawBase); [EOL] when(ai.findSubtypes(property)).thenReturn(propertySubtypes); [EOL] Collection<NamedType> result = collectAndResolveSubtypes(property, config, ai, baseType); [EOL] assertFalse(result.isEmpty()); [EOL] assertTrue(result.contains(new NamedType(String.class))); [EOL] }
public void testWithTypeHandlerSameHandler() { [EOL] ArrayType original = new ArrayType(...); // Provide actual initialization [EOL] ArrayType result = original.withTypeHandler(original.getTypeHandler()); [EOL] assertSame("Should return the same object if handler is the same", original, result); [EOL] }
public void testWithTypeHandlerDifferentHandler() { [EOL] ArrayType original = new ArrayType(...); // Provide actual initialization [EOL] Object newHandler = new Object(); [EOL] ArrayType result = original.withTypeHandler(newHandler); [EOL] assertNotSame("Should return a new object if handler is different", original, result); [EOL] assertNotNull("New ArrayType should not be null", result); [EOL] assertSame("Type handler should be the one set", newHandler, result.getTypeHandler()); [EOL] }
public void testHasGenericTypes_True() { [EOL] TypeComponentMock componentTypeMock = new TypeComponentMock(); [EOL] componentTypeMock.setHasGenericTypes(true); [EOL] this._componentType = componentTypeMock; [EOL] boolean result = this.hasGenericTypes(); [EOL] assertTrue(result); [EOL] }
public void testHasGenericTypes_False() { [EOL] TypeComponentMock componentTypeMock = new TypeComponentMock(); [EOL] componentTypeMock.setHasGenericTypes(false); [EOL] this._componentType = componentTypeMock; [EOL] boolean result = this.hasGenericTypes(); [EOL] assertFalse(result); [EOL] }
public void testSerializeWithNonNullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] Short testValue = 123; [EOL] new ShortSerializer().serialize(testValue, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeNumber(testValue.shortValue()); [EOL] }
public void testSerializeWithNullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] Short testValue = null; [EOL] new ShortSerializer().serialize(testValue, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator, never()).writeNumber(anyShort()); [EOL] }
public void testSerializeWithNullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] new NumberSerializer().serialize(null, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator, never()).writeNumber(anyInt()); [EOL] }
public void testSerializeWithNonNullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] Number value = 42; [EOL] new NumberSerializer().serialize(value, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeNumber(value.intValue()); [EOL] }
public void testSerializeWithNullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] new FloatSerializer().serialize(null, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator, never()).writeNumber(anyFloat()); [EOL] }
public void testSerializeWithNonNullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] Float testValue = 123.45f; [EOL] new FloatSerializer().serialize(testValue, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeNumber(testValue.floatValue()); [EOL] }
public void testSerializeWithNonNullValue() throws IOException { [EOL] Double value = 123.45; [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] new DoubleSerializer().serialize(value, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeNumber(value.doubleValue()); [EOL] }
public void testSerializeWithNullValue() throws IOException { [EOL] Double value = null; [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] new DoubleSerializer().serialize(value, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator, never()).writeNumber(anyDouble()); [EOL] }
public void testSerializeBigDecimalAsPlain() throws IOException { [EOL] BigDecimal bigDecimal = new BigDecimal("12345.6789"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)).thenReturn(true); [EOL] new NumberSerializer().serialize(bigDecimal, jgen, provider); [EOL] verify(jgen).writeNumber(bigDecimal.toPlainString()); [EOL] }
public void testSerializeBigDecimalNotAsPlain() throws IOException { [EOL] BigDecimal bigDecimal = new BigDecimal("12345.6789"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)).thenReturn(false); [EOL] new NumberSerializer().serialize(bigDecimal, jgen, provider); [EOL] verify(jgen).writeNumber(bigDecimal); [EOL] }
public void testSerializeBigInteger() throws IOException { [EOL] BigInteger bigInteger = new BigInteger("123456789"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] new NumberSerializer().serialize(bigInteger, jgen, provider); [EOL] verify(jgen).writeNumber(bigInteger); [EOL] }
public void testSerializeInteger() throws IOException { [EOL] Integer intValue = 123; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] new NumberSerializer().serialize(intValue, jgen, provider); [EOL] verify(jgen).writeNumber(intValue.intValue()); [EOL] }
public void testSerializeLong() throws IOException { [EOL] Long longValue = 123L; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] new NumberSerializer().serialize(longValue, jgen, provider); [EOL] verify(jgen).writeNumber(longValue.longValue()); [EOL] }
public void testSerializeDouble() throws IOException { [EOL] Double doubleValue = 123.45; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] new NumberSerializer().serialize(doubleValue, jgen, provider); [EOL] verify(jgen).writeNumber(doubleValue.doubleValue()); [EOL] }
public void testSerializeFloat() throws IOException { [EOL] Float floatValue = 123.45f; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] new NumberSerializer().serialize(floatValue, jgen, provider); [EOL] verify(jgen).writeNumber(floatValue.floatValue()); [EOL] }
public void testSerializeByte() throws IOException { [EOL] Byte byteValue = 123; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] new NumberSerializer().serialize(byteValue, jgen, provider); [EOL] verify(jgen).writeNumber(byteValue.intValue()); [EOL] }
public void testSerializeShort() throws IOException { [EOL] Short shortValue = 12345; [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] new NumberSerializer().serialize(shortValue, jgen, provider); [EOL] verify(jgen).writeNumber(shortValue.intValue()); [EOL] }
public void testSerializeUnknownNumberType() throws IOException { [EOL] AtomicLong atomicLong = new AtomicLong(123L); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] new NumberSerializer().serialize(atomicLong, jgen, provider); [EOL] verify(jgen).writeNumber(atomicLong.toString()); [EOL] }
public void testHasSingleElementWithSingleElementArray() { [EOL] String[] singleElementArray = {"one"}; [EOL] assertTrue(hasSingleElement(singleElementArray)); [EOL] }
public void testHasSingleElementWithEmptyArray() { [EOL] String[] emptyArray = {}; [EOL] assertFalse(hasSingleElement(emptyArray)); [EOL] }
public void testHasSingleElementWithMultipleElementsArray() { [EOL] String[] multipleElementsArray = {"one", "two"}; [EOL] assertFalse(hasSingleElement(multipleElementsArray)); [EOL] }
public void testValueOfWithNull() { [EOL] TextNode result = TextNode.valueOf(null); [EOL] assertNull(result); [EOL] }
public void testValueOfWithEmptyString() { [EOL] TextNode result = TextNode.valueOf(""); [EOL] assertSame(TextNode.EMPTY_STRING_NODE, result); [EOL] }
public void testValueOfWithNonEmptyString() { [EOL] String nonEmpty = "non-empty"; [EOL] TextNode result = TextNode.valueOf(nonEmpty); [EOL] assertNotNull(result); [EOL] assertEquals(nonEmpty, result.textValue()); [EOL] }
public void testAsToken() { [EOL] TextNode node = new TextNode("test"); [EOL] assertEquals(JsonToken.VALUE_STRING, node.asToken()); [EOL] }
public void testAsIntWithDefaultValue() { [EOL] TextNode node = new TextNode("123"); [EOL] int result = node.asInt(0); [EOL] assertEquals(123, result); [EOL] }
public void testAsIntWithNonNumericValue() { [EOL] TextNode node = new TextNode("not_a_number"); [EOL] int result = node.asInt(10); [EOL] assertEquals(10, result); [EOL] }
public void testAsIntWithNullValue() { [EOL] TextNode node = new TextNode(null); [EOL] int result = node.asInt(20); [EOL] assertEquals(20, result); [EOL] }
public void testAsLongWithDefaultValue() { [EOL] TextNode node = new TextNode("12345"); [EOL] long defaultValue = 10L; [EOL] long result = node.asLong(defaultValue); [EOL] assertEquals(12345L, result); [EOL] }
public void testAsLongWithInvalidNumber() { [EOL] TextNode node = new TextNode("not_a_number"); [EOL] long defaultValue = 10L; [EOL] long result = node.asLong(defaultValue); [EOL] assertEquals(defaultValue, result); [EOL] }
public void testAsLongWithNull() { [EOL] TextNode node = new TextNode(null); [EOL] long defaultValue = 10L; [EOL] long result = node.asLong(defaultValue); [EOL] assertEquals(defaultValue, result); [EOL] }
public void testAsDoubleWithValidDouble() { [EOL] TextNode node = TextNode.valueOf("10.5"); [EOL] double result = node.asDouble(0.0); [EOL] assert result == 10.5; [EOL] }
public void testAsDoubleWithInvalidDouble() { [EOL] TextNode node = TextNode.valueOf("not a number"); [EOL] double result = node.asDouble(0.0); [EOL] assert result == 0.0; [EOL] }
public void testAsDoubleWithDefault() { [EOL] TextNode node = TextNode.valueOf("not a number"); [EOL] double result = node.asDouble(5.5); [EOL] assert result == 5.5; [EOL] }
public void testEquals_sameObject() { [EOL] TextNode node = new TextNode("test"); [EOL] assertTrue(node.equals(node)); [EOL] } [EOL] public void testEquals_nullObject() { [EOL] TextNode node = new TextNode("test"); [EOL] assertFalse(node.equals(null)); [EOL] } [EOL] public void testEquals_differentClass() { [EOL] TextNode node = new TextNode("test"); [EOL] Object other = new Object(); [EOL] assertFalse(node.equals(other)); [EOL] } [EOL] public void testEquals_equalObjects() { [EOL] TextNode node1 = new TextNode("test"); [EOL] TextNode node2 = new TextNode("test"); [EOL] assertTrue(node1.equals(node2)); [EOL] } [EOL] public void testEquals_unequalObjects() { [EOL] TextNode node1 = new TextNode("test"); [EOL] TextNode node2 = new TextNode("different"); [EOL] assertFalse(node1.equals(node2)); [EOL] }
public void testHashCodeWithNonNullValue() { [EOL] SomeClass instance = new SomeClass("testValue"); [EOL] int expectedHashCode = "testValue".hashCode(); [EOL] int actualHashCode = instance.hashCode(); [EOL] assertEquals(expectedHashCode, actualHashCode); [EOL] }
public void testHashCodeWithNullValue() { [EOL] SomeClass instance = new SomeClass(null); [EOL] int expectedHashCode = 0; // Assuming the hashCode for null _value is 0 [EOL] int actualHashCode = instance.hashCode(); [EOL] assertEquals(expectedHashCode, actualHashCode); [EOL] }
public void testToStringEmpty() { [EOL] MyStringWrapper wrapper = new MyStringWrapper(""); // Assuming MyStringWrapper is the class containing the toString method [EOL] String result = wrapper.toString(); [EOL] assertEquals("\"\"", result); [EOL] }
public void testToStringShortString() { [EOL] MyStringWrapper wrapper = new MyStringWrapper("abc"); [EOL] String result = wrapper.toString(); [EOL] assertEquals("\"abc\"", result); [EOL] }
public void testToStringLongString() { [EOL] MyStringWrapper wrapper = new MyStringWrapper("abcdefghijklmnopqrstuvwxyz"); [EOL] String result = wrapper.toString(); [EOL] assertTrue(result.length() > "abcdefghijklmnopqrstuvwxyz".length()); [EOL] assertEquals("\"abcdefghijklmnopqrstuvwxyz\"", result); [EOL] }
public void testAppendQuotedWithEmptyString() { [EOL] StringBuilder sb = new StringBuilder(); [EOL] String content = ""; [EOL] appendQuoted(sb, content); [EOL] assertEquals("\"\"", sb.toString()); [EOL] }
public void testAppendQuotedWithRegularString() { [EOL] StringBuilder sb = new StringBuilder(); [EOL] String content = "test"; [EOL] appendQuoted(sb, content); [EOL] assertEquals("\"test\"", sb.toString()); [EOL] }
public void testAppendQuotedWithSpecialCharacters() { [EOL] StringBuilder sb = new StringBuilder(); [EOL] String content = "te\"st"; [EOL] appendQuoted(sb, content); [EOL] assertEquals("\"te\\\"st\"", sb.toString()); [EOL] }
public void testCreateContextualWithNullDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] StringArrayDeserializer deserializer = new StringArrayDeserializer(null); [EOL] JsonDeserializer<?> result = deserializer.createContextual(ctxt, property); [EOL] assertNull(result); [EOL] }
public void testCreateContextualWithNonNullDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonDeserializer<?> elementDeserializer = mock(JsonDeserializer.class); [EOL] StringArrayDeserializer deserializer = new StringArrayDeserializer(elementDeserializer); [EOL] when(ctxt.findContextualValueDeserializer(any(), any())).thenReturn(elementDeserializer); [EOL] when(elementDeserializer instanceof ContextualDeserializer).thenReturn(true); [EOL] when(((ContextualDeserializer) elementDeserializer).createContextual(ctxt, property)).thenReturn(elementDeserializer); [EOL] JsonDeserializer<?> result = deserializer.createContextual(ctxt, property); [EOL] assertNotSame(elementDeserializer, result); [EOL] assertTrue(result instanceof StringArrayDeserializer); [EOL] }
public void testCreateContextualWithDefaultDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonDeserializer<?> elementDeserializer = mock(JsonDeserializer.class); [EOL] StringArrayDeserializer deserializer = new StringArrayDeserializer(elementDeserializer); [EOL] when(ctxt.findContextualValueDeserializer(any(), any())).thenReturn(elementDeserializer); [EOL] when(deserializer.isDefaultDeserializer(elementDeserializer)).thenReturn(true); [EOL] JsonDeserializer<?> result = deserializer.createContextual(ctxt, property); [EOL] assertSame(deserializer, result); [EOL] }
public void testHierarchicTypeConstructorWithAllParams() { [EOL] Type actualType = String.class; [EOL] Class<?> rawClass = String.class; [EOL] ParameterizedType genericType = null; // Assuming we don't have a concrete ParameterizedType for this test [EOL] HierarchicType superType = new HierarchicType(Object.class, Object.class, null, null, null); [EOL] HierarchicType subType = null; [EOL] HierarchicType hierarchicType = new HierarchicType(actualType, rawClass, genericType, superType, subType); [EOL] assertNotNull(hierarchicType); [EOL] assertEquals(actualType, hierarchicType._actualType); [EOL] assertEquals(rawClass, hierarchicType._rawClass); [EOL] assertEquals(genericType, hierarchicType._genericType); [EOL] assertEquals(superType, hierarchicType._superType); [EOL] assertNull(hierarchicType._subType); [EOL] }
public void testDeepCloneWithoutSubtypeWithNullSuperType() { [EOL] HierarchicType original = new HierarchicType(Object.class, null, null, null, null); [EOL] HierarchicType clone = original.deepCloneWithoutSubtype(); [EOL] assertNotNull(clone); [EOL] assertNull(clone.getSuperType()); [EOL] assertEquals(Object.class, clone.getRawClass()); [EOL] assertNull(clone.getSubType()); [EOL] assertNull(clone.getGenericType()); [EOL] }
public void testDeepCloneWithoutSubtypeWithNonNullSuperType() { [EOL] HierarchicType superType = new HierarchicType(String.class, null, null, null, null); [EOL] HierarchicType original = new HierarchicType(Object.class, null, null, superType, null); [EOL] HierarchicType clone = original.deepCloneWithoutSubtype(); [EOL] assertNotNull(clone); [EOL] assertNotNull(clone.getSuperType()); [EOL] assertEquals(Object.class, clone.getRawClass()); [EOL] assertNull(clone.getSubType()); [EOL] assertNull(clone.getGenericType()); [EOL] assertNotSame(superType, clone.getSuperType()); [EOL] assertEquals(String.class, clone.getSuperType().getRawClass()); [EOL] assertNull(clone.getSuperType().getSubType()); [EOL] assertNull(clone.getSuperType().getGenericType()); [EOL] }
public void testInetAddressSerializerConstructor() { [EOL] InetAddressSerializer serializer = new InetAddressSerializer(); [EOL] assertNotNull(serializer); [EOL] assertEquals(InetAddress.class, serializer.handledType()); [EOL] }
public void testSerializeWithSlashAtStart() throws IOException { [EOL] InetAddress value = InetAddress.getByName("/127.0.0.1"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] new InetAddressSerializer().serialize(value, jgen, provider); [EOL] verify(jgen).writeString("127.0.0.1"); [EOL] }
public void testSerializeWithSlashInMiddle() throws IOException { [EOL] InetAddress value = InetAddress.getByName("localhost/127.0.0.1"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] new InetAddressSerializer().serialize(value, jgen, provider); [EOL] verify(jgen).writeString("localhost"); [EOL] }
public void testSerializeWithoutSlash() throws IOException { [EOL] InetAddress value = InetAddress.getByName("127.0.0.1"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] new InetAddressSerializer().serialize(value, jgen, provider); [EOL] verify(jgen).writeString("127.0.0.1"); [EOL] }
public void testAddSerializerWithNullSerializers() { [EOL] SimpleModule module = new SimpleModule(); [EOL] JsonSerializer<?> serializer = mock(JsonSerializer.class); [EOL] module.addSerializer(serializer); [EOL] assertNotNull(module.getSerializers()); [EOL] }
public void testAddSerializerWithNonNullSerializers() { [EOL] SimpleModule module = new SimpleModule(); [EOL] JsonSerializer<?> serializer1 = mock(JsonSerializer.class); [EOL] JsonSerializer<?> serializer2 = mock(JsonSerializer.class); [EOL] module.addSerializer(serializer1); // This call initializes _serializers [EOL] module.addSerializer(serializer2); // This call uses the existing _serializers [EOL] assertNotNull(module.getSerializers()); [EOL] assertEquals(2, module.getSerializers().size()); [EOL] }
public void testAddKeySerializerWithNonNullSerializers() { [EOL] SimpleModule module = new SimpleModule(); [EOL] JsonSerializer<Object> serializer = new JsonSerializer<Object>() { [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider serializers) { [EOL] } [EOL] }; [EOL] module.addKeySerializer(String.class, serializer); [EOL] }
public void testAddKeySerializerWithNullSerializers() { [EOL] SimpleModule module = new SimpleModule(); [EOL] JsonSerializer<Object> serializer = new JsonSerializer<Object>() { [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider serializers) { [EOL] } [EOL] }; [EOL] module.addKeySerializer(String.class, serializer); [EOL] }
public void testAddValueInstantiatorWithNullValueInstantiators() { [EOL] SimpleModule module = new SimpleModule(); [EOL] Class<?> beanType = String.class; [EOL] ValueInstantiator inst = new StdValueInstantiator(null); [EOL] SimpleModule result = module.addValueInstantiator(beanType, inst); [EOL] assertNotNull(result); [EOL] assertSame(result, module); [EOL] }
public void testAddValueInstantiatorWithNonNullValueInstantiators() { [EOL] SimpleModule module = new SimpleModule(); [EOL] Class<?> beanType = String.class; [EOL] ValueInstantiator inst = new StdValueInstantiator(null); [EOL] module.addValueInstantiator(beanType, inst); // Pre-populate with one instantiator [EOL] Class<?> newBeanType = Integer.class; [EOL] ValueInstantiator newInst = new StdValueInstantiator(null); [EOL] SimpleModule result = module.addValueInstantiator(newBeanType, newInst); [EOL] assertNotNull(result); [EOL] assertSame(result, module); [EOL] }
public void testSetupModuleWithAllFieldsNull() { [EOL] SetupContext context = mock(SetupContext.class); [EOL] setupModule(context); [EOL] verify(context, never()).addSerializers(any()); [EOL] verify(context, never()).addDeserializers(any()); [EOL] verify(context, never()).addKeySerializers(any()); [EOL] verify(context, never()).addKeyDeserializers(any()); [EOL] verify(context, never()).addAbstractTypeResolver(any()); [EOL] verify(context, never()).addValueInstantiators(any()); [EOL] verify(context, never()).addBeanDeserializerModifier(any()); [EOL] verify(context, never()).addBeanSerializerModifier(any()); [EOL] verify(context, never()).registerSubtypes((NamedType[]) any()); [EOL] verify(context, never()).setMixInAnnotations(any(Class.class), any(Class.class)); [EOL] }
public void testSetupModuleWithNonNullFields() { [EOL] SetupContext context = mock(SetupContext.class); [EOL] when(_serializers != null).thenReturn(true); [EOL] when(_deserializers != null).thenReturn(true); [EOL] when(_keySerializers != null).thenReturn(true); [EOL] when(_keyDeserializers != null).thenReturn(true); [EOL] when(_abstractTypes != null).thenReturn(true); [EOL] when(_valueInstantiators != null).thenReturn(true); [EOL] when(_deserializerModifier != null).thenReturn(true); [EOL] when(_serializerModifier != null).thenReturn(true); [EOL] when(_subtypes != null).thenReturn(true); [EOL] when(_subtypes.size()).thenReturn(1); [EOL] when(_mixins != null).thenReturn(true); [EOL] when(_mixins.entrySet()).thenReturn(new HashSet<Map.Entry<Class<?>, Class<?>>>().iterator()); [EOL] setupModule(context); [EOL] verify(context).addSerializers(_serializers); [EOL] verify(context).addDeserializers(_deserializers); [EOL] verify(context).addKeySerializers(_keySerializers); [EOL] verify(context).addKeyDeserializers(_keyDeserializers); [EOL] verify(context).addAbstractTypeResolver(_abstractTypes); [EOL] verify(context).addValueInstantiators(_valueInstantiators); [EOL] verify(context).addBeanDeserializerModifier(_deserializerModifier); [EOL] verify(context).addBeanSerializerModifier(_serializerModifier); [EOL] verify(context).registerSubtypes((NamedType[]) any()); [EOL] verify(context).setMixInAnnotations(any(Class.class), any(Class.class)); [EOL] }
public void testSetupModuleWithNonNullSubtypesAndEmptyList() { [EOL] SetupContext context = mock(SetupContext.class); [EOL] when(_subtypes != null).thenReturn(true); [EOL] when(_subtypes.size()).thenReturn(0); [EOL] setupModule(context); [EOL] verify(context, never()).registerSubtypes((NamedType[]) any()); [EOL] }
public void testSetupModuleWithNonNullMixins() { [EOL] SetupContext context = mock(SetupContext.class); [EOL] Map<Class<?>, Class<?>> mixinsMap = new HashMap<>(); [EOL] mixinsMap.put(String.class, Integer.class); [EOL] when(_mixins != null).thenReturn(true); [EOL] when(_mixins.entrySet()).thenReturn(mixinsMap.entrySet()); [EOL] setupModule(context); [EOL] verify(context).setMixInAnnotations(String.class, Integer.class); [EOL] }
public void testConstructUnsafeWithNonNullClass() { [EOL] Class<?> rawClass = String.class; [EOL] SimpleType simpleType = SimpleType.constructUnsafe(rawClass); [EOL] assertNotNull(simpleType); [EOL] assertEquals(rawClass, simpleType.getRawClass()); [EOL] assertNull(simpleType.getBindings()); [EOL] assertFalse(simpleType.isContainerType()); [EOL] }
public void testConstructUnsafeWithNullClass() { [EOL] try { [EOL] SimpleType.constructUnsafe(null); [EOL] fail("Expected IllegalArgumentException for null class"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testBuildCanonicalNameWithoutTypeParameters() { [EOL] MyClassUnderTest instance = createInstance(String.class, null); [EOL] String result = instance.buildCanonicalName(); [EOL] assertEquals("java.lang.String", result); [EOL] }
public void testBuildCanonicalNameWithTypeParameters() { [EOL] JavaType[] typeParameters = new JavaType[] { createJavaType(String.class), createJavaType(Integer.class) }; [EOL] MyClassUnderTest instance = createInstance(List.class, typeParameters); [EOL] String result = instance.buildCanonicalName(); [EOL] assertEquals("java.util.List<java.lang.String,java.lang.Integer>", result); [EOL] }
public void testEquals_Reflexive() { [EOL] SimpleType type = new SimpleType(String.class); [EOL] assertTrue(type.equals(type)); [EOL] }
public void testEquals_Null() { [EOL] SimpleType type = new SimpleType(String.class); [EOL] assertFalse(type.equals(null)); [EOL] }
public void testEquals_DifferentClass() { [EOL] SimpleType type1 = new SimpleType(String.class); [EOL] Object type2 = new Object(); [EOL] assertFalse(type1.equals(type2)); [EOL] }
public void testEquals_DifferentTypeClass() { [EOL] SimpleType type1 = new SimpleType(String.class); [EOL] SimpleType type2 = new SimpleType(Integer.class); [EOL] assertFalse(type1.equals(type2)); [EOL] }
public void testEquals_TypeParametersNull() { [EOL] SimpleType type1 = new SimpleType(String.class, null, null, null); [EOL] SimpleType type2 = new SimpleType(String.class, null, null, null); [EOL] assertTrue(type1.equals(type2)); [EOL] }
public void testEquals_TypeParametersEmpty() { [EOL] SimpleType type1 = new SimpleType(String.class, new JavaType[0], null, null); [EOL] SimpleType type2 = new SimpleType(String.class, null, null, null); [EOL] assertTrue(type1.equals(type2)); [EOL] }
public void testEquals_TypeParametersDifferentLengths() { [EOL] SimpleType type1 = new SimpleType(String.class, new JavaType[1], null, null); [EOL] SimpleType type2 = new SimpleType(String.class, new JavaType[2], null, null); [EOL] assertFalse(type1.equals(type2)); [EOL] }
public void testEquals_TypeParametersElementMismatch() { [EOL] JavaType javaType1 = new SimpleType(String.class); [EOL] JavaType javaType2 = new SimpleType(Integer.class); [EOL] SimpleType type1 = new SimpleType(String.class, new JavaType[]{javaType1}, null, null); [EOL] SimpleType type2 = new SimpleType(String.class, new JavaType[]{javaType2}, null, null); [EOL] assertFalse(type1.equals(type2)); [EOL] }
public void testEquals_TypeParametersEqual() { [EOL] JavaType javaType = new SimpleType(String.class); [EOL] SimpleType type1 = new SimpleType(String.class, new JavaType[]{javaType}, null, null); [EOL] SimpleType type2 = new SimpleType(String.class, new JavaType[]{javaType}, null, null); [EOL] assertTrue(type1.equals(type2)); [EOL] }
public void testDefaultInstance() { [EOL] TypeFactory typeFactory1 = TypeFactory.defaultInstance(); [EOL] assertNotNull(typeFactory1); [EOL] TypeFactory typeFactory2 = TypeFactory.defaultInstance(); [EOL] assertSame(typeFactory1, typeFactory2); [EOL] }
public void testConstructSpecializedTypeWithSimpleTypeAndSubclassIsArray() { [EOL] JavaType baseType = new SimpleType(String.class); [EOL] Class<?> subclass = String[].class; [EOL] try { [EOL] constructSpecializedType(baseType, subclass); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConstructSpecializedTypeWithSimpleTypeAndSubclassIsMap() { [EOL] JavaType baseType = new SimpleType(AbstractMap.class); [EOL] Class<?> subclass = HashMap.class; [EOL] JavaType specializedType = constructSpecializedType(baseType, subclass); [EOL] assertEquals(subclass, specializedType.getRawClass()); [EOL] }
public void testConstructSpecializedTypeWithSimpleTypeAndSubclassIsCollection() { [EOL] JavaType baseType = new SimpleType(AbstractCollection.class); [EOL] Class<?> subclass = ArrayList.class; [EOL] JavaType specializedType = constructSpecializedType(baseType, subclass); [EOL] assertEquals(subclass, specializedType.getRawClass()); [EOL] }
public void testConstructSpecializedTypeWithNonSimpleType() { [EOL] JavaType baseType = new ArrayType(String[].class, null, null, null, null); [EOL] Class<?> subclass = String[].class; [EOL] JavaType specializedType = constructSpecializedType(baseType, subclass); [EOL] assertEquals(subclass, specializedType.getRawClass()); [EOL] }
public void testConstructFromCanonicalWithValidInput() { [EOL] TypeFactory typeFactory = TypeFactory.defaultInstance(); [EOL] String canonical = "java.util.List<java.lang.String>"; [EOL] JavaType javaType = typeFactory.constructFromCanonical(canonical); [EOL] assertNotNull(javaType); [EOL] assertEquals("java.util.List", javaType.getRawClass().getName()); [EOL] assertEquals("java.lang.String", javaType.containedType(0).getRawClass().getName()); [EOL] }
public void testConstructFromCanonicalWithInvalidInput() { [EOL] TypeFactory typeFactory = TypeFactory.defaultInstance(); [EOL] String canonical = "invalid"; [EOL] try { [EOL] typeFactory.constructFromCanonical(canonical); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertNotNull(e.getMessage()); [EOL] } [EOL] }
public void testConstructFromCanonicalWithNullInput() { [EOL] TypeFactory typeFactory = TypeFactory.defaultInstance(); [EOL] try { [EOL] typeFactory.constructFromCanonical(null); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertNotNull(e.getMessage()); [EOL] } [EOL] }
public void testFindTypeParametersWithNullClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType[] typeParameters = mapper.getTypeFactory().findTypeParameters(null, Object.class); [EOL] assertNull(typeParameters); [EOL] }
public void testFindTypeParametersWithNonParameterizedClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType[] typeParameters = mapper.getTypeFactory().findTypeParameters(String.class, Object.class); [EOL] assertNotNull(typeParameters); [EOL] assertEquals(0, typeParameters.length); [EOL] }
public void testFindTypeParametersWithParameterizedClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType[] typeParameters = mapper.getTypeFactory().findTypeParameters(ArrayList.class, List.class); [EOL] assertNotNull(typeParameters); [EOL] assertEquals(1, typeParameters.length); [EOL] assertEquals(Object.class, typeParameters[0].getRawClass()); [EOL] }
public void testFindTypeParametersWithNonSubtype() { [EOL] try { [EOL] TypeFactory typeFactory = TypeFactory.defaultInstance(); [EOL] Class<?> clz = String.class; [EOL] Class<?> expType = Integer.class; [EOL] TypeBindings bindings = new TypeBindings(typeFactory, clz); [EOL] typeFactory.findTypeParameters(clz, expType, bindings); [EOL] fail("IllegalArgumentException expected"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testFindTypeParametersWithDirectSubtype() { [EOL] TypeFactory typeFactory = TypeFactory.defaultInstance(); [EOL] Class<?> clz = ArrayList.class; [EOL] Class<?> expType = List.class; [EOL] TypeBindings bindings = new TypeBindings(typeFactory, clz); [EOL] JavaType[] types = typeFactory.findTypeParameters(clz, expType, bindings); [EOL] assertNotNull(types); [EOL] assertEquals(1, types.length); [EOL] }
public void testFindTypeParametersWithIndirectSubtype() { [EOL] TypeFactory typeFactory = TypeFactory.defaultInstance(); [EOL] Class<?> clz = Integer.class; [EOL] Class<?> expType = Number.class; [EOL] TypeBindings bindings = new TypeBindings(typeFactory, clz); [EOL] JavaType[] types = typeFactory.findTypeParameters(clz, expType, bindings); [EOL] assertNull(types); [EOL] }
public JavaType constructType(Type type) { [EOL] return _constructType(type, null); [EOL] }
public void testConstructTypeWithClass() { [EOL] TypeBindings context = new TypeBindings(null, null, null); [EOL] JavaType result = _constructType(String.class, context); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof SimpleType); [EOL] }
public void testConstructTypeWithParameterizedType() throws NoSuchFieldException { [EOL] TypeBindings context = new TypeBindings(null, null, null); [EOL] Type type = getClass().getDeclaredField("listOfString").getGenericType(); [EOL] JavaType result = _constructType(type, context); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof SimpleType); [EOL] }
public void testConstructTypeWithJavaType() { [EOL] TypeBindings context = new TypeBindings(null, null, null); [EOL] JavaType javaType = new SimpleType(String.class); [EOL] JavaType result = _constructType(javaType, context); [EOL] assertSame(javaType, result); [EOL] }
public void testConstructTypeWithGenericArrayType() throws NoSuchFieldException { [EOL] TypeBindings context = new TypeBindings(null, null, null); [EOL] Type type = getClass().getDeclaredField("arrayOfListOfString").getGenericType(); [EOL] JavaType result = _constructType(type, context); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ArrayType); [EOL] }
public void testConstructTypeWithTypeVariable() throws NoSuchFieldException { [EOL] TypeBindings context = new TypeBindings(null, null, null); [EOL] TypeVariable<?> typeVariable = getClass().getTypeParameters()[0]; [EOL] JavaType result = _constructType(typeVariable, context); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof TypeBase); [EOL] }
public void testConstructTypeWithWildcardType() throws NoSuchFieldException { [EOL] TypeBindings context = new TypeBindings(null, null, null); [EOL] Field field = getClass().getDeclaredField("wildcardType"); [EOL] WildcardType wildcardType = (WildcardType) field.getGenericType(); [EOL] JavaType result = _constructType(wildcardType, context); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof TypeBase); [EOL] }
public void testConstructTypeWithUnrecognizedType() { [EOL] TypeBindings context = new TypeBindings(null, null, null); [EOL] Type type = new Type() {}; [EOL] try { [EOL] _constructType(type, context); [EOL] fail("IllegalArgumentException expected"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Unrecognized Type: " + type.toString(), e.getMessage()); [EOL] } [EOL] }
public void testConstructMapTypeWithValidClasses() { [EOL] Class<? extends Map> mapClass = HashMap.class; [EOL] Class<?> keyClass = String.class; [EOL] Class<?> valueClass = Integer.class; [EOL] MapType mapType = constructMapType(mapClass, keyClass, valueClass); [EOL] assertNotNull(mapType); [EOL] assertEquals(mapClass, mapType.getRawClass()); [EOL] assertEquals(keyClass, mapType.getKeyType().getRawClass()); [EOL] assertEquals(valueClass, mapType.getContentType().getRawClass()); [EOL] }
public void testConstructMapTypeWithNullMapClass() { [EOL] Class<?> keyClass = String.class; [EOL] Class<?> valueClass = Integer.class; [EOL] try { [EOL] constructMapType(null, keyClass, valueClass); [EOL] fail("IllegalArgumentException expected for null mapClass"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConstructMapTypeWithNullKeyClass() { [EOL] Class<? extends Map> mapClass = HashMap.class; [EOL] Class<?> valueClass = Integer.class; [EOL] try { [EOL] constructMapType(mapClass, null, valueClass); [EOL] fail("IllegalArgumentException expected for null keyClass"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConstructMapTypeWithNullValueClass() { [EOL] Class<? extends Map> mapClass = HashMap.class; [EOL] Class<?> keyClass = String.class; [EOL] try { [EOL] constructMapType(mapClass, keyClass, null); [EOL] fail("IllegalArgumentException expected for null valueClass"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConstructRawCollectionTypeWithArrayList() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] CollectionType type = mapper.getTypeFactory().constructRawCollectionType(ArrayList.class); [EOL] assertNotNull(type); [EOL] assertTrue(type.isCollectionLikeType()); [EOL] assertEquals(ArrayList.class, type.getRawClass()); [EOL] }
public void testConstructRawCollectionTypeWithHashSet() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] CollectionType type = mapper.getTypeFactory().constructRawCollectionType(HashSet.class); [EOL] assertNotNull(type); [EOL] assertTrue(type.isCollectionLikeType()); [EOL] assertEquals(HashSet.class, type.getRawClass()); [EOL] }
public void testConstructRawCollectionLikeTypeWithValidClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Class<?> collectionClass = List.class; [EOL] JavaType type = mapper.getTypeFactory().constructRawCollectionLikeType(collectionClass); [EOL] assertNotNull(type); [EOL] assertTrue(type instanceof CollectionLikeType); [EOL] assertEquals(collectionClass, type.getRawClass()); [EOL] }
public void testConstructRawCollectionLikeTypeWithNullClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] JavaType type = mapper.getTypeFactory().constructRawCollectionLikeType(null); [EOL] fail("Expected IllegalArgumentException not thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void test_fromClassWithStringClass() { [EOL] JavaType result = _fromClass(String.class, null); [EOL] assertSame(CORE_TYPE_STRING, result); [EOL] }
public void test_fromClassWithBooleanType() { [EOL] JavaType result = _fromClass(Boolean.TYPE, null); [EOL] assertSame(CORE_TYPE_BOOL, result); [EOL] }
public void test_fromClassWithIntegerType() { [EOL] JavaType result = _fromClass(Integer.TYPE, null); [EOL] assertSame(CORE_TYPE_INT, result); [EOL] }
public void test_fromClassWithLongType() { [EOL] JavaType result = _fromClass(Long.TYPE, null); [EOL] assertSame(CORE_TYPE_LONG, result); [EOL] }
public void test_fromClassWithArrayType() { [EOL] JavaType result = _fromClass(new int[]{}.getClass(), null); [EOL] assertTrue(result instanceof ArrayType); [EOL] }
public void test_fromClassWithEnumType() { [EOL] JavaType result = _fromClass(TestEnum.class, null); [EOL] assertTrue(result instanceof SimpleType); [EOL] }
public void test_fromClassWithMapType() { [EOL] JavaType result = _fromClass(TestMap.class, null); [EOL] assertTrue(result instanceof MapType); [EOL] }
public void test_fromClassWithCollectionType() { [EOL] JavaType result = _fromClass(TestCollection.class, null); [EOL] assertTrue(result instanceof CollectionType); [EOL] }
public void test_fromClassWithSimpleType() { [EOL] JavaType result = _fromClass(TestSimple.class, null); [EOL] assertTrue(result instanceof SimpleType); [EOL] }
public void test_fromClassWithCachedType() { [EOL] ClassKey key = new ClassKey(TestSimple.class); [EOL] SimpleType cachedType = new SimpleType(TestSimple.class); [EOL] synchronized (_typeCache) { [EOL] _typeCache.put(key, cachedType); [EOL] } [EOL] JavaType result = _fromClass(TestSimple.class, null); [EOL] assertSame(cachedType, result); [EOL] }
public void testFromArrayParameterizedClass() { [EOL] Class<?> clz = String[].class; [EOL] List<JavaType> paramTypes = new ArrayList<>(); [EOL] JavaType result = _fromParameterizedClass(clz, paramTypes); [EOL] assertTrue(result instanceof ArrayType); [EOL] }
public void testFromEnumParameterizedClass() { [EOL] Class<?> clz = Enum.class; [EOL] List<JavaType> paramTypes = new ArrayList<>(); [EOL] JavaType result = _fromParameterizedClass(clz, paramTypes); [EOL] assertTrue(result instanceof SimpleType); [EOL] }
public void testFromMapParameterizedClassWithParams() { [EOL] Class<?> clz = Map.class; [EOL] List<JavaType> paramTypes = new ArrayList<>(); [EOL] paramTypes.add(new SimpleType(String.class)); [EOL] paramTypes.add(new SimpleType(Integer.class)); [EOL] JavaType result = _fromParameterizedClass(clz, paramTypes); [EOL] assertTrue(result instanceof MapType); [EOL] }
public void testFromMapParameterizedClassWithoutParams() { [EOL] Class<?> clz = Map.class; [EOL] List<JavaType> paramTypes = new ArrayList<>(); [EOL] JavaType result = _fromParameterizedClass(clz, paramTypes); [EOL] assertTrue(result instanceof MapType); [EOL] }
public void testFromCollectionParameterizedClassWithParam() { [EOL] Class<?> clz = Collection.class; [EOL] List<JavaType> paramTypes = new ArrayList<>(); [EOL] paramTypes.add(new SimpleType(String.class)); [EOL] JavaType result = _fromParameterizedClass(clz, paramTypes); [EOL] assertTrue(result instanceof CollectionType); [EOL] }
public void testFromCollectionParameterizedClassWithoutParam() { [EOL] Class<?> clz = Collection.class; [EOL] List<JavaType> paramTypes = new ArrayList<>(); [EOL] JavaType result = _fromParameterizedClass(clz, paramTypes); [EOL] assertTrue(result instanceof CollectionType); [EOL] }
public void testFromSimpleParameterizedClassWithoutParams() { [EOL] Class<?> clz = String.class; [EOL] List<JavaType> paramTypes = new ArrayList<>(); [EOL] JavaType result = _fromParameterizedClass(clz, paramTypes); [EOL] assertTrue(result instanceof SimpleType); [EOL] }
public void testFromSimpleParameterizedClassWithParams() { [EOL] Class<?> clz = String.class; [EOL] List<JavaType> paramTypes = new ArrayList<>(); [EOL] paramTypes.add(new SimpleType(String.class)); [EOL] JavaType result = _fromParameterizedClass(clz, paramTypes); [EOL] assertTrue(result instanceof SimpleType); [EOL] }
public void testFromVariableWithContextNull() { [EOL] TypeVariable<?> type = mock(TypeVariable.class); [EOL] JavaType result = _fromVariable(type, null); [EOL] assertNotNull(result); [EOL] }
public void testFromVariableWithActualTypeFound() { [EOL] TypeVariable<?> type = mock(TypeVariable.class); [EOL] when(type.getName()).thenReturn("T"); [EOL] TypeBindings context = mock(TypeBindings.class); [EOL] JavaType expectedType = mock(JavaType.class); [EOL] when(context.findType("T")).thenReturn(expectedType); [EOL] JavaType result = _fromVariable(type, context); [EOL] assertSame(expectedType, result); [EOL] }
public void testFromVariableWithActualTypeNotFound() { [EOL] TypeVariable<?> type = mock(TypeVariable.class); [EOL] when(type.getName()).thenReturn("T"); [EOL] TypeBindings context = mock(TypeBindings.class); [EOL] when(context.findType("T")).thenReturn(null); [EOL] Type[] bounds = new Type[] { mock(Type.class) }; [EOL] when(type.getBounds()).thenReturn(bounds); [EOL] doNothing().when(context)._addPlaceholder(anyString()); [EOL] JavaType expectedType = mock(JavaType.class); [EOL] when(_constructType(bounds[0], context)).thenReturn(expectedType); [EOL] JavaType result = _fromVariable(type, context); [EOL] assertSame(expectedType, result); [EOL] }
protected JavaType _fromWildcard(WildcardType type, TypeBindings context) { [EOL] return _constructType(type.getUpperBounds()[0], context); [EOL] }
public void testMapTypeWithNullTypeParameters() { [EOL] JavaType unknownType = _unknownType(); [EOL] Class<?> rawClass = HashMap.class; [EOL] when(findTypeParameters(rawClass, Map.class)).thenReturn(null); [EOL] JavaType result = _mapType(rawClass); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MapType); [EOL] assertEquals(unknownType, ((MapType) result).getKeyType()); [EOL] assertEquals(unknownType, ((MapType) result).getContentType()); [EOL] }
public void testMapTypeWithInvalidTypeParametersLength() { [EOL] Class<?> rawClass = HashMap.class; [EOL] JavaType[] typeParams = new JavaType[]{_unknownType()}; [EOL] when(findTypeParameters(rawClass, Map.class)).thenReturn(typeParams); [EOL] try { [EOL] _mapType(rawClass); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Strange Map type " + rawClass.getName() + ": can not determine type parameters", e.getMessage()); [EOL] } [EOL] }
public void testMapTypeWithValidTypeParameters() { [EOL] Class<?> rawClass = HashMap.class; [EOL] JavaType keyType = _unknownType(); [EOL] JavaType valueType = _unknownType(); [EOL] JavaType[] typeParams = new JavaType[]{keyType, valueType}; [EOL] when(findTypeParameters(rawClass, Map.class)).thenReturn(typeParams); [EOL] JavaType result = _mapType(rawClass); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MapType); [EOL] assertEquals(keyType, ((MapType) result).getKeyType()); [EOL] assertEquals(valueType, ((MapType) result).getContentType()); [EOL] }
public void testCollectionTypeWithNoTypeParameters() { [EOL] JavaType result = _collectionType(ArrayList.class); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof CollectionType); [EOL] assertEquals(ArrayList.class, result.getRawClass()); [EOL] assertTrue("Expected unknown type", checkUnknownTypeCondition(result.getContentType())); [EOL] }
public void testCollectionTypeWithOneTypeParameter() { [EOL] JavaType result = _collectionType(List.class); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof CollectionType); [EOL] assertEquals(List.class, result.getRawClass()); [EOL] assertEquals(String.class, result.getContentType().getRawClass()); [EOL] }
public void testCollectionTypeWithInvalidTypeParameters() { [EOL] try { [EOL] _collectionType(CustomMultiTypeCollection.class); [EOL] fail("Expected IllegalArgumentException for collection with multiple type parameters"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
protected HierarchicType _findSuperTypeChain(Class<?> subtype, Class<?> supertype) { [EOL] if (supertype.isInterface()) { [EOL] return _findSuperInterfaceChain(subtype, supertype); [EOL] } [EOL] return _findSuperClassChain(subtype, supertype); [EOL] }
protected HierarchicType _findSuperInterfaceChain(Type currentType, Class<?> target) { [EOL] HierarchicType current = new HierarchicType(currentType); [EOL] Class<?> raw = current.getRawClass(); [EOL] if (raw == target) { [EOL] return new HierarchicType(currentType); [EOL] } [EOL] if (raw == HashMap.class) { [EOL] if (target == Map.class) { [EOL] return _hashMapSuperInterfaceChain(current); [EOL] } [EOL] } [EOL] if (raw == ArrayList.class) { [EOL] if (target == List.class) { [EOL] return _arrayListSuperInterfaceChain(current); [EOL] } [EOL] } [EOL] return _doFindSuperInterfaceChain(current, target); [EOL] }
protected HierarchicType _doFindSuperInterfaceChain(HierarchicType current, Class<?> target) { [EOL] Class<?> raw = current.getRawClass(); [EOL] Type[] parents = raw.getGenericInterfaces(); [EOL] if (parents != null) { [EOL] for (Type parent : parents) { [EOL] HierarchicType sup = _findSuperInterfaceChain(parent, target); [EOL] if (sup != null) { [EOL] sup.setSubType(current); [EOL] current.setSuperType(sup); [EOL] return current; [EOL] } [EOL] } [EOL] } [EOL] Type parent = raw.getGenericSuperclass(); [EOL] if (parent != null) { [EOL] HierarchicType sup = _findSuperInterfaceChain(parent, target); [EOL] if (sup != null) { [EOL] sup.setSubType(current); [EOL] current.setSuperType(sup); [EOL] return current; [EOL] } [EOL] } [EOL] return null; [EOL] }
public void testHashMapSuperInterfaceChainWithNullCache() { [EOL] HierarchicType current = new HierarchicType(Map.class); [EOL] HierarchicType result = _hashMapSuperInterfaceChain(current); [EOL] assertNotNull(result); [EOL] assertNotNull(result.getSuperType()); [EOL] assertEquals(Map.class, result.getSuperType().getRawClass()); [EOL] }
public void testHashMapSuperInterfaceChainWithCachedType() { [EOL] HierarchicType current = new HierarchicType(Map.class); [EOL] HierarchicType cachedType = new HierarchicType(HashMap.class); [EOL] _cachedHashMapType = cachedType; [EOL] HierarchicType result = _hashMapSuperInterfaceChain(current); [EOL] assertNotNull(result); [EOL] assertSame(cachedType, result.getSuperType()); [EOL] assertNotSame(current, result.getSuperType().getSubType()); [EOL] assertEquals(Map.class, result.getSuperType().getRawClass()); [EOL] }
public void testDeserializeTypedFromAnyWithStartArrayToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] AsArrayDeserializer deserializer = new AsArrayDeserializer(); [EOL] Object result = deserializer.deserializeTypedFromAny(jp, ctxt); [EOL] verify(jp).getCurrentToken(); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeTypedFromAnyWithNonStartArrayToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); // Any token other than START_ARRAY [EOL] AsArrayDeserializer deserializer = new AsArrayDeserializer(); [EOL] Object result = deserializer.deserializeTypedFromAny(jp, ctxt); [EOL] verify(jp).getCurrentToken(); [EOL] assertNotNull(result); [EOL] }
public void testMapperConfigBaseCopyConstructor() { [EOL] ConcreteMapperConfigBase src = new ConcreteMapperConfigBase(); [EOL] src._mixInAnnotations = new HashMap<Class<?>, Class<?>>(); // Assuming these are the correct types [EOL] src._subtypeResolver = new SubtypeResolver(); // Assuming this is a valid subtype resolver [EOL] src._rootName = "rootName"; // Assuming _rootName is a String [EOL] src._view = Object.class; // Assuming _view is a Class<?> type [EOL] ConcreteMapperConfigBase copied = new ConcreteMapperConfigBase(src); [EOL] assertEquals(src._mixInAnnotations, copied._mixInAnnotations, "MixInAnnotations should be copied"); [EOL] assertEquals(src._subtypeResolver, copied._subtypeResolver, "SubtypeResolver should be copied"); [EOL] assertEquals(src._rootName, copied._rootName, "RootName should be copied"); [EOL] assertEquals(src._view, copied._view, "View should be copied"); [EOL] }
public void testCopyCurrentEventWithStartObject() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeStartObject(); [EOL] }
public void testCopyCurrentEventWithEndObject() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_OBJECT); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeEndObject(); [EOL] }
public void testCopyCurrentEventWithStartArray() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeStartArray(); [EOL] }
public void testCopyCurrentEventWithEndArray() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_ARRAY); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeEndArray(); [EOL] }
public void testCopyCurrentEventWithFieldName() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(jp.getCurrentName()).thenReturn("fieldName"); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeFieldName("fieldName"); [EOL] }
public void testCopyCurrentEventWithValueStringUsingTextCharacters() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.hasTextCharacters()).thenReturn(true); [EOL] when(jp.getTextCharacters()).thenReturn(new char[]{'t', 'e', 'x', 't'}); [EOL] when(jp.getTextOffset()).thenReturn(0); [EOL] when(jp.getTextLength()).thenReturn(4); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeString(new char[]{'t', 'e', 'x', 't'}, 0, 4); [EOL] }
public void testCopyCurrentEventWithValueStringWithoutTextCharacters() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.hasTextCharacters()).thenReturn(false); [EOL] when(jp.getText()).thenReturn("text"); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeString("text"); [EOL] }
public void testCopyCurrentEventWithValueNumberIntWithInt() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.INT); [EOL] when(jp.getIntValue()).thenReturn(123); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeNumber(123); [EOL] }
public void testCopyCurrentEventWithValueNumberIntWithBigInteger() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.BIG_INTEGER); [EOL] when(jp.getBigIntegerValue()).thenReturn(new BigInteger("12345678901234567890")); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeNumber(new BigInteger("12345678901234567890")); [EOL] }
public void testCopyCurrentEventWithValueNumberIntWithLong() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.LONG); [EOL] when(jp.getLongValue()).thenReturn(1234567890123456789L); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeNumber(1234567890123456789L); [EOL] }
public void testCopyCurrentEventWithValueNumberFloatWithBigDecimal() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.BIG_DECIMAL); [EOL] when(jp.getDecimalValue()).thenReturn(new BigDecimal("123.456")); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeNumber(new BigDecimal("123.456")); [EOL] }
public void testCopyCurrentEventWithValueNumberFloatWithFloat() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.FLOAT); [EOL] when(jp.getFloatValue()).thenReturn(123.456f); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeNumber(123.456f); [EOL] }
public void testCopyCurrentEventWithValueNumberFloatWithDouble() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.DOUBLE); [EOL] when(jp.getDoubleValue()).thenReturn(123.456d); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeNumber(123.456d); [EOL] }
public void testCopyCurrentEventWithValueTrue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeBoolean(true); [EOL] }
public void testCopyCurrentEventWithValueFalse() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeBoolean(false); [EOL] }
public void testCopyCurrentEventWithValueNull() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeNull(); [EOL] }
public void testCopyCurrentEventWithValueEmbeddedObject() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] Object embeddedObject = new Object(); [EOL] when(jp.getEmbeddedObject()).thenReturn(embeddedObject); [EOL] copyCurrentEvent(jp); [EOL] verify(this).writeObject(embeddedObject); [EOL] }
public void testCopyCurrentEventWithUnexpectedToken() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(null); [EOL] assertThrows(RuntimeException.class, () -> copyCurrentEvent(jp)); [EOL] }
public void testHasTextCharacters() { [EOL] JsonParser jp = new MyJsonParser(); [EOL] assertFalse(jp.hasTextCharacters()); [EOL] }
public void testIsConcreteWithNonConcreteClass() { [EOL] _class = NonConcreteClass.class; // Replace NonConcreteClass with an actual non-concrete class [EOL] boolean result = isConcrete(); [EOL] assertFalse(result); [EOL] }
public void testIsConcreteWithConcreteClass() { [EOL] _class = ConcreteClass.class; // Replace ConcreteClass with an actual concrete class [EOL] boolean result = isConcrete(); [EOL] assertTrue(result); [EOL] }
public void testIsConcreteWithPrimitiveType() { [EOL] _class = int.class; // Example with a primitive type [EOL] boolean result = isConcrete(); [EOL] assertTrue(result); [EOL] }
public void testIsCollectionLikeType() { [EOL] MyType instance = new MyType(); [EOL] boolean result = instance.isCollectionLikeType(); [EOL] assertFalse("The method should return false", result); [EOL] }
public void testIsMapLikeType() { [EOL] MyNonMapLikeType type = new MyNonMapLikeType(); [EOL] assertFalse(type.isMapLikeType()); [EOL] }
public void testHasGenericTypes_WithNoContainedTypes() { [EOL] when(instance.containedTypeCount()).thenReturn(0); [EOL] boolean result = instance.hasGenericTypes(); [EOL] assertFalse(result); [EOL] }
public void testHasGenericTypes_WithContainedTypes() { [EOL] when(instance.containedTypeCount()).thenReturn(1); [EOL] boolean result = instance.hasGenericTypes(); [EOL] assertTrue(result); [EOL] }
public void testGetKeyTypeReturnsNull() { [EOL] ExampleClass example = new ExampleClass(); [EOL] JavaType result = example.getKeyType(); [EOL] assertNull(result); [EOL] }
public void testSerializeWithTimestamp() throws IOException { [EOL] Date value = new Date(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] DateSerializer serializer = new DateSerializer(true, null); [EOL] serializer.serialize(value, jgen, provider); [EOL] verify(jgen).writeNumber(anyLong()); [EOL] }
public void testSerializeWithCustomFormat() throws IOException { [EOL] Date value = new Date(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] DateFormat customFormat = new SimpleDateFormat("yyyy-MM-dd"); [EOL] DateSerializer serializer = new DateSerializer(false, customFormat); [EOL] serializer.serialize(value, jgen, provider); [EOL] verify(jgen).writeString(anyString()); [EOL] }
public void testSerializeWithDefault() throws IOException { [EOL] Date value = new Date(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] DateSerializer serializer = new DateSerializer(false, null); [EOL] serializer.serialize(value, jgen, provider); [EOL] verify(provider).defaultSerializeDateValue(value, jgen); [EOL] }
public void testHasContentTypeAnnotationWithNullProperty() { [EOL] SerializerProvider provider = createMockSerializerProvider(); [EOL] boolean result = hasContentTypeAnnotation(provider, null); [EOL] assertFalse(result); [EOL] }
public void testHasContentTypeAnnotationWithNonNullPropertyAndNullIntrospector() { [EOL] SerializerProvider provider = createMockSerializerProviderWithNullIntrospector(); [EOL] BeanProperty property = createMockBeanProperty(); [EOL] boolean result = hasContentTypeAnnotation(provider, property); [EOL] assertFalse(result); [EOL] }
public void testHasContentTypeAnnotationWithNonNullPropertyAndNonNullIntrospectorButNoAnnotation() { [EOL] SerializerProvider provider = createMockSerializerProviderWithNonNullIntrospector(); [EOL] BeanProperty property = createMockBeanPropertyWithMemberAndType(); [EOL] boolean result = hasContentTypeAnnotation(provider, property); [EOL] assertFalse(result); [EOL] }
public void testHasContentTypeAnnotationWithNonNullPropertyAndNonNullIntrospectorWithAnnotation() { [EOL] SerializerProvider provider = createMockSerializerProviderWithNonNullIntrospectorAndAnnotation(); [EOL] BeanProperty property = createMockBeanPropertyWithMemberAndType(); [EOL] boolean result = hasContentTypeAnnotation(provider, property); [EOL] assertTrue(result); [EOL] }
public void testBuildTypeDeserializerWithUseForTypeTrue() { [EOL] DeserializationConfig config = createDeserializationConfigMock(); [EOL] JavaType baseType = createJavaTypeMock(); [EOL] Collection<NamedType> subtypes = createSubtypesCollection(); [EOL] when(useForType(baseType)).thenReturn(true); [EOL] TypeDeserializer result = buildTypeDeserializer(config, baseType, subtypes); [EOL] assertNotNull(result); [EOL] }
public void testBuildTypeDeserializerWithUseForTypeFalse() { [EOL] DeserializationConfig config = createDeserializationConfigMock(); [EOL] JavaType baseType = createJavaTypeMock(); [EOL] Collection<NamedType> subtypes = createSubtypesCollection(); [EOL] when(useForType(baseType)).thenReturn(false); [EOL] TypeDeserializer result = buildTypeDeserializer(config, baseType, subtypes); [EOL] assertNull(result); [EOL] }
public void testUseForTypeWithNonConcreteAndArrays() { [EOL] JavaType arrayType = createArrayType(); // This method should return a JavaType representing an array [EOL] boolean result = useForType(arrayType); [EOL] assertTrue(result); [EOL] } [EOL] public void testUseForTypeWithObjectAndNonConcrete() { [EOL] JavaType objectType = createJavaType(Object.class); // This method should return a JavaType representing Object.class [EOL] boolean result = useForType(objectType); [EOL] assertTrue(result); [EOL] JavaType nonConcreteType = createNonConcreteType(); // This method should return a non-concrete JavaType [EOL] result = useForType(nonConcreteType); [EOL] assertTrue(result); [EOL] } [EOL] public void testUseForTypeWithNonFinal() { [EOL] JavaType nonFinalType = createNonFinalType(); // This method should return a non-final JavaType [EOL] boolean result = useForType(nonFinalType); [EOL] assertTrue(result); [EOL] } [EOL] public void testUseForTypeWithDefaultCase() { [EOL] JavaType defaultType = createJavaType(String.class); // This method should return a JavaType representing any class other than Object [EOL] boolean result = useForType(defaultType); [EOL] assertFalse(result); [EOL] }
public ObjectMapper registerModule(Module module) { [EOL] String name = module.getModuleName(); [EOL] if (name == null) { [EOL] throw new IllegalArgumentException("Module without defined name"); [EOL] } [EOL] Version version = module.version(); [EOL] if (version == null) { [EOL] throw new IllegalArgumentException("Module without defined version"); [EOL] } [EOL] final ObjectMapper mapper = this; [EOL] module.setupModule(new Module.SetupContext() { [EOL] @Override [EOL] public Version getMapperVersion() { [EOL] return version(); [EOL] } [EOL] @SuppressWarnings("unchecked") [EOL] @Override [EOL] public <C extends ObjectCodec> C getOwner() { [EOL] return (C) mapper; [EOL] } [EOL] @Override [EOL] public TypeFactory getTypeFactory() { [EOL] return _typeFactory; [EOL] } [EOL] @Override [EOL] public boolean isEnabled(MapperFeature f) { [EOL] return mapper.isEnabled(f); [EOL] } [EOL] @Override [EOL] public boolean isEnabled(DeserializationFeature f) { [EOL] return mapper.isEnabled(f); [EOL] } [EOL] @Override [EOL] public boolean isEnabled(SerializationFeature f) { [EOL] return mapper.isEnabled(f); [EOL] } [EOL] @Override [EOL] public boolean isEnabled(JsonFactory.Feature f) { [EOL] return mapper.isEnabled(f); [EOL] } [EOL] @Override [EOL] public boolean isEnabled(JsonParser.Feature f) { [EOL] return mapper.isEnabled(f); [EOL] } [EOL] @Override [EOL] public boolean isEnabled(JsonGenerator.Feature f) { [EOL] return mapper.isEnabled(f); [EOL] } [EOL] @Override [EOL] public void addDeserializers(Deserializers d) { [EOL] DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d); [EOL] mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL] } [EOL] @Override [EOL] public void addKeyDeserializers(KeyDeserializers d) { [EOL] DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d); [EOL] mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL] } [EOL] @Override [EOL] public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) { [EOL] DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier); [EOL] mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL] } [EOL] @Override [EOL] public void addSerializers(Serializers s) { [EOL] mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s); [EOL] } [EOL] @Override [EOL] public void addKeySerializers(Serializers s) { [EOL] mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s); [EOL] } [EOL] @Override [EOL] public void addBeanSerializerModifier(BeanSerializerModifier modifier) { [EOL] mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier); [EOL] } [EOL] @Override [EOL] public void addAbstractTypeResolver(AbstractTypeResolver resolver) { [EOL] DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver); [EOL] mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL] } [EOL] @Override [EOL] public void addTypeModifier(TypeModifier modifier) { [EOL] TypeFactory f = mapper._typeFactory; [EOL] f = f.withModifier(modifier); [EOL] mapper.setTypeFactory(f); [EOL] } [EOL] @Override [EOL] public void addValueInstantiators(ValueInstantiators instantiators) { [EOL] DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators); [EOL] mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL] } [EOL] @Override [EOL] public void setClassIntrospector(ClassIntrospector ci) { [EOL] mapper._deserializationConfig = mapper._deserializationConfig.with(ci); [EOL] mapper._serializationConfig = mapper._serializationConfig.with(ci); [EOL] } [EOL] @Override [EOL] public void insertAnnotationIntrospector(AnnotationIntrospector ai) { [EOL] mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai); [EOL] mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai); [EOL] } [EOL] @Override [EOL] public void appendAnnotationIntrospector(AnnotationIntrospector ai) { [EOL] mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai); [EOL] mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai); [EOL] } [EOL] @Override [EOL] public void registerSubtypes(Class<?>... subtypes) { [EOL] mapper.registerSubtypes(subtypes); [EOL] } [EOL] @Override [EOL] public void registerSubtypes(NamedType... subtypes) { [EOL] mapper.registerSubtypes(subtypes); [EOL] } [EOL] @Override [EOL] public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) { [EOL] mapper.addMixInAnnotations(target, mixinSource); [EOL] } [EOL] @Override [EOL] public void addDeserializationProblemHandler(DeserializationProblemHandler handler) { [EOL] mapper.addHandler(handler); [EOL] } [EOL] }); [EOL] return this; [EOL] }
public void testSetSerializationInclusionNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonInclude.Include incl = JsonInclude.Include.ALWAYS; [EOL] ObjectMapper result = mapper.setSerializationInclusion(incl); [EOL] assertNotNull(result); [EOL] assertEquals(incl, result.getSerializationConfig().getSerializationInclusion()); [EOL] }
public void testSetSerializationInclusionNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectMapper result = mapper.setSerializationInclusion(null); [EOL] assertNotNull(result); [EOL] assertNull(result.getSerializationConfig().getSerializationInclusion()); [EOL] }
public void testEnableDefaultTyping() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectMapper result = mapper.enableDefaultTyping(); [EOL] assertNotNull(result); [EOL] assertTrue(result.isEnabled(MapperFeature.USE_BASE_TYPE_AS_DEFAULT_IMPL)); [EOL] }
public void testEnableDefaultTypingWithNonNullDefaultTyping() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DefaultTyping dti = DefaultTyping.NON_FINAL; [EOL] ObjectMapper resultMapper = mapper.enableDefaultTyping(dti); [EOL] assertNotNull(resultMapper); [EOL] assertNotSame(mapper, resultMapper); [EOL] }
public void testEnableDefaultTypingWithNullDefaultTyping() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DefaultTyping dti = null; [EOL] try { [EOL] mapper.enableDefaultTyping(dti); [EOL] fail("Should throw IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testEnableDefaultTypingWithNonNullValues() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DefaultTyping applicability = DefaultTyping.NON_FINAL; [EOL] JsonTypeInfo.As includeAs = JsonTypeInfo.As.WRAPPER_ARRAY; [EOL] ObjectMapper result = mapper.enableDefaultTyping(applicability, includeAs); [EOL] assertNotNull(result); [EOL] TypeResolverBuilder<?> typer = result.getTypeResolverBuilder(); [EOL] assertNotNull(typer); [EOL] assertEquals(DefaultTypeResolverBuilder.class, typer.getClass()); [EOL] assertEquals(JsonTypeInfo.Id.CLASS, typer.getIdType()); [EOL] assertEquals(includeAs, typer.getInclusion()); [EOL] }
public void testEnableDefaultTypingWithNullValues() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DefaultTyping applicability = null; [EOL] JsonTypeInfo.As includeAs = null; [EOL] ObjectMapper result = mapper.enableDefaultTyping(applicability, includeAs); [EOL] assertNotNull(result); [EOL] TypeResolverBuilder<?> typer = result.getTypeResolverBuilder(); [EOL] assertNotNull(typer); [EOL] assertEquals(DefaultTypeResolverBuilder.class, typer.getClass()); [EOL] assertEquals(JsonTypeInfo.Id.CLASS, typer.getIdType()); [EOL] assertEquals(JsonTypeInfo.As.WRAPPER_ARRAY, typer.getInclusion()); [EOL] }
public void testSetInjectableValuesWithNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] InjectableValues injectableValues = new InjectableValues.Std(); [EOL] ObjectMapper result = mapper.setInjectableValues(injectableValues); [EOL] assertNotNull(result); [EOL] assertSame(mapper, result); [EOL] assertSame(injectableValues, result.getInjectableValues()); [EOL] }
public void testSetInjectableValuesWithNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectMapper result = mapper.setInjectableValues(null); [EOL] assertNotNull(result); [EOL] assertSame(mapper, result); [EOL] assertNull(result.getInjectableValues()); [EOL] }
public void testReadValueWithValidInput() throws IOException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonParser jp = new JsonFactory().createParser("{\"name\":\"test\"}"); [EOL] jp.nextToken(); // to point to the first token [EOL] String result = mapper.readValue(jp, String.class); [EOL] assertEquals("Expecting the parsed value to match", "{\"name\":\"test\"}", result); [EOL] } [EOL] public void testReadValueWithInvalidInput() throws IOException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonParser jp = new JsonFactory().createParser("invalid json"); [EOL] try { [EOL] jp.nextToken(); // to point to the first token [EOL] mapper.readValue(jp, String.class); [EOL] fail("Expecting an exception to be thrown due to invalid JSON"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] } [EOL] public void testReadValueWithNullParser() throws IOException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.readValue((JsonParser) null, String.class); [EOL] fail("Expecting an exception to be thrown due to null JsonParser"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testReadValueWithNullClass() throws IOException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonParser jp = new JsonFactory().createParser("{\"name\":\"test\"}"); [EOL] jp.nextToken(); // to point to the first token [EOL] try { [EOL] mapper.readValue(jp, null); [EOL] fail("Expecting an exception to be thrown due to null Class"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testReadTreeWithNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(null); [EOL] when(jp.nextToken()).thenReturn(null); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TreeNode result = mapper.readTree(jp); [EOL] assertNull(result); [EOL] }
public void testReadTreeWithNonNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonNode expectedNode = JsonNodeFactory.instance.objectNode(); [EOL] when(jp.readValueAsTree()).thenReturn(expectedNode); [EOL] TreeNode result = mapper.readTree(jp); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof JsonNode); [EOL] assertEquals(expectedNode, result); [EOL] }
public void testReadTreeWithInitialNullThenNonNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(null); [EOL] when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonNode expectedNode = JsonNodeFactory.instance.objectNode(); [EOL] when(jp.readValueAsTree()).thenReturn(expectedNode); [EOL] TreeNode result = mapper.readTree(jp); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof JsonNode); [EOL] assertEquals(expectedNode, result); [EOL] }
public void testReadTreeReturnsNullNode() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TreeNode result = mapper.readTree(jp); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof JsonNode); [EOL] assertTrue(((JsonNode) result).isNull()); [EOL] }
public void testWriteValueWithIndentOutputEnabled() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(config.isEnabled(SerializationFeature.INDENT_OUTPUT)).thenReturn(true); [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper.setSerializationConfig(config); [EOL] objectMapper.writeValue(jgen, value); [EOL] verify(jgen).useDefaultPrettyPrinter(); [EOL] verify(config, never()).isEnabled(SerializationFeature.CLOSE_CLOSEABLE); [EOL] verify(config, never()).isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE); [EOL] }
public void testWriteValueWithCloseCloseableEnabled() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Closeable value = mock(Closeable.class); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE)).thenReturn(true); [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper.setSerializationConfig(config); [EOL] objectMapper.writeValue(jgen, value); [EOL] verify(jgen, never()).useDefaultPrettyPrinter(); [EOL] verify(config, never()).isEnabled(SerializationFeature.INDENT_OUTPUT); [EOL] verify(config, never()).isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE); [EOL] }
public void testWriteValueWithFlushAfterWriteValueEnabled() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)).thenReturn(true); [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper.setSerializationConfig(config); [EOL] objectMapper.writeValue(jgen, value); [EOL] verify(jgen, never()).useDefaultPrettyPrinter(); [EOL] verify(config, never()).isEnabled(SerializationFeature.CLOSE_CLOSEABLE); [EOL] verify(jgen).flush(); [EOL] }
public void testWriteValueWithNoFeaturesEnabled() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(config.isEnabled(any(SerializationFeature.class))).thenReturn(false); [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper.setSerializationConfig(config); [EOL] objectMapper.writeValue(jgen, value); [EOL] verify(jgen, never()).useDefaultPrettyPrinter(); [EOL] verify(config, never()).isEnabled(SerializationFeature.CLOSE_CLOSEABLE); [EOL] verify(jgen, never()).flush(); [EOL] }
public void testCreateArrayNode() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ArrayNode arrayNode = mapper.createArrayNode(); [EOL] assertNotNull(arrayNode); [EOL] assertTrue(arrayNode.isArray()); [EOL] }
public void testTreeAsTokensWithNonNullNode() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonNode node = mapper.createObjectNode(); [EOL] JsonParser parser = mapper.treeAsTokens(node); [EOL] assertNotNull(parser); [EOL] assertTrue(parser instanceof TreeTraversingParser); [EOL] } [EOL] public void testTreeAsTokensWithNullNode() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.treeAsTokens(null); [EOL] fail("treeAsTokens should throw an IllegalArgumentException when node is null"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testTreeToValueWithNonObjectClassAssignable() throws JsonProcessingException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TreeNode treeNode = new JsonNodeFactory(false).objectNode(); [EOL] treeNode = mapper.readTree("{\"key\":\"value\"}"); [EOL] String result = mapper.treeToValue(treeNode, String.class); [EOL] assertEquals("{\"key\":\"value\"}", result); [EOL] }
public void testTreeToValueWithObjectClass() throws JsonProcessingException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TreeNode treeNode = new JsonNodeFactory(false).objectNode(); [EOL] treeNode = mapper.readTree("{\"key\":\"value\"}"); [EOL] Object result = mapper.treeToValue(treeNode, Object.class); [EOL] assertTrue(result instanceof TreeNode); [EOL] }
public void testTreeToValueWithIOException() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TreeNode treeNode = new TreeNode() { [EOL] @Override [EOL] public JsonToken asToken() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public JsonParser.NumberType numberType() { [EOL] return null; [EOL] } [EOL] @Override [EOL] public int size() { [EOL] return 0; [EOL] } [EOL] @Override [EOL] public JsonParser traverse() throws IOException { [EOL] throw new IOException("Test IOException"); [EOL] } [EOL] @Override [EOL] public JsonParser traverse(ObjectCodec codec) throws IOException { [EOL] throw new IOException("Test IOException"); [EOL] } [EOL] }; [EOL] try { [EOL] mapper.treeToValue(treeNode, String.class); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Test IOException", e.getCause().getMessage()); [EOL] } catch (JsonProcessingException e) { [EOL] fail("Expected IllegalArgumentException, not JsonProcessingException"); [EOL] } [EOL] }
public void testReadValueWithValidInput() throws IOException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] byte[] jsonBytes = "{\"key\":\"value\"}".getBytes(); [EOL] Map<String, String> result = mapper.readValue(jsonBytes, Map.class); [EOL] assertNotNull(result); [EOL] assertEquals("value", result.get("key")); [EOL] }
public void testReadValueWithInvalidInput() throws IOException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] byte[] jsonBytes = "invalid json".getBytes(); [EOL] try { [EOL] mapper.readValue(jsonBytes, Map.class); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testReadValueWithNullInput() throws IOException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.readValue((byte[]) null, Map.class); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testReadValueWithNullType() throws IOException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] byte[] jsonBytes = "{\"key\":\"value\"}".getBytes(); [EOL] try { [EOL] mapper.readValue(jsonBytes, null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void writeValue_ShouldThrowIOException_WhenOutputStreamIsClosed() throws IOException { [EOL] OutputStream out = new ByteArrayOutputStream(); [EOL] out.close(); [EOL] Object value = new Object(); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] assertThrows(IOException.class, () -> mapper.writeValue(out, value)); [EOL] }
public void writeValue_ShouldSucceed_WhenOutputStreamIsValid() throws IOException { [EOL] OutputStream out = new ByteArrayOutputStream(); [EOL] Object value = new Object(); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.writeValue(out, value); [EOL] assertTrue(out.toString().length() > 0); [EOL] }
public void testWriteValueAsBytesWithValidInput() throws JsonProcessingException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String testValue = "Jackson"; [EOL] byte[] result = mapper.writeValueAsBytes(testValue); [EOL] assertNotNull(result); [EOL] assertTrue(result.length > 0); [EOL] } [EOL] public void testWriteValueAsBytesWithNullInput() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.writeValueAsBytes(null); [EOL] fail("Expected JsonProcessingException"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testWriteValueAsBytesWithJsonProcessingException() { [EOL] ObjectMapper mapper = new ObjectMapper() { [EOL] @Override [EOL] public byte[] writeValueAsBytes(Object value) throws JsonProcessingException { [EOL] throw new JsonProcessingException("Test exception") {}; [EOL] } [EOL] }; [EOL] try { [EOL] mapper.writeValueAsBytes(new Object()); [EOL] fail("Expected JsonProcessingException"); [EOL] } catch (JsonProcessingException e) { [EOL] assertEquals("Test exception", e.getMessage()); [EOL] } [EOL] }
public void testWriteValueAsBytesWithIOException() { [EOL] ObjectMapper mapper = new ObjectMapper() { [EOL] @Override [EOL] protected void _configAndWriteValue(JsonGenerator g, Object value) throws IOException { [EOL] throw new IOException("Test IO exception"); [EOL] } [EOL] }; [EOL] try { [EOL] mapper.writeValueAsBytes(new Object()); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] assertTrue(e.getCause() instanceof IOException); [EOL] assertEquals("Test IO exception", e.getCause().getMessage()); [EOL] } [EOL] }
public void testWriterWithEnabledFeature() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationFeature feature = SerializationFeature.INDENT_OUTPUT; [EOL] ObjectWriter writer = mapper.writer(feature); [EOL] assertTrue(writer.getSerializationConfig().isEnabled(feature)); [EOL] }
public void testWriterWithDisabledFeature() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationFeature feature = SerializationFeature.INDENT_OUTPUT; [EOL] mapper.disable(feature); [EOL] ObjectWriter writer = mapper.writer(feature); [EOL] assertTrue(writer.getSerializationConfig().isEnabled(feature)); [EOL] }
public void testWriterWithNullDateFormat() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectWriter writer = mapper.writer((DateFormat) null); [EOL] assertNotNull(writer); [EOL] }
public void testWriterWithSpecificDateFormat() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DateFormat df = new SimpleDateFormat("yyyy-MM-dd"); [EOL] ObjectWriter writer = mapper.writer(df); [EOL] assertNotNull(writer); [EOL] assertEquals(df, writer.getConfig().getDateFormat()); [EOL] }
public void testWriterWithDefaultPrettyPrinter() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectWriter writer = mapper.writerWithDefaultPrettyPrinter(); [EOL] assertNotNull(writer); [EOL] assertTrue(writer.hasPrettyPrinter()); [EOL] }
public void testConvertValueWithNullFromValue() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Object fromValue = null; [EOL] Class<String> toValueType = String.class; [EOL] String result = mapper.convertValue(fromValue, toValueType); [EOL] assertNull(result); [EOL] }
public void testConvertValueWithNonNullFromValue() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String fromValue = "test"; [EOL] Class<String> toValueType = String.class; [EOL] String result = mapper.convertValue(fromValue, toValueType); [EOL] assertNotNull(result); [EOL] assertEquals("test", result); [EOL] }
public void test_convert_withAssignableTargetType() { [EOL] Object fromValue = "testString"; [EOL] JavaType toValueType = TypeFactory.defaultInstance().constructType(String.class); [EOL] Object result = _convert(fromValue, toValueType); [EOL] assertEquals("The returned object should be the same as the fromValue", fromValue, result); [EOL] }
public void test_convert_withNonAssignableTargetType() { [EOL] Object fromValue = "testString"; [EOL] JavaType toValueType = TypeFactory.defaultInstance().constructType(Integer.class); [EOL] try { [EOL] Object result = _convert(fromValue, toValueType); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void test_convert_withNullValue() throws IOException { [EOL] Object fromValue = null; [EOL] JavaType toValueType = TypeFactory.defaultInstance().constructType(Object.class); [EOL] TokenBuffer buf = new TokenBuffer(null); [EOL] buf.writeNull(); [EOL] JsonParser jp = buf.asParser(); [EOL] when(this._initForReading(jp)).thenReturn(JsonToken.VALUE_NULL); [EOL] Object result = _convert(fromValue, toValueType); [EOL] assertNull("The result should be null for a null value input", result); [EOL] jp.close(); [EOL] }
public void test_convert_withEndArrayToken() throws IOException { [EOL] Object fromValue = new ArrayList<>(); [EOL] JavaType toValueType = TypeFactory.defaultInstance().constructType(List.class); [EOL] TokenBuffer buf = new TokenBuffer(null); [EOL] buf.writeEndArray(); [EOL] JsonParser jp = buf.asParser(); [EOL] when(this._initForReading(jp)).thenReturn(JsonToken.END_ARRAY); [EOL] Object result = _convert(fromValue, toValueType); [EOL] assertNull("The result should be null for an END_ARRAY token", result); [EOL] jp.close(); [EOL] }
public void test_convert_withEndObjectToken() throws IOException { [EOL] Object fromValue = new HashMap<>(); [EOL] JavaType toValueType = TypeFactory.defaultInstance().constructType(Map.class); [EOL] TokenBuffer buf = new TokenBuffer(null); [EOL] buf.writeEndObject(); [EOL] JsonParser jp = buf.asParser(); [EOL] when(this._initForReading(jp)).thenReturn(JsonToken.END_OBJECT); [EOL] Object result = _convert(fromValue, toValueType); [EOL] assertNull("The result should be null for an END_OBJECT token", result); [EOL] jp.close(); [EOL] }
public void test_convert_withIOException() throws IOException { [EOL] Object fromValue = "testString"; [EOL] JavaType toValueType = TypeFactory.defaultInstance().constructType(Object.class); [EOL] TokenBuffer buf = new TokenBuffer(null); [EOL] buf.writeStartObject(); [EOL] JsonParser jp = buf.asParser(); [EOL] when(this._initForReading(jp)).thenThrow(new IOException("Test IOException")); [EOL] try { [EOL] _convert(fromValue, toValueType); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The cause of the IllegalArgumentException should be an IOException", IOException.class, e.getCause().getClass()); [EOL] assertEquals("Test IOException", e.getCause().getMessage()); [EOL] } [EOL] jp.close(); [EOL] }
public void testGenerateJsonSchemaWithValidClass() throws JsonMappingException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonSchema schema = mapper.generateJsonSchema(SomeValidClass.class); [EOL] assertNotNull(schema); [EOL] assertTrue(schema.isObjectSchema()); [EOL] ObjectSchema objectSchema = schema.asObjectSchema(); [EOL] assertNotNull(objectSchema.getProperties()); [EOL] assertFalse(objectSchema.getProperties().isEmpty()); [EOL] }
public void testGenerateJsonSchemaWithInvalidClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.generateJsonSchema(SomeInvalidClass.class); [EOL] fail("Expected JsonMappingException was not thrown"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testGenerateJsonSchemaWithNullClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.generateJsonSchema(null); [EOL] fail("Expected IllegalArgumentException was not thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
protected PrettyPrinter _defaultPrettyPrinter() { [EOL] return _defaultPrettyPrinter; [EOL] }
public void testConfigAndWriteValue_IndentOutputEnabled() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] SerializationConfig cfg = mock(SerializationConfig.class); [EOL] when(cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)).thenReturn(true); [EOL] _configAndWriteValue(jgen, value); [EOL] verify(jgen).useDefaultPrettyPrinter(); [EOL] verify(cfg, never()).isEnabled(SerializationFeature.CLOSE_CLOSEABLE); [EOL] }
public void testConfigAndWriteValue_CloseCloseableEnabled() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Closeable value = mock(Closeable.class); [EOL] SerializationConfig cfg = mock(SerializationConfig.class); [EOL] when(cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE)).thenReturn(true); [EOL] _configAndWriteValue(jgen, value); [EOL] verify(jgen, never()).useDefaultPrettyPrinter(); [EOL] verify(value).close(); [EOL] }
public void testConfigAndWriteValue_NoFeaturesEnabled() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] SerializationConfig cfg = mock(SerializationConfig.class); [EOL] when(cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)).thenReturn(false); [EOL] when(cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE)).thenReturn(false); [EOL] _configAndWriteValue(jgen, value); [EOL] verify(jgen, never()).useDefaultPrettyPrinter(); [EOL] verify(jgen).close(); [EOL] }
public void testConfigAndWriteValue_ExceptionThrown() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] SerializationConfig cfg = mock(SerializationConfig.class); [EOL] when(cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)).thenReturn(false); [EOL] when(cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE)).thenReturn(false); [EOL] doThrow(new IOException()).when(jgen).close(); [EOL] try { [EOL] _configAndWriteValue(jgen, value); [EOL] } catch (IOException e) { [EOL] } [EOL] verify(jgen, never()).useDefaultPrettyPrinter(); [EOL] verify(jgen).close(); [EOL] }
public void testConfigAndWriteCloseableWithNonNullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] Object mockValue = mock(Closeable.class); [EOL] SerializationConfig mockConfig = mock(SerializationConfig.class); [EOL] _configAndWriteCloseable(mockJsonGenerator, mockValue, mockConfig); [EOL] verify(mockValue).close(); [EOL] verify(mockJsonGenerator).close(); [EOL] }
public void testConfigAndWriteCloseableWithJsonGeneratorException() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] Object mockValue = mock(Closeable.class); [EOL] SerializationConfig mockConfig = mock(SerializationConfig.class); [EOL] doThrow(new JsonGenerationException("")).when(mockJsonGenerator).close(); [EOL] _configAndWriteCloseable(mockJsonGenerator, mockValue, mockConfig); [EOL] verify(mockValue).close(); [EOL] }
public void testConfigAndWriteCloseableWithValueIOException() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] Closeable mockValue = mock(Closeable.class); [EOL] SerializationConfig mockConfig = mock(SerializationConfig.class); [EOL] doThrow(new IOException()).when(mockValue).close(); [EOL] _configAndWriteCloseable(mockJsonGenerator, mockValue, mockConfig); [EOL] verify(mockJsonGenerator).close(); [EOL] }
public void testConfigAndWriteCloseableWithBothExceptions() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] Closeable mockValue = mock(Closeable.class); [EOL] SerializationConfig mockConfig = mock(SerializationConfig.class); [EOL] doThrow(new IOException()).when(mockValue).close(); [EOL] doThrow(new JsonGenerationException("")).when(mockJsonGenerator).close(); [EOL] _configAndWriteCloseable(mockJsonGenerator, mockValue, mockConfig); [EOL] }
public void testReadValueWithNullToken() throws IOException { [EOL] DeserializationConfig cfg = new DeserializationConfig(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] JavaType valueType = mock(JavaType.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] when(_initForReading(jp)).thenReturn(JsonToken.VALUE_NULL); [EOL] DeserializationContext ctxt = createDeserializationContext(jp, cfg); [EOL] JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); [EOL] when(deser.getNullValue()).thenReturn(null); [EOL] Object result = _readValue(cfg, jp, valueType); [EOL] assertNull(result); [EOL] verify(jp).clearCurrentToken(); [EOL] }
public void testReadValueWithEndArrayToken() throws IOException { [EOL] DeserializationConfig cfg = new DeserializationConfig(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] JavaType valueType = mock(JavaType.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_ARRAY); [EOL] when(_initForReading(jp)).thenReturn(JsonToken.END_ARRAY); [EOL] Object result = _readValue(cfg, jp, valueType); [EOL] assertNull(result); [EOL] verify(jp).clearCurrentToken(); [EOL] }
public void testReadValueWithRegularTokenWithoutRootWrapping() throws IOException { [EOL] DeserializationConfig cfg = new DeserializationConfig(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] JavaType valueType = mock(JavaType.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(_initForReading(jp)).thenReturn(JsonToken.START_OBJECT); [EOL] DeserializationContext ctxt = createDeserializationContext(jp, cfg); [EOL] JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); [EOL] when(cfg.useRootWrapping()).thenReturn(false); [EOL] Object expectedValue = new Object(); [EOL] when(deser.deserialize(jp, ctxt)).thenReturn(expectedValue); [EOL] Object result = _readValue(cfg, jp, valueType); [EOL] assertSame(expectedValue, result); [EOL] verify(jp).clearCurrentToken(); [EOL] }
public void testReadValueWithRegularTokenWithRootWrapping() throws IOException { [EOL] DeserializationConfig cfg = new DeserializationConfig(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] JavaType valueType = mock(JavaType.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(_initForReading(jp)).thenReturn(JsonToken.START_OBJECT); [EOL] DeserializationContext ctxt = createDeserializationContext(jp, cfg); [EOL] JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); [EOL] when(cfg.useRootWrapping()).thenReturn(true); [EOL] Object expectedValue = new Object(); [EOL] when(_unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser)).thenReturn(expectedValue); [EOL] Object result = _readValue(cfg, jp, valueType); [EOL] assertSame(expectedValue, result); [EOL] verify(jp).clearCurrentToken(); [EOL] }
protected Object _readMapAndClose(JsonParser jp, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { [EOL] try { [EOL] Object result; [EOL] JsonToken t = _initForReading(jp); [EOL] if (t == JsonToken.VALUE_NULL) { [EOL] DeserializationContext ctxt = createDeserializationContext(jp, getDeserializationConfig()); [EOL] result = _findRootDeserializer(ctxt, valueType).getNullValue(); [EOL] } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL] result = null; [EOL] } else { [EOL] DeserializationConfig cfg = getDeserializationConfig(); [EOL] DeserializationContext ctxt = createDeserializationContext(jp, cfg); [EOL] JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, valueType); [EOL] if (cfg.useRootWrapping()) { [EOL] result = _unwrapAndDeserialize(jp, ctxt, cfg, valueType, deser); [EOL] } else { [EOL] result = deser.deserialize(jp, ctxt); [EOL] } [EOL] } [EOL] jp.clearCurrentToken(); [EOL] return result; [EOL] } finally { [EOL] try { [EOL] jp.close(); [EOL] } catch (IOException ioe) { [EOL] } [EOL] } [EOL] }
public boolean canCreateFromObjectWith() { [EOL] return false; [EOL] }
public SettableBeanProperty[] testGetFromObjectArgumentsWithNonNullConfig() { [EOL] DeserializationConfig config = new DeserializationConfig(); [EOL] SettableBeanProperty[] result = getFromObjectArguments(config); [EOL] assertNull(result); [EOL] }
public SettableBeanProperty[] testGetFromObjectArgumentsWithNullConfig() { [EOL] SettableBeanProperty[] result = getFromObjectArguments(null); [EOL] assertNull(result); [EOL] }
public void testGetIncompleteParameterReturnsNull() { [EOL] TestClass testInstance = new TestClass(); [EOL] AnnotatedParameter result = testInstance.getIncompleteParameter(); [EOL] assertNull(result); [EOL] }
public void testGetFalse() { [EOL] BooleanNode result = BooleanNode.getFalse(); [EOL] assertNotNull(result); [EOL] assertFalse(result.booleanValue()); [EOL] }
public void testAsLongWithTrueValue() { [EOL] BooleanNode node = BooleanNode.getTrue(); [EOL] long result = node.asLong(0L); [EOL] assert result == 1L; [EOL] }
public void testAsLongWithFalseValue() { [EOL] BooleanNode node = BooleanNode.getFalse(); [EOL] long result = node.asLong(0L); [EOL] assert result == 0L; [EOL] }
public void testAsDoubleWithTrueValue() { [EOL] JsonBoolean jsonBooleanTrue = new JsonBoolean(true); [EOL] double result = jsonBooleanTrue.asDouble(0.0); [EOL] assert result == 1.0 : "The result should be 1.0 for true value"; [EOL] }
public void testAsDoubleWithFalseValue() { [EOL] JsonBoolean jsonBooleanFalse = new JsonBoolean(false); [EOL] double result = jsonBooleanFalse.asDouble(0.0); [EOL] assert result == 0.0 : "The result should be 0.0 for false value"; [EOL] }
public void testEqualsWithSameObject() { [EOL] BooleanNode node = BooleanNode.getTrue(); [EOL] assertTrue(node.equals(node)); [EOL] }
public void testEqualsWithNull() { [EOL] BooleanNode node = BooleanNode.getTrue(); [EOL] assertFalse(node.equals(null)); [EOL] }
public void testEqualsWithDifferentClass() { [EOL] BooleanNode node = BooleanNode.getTrue(); [EOL] Object other = new Object(); [EOL] assertFalse(node.equals(other)); [EOL] }
public void testEqualsWithDifferentValue() { [EOL] BooleanNode trueNode = BooleanNode.getTrue(); [EOL] BooleanNode falseNode = BooleanNode.getFalse(); [EOL] assertFalse(trueNode.equals(falseNode)); [EOL] }
public void testEqualsWithSameValue() { [EOL] BooleanNode firstTrueNode = BooleanNode.getTrue(); [EOL] BooleanNode secondTrueNode = BooleanNode.getTrue(); [EOL] assertTrue(firstTrueNode.equals(secondTrueNode)); [EOL] }
public void testSimpleTransformerWithPrefixAndSuffix() { [EOL] NameTransformer transformer = NameTransformer.simpleTransformer("pre_", "_suf"); [EOL] String transformed = transformer.transform("name"); [EOL] String reversed = transformer.reverse("pre_name_suf"); [EOL] assertEquals("pre_name_suf", transformed); [EOL] assertEquals("name", reversed); [EOL] assertEquals("[PreAndSuffixTransformer('pre_','_suf')]", transformer.toString()); [EOL] }
public void testSimpleTransformerWithPrefixOnly() { [EOL] NameTransformer transformer = NameTransformer.simpleTransformer("pre_", null); [EOL] String transformed = transformer.transform("name"); [EOL] String reversed = transformer.reverse("pre_name"); [EOL] assertEquals("pre_name", transformed); [EOL] assertEquals("name", reversed); [EOL] assertEquals("[PrefixTransformer('pre_')]", transformer.toString()); [EOL] }
public void testSimpleTransformerWithSuffixOnly() { [EOL] NameTransformer transformer = NameTransformer.simpleTransformer(null, "_suf"); [EOL] String transformed = transformer.transform("name"); [EOL] String reversed = transformer.reverse("name_suf"); [EOL] assertEquals("name_suf", transformed); [EOL] assertEquals("name", reversed); [EOL] assertEquals("[SuffixTransformer('_suf')]", transformer.toString()); [EOL] }
public void testSimpleTransformerWithNoPrefixOrSuffix() { [EOL] NameTransformer transformer = NameTransformer.simpleTransformer(null, null); [EOL] String transformed = transformer.transform("name"); [EOL] String reversed = transformer.reverse("name"); [EOL] assertEquals("name", transformed); [EOL] assertEquals("name", reversed); [EOL] assertEquals(transformer, NameTransformer.NOP); [EOL] }
protected StdDeserializer(Class<?> vc) { [EOL] _valueClass = vc; [EOL] }
public void testParseBooleanWithTrueToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] Boolean result = _parseBoolean(jp, ctxt); [EOL] assertTrue(result); [EOL] }
public void testParseBooleanWithFalseToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] Boolean result = _parseBoolean(jp, ctxt); [EOL] assertFalse(result); [EOL] }
public void testParseBooleanWithNumberIntZero() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(NumberType.INT); [EOL] when(jp.getIntValue()).thenReturn(0); [EOL] Boolean result = _parseBoolean(jp, ctxt); [EOL] assertFalse(result); [EOL] }
public void testParseBooleanWithNumberIntNonZero() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(NumberType.INT); [EOL] when(jp.getIntValue()).thenReturn(1); [EOL] Boolean result = _parseBoolean(jp, ctxt); [EOL] assertTrue(result); [EOL] }
public void testParseBooleanWithNumberIntOther() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(NumberType.LONG); // Assuming _parseBooleanFromNumber handles other types [EOL] when(ctxt.weirdStringException(anyString(), any(), anyString())).thenThrow(new JsonProcessingException("") {}); [EOL] when(_parseBooleanFromNumber(jp, ctxt)).thenReturn(true); [EOL] Boolean result = _parseBoolean(jp, ctxt); [EOL] assertTrue(result); [EOL] }
public void testParseBooleanWithNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] when(ctxt.getNullValue()).thenReturn(null); [EOL] Boolean result = _parseBoolean(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testParseBooleanWithStringTrue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("true"); [EOL] Boolean result = _parseBoolean(jp, ctxt); [EOL] assertTrue(result); [EOL] }
public void testParseBooleanWithStringFalse() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("false"); [EOL] Boolean result = _parseBoolean(jp, ctxt); [EOL] assertFalse(result); [EOL] }
public void testParseBooleanWithStringEmpty() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(""); [EOL] when(ctxt.getEmptyValue()).thenReturn(null); [EOL] Boolean result = _parseBoolean(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testParseBooleanWithStringInvalid() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("invalid"); [EOL] when(ctxt.weirdStringException(anyString(), any(), anyString())).thenThrow(new JsonProcessingException("") {}); [EOL] assertThrows(JsonProcessingException.class, () -> { [EOL] _parseBoolean(jp, ctxt); [EOL] }); [EOL] }
public void testParseBooleanWithInvalidToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] when(ctxt.mappingException(any(), any())).thenThrow(new JsonMappingException("")); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] _parseBoolean(jp, ctxt); [EOL] }); [EOL] }
public void testParseByteWithNumberIntToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getByteValue()).thenReturn((byte) 10); [EOL] byte result = _parseByte(jp, ctxt); [EOL] assertEquals((byte) 10, result); [EOL] }
public void testParseByteWithNumberFloatToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getByteValue()).thenReturn((byte) 10); [EOL] byte result = _parseByte(jp, ctxt); [EOL] assertEquals((byte) 10, result); [EOL] }
public void testParseByteWithEmptyString() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(""); [EOL] Byte result = _parseByte(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testParseByteWithValidString() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("10"); [EOL] Byte result = _parseByte(jp, ctxt); [EOL] assertEquals(Byte.valueOf((byte) 10), result); [EOL] }
public void testParseByteWithInvalidString() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("invalid"); [EOL] try { [EOL] _parseByte(jp, ctxt); [EOL] fail("Expected JsonProcessingException to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected JsonProcessingException, not IOException"); [EOL] } [EOL] }
public void testParseByteWithStringOverflow() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("256"); [EOL] try { [EOL] _parseByte(jp, ctxt); [EOL] fail("Expected JsonProcessingException to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected JsonProcessingException, not IOException"); [EOL] } [EOL] }
public void testParseByteWithNullToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] Byte result = _parseByte(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testParseByteWithUnexpectedToken() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] try { [EOL] _parseByte(jp, ctxt); [EOL] fail("Expected JsonMappingException to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected JsonMappingException, not IOException"); [EOL] } [EOL] }
protected final Integer _parseInteger(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL] JsonToken t = jp.getCurrentToken(); [EOL] if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL] return Integer.valueOf(jp.getIntValue()); [EOL] } [EOL] if (t == JsonToken.VALUE_STRING) { [EOL] String text = jp.getText().trim(); [EOL] try { [EOL] int len = text.length(); [EOL] if (len > 9) { [EOL] long l = Long.parseLong(text); [EOL] if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) { [EOL] throw ctxt.weirdStringException(text, _valueClass, "Overflow: numeric value (" + text + ") out of range of Integer (" + Integer.MIN_VALUE + " - " + Integer.MAX_VALUE + ")"); [EOL] } [EOL] return Integer.valueOf((int) l); [EOL] } [EOL] if (len == 0) { [EOL] return (Integer) getEmptyValue(); [EOL] } [EOL] return Integer.valueOf(NumberInput.parseInt(text)); [EOL] } catch (IllegalArgumentException iae) { [EOL] throw ctxt.weirdStringException(text, _valueClass, "not a valid Integer value"); [EOL] } [EOL] } [EOL] if (t == JsonToken.VALUE_NULL) { [EOL] return (Integer) getNullValue(); [EOL] } [EOL] throw ctxt.mappingException(_valueClass, t); [EOL] }
public void testParseFloatWithNumberIntToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getFloatValue()).thenReturn(10.0f); [EOL] float result = _parseFloat(jp, ctxt); [EOL] assertEquals(10.0f, result, 0.0f); [EOL] }
public void testParseFloatWithNumberFloatToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getFloatValue()).thenReturn(20.0f); [EOL] float result = _parseFloat(jp, ctxt); [EOL] assertEquals(20.0f, result, 0.0f); [EOL] }
public void testParseFloatWithStringTokenEmptyString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(""); [EOL] when(ctxt.getEmptyValue()).thenReturn(null); [EOL] Float result = _parseFloat(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testParseFloatWithStringTokenInfinity() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("Infinity"); [EOL] Float result = _parseFloat(jp, ctxt); [EOL] assertEquals(Float.POSITIVE_INFINITY, result, 0.0f); [EOL] }
public void testParseFloatWithStringTokenNegativeInfinity() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("-Infinity"); [EOL] Float result = _parseFloat(jp, ctxt); [EOL] assertEquals(Float.NEGATIVE_INFINITY, result, 0.0f); [EOL] }
public void testParseFloatWithStringTokenNaN() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("NaN"); [EOL] Float result = _parseFloat(jp, ctxt); [EOL] assertEquals(Float.NaN, result, 0.0f); [EOL] }
public void testParseFloatWithStringTokenValidFloat() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("123.45"); [EOL] Float result = _parseFloat(jp, ctxt); [EOL] assertEquals(123.45f, result, 0.0f); [EOL] }
public void testParseFloatWithStringTokenInvalidFloat() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("not a float"); [EOL] when(ctxt.weirdStringException(anyString(), any(Class.class), anyString())) [EOL] .thenThrow(new JsonProcessingException("") {}); [EOL] assertThrows(JsonProcessingException.class, () -> _parseFloat(jp, ctxt)); [EOL] }
public void testParseFloatWithNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] when(ctxt.getNullValue()).thenReturn(null); [EOL] Float result = _parseFloat(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testParseFloatWithUnexpectedToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] when(ctxt.mappingException(any(Class.class), any(JsonToken.class))) [EOL] .thenThrow(new JsonMappingException("")); [EOL] assertThrows(JsonMappingException.class, () -> _parseFloat(jp, ctxt)); [EOL] }
public void testParseDoubleWithNumberIntToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getDoubleValue()).thenReturn(123.0); [EOL] Double result = _parseDouble(jp, ctxt); [EOL] assertEquals(Double.valueOf(123.0), result); [EOL] }
public void testParseDoubleWithNumberFloatToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getDoubleValue()).thenReturn(456.0); [EOL] Double result = _parseDouble(jp, ctxt); [EOL] assertEquals(Double.valueOf(456.0), result); [EOL] }
public void testParseDoubleWithStringTokenEmpty() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(" "); [EOL] when(ctxt.getEmptyValue()).thenReturn(null); [EOL] Double result = _parseDouble(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testParseDoubleWithStringTokenInfinity() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("Infinity"); [EOL] Double result = _parseDouble(jp, ctxt); [EOL] assertEquals(Double.POSITIVE_INFINITY, result, 0); [EOL] }
public void testParseDoubleWithStringTokenNegativeInfinity() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("-Infinity"); [EOL] Double result = _parseDouble(jp, ctxt); [EOL] assertEquals(Double.NEGATIVE_INFINITY, result, 0); [EOL] }
public void testParseDoubleWithStringTokenNaN() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("NaN"); [EOL] Double result = _parseDouble(jp, ctxt); [EOL] assertEquals(Double.NaN, result, 0); [EOL] }
public void testParseDoubleWithStringTokenInvalid() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("invalid"); [EOL] when(ctxt.weirdStringException(anyString(), any(Class.class), anyString())) [EOL] .thenThrow(new JsonProcessingException("") {}); [EOL] assertThrows(JsonProcessingException.class, () -> _parseDouble(jp, ctxt)); [EOL] }
public void testParseDoubleWithNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] when(ctxt.getNullValue()).thenReturn(null); [EOL] Double result = _parseDouble(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testParseDoubleWithUnexpectedToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] when(ctxt.mappingException(any(Class.class), any(JsonToken.class))) [EOL] .thenThrow(new JsonMappingException("")); [EOL] assertThrows(JsonMappingException.class, () -> _parseDouble(jp, ctxt)); [EOL] }
protected final double _parseDoublePrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL] JsonToken t = jp.getCurrentToken(); [EOL] if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL] return jp.getDoubleValue(); [EOL] } [EOL] if (t == JsonToken.VALUE_STRING) { [EOL] String text = jp.getText().trim(); [EOL] if (text.length() == 0) { [EOL] return 0.0; [EOL] } [EOL] switch(text.charAt(0)) { [EOL] case 'I': [EOL] if ("Infinity".equals(text) || "INF".equals(text)) { [EOL] return Double.POSITIVE_INFINITY; [EOL] } [EOL] break; [EOL] case 'N': [EOL] if ("NaN".equals(text)) { [EOL] return Double.NaN; [EOL] } [EOL] break; [EOL] case '-': [EOL] if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL] return Double.NEGATIVE_INFINITY; [EOL] } [EOL] break; [EOL] } [EOL] try { [EOL] return parseDouble(text); [EOL] } catch (IllegalArgumentException iae) { [EOL] } [EOL] throw ctxt.weirdStringException(text, _valueClass, "not a valid double value"); [EOL] } [EOL] if (t == JsonToken.VALUE_NULL) { [EOL] return 0.0; [EOL] } [EOL] throw ctxt.mappingException(_valueClass, t); [EOL] }
public void testParseDateWithNumberIntToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getLongValue()).thenReturn(1451606400000L); // Example timestamp for January 1, 2016 [EOL] Date result = _parseDate(jp, ctxt); [EOL] assertEquals(new Date(1451606400000L), result); [EOL] }
public void testParseDateWithNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] when(ctxt.getNullValue()).thenReturn(null); [EOL] Date result = _parseDate(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testParseDateWithEmptyStringToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("   "); [EOL] when(ctxt.getEmptyValue()).thenReturn(null); [EOL] Date result = _parseDate(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testParseDateWithValidStringToken() throws IOException, ParseException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("2016-01-01"); [EOL] SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd"); [EOL] when(ctxt.parseDate("2016-01-01")).thenReturn(formatter.parse("2016-01-01")); [EOL] Date result = _parseDate(jp, ctxt); [EOL] assertEquals(formatter.parse("2016-01-01"), result); [EOL] }
public void testParseDateWithInvalidStringToken() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("invalid-date"); [EOL] when(ctxt.parseDate(anyString())).thenThrow(new IllegalArgumentException("not a valid representation")); [EOL] assertThrows(JsonProcessingException.class, () -> _parseDate(jp, ctxt)); [EOL] }
public void testParseDateWithUnexpectedToken() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); // An unexpected token type [EOL] assertThrows(JsonMappingException.class, () -> _parseDate(jp, ctxt)); [EOL] }
public void testFindConvertingContentDeserializerWithNullIntrAndProp() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty prop = null; [EOL] JsonDeserializer<?> existingDeserializer = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> result = findConvertingContentDeserializer(ctxt, prop, existingDeserializer); [EOL] assertSame(existingDeserializer, result); [EOL] }
public void testFindConvertingContentDeserializerWithNonNullIntrAndNullProp() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty prop = null; [EOL] JsonDeserializer<?> existingDeserializer = mock(JsonDeserializer.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] JsonDeserializer<?> result = findConvertingContentDeserializer(ctxt, prop, existingDeserializer); [EOL] assertSame(existingDeserializer, result); [EOL] }
public void testFindConvertingContentDeserializerWithNonNullIntrAndPropButNoConverter() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty prop = mock(BeanProperty.class); [EOL] JsonDeserializer<?> existingDeserializer = mock(JsonDeserializer.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(prop.getMember()).thenReturn(mock(AnnotatedMember.class)); [EOL] when(intr.findDeserializationContentConverter(any(AnnotatedMember.class))).thenReturn(null); [EOL] JsonDeserializer<?> result = findConvertingContentDeserializer(ctxt, prop, existingDeserializer); [EOL] assertSame(existingDeserializer, result); [EOL] }
public void testFindConvertingContentDeserializerWithNonNullIntrPropAndConverter() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty prop = mock(BeanProperty.class); [EOL] JsonDeserializer<?> existingDeserializer = null; [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] Converter<Object, Object> conv = mock(Converter.class); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(prop.getMember()).thenReturn(mock(AnnotatedMember.class)); [EOL] when(intr.findDeserializationContentConverter(any(AnnotatedMember.class))).thenReturn(new Object()); [EOL] when(ctxt.converterInstance(any(AnnotatedMember.class), any())).thenReturn(conv); [EOL] when(conv.getInputType(any(TypeFactory.class))).thenReturn(delegateType); [EOL] when(ctxt.findContextualValueDeserializer(any(JavaType.class), any(BeanProperty.class))).thenReturn(mock(JsonDeserializer.class)); [EOL] JsonDeserializer<?> result = findConvertingContentDeserializer(ctxt, prop, existingDeserializer); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StdDelegatingDeserializer); [EOL] }
public void testFindConvertingContentDeserializerWithNonNullIntrPropConverterAndExistingDeserializer() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty prop = mock(BeanProperty.class); [EOL] JsonDeserializer<?> existingDeserializer = mock(JsonDeserializer.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] Converter<Object, Object> conv = mock(Converter.class); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(prop.getMember()).thenReturn(mock(AnnotatedMember.class)); [EOL] when(intr.findDeserializationContentConverter(any(AnnotatedMember.class))).thenReturn(new Object()); [EOL] when(ctxt.converterInstance(any(AnnotatedMember.class), any())).thenReturn(conv); [EOL] when(conv.getInputType(any(TypeFactory.class))).thenReturn(delegateType); [EOL] JsonDeserializer<?> result = findConvertingContentDeserializer(ctxt, prop, existingDeserializer); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StdDelegatingDeserializer); [EOL] }
public void testGetNodeType() { [EOL] JsonNode node = new NumericNode(); [EOL] assertEquals(JsonNodeType.NUMBER, node.getNodeType()); [EOL] }
public void testAsIntWithValidIntValue() { [EOL] YourClass instance = new YourClass(5); // Replace with actual constructor [EOL] int result = instance.asInt(); [EOL] assertEquals(5, result); [EOL] }
public void testAsIntWithDefaultValue() { [EOL] JsonNode node = new IntNode(5); [EOL] int result = node.asInt(10); [EOL] assertEquals(5, result); [EOL] }
public void testAsIntWithDefaultValueWhenNull() { [EOL] JsonNode node = NullNode.getInstance(); [EOL] int result = node.asInt(10); [EOL] assertEquals(10, result); [EOL] }
public void testAsLongWithValidLong() { [EOL] YourClassWithAsLongMethod instance = new YourClassWithAsLongMethod(); [EOL] Mockito.when(instance.longValue()).thenReturn(10L); [EOL] long result = instance.asLong(); [EOL] assertEquals(10L, result); [EOL] }
public void testAsLongWithMaxLong() { [EOL] YourClassWithAsLongMethod instance = new YourClassWithAsLongMethod(); [EOL] Mockito.when(instance.longValue()).thenReturn(Long.MAX_VALUE); [EOL] long result = instance.asLong(); [EOL] assertEquals(Long.MAX_VALUE, result); [EOL] }
public void testAsLongWithMinLong() { [EOL] YourClassWithAsLongMethod instance = new YourClassWithAsLongMethod(); [EOL] Mockito.when(instance.longValue()).thenReturn(Long.MIN_VALUE); [EOL] long result = instance.asLong(); [EOL] assertEquals(Long.MIN_VALUE, result); [EOL] }
public void testAsLongWithDefaultValue() { [EOL] JsonNode node = new LongNode(5L); [EOL] long result = node.asLong(10L); [EOL] assertEquals(5L, result); [EOL] }
public void testAsLongWithException() { [EOL] JsonNode node = new TextNode("not_a_number"); [EOL] try { [EOL] node.asLong(10L); [EOL] fail("Expected an exception due to invalid number format"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testAsDoubleWithPositiveValue() { [EOL] JsonNode node = new DoubleNode(10.5); [EOL] double result = node.asDouble(); [EOL] assert result == 10.5; [EOL] }
public void testAsDoubleWithNegativeValue() { [EOL] JsonNode node = new DoubleNode(-10.5); [EOL] double result = node.asDouble(); [EOL] assert result == -10.5; [EOL] }
public void testAsDoubleWithZeroValue() { [EOL] JsonNode node = new DoubleNode(0.0); [EOL] double result = node.asDouble(); [EOL] assert result == 0.0; [EOL] }
public void testAsDoubleWithDefaultValue() { [EOL] JsonNode node = new DoubleNode(5.25); [EOL] double result = node.asDouble(1.0); [EOL] assertEquals(5.25, result, 0); [EOL] }
public void testAsDoubleWithDefaultValueWhenNaN() { [EOL] JsonNode node = new DoubleNode(Double.NaN); [EOL] double result = node.asDouble(1.0); [EOL] assertTrue(Double.isNaN(result)); [EOL] }
public void testSerializationConfigCopyConstructorWithInclusion() { [EOL] SerializationConfig src = new SerializationConfig(new BaseSettings(null, null, null, null, null, null, null, null, null, null), null, null); [EOL] JsonInclude.Include incl = JsonInclude.Include.NON_NULL; [EOL] SerializationConfig newConfig = new SerializationConfig(src, incl); [EOL] assertNotNull(newConfig); [EOL] assertEquals(incl, newConfig.getSerializationInclusion()); [EOL] assertEquals(src._serFeatures, newConfig._serFeatures); [EOL] assertEquals(src._filterProvider, newConfig._filterProvider); [EOL] }
public void testSerializationConfigCopyConstructorWithDifferentInclusion() { [EOL] SerializationConfig src = new SerializationConfig(new BaseSettings(null, null, null, null, null, null, null, null, null, null), null, null); [EOL] JsonInclude.Include originalIncl = src.getSerializationInclusion(); [EOL] JsonInclude.Include newIncl = (originalIncl == JsonInclude.Include.NON_NULL) ? JsonInclude.Include.NON_DEFAULT : JsonInclude.Include.NON_NULL; [EOL] SerializationConfig newConfig = new SerializationConfig(src, newIncl); [EOL] assertNotNull(newConfig); [EOL] assertNotEquals(originalIncl, newConfig.getSerializationInclusion()); [EOL] assertEquals(newIncl, newConfig.getSerializationInclusion()); [EOL] assertEquals(src._serFeatures, newConfig._serFeatures); [EOL] assertEquals(src._filterProvider, newConfig._filterProvider); [EOL] }
public void testWithNoFeatures() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] SerializationConfig newConfig = config.with(); [EOL] assertSame("Should be the same config as no features were added", config, newConfig); [EOL] }
public void testWithOneFeature() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] SerializationConfig newConfig = config.with(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES); [EOL] assertNotSame("Should not be the same config as a feature was added", config, newConfig); [EOL] assertTrue("New config should have the feature enabled", newConfig.isEnabled(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES)); [EOL] }
public void testWithMultipleFeatures() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] SerializationConfig newConfig = config.with(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, MapperFeature.AUTO_DETECT_FIELDS); [EOL] assertNotSame("Should not be the same config as features were added", config, newConfig); [EOL] assertTrue("New config should have ACCEPT_CASE_INSENSITIVE_PROPERTIES feature enabled", newConfig.isEnabled(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES)); [EOL] assertTrue("New config should have AUTO_DETECT_FIELDS feature enabled", newConfig.isEnabled(MapperFeature.AUTO_DETECT_FIELDS)); [EOL] }
public void testWithNullDateFormat() { [EOL] SerializationConfig originalConfig = new SerializationConfig(); [EOL] SerializationConfig newConfig = originalConfig.with(null); [EOL] assertTrue(newConfig.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)); [EOL] }
public void testWithNonNullDateFormat() { [EOL] SerializationConfig originalConfig = new SerializationConfig(); [EOL] DateFormat df = new SimpleDateFormat(); [EOL] SerializationConfig newConfig = originalConfig.with(df); [EOL] assertFalse(newConfig.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)); [EOL] }
public void testWithoutWhenFeatureIsEnabled() { [EOL] SerializationConfig config = new SerializationConfig(...); // provide necessary initialization parameters [EOL] SerializationFeature feature = SerializationFeature.WRAP_ROOT_VALUE; // choose a feature that is enabled in config [EOL] int expectedFeatures = config.getSerializationFeatures() & ~feature.getMask(); [EOL] SerializationConfig newConfig = config.without(feature); [EOL] assertEquals(expectedFeatures, newConfig.getSerializationFeatures()); [EOL] assertNotSame(config, newConfig); // Ensure a new instance is returned [EOL] }
public void testWithoutWhenFeatureIsDisabled() { [EOL] SerializationConfig config = new SerializationConfig(...); // provide necessary initialization parameters [EOL] SerializationFeature feature = SerializationFeature.FAIL_ON_EMPTY_BEANS; // choose a feature that is disabled in config [EOL] int expectedFeatures = config.getSerializationFeatures(); [EOL] SerializationConfig newConfig = config.without(feature); [EOL] assertEquals(expectedFeatures, newConfig.getSerializationFeatures()); [EOL] assertSame(config, newConfig); // Ensure the same instance is returned if feature is already disabled [EOL] }
public void testWithSerializationInclusionSameValue() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide necessary initialization parameters [EOL] JsonInclude.Include incl = config.getSerializationInclusion(); // Assuming getSerializationInclusion() method exists [EOL] SerializationConfig newConfig = config.withSerializationInclusion(incl); [EOL] assertSame(config, newConfig); [EOL] }
public void testWithSerializationInclusionDifferentValue() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide necessary initialization parameters [EOL] JsonInclude.Include incl = JsonInclude.Include.NON_NULL; // Choose a value different from the default [EOL] SerializationConfig newConfig = config.withSerializationInclusion(incl); [EOL] assertNotSame(config, newConfig); [EOL] assertEquals(incl, newConfig.getSerializationInclusion()); // Assuming getSerializationInclusion() method exists [EOL] }
public void testGetSerializationInclusionNonNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL] assertEquals(JsonInclude.Include.NON_NULL, mapper.getSerializationInclusion()); [EOL] }
public void testGetSerializationInclusionDefault() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] assertEquals(JsonInclude.Include.ALWAYS, mapper.getSerializationInclusion()); [EOL] }
public void testFindWithUnregisteredClassName() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(URI.class, "UnregisteredClassName"); [EOL] assertNull(deserializer); [EOL] }
public void testFindWithURIClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(URI.class, "java.net.URI"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof URIDeserializer); [EOL] }
public void testFindWithURLClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(URL.class, "java.net.URL"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof URLDeserializer); [EOL] }
public void testFindWithFileClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(File.class, "java.io.File"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof FileDeserializer); [EOL] }
public void testFindWithUUIDClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(UUID.class, "java.util.UUID"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof UUIDDeserializer); [EOL] }
public void testFindWithCurrencyClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Currency.class, "java.util.Currency"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof CurrencyDeserializer); [EOL] }
public void testFindWithPatternClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Pattern.class, "java.util.regex.Pattern"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof PatternDeserializer); [EOL] }
public void testFindWithLocaleClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Locale.class, "java.util.Locale"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof LocaleDeserializer); [EOL] }
public void testFindWithInetAddressClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(InetAddress.class, "java.net.InetAddress"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof InetAddressDeserializer); [EOL] }
public void testFindWithCharsetClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Charset.class, "java.nio.charset.Charset"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof CharsetDeserializer); [EOL] }
public void testFindWithClassClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Class.class, "java.lang.Class"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof ClassDeserializer); [EOL] }
public void testFindWithStackTraceElementClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(StackTraceElement.class, "java.lang.StackTraceElement"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof StackTraceElementDeserializer); [EOL] }
public void testFindWithAtomicBooleanClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(AtomicBoolean.class, "java.util.concurrent.atomic.AtomicBoolean"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof AtomicBooleanDeserializer); [EOL] }
public void testFindWithInvalidClass() { [EOL] try { [EOL] YourClass.find(Object.class, "java.lang.Object"); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAtomicReferenceDeserializerWithNonNullReferencedType() { [EOL] JavaType referencedType = TypeFactory.defaultInstance().constructType(String.class); [EOL] AtomicReferenceDeserializer deserializer = new AtomicReferenceDeserializer(referencedType); [EOL] assertNotNull(deserializer); [EOL] }
public void testAtomicReferenceDeserializerWithNullReferencedType() { [EOL] JavaType referencedType = null; [EOL] try { [EOL] AtomicReferenceDeserializer deserializer = new AtomicReferenceDeserializer(referencedType); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("referencedType cannot be null", e.getMessage()); [EOL] } [EOL] }
public void testAtomicReferenceDeserializerWithNonNullTypes() { [EOL] JavaType referencedType = TypeFactory.defaultInstance().constructType(String.class); [EOL] JsonDeserializer<?> deser = new StdDeserializer.StringDeserializer(); [EOL] AtomicReferenceDeserializer deserializer = new AtomicReferenceDeserializer(referencedType, deser); [EOL] assertNotNull(deserializer); [EOL] } [EOL] public void testAtomicReferenceDeserializerWithNullReferencedType() { [EOL] JavaType referencedType = null; [EOL] JsonDeserializer<?> deser = new StdDeserializer.StringDeserializer(); [EOL] try { [EOL] AtomicReferenceDeserializer deserializer = new AtomicReferenceDeserializer(referencedType, deser); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testAtomicReferenceDeserializerWithNullValueDeserializer() { [EOL] JavaType referencedType = TypeFactory.defaultInstance().constructType(String.class); [EOL] JsonDeserializer<?> deser = null; [EOL] AtomicReferenceDeserializer deserializer = new AtomicReferenceDeserializer(referencedType, deser); [EOL] assertNotNull(deserializer); [EOL] }
public void testDeserializeWithNonNullValue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> valueDeserializer = mock(JsonDeserializer.class); [EOL] AtomicReferenceDeserializer deserializer = new AtomicReferenceDeserializer(valueDeserializer); [EOL] when(valueDeserializer.deserialize(jp, ctxt)).thenReturn("testValue"); [EOL] AtomicReference<?> result = deserializer.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals("testValue", result.get()); [EOL] }
public void testDeserializeWithNullValue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> valueDeserializer = mock(JsonDeserializer.class); [EOL] AtomicReferenceDeserializer deserializer = new AtomicReferenceDeserializer(valueDeserializer); [EOL] when(valueDeserializer.deserialize(jp, ctxt)).thenReturn(null); [EOL] AtomicReference<?> result = deserializer.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertNull(result.get()); [EOL] }
public void testCreateContextualWithValueDeserializerNotNull() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonDeserializer<?> valueDeserializer = mock(JsonDeserializer.class); [EOL] AtomicReferenceDeserializer instance = new AtomicReferenceDeserializer(null, valueDeserializer); [EOL] JsonDeserializer<?> result = instance.createContextual(ctxt, property); [EOL] assertSame(instance, result, "Expected the same instance to be returned when valueDeserializer is not null."); [EOL] }
public void testCreateContextualWithValueDeserializerNull() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JavaType referencedType = mock(JavaType.class); [EOL] AtomicReferenceDeserializer instance = new AtomicReferenceDeserializer(referencedType, null); [EOL] when(ctxt.findContextualValueDeserializer(referencedType, property)).thenReturn(mock(JsonDeserializer.class)); [EOL] JsonDeserializer<?> result = instance.createContextual(ctxt, property); [EOL] assertNotNull(result, "Expected a non-null JsonDeserializer to be returned when valueDeserializer is null."); [EOL] assertTrue(result instanceof AtomicReferenceDeserializer, "Expected result to be an instance of AtomicReferenceDeserializer."); [EOL] }
public void testStackTraceElementDeserializerConstructor() { [EOL] StackTraceElementDeserializer deserializer = new StackTraceElementDeserializer(); [EOL] assertNotNull(deserializer); [EOL] }
public void testForPropertySameProperty() { [EOL] AsPropertyTypeSerializer original = new AsPropertyTypeSerializer(idResolver, property, typePropertyName); [EOL] AsPropertyTypeSerializer result = original.forProperty(property); [EOL] assertSame(original, result); [EOL] }
public void testForPropertyDifferentProperty() { [EOL] AsPropertyTypeSerializer original = new AsPropertyTypeSerializer(idResolver, property, typePropertyName); [EOL] BeanProperty newProperty = mock(BeanProperty.class); [EOL] AsPropertyTypeSerializer result = original.forProperty(newProperty); [EOL] assertNotNull(result); [EOL] assertNotSame(original, result); [EOL] assertEquals(newProperty, result.getProperty()); [EOL] }
public void testWriteCustomTypePrefixForObject() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] CustomSerializer serializer = new CustomSerializer("typeProperty"); [EOL] Object value = new Object(); [EOL] String typeId = "customType"; [EOL] serializer.writeCustomTypePrefixForObject(value, mockJsonGenerator, typeId); [EOL] verify(mockJsonGenerator).writeStartObject(); [EOL] verify(mockJsonGenerator).writeStringField("typeProperty", typeId); [EOL] }
public void testWriteCustomTypeSuffixForObject() throws IOException, JsonProcessingException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] CustomSerializer serializer = new CustomSerializer(); [EOL] serializer.writeCustomTypeSuffixForObject(new Object(), mockJsonGenerator, "typeId"); [EOL] verify(mockJsonGenerator).writeEndObject(); [EOL] }
public void testCreateContextualWithNonNullPropertyAndNonNullFormatWithNumericShape() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(prov.getAnnotationIntrospector().findFormat(member)).thenReturn(format); [EOL] when(format.getShape()).thenReturn(JsonFormat.Shape.NUMBER); [EOL] JsonSerializer<?> result = createContextual(prov, property); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NumericSerializer); [EOL] }
public void testCreateContextualWithNonNullPropertyAndNonNullFormatWithPattern() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(prov.getAnnotationIntrospector().findFormat(member)).thenReturn(format); [EOL] when(format.getPattern()).thenReturn("yyyy-MM-dd"); [EOL] when(format.getLocale()).thenReturn(null); [EOL] when(prov.getLocale()).thenReturn(Locale.US); [EOL] when(format.getTimeZone()).thenReturn(null); [EOL] when(prov.getTimeZone()).thenReturn(TimeZone.getTimeZone("UTC")); [EOL] JsonSerializer<?> result = createContextual(prov, property); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof PatternSerializer); [EOL] }
public void testCreateContextualWithNonNullPropertyAndNonNullFormatWithTimeZone() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(prov.getAnnotationIntrospector().findFormat(member)).thenReturn(format); [EOL] when(format.getShape()).thenReturn(JsonFormat.Shape.STRING); // Not numeric [EOL] when(format.getPattern()).thenReturn(""); // Empty pattern [EOL] when(format.getTimeZone()).thenReturn(TimeZone.getTimeZone("UTC")); [EOL] when(prov.getConfig().getDateFormat()).thenReturn(new StdDateFormat()); [EOL] JsonSerializer<?> result = createContextual(prov, property); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof TimeZoneSerializer); [EOL] }
public void testCreateContextualWithNullProperty() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanProperty property = null; [EOL] JsonSerializer<?> result = createContextual(prov, property); [EOL] assertSame(this, result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndNullFormat() { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] when(prov.getAnnotationIntrospector().findFormat(member)).thenReturn(null); [EOL] JsonSerializer<?> result = createContextual(prov, property); [EOL] assertSame(this, result); [EOL] }
public void testDeserializeSetAndReturnWithValidInput() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object instance = new Object(); [EOL] Object expected = new Object(); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonDeserializer<Object> deserializer = mapper.getDeserializationContext().findRootValueDeserializer(mapper.constructType(Object.class)); [EOL] when(deserializer.deserialize(jp, ctxt)).thenReturn(expected); [EOL] Object result = deserializer.deserializeSetAndReturn(jp, ctxt, instance); [EOL] assertEquals(expected, result); [EOL] }
public void testDeserializeSetAndReturnWithIOException() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object instance = new Object(); [EOL] when(deserializer.deserialize(jp, ctxt)).thenThrow(new IOException()); [EOL] try { [EOL] deserializer.deserializeSetAndReturn(jp, ctxt, instance); [EOL] fail("Expected an IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testDeserializeSetAndReturnWithJsonProcessingException() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object instance = new Object(); [EOL] when(deserializer.deserialize(jp, ctxt)).thenThrow(new JsonProcessingException("") {}); [EOL] try { [EOL] deserializer.deserializeSetAndReturn(jp, ctxt, instance); [EOL] fail("Expected a JsonProcessingException to be thrown"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testBeanDeserializerBaseWithUnwrapper() { [EOL] BeanDeserializerBase src = createBeanDeserializerBase(); [EOL] NameTransformer unwrapper = createNameTransformer(); [EOL] BeanDeserializerBase result = new BeanDeserializerBase(src, unwrapper); [EOL] assertNotNull(result._beanType); [EOL] assertEquals(src._classAnnotations, result._classAnnotations); [EOL] assertEquals(src._valueInstantiator, result._valueInstantiator); [EOL] assertEquals(src._delegateDeserializer, result._delegateDeserializer); [EOL] assertEquals(src._propertyBasedCreator, result._propertyBasedCreator); [EOL] assertEquals(src._backRefs, result._backRefs); [EOL] assertEquals(src._ignorableProps, result._ignorableProps); [EOL] assertTrue(result._ignoreAllUnknown); [EOL] assertEquals(src._anySetter, result._anySetter); [EOL] assertEquals(src._injectables, result._injectables); [EOL] assertEquals(src._objectIdReader, result._objectIdReader); [EOL] assertEquals(src._nonStandardCreation, result._nonStandardCreation); [EOL] assertNotNull(result._unwrappedPropertyHandler); [EOL] assertNotNull(result._beanProperties); [EOL] assertEquals(src._needViewProcesing, result._needViewProcesing); [EOL] assertEquals(src._serializationShape, result._serializationShape); [EOL] assertFalse(result._vanillaProcessing); [EOL] }
public void testBeanDeserializerBaseWithoutUnwrapper() { [EOL] BeanDeserializerBase src = createBeanDeserializerBase(); [EOL] NameTransformer unwrapper = null; [EOL] BeanDeserializerBase result = new BeanDeserializerBase(src, unwrapper); [EOL] assertNotNull(result._beanType); [EOL] assertEquals(src._classAnnotations, result._classAnnotations); [EOL] assertEquals(src._valueInstantiator, result._valueInstantiator); [EOL] assertEquals(src._delegateDeserializer, result._delegateDeserializer); [EOL] assertEquals(src._propertyBasedCreator, result._propertyBasedCreator); [EOL] assertEquals(src._backRefs, result._backRefs); [EOL] assertEquals(src._ignorableProps, result._ignorableProps); [EOL] assertEquals(src._ignoreAllUnknown, result._ignoreAllUnknown); [EOL] assertEquals(src._anySetter, result._anySetter); [EOL] assertEquals(src._injectables, result._injectables); [EOL] assertEquals(src._objectIdReader, result._objectIdReader); [EOL] assertEquals(src._nonStandardCreation, result._nonStandardCreation); [EOL] assertEquals(src._unwrappedPropertyHandler, result._unwrappedPropertyHandler); [EOL] assertEquals(src._beanProperties, result._beanProperties); [EOL] assertEquals(src._needViewProcesing, result._needViewProcesing); [EOL] assertEquals(src._serializationShape, result._serializationShape); [EOL] assertFalse(result._vanillaProcessing); [EOL] }
public void testBeanDeserializerBaseWithNullObjectIdReader() { [EOL] BeanDeserializerBase original = createMockBeanDeserializerBase(); [EOL] BeanDeserializerBase copy = new BeanDeserializerBase(original, null); [EOL] assertNotNull(copy); [EOL] assertEquals(original._beanType, copy._beanType); [EOL] assertEquals(original._classAnnotations, copy._classAnnotations); [EOL] assertEquals(original._valueInstantiator, copy._valueInstantiator); [EOL] assertEquals(original._delegateDeserializer, copy._delegateDeserializer); [EOL] assertEquals(original._propertyBasedCreator, copy._propertyBasedCreator); [EOL] assertEquals(original._backRefs, copy._backRefs); [EOL] assertEquals(original._ignorableProps, copy._ignorableProps); [EOL] assertEquals(original._ignoreAllUnknown, copy._ignoreAllUnknown); [EOL] assertEquals(original._anySetter, copy._anySetter); [EOL] assertEquals(original._injectables, copy._injectables); [EOL] assertEquals(original._nonStandardCreation, copy._nonStandardCreation); [EOL] assertEquals(original._unwrappedPropertyHandler, copy._unwrappedPropertyHandler); [EOL] assertEquals(original._needViewProcesing, copy._needViewProcesing); [EOL] assertEquals(original._serializationShape, copy._serializationShape); [EOL] assertEquals(original._vanillaProcessing, copy._vanillaProcessing); [EOL] assertEquals(original._beanProperties, copy._beanProperties); [EOL] assertNull(copy._objectIdReader); [EOL] }
public void testBeanDeserializerBaseWithNonNullObjectIdReader() { [EOL] BeanDeserializerBase original = createMockBeanDeserializerBase(); [EOL] ObjectIdReader oir = createMockObjectIdReader(); [EOL] BeanDeserializerBase copy = new BeanDeserializerBase(original, oir); [EOL] assertNotNull(copy); [EOL] assertEquals(original._beanType, copy._beanType); [EOL] assertEquals(original._classAnnotations, copy._classAnnotations); [EOL] assertEquals(original._valueInstantiator, copy._valueInstantiator); [EOL] assertEquals(original._delegateDeserializer, copy._delegateDeserializer); [EOL] assertEquals(original._propertyBasedCreator, copy._propertyBasedCreator); [EOL] assertEquals(original._backRefs, copy._backRefs); [EOL] assertEquals(original._ignorableProps, copy._ignorableProps); [EOL] assertEquals(original._ignoreAllUnknown, copy._ignoreAllUnknown); [EOL] assertEquals(original._anySetter, copy._anySetter); [EOL] assertEquals(original._injectables, copy._injectables); [EOL] assertEquals(original._nonStandardCreation, copy._nonStandardCreation); [EOL] assertEquals(original._unwrappedPropertyHandler, copy._unwrappedPropertyHandler); [EOL] assertEquals(original._needViewProcesing, copy._needViewProcesing); [EOL] assertEquals(original._serializationShape, copy._serializationShape); [EOL] assertEquals(original._vanillaProcessing, copy._vanillaProcessing); [EOL] assertNotEquals(original._beanProperties, copy._beanProperties); [EOL] assertNotNull(copy._objectIdReader); [EOL] }
public void testBeanDeserializerBaseConstructorWithNullIgnorableProps() { [EOL] BeanDeserializerBase original = createBeanDeserializerBase(); [EOL] BeanDeserializerBase copy = new BeanDeserializerBase(original, null); [EOL] assertNotNull(copy); [EOL] assertEquals(original._beanType, copy._beanType); [EOL] assertEquals(original._classAnnotations, copy._classAnnotations); [EOL] assertEquals(original._valueInstantiator, copy._valueInstantiator); [EOL] assertEquals(original._delegateDeserializer, copy._delegateDeserializer); [EOL] assertEquals(original._propertyBasedCreator, copy._propertyBasedCreator); [EOL] assertEquals(original._backRefs, copy._backRefs); [EOL] assertNull(copy._ignorableProps); [EOL] assertEquals(original._ignoreAllUnknown, copy._ignoreAllUnknown); [EOL] assertEquals(original._anySetter, copy._anySetter); [EOL] assertEquals(original._injectables, copy._injectables); [EOL] assertEquals(original._nonStandardCreation, copy._nonStandardCreation); [EOL] assertEquals(original._unwrappedPropertyHandler, copy._unwrappedPropertyHandler); [EOL] assertEquals(original._needViewProcesing, copy._needViewProcesing); [EOL] assertEquals(original._serializationShape, copy._serializationShape); [EOL] assertEquals(original._vanillaProcessing, copy._vanillaProcessing); [EOL] assertEquals(original._objectIdReader, copy._objectIdReader); [EOL] assertEquals(original._beanProperties, copy._beanProperties); [EOL] }
public void testBeanDeserializerBaseConstructorWithNonNullIgnorableProps() { [EOL] BeanDeserializerBase original = createBeanDeserializerBase(); [EOL] HashSet<String> ignorableProps = new HashSet<>(); [EOL] ignorableProps.add("prop1"); [EOL] ignorableProps.add("prop2"); [EOL] BeanDeserializerBase copy = new BeanDeserializerBase(original, ignorableProps); [EOL] assertNotNull(copy); [EOL] assertEquals(original._beanType, copy._beanType); [EOL] assertEquals(original._classAnnotations, copy._classAnnotations); [EOL] assertEquals(original._valueInstantiator, copy._valueInstantiator); [EOL] assertEquals(original._delegateDeserializer, copy._delegateDeserializer); [EOL] assertEquals(original._propertyBasedCreator, copy._propertyBasedCreator); [EOL] assertEquals(original._backRefs, copy._backRefs); [EOL] assertEquals(ignorableProps, copy._ignorableProps); [EOL] assertEquals(original._ignoreAllUnknown, copy._ignoreAllUnknown); [EOL] assertEquals(original._anySetter, copy._anySetter); [EOL] assertEquals(original._injectables, copy._injectables); [EOL] assertEquals(original._nonStandardCreation, copy._nonStandardCreation); [EOL] assertEquals(original._unwrappedPropertyHandler, copy._unwrappedPropertyHandler); [EOL] assertEquals(original._needViewProcesing, copy._needViewProcesing); [EOL] assertEquals(original._serializationShape, copy._serializationShape); [EOL] assertEquals(original._vanillaProcessing, copy._vanillaProcessing); [EOL] assertEquals(original._objectIdReader, copy._objectIdReader); [EOL] assertEquals(original._beanProperties, copy._beanProperties); [EOL] }
public void testResolveWithCanCreateFromObjectWith() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] ValueInstantiator valueInstantiator = createValueInstantiator(true, true, false); [EOL] BeanDeserializerBuilder builder = createBeanDeserializerBuilder(valueInstantiator); [EOL] builder.resolve(ctxt); [EOL] assertNotNull(builder._propertyBasedCreator); [EOL] assertNotNull(builder._externalTypeIdHandler); [EOL] assertTrue(builder._nonStandardCreation); [EOL] }
public void testResolveWithUnwrappedPropertyHandler() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] ValueInstantiator valueInstantiator = createValueInstantiator(false, false, false); [EOL] BeanDeserializerBuilder builder = createBeanDeserializerBuilder(valueInstantiator); [EOL] builder._beanProperties = createBeanPropertiesWithUnwrapped(); [EOL] builder.resolve(ctxt); [EOL] assertNotNull(builder._unwrappedPropertyHandler); [EOL] assertTrue(builder._nonStandardCreation); [EOL] }
public void testResolveWithDelegateType() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] ValueInstantiator valueInstantiator = createValueInstantiator(false, false, true); [EOL] BeanDeserializerBuilder builder = createBeanDeserializerBuilder(valueInstantiator); [EOL] builder.resolve(ctxt); [EOL] assertNotNull(builder._delegateDeserializer); [EOL] }
public void testResolveWithInvalidDelegateType() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] ValueInstantiator valueInstantiator = createValueInstantiator(false, false, true, true); [EOL] BeanDeserializerBuilder builder = createBeanDeserializerBuilder(valueInstantiator); [EOL] assertThrows(IllegalArgumentException.class, () -> builder.resolve(ctxt)); [EOL] }
public void testResolveWithExternalTypeProperty() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] ValueInstantiator valueInstantiator = createValueInstantiator(false, true, false); [EOL] BeanDeserializerBuilder builder = createBeanDeserializerBuilder(valueInstantiator); [EOL] builder._beanProperties = createBeanPropertiesWithExternalType(); [EOL] builder.resolve(ctxt); [EOL] assertNotNull(builder._externalTypeIdHandler); [EOL] assertTrue(builder._nonStandardCreation); [EOL] }
public void testResolveVanillaProcessing() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] ValueInstantiator valueInstantiator = createValueInstantiator(false, false, false); [EOL] BeanDeserializerBuilder builder = createBeanDeserializerBuilder(valueInstantiator); [EOL] builder.resolve(ctxt); [EOL] assertTrue(builder._vanillaProcessing); [EOL] }
public void testCreateContextualWithNullPropertyAndIntr() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = null; [EOL] BeanDeserializerBase instance = createInstance(); [EOL] JsonDeserializer<?> result = instance.createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] } [EOL] public void testCreateContextualWithNonNullPropertyAndNullIntr() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(null); [EOL] BeanDeserializerBase instance = createInstance(); [EOL] JsonDeserializer<?> result = instance.createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] } [EOL] public void testCreateContextualWithIgnorals() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(property.getMember()).thenReturn(accessor); [EOL] when(intr.findPropertiesToIgnore(accessor)).thenReturn(new String[]{"propToIgnore"}); [EOL] BeanDeserializerBase instance = createInstance(); [EOL] JsonDeserializer<?> result = instance.createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] } [EOL] public void testCreateContextualWithObjectIdInfoAndPropertyGenerator() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] ObjectIdInfo objectIdInfo = mock(ObjectIdInfo.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(property.getMember()).thenReturn(accessor); [EOL] when(intr.findObjectIdInfo(accessor)).thenReturn(objectIdInfo); [EOL] when(objectIdInfo.getGeneratorType()).thenReturn(ObjectIdGenerators.PropertyGenerator.class); [EOL] when(objectIdInfo.getPropertyName()).thenReturn("id"); [EOL] when(objectIdInfo.getScope()).thenReturn(Object.class); [EOL] BeanDeserializerBase instance = createInstance(); [EOL] SettableBeanProperty idProp = mock(SettableBeanProperty.class); [EOL] when(instance.findProperty("id")).thenReturn(idProp); [EOL] when(idProp.getType()).thenReturn(mock(JavaType.class)); [EOL] JsonDeserializer<?> result = instance.createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] } [EOL] public void testCreateContextualWithObjectIdInfoAndNonPropertyGenerator() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] ObjectIdInfo objectIdInfo = mock(ObjectIdInfo.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(property.getMember()).thenReturn(accessor); [EOL] when(intr.findObjectIdInfo(accessor)).thenReturn(objectIdInfo); [EOL] when(objectIdInfo.getGeneratorType()).thenReturn(ObjectIdGenerators.IntSequenceGenerator.class); [EOL] when(objectIdInfo.getPropertyName()).thenReturn("id"); [EOL] when(objectIdInfo.getScope()).thenReturn(Object.class); [EOL] BeanDeserializerBase instance = createInstance(); [EOL] when(ctxt.objectIdGeneratorInstance(accessor, objectIdInfo)).thenReturn(mock(ObjectIdGenerator.class)); [EOL] JsonDeserializer<?> result = instance.createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] } [EOL] public void testCreateContextualWithArrayShape() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(property.getMember()).thenReturn(accessor); [EOL] when(intr.findFormat(accessor)).thenReturn(format); [EOL] when(format.getShape()).thenReturn(JsonFormat.Shape.ARRAY); [EOL] BeanDeserializerBase instance = createInstance(); [EOL] JsonDeserializer<?> result = instance.createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] }
private BeanDeserializerBase createInstance() { [EOL] return mock(BeanDeserializerBase.class); [EOL] }
protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL] String refName = prop.getManagedReferenceName(); [EOL] if (refName == null) { [EOL] return prop; [EOL] } [EOL] JsonDeserializer<?> valueDeser = prop.getValueDeserializer(); [EOL] SettableBeanProperty backProp = null; [EOL] boolean isContainer = false; [EOL] if (valueDeser instanceof BeanDeserializerBase) { [EOL] backProp = ((BeanDeserializerBase) valueDeser).findBackReference(refName); [EOL] } else if (valueDeser instanceof ContainerDeserializerBase<?>) { [EOL] JsonDeserializer<?> contentDeser = ((ContainerDeserializerBase<?>) valueDeser).getContentDeserializer(); [EOL] if (!(contentDeser instanceof BeanDeserializerBase)) { [EOL] String deserName = (contentDeser == null) ? "NULL" : contentDeser.getClass().getName(); [EOL] throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': value deserializer is of type ContainerDeserializerBase, but content type is not handled by a BeanDeserializer " + " (instead it's of type " + deserName + ")"); [EOL] } [EOL] backProp = ((BeanDeserializerBase) contentDeser).findBackReference(refName); [EOL] isContainer = true; [EOL] } else if (valueDeser instanceof AbstractDeserializer) { [EOL] backProp = ((AbstractDeserializer) valueDeser).findBackReference(refName); [EOL] } else { [EOL] throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': type for value deserializer is not BeanDeserializer or ContainerDeserializerBase, but " + valueDeser.getClass().getName()); [EOL] } [EOL] if (backProp == null) { [EOL] throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': no back reference property found from type " + prop.getType()); [EOL] } [EOL] JavaType referredType = _beanType; [EOL] JavaType backRefType = backProp.getType(); [EOL] if (!backRefType.getRawClass().isAssignableFrom(referredType.getRawClass())) { [EOL] throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': back reference type (" + backRefType.getRawClass().getName() + ") not compatible with managed type (" + referredType.getRawClass().getName() + ")"); [EOL] } [EOL] return new ManagedReferenceProperty(prop, refName, backProp, _classAnnotations, isContainer); [EOL] }
public void testResolveUnwrappedPropertyWithNonNullMemberAndUnwrapper() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] NameTransformer unwrapper = mock(NameTransformer.class); [EOL] JsonDeserializer<Object> orig = mock(JsonDeserializer.class); [EOL] JsonDeserializer<Object> unwrapping = mock(JsonDeserializer.class); [EOL] when(prop.getMember()).thenReturn(am); [EOL] when(ctxt.getAnnotationIntrospector().findUnwrappingNameTransformer(am)).thenReturn(unwrapper); [EOL] when(prop.getValueDeserializer()).thenReturn(orig); [EOL] when(orig.unwrappingDeserializer(unwrapper)).thenReturn(unwrapping); [EOL] SettableBeanProperty result = _resolveUnwrappedProperty(ctxt, prop); [EOL] assertNotNull(result); [EOL] assertSame(unwrapping, result.getValueDeserializer()); [EOL] }
public void testResolveUnwrappedPropertyWithNonNullMemberAndNoUnwrapper() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] when(prop.getMember()).thenReturn(am); [EOL] when(ctxt.getAnnotationIntrospector().findUnwrappingNameTransformer(am)).thenReturn(null); [EOL] SettableBeanProperty result = _resolveUnwrappedProperty(ctxt, prop); [EOL] assertNull(result); [EOL] }
public void testResolveUnwrappedPropertyWithNullMember() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] when(prop.getMember()).thenReturn(null); [EOL] SettableBeanProperty result = _resolveUnwrappedProperty(ctxt, prop); [EOL] assertNull(result); [EOL] }
public void testResolveUnwrappedPropertyWithUnchangedDeserializer() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] NameTransformer unwrapper = mock(NameTransformer.class); [EOL] JsonDeserializer<Object> orig = mock(JsonDeserializer.class); [EOL] when(prop.getMember()).thenReturn(am); [EOL] when(ctxt.getAnnotationIntrospector().findUnwrappingNameTransformer(am)).thenReturn(unwrapper); [EOL] when(prop.getValueDeserializer()).thenReturn(orig); [EOL] when(orig.unwrappingDeserializer(unwrapper)).thenReturn(orig); [EOL] SettableBeanProperty result = _resolveUnwrappedProperty(ctxt, prop); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithTypeWithObjectIdReaderNotNullAndScalarToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] ObjectIdReader objectIdReader = mock(ObjectIdReader.class); [EOL] when(_objectIdReader).thenReturn(objectIdReader); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] Object expected = new Object(); [EOL] when(deserializeFromObjectId(jp, ctxt)).thenReturn(expected); [EOL] Object result = deserializeWithType(jp, ctxt, typeDeserializer); [EOL] assertSame(expected, result); [EOL] }
public void testDeserializeWithTypeWithObjectIdReaderNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] when(_objectIdReader).thenReturn(null); [EOL] Object expected = new Object(); [EOL] when(typeDeserializer.deserializeTypedFromObject(jp, ctxt)).thenReturn(expected); [EOL] Object result = deserializeWithType(jp, ctxt, typeDeserializer); [EOL] assertSame(expected, result); [EOL] }
public void testDeserializeWithTypeWithObjectIdReaderNotNullAndNonScalarToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] ObjectIdReader objectIdReader = mock(ObjectIdReader.class); [EOL] when(_objectIdReader).thenReturn(objectIdReader); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] Object expected = new Object(); [EOL] when(typeDeserializer.deserializeTypedFromObject(jp, ctxt)).thenReturn(expected); [EOL] Object result = deserializeWithType(jp, ctxt, typeDeserializer); [EOL] assertSame(expected, result); [EOL] }
public void testDeserializeWithObjectIdWhenIdPropNameMatchesCurrentName() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ObjectIdReader objectIdReader = mock(ObjectIdReader.class); [EOL] when(objectIdReader.propertyName).thenReturn("id"); [EOL] when(jp.getCurrentName()).thenReturn("id"); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_OBJECT); [EOL] YourDeserializer deserializer = new YourDeserializer(objectIdReader); [EOL] Object result = deserializer.deserializeWithObjectId(jp, ctxt); [EOL] verify(jp).getCurrentName(); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithObjectIdWhenIdPropNameDoesNotMatchCurrentName() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ObjectIdReader objectIdReader = mock(ObjectIdReader.class); [EOL] when(objectIdReader.propertyName).thenReturn("id"); [EOL] when(jp.getCurrentName()).thenReturn("name").thenReturn("id"); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] doNothing().when(jp).skipChildren(); [EOL] YourDeserializer deserializer = new YourDeserializer(objectIdReader); [EOL] Object result = deserializer.deserializeWithObjectId(jp, ctxt); [EOL] verify(jp, times(2)).getCurrentName(); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithObjectIdWhenIdPropNameDoesNotMatchAnyCurrentName() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ObjectIdReader objectIdReader = mock(ObjectIdReader.class); [EOL] when(objectIdReader.propertyName).thenReturn("id"); [EOL] when(jp.getCurrentName()).thenReturn("name1").thenReturn("name2"); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] doNothing().when(jp).skipChildren(); [EOL] YourDeserializer deserializer = new YourDeserializer(objectIdReader); [EOL] Object result = deserializer.deserializeWithObjectId(jp, ctxt); [EOL] verify(jp, times(2)).getCurrentName(); [EOL] assertNotNull(result); [EOL] }
public void testHandlePolymorphicWithSubDeserializerAndUnknownTokens() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] TokenBuffer unknownTokens = new TokenBuffer(jp, ctxt); [EOL] JsonDeserializer<Object> subDeser = mock(JsonDeserializer.class); [EOL] when(_findSubclassDeserializer(ctxt, bean, unknownTokens)).thenReturn(subDeser); [EOL] unknownTokens.writeStartObject(); // to balance writeEndObject call [EOL] Object result = handlePolymorphic(jp, ctxt, bean, unknownTokens); [EOL] verify(subDeser).deserialize(any(JsonParser.class), eq(ctxt), eq(bean)); [EOL] assertNotNull(result); [EOL] }
public void testHandlePolymorphicWithSubDeserializerAndNoUnknownTokens() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] JsonDeserializer<Object> subDeser = mock(JsonDeserializer.class); [EOL] when(_findSubclassDeserializer(ctxt, bean, null)).thenReturn(subDeser); [EOL] Object result = handlePolymorphic(jp, ctxt, bean, null); [EOL] verify(subDeser).deserialize(jp, ctxt, bean); [EOL] assertNotNull(result); [EOL] }
public void testHandlePolymorphicWithoutSubDeserializerAndUnknownTokens() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] TokenBuffer unknownTokens = new TokenBuffer(jp, ctxt); [EOL] when(_findSubclassDeserializer(ctxt, bean, unknownTokens)).thenReturn(null); [EOL] unknownTokens.writeStartObject(); // to balance writeEndObject call [EOL] Object result = handlePolymorphic(jp, ctxt, bean, unknownTokens); [EOL] verify(this, never())._findSubclassDeserializer(ctxt, bean, unknownTokens); [EOL] assertNotNull(result); [EOL] }
public void testHandlePolymorphicWithoutSubDeserializerAndNoUnknownTokens() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object bean = new Object(); [EOL] when(_findSubclassDeserializer(ctxt, bean, null)).thenReturn(null); [EOL] Object result = handlePolymorphic(jp, ctxt, bean, null); [EOL] verify(this, never())._findSubclassDeserializer(ctxt, bean, null); [EOL] assertNotNull(result); [EOL] }
protected JsonDeserializer<Object> _findSubclassDeserializer(DeserializationContext ctxt, Object bean, TokenBuffer unknownTokens) throws IOException, JsonProcessingException { [EOL] JsonDeserializer<Object> subDeser; [EOL] synchronized (this) { [EOL] subDeser = (_subDeserializers == null) ? null : _subDeserializers.get(new ClassKey(bean.getClass())); [EOL] } [EOL] if (subDeser != null) { [EOL] return subDeser; [EOL] } [EOL] JavaType type = ctxt.constructType(bean.getClass()); [EOL] subDeser = ctxt.findRootValueDeserializer(type); [EOL] if (subDeser != null) { [EOL] synchronized (this) { [EOL] if (_subDeserializers == null) { [EOL] _subDeserializers = new HashMap<ClassKey, JsonDeserializer<Object>>(); [EOL] } [EOL] _subDeserializers.put(new ClassKey(bean.getClass()), subDeser); [EOL] } [EOL] } [EOL] return subDeser; [EOL] }
protected final ArrayNode deserializeArray(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL] ArrayNode node = nodeFactory.arrayNode(); [EOL] while (true) { [EOL] JsonToken t = jp.nextToken(); [EOL] if (t == null) { [EOL] throw ctxt.mappingException("Unexpected end-of-input when binding data into ArrayNode"); [EOL] } [EOL] switch(t) { [EOL] case START_OBJECT: [EOL] node.add(deserializeObject(jp, ctxt, nodeFactory)); [EOL] break; [EOL] case START_ARRAY: [EOL] node.add(deserializeArray(jp, ctxt, nodeFactory)); [EOL] break; [EOL] case END_ARRAY: [EOL] return node; [EOL] case VALUE_STRING: [EOL] node.add(nodeFactory.textNode(jp.getText())); [EOL] break; [EOL] default: [EOL] node.add(deserializeAny(jp, ctxt, nodeFactory)); [EOL] break; [EOL] } [EOL] } [EOL] }
public void testDeserializeAnyWithStartObject() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isObject()); [EOL] }
public void testDeserializeAnyWithStartArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isArray()); [EOL] }
public void testDeserializeAnyWithFieldName() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isObject()); [EOL] }
public void testDeserializeAnyWithValueEmbeddedObjectNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(null); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isNull()); [EOL] }
public void testDeserializeAnyWithValueEmbeddedObjectByteArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] byte[] data = new byte[]{1, 2, 3}; [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(data); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isBinary()); [EOL] }
public void testDeserializeAnyWithValueEmbeddedObjectPojo() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] Object pojo = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(pojo); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isPojo()); [EOL] }
public void testDeserializeAnyWithValueString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("test"); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isTextual()); [EOL] assertEquals("test", result.textValue()); [EOL] }
public void testDeserializeAnyWithValueNumberIntUseBigInteger() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.BIG_INTEGER); [EOL] when(jp.getBigIntegerValue()).thenReturn(new BigInteger("12345678901234567890")); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isBigInteger()); [EOL] }
public void testDeserializeAnyWithValueNumberIntRegularInt() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.INT); [EOL] when(jp.getIntValue()).thenReturn(123); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isInt()); [EOL] assertEquals(123, result.intValue()); [EOL] }
public void testDeserializeAnyWithValueNumberIntLong() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.LONG); [EOL] when(jp.getLongValue()).thenReturn(123L); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isLong()); [EOL] assertEquals(123L, result.longValue()); [EOL] }
public void testDeserializeAnyWithValueNumberFloatUseBigDecimal() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.BIG_DECIMAL); [EOL] when(jp.getDecimalValue()).thenReturn(new BigDecimal("123.45")); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isBigDecimal()); [EOL] }
public void testDeserializeAnyWithValueNumberFloatDouble() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.DOUBLE); [EOL] when(jp.getDoubleValue()).thenReturn(123.45); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isDouble()); [EOL] assertEquals(123.45, result.doubleValue(), 0.0); [EOL] }
public void testDeserializeAnyWithValueTrue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isBoolean()); [EOL] assertTrue(result.booleanValue()); [EOL] }
public void testDeserializeAnyWithValueFalse() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isBoolean()); [EOL] assertFalse(result.booleanValue()); [EOL] }
public void testDeserializeAnyWithValueNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] JsonNode result = deserializeAny(jp, ctxt, nodeFactory); [EOL] assertNotNull(result); [EOL] assertTrue(result.isNull()); [EOL] }
public void testDeserializeAnyWithInvalidToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] when(jp.getCurrentToken()).thenReturn(null); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] deserializeAny(jp, ctxt, nodeFactory); [EOL] }); [EOL] }
@Override [EOL] public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL] final DeserializationConfig config = ctxt.getConfig(); [EOL] JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc); [EOL] if (custom != null) { [EOL] return custom; [EOL] } [EOL] if (type.isThrowable()) { [EOL] return buildThrowableDeserializer(ctxt, type, beanDesc); [EOL] } [EOL] if (type.isAbstract()) { [EOL] JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc); [EOL] if (concreteType != null) { [EOL] beanDesc = config.introspect(concreteType); [EOL] return buildBeanDeserializer(ctxt, concreteType, beanDesc); [EOL] } [EOL] } [EOL] @SuppressWarnings("unchecked") [EOL] JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc); [EOL] if (deser != null) { [EOL] return deser; [EOL] } [EOL] if (!isPotentialBeanType(type.getRawClass())) { [EOL] return null; [EOL] } [EOL] return buildBeanDeserializer(ctxt, type, beanDesc); [EOL] } [EOL] public BeanDeserializerFactory(DeserializerFactoryConfig config); [EOL] public DeserializerFactory withConfig(DeserializerFactoryConfig config); [EOL] protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; [EOL] protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; [EOL] protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); [EOL] protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; [EOL] protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; [EOL] protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; [EOL] protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; [EOL] protected boolean isPotentialBeanType(Class<?> type); [EOL] protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); [EOL] long serialVersionUID=Optional[1]; [EOL] Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }];
protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL] JsonDeserializer<?> deser = findDefaultDeserializer(ctxt, type, beanDesc); [EOL] if (deser != null) { [EOL] return deser; [EOL] } [EOL] Class<?> cls = type.getRawClass(); [EOL] if (AtomicReference.class.isAssignableFrom(cls)) { [EOL] TypeFactory tf = ctxt.getTypeFactory(); [EOL] JavaType[] params = tf.findTypeParameters(type, AtomicReference.class); [EOL] JavaType referencedType; [EOL] if (params == null || params.length < 1) { [EOL] referencedType = TypeFactory.unknownType(); [EOL] } else { [EOL] referencedType = params[0]; [EOL] } [EOL] return new JdkDeserializers.AtomicReferenceDeserializer(referencedType); [EOL] } [EOL] return findOptionalStdDeserializer(ctxt, type, beanDesc); [EOL] } [EOL] public BeanDeserializerFactory(DeserializerFactoryConfig config); [EOL] public DeserializerFactory withConfig(DeserializerFactoryConfig config); [EOL] protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; [EOL] protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; [EOL] protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); [EOL] protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; [EOL] protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; [EOL] protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; [EOL] protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; [EOL] protected boolean isPotentialBeanType(Class<?> type); [EOL] protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); [EOL] long serialVersionUID=1; [EOL] Class<?>[] INIT_CAUSE_PARAMS=new Class<?>[] { Throwable.class };
It seems there was a misunderstanding. The provided input text does not contain any comments, NL descriptions, or @Test annotations to remove. The text appears to be a series of method signatures and a method implementation from a Java class, possibly related to Jackson's deserialization process. If you need assistance with something else, such as generating unit test cases for the provided method, please let me know!
public void testAddObjectIdReaderWithNullObjectIdInfo() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] when(beanDesc.getObjectIdInfo()).thenReturn(null); [EOL] addObjectIdReader(ctxt, beanDesc, builder); [EOL] verify(builder, never()).setObjectIdReader(any(ObjectIdReader.class)); [EOL] }
public void testAddObjectIdReaderWithPropertyGenerator() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] ObjectIdInfo objectIdInfo = mock(ObjectIdInfo.class); [EOL] when(beanDesc.getObjectIdInfo()).thenReturn(objectIdInfo); [EOL] when(objectIdInfo.getGeneratorType()).thenReturn(ObjectIdGenerators.PropertyGenerator.class); [EOL] when(objectIdInfo.getPropertyName()).thenReturn("id"); [EOL] when(objectIdInfo.getScope()).thenReturn(Object.class); [EOL] SettableBeanProperty idProp = mock(SettableBeanProperty.class); [EOL] when(builder.findProperty("id")).thenReturn(idProp); [EOL] when(idProp.getType()).thenReturn(mock(JavaType.class)); [EOL] addObjectIdReader(ctxt, beanDesc, builder); [EOL] verify(builder).setObjectIdReader(any(ObjectIdReader.class)); [EOL] }
public void testAddObjectIdReaderWithNonPropertyGenerator() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] ObjectIdInfo objectIdInfo = mock(ObjectIdInfo.class); [EOL] when(beanDesc.getObjectIdInfo()).thenReturn(objectIdInfo); [EOL] when(objectIdInfo.getGeneratorType()).thenReturn(ObjectIdGenerators.IntSequenceGenerator.class); [EOL] when(ctxt.constructType(ObjectIdGenerators.IntSequenceGenerator.class)).thenReturn(mock(JavaType.class)); [EOL] when(ctxt.getTypeFactory()).thenReturn(mock(TypeFactory.class)); [EOL] when(ctxt.objectIdGeneratorInstance(any(), any())).thenReturn(mock(ObjectIdGenerator.class)); [EOL] addObjectIdReader(ctxt, beanDesc, builder); [EOL] verify(builder).setObjectIdReader(any(ObjectIdReader.class)); [EOL] }
public void testAddObjectIdReaderWithPropertyGeneratorAndMissingProperty() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanDeserializerBuilder builder = mock(BeanDeserializerBuilder.class); [EOL] ObjectIdInfo objectIdInfo = mock(ObjectIdInfo.class); [EOL] when(beanDesc.getObjectIdInfo()).thenReturn(objectIdInfo); [EOL] when(objectIdInfo.getGeneratorType()).thenReturn(ObjectIdGenerators.PropertyGenerator.class); [EOL] when(objectIdInfo.getPropertyName()).thenReturn("missingProperty"); [EOL] when(beanDesc.getBeanClass()).thenReturn((Class) Object.class); [EOL] when(builder.findProperty("missingProperty")).thenReturn(null); [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] addObjectIdReader(ctxt, beanDesc, builder); [EOL] }); [EOL] String expectedMessage = "Invalid Object Id definition for java.lang.Object: can not find property with name 'missingProperty'"; [EOL] String actualMessage = exception.getMessage(); [EOL] assertTrue(actualMessage.contains(expectedMessage)); [EOL] }
protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { [EOL] Map<String, AnnotatedMember> refs = beanDesc.findBackReferenceProperties(); [EOL] if (refs != null) { [EOL] for (Map.Entry<String, AnnotatedMember> en : refs.entrySet()) { [EOL] String name = en.getKey(); [EOL] AnnotatedMember m = en.getValue(); [EOL] Type genericType; [EOL] if (m instanceof AnnotatedMethod) { [EOL] genericType = ((AnnotatedMethod) m).getGenericParameterType(0); [EOL] } else { [EOL] genericType = m.getRawType(); [EOL] } [EOL] SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), m); [EOL] builder.addBackReferenceProperty(name, constructSettableProperty(ctxt, beanDesc, propDef, genericType)); [EOL] } [EOL] } [EOL] } [EOL] public BeanDeserializerFactory(DeserializerFactoryConfig config); [EOL] public DeserializerFactory withConfig(DeserializerFactoryConfig config); [EOL] protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; [EOL] protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; [EOL] protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; [EOL] protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); [EOL] protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; [EOL] protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; [EOL] protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; [EOL] protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; [EOL] protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; [EOL] protected boolean isPotentialBeanType(Class<?> type); [EOL] protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); [EOL] long serialVersionUID=1; [EOL] Class<?>[] INIT_CAUSE_PARAMS=new Class<?>[] { Throwable.class };
public void testSetDefaultFilterWithNonNull() { [EOL] SimpleFilterProvider provider = new SimpleFilterProvider(); [EOL] BeanPropertyFilter filter = new BeanPropertyFilter() { [EOL] }; [EOL] provider.setDefaultFilter(filter); [EOL] assertEquals(filter, provider.getDefaultFilter()); [EOL] }
public void testSetDefaultFilterWithNull() { [EOL] SimpleFilterProvider provider = new SimpleFilterProvider(); [EOL] provider.setDefaultFilter(null); [EOL] assertNull(provider.getDefaultFilter()); [EOL] }
public void testFindFilterWithExistingId() { [EOL] SimpleFilterProvider provider = new SimpleFilterProvider(); [EOL] BeanPropertyFilter filter = mock(BeanPropertyFilter.class); [EOL] provider.addFilter("existingFilterId", filter); [EOL] BeanPropertyFilter result = provider.findFilter("existingFilterId"); [EOL] assertNotNull(result); [EOL] assertEquals(filter, result); [EOL] }
public void testFindFilterWithDefaultFilter() { [EOL] SimpleFilterProvider provider = new SimpleFilterProvider(); [EOL] BeanPropertyFilter defaultFilter = mock(BeanPropertyFilter.class); [EOL] provider.setDefaultFilter(defaultFilter); [EOL] BeanPropertyFilter result = provider.findFilter("nonExistingFilterId"); [EOL] assertNotNull(result); [EOL] assertEquals(defaultFilter, result); [EOL] }
public void testFindFilterWithUnknownIdAndFailOnUnknownId() { [EOL] SimpleFilterProvider provider = new SimpleFilterProvider(); [EOL] provider.setFailOnUnknownId(true); [EOL] try { [EOL] provider.findFilter("unknownFilterId"); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithAdditionalKeySerializers_Null() { [EOL] SerializerFactory factory = new CustomSerializerFactory(); [EOL] SerializerFactory result = factory.withAdditionalKeySerializers(null); [EOL] assertNotNull(result); [EOL] }
public void testWithAdditionalKeySerializers_NonNull() { [EOL] SerializerFactory factory = new CustomSerializerFactory(); [EOL] Serializers additionalSerializers = new SimpleSerializers(); [EOL] SerializerFactory result = factory.withAdditionalKeySerializers(additionalSerializers); [EOL] assertNotNull(result); [EOL] assertNotSame(factory, result); [EOL] }
public void testCreateKeySerializerWithKeySerializers() { [EOL] SerializationConfig config = new SerializationConfig(...); // provide necessary initialization [EOL] JavaType keyType = ...; // provide necessary initialization [EOL] JsonSerializer<Object> defaultImpl = ...; // provide necessary initialization [EOL] _factoryConfig = new SerializerFactoryConfig(); [EOL] Serializers serializersMock = mock(Serializers.class); [EOL] JsonSerializer<?> keySerializerMock = mock(JsonSerializer.class); [EOL] when(serializersMock.findSerializer(any(SerializationConfig.class), any(JavaType.class), any(BeanDescription.class))) [EOL] .thenReturn(keySerializerMock); [EOL] _factoryConfig = _factoryConfig.withAdditionalKeySerializers(serializersMock); [EOL] JsonSerializer<Object> result = createKeySerializer(config, keyType, defaultImpl); [EOL] assertNotNull(result); [EOL] assertSame(keySerializerMock, result); [EOL] }
public void testCreateKeySerializerWithDefaultImpl() { [EOL] SerializationConfig config = new SerializationConfig(...); // provide necessary initialization [EOL] JavaType keyType = ...; // provide necessary initialization [EOL] JsonSerializer<Object> defaultImpl = mock(JsonSerializer.class); [EOL] _factoryConfig = new SerializerFactoryConfig(); [EOL] JsonSerializer<Object> result = createKeySerializer(config, keyType, defaultImpl); [EOL] assertNotNull(result); [EOL] assertSame(defaultImpl, result); [EOL] }
public void testCreateKeySerializerWithStdKeySerializer() { [EOL] SerializationConfig config = new SerializationConfig(...); // provide necessary initialization [EOL] JavaType keyType = ...; // provide necessary initialization [EOL] _factoryConfig = new SerializerFactoryConfig(); [EOL] JsonSerializer<Object> result = createKeySerializer(config, keyType, null); [EOL] assertNotNull(result); [EOL] assertTrue(StdKeySerializers.getStdKeySerializer(keyType).getClass().isInstance(result)); [EOL] }
public void testCreateKeySerializerWithSerializerModifiers() { [EOL] SerializationConfig config = new SerializationConfig(...); // provide necessary initialization [EOL] JavaType keyType = ...; // provide necessary initialization [EOL] JsonSerializer<Object> defaultImpl = ...; // provide necessary initialization [EOL] _factoryConfig = new SerializerFactoryConfig(); [EOL] BeanSerializerModifier modifierMock = mock(BeanSerializerModifier.class); [EOL] JsonSerializer<?> modifiedSerializerMock = mock(JsonSerializer.class); [EOL] when(modifierMock.modifyKeySerializer(any(SerializationConfig.class), any(JavaType.class), any(BeanDescription.class), any(JsonSerializer.class))) [EOL] .thenReturn(modifiedSerializerMock); [EOL] _factoryConfig = _factoryConfig.withSerializerModifier(modifierMock); [EOL] JsonSerializer<Object> result = createKeySerializer(config, keyType, defaultImpl); [EOL] assertNotNull(result); [EOL] assertSame(modifiedSerializerMock, result); [EOL] }
public void testCreateTypeSerializerWithNullTypeResolverBuilderAndNoDefaultTyper() { [EOL] SerializationConfig config = new SerializationConfig(...); // provide necessary initialization [EOL] JavaType baseType = ...; // provide necessary initialization [EOL] TypeSerializer result = createTypeSerializer(config, baseType); [EOL] assertNull(result); [EOL] }
public void testCreateTypeSerializerWithNonNullTypeResolverBuilder() { [EOL] SerializationConfig config = new SerializationConfig(...); // provide necessary initialization [EOL] JavaType baseType = ...; // provide necessary initialization [EOL] TypeSerializer result = createTypeSerializer(config, baseType); [EOL] assertNotNull(result); [EOL] }
public void testCreateTypeSerializerWithNullTypeResolverBuilderAndNonNullDefaultTyper() { [EOL] SerializationConfig config = new SerializationConfig(...); // provide necessary initialization [EOL] JavaType baseType = ...; // provide necessary initialization [EOL] TypeSerializer result = createTypeSerializer(config, baseType); [EOL] assertNotNull(result); [EOL] }
public void testFindSerializerByPrimaryTypeWithInetAddress() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(InetAddress.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] boolean staticTyping = false; [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); [EOL] assertTrue(result instanceof InetAddressSerializer); [EOL] }
public void testFindSerializerByPrimaryTypeWithTimeZone() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(TimeZone.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] boolean staticTyping = false; [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); [EOL] assertTrue(result instanceof TimeZoneSerializer); [EOL] }
public void testFindSerializerByPrimaryTypeWithCharset() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(java.nio.charset.Charset.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] boolean staticTyping = false; [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); [EOL] assertTrue(result instanceof ToStringSerializer); [EOL] }
public void testFindSerializerByPrimaryTypeWithNumber() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(Number.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] boolean staticTyping = false; [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); [EOL] assertTrue(result instanceof NumberSerializers.NumberSerializer); [EOL] }
public void testFindSerializerByPrimaryTypeWithEnum() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(Enum.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] boolean staticTyping = false; [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); [EOL] assertNotNull(result); [EOL] }
public void testFindSerializerByPrimaryTypeWithCalendar() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(Calendar.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] boolean staticTyping = false; [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); [EOL] assertTrue(result instanceof CalendarSerializer); [EOL] }
public void testFindSerializerByPrimaryTypeWithDate() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(java.util.Date.class); [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] boolean staticTyping = false; [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); [EOL] assertTrue(result instanceof DateSerializer); [EOL] }
public void testFindSerializerByPrimaryTypeWithOptionalStdSerializer() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(MyCustomType.class); // Replace with a type that triggers optional std serializer [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] boolean staticTyping = false; [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); [EOL] assertNotNull(result); [EOL] }
public void testFindSerializerByPrimaryTypeWithNull() { [EOL] SerializerProvider prov = null; // Mock or create instance [EOL] JavaType type = SimpleType.constructUnsafe(Object.class); // Use a type that does not match any condition [EOL] BeanDescription beanDesc = null; // Mock or create instance [EOL] boolean staticTyping = false; [EOL] JsonSerializer<?> result = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); [EOL] assertNull(result); [EOL] }
public void testBuildContainerSerializerWithStaticTypingAndNonContainerType() throws JsonMappingException { [EOL] SerializerProvider prov = createMockSerializerProvider(); [EOL] JavaType type = createMockJavaType(false, false, true, Object.class); [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] JsonSerializer<?> result = buildContainerSerializer(prov, type, beanDesc, false); [EOL] assertNotNull(result); [EOL] } [EOL] public void testBuildContainerSerializerWithMapLikeType() throws JsonMappingException { [EOL] SerializerProvider prov = createMockSerializerProvider(); [EOL] JavaType type = createMockJavaType(true, true, false, null); [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] JsonSerializer<?> result = buildContainerSerializer(prov, type, beanDesc, false); [EOL] assertNotNull(result); [EOL] } [EOL] public void testBuildContainerSerializerWithCollectionLikeType() throws JsonMappingException { [EOL] SerializerProvider prov = createMockSerializerProvider(); [EOL] JavaType type = createMockJavaType(true, false, true, null); [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] JsonSerializer<?> result = buildContainerSerializer(prov, type, beanDesc, false); [EOL] assertNotNull(result); [EOL] } [EOL] public void testBuildContainerSerializerWithArrayType() throws JsonMappingException { [EOL] SerializerProvider prov = createMockSerializerProvider(); [EOL] JavaType type = createMockJavaType(false, false, false, null); [EOL] BeanDescription beanDesc = createMockBeanDescription(); [EOL] JsonSerializer<?> result = buildContainerSerializer(prov, type, beanDesc, false); [EOL] assertNotNull(result); [EOL] }
private SerializerProvider createMockSerializerProvider() { [EOL] return null; // Replace with actual mock creation [EOL] } [EOL] private JavaType createMockJavaType(boolean isMapLikeType, boolean isTrueMapType, boolean isCollectionLikeType, Class<?> contentTypeClass) { [EOL] return null; // Replace with actual mock creation [EOL] } [EOL] private BeanDescription createMockBeanDescription() { [EOL] return null; // Replace with actual mock creation [EOL] }
public void testBuildEnumSerializerWithFormatShapeObject() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType type = ...; // Provide actual initialization [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(beanDesc.findExpectedFormat(null)).thenReturn(format); [EOL] when(format.getShape()).thenReturn(JsonFormat.Shape.OBJECT); [EOL] JsonSerializer<?> result = buildEnumSerializer(config, type, beanDesc); [EOL] assertNull(result); [EOL] verify((BasicBeanDescription) beanDesc).removeProperty("declaringClass"); [EOL] }
public void testBuildEnumSerializerWithoutFormatShapeObject() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType type = ...; // Provide actual initialization [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(beanDesc.findExpectedFormat(null)).thenReturn(format); [EOL] when(format.getShape()).thenReturn(JsonFormat.Shape.STRING); // Any shape other than OBJECT [EOL] JsonSerializer<?> result = buildEnumSerializer(config, type, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testBuildEnumSerializerWithSerializerModifiers() throws JsonMappingException { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType type = ...; // Provide actual initialization [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(beanDesc.findExpectedFormat(null)).thenReturn(format); [EOL] when(format.getShape()).thenReturn(JsonFormat.Shape.STRING); // Any shape other than OBJECT [EOL] when(_factoryConfig.hasSerializerModifiers()).thenReturn(true); [EOL] BeanSerializerModifier modifier = mock(BeanSerializerModifier.class); [EOL] when(_factoryConfig.serializerModifiers()).thenReturn(Collections.singletonList(modifier)); [EOL] JsonSerializer<?> originalSerializer = mock(JsonSerializer.class); [EOL] JsonSerializer<?> modifiedSerializer = mock(JsonSerializer.class); [EOL] when(modifier.modifyEnumSerializer(any(), any(), any(), any())).thenReturn(modifiedSerializer); [EOL] JsonSerializer<?> result = buildEnumSerializer(config, type, beanDesc); [EOL] assertSame(modifiedSerializer, result); [EOL] }
public void testSerializeWithFailOnEmptyBeansEnabled() throws IOException { [EOL] Object value = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.FAIL_ON_EMPTY_BEANS)).thenReturn(true); [EOL] try { [EOL] serialize(value, jgen, provider); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] verify(jgen, never()).writeStartObject(); [EOL] verify(jgen, never()).writeEndObject(); [EOL] }
public void testSerializeWithFailOnEmptyBeansDisabled() throws IOException { [EOL] Object value = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.FAIL_ON_EMPTY_BEANS)).thenReturn(false); [EOL] serialize(value, jgen, provider); [EOL] verify(jgen).writeStartObject(); [EOL] verify(jgen).writeEndObject(); [EOL] }
public void testFailForEmptyWithNonNullValue() throws JsonMappingException { [EOL] Object nonEmptyObject = new Object(); [EOL] try { [EOL] failForEmpty(nonEmptyObject); [EOL] fail("Expected JsonMappingException to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals("No serializer found for class " + nonEmptyObject.getClass().getName() + " and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) )", e.getMessage()); [EOL] } [EOL] }
public void testFailForEmptyWithNullValue() throws JsonMappingException { [EOL] Object nullObject = null; [EOL] try { [EOL] failForEmpty(nullObject); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testGetStaticMethods_NotResolved() { [EOL] ReflectionTestUtils.setField(instance, "_creatorsResolved", false); [EOL] ReflectionTestUtils.setField(instance, "_creatorMethods", null); [EOL] List<AnnotatedMethod> methods = instance.getStaticMethods(); [EOL] assertNotNull(methods); [EOL] assertTrue(instance._creatorsResolved); [EOL] }
public void testGetStaticMethods_AlreadyResolved() { [EOL] ReflectionTestUtils.setField(instance, "_creatorsResolved", true); [EOL] List<AnnotatedMethod> expectedMethods = new ArrayList<>(); [EOL] ReflectionTestUtils.setField(instance, "_creatorMethods", expectedMethods); [EOL] List<AnnotatedMethod> methods = instance.getStaticMethods(); [EOL] assertSame(expectedMethods, methods); [EOL] }
public void testResolveClassAnnotationsWithNonNullIntrospectorAndPrimaryMixIn() { [EOL] AnnotationIntrospector introspector = Mockito.mock(AnnotationIntrospector.class); [EOL] Class<?> primaryMixIn = Mockito.mock(Class.class); [EOL] Class<?> clazz = Mockito.mock(Class.class); [EOL] List<Class<?>> superTypes = new ArrayList<>(); [EOL] superTypes.add(Mockito.mock(Class.class)); // Add at least one element to trigger the loop [EOL] _annotationIntrospector = introspector; [EOL] _primaryMixIn = primaryMixIn; [EOL] _class = clazz; [EOL] _superTypes = superTypes; [EOL] resolveClassAnnotations(); [EOL] assertNotNull(_classAnnotations); [EOL] Mockito.verify(introspector, Mockito.times(1)).findMixInClassFor(clazz); [EOL] Mockito.verify(clazz, Mockito.atLeastOnce()).getDeclaredAnnotations(); [EOL] for (Class<?> cls : superTypes) { [EOL] Mockito.verify(introspector, Mockito.times(1)).findMixInClassFor(cls); [EOL] Mockito.verify(cls, Mockito.atLeastOnce()).getDeclaredAnnotations(); [EOL] } [EOL] Mockito.verify(introspector, Mockito.times(1)).findMixInClassFor(Object.class); [EOL] }
public void testResolveClassAnnotationsWithNonNullIntrospectorNoPrimaryMixIn() { [EOL] AnnotationIntrospector introspector = Mockito.mock(AnnotationIntrospector.class); [EOL] Class<?> clazz = Mockito.mock(Class.class); [EOL] List<Class<?>> superTypes = new ArrayList<>(); [EOL] superTypes.add(Mockito.mock(Class.class)); // Add at least one element to trigger the loop [EOL] _annotationIntrospector = introspector; [EOL] _primaryMixIn = null; // No primary mix-in [EOL] _class = clazz; [EOL] _superTypes = superTypes; [EOL] resolveClassAnnotations(); [EOL] assertNotNull(_classAnnotations); [EOL] Mockito.verify(clazz, Mockito.atLeastOnce()).getDeclaredAnnotations(); [EOL] for (Class<?> cls : superTypes) { [EOL] Mockito.verify(introspector, Mockito.times(1)).findMixInClassFor(cls); [EOL] Mockito.verify(cls, Mockito.atLeastOnce()).getDeclaredAnnotations(); [EOL] } [EOL] Mockito.verify(introspector, Mockito.times(1)).findMixInClassFor(Object.class); [EOL] }
public void testResolveClassAnnotationsWithNullIntrospector() { [EOL] Class<?> clazz = Mockito.mock(Class.class); [EOL] List<Class<?>> superTypes = new ArrayList<>(); [EOL] _annotationIntrospector = null; // No annotation introspector [EOL] _class = clazz; [EOL] _superTypes = superTypes; [EOL] resolveClassAnnotations(); [EOL] assertNotNull(_classAnnotations); [EOL] }
public void testResolveCreatorsWithNoDeclaredConstructorsAndNoMixIn() { [EOL] _class = SomeClassWithoutDeclaredConstructors.class; [EOL] _primaryMixIn = null; [EOL] _annotationIntrospector = null; [EOL] resolveCreators(); [EOL] assertTrue(_defaultConstructor == null); [EOL] assertTrue(_constructors.isEmpty()); [EOL] assertTrue(_creatorMethods.isEmpty()); [EOL] assertTrue(_creatorsResolved); [EOL] }
public void testResolveCreatorsWithDefaultConstructorAndIgnoredConstructors() { [EOL] _class = SomeClassWithDefaultAndIgnoredConstructors.class; [EOL] _primaryMixIn = null; [EOL] _annotationIntrospector = new AnnotationIntrospectorStub() { [EOL] @Override [EOL] public boolean hasIgnoreMarker(AnnotatedMember m) { [EOL] return !(m instanceof AnnotatedConstructor && ((AnnotatedConstructor) m).getParameterCount() == 0); [EOL] } [EOL] }; [EOL] resolveCreators(); [EOL] assertNotNull(_defaultConstructor); [EOL] assertTrue(_constructors.isEmpty()); // Ignored constructors should not be added [EOL] assertTrue(_creatorMethods.isEmpty()); [EOL] assertTrue(_creatorsResolved); [EOL] }
public void testResolveCreatorsWithStaticCreatorMethodsAndMixIn() { [EOL] _class = SomeClassWithStaticCreatorMethods.class; [EOL] _primaryMixIn = SomeMixin.class; [EOL] _annotationIntrospector = null; [EOL] resolveCreators(); [EOL] assertTrue(_defaultConstructor == null); [EOL] assertTrue(_constructors.isEmpty()); [EOL] assertFalse(_creatorMethods.isEmpty()); // Static methods should be added [EOL] assertTrue(_creatorsResolved); [EOL] }
public void testResolveCreatorsWithAnnotatedStaticCreatorMethods() { [EOL] _class = SomeClassWithAnnotatedStaticCreatorMethods.class; [EOL] _primaryMixIn = null; [EOL] _annotationIntrospector = new AnnotationIntrospectorStub() { [EOL] @Override [EOL] public boolean hasIgnoreMarker(AnnotatedMember m) { [EOL] return m.hasAnnotation(Ignore.class); [EOL] } [EOL] }; [EOL] resolveCreators(); [EOL] assertTrue(_defaultConstructor == null); [EOL] assertTrue(_constructors.isEmpty()); [EOL] assertTrue(_creatorMethods.stream().noneMatch(m -> m.hasAnnotation(Ignore.class))); [EOL] assertTrue(_creatorsResolved); [EOL] }
public void testResolveMemberMethods_NoMixinsNoAnnotationIntrospector() { [EOL] initTestEnvironment(null, null, null, null); [EOL] resolveMemberMethods(); [EOL] assertNotNull(_memberMethods); [EOL] assertTrue(_memberMethods.isEmpty()); [EOL] }
public void testResolveMemberMethods_WithMixinsNoAnnotationIntrospector() { [EOL] MixInResolver mockMixInResolver = createMockMixInResolver(); [EOL] initTestEnvironment(mockMixInResolver, null, null, null); [EOL] resolveMemberMethods(); [EOL] assertNotNull(_memberMethods); [EOL] assertFalse(_memberMethods.isEmpty()); [EOL] }
public void testResolveMemberMethods_NoMixinsWithAnnotationIntrospector() { [EOL] AnnotationIntrospector mockAnnotationIntrospector = createMockAnnotationIntrospector(); [EOL] initTestEnvironment(null, mockAnnotationIntrospector, null, null); [EOL] resolveMemberMethods(); [EOL] assertNotNull(_memberMethods); [EOL] }
public void testResolveMemberMethods_WithMixinsAndAnnotationIntrospector() { [EOL] MixInResolver mockMixInResolver = createMockMixInResolver(); [EOL] AnnotationIntrospector mockAnnotationIntrospector = createMockAnnotationIntrospector(); [EOL] initTestEnvironment(mockMixInResolver, mockAnnotationIntrospector, null, null); [EOL] resolveMemberMethods(); [EOL] assertNotNull(_memberMethods); [EOL] assertFalse(_memberMethods.isEmpty()); [EOL] } [EOL] private void initTestEnvironment(MixInResolver mixInResolver, AnnotationIntrospector annotationIntrospector, Class<?> clazz, List<Class<?>> superTypes) { [EOL] this._mixInResolver = mixInResolver; [EOL] this._annotationIntrospector = annotationIntrospector; [EOL] this._class = clazz; [EOL] this._superTypes = superTypes; [EOL] } [EOL] private MixInResolver createMockMixInResolver() { [EOL] return new MixInResolver() { [EOL] }; [EOL] } [EOL] private AnnotationIntrospector createMockAnnotationIntrospector() { [EOL] return new AnnotationIntrospector() { [EOL] }; [EOL] }
public void testResolveFieldsWithNullFoundFields() { [EOL] when(_findFields(_class, null)).thenReturn(null); [EOL] resolveFields(); [EOL] assertTrue(_fields.isEmpty()); [EOL] }
public void testResolveFieldsWithEmptyFoundFields() { [EOL] Map<String, AnnotatedField> emptyMap = Collections.emptyMap(); [EOL] when(_findFields(_class, null)).thenReturn(emptyMap); [EOL] resolveFields(); [EOL] assertTrue(_fields.isEmpty()); [EOL] }
public void testResolveFieldsWithNonEmptyFoundFields() { [EOL] Map<String, AnnotatedField> nonEmptyMap = new HashMap<>(); [EOL] nonEmptyMap.put("field1", new AnnotatedField()); [EOL] nonEmptyMap.put("field2", new AnnotatedField()); [EOL] when(_findFields(_class, null)).thenReturn(nonEmptyMap); [EOL] resolveFields(); [EOL] assertFalse(_fields.isEmpty()); [EOL] assertEquals(nonEmptyMap.size(), _fields.size()); [EOL] assertTrue(_fields.containsAll(nonEmptyMap.values())); [EOL] }
public void testAddClassMixIns_withNullMixin() { [EOL] AnnotationMap annotations = new AnnotationMap(); [EOL] Class<?> toMask = Object.class; [EOL] Class<?> mixin = null; [EOL] _addClassMixIns(annotations, toMask, mixin); [EOL] assertTrue(annotations.isEmpty()); [EOL] }
public void testAddClassMixIns_withNonNullMixinNoSuperTypes() { [EOL] AnnotationMap annotations = new AnnotationMap(); [EOL] Class<?> toMask = Object.class; [EOL] Class<?> mixin = String.class; // Assuming String.class has no custom annotations [EOL] _addClassMixIns(annotations, toMask, mixin); [EOL] assertTrue(annotations.isEmpty()); // Assuming String.class has no annotations to add [EOL] }
public void testAddClassMixIns_withNonNullMixinAndSuperTypes() { [EOL] AnnotationMap annotations = new AnnotationMap(); [EOL] Class<?> toMask = Number.class; [EOL] Class<?> mixin = Integer.class; // Assuming Integer.class or its supertypes have custom annotations [EOL] _addClassMixIns(annotations, toMask, mixin); [EOL] assertFalse(annotations.isEmpty()); // Assuming Integer.class or its supertypes have annotations to add [EOL] }
public void testAddConstructorMixIns_NoConstructors() { [EOL] _addConstructorMixIns(Mockito.mock(Class.class)); [EOL] } [EOL] public void testAddConstructorMixIns_WithDefaultConstructor() { [EOL] _defaultConstructor = Mockito.mock(AnnotatedConstructor.class); [EOL] Class<?> mixin = Mockito.mock(Class.class); [EOL] Constructor<?> ctor = Mockito.mock(Constructor.class); [EOL] Mockito.when(mixin.getDeclaredConstructors()).thenReturn(new Constructor<?>[]{ctor}); [EOL] Mockito.when(ctor.getParameterTypes()).thenReturn(new Class<?>[0]); [EOL] _addConstructorMixIns(mixin); [EOL] } [EOL] public void testAddConstructorMixIns_WithNonDefaultConstructors() { [EOL] _constructors = new ArrayList<>(); [EOL] AnnotatedConstructor annotatedConstructor = Mockito.mock(AnnotatedConstructor.class); [EOL] _constructors.add(annotatedConstructor); [EOL] Class<?> mixin = Mockito.mock(Class.class); [EOL] Constructor<?> ctor = Mockito.mock(Constructor.class); [EOL] Mockito.when(mixin.getDeclaredConstructors()).thenReturn(new Constructor<?>[]{ctor}); [EOL] Mockito.when(ctor.getParameterTypes()).thenReturn(new Class<?>[]{String.class}); [EOL] Mockito.when(ctor.getAnnotated()).thenReturn(ctor); [EOL] Mockito.when(annotatedConstructor.getAnnotated()).thenReturn(ctor); [EOL] _addConstructorMixIns(mixin); [EOL] } [EOL] public void testAddConstructorMixIns_WithNonMatchingConstructors() { [EOL] _constructors = new ArrayList<>(); [EOL] AnnotatedConstructor annotatedConstructor = Mockito.mock(AnnotatedConstructor.class); [EOL] _constructors.add(annotatedConstructor); [EOL] Class<?> mixin = Mockito.mock(Class.class); [EOL] Constructor<?> ctor = Mockito.mock(Constructor.class); [EOL] Constructor<?> anotherCtor = Mockito.mock(Constructor.class); [EOL] Mockito.when(mixin.getDeclaredConstructors()).thenReturn(new Constructor<?>[]{ctor}); [EOL] Mockito.when(ctor.getParameterTypes()).thenReturn(new Class<?>[]{String.class}); [EOL] Mockito.when(anotherCtor.getParameterTypes()).thenReturn(new Class<?>[]{String.class}); [EOL] Mockito.when(ctor.getAnnotated()).thenReturn(ctor); [EOL] Mockito.when(anotherCtor.getAnnotated()).thenReturn(anotherCtor); [EOL] Mockito.when(annotatedConstructor.getAnnotated()).thenReturn(anotherCtor); [EOL] _addConstructorMixIns(mixin); [EOL] }
public void testAddMemberMethods_NullMixInCls() { [EOL] Class<?> cls = MyClass.class; [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] _addMemberMethods(cls, methods, null, null); [EOL] } [EOL] public void testAddMemberMethods_WithMixInCls() { [EOL] Class<?> cls = MyClass.class; [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] Class<?> mixInCls = MyMixIn.class; [EOL] AnnotatedMethodMap mixIns = new AnnotatedMethodMap(); [EOL] _addMemberMethods(cls, methods, mixInCls, mixIns); [EOL] } [EOL] public void testAddMemberMethods_NullCls() { [EOL] _addMemberMethods(null, new AnnotatedMethodMap(), null, null); [EOL] } [EOL] public void testAddMemberMethods_NonIncludableMemberMethod() { [EOL] Class<?> cls = MyClassWithNonIncludableMethods.class; [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] _addMemberMethods(cls, methods, null, null); [EOL] } [EOL] public void testAddMemberMethods_ExistingMethodInMethods() { [EOL] Class<?> cls = MyClass.class; [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] Method existingMethod = cls.getDeclaredMethods()[0]; [EOL] AnnotatedMethod annotatedMethod = _constructMethod(existingMethod); [EOL] methods.add(annotatedMethod); [EOL] _addMemberMethods(cls, methods, null, null); [EOL] } [EOL] public void testAddMemberMethods_ExistingMethodInMixIns() { [EOL] Class<?> cls = MyClass.class; [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] Class<?> mixInCls = MyMixIn.class; [EOL] AnnotatedMethodMap mixIns = new AnnotatedMethodMap(); [EOL] Method mixInMethod = mixInCls.getDeclaredMethods()[0]; [EOL] AnnotatedMethod annotatedMixInMethod = _constructMethod(mixInMethod); [EOL] mixIns.add(annotatedMixInMethod); [EOL] _addMemberMethods(cls, methods, mixInCls, mixIns); [EOL] } [EOL] public void testAddMemberMethods_InterfaceMethodOverrides() { [EOL] Class<?> cls = MyClassImplementingInterface.class; [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] Class<?> interfaceCls = MyInterface.class; [EOL] for (Method m : interfaceCls.getDeclaredMethods()) { [EOL] AnnotatedMethod old = _constructMethod(m); [EOL] methods.add(old); [EOL] } [EOL] _addMemberMethods(cls, methods, null, null); [EOL] }
public void testAddMethodMixIns_WithValidMixIn() { [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] AnnotatedMethodMap mixIns = new AnnotatedMethodMap(); [EOL] Class<?> targetClass = TargetClass.class; [EOL] Class<?> mixInCls = MixInClass.class; [EOL] _addMethodMixIns(targetClass, methods, mixInCls, mixIns); [EOL] assertFalse(methods.isEmpty()); [EOL] assertFalse(mixIns.isEmpty()); [EOL] }
public void testAddMethodMixIns_WithNoMethodsInMixIn() { [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] AnnotatedMethodMap mixIns = new AnnotatedMethodMap(); [EOL] Class<?> targetClass = TargetClass.class; [EOL] Class<?> mixInCls = EmptyMixInClass.class; [EOL] _addMethodMixIns(targetClass, methods, mixInCls, mixIns); [EOL] assertTrue(methods.isEmpty()); [EOL] assertTrue(mixIns.isEmpty()); [EOL] }
public void testAddMethodMixIns_WithIncludableAndNonIncludableMethods() { [EOL] AnnotatedMethodMap methods = new AnnotatedMethodMap(); [EOL] AnnotatedMethodMap mixIns = new AnnotatedMethodMap(); [EOL] Class<?> targetClass = TargetClass.class; [EOL] Class<?> mixInCls = MixInWithIncludableAndNonIncludableMethods.class; [EOL] _addMethodMixIns(targetClass, methods, mixInCls, mixIns); [EOL] assertFalse(methods.isEmpty()); [EOL] assertEquals(expectedNumberOfIncludableMethods, mixIns.size()); [EOL] }
public void testFindFieldsWithNullParent() { [EOL] Map<String, AnnotatedField> fields = new LinkedHashMap<>(); [EOL] Map<String, AnnotatedField> result = _findFields(Object.class, fields); [EOL] assertTrue(result.isEmpty()); [EOL] } [EOL] public void testFindFieldsWithNonNullParent() { [EOL] Map<String, AnnotatedField> fields = new LinkedHashMap<>(); [EOL] Map<String, AnnotatedField> result = _findFields(ChildClass.class, fields); [EOL] assertFalse(result.isEmpty()); [EOL] assertNotNull(result.get("childField")); [EOL] } [EOL] public void testFindFieldsWithMixIn() { [EOL] Map<String, AnnotatedField> fields = new LinkedHashMap<>(); [EOL] _mixInResolver = new MixInResolver() { [EOL] @Override [EOL] public Class<?> findMixInClassFor(Class<?> cls) { [EOL] return cls == ChildClass.class ? MixInClass.class : null; [EOL] } [EOL] }; [EOL] Map<String, AnnotatedField> result = _findFields(ChildClass.class, fields); [EOL] assertFalse(result.isEmpty()); [EOL] assertNotNull(result.get("mixinField")); [EOL] }
public void testFindFieldsWithoutMixIn() { [EOL] Map<String, AnnotatedField> fields = new LinkedHashMap<>(); [EOL] _mixInResolver = new MixInResolver() { [EOL] @Override [EOL] public Class<?> findMixInClassFor(Class<?> cls) { [EOL] return null; [EOL] } [EOL] }; [EOL] Map<String, AnnotatedField> result = _findFields(ChildClass.class, fields); [EOL] assertFalse(result.isEmpty()); [EOL] assertNull(result.get("mixinField")); [EOL] }
public void testAddFieldMixIns_WithEmptyFields() { [EOL] Map<String, AnnotatedField> fields = new HashMap<>(); [EOL] _addFieldMixIns(TargetClass.class, MixInClass.class, fields); [EOL] assertTrue(fields.isEmpty()); [EOL] }
public void testAddFieldMixIns_WithNonIncludableFields() { [EOL] Map<String, AnnotatedField> fields = new HashMap<>(); [EOL] _addFieldMixIns(TargetClass.class, MixInClassWithNonIncludableFields.class, fields); [EOL] assertTrue(fields.isEmpty()); [EOL] }
public void testAddFieldMixIns_WithIncludableFields() { [EOL] Map<String, AnnotatedField> fields = new HashMap<>(); [EOL] _addFieldMixIns(TargetClass.class, MixInClassWithIncludableFields.class, fields); [EOL] assertFalse(fields.isEmpty()); [EOL] }
public void testAddFieldMixIns_WithExistingFields() { [EOL] Map<String, AnnotatedField> fields = new HashMap<>(); [EOL] AnnotatedField existingField = new AnnotatedField(...); // Provide necessary parameters [EOL] fields.put("existingFieldName", existingField); [EOL] _addFieldMixIns(TargetClass.class, MixInClassWithIncludableFields.class, fields); [EOL] assertEquals(1, fields.size()); [EOL] assertNotNull(fields.get("existingFieldName")); [EOL] }
public void testAddFieldMixIns_WithOverrideFields() { [EOL] Map<String, AnnotatedField> fields = new HashMap<>(); [EOL] AnnotatedField existingField = new AnnotatedField(...); // Provide necessary parameters [EOL] fields.put("fieldNameToOverride", existingField); [EOL] _addFieldMixIns(TargetClass.class, MixInClassWithIncludableFields.class, fields); [EOL] AnnotatedField overriddenField = fields.get("fieldNameToOverride"); [EOL] assertNotNull(overriddenField); [EOL] }
public void test_constructMethodWithNullIntrospector() { [EOL] Method method = String.class.getMethod("toString"); [EOL] MyClass instance = new MyClass(null); // Assuming the constructor takes an AnnotationIntrospector [EOL] AnnotatedMethod result = instance._constructMethod(method); [EOL] assertNotNull(result); [EOL] assertEquals(method, result.getAnnotated()); [EOL] assertTrue(result.getAnnotationMap().isEmpty()); [EOL] }
public void test_constructMethodWithNonNullIntrospector() { [EOL] Method method = String.class.getMethod("toString"); [EOL] AnnotationIntrospector introspector = mock(AnnotationIntrospector.class); [EOL] when(introspector.collectRelevantAnnotations(method.getDeclaredAnnotations())) [EOL] .thenReturn(someAnnotationMap); // Replace with actual annotation map [EOL] MyClass instance = new MyClass(introspector); [EOL] AnnotatedMethod result = instance._constructMethod(method); [EOL] assertNotNull(result); [EOL] assertEquals(method, result.getAnnotated()); [EOL] assertEquals(someAnnotationMap, result.getAnnotationMap()); // Replace with actual assertion [EOL] }
public void testConstructConstructorWithNullIntrospectorAndDefaultCtor() { [EOL] Constructor<?> ctor = Object.class.getDeclaredConstructors()[0]; [EOL] AnnotatedConstructor result = _constructConstructor(ctor, true); [EOL] assertNotNull(result); [EOL] }
public void testConstructConstructorWithNullIntrospectorAndNonDefaultCtor() { [EOL] Constructor<?> ctor = Object.class.getDeclaredConstructors()[0]; [EOL] AnnotatedConstructor result = _constructConstructor(ctor, false); [EOL] assertNotNull(result); [EOL] }
public void testConstructConstructorWithMismatchedAnnotations() { [EOL] Constructor<?> ctor = SampleEnum.class.getDeclaredConstructors()[0]; [EOL] try { [EOL] AnnotatedConstructor result = _constructConstructor(ctor, false); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("Internal error: constructor for " + ctor.getDeclaringClass().getName() + " has mismatch: 2 parameters; 0 sets of annotations", e.getMessage()); [EOL] } [EOL] }
public void testConstructConstructorWithEnumAndCorrectAnnotations() { [EOL] Constructor<?> ctor = SampleEnum.class.getDeclaredConstructors()[0]; [EOL] AnnotatedConstructor result = _constructConstructor(ctor, false); [EOL] assertNotNull(result); [EOL] }
public void testConstructConstructorWithMemberClassAndCorrectAnnotations() { [EOL] Constructor<?> ctor = SampleMemberClass.class.getDeclaredConstructors()[0]; [EOL] AnnotatedConstructor result = _constructConstructor(ctor, false); [EOL] assertNotNull(result); [EOL] }
public void testConstructCreatorMethodWithNullIntrospector() { [EOL] Method method = MyClass.class.getDeclaredMethod("myMethod"); [EOL] _setAnnotationIntrospector(null); [EOL] AnnotatedMethod annotatedMethod = _constructCreatorMethod(method); [EOL] assertNotNull(annotatedMethod); [EOL] assertEquals(method, annotatedMethod.getAnnotated()); [EOL] assertTrue(annotatedMethod.getAnnotations().isEmpty()); [EOL] for (AnnotationMap paramAnnotations : annotatedMethod.getParameterAnnotations()) { [EOL] assertTrue(paramAnnotations.isEmpty()); [EOL] } [EOL] }
public void testConstructCreatorMethodWithNonNullIntrospector() { [EOL] Method method = MyClass.class.getDeclaredMethod("myMethod"); [EOL] _setAnnotationIntrospector(new SomeAnnotationIntrospector()); [EOL] AnnotatedMethod annotatedMethod = _constructCreatorMethod(method); [EOL] assertNotNull(annotatedMethod); [EOL] assertEquals(method, annotatedMethod.getAnnotated()); [EOL] assertFalse(annotatedMethod.getAnnotations().isEmpty()); [EOL] for (AnnotationMap paramAnnotations : annotatedMethod.getParameterAnnotations()) { [EOL] assertFalse(paramAnnotations.isEmpty()); [EOL] } [EOL] }
public void test_constructFieldWithNullIntrospector() { [EOL] Field f = String.class.getDeclaredFields()[0]; // Assuming String has at least one field [EOL] MyObjectMapper objectMapper = new MyObjectMapper(null); // Assuming MyObjectMapper is a subclass with _annotationIntrospector field [EOL] AnnotatedField result = objectMapper._constructField(f); [EOL] assertNotNull(result); [EOL] assertEquals(f, result.getAnnotated()); [EOL] assertTrue(result.getAnnotationMap().isEmpty()); [EOL] }
public void test_constructFieldWithNonNullIntrospector() { [EOL] Field f = String.class.getDeclaredFields()[0]; // Assuming String has at least one field [EOL] AnnotationIntrospector introspector = new MyAnnotationIntrospector(); // Assuming MyAnnotationIntrospector is a concrete subclass [EOL] MyObjectMapper objectMapper = new MyObjectMapper(introspector); // Assuming MyObjectMapper is a subclass with _annotationIntrospector field [EOL] AnnotatedField result = objectMapper._constructField(f); [EOL] assertNotNull(result); [EOL] assertEquals(f, result.getAnnotated()); [EOL] assertFalse(result.getAnnotationMap().isEmpty()); // Assuming the field has annotations and MyAnnotationIntrospector does not return an empty map [EOL] }
private AnnotationMap _emptyAnnotationMap() { [EOL] return new AnnotationMap(); [EOL] }
public void testEmptyAnnotationMapsZeroCount() { [EOL] AnnotationMap[] result = _emptyAnnotationMaps(0); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testEmptyAnnotationMapsPositiveCount() { [EOL] int count = 3; [EOL] AnnotationMap[] result = _emptyAnnotationMaps(count); [EOL] assertNotNull(result); [EOL] assertEquals(count, result.length); [EOL] for (AnnotationMap map : result) { [EOL] assertNotNull(map); [EOL] } [EOL] }
public void testFindDefaultImplDeserializerWithNullDefaultImplAndFailOnInvalidSubtypeDisabled() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)).thenReturn(false); [EOL] JsonDeserializer<Object> result = _findDefaultImplDeserializer(ctxt); [EOL] assertSame(NullifyingDeserializer.instance, result); [EOL] }
public void testFindDefaultImplDeserializerWithNullDefaultImplAndFailOnInvalidSubtypeEnabled() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE)).thenReturn(true); [EOL] JsonDeserializer<Object> result = _findDefaultImplDeserializer(ctxt); [EOL] assertNull(result); [EOL] }
public void testFindDefaultImplDeserializerWithNonNullDefaultImplAndNoClass() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] _defaultImpl = JavaType.constructFromCanonical(NoClass.class.getCanonicalName()); [EOL] JsonDeserializer<Object> result = _findDefaultImplDeserializer(ctxt); [EOL] assertSame(NullifyingDeserializer.instance, result); [EOL] }
public void testFindDefaultImplDeserializerWithNonNullDefaultImplAndValidClass() throws IOException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] _defaultImpl = JavaType.constructFromCanonical(String.class.getCanonicalName()); [EOL] _defaultImplDeserializer = mock(JsonDeserializer.class); [EOL] when(ctxt.findContextualValueDeserializer(_defaultImpl, _property)).thenReturn(_defaultImplDeserializer); [EOL] JsonDeserializer<Object> result = _findDefaultImplDeserializer(ctxt); [EOL] assertSame(_defaultImplDeserializer, result); [EOL] }
public void testAddMappingWithSameSuperAndSubType() { [EOL] SimpleAbstractTypeResolver resolver = new SimpleAbstractTypeResolver(); [EOL] try { [EOL] resolver.addMapping(SomeAbstractClass.class, SomeAbstractClass.class); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Can not add mapping from class to itself", e.getMessage()); [EOL] } [EOL] }
public void testAddMappingWithNonAssignableSubType() { [EOL] SimpleAbstractTypeResolver resolver = new SimpleAbstractTypeResolver(); [EOL] try { [EOL] resolver.addMapping(SomeAbstractClass.class, SomeOtherClass.class); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("as latter is not a subtype of former")); [EOL] } [EOL] }
public void testAddMappingWithNonAbstractSuperType() { [EOL] SimpleAbstractTypeResolver resolver = new SimpleAbstractTypeResolver(); [EOL] try { [EOL] resolver.addMapping(SomeConcreteClass.class, SomeSubClassOfConcreteClass.class); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("since it is not abstract")); [EOL] } [EOL] }
public void testAddMappingWithValidArguments() { [EOL] SimpleAbstractTypeResolver resolver = new SimpleAbstractTypeResolver(); [EOL] resolver = resolver.addMapping(SomeAbstractClass.class, SomeSubClassOfAbstractClass.class); [EOL] assertNotNull(resolver); [EOL] assertEquals(SomeSubClassOfAbstractClass.class, resolver.findTypeMapping(SomeAbstractClass.class)); [EOL] }
public void testFindTypeMappingWithUnmappedClass() { [EOL] DeserializationConfig config = new DeserializationConfig(); [EOL] JavaType type = new JavaType(UnmappedClass.class); [EOL] TypeMapping mapping = new TypeMapping(); [EOL] JavaType result = mapping.findTypeMapping(config, type); [EOL] assertNull(result); [EOL] }
public void testFindTypeMappingWithMappedClass() { [EOL] DeserializationConfig config = new DeserializationConfig(); [EOL] JavaType type = new JavaType(MappedClass.class); [EOL] TypeMapping mapping = new TypeMapping(); [EOL] mapping.addMapping(MappedClass.class, MappedClassDestination.class); [EOL] JavaType result = mapping.findTypeMapping(config, type); [EOL] assertNotNull(result); [EOL] assertEquals(MappedClassDestination.class, result.getRawClass()); [EOL] }
public void testForDeserializationWithCachedDesc() { [EOL] DeserializationConfig cfg = createDeserializationConfigMock(); [EOL] JavaType type = createJavaTypeMock(); [EOL] MixInResolver r = createMixInResolverMock(); [EOL] BasicBeanDescription expectedDesc = createBasicBeanDescriptionMock(); [EOL] BeanDescriptionCache cache = createBeanDescriptionCacheWithCachedDesc(type, expectedDesc); [EOL] BasicClassIntrospector introspector = new BasicClassIntrospector(cache); [EOL] BasicBeanDescription result = introspector.forDeserialization(cfg, type, r); [EOL] assertSame(expectedDesc, result); [EOL] }
public void testForDeserializationWithoutCachedDesc() { [EOL] DeserializationConfig cfg = createDeserializationConfigMock(); [EOL] JavaType type = createJavaTypeMock(); [EOL] MixInResolver r = createMixInResolverMock(); [EOL] BasicBeanDescription expectedDesc = createBasicBeanDescriptionMock(); [EOL] BeanDescriptionCache cache = createBeanDescriptionCacheWithoutCachedDesc(); [EOL] BasicClassIntrospector introspector = new BasicClassIntrospector(cache); [EOL] BasicBeanDescription result = introspector.forDeserialization(cfg, type, r); [EOL] assertNotNull(result); [EOL] verifyNewBasicBeanDescriptionForDeserialization(result, cfg, type, r); [EOL] }
public void testFindCachedDescWithStringType() { [EOL] JavaType stringType = TypeFactory.defaultInstance().constructType(String.class); [EOL] BasicBeanDescription result = _findCachedDesc(stringType); [EOL] assertNotNull(result); [EOL] assertSame(STRING_DESC, result); [EOL] }
public void testFindCachedDescWithBooleanType() { [EOL] JavaType booleanType = TypeFactory.defaultInstance().constructType(Boolean.TYPE); [EOL] BasicBeanDescription result = _findCachedDesc(booleanType); [EOL] assertNotNull(result); [EOL] assertSame(BOOLEAN_DESC, result); [EOL] }
public void testFindCachedDescWithIntegerType() { [EOL] JavaType integerType = TypeFactory.defaultInstance().constructType(Integer.TYPE); [EOL] BasicBeanDescription result = _findCachedDesc(integerType); [EOL] assertNotNull(result); [EOL] assertSame(INT_DESC, result); [EOL] }
public void testFindCachedDescWithLongType() { [EOL] JavaType longType = TypeFactory.defaultInstance().constructType(Long.TYPE); [EOL] BasicBeanDescription result = _findCachedDesc(longType); [EOL] assertNotNull(result); [EOL] assertSame(LONG_DESC, result); [EOL] }
public void testFindCachedDescWithUnrecognizedType() { [EOL] JavaType unrecognizedType = TypeFactory.defaultInstance().constructType(Object.class); [EOL] BasicBeanDescription result = _findCachedDesc(unrecognizedType); [EOL] assertNull(result); [EOL] }
public void testArrayBlockingQueueDeserializerWithNonNullParameters() { [EOL] JavaType collectionType = mock(JavaType.class); [EOL] JsonDeserializer<Object> valueDeser = mock(JsonDeserializer.class); [EOL] TypeDeserializer valueTypeDeser = mock(TypeDeserializer.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] JsonDeserializer<Object> delegateDeser = mock(JsonDeserializer.class); [EOL] ArrayBlockingQueueDeserializer deserializer = new ArrayBlockingQueueDeserializer( [EOL] collectionType, valueDeser, valueTypeDeser, valueInstantiator, delegateDeser [EOL] ); [EOL] assertNotNull(deserializer); [EOL] }
public void testWithResolvedSameDeserializers() { [EOL] JsonDeserializer<?> dd = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> vd = mock(JsonDeserializer.class); [EOL] TypeDeserializer vtd = mock(TypeDeserializer.class); [EOL] ArrayBlockingQueueDeserializer original = new ArrayBlockingQueueDeserializer(null, vd, vtd, null, dd); [EOL] ArrayBlockingQueueDeserializer result = original.withResolved(dd, vd, vtd); [EOL] assertSame("Should return the same object when deserializers are the same", original, result); [EOL] }
public void testWithResolvedDifferentValueDeserializer() { [EOL] JsonDeserializer<?> dd = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> vd1 = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> vd2 = mock(JsonDeserializer.class); [EOL] TypeDeserializer vtd = mock(TypeDeserializer.class); [EOL] ArrayBlockingQueueDeserializer original = new ArrayBlockingQueueDeserializer(null, vd1, vtd, null, dd); [EOL] ArrayBlockingQueueDeserializer result = original.withResolved(dd, vd2, vtd); [EOL] assertNotSame("Should not return the same object when value deserializer is different", original, result); [EOL] }
public void testWithResolvedDifferentTypeDeserializer() { [EOL] JsonDeserializer<?> dd = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> vd = mock(JsonDeserializer.class); [EOL] TypeDeserializer vtd1 = mock(TypeDeserializer.class); [EOL] TypeDeserializer vtd2 = mock(TypeDeserializer.class); [EOL] ArrayBlockingQueueDeserializer original = new ArrayBlockingQueueDeserializer(null, vd, vtd1, null, dd); [EOL] ArrayBlockingQueueDeserializer result = original.withResolved(dd, vd, vtd2); [EOL] assertNotSame("Should not return the same object when type deserializer is different", original, result); [EOL] }
public void testWithResolvedDifferentDelegateDeserializer() { [EOL] JsonDeserializer<?> dd1 = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> dd2 = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> vd = mock(JsonDeserializer.class); [EOL] TypeDeserializer vtd = mock(TypeDeserializer.class); [EOL] ArrayBlockingQueueDeserializer original = new ArrayBlockingQueueDeserializer(null, vd, vtd, null, dd1); [EOL] ArrayBlockingQueueDeserializer result = original.withResolved(dd2, vd, vtd); [EOL] assertNotSame("Should not return the same object when delegate deserializer is different", original, result); [EOL] }
public void testDeserializeWithDelegateDeserializer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<Object> expectedResult = mock(Collection.class); [EOL] JsonDeserializer<Object> delegateDeserializer = mock(JsonDeserializer.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] when(_delegateDeserializer).thenReturn(delegateDeserializer); [EOL] when(delegateDeserializer.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] when(valueInstantiator.createUsingDelegate(ctxt, new Object())).thenReturn(expectedResult); [EOL] Collection<Object> result = deserialize(jp, ctxt); [EOL] assertSame(expectedResult, result); [EOL] }
public void testDeserializeWithEmptyString() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<Object> expectedResult = mock(Collection.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(""); [EOL] when(valueInstantiator.createFromString(ctxt, "")).thenReturn(expectedResult); [EOL] Collection<Object> result = deserialize(jp, ctxt); [EOL] assertSame(expectedResult, result); [EOL] }
public void testDeserializeWithNonEmptyStringToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("non-empty"); [EOL] deserialize(jp, ctxt, null); // This line is to ensure coverage, the actual test would depend on the implementation of 'deserialize' [EOL] }
public void testDeserializeWithNonStringValueToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); // Use a different token that is not VALUE_STRING [EOL] deserialize(jp, ctxt, null); // This line is to ensure coverage, the actual test would depend on the implementation of 'deserialize' [EOL] }
public void testDeserializeWithNonArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<Object> result0 = new ArrayBlockingQueue<Object>(1); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(false); [EOL] Collection<Object> result = deserialize(jp, ctxt, result0); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ArrayBlockingQueue); [EOL] assertEquals(1, result.size()); [EOL] }
public void testDeserializeWithEmptyArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<Object> result0 = null; [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] Collection<Object> result = deserialize(jp, ctxt, result0); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ArrayBlockingQueue); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testDeserializeWithNonNullValues() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<Object> result0 = new ArrayList<Object>(); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] _valueDeserializer = valueDes; [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_ARRAY); [EOL] when(valueDes.deserialize(jp, ctxt)).thenReturn("test"); [EOL] Collection<Object> result = deserialize(jp, ctxt, result0); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.size()); [EOL] assertTrue(result.contains("test")); [EOL] }
public void testDeserializeWithTypeDeserializer() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Collection<Object> result0 = null; [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] _valueDeserializer = valueDes; [EOL] _valueTypeDeserializer = typeDeser; [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_ARRAY); [EOL] when(valueDes.deserializeWithType(jp, ctxt, typeDeser)).thenReturn("test"); [EOL] Collection<Object> result = deserialize(jp, ctxt, result0); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof ArrayBlockingQueue); [EOL] assertEquals(1, result.size()); [EOL] assertTrue(result.contains("test")); [EOL] }
public void testIdFromWithEnumClass() { [EOL] setUpBaseType(EnumClass.class); // EnumClass is a placeholder for an actual enum type [EOL] String result = _idFrom(EnumClass.VALUE, EnumClass.class); [EOL] assertEquals("Expected enum class name", EnumClass.class.getName(), result); [EOL] }
public void testIdFromWithNonEnumSubclassOfEnum() { [EOL] setUpBaseType(NonEnumSubclass.class); // NonEnumSubclass is a placeholder for an actual class that is a subclass of an enum [EOL] String result = _idFrom(NonEnumSubclass.VALUE, NonEnumSubclass.class); [EOL] assertEquals("Expected superclass enum name", NonEnumSubclass.class.getSuperclass().getName(), result); [EOL] }
public void testIdFromWithJavaUtilClass() { [EOL] setUpBaseType(ArrayList.class); [EOL] String result = _idFrom(new ArrayList<>(), ArrayList.class); [EOL] assertEquals("Expected canonical name for ArrayList", "java.util.ArrayList", result); [EOL] }
public void testIdFromWithEnumSet() { [EOL] setUpBaseType(EnumSet.class); [EOL] EnumSet<EnumClass> enumSet = EnumSet.noneOf(EnumClass.class); [EOL] String result = _idFrom(enumSet, EnumSet.class); [EOL] assertEquals("Expected canonical name for EnumSet", "java.util.EnumSet<EnumClass>", result); [EOL] }
public void testIdFromWithEnumMap() { [EOL] setUpBaseType(EnumMap.class); [EOL] EnumMap<EnumClass, Object> enumMap = new EnumMap<>(EnumClass.class); [EOL] String result = _idFrom(enumMap, EnumMap.class); [EOL] assertEquals("Expected canonical name for EnumMap", "java.util.EnumMap<EnumClass,java.lang.Object>", result); [EOL] }
public void testIdFromWithInnerClass() { [EOL] setUpBaseType(OuterClass.InnerClass.class); [EOL] String result = _idFrom(new OuterClass.InnerClass(), OuterClass.InnerClass.class); [EOL] assertEquals("Expected name for inner class", OuterClass.InnerClass.class.getName(), result); [EOL] }
public void testIdFromWithStaticInnerClass() { [EOL] setUpBaseType(OuterClass.StaticInnerClass.class); [EOL] String result = _idFrom(new OuterClass.StaticInnerClass(), OuterClass.StaticInnerClass.class); [EOL] assertEquals("Expected name for static inner class", OuterClass.StaticInnerClass.class.getName(), result); [EOL] }
public void testBuildWriterWithContentTypeSerializerAndNonNullSerializationType() { [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] JavaType declaredType = mock(JavaType.class); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] TypeSerializer contentTypeSer = mock(TypeSerializer.class); [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] boolean defaultUseStaticTyping = false; [EOL] when(declaredType.getContentType()).thenReturn(mock(JavaType.class)); [EOL] when(declaredType.withContentTypeHandler(any())).thenReturn(declaredType); [EOL] BeanPropertyWriter result = buildWriter(propDef, declaredType, ser, typeSer, contentTypeSer, am, defaultUseStaticTyping); [EOL] assertNotNull(result); [EOL] }
public void testBuildWriterWithNullSerializationTypeAndNonNullContentTypeSerializer() { [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] JavaType declaredType = mock(JavaType.class); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] TypeSerializer contentTypeSer = mock(TypeSerializer.class); [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] boolean defaultUseStaticTyping = false; [EOL] when(declaredType.getContentType()).thenReturn(null); [EOL] try { [EOL] buildWriter(propDef, declaredType, ser, typeSer, contentTypeSer, am, defaultUseStaticTyping); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testBuildWriterWithSerializationInclusionNonDefault() { [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] JavaType declaredType = mock(JavaType.class); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] boolean defaultUseStaticTyping = false; [EOL] when(propDef.getName()).thenReturn("propertyName"); [EOL] when(_annotationIntrospector.findSerializationInclusion(am, _outputProps)).thenReturn(JsonInclude.Include.NON_DEFAULT); [EOL] BeanPropertyWriter result = buildWriter(propDef, declaredType, ser, typeSer, null, am, defaultUseStaticTyping); [EOL] assertNotNull(result); [EOL] assertEquals(BeanPropertyWriter.MARKER_FOR_EMPTY, result.getNullSerializer()); [EOL] }
public void testBuildWriterWithSerializationInclusionNonEmpty() { [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] JavaType declaredType = mock(JavaType.class); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] boolean defaultUseStaticTyping = false; [EOL] when(_annotationIntrospector.findSerializationInclusion(am, _outputProps)).thenReturn(JsonInclude.Include.NON_EMPTY); [EOL] BeanPropertyWriter result = buildWriter(propDef, declaredType, ser, typeSer, null, am, defaultUseStaticTyping); [EOL] assertNotNull(result); [EOL] assertTrue(result.willSuppressNulls()); [EOL] }
public void testBuildWriterWithSerializationInclusionNonNull() { [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] JavaType declaredType = mock(JavaType.class); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] boolean defaultUseStaticTyping = false; [EOL] when(_annotationIntrospector.findSerializationInclusion(am, _outputProps)).thenReturn(JsonInclude.Include.NON_NULL); [EOL] BeanPropertyWriter result = buildWriter(propDef, declaredType, ser, typeSer, null, am, defaultUseStaticTyping); [EOL] assertNotNull(result); [EOL] assertTrue(result.willSuppressNulls()); [EOL] }
public void testBuildWriterWithSerializationInclusionAlwaysAndContainerType() { [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] JavaType declaredType = mock(JavaType.class); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] boolean defaultUseStaticTyping = false; [EOL] when(declaredType.isContainerType()).thenReturn(true); [EOL] when(_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)).thenReturn(false); [EOL] when(_annotationIntrospector.findSerializationInclusion(am, _outputProps)).thenReturn(JsonInclude.Include.ALWAYS); [EOL] BeanPropertyWriter result = buildWriter(propDef, declaredType, ser, typeSer, null, am, defaultUseStaticTyping); [EOL] assertNotNull(result); [EOL] assertEquals(BeanPropertyWriter.MARKER_FOR_EMPTY, result.getNullSerializer()); [EOL] }
public void testBuildWriterWithUnwrappingNameTransformer() { [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] JavaType declaredType = mock(JavaType.class); [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] AnnotatedMember am = mock(AnnotatedMember.class); [EOL] boolean defaultUseStaticTyping = false; [EOL] NameTransformer unwrapper = mock(NameTransformer.class); [EOL] when(_annotationIntrospector.findUnwrappingNameTransformer(am)).thenReturn(unwrapper); [EOL] BeanPropertyWriter result = buildWriter(propDef, declaredType, ser, typeSer, null, am, defaultUseStaticTyping); [EOL] assertNotNull(result); [EOL] verify(result, times(1)).unwrappingWriter(unwrapper); [EOL] }
protected JavaType findSerializationType(Annotated a, boolean useStaticTyping, JavaType declaredType) { [EOL] Class<?> serClass = _annotationIntrospector.findSerializationType(a); [EOL] if (serClass != null) { [EOL] Class<?> rawDeclared = declaredType.getRawClass(); [EOL] if (serClass.isAssignableFrom(rawDeclared)) { [EOL] declaredType = declaredType.widenBy(serClass); [EOL] } else { [EOL] if (!rawDeclared.isAssignableFrom(serClass)) { [EOL] throw new IllegalArgumentException("Illegal concrete-type annotation for method '" + a.getName() + "': class " + serClass.getName() + " not a super-type of (declared) class " + rawDeclared.getName()); [EOL] } [EOL] declaredType = _config.constructSpecializedType(declaredType, serClass); [EOL] } [EOL] useStaticTyping = true; [EOL] } [EOL] JavaType secondary = BeanSerializerFactory.modifySecondaryTypesByAnnotation(_config, a, declaredType); [EOL] if (secondary != declaredType) { [EOL] useStaticTyping = true; [EOL] declaredType = secondary; [EOL] } [EOL] if (!useStaticTyping) { [EOL] JsonSerialize.Typing typing = _annotationIntrospector.findSerializationTyping(a); [EOL] if (typing != null) { [EOL] useStaticTyping = (typing == JsonSerialize.Typing.STATIC); [EOL] } [EOL] } [EOL] return useStaticTyping ? declaredType : null; [EOL] }
public void testToStringReturnsSchemaString() { [EOL] YourClass instance = new YourClass(); [EOL] instance.schema = new SchemaType(); // Replace 'SchemaType' with the actual type of 'schema' [EOL] String expected = instance.schema.toString(); [EOL] String actual = instance.toString(); [EOL] assertEquals(expected, actual); [EOL] }
public void testSerializeWithSingleElementUnwrapped() throws IOException { [EOL] Collection<String> value = Collections.singletonList("singleElement"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)).thenReturn(true); [EOL] serialize(value, jgen, provider); [EOL] verify(jgen, never()).writeStartArray(); [EOL] verify(jgen, never()).writeEndArray(); [EOL] verify(provider).isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL] }
public void testSerializeWithMultipleElements() throws IOException { [EOL] Collection<String> value = Arrays.asList("element1", "element2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] serialize(value, jgen, provider); [EOL] verify(jgen).writeStartArray(); [EOL] verify(jgen).writeEndArray(); [EOL] verify(provider, never()).isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL] }
public void testSerializeWithCustomSerializer() throws IOException { [EOL] Collection<String> value = Arrays.asList("element1", "element2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] _serializer = mock(JsonSerializer.class); [EOL] serialize(value, jgen, provider); [EOL] verify(jgen).writeStartArray(); [EOL] verify(_serializer).serialize(any(), eq(jgen), eq(provider)); [EOL] verify(jgen).writeEndArray(); [EOL] }
public void testSerializeUnwrappedWithNullSerializer() throws IOException, JsonGenerationException { [EOL] Collection<String> value = Arrays.asList("value1", "value2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] _serializeUnwrapped(value, jgen, provider); [EOL] verify(jgen, times(1)).writeString("value1"); [EOL] verify(jgen, times(1)).writeString("value2"); [EOL] }
public void testSerializeUnwrappedWithNonNullSerializer() throws IOException, JsonGenerationException { [EOL] Collection<String> value = Arrays.asList("value1", "value2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] setSerializer(serializer); [EOL] _serializeUnwrapped(value, jgen, provider); [EOL] verify(serializer, times(1)).serialize("value1", jgen, provider); [EOL] verify(serializer, times(1)).serialize("value2", jgen, provider); [EOL] }
public void testWithSameBase64Variant() { [EOL] Base64Variant base64 = new Base64Variant("id", "name", true, '=', 0); [EOL] BaseSettings settings = new BaseSettings(null, null, null, null, null, null, null, null, null, null, base64); [EOL] BaseSettings result = settings.with(base64); [EOL] assertSame(settings, result); [EOL] }
public void testWithDifferentBase64Variant() { [EOL] Base64Variant base64 = new Base64Variant("id", "name", true, '=', 0); [EOL] Base64Variant differentBase64 = new Base64Variant("id2", "name2", false, ':', 1); [EOL] BaseSettings settings = new BaseSettings(null, null, null, null, null, null, null, null, null, null, base64); [EOL] BaseSettings result = settings.with(differentBase64); [EOL] assertNotSame(settings, result); [EOL] assertEquals(differentBase64, result.getBase64Variant()); [EOL] }
public void testGetBase64Variant() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Base64Variant result = mapper.getSerializationConfig().getBase64Variant(); [EOL] assertNotNull(result); [EOL] assertEquals(result, Base64Variants.getDefaultVariant()); [EOL] }
public void testGetByteBuilder_WhenByteBuilderIsNull() { [EOL] YourClass instance = new YourClass(); [EOL] ByteBuilder result = instance.getByteBuilder(); [EOL] assertNotNull(result); [EOL] }
public void testGetByteBuilder_WhenByteBuilderIsNotNull() { [EOL] YourClass instance = new YourClass(); [EOL] ByteBuilder expected = new ByteBuilder(); [EOL] instance.getByteBuilder(); // Call once to initialize _byteBuilder [EOL] ByteBuilder result = instance.getByteBuilder(); [EOL] assertSame(expected, result); [EOL] }
public void testByteBuilderConstructor() { [EOL] ByteBuilder byteBuilder = new ByteBuilder(); [EOL] assertNotNull(byteBuilder); [EOL] }
public void testConstructArrayWithZeroLength() { [EOL] int len = 0; [EOL] byte[] result = _constructArray(len); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testConstructArrayWithPositiveLength() { [EOL] int len = 10; [EOL] byte[] result = _constructArray(len); [EOL] assertNotNull(result); [EOL] assertEquals(10, result.length); [EOL] }
public void testArrayToSetWithNonNullElements() { [EOL] Integer[] elements = new Integer[]{1, 2, 3, 4}; [EOL] HashSet<Integer> resultSet = arrayToSet(elements); [EOL] assertEquals(4, resultSet.size()); [EOL] assertTrue(resultSet.contains(1)); [EOL] assertTrue(resultSet.contains(2)); [EOL] assertTrue(resultSet.contains(3)); [EOL] assertTrue(resultSet.contains(4)); [EOL] }
public void testArrayToSetWithNullElements() { [EOL] Integer[] elements = null; [EOL] HashSet<Integer> resultSet = arrayToSet(elements); [EOL] assertTrue(resultSet.isEmpty()); [EOL] }
public void testArrayToSetWithEmptyArray() { [EOL] Integer[] elements = new Integer[]{}; [EOL] HashSet<Integer> resultSet = arrayToSet(elements); [EOL] assertTrue(resultSet.isEmpty()); [EOL] }
public void testArrayToSetWithDuplicateElements() { [EOL] Integer[] elements = new Integer[]{1, 2, 2, 3, 3, 3}; [EOL] HashSet<Integer> resultSet = arrayToSet(elements); [EOL] assertEquals(3, resultSet.size()); [EOL] assertTrue(resultSet.contains(1)); [EOL] assertTrue(resultSet.contains(2)); [EOL] assertTrue(resultSet.contains(3)); [EOL] }
public void testInsertInListNoDup_ElementNotInArray() { [EOL] Integer[] originalArray = new Integer[]{1, 2, 3}; [EOL] Integer newElement = 4; [EOL] Integer[] resultArray = insertInListNoDup(originalArray, newElement); [EOL] assertEquals(4, resultArray.length); [EOL] assertEquals(newElement, resultArray[0]); [EOL] for (int i = 0; i < originalArray.length; i++) { [EOL] assertEquals(originalArray[i], resultArray[i + 1]); [EOL] } [EOL] }
public void testInsertInListNoDup_ElementInArrayFirstPosition() { [EOL] Integer[] originalArray = new Integer[]{1, 2, 3}; [EOL] Integer newElement = 1; [EOL] Integer[] resultArray = insertInListNoDup(originalArray, newElement); [EOL] assertSame(originalArray, resultArray); [EOL] }
public void testInsertInListNoDup_ElementInArrayNotFirstPosition() { [EOL] Integer[] originalArray = new Integer[]{1, 2, 3}; [EOL] Integer newElement = 2; [EOL] Integer[] resultArray = insertInListNoDup(originalArray, newElement); [EOL] assertEquals(3, resultArray.length); [EOL] assertEquals(newElement, resultArray[0]); [EOL] assertEquals(Integer.valueOf(1), resultArray[1]); [EOL] assertEquals(Integer.valueOf(3), resultArray[2]); [EOL] }
public void testInsertInListNoDup_EmptyArray() { [EOL] Integer[] originalArray = new Integer[]{}; [EOL] Integer newElement = 1; [EOL] Integer[] resultArray = insertInListNoDup(originalArray, newElement); [EOL] assertEquals(1, resultArray.length); [EOL] assertEquals(newElement, resultArray[0]); [EOL] }
public void testHasAbstractTypeResolvers_Empty() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] assertFalse(config.hasAbstractTypeResolvers()); [EOL] } [EOL] public void testHasAbstractTypeResolvers_NonEmpty() { [EOL] AbstractTypeResolver resolver = mock(AbstractTypeResolver.class); [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig().withAbstractTypeResolver(resolver); [EOL] assertTrue(config.hasAbstractTypeResolvers()); [EOL] }
public void testHasDeserializers_Empty() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] assertFalse(config.hasDeserializers()); [EOL] } [EOL] public void testHasDeserializers_NonEmpty() { [EOL] Deserializers deserializers = mock(Deserializers.class); [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig().withAdditionalDeserializers(deserializers); [EOL] assertTrue(config.hasDeserializers()); [EOL] }
public void testHasKeyDeserializers_Empty() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] assertFalse(config.hasKeyDeserializers()); [EOL] } [EOL] public void testHasKeyDeserializers_NonEmpty() { [EOL] KeyDeserializers keyDeserializers = mock(KeyDeserializers.class); [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig().withAdditionalKeyDeserializers(keyDeserializers); [EOL] assertTrue(config.hasKeyDeserializers()); [EOL] }
public void testHasDeserializerModifiers_Empty() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] assertFalse(config.hasDeserializerModifiers()); [EOL] } [EOL] public void testHasDeserializerModifiers_NonEmpty() { [EOL] BeanDeserializerModifier modifier = mock(BeanDeserializerModifier.class); [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig().withDeserializerModifier(modifier); [EOL] assertTrue(config.hasDeserializerModifiers()); [EOL] }
public void testHasValueInstantiators_Empty() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(); [EOL] assertFalse(config.hasValueInstantiators()); [EOL] } [EOL] public void testHasValueInstantiators_NonEmpty() { [EOL] ValueInstantiators instantiators = mock(ValueInstantiators.class); [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig().withValueInstantiators(instantiators); [EOL] assertTrue(config.hasValueInstantiators()); [EOL] }
public void testAbstractTypeResolversWithNonNull() { [EOL] AbstractTypeResolver[] atr = new AbstractTypeResolver[] { new MyAbstractTypeResolver() }; [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(null, null, null, atr, null); [EOL] Iterable<AbstractTypeResolver> resolvers = config.abstractTypeResolvers(); [EOL] assertNotNull(resolvers); [EOL] assertTrue(resolvers.iterator().hasNext()); [EOL] assertEquals(atr[0], resolvers.iterator().next()); [EOL] }
public void testAbstractTypeResolversWithNull() { [EOL] DeserializerFactoryConfig config = new DeserializerFactoryConfig(null, null, null, null, null); [EOL] Iterable<AbstractTypeResolver> resolvers = config.abstractTypeResolvers(); [EOL] assertNotNull(resolvers); [EOL] assertFalse(resolvers.iterator().hasNext()); [EOL] }
public void testSerializeAsFieldWithNonNullValueAndNoSerializer() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] serializeAsField(bean, jgen, prov); [EOL] verify(jgen).writeFieldName(anyString()); [EOL] verify(jgen).writeObject(any()); [EOL] }
public void testSerializeAsFieldWithNullValue() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] serializeAsField(null, jgen, prov); [EOL] verifyNoMoreInteractions(jgen); [EOL] }
public void testSerializeAsFieldWithSuppressableValue() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] setSuppressableValue(MARKER_FOR_EMPTY); [EOL] serializeAsField(bean, jgen, prov); [EOL] verifyNoMoreInteractions(jgen); [EOL] }
public void testSerializeAsFieldWithSelfReference() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] serializeAsField(bean, jgen, prov); [EOL] verifyPrivate().invoke("_handleSelfReference", bean, any(JsonSerializer.class)); [EOL] }
public void testSerializeAsFieldWithTypeSerializer() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] setTypeSerializer(typeSer); [EOL] serializeAsField(bean, jgen, prov); [EOL] verify(jgen).writeFieldName(anyString()); [EOL] verify(jgen).writeObjectWithType(any(), eq(typeSer)); [EOL] }
protected JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map, Class<?> type, SerializerProvider provider) throws JsonMappingException { [EOL] JsonSerializer<Object> serializer; [EOL] if (_nonTrivialBaseType != null) { [EOL] JavaType subtype = provider.constructSpecializedType(_nonTrivialBaseType, type); [EOL] serializer = provider.findValueSerializer(subtype, this); [EOL] } else { [EOL] serializer = provider.findValueSerializer(type, this); [EOL] } [EOL] NameTransformer t = _nameTransformer; [EOL] if (serializer.isUnwrappingSerializer()) { [EOL] t = NameTransformer.chainedTransformer(t, ((UnwrappingBeanSerializer) serializer)._nameTransformer); [EOL] } [EOL] serializer = serializer.unwrappingSerializer(t); [EOL] _dynamicSerializers = _dynamicSerializers.newWith(type, serializer); [EOL] return serializer; [EOL] }
public void testBeanSerializerBaseWithNullBuilder() { [EOL] JavaType type = mock(JavaType.class); [EOL] BeanPropertyWriter[] properties = new BeanPropertyWriter[0]; [EOL] BeanPropertyWriter[] filteredProperties = new BeanPropertyWriter[0]; [EOL] BeanSerializerBase serializer = new BeanSerializerBase(type, null, properties, filteredProperties); [EOL] assertNull(serializer._typeId); [EOL] assertNull(serializer._anyGetterWriter); [EOL] assertNull(serializer._propertyFilterId); [EOL] assertNull(serializer._objectIdWriter); [EOL] assertNull(serializer._serializationShape); [EOL] }
public void testBeanSerializerBaseWithNonNullBuilder() { [EOL] JavaType type = mock(JavaType.class); [EOL] BeanPropertyWriter[] properties = new BeanPropertyWriter[0]; [EOL] BeanPropertyWriter[] filteredProperties = new BeanPropertyWriter[0]; [EOL] BeanSerializerBuilder builder = mock(BeanSerializerBuilder.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(builder.getTypeId()).thenReturn("typeId"); [EOL] when(builder.getAnyGetter()).thenReturn(mock(AnyGetterWriter.class)); [EOL] when(builder.getFilterId()).thenReturn("filterId"); [EOL] when(builder.getObjectIdWriter()).thenReturn(mock(ObjectIdWriter.class)); [EOL] when(builder.getBeanDescription()).thenReturn(beanDesc); [EOL] when(beanDesc.findExpectedFormat(null)).thenReturn(format); [EOL] when(format.getShape()).thenReturn(JsonFormat.Shape.STRING); [EOL] BeanSerializerBase serializer = new BeanSerializerBase(type, builder, properties, filteredProperties); [EOL] assertEquals("typeId", serializer._typeId); [EOL] assertNotNull(serializer._anyGetterWriter); [EOL] assertEquals("filterId", serializer._propertyFilterId); [EOL] assertNotNull(serializer._objectIdWriter); [EOL] assertEquals(JsonFormat.Shape.STRING, serializer._serializationShape); [EOL] }
public void testBeanSerializerBaseConstructor() { [EOL] BeanPropertyWriter[] properties = new BeanPropertyWriter[0]; [EOL] BeanPropertyWriter[] filteredProperties = new BeanPropertyWriter[0]; [EOL] BeanSerializerBase original = new BeanSerializerBase() { [EOL] }; [EOL] BeanSerializerBase copy = new BeanSerializerBase(original, properties, filteredProperties); [EOL] assertEquals(original._handledType, copy._handledType); [EOL] assertArrayEquals(properties, copy._props); [EOL] assertArrayEquals(filteredProperties, copy._filteredProps); [EOL] assertEquals(original._typeId, copy._typeId); [EOL] assertEquals(original._anyGetterWriter, copy._anyGetterWriter); [EOL] assertEquals(original._objectIdWriter, copy._objectIdWriter); [EOL] assertEquals(original._propertyFilterId, copy._propertyFilterId); [EOL] assertEquals(original._serializationShape, copy._serializationShape); [EOL] }
protected BeanSerializerBase(BeanSerializerBase src, NameTransformer unwrapper) { [EOL] this(src, rename(src._props, unwrapper), rename(src._filteredProps, unwrapper)); [EOL] }
public void testRenameWithNullProps() { [EOL] BeanPropertyWriter[] result = rename(null, new NameTransformer() { [EOL] @Override [EOL] public String transform(String name) { [EOL] return "transformed_" + name; [EOL] } [EOL] }); [EOL] assertNull(result); [EOL] }
public void testRenameWithEmptyProps() { [EOL] BeanPropertyWriter[] props = new BeanPropertyWriter[0]; [EOL] BeanPropertyWriter[] result = rename(props, new NameTransformer() { [EOL] @Override [EOL] public String transform(String name) { [EOL] return "transformed_" + name; [EOL] } [EOL] }); [EOL] assertArrayEquals(props, result); [EOL] }
public void testRenameWithNullTransformer() { [EOL] BeanPropertyWriter[] props = { new BeanPropertyWriter() }; [EOL] BeanPropertyWriter[] result = rename(props, null); [EOL] assertArrayEquals(props, result); [EOL] }
public void testRenameWithNoOpTransformer() { [EOL] BeanPropertyWriter[] props = { new BeanPropertyWriter() }; [EOL] BeanPropertyWriter[] result = rename(props, NameTransformer.NOP); [EOL] assertArrayEquals(props, result); [EOL] }
public void testRenameWithNonNullPropsAndTransformer() { [EOL] BeanPropertyWriter[] props = { new BeanPropertyWriter(), null }; [EOL] BeanPropertyWriter[] result = rename(props, new NameTransformer() { [EOL] @Override [EOL] public String transform(String name) { [EOL] return "transformed_" + name; [EOL] } [EOL] }); [EOL] assertNotNull(result); [EOL] assertEquals("transformed_" + props[0].getName(), result[0].getName()); [EOL] assertNull(result[1]); [EOL] }
public void testSerializeWithTypeWithObjectId() throws IOException { [EOL] _objectIdWriter = createObjectIdWriter(); // Replace with actual method to create a non-null ObjectIdWriter [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = createJsonGenerator(); // Replace with actual method to create a JsonGenerator [EOL] SerializerProvider provider = createSerializerProvider(); // Replace with actual method to create a SerializerProvider [EOL] TypeSerializer typeSer = createTypeSerializer(); // Replace with actual method to create a TypeSerializer [EOL] serializeWithType(bean, jgen, provider, typeSer); [EOL] }
public void testSerializeWithTypeWithoutObjectIdAndWithoutCustomTypeId() throws IOException { [EOL] _objectIdWriter = null; [EOL] _typeId = null; [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = createJsonGenerator(); [EOL] SerializerProvider provider = createSerializerProvider(); [EOL] TypeSerializer typeSer = createTypeSerializer(); [EOL] serializeWithType(bean, jgen, provider, typeSer); [EOL] }
public void testSerializeWithTypeWithoutObjectIdAndWithCustomTypeId() throws IOException { [EOL] _objectIdWriter = null; [EOL] _typeId = createTypeId(); // Replace with actual method to create a non-null TypeId [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = createJsonGenerator(); [EOL] SerializerProvider provider = createSerializerProvider(); [EOL] TypeSerializer typeSer = createTypeSerializer(); [EOL] when(_customTypeId(bean)).thenReturn("customType"); [EOL] serializeWithType(bean, jgen, provider, typeSer); [EOL] }
public void testSerializeWithTypeWithPropertyFilterId() throws IOException { [EOL] _propertyFilterId = createPropertyFilterId(); // Replace with actual method to create a non-null PropertyFilterId [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = createJsonGenerator(); [EOL] SerializerProvider provider = createSerializerProvider(); [EOL] TypeSerializer typeSer = createTypeSerializer(); [EOL] serializeWithType(bean, jgen, provider, typeSer); [EOL] }
public void testCustomTypeIdWithNullTypeId() { [EOL] Object bean = new Object() { [EOL] public Object getTypeId() { [EOL] return null; [EOL] } [EOL] }; [EOL] MyClass myClass = new MyClass(); [EOL] String result = myClass._customTypeId(bean); [EOL] assertEquals("", result); [EOL] }
public void testCustomTypeIdWithStringTypeId() { [EOL] Object bean = new Object() { [EOL] public Object getTypeId() { [EOL] return "stringTypeId"; [EOL] } [EOL] }; [EOL] MyClass myClass = new MyClass(); [EOL] String result = myClass._customTypeId(bean); [EOL] assertEquals("stringTypeId", result); [EOL] }
public void testCustomTypeIdWithNonStringTypeId() { [EOL] Object bean = new Object() { [EOL] public Object getTypeId() { [EOL] return new Object() { [EOL] @Override [EOL] public String toString() { [EOL] return "nonStringTypeId"; [EOL] } [EOL] }; [EOL] } [EOL] }; [EOL] MyClass myClass = new MyClass(); [EOL] String result = myClass._customTypeId(bean); [EOL] assertEquals("nonStringTypeId", result); [EOL] }
public void testGetSchemaWithAnnotationAndFilter() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] Type typeHint = mock(Type.class); [EOL] BeanPropertyWriter[] props = new BeanPropertyWriter[1]; [EOL] props[0] = mock(BeanPropertyWriter.class); [EOL] BeanPropertyFilter filter = mock(BeanPropertyFilter.class); [EOL] when(_handledType.getAnnotation(JsonSerializableSchema.class)).thenReturn(mock(JsonSerializableSchema.class)); [EOL] when(_handledType.getAnnotation(JsonSerializableSchema.class).id()).thenReturn("customId"); [EOL] when(_propertyFilterId).thenReturn("filterId"); [EOL] when(findFilter(provider)).thenReturn(filter); [EOL] JsonNode result = getSchema(provider, typeHint); [EOL] assertNotNull(result); [EOL] assertTrue(result.isObject()); [EOL] assertEquals("customId", result.get("id").asText()); [EOL] verify(filter).depositSchemaProperty(any(BeanPropertyWriter.class), any(ObjectNode.class), eq(provider)); [EOL] }
public void testGetSchemaWithoutAnnotationAndWithoutFilter() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] Type typeHint = mock(Type.class); [EOL] BeanPropertyWriter[] props = new BeanPropertyWriter[1]; [EOL] props[0] = mock(BeanPropertyWriter.class); [EOL] when(_handledType.getAnnotation(JsonSerializableSchema.class)).thenReturn(null); [EOL] when(_propertyFilterId).thenReturn(null); [EOL] JsonNode result = getSchema(provider, typeHint); [EOL] assertNotNull(result); [EOL] assertTrue(result.isObject()); [EOL] assertNull(result.get("id")); [EOL] verify(props[0]).depositSchemaProperty(any(ObjectNode.class), eq(provider)); [EOL] }
public void testUpdateBuilderWithNonNullValues() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] BeanDescription beanDesc = new BeanDescription(...); // Provide actual initialization [EOL] BeanSerializerBuilder builder = new BeanSerializerBuilder(beanDesc); [EOL] BeanSerializerBuilder result = updateBuilder(config, beanDesc, builder); [EOL] assertSame(builder, result); [EOL] }
public void testModifySerializerWithNonNullSerializer() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] BeanDescription beanDesc = new BeanDescription(...); // Provide actual initialization [EOL] JsonSerializer<?> serializer = new JsonSerializer<Object>() { ... }; // Provide actual implementation [EOL] JsonSerializer<?> modifiedSerializer = modifySerializer(config, beanDesc, serializer); [EOL] assertSame(serializer, modifiedSerializer); [EOL] }
public void testSortPropertiesWithNullIntrAndAlpha() { [EOL] _annotationIntrospector = null; [EOL] _classDef = null; // Assuming _classDef is a field that can be set to null [EOL] _config = mock(SerializationConfig.class); [EOL] when(_config.shouldSortPropertiesAlphabetically()).thenReturn(false); [EOL] _properties = new LinkedHashMap<>(); [EOL] _creatorProperties = null; [EOL] _sortProperties(); [EOL] assertTrue("Properties should not be sorted", _properties instanceof LinkedHashMap); [EOL] }
public void testSortPropertiesWithNonNullIntrAndAlphaTrue() { [EOL] _annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] _classDef = mock(AnnotatedClass.class); [EOL] when(_annotationIntrospector.findSerializationSortAlphabetically(_classDef)).thenReturn(Boolean.TRUE); [EOL] _properties = new LinkedHashMap<>(); [EOL] _creatorProperties = null; [EOL] _sortProperties(); [EOL] assertTrue("Properties should be sorted", _properties instanceof TreeMap); [EOL] }
public void testSortPropertiesWithNonNullIntrAndAlphaFalse() { [EOL] _annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] _classDef = mock(AnnotatedClass.class); [EOL] when(_annotationIntrospector.findSerializationSortAlphabetically(_classDef)).thenReturn(Boolean.FALSE); [EOL] _properties = new LinkedHashMap<>(); [EOL] _creatorProperties = null; [EOL] _sortProperties(); [EOL] assertTrue("Properties should not be sorted", _properties instanceof LinkedHashMap); [EOL] }
public void testSortPropertiesWithPropertyOrder() { [EOL] _annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] _classDef = mock(AnnotatedClass.class); [EOL] when(_annotationIntrospector.findSerializationSortAlphabetically(_classDef)).thenReturn(null); [EOL] when(_annotationIntrospector.findSerializationPropertyOrder(_classDef)).thenReturn(new String[]{"prop1", "prop2"}); [EOL] _properties = new LinkedHashMap<>(); [EOL] _properties.put("prop1", new POJOPropertyBuilder()); [EOL] _properties.put("prop2", new POJOPropertyBuilder()); [EOL] _creatorProperties = null; [EOL] _sortProperties(); [EOL] List<String> keys = new ArrayList<>(_properties.keySet()); [EOL] assertEquals("First property should be 'prop1'", "prop1", keys.get(0)); [EOL] assertEquals("Second property should be 'prop2'", "prop2", keys.get(1)); [EOL] }
public void testSortPropertiesWithCreatorProperties() { [EOL] _annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] _classDef = mock(AnnotatedClass.class); [EOL] when(_annotationIntrospector.findSerializationSortAlphabetically(_classDef)).thenReturn(null); [EOL] _properties = new LinkedHashMap<>(); [EOL] _creatorProperties = new ArrayList<>(); [EOL] POJOPropertyBuilder creatorProp = new POJOPropertyBuilder(); [EOL] _creatorProperties.add(creatorProp); [EOL] _sortProperties(); [EOL] assertTrue("Creator properties should be included", _properties.containsValue(creatorProp)); [EOL] }
public void testAddFieldsWithNullAnnotationIntrospectorAndSerialization() { [EOL] _forSerialization = true; [EOL] _annotationIntrospector = null; [EOL] _addFields(); [EOL] }
public void testAddFieldsWithNonNullAnnotationIntrospectorAndSerialization() { [EOL] _forSerialization = true; [EOL] _annotationIntrospector = createMockAnnotationIntrospectorWithSerialization(); [EOL] _addFields(); [EOL] }
public void testAddFieldsWithNonNullAnnotationIntrospectorAndDeserialization() { [EOL] _forSerialization = false; [EOL] _annotationIntrospector = createMockAnnotationIntrospectorWithDeserialization(); [EOL] _addFields(); [EOL] }
public void testAddFieldsWithPruneFinalFields() { [EOL] _forSerialization = false; [EOL] _config = createConfigWithFinalFieldsAsMutatorsDisabled(); [EOL] _annotationIntrospector = createMockAnnotationIntrospectorWithIgnoreMarker(); [EOL] _addFields(); [EOL] }
public void testAddFieldsWithVisibleFields() { [EOL] _visibilityChecker = createVisibilityCheckerWithVisibleFields(); [EOL] _addFields(); [EOL] }
public void testAddFieldsWithIgnoredFields() { [EOL] _annotationIntrospector = createMockAnnotationIntrospectorWithIgnoreMarker(); [EOL] _addFields(); [EOL] }
public void testRenameUsingWithSerializationAndGetter() { [EOL] PropertyNamingStrategy naming = mock(PropertyNamingStrategy.class); [EOL] when(naming.nameForGetterMethod(any(), any(), anyString())).thenReturn("newName"); [EOL] POJOPropertyBuilder prop = mock(POJOPropertyBuilder.class); [EOL] when(prop.getName()).thenReturn("oldName"); [EOL] when(prop.hasGetter()).thenReturn(true); [EOL] when(prop.getGetter()).thenReturn(mock(AnnotatedMethod.class)); [EOL] LinkedHashMap<String, POJOPropertyBuilder> properties = new LinkedHashMap<>(); [EOL] properties.put("oldName", prop); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(beanDesc.findProperties()).thenReturn(properties); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] boolean forSerialization = true; [EOL] beanDesc._renameUsing(naming, config, forSerialization); [EOL] assertEquals("newName", prop.getName()); [EOL] }
public void testRenameUsingWithSerializationAndField() { [EOL] PropertyNamingStrategy naming = mock(PropertyNamingStrategy.class); [EOL] when(naming.nameForField(any(), any(), anyString())).thenReturn("newName"); [EOL] POJOPropertyBuilder prop = mock(POJOPropertyBuilder.class); [EOL] when(prop.getName()).thenReturn("oldName"); [EOL] when(prop.hasField()).thenReturn(true); [EOL] when(prop.getField()).thenReturn(mock(AnnotatedField.class)); [EOL] LinkedHashMap<String, POJOPropertyBuilder> properties = new LinkedHashMap<>(); [EOL] properties.put("oldName", prop); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(beanDesc.findProperties()).thenReturn(properties); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] boolean forSerialization = true; [EOL] beanDesc._renameUsing(naming, config, forSerialization); [EOL] assertEquals("newName", prop.getName()); [EOL] }
public void testRenameUsingWithoutSerializationAndSetter() { [EOL] PropertyNamingStrategy naming = mock(PropertyNamingStrategy.class); [EOL] when(naming.nameForSetterMethod(any(), any(), anyString())).thenReturn("newName"); [EOL] POJOPropertyBuilder prop = mock(POJOPropertyBuilder.class); [EOL] when(prop.getName()).thenReturn("oldName"); [EOL] when(prop.hasSetter()).thenReturn(true); [EOL] when(prop.getSetter()).thenReturn(mock(AnnotatedMethod.class)); [EOL] LinkedHashMap<String, POJOPropertyBuilder> properties = new LinkedHashMap<>(); [EOL] properties.put("oldName", prop); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(beanDesc.findProperties()).thenReturn(properties); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] boolean forSerialization = false; [EOL] beanDesc._renameUsing(naming, config, forSerialization); [EOL] assertEquals("newName", prop.getName()); [EOL] }
public void testRenameUsingWithoutSerializationAndConstructorParameter() { [EOL] PropertyNamingStrategy naming = mock(PropertyNamingStrategy.class); [EOL] when(naming.nameForConstructorParameter(any(), any(), anyString())).thenReturn("newName"); [EOL] POJOPropertyBuilder prop = mock(POJOPropertyBuilder.class); [EOL] when(prop.getName()).thenReturn("oldName"); [EOL] when(prop.hasConstructorParameter()).thenReturn(true); [EOL] when(prop.getConstructorParameter()).thenReturn(mock(AnnotatedParameter.class)); [EOL] LinkedHashMap<String, POJOPropertyBuilder> properties = new LinkedHashMap<>(); [EOL] properties.put("oldName", prop); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(beanDesc.findProperties()).thenReturn(properties); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] boolean forSerialization = false; [EOL] beanDesc._renameUsing(naming, config, forSerialization); [EOL] assertEquals("newName", prop.getName()); [EOL] }
public void testRenameUsingWithoutSerializationAndField() { [EOL] PropertyNamingStrategy naming = mock(PropertyNamingStrategy.class); [EOL] when(naming.nameForField(any(), any(), anyString())).thenReturn("newName"); [EOL] POJOPropertyBuilder prop = mock(POJOPropertyBuilder.class); [EOL] when(prop.getName()).thenReturn("oldName"); [EOL] when(prop.hasField()).thenReturn(true); [EOL] when(prop.getField()).thenReturn(mock(AnnotatedField.class)); [EOL] LinkedHashMap<String, POJOPropertyBuilder> properties = new LinkedHashMap<>(); [EOL] properties.put("oldName", prop); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(beanDesc.findProperties()).thenReturn(properties); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] boolean forSerialization = false; [EOL] beanDesc._renameUsing(naming, config, forSerialization); [EOL] assertEquals("newName", prop.getName()); [EOL] }
public void testRenameUsingWithoutSerializationAndGetter() { [EOL] PropertyNamingStrategy naming = mock(PropertyNamingStrategy.class); [EOL] when(naming.nameForGetterMethod(any(), any(), anyString())).thenReturn("newName"); [EOL] POJOPropertyBuilder prop = mock(POJOPropertyBuilder.class); [EOL] when(prop.getName()).thenReturn("oldName"); [EOL] when(prop.hasGetter()).thenReturn(true); [EOL] when(prop.getGetter()).thenReturn(mock(AnnotatedMethod.class)); [EOL] LinkedHashMap<String, POJOPropertyBuilder> properties = new LinkedHashMap<>(); [EOL] properties.put("oldName", prop); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(beanDesc.findProperties()).thenReturn(properties); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] boolean forSerialization = false; [EOL] beanDesc._renameUsing(naming, config, forSerialization); [EOL] assertEquals("newName", prop.getName()); [EOL] }
public void testFindBackReferenceWithNullBackRefProperties() { [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false, Collections.emptyList()); [EOL] SettableBeanProperty result = beanPropertyMap.findBackReference("someLogicalName"); [EOL] assertNull(result); [EOL] }
public void testFindBackReferenceWithNonNullBackRefPropertiesAndKeyExists() { [EOL] Map<String, SettableBeanProperty> backRefProperties = new HashMap<>(); [EOL] SettableBeanProperty mockProperty = mock(SettableBeanProperty.class); [EOL] backRefProperties.put("existingKey", mockProperty); [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false, Collections.emptyList()); [EOL] beanPropertyMap.assignBackReferenceProperties(backRefProperties); [EOL] SettableBeanProperty result = beanPropertyMap.findBackReference("existingKey"); [EOL] assertSame(mockProperty, result); [EOL] }
public void testFindBackReferenceWithNonNullBackRefPropertiesAndKeyDoesNotExist() { [EOL] Map<String, SettableBeanProperty> backRefProperties = new HashMap<>(); [EOL] BeanPropertyMap beanPropertyMap = new BeanPropertyMap(false, Collections.emptyList()); [EOL] beanPropertyMap.assignBackReferenceProperties(backRefProperties); [EOL] SettableBeanProperty result = beanPropertyMap.findBackReference("nonExistingKey"); [EOL] assertNull(result); [EOL] }
public void testWithBase64Variant() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] Base64Variant defaultBase64 = Base64Variants.MIME_NO_LINEFEEDS; [EOL] ObjectReader reader = mapper.reader(); [EOL] ObjectReader newReader = reader.with(defaultBase64); [EOL] assertNotSame(reader, newReader); [EOL] assertEquals(newReader.getFactory()._getStreamFactory().getBase64Variant(), defaultBase64); [EOL] }
public void testWithBase64VariantNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectReader reader = mapper.reader(); [EOL] ObjectReader newReader = reader.with((Base64Variant) null); [EOL] assertNotSame(reader, newReader); [EOL] assertNotNull(newReader.getFactory()._getStreamFactory().getBase64Variant()); [EOL] }
public void testReadValueWithFormatReadersNotNull() throws IOException, JsonProcessingException { [EOL] InputStream src = new ByteArrayInputStream("test data".getBytes()); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DataFormatReaders dataFormatReaders = mock(DataFormatReaders.class); [EOL] when(dataFormatReaders.findFormat(src)).thenReturn(null); [EOL] mapper._dataFormatReaders = dataFormatReaders; [EOL] Object result = mapper.readValue(src); [EOL] assertNull(result); [EOL] }
public void testReadValueWithFormatReadersNull() throws IOException, JsonProcessingException { [EOL] InputStream src = new ByteArrayInputStream("test data".getBytes()); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper._dataFormatReaders = null; [EOL] mapper._jsonFactory = new JsonFactory(); [EOL] mapper._valueToUpdate = null; [EOL] Object result = mapper.readValue(src); [EOL] assertNotNull(result); [EOL] }
public void testReadTreeWithNullDataFormatReaders() throws IOException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String json = "{\"key\":\"value\"}"; [EOL] JsonNode result = mapper.readTree(json); [EOL] assertNotNull(result); [EOL] assertTrue(result.isObject()); [EOL] assertEquals("value", result.get("key").asText()); [EOL] }
public void testReadTreeWithDataFormatReaders() throws IOException { [EOL] ObjectMapper mapper = new ObjectMapper() { [EOL] @Override [EOL] public Version version() { [EOL] return Version.unknownVersion(); [EOL] } [EOL] }; [EOL] mapper._dataFormatReaders = new DataFormatReaders(); [EOL] String json = "{\"key\":\"value\"}"; [EOL] try { [EOL] mapper.readTree(json); [EOL] fail("Expected JsonProcessingException"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] }
public void testReadValuesWithNonNullParserAndType() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType valueType = mapper.constructType(List.class); [EOL] ObjectReader reader = mapper.readerFor(valueType); [EOL] MappingIterator<List> iterator = reader.readValues(jp); [EOL] assertNotNull(iterator); [EOL] assertEquals(valueType, iterator.getValueType()); [EOL] }
public void testReadValuesWithNullParser() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType valueType = mapper.constructType(List.class); [EOL] ObjectReader reader = mapper.readerFor(valueType); [EOL] assertThrows(IllegalArgumentException.class, () -> { [EOL] reader.readValues((JsonParser) null); [EOL] }); [EOL] }
public void testReadValuesWithClosedParser() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.isClosed()).thenReturn(true); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType valueType = mapper.constructType(List.class); [EOL] ObjectReader reader = mapper.readerFor(valueType); [EOL] assertThrows(IOException.class, () -> { [EOL] reader.readValues(jp); [EOL] }); [EOL] }
public void test_bindAsTree_withNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonNode result = mapper.readTree(jp); [EOL] assertTrue(result.isNull()); [EOL] }
public void test_bindAsTree_withEndArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonNode result = mapper.readTree(jp); [EOL] assertTrue(result.isNull()); [EOL] }
public void test_bindAsTree_withEndObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonNode result = mapper.readTree(jp); [EOL] assertTrue(result.isNull()); [EOL] }
public void test_bindAsTree_withValidStartArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.nextToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonNode result = mapper.readTree(jp); [EOL] assertNotNull(result); [EOL] assertTrue(result.isArray()); [EOL] }
public void test_bindAsTree_withValidStartObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonNode result = mapper.readTree(jp); [EOL] assertNotNull(result); [EOL] assertTrue(result.isObject()); [EOL] }
public void test_bindAsTree_withUnwrapRoot() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.nextToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.configure(DeserializationFeature.UNWRAP_ROOT_VALUE, true); [EOL] JsonNode result = mapper.readTree(jp); [EOL] assertNotNull(result); [EOL] }
public void test_bindAndCloseAsTree_withSchema() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(_schema != null).thenReturn(true); [EOL] JsonNode resultNode = mock(JsonNode.class); [EOL] when(_bindAsTree(jp)).thenReturn(resultNode); [EOL] JsonNode result = _bindAndCloseAsTree(jp); [EOL] verify(jp).setSchema(_schema); [EOL] verify(jp).close(); [EOL] assertEquals(resultNode, result); [EOL] }
public void test_bindAndCloseAsTree_withoutSchema() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(_schema == null).thenReturn(true); [EOL] JsonNode resultNode = mock(JsonNode.class); [EOL] when(_bindAsTree(jp)).thenReturn(resultNode); [EOL] JsonNode result = _bindAndCloseAsTree(jp); [EOL] verify(jp, never()).setSchema(_schema); [EOL] verify(jp).close(); [EOL] assertEquals(resultNode, result); [EOL] }
public void test_bindAndCloseAsTree_withIOExceptionOnClose() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(_schema == null).thenReturn(true); [EOL] JsonNode resultNode = mock(JsonNode.class); [EOL] when(_bindAsTree(jp)).thenReturn(resultNode); [EOL] doThrow(new IOException()).when(jp).close(); [EOL] JsonNode result = _bindAndCloseAsTree(jp); [EOL] verify(jp, never()).setSchema(_schema); [EOL] verify(jp).close(); [EOL] assertEquals(resultNode, result); [EOL] }
protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt, JavaType valueType) throws JsonMappingException { [EOL] if (_rootDeserializer != null) { [EOL] return _rootDeserializer; [EOL] } [EOL] if (valueType == null) { [EOL] throw new JsonMappingException("No value type configured for ObjectReader"); [EOL] } [EOL] JsonDeserializer<Object> deser = _rootDeserializers.get(valueType); [EOL] if (deser != null) { [EOL] return deser; [EOL] } [EOL] deser = ctxt.findRootValueDeserializer(valueType); [EOL] if (deser == null) { [EOL] throw new JsonMappingException("Can not find a deserializer for type " + valueType); [EOL] } [EOL] _rootDeserializers.put(valueType, deser); [EOL] return deser; [EOL] }
public void testWithSameConfig() { [EOL] DeserializationConfig config = new DeserializationConfig(...); // Provide actual initialization [EOL] ObjectReader reader = new ObjectReader(..., config); // Provide actual initialization [EOL] ObjectReader result = reader._with(config); [EOL] assertSame(reader, result); [EOL] }
public void testWithDifferentConfigAndDataFormatReadersNotNull() { [EOL] DeserializationConfig oldConfig = new DeserializationConfig(...); // Provide actual initialization [EOL] DeserializationConfig newConfig = new DeserializationConfig(...); // Provide actual initialization with different settings [EOL] DataFormatReaders dataFormatReaders = new DataFormatReaders(...); // Provide actual initialization [EOL] ObjectReader reader = new ObjectReader(..., oldConfig, dataFormatReaders); // Provide actual initialization [EOL] ObjectReader result = reader._with(newConfig); [EOL] assertNotNull(result); [EOL] assertNotSame(reader, result); [EOL] assertNotNull(result._dataFormatReaders); [EOL] }
public void testWithDifferentConfigAndDataFormatReadersNull() { [EOL] DeserializationConfig oldConfig = new DeserializationConfig(...); // Provide actual initialization [EOL] DeserializationConfig newConfig = new DeserializationConfig(...); // Provide actual initialization with different settings [EOL] ObjectReader reader = new ObjectReader(..., oldConfig); // Provide actual initialization [EOL] ObjectReader result = reader._with(newConfig); [EOL] assertNotNull(result); [EOL] assertNotSame(reader, result); [EOL] assertNull(result._dataFormatReaders); [EOL] }
public void testEquals_sameObject() { [EOL] CollectionLikeType clt = new CollectionLikeType(String.class, new SimpleType(Integer.class)); [EOL] assertTrue(clt.equals(clt)); [EOL] }
public void testEquals_nullObject() { [EOL] CollectionLikeType clt = new CollectionLikeType(String.class, new SimpleType(Integer.class)); [EOL] assertFalse(clt.equals(null)); [EOL] }
public void testEquals_differentClass() { [EOL] CollectionLikeType clt = new CollectionLikeType(String.class, new SimpleType(Integer.class)); [EOL] Object other = new Object(); [EOL] assertFalse(clt.equals(other)); [EOL] }
public void testEquals_differentElementType() { [EOL] CollectionLikeType clt1 = new CollectionLikeType(String.class, new SimpleType(Integer.class)); [EOL] CollectionLikeType clt2 = new CollectionLikeType(String.class, new SimpleType(Double.class)); [EOL] assertFalse(clt1.equals(clt2)); [EOL] }
public void testEquals_equalObjects() { [EOL] CollectionLikeType clt1 = new CollectionLikeType(String.class, new SimpleType(Integer.class)); [EOL] CollectionLikeType clt2 = new CollectionLikeType(String.class, new SimpleType(Integer.class)); [EOL] assertTrue(clt1.equals(clt2)); [EOL] }
public void testToCanonicalWhenCanonicalNameIsNull() { [EOL] instance._canonicalName = null; [EOL] String result = instance.toCanonical(); [EOL] assertNotNull(result); [EOL] assertEquals(result, instance.buildCanonicalName()); [EOL] }
public void testToCanonicalWhenCanonicalNameIsNotNull() { [EOL] String expected = "expectedCanonicalName"; [EOL] instance._canonicalName = expected; [EOL] String result = instance.toCanonical(); [EOL] assertNotNull(result); [EOL] assertEquals(expected, result); [EOL] }
public void testGetValueHandlerWithNoHandlerSet() { [EOL] JacksonDatabindClass instance = new JacksonDatabindClass(); [EOL] Object valueHandler = instance.getValueHandler(); [EOL] assertNull(valueHandler); [EOL] }
public void testGetValueHandlerWithHandlerSet() { [EOL] JacksonDatabindClass instance = new JacksonDatabindClass(); [EOL] Object expectedHandler = new Object(); [EOL] instance.setValueHandler(expectedHandler); // Assuming there's a method to set the value handler [EOL] Object valueHandler = instance.getValueHandler(); [EOL] assertSame(expectedHandler, valueHandler); [EOL] }
public void testGetTypeHandlerWithSetTypeHandler() { [EOL] MyClass instance = new MyClass(); [EOL] TypeHandler expected = new TypeHandler(); // Assuming TypeHandler is a valid class [EOL] instance.setTypeHandler(expected); // Assuming there's a method to set the _typeHandler field [EOL] TypeHandler actual = instance.getTypeHandler(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetTypeHandlerWithoutSetTypeHandler() { [EOL] MyClass instance = new MyClass(); [EOL] TypeHandler actual = instance.getTypeHandler(); [EOL] assertNull(actual); [EOL] }
public void testObjectWriterConstruction() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] ObjectWriter writer = new ObjectWriter(mapper, config); [EOL] assertNotNull(writer); [EOL] assertSame(config, writer._config); [EOL] assertSame(mapper.getSerializerProviderInstance(), writer._serializerProvider); [EOL] assertSame(mapper.getSerializerFactory(), writer._serializerFactory); [EOL] assertSame(mapper.getFactory(), writer._jsonFactory); [EOL] assertNull(writer._rootType); [EOL] assertNull(writer._rootSerializer); [EOL] assertNull(writer._prettyPrinter); [EOL] assertNull(writer._schema); [EOL] }
public void testObjectWriterConstructor() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType rootType = ...; // Provide actual initialization [EOL] JsonSerializer<Object> rootSer = ...; // Provide actual initialization [EOL] PrettyPrinter pp = ...; // Provide actual initialization [EOL] FormatSchema s = ...; // Provide actual initialization [EOL] ObjectWriter base = new ObjectWriter(...); // Provide actual initialization [EOL] ObjectWriter writer = new ObjectWriter(base, config, rootType, rootSer, pp, s); [EOL] assertNotNull(writer); [EOL] assertEquals(config, writer._config); [EOL] assertEquals(base._serializerProvider, writer._serializerProvider); [EOL] assertEquals(base._serializerFactory, writer._serializerFactory); [EOL] assertEquals(base._jsonFactory, writer._jsonFactory); [EOL] assertEquals(rootType, writer._rootType); [EOL] assertEquals(rootSer, writer._rootSerializer); [EOL] assertEquals(pp, writer._prettyPrinter); [EOL] assertEquals(s, writer._schema); [EOL] }
public void testObjectWriterCopyConstructor() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] ObjectWriter baseWriter = new ObjectWriter(...); // Provide actual initialization [EOL] ObjectWriter newWriter = new ObjectWriter(baseWriter, config); [EOL] assertNotNull(newWriter); [EOL] assertEquals(config, newWriter._config); [EOL] assertEquals(baseWriter._serializerProvider, newWriter._serializerProvider); [EOL] assertEquals(baseWriter._serializerFactory, newWriter._serializerFactory); [EOL] assertEquals(baseWriter._jsonFactory, newWriter._jsonFactory); [EOL] assertEquals(baseWriter._schema, newWriter._schema); [EOL] assertEquals(baseWriter._rootType, newWriter._rootType); [EOL] assertEquals(baseWriter._rootSerializer, newWriter._rootSerializer); [EOL] assertEquals(baseWriter._prettyPrinter, newWriter._prettyPrinter); [EOL] }
public void testWithSameDateFormat() { [EOL] ObjectWriter writer = new ObjectWriter(); [EOL] DateFormat df = writer.getSerializationConfig().getDateFormat(); [EOL] ObjectWriter result = writer.with(df); [EOL] assertSame("Expected same ObjectWriter instance when same DateFormat is set", writer, result); [EOL] }
public void testWithDifferentDateFormat() { [EOL] ObjectWriter writer = new ObjectWriter(); [EOL] DateFormat originalFormat = writer.getSerializationConfig().getDateFormat(); [EOL] DateFormat newFormat = new SimpleDateFormat("yyyy-MM-dd"); [EOL] assertNotSame("Expected different DateFormat instances", originalFormat, newFormat); [EOL] ObjectWriter result = writer.with(newFormat); [EOL] assertNotSame("Expected new ObjectWriter instance when different DateFormat is set", writer, result); [EOL] assertNotSame("Expected different SerializationConfig instances", writer.getSerializationConfig(), result.getSerializationConfig()); [EOL] }
public void testWithDefaultPrettyPrinter() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectWriter writer = mapper.writer(); [EOL] ObjectWriter writerWithDefaultPrettyPrinter = writer.withDefaultPrettyPrinter(); [EOL] assertNotNull(writerWithDefaultPrettyPrinter); [EOL] assertTrue(writerWithDefaultPrettyPrinter.getFactory().getCharacterEscapes() instanceof DefaultPrettyPrinter); [EOL] }
public void testWithSamePrettyPrinter() { [EOL] ObjectWriter writer = new ObjectWriter(); [EOL] PrettyPrinter pp = writer.getPrettyPrinter(); [EOL] ObjectWriter result = writer.with(pp); [EOL] assertSame(writer, result); [EOL] }
public void testWithNullPrettyPrinter() { [EOL] ObjectWriter writer = new ObjectWriter(); [EOL] ObjectWriter result = writer.with(null); [EOL] assertNotNull(result); [EOL] assertNotSame(writer, result); [EOL] assertNotNull(result.getPrettyPrinter()); [EOL] assertEquals(NULL_PRETTY_PRINTER, result.getPrettyPrinter()); [EOL] }
public void testWithDifferentPrettyPrinter() { [EOL] ObjectWriter writer = new ObjectWriter(); [EOL] PrettyPrinter pp = new DefaultPrettyPrinter(); [EOL] ObjectWriter result = writer.with(pp); [EOL] assertNotNull(result); [EOL] assertNotSame(writer, result); [EOL] assertSame(pp, result.getPrettyPrinter()); [EOL] }
public void testWithType_NullRootType() { [EOL] ObjectWriter writer = new ObjectWriter(); [EOL] JavaType rootType = null; [EOL] try { [EOL] writer.withType(rootType); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testWithType_ValidRootType() { [EOL] ObjectWriter writer = new ObjectWriter(); [EOL] JavaType rootType = new SimpleType(String.class); [EOL] ObjectWriter resultWriter = writer.withType(rootType); [EOL] assertNotNull(resultWriter); [EOL] assertNotSame(writer, resultWriter); [EOL] assertEquals(rootType.withStaticTyping(), resultWriter._rootType); [EOL] }
public void testWithType_StaticTyping() { [EOL] ObjectWriter writer = new ObjectWriter(); [EOL] JavaType rootType = new SimpleType(String.class); [EOL] rootType = rootType.withStaticTyping(); [EOL] ObjectWriter resultWriter = writer.withType(rootType); [EOL] assertNotNull(resultWriter); [EOL] assertNotSame(writer, resultWriter); [EOL] assertTrue(resultWriter._rootType.isStaticTyping()); [EOL] }
public void testWithTypeUsingNonNullClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectWriter writer = mapper.writer(); [EOL] ObjectWriter newWriter = writer.withType(String.class); [EOL] assertNotNull(newWriter); [EOL] }
public void testWithTypeUsingNullClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectWriter writer = mapper.writer(); [EOL] try { [EOL] writer.withType((Class<?>) null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testHasPrefetchedSerializerWhenSerializerIsNull() { [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] assertFalse(objectMapper.hasPrefetchedSerializer()); [EOL] }
public void testHasPrefetchedSerializerWhenSerializerIsNotNull() { [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] objectMapper._rootSerializer = new SomeSerializer(); // Assuming SomeSerializer is a valid serializer implementation [EOL] assertTrue(objectMapper.hasPrefetchedSerializer()); [EOL] }
public void testWriteValueAsStringWithValidObject() throws JsonProcessingException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] String result = mapper.writeValueAsString(new MyObject()); [EOL] assertNotNull(result); [EOL] assertFalse(result.isEmpty()); [EOL] } [EOL] public void testWriteValueAsStringWithNull() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.writeValueAsString(null); [EOL] fail("JsonProcessingException expected"); [EOL] } catch (JsonProcessingException e) { [EOL] } [EOL] } [EOL] public void testWriteValueAsStringWithIOException() throws JsonProcessingException { [EOL] ObjectMapper mapper = new ObjectMapper() { [EOL] @Override [EOL] public ObjectWriter writer() { [EOL] return new ObjectWriter(this, getSerializationConfig()) { [EOL] @Override [EOL] protected DefaultSerializerProvider _serializerProvider(SerializationConfig config) { [EOL] return new DefaultSerializerProvider.Impl() { [EOL] @Override [EOL] public void serializeValue(JsonGenerator gen, Object value) throws IOException { [EOL] throw new IOException("simulated IO exception"); [EOL] } [EOL] }; [EOL] } [EOL] }; [EOL] } [EOL] }; [EOL] try { [EOL] mapper.writeValueAsString(new MyObject()); [EOL] fail("JsonMappingException expected"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void test_serializerProviderWithNonNullConfig() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] DefaultSerializerProvider provider = mapper._serializerProvider(config); [EOL] assertNotNull(provider); [EOL] }
public void test_serializerProviderWithNullConfig() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper._serializerProvider(null); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testConfigAndWriteValueWithCloseable() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Closeable value = mock(Closeable.class); [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] config.enable(SerializationFeature.CLOSE_CLOSEABLE); [EOL] _configAndWriteValue(jgen, value); [EOL] verify(value).close(); [EOL] verify(jgen, never()).close(); [EOL] }
public void testConfigAndWriteValueWithNonCloseable() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] config.disable(SerializationFeature.CLOSE_CLOSEABLE); [EOL] _configAndWriteValue(jgen, value); [EOL] verify(jgen).close(); [EOL] }
public void testConfigAndWriteValueWithRootType() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType _rootType = ...; // Provide actual initialization [EOL] JsonSerializer<Object> _rootSerializer = ...; // Provide actual initialization [EOL] _configAndWriteValue(jgen, value); [EOL] verify(_serializerProvider(config)).serializeValue(eq(jgen), eq(value), eq(_rootType), eq(_rootSerializer)); [EOL] verify(jgen).close(); [EOL] }
public void testConfigAndWriteValueExceptionHandling() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Object value = new Object(); [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] doThrow(new IOException()).when(jgen).close(); [EOL] _configAndWriteValue(jgen, value); [EOL] verify(jgen).close(); [EOL] }
public void testWriteCloseableWithNullRootType() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Closeable value = mock(Closeable.class); [EOL] SerializationConfig cfg = mock(SerializationConfig.class); [EOL] when(cfg.getSerializationFeatures()).thenReturn(0); [EOL] _writeCloseable(jgen, value, cfg); [EOL] verify(value).close(); [EOL] verify(jgen).close(); [EOL] }
public void testWriteCloseableWithNonNullRootType() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Closeable value = mock(Closeable.class); [EOL] SerializationConfig cfg = mock(SerializationConfig.class); [EOL] JavaType _rootType = mock(JavaType.class); [EOL] JsonSerializer<Object> _rootSerializer = mock(JsonSerializer.class); [EOL] when(cfg.getSerializationFeatures()).thenReturn(0); [EOL] _writeCloseable(jgen, value, cfg, _rootType, _rootSerializer); [EOL] verify(value).close(); [EOL] verify(jgen).close(); [EOL] }
public void testPrefetchRootSerializerWithNullValueType() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType valueType = null; [EOL] JsonSerializer<Object> result = _prefetchRootSerializer(config, valueType); [EOL] assertNull(result); [EOL] }
public void testPrefetchRootSerializerWithEagerSerializerFetchDisabled() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType valueType = ...; // Provide actual initialization [EOL] when(config.isEnabled(SerializationFeature.EAGER_SERIALIZER_FETCH)).thenReturn(false); [EOL] JsonSerializer<Object> result = _prefetchRootSerializer(config, valueType); [EOL] assertNull(result); [EOL] }
public void testPrefetchRootSerializerWithEagerSerializerFetchEnabled() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType valueType = ...; // Provide actual initialization [EOL] when(config.isEnabled(SerializationFeature.EAGER_SERIALIZER_FETCH)).thenReturn(true); [EOL] try { [EOL] JsonSerializer<Object> result = _prefetchRootSerializer(config, valueType); [EOL] assertNotNull(result); [EOL] } catch (JsonProcessingException e) { [EOL] fail("JsonProcessingException should not be thrown"); [EOL] } [EOL] }
public void testPrefetchRootSerializerWithJsonProcessingException() { [EOL] SerializationConfig config = new SerializationConfig(...); // Provide actual initialization [EOL] JavaType valueType = ...; // Provide actual initialization [EOL] when(config.isEnabled(SerializationFeature.EAGER_SERIALIZER_FETCH)).thenReturn(true); [EOL] when(_serializerProvider(config).findTypedValueSerializer(valueType, true, null)).thenThrow(new JsonProcessingException(...)); [EOL] JsonSerializer<Object> result = _prefetchRootSerializer(config, valueType); [EOL] assertNull(result); [EOL] }
public void testConfigureJsonGeneratorWithNullPrettyPrinter() { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] _configureJsonGenerator(jgen); [EOL] verify(jgen).setPrettyPrinter(null); [EOL] }
public void testConfigureJsonGeneratorWithNonNullPrettyPrinter() { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] PrettyPrinter pp = mock(PrettyPrinter.class); [EOL] _prettyPrinter = pp; [EOL] _configureJsonGenerator(jgen); [EOL] verify(jgen).setPrettyPrinter(pp); [EOL] }
public void testConfigureJsonGeneratorWithInstantiatablePrettyPrinter() { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] Instantiatable<PrettyPrinter> instantiatablePP = mock(Instantiatable.class); [EOL] PrettyPrinter pp = mock(PrettyPrinter.class); [EOL] when(instantiatablePP.createInstance()).thenReturn(pp); [EOL] _prettyPrinter = (PrettyPrinter) instantiatablePP; [EOL] _configureJsonGenerator(jgen); [EOL] verify(jgen).setPrettyPrinter(pp); [EOL] }
public void testConfigureJsonGeneratorWithIndentOutputEnabled() { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] _config = mock(SerializationConfig.class); [EOL] when(_config.isEnabled(SerializationFeature.INDENT_OUTPUT)).thenReturn(true); [EOL] _configureJsonGenerator(jgen); [EOL] verify(jgen).useDefaultPrettyPrinter(); [EOL] }
public void testConfigureJsonGeneratorWithSchema() { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] FormatSchema schema = mock(FormatSchema.class); [EOL] _schema = schema; [EOL] _configureJsonGenerator(jgen); [EOL] verify(jgen).setSchema(schema); [EOL] }
public void testAsToken() { [EOL] JsonNode node = new ArrayNode(JsonNodeFactory.instance); [EOL] assertEquals(JsonToken.START_ARRAY, node.asToken()); [EOL] }
public void testFindValueWhenChildrenHaveTheField() { [EOL] ObjectNode parent = JsonNodeFactory.instance.objectNode(); [EOL] ObjectNode childWithField = JsonNodeFactory.instance.objectNode(); [EOL] childWithField.put("fieldName", "value"); [EOL] parent.set("child", childWithField); [EOL] JsonNode result = parent.findValue("fieldName"); [EOL] assertNotNull(result); [EOL] assertEquals("value", result.asText()); [EOL] }
public void testFindValueWhenChildrenDoNotHaveTheField() { [EOL] ObjectNode parent = JsonNodeFactory.instance.objectNode(); [EOL] ObjectNode childWithoutField = JsonNodeFactory.instance.objectNode(); [EOL] parent.set("child", childWithoutField); [EOL] JsonNode result = parent.findValue("fieldName"); [EOL] assertNull(result); [EOL] }
public void testFindValueWhenNoChildren() { [EOL] ObjectNode parent = JsonNodeFactory.instance.objectNode(); [EOL] JsonNode result = parent.findValue("fieldName"); [EOL] assertNull(result); [EOL] }
public void testFindParentWithExistingFieldName() { [EOL] ObjectNode root = JsonNodeFactory.instance.objectNode(); [EOL] ObjectNode child1 = JsonNodeFactory.instance.objectNode(); [EOL] ObjectNode child2 = JsonNodeFactory.instance.objectNode(); [EOL] root.set("child1", child1); [EOL] child1.put("fieldName", "value1"); [EOL] root.set("child2", child2); [EOL] ObjectNode result = root.findParent("fieldName"); [EOL] assertNotNull(result); [EOL] assertEquals(child1, result); [EOL] }
public void testFindParentWithNonExistingFieldName() { [EOL] ObjectNode root = JsonNodeFactory.instance.objectNode(); [EOL] ObjectNode child1 = JsonNodeFactory.instance.objectNode(); [EOL] ObjectNode child2 = JsonNodeFactory.instance.objectNode(); [EOL] root.set("child1", child1); [EOL] root.set("child2", child2); [EOL] ObjectNode result = root.findParent("nonExistingField"); [EOL] assertNull(result); [EOL] }
public void testAddArray() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ArrayNode arrayNode = mapper.createArrayNode(); [EOL] ArrayNode result = arrayNode.addArray(); [EOL] assertNotNull(result); [EOL] assertTrue(result.isArray()); [EOL] assertEquals(1, arrayNode.size()); [EOL] assertSame(result, arrayNode.get(0)); [EOL] }
public void testAddObject() { [EOL] JsonNodeFactory factory = JsonNodeFactory.instance; [EOL] ArrayNode arrayNode = new ArrayNode(factory); [EOL] ObjectNode objectNode = arrayNode.addObject(); [EOL] assertNotNull(objectNode); [EOL] assertTrue(arrayNode.contains(objectNode)); [EOL] assertEquals(1, arrayNode.size()); [EOL] }

public void testAddPOJONullValue() { [EOL] ArrayNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] arrayNode.addPOJO(null); [EOL] assertTrue(arrayNode.size() == 1); [EOL] assertTrue(arrayNode.get(0).isNull()); [EOL] }
public void testAddPOJOWithValue() { [EOL] ArrayNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] Object pojo = new Object(); [EOL] arrayNode.addPOJO(pojo); [EOL] assertTrue(arrayNode.size() == 1); [EOL] assertTrue(arrayNode.get(0).isPojo()); [EOL] assertEquals(pojo, ((POJONode) arrayNode.get(0)).getPojo()); [EOL] }
public void testAddLong() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ArrayNode arrayNode = mapper.createArrayNode(); [EOL] long valueToAdd = 123L; [EOL] ArrayNode result = arrayNode.add(valueToAdd); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.size()); [EOL] assertTrue(result.get(0).isLong()); [EOL] assertEquals(valueToAdd, result.get(0).longValue()); [EOL] }
public void testAddFloat() { [EOL] ArrayNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] float valueToAdd = 1.23f; [EOL] ArrayNode result = arrayNode.add(valueToAdd); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.size()); [EOL] assertTrue(result.get(0).isFloat()); [EOL] assertEquals(valueToAdd, result.get(0).floatValue(), 0.0f); [EOL] }
public void testAddDouble() { [EOL] ArrayNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] arrayNode.add(10.5); [EOL] assertEquals(1, arrayNode.size()); [EOL] assertTrue(arrayNode.get(0).isDouble()); [EOL] assertEquals(10.5, arrayNode.get(0).doubleValue(), 0.0); [EOL] }
public void testAddBooleanTrue() { [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] arrayNode.add(true); [EOL] assertTrue(arrayNode.get(0).asBoolean()); [EOL] }
public void testAddBooleanFalse() { [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] arrayNode.add(false); [EOL] assertFalse(arrayNode.get(0).asBoolean()); [EOL] }
public void testInsertArray_ValidIndex() { [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] int index = 0; [EOL] ArrayNode result = arrayNode.insertArray(index); [EOL] assertNotNull(result); [EOL] assertEquals(result, arrayNode.get(index)); [EOL] }
public void testInsertArray_NegativeIndex() { [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] int index = -1; [EOL] try { [EOL] arrayNode.insertArray(index); [EOL] fail("Should throw an IndexOutOfBoundsException for negative index"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testInsertArray_IndexGreaterThanSize() { [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] arrayNode.add("existingElement"); [EOL] int index = 2; // Greater than current size [EOL] ArrayNode result = arrayNode.insertArray(index); [EOL] assertNotNull(result); [EOL] assertEquals(result, arrayNode.get(index)); [EOL] }
public void testInsertObject_ValidIndex() { [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] int index = 0; [EOL] ObjectNode objectNode = arrayNode.insertObject(index); [EOL] assertNotNull(objectNode); [EOL] assertEquals(objectNode, arrayNode.get(index)); [EOL] }
public void testInsertObject_NegativeIndex() { [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] int index = -1; [EOL] try { [EOL] arrayNode.insertObject(index); [EOL] fail("Expected IndexOutOfBoundsException to be thrown"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testInsertObject_IndexGreaterThanSize() { [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] int index = 1; // Assuming the array is empty, index 1 is out of bounds [EOL] try { [EOL] arrayNode.insertObject(index); [EOL] fail("Expected IndexOutOfBoundsException to be thrown"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testInsertPOJO_NullValue() { [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] int index = 0; [EOL] Object value = null; [EOL] ArrayNode result = arrayNode.insertPOJO(index, value); [EOL] assertNotNull(result); [EOL] assertTrue(result.get(index).isNull()); [EOL] }
public void testInsertPOJO_NonNullValue() { [EOL] ArrayNode arrayNode = JsonNodeFactory.instance.arrayNode(); [EOL] int index = 0; [EOL] Object value = new Object(); [EOL] ArrayNode result = arrayNode.insertPOJO(index, value); [EOL] assertNotNull(result); [EOL] assertEquals(value, result.get(index).asPOJONode().getPojo()); [EOL] }
public void testToStringEmpty() { [EOL] String result = instance.toString(); [EOL] assertEquals("[]", result); [EOL] }
public void testToStringSingleElement() { [EOL] instance.addChild("Element1"); [EOL] String result = instance.toString(); [EOL] assertEquals("[Element1]", result); [EOL] }
public void testToStringMultipleElements() { [EOL] instance.addChild("Element1"); [EOL] instance.addChild("Element2"); [EOL] instance.addChild("Element3"); [EOL] String result = instance.toString(); [EOL] assertEquals("[Element1,Element2,Element3]", result); [EOL] }
public void testInsertAtNegativeIndex() { [EOL] ArrayNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] JsonNode newNode = TextNode.valueOf("test"); [EOL] arrayNode._insert(-1, newNode); [EOL] assertEquals("test", arrayNode.get(0).asText()); [EOL] }
public void testInsertAtIndexGreaterThanSize() { [EOL] ArrayNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] arrayNode.add(TextNode.valueOf("existing")); [EOL] JsonNode newNode = TextNode.valueOf("test"); [EOL] arrayNode._insert(2, newNode); [EOL] assertEquals("test", arrayNode.get(1).asText()); [EOL] }
public void testInsertAtIndexWithinBounds() { [EOL] ArrayNode arrayNode = new ArrayNode(JsonNodeFactory.instance); [EOL] arrayNode.add(TextNode.valueOf("existing1")); [EOL] arrayNode.add(TextNode.valueOf("existing2")); [EOL] JsonNode newNode = TextNode.valueOf("test"); [EOL] arrayNode._insert(1, newNode); [EOL] assertEquals("test", arrayNode.get(1).asText()); [EOL] assertEquals("existing2", arrayNode.get(2).asText()); [EOL] }
public void testCachedDeserializersCount_EmptyCache() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] int count = mapper.getDeserializationContext().cachedDeserializersCount(); [EOL] assertEquals(0, count); [EOL] }
public void testCachedDeserializersCount_NonEmptyCache() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.readValue("{\"key\":\"value\"}", Object.class); [EOL] int count = mapper.getDeserializationContext().cachedDeserializersCount(); [EOL] assertTrue(count > 0); [EOL] }
public void testFlushCachedDeserializers() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonFactory factory = new JsonFactory(); [EOL] JsonParser parser = factory.createParser("{}"); [EOL] DeserializationContext ctxt = mapper.getDeserializationContext(); [EOL] JsonDeserializer<Object> deserializer = ctxt.findRootValueDeserializer(ctxt.constructType(Object.class)); [EOL] int beforeFlushSize = ctxt._cachedDeserializers.size(); [EOL] ctxt.flushCachedDeserializers(); [EOL] int afterFlushSize = ctxt._cachedDeserializers.size(); [EOL] assertTrue("Cache should be empty after flush", afterFlushSize == 0); [EOL] assertTrue("Cache should not be empty before flush", beforeFlushSize > 0); [EOL] }
public void testFindValueDeserializerWithCachedDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType propertyType = mock(JavaType.class); [EOL] JsonDeserializer<Object> expectedDeserializer = mock(JsonDeserializer.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SimpleDeserializers deserializers = new SimpleDeserializers(); [EOL] deserializers.addDeserializer(propertyType.getRawClass(), expectedDeserializer); [EOL] mapper.setDeserializerProvider(new SimpleDeserializersProvider(deserializers)); [EOL] JsonDeserializer<Object> result = mapper.findValueDeserializer(ctxt, factory, propertyType); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testFindValueDeserializerWithCreatedDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType propertyType = mock(JavaType.class); [EOL] JsonDeserializer<Object> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(factory.createValueDeserializer(ctxt, propertyType)).thenReturn(expectedDeserializer); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.setDeserializerProvider(new SimpleDeserializersProvider(new SimpleDeserializers())); [EOL] JsonDeserializer<Object> result = mapper.findValueDeserializer(ctxt, factory, propertyType); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testFindValueDeserializerWithUnknownDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType propertyType = mock(JavaType.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.setDeserializerProvider(new SimpleDeserializersProvider(new SimpleDeserializers())); [EOL] JsonDeserializer<Object> result = mapper.findValueDeserializer(ctxt, factory, propertyType); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof UnknownDeserializer); [EOL] }
public void testFindCachedDeserializerWithNullType() { [EOL] try { [EOL] _findCachedDeserializer(null); [EOL] fail("Expected IllegalArgumentException not thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Null JavaType passed", e.getMessage()); [EOL] } [EOL] } [EOL] public void testFindCachedDeserializerWithValidType() { [EOL] JavaType mockType = mock(JavaType.class); [EOL] JsonDeserializer<Object> expectedDeserializer = mock(JsonDeserializer.class); [EOL] _cachedDeserializers.put(mockType, expectedDeserializer); [EOL] JsonDeserializer<Object> actualDeserializer = _findCachedDeserializer(mockType); [EOL] assertSame("Cached deserializer should be returned", expectedDeserializer, actualDeserializer); [EOL] }
public void testCreateAndCacheValueDeserializerWithCachedDeserializer() { [EOL] DeserializationContext ctxt = ...; // Mock or create an instance [EOL] DeserializerFactory factory = ...; // Mock or create an instance [EOL] JavaType type = ...; // Create a type instance for testing [EOL] JsonDeserializer<Object> expectedDeserializer = ...; // Mock or create an instance [EOL] when(_findCachedDeserializer(type)).thenReturn(expectedDeserializer); [EOL] JsonDeserializer<Object> actualDeserializer = _createAndCacheValueDeserializer(ctxt, factory, type); [EOL] assertSame(expectedDeserializer, actualDeserializer); [EOL] }
public void testCreateAndCacheValueDeserializerWithIncompleteDeserializers() { [EOL] DeserializationContext ctxt = ...; // Mock or create an instance [EOL] DeserializerFactory factory = ...; // Mock or create an instance [EOL] JavaType type = ...; // Create a type instance for testing [EOL] when(_findCachedDeserializer(type)).thenReturn(null); [EOL] when(_incompleteDeserializers.size()).thenReturn(1); [EOL] JsonDeserializer<Object> incompleteDeserializer = ...; // Mock or create an instance [EOL] when(_incompleteDeserializers.get(type)).thenReturn(incompleteDeserializer); [EOL] JsonDeserializer<Object> actualDeserializer = _createAndCacheValueDeserializer(ctxt, factory, type); [EOL] assertSame(incompleteDeserializer, actualDeserializer); [EOL] }
public void testCreateAndCacheValueDeserializerWithCreation() { [EOL] DeserializationContext ctxt = ...; // Mock or create an instance [EOL] DeserializerFactory factory = ...; // Mock or create an instance [EOL] JavaType type = ...; // Create a type instance for testing [EOL] when(_findCachedDeserializer(type)).thenReturn(null); [EOL] when(_incompleteDeserializers.size()).thenReturn(0); [EOL] when(_incompleteDeserializers.get(type)).thenReturn(null); [EOL] JsonDeserializer<Object> newDeserializer = ...; // Mock or create an instance [EOL] when(_createAndCache2(ctxt, factory, type)).thenReturn(newDeserializer); [EOL] JsonDeserializer<Object> actualDeserializer = _createAndCacheValueDeserializer(ctxt, factory, type); [EOL] assertSame(newDeserializer, actualDeserializer); [EOL] assertTrue(_incompleteDeserializers.isEmpty()); [EOL] }
public void testCreateAndCache2WithNullDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] when(factory.createDeserializer(ctxt, type)).thenReturn(null); [EOL] JsonDeserializer<Object> result = _createAndCache2(ctxt, factory, type); [EOL] assertNull(result); [EOL] }
public void testCreateAndCache2WithIllegalArgumentException() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] when(factory.createDeserializer(ctxt, type)).thenThrow(new IllegalArgumentException("Illegal argument")); [EOL] try { [EOL] _createAndCache2(ctxt, factory, type); [EOL] fail("Expected JsonMappingException to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals("Illegal argument", e.getMessage()); [EOL] } [EOL] }
public void testCreateAndCache2WithResolvableDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] ResolvableDeserializer resolvableDeserializer = mock(ResolvableDeserializer.class); [EOL] when(factory.createDeserializer(ctxt, type)).thenReturn(resolvableDeserializer); [EOL] when(resolvableDeserializer.isCachable()).thenReturn(false); [EOL] JsonDeserializer<Object> result = _createAndCache2(ctxt, factory, type); [EOL] verify(resolvableDeserializer).resolve(ctxt); [EOL] assertSame(resolvableDeserializer, result); [EOL] }
public void testCreateAndCache2WithCachableDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] JsonDeserializer<Object> cachableDeserializer = mock(JsonDeserializer.class); [EOL] when(factory.createDeserializer(ctxt, type)).thenReturn(cachableDeserializer); [EOL] when(cachableDeserializer.isCachable()).thenReturn(true); [EOL] JsonDeserializer<Object> result = _createAndCache2(ctxt, factory, type); [EOL] assertSame(cachableDeserializer, result); [EOL] }
public void testCreateDeserializerWithAbstractType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType abstractType = mock(JavaType.class); [EOL] when(abstractType.isAbstract()).thenReturn(true); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(factory.mapAbstractType(config, abstractType)).thenReturn(abstractType); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(config.introspect(abstractType)).thenReturn(beanDesc); [EOL] when(beanDesc.getClassInfo()).thenReturn(mock(AnnotatedClass.class)); [EOL] JsonDeserializer<Object> deserializer = new ObjectMapper().createDeserializer(ctxt, factory, abstractType); [EOL] assertNotNull(deserializer); [EOL] }
public void testCreateDeserializerWithDeserializerFromAnnotation() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(config.introspect(type)).thenReturn(beanDesc); [EOL] AnnotatedClass annotatedClass = mock(AnnotatedClass.class); [EOL] when(beanDesc.getClassInfo()).thenReturn(annotatedClass); [EOL] JsonDeserializer<Object> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(findDeserializerFromAnnotation(ctxt, annotatedClass)).thenReturn(expectedDeserializer); [EOL] JsonDeserializer<Object> deserializer = new ObjectMapper().createDeserializer(ctxt, factory, type); [EOL] assertSame(expectedDeserializer, deserializer); [EOL] }
public void testCreateDeserializerWithBuilderBasedDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(config.introspect(type)).thenReturn(beanDesc); [EOL] when(beanDesc.findPOJOBuilder()).thenReturn(Object.class); [EOL] JsonDeserializer<Object> deserializer = new ObjectMapper().createDeserializer(ctxt, factory, type); [EOL] assertNotNull(deserializer); [EOL] }
public void testCreateDeserializerWithConversion() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(config.introspect(type)).thenReturn(beanDesc); [EOL] Converter<Object, Object> converter = mock(Converter.class); [EOL] when(beanDesc.findDeserializationConverter()).thenReturn(converter); [EOL] TypeFactory typeFactory = mock(TypeFactory.class); [EOL] when(ctxt.getTypeFactory()).thenReturn(typeFactory); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] when(converter.getInputType(typeFactory)).thenReturn(delegateType); [EOL] JsonDeserializer<Object> deserializer = new ObjectMapper().createDeserializer(ctxt, factory, type); [EOL] assertNotNull(deserializer); [EOL] }
public void testCreateDeserializerWithNoConversionAndNoBuilder() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(config.introspect(type)).thenReturn(beanDesc); [EOL] when(beanDesc.findDeserializationConverter()).thenReturn(null); [EOL] when(beanDesc.findPOJOBuilder()).thenReturn(null); [EOL] JsonDeserializer<Object> deserializer = new ObjectMapper().createDeserializer(ctxt, factory, type); [EOL] assertNotNull(deserializer); [EOL] }
public void testCreateDeserializer2WithEnumType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.isEnumType()).thenReturn(true); [EOL] _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] verify(factory).createEnumDeserializer(ctxt, type, beanDesc); [EOL] }
public void testCreateDeserializer2WithArrayType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] ArrayType type = mock(ArrayType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.isContainerType()).thenReturn(true); [EOL] when(type.isArrayType()).thenReturn(true); [EOL] _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] verify(factory).createArrayDeserializer(ctxt, type, beanDesc); [EOL] }
public void testCreateDeserializer2WithMapType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] MapType type = mock(MapType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.isContainerType()).thenReturn(true); [EOL] when(type.isMapLikeType()).thenReturn(true); [EOL] when(((MapLikeType) type).isTrueMapType()).thenReturn(true); [EOL] _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] verify(factory).createMapDeserializer(ctxt, type, beanDesc); [EOL] }
public void testCreateDeserializer2WithMapLikeType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] MapLikeType type = mock(MapLikeType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.isContainerType()).thenReturn(true); [EOL] when(type.isMapLikeType()).thenReturn(true); [EOL] when(type.isTrueMapType()).thenReturn(false); [EOL] _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] verify(factory).createMapLikeDeserializer(ctxt, type, beanDesc); [EOL] }
public void testCreateDeserializer2WithCollectionType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] CollectionType type = mock(CollectionType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.isContainerType()).thenReturn(true); [EOL] when(type.isCollectionLikeType()).thenReturn(true); [EOL] when(((CollectionLikeType) type).isTrueCollectionType()).thenReturn(true); [EOL] _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] verify(factory).createCollectionDeserializer(ctxt, type, beanDesc); [EOL] }
public void testCreateDeserializer2WithCollectionLikeType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] CollectionLikeType type = mock(CollectionLikeType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JsonFormat.Value format = mock(JsonFormat.Value.class); [EOL] when(type.isContainerType()).thenReturn(true); [EOL] when(type.isCollectionLikeType()).thenReturn(true); [EOL] when(beanDesc.findExpectedFormat(null)).thenReturn(format); [EOL] when(format.getShape()).thenReturn(JsonFormat.Shape.ARRAY); // Different shape to cover the branch [EOL] _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] verify(factory).createCollectionLikeDeserializer(ctxt, type, beanDesc); [EOL] }
public void testCreateDeserializer2WithJsonNodeType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(type.getRawClass()).thenReturn(JsonNode.class); [EOL] _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] verify(factory).createTreeDeserializer(config, type, beanDesc); [EOL] }
public void testCreateDeserializer2WithBeanType() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializerFactory factory = mock(DeserializerFactory.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.isEnumType()).thenReturn(false); [EOL] when(type.isContainerType()).thenReturn(false); [EOL] when(JsonNode.class.isAssignableFrom(type.getRawClass())).thenReturn(false); [EOL] _createDeserializer2(ctxt, factory, type, beanDesc); [EOL] verify(factory).createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
public void testFindDeserializerFromAnnotationWithNullDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Annotated ann = mock(Annotated.class); [EOL] when(ctxt.getAnnotationIntrospector().findDeserializer(ann)).thenReturn(null); [EOL] JsonDeserializer<Object> result = findDeserializerFromAnnotation(ctxt, ann); [EOL] assertNull(result); [EOL] }
public void testFindDeserializerFromAnnotationWithNonNullDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Annotated ann = mock(Annotated.class); [EOL] Object deserDef = new Object(); [EOL] JsonDeserializer<Object> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(ctxt.getAnnotationIntrospector().findDeserializer(ann)).thenReturn(deserDef); [EOL] when(ctxt.deserializerInstance(ann, deserDef)).thenReturn(expectedDeserializer); [EOL] when(findConvertingDeserializer(ctxt, ann, expectedDeserializer)).thenReturn(expectedDeserializer); [EOL] JsonDeserializer<Object> result = findDeserializerFromAnnotation(ctxt, ann); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testModifyTypeByAnnotationWithSubclass() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] JavaType type = createJavaType(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithDeserializationType(type.getRawClass()); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] JavaType result = modifyTypeByAnnotation(ctxt, a, type); [EOL] assertNotNull(result); [EOL] assertNotSame(type, result); [EOL] assertEquals(type.narrowBy(type.getRawClass()), result); [EOL] }
public void testModifyTypeByAnnotationWithInvalidSubclass() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] JavaType type = createJavaType(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithInvalidDeserializationType(); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] assertThrows(JsonMappingException.class, () -> modifyTypeByAnnotation(ctxt, a, type)); [EOL] }
public void testModifyTypeByAnnotationWithKeyClassForMapLikeType() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] MapLikeType type = createMapLikeType(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithKeyDeserializationType(type.getKeyType().getRawClass()); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] JavaType result = modifyTypeByAnnotation(ctxt, a, type); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MapLikeType); [EOL] assertEquals(type.narrowKey(type.getKeyType().getRawClass()), result); [EOL] }
public void testModifyTypeByAnnotationWithIllegalKeyTypeAnnotation() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] JavaType type = createJavaType(); // Not a MapLikeType [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithKeyDeserializationType(Object.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] assertThrows(JsonMappingException.class, () -> modifyTypeByAnnotation(ctxt, a, type)); [EOL] }
public void testModifyTypeByAnnotationWithKeyDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] MapLikeType type = createMapLikeTypeWithoutKeyHandler(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithKeyDeserializer(); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] KeyDeserializer keyDeserializer = createKeyDeserializer(); [EOL] when(ctxt.keyDeserializerInstance(any(Annotated.class), any())).thenReturn(keyDeserializer); [EOL] JavaType result = modifyTypeByAnnotation(ctxt, a, type); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MapLikeType); [EOL] assertEquals(keyDeserializer, ((MapLikeType) result).getKeyType().getValueHandler()); [EOL] }
public void testModifyTypeByAnnotationWithContentType() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] JavaType type = createContainerType(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithContentType(type.getContentType().getRawClass()); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] JavaType result = modifyTypeByAnnotation(ctxt, a, type); [EOL] assertNotNull(result); [EOL] assertTrue(result.isContainerType()); [EOL] assertEquals(type.narrowContentsBy(type.getContentType().getRawClass()), result); [EOL] }
public void testModifyTypeByAnnotationWithContentDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] JavaType type = createContainerTypeWithoutContentHandler(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithContentDeserializer(); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] JsonDeserializer<?> contentDeserializer = createContentDeserializer(); [EOL] when(ctxt.deserializerInstance(any(Annotated.class), any(Class.class))).thenReturn(contentDeserializer); [EOL] JavaType result = modifyTypeByAnnotation(ctxt, a, type); [EOL] assertNotNull(result); [EOL] assertTrue(result.isContainerType()); [EOL] assertEquals(contentDeserializer, result.getContentType().getValueHandler()); [EOL] }
public void testMappingIteratorWithNullValueToUpdate() { [EOL] JavaType type = mock(JavaType.class); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<?> deser = mock(JsonDeserializer.class); [EOL] boolean managedParser = true; [EOL] MappingIterator<?> iterator = new MappingIterator<>(type, jp, ctxt, deser, managedParser, null); [EOL] assertNull(iterator._updatedValue); [EOL] }
public void testMappingIteratorWithValueToUpdate() { [EOL] JavaType type = mock(JavaType.class); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<?> deser = mock(JsonDeserializer.class); [EOL] boolean managedParser = true; [EOL] Object valueToUpdate = new Object(); [EOL] MappingIterator<?> iterator = new MappingIterator<>(type, jp, ctxt, deser, managedParser, valueToUpdate); [EOL] assertNotNull(iterator._updatedValue); [EOL] }
public void testMappingIteratorWithManagedParserAndStartArrayToken() { [EOL] JavaType type = mock(JavaType.class); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<?> deser = mock(JsonDeserializer.class); [EOL] boolean managedParser = true; [EOL] Object valueToUpdate = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] MappingIterator<?> iterator = new MappingIterator<>(type, jp, ctxt, deser, managedParser, valueToUpdate); [EOL] verify(jp).clearCurrentToken(); [EOL] }
public void testMappingIteratorWithManagedParserAndNonStartArrayToken() { [EOL] JavaType type = mock(JavaType.class); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<?> deser = mock(JsonDeserializer.class); [EOL] boolean managedParser = true; [EOL] Object valueToUpdate = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] MappingIterator<?> iterator = new MappingIterator<>(type, jp, ctxt, deser, managedParser, valueToUpdate); [EOL] verify(jp, never()).clearCurrentToken(); [EOL] }
public void testHasNextValueWithNullParser() throws IOException { [EOL] YourClass instance = new YourClass(null); // _parser is initialized to null [EOL] boolean result = instance.hasNextValue(); [EOL] assertFalse("Expected false when parser is null", result); [EOL] }
public void testHasNextValueWithEndArrayToken() throws IOException { [EOL] JsonParser mockParser = mock(JsonParser.class); [EOL] when(mockParser.getCurrentToken()).thenReturn(JsonToken.END_ARRAY); [EOL] YourClass instance = new YourClass(mockParser); [EOL] boolean result = instance.hasNextValue(); [EOL] assertFalse("Expected false when current token is END_ARRAY", result); [EOL] }
public void testHasNextValueWithNonNullParserNoTokens() throws IOException { [EOL] JsonParser mockParser = mock(JsonParser.class); [EOL] when(mockParser.getCurrentToken()).thenReturn(null); [EOL] when(mockParser.nextToken()).thenReturn(null); [EOL] YourClass instance = new YourClass(mockParser); [EOL] boolean result = instance.hasNextValue(); [EOL] assertFalse("Expected false when no more tokens are available", result); [EOL] }
public void testHasNextValueWithNonNullParserValidToken() throws IOException { [EOL] JsonParser mockParser = mock(JsonParser.class); [EOL] when(mockParser.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] YourClass instance = new YourClass(mockParser); [EOL] boolean result = instance.hasNextValue(); [EOL] assertTrue("Expected true when a valid token is present", result); [EOL] }
public void testHasNextValueWithNonNullParserAndClose() throws IOException { [EOL] JsonParser mockParser = mock(JsonParser.class); [EOL] when(mockParser.getCurrentToken()).thenReturn(null); [EOL] when(mockParser.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] YourClass instance = new YourClass(mockParser, true); // _closeParser is true [EOL] boolean result = instance.hasNextValue(); [EOL] assertFalse("Expected false when parser reaches the end and should be closed", result); [EOL] verify(mockParser, times(1)).close(); [EOL] }
public void testNextValueWithNoNext() { [EOL] try { [EOL] nextValue(); [EOL] fail("Expected NoSuchElementException"); [EOL] } catch (NoSuchElementException e) { [EOL] } [EOL] }
public void testNextValueWithNullParser() { [EOL] try { [EOL] nextValue(); [EOL] fail("Expected NoSuchElementException"); [EOL] } catch (NoSuchElementException e) { [EOL] } [EOL] }
public void testNextValueWithNonNullParserAndNullUpdatedValue() { [EOL] try { [EOL] T result = nextValue(); [EOL] assertNotNull(result); [EOL] } catch (IOException e) { [EOL] fail("Did not expect IOException"); [EOL] } [EOL] }
public void testNextValueWithNonNullParserAndNonNullUpdatedValue() { [EOL] try { [EOL] T result = nextValue(); [EOL] assertNotNull(result); [EOL] assertSame(_updatedValue, result); [EOL] } catch (IOException e) { [EOL] fail("Did not expect IOException"); [EOL] } [EOL] }
public void testBinaryNodeWithNonNullData() { [EOL] byte[] data = new byte[]{1, 2, 3}; [EOL] BinaryNode node = new BinaryNode(data); [EOL] assertArrayEquals(data, node._data); [EOL] }
public void testBinaryNodeWithNullData() { [EOL] byte[] data = null; [EOL] BinaryNode node = new BinaryNode(data); [EOL] assertNull(node._data); [EOL] }
public void testValueOfWithNullData() { [EOL] BinaryNode result = BinaryNode.valueOf(null); [EOL] assertNull(result); [EOL] }
public void testValueOfWithEmptyData() { [EOL] byte[] data = new byte[0]; [EOL] BinaryNode result = BinaryNode.valueOf(data); [EOL] assertSame(BinaryNode.EMPTY_BINARY_NODE, result); [EOL] }
public void testValueOfWithNonEmptyData() { [EOL] byte[] data = new byte[]{1, 2, 3}; [EOL] BinaryNode result = BinaryNode.valueOf(data); [EOL] assertNotNull(result); [EOL] assertNotSame(BinaryNode.EMPTY_BINARY_NODE, result); [EOL] assertTrue(Arrays.equals(data, result.data())); [EOL] }
public void testGetNodeType() { [EOL] BinaryNode node = new BinaryNode(); [EOL] assertEquals(JsonNodeType.BINARY, node.getNodeType()); [EOL] }
public void testAsToken() { [EOL] JsonEmbeddedObject obj = new JsonEmbeddedObject(); [EOL] JsonToken result = obj.asToken(); [EOL] assertEquals(JsonToken.VALUE_EMBEDDED_OBJECT, result); [EOL] }
public void testBinaryValueNonNullData() { [EOL] byte[] expectedData = new byte[]{1, 2, 3, 4}; [EOL] JacksonDatabindClass instance = new JacksonDatabindClass(expectedData); [EOL] byte[] result = instance.binaryValue(); [EOL] assertArrayEquals(expectedData, result); [EOL] }
public void testAsTextWithNonEmptyData() { [EOL] byte[] data = new byte[] { 1, 2, 3, 4 }; [EOL] BinaryNode binaryNode = new BinaryNode(data); [EOL] String text = binaryNode.asText(); [EOL] assertEquals("AQIDBA==", text); [EOL] }
public void testAsTextWithEmptyData() { [EOL] byte[] data = new byte[] {}; [EOL] BinaryNode binaryNode = new BinaryNode(data); [EOL] String text = binaryNode.asText(); [EOL] assertEquals("", text); [EOL] }
public void testCompleteAndClearBufferWithEmptyLastChunk() { [EOL] Object[] lastChunk = new Object[0]; [EOL] int lastChunkEntries = 0; [EOL] ObjectBuffer buffer = new ObjectBuffer(); [EOL] buffer.appendCompletedChunk(new Object[]{"a", "b"}); [EOL] Object[] result = buffer.completeAndClearBuffer(lastChunk, lastChunkEntries); [EOL] assertEquals(2, result.length); [EOL] assertEquals("a", result[0]); [EOL] assertEquals("b", result[1]); [EOL] }
public void testCompleteAndClearBufferWithNonEmptyLastChunk() { [EOL] Object[] lastChunk = new Object[]{"c", "d"}; [EOL] int lastChunkEntries = 2; [EOL] ObjectBuffer buffer = new ObjectBuffer(); [EOL] buffer.appendCompletedChunk(new Object[]{"a", "b"}); [EOL] Object[] result = buffer.completeAndClearBuffer(lastChunk, lastChunkEntries); [EOL] assertEquals(4, result.length); [EOL] assertEquals("a", result[0]); [EOL] assertEquals("b", result[1]); [EOL] assertEquals("c", result[2]); [EOL] assertEquals("d", result[3]); [EOL] }
public void testDeserializeWithStartObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(jp).getCurrentToken(); [EOL] }
public void testDeserializeWithStartArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(jp).getCurrentToken(); [EOL] }
public void testDeserializeWithFieldNameToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(jp).getCurrentToken(); [EOL] }
public void testDeserializeWithValueEmbeddedObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object embeddedObject = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(embeddedObject); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertSame(embeddedObject, result); [EOL] verify(jp).getCurrentToken(); [EOL] }
public void testDeserializeWithValueStringToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("string"); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertEquals("string", result); [EOL] verify(jp).getCurrentToken(); [EOL] }
public void testDeserializeWithValueNumberIntTokenWithoutBigIntFeature() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(false); [EOL] when(jp.getNumberValue()).thenReturn(42); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertEquals(42, result); [EOL] verify(jp).getCurrentToken(); [EOL] }
public void testDeserializeWithValueNumberIntTokenWithBigIntFeature() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BigInteger bigInt = new BigInteger("42"); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(true); [EOL] when(jp.getBigIntegerValue()).thenReturn(bigInt); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertEquals(bigInt, result); [EOL] verify(jp).getCurrentToken(); [EOL] }
public void testDeserializeWithValueNumberFloatTokenWithoutBigDecimalFeature() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(false); [EOL] when(jp.getDoubleValue()).thenReturn(42.0); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertEquals(Double.valueOf(42.0), result); [EOL] verify(jp).getCurrentToken(); [EOL] }
public void testDeserializeWithValueNumberFloatTokenWithBigDecimalFeature() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BigDecimal bigDecimal = new BigDecimal("42.0"); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(true); [EOL] when(jp.getDecimalValue()).thenReturn(bigDecimal); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertEquals(bigDecimal, result); [EOL] verify(jp).getCurrentToken(); [EOL] }
public void testDeserializeWithValueTrueToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertEquals(Boolean.TRUE, result); [EOL] verify(jp).getCurrentToken(); [EOL] }
public void testDeserializeWithValueFalseToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertEquals(Boolean.FALSE, result); [EOL] verify(jp).getCurrentToken(); [EOL] }
public void testDeserializeWithValueNullToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNull(result); [EOL] verify(jp).getCurrentToken(); [EOL] }
public void testDeserializeWithEndArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_ARRAY); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected exception not thrown"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] verify(jp).getCurrentToken(); [EOL] }
public void testDeserializeWithEndObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_OBJECT); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected exception not thrown"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] verify(jp).getCurrentToken(); [EOL] }
public void testDeserializeWithDefaultCaseToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(null); // No valid token to trigger default case [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected exception not thrown"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] verify(jp).getCurrentToken(); [EOL] }
public void testDeserializeWithTypeStartArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(typeDeserializer.deserializeTypedFromAny(jp, ctxt)).thenReturn(new Object()); [EOL] Object result = deserializeWithType(jp, ctxt, typeDeserializer); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithTypeStartObject() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(typeDeserializer.deserializeTypedFromAny(jp, ctxt)).thenReturn(new Object()); [EOL] Object result = deserializeWithType(jp, ctxt, typeDeserializer); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithTypeFieldName() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] when(typeDeserializer.deserializeTypedFromAny(jp, ctxt)).thenReturn(new Object()); [EOL] Object result = deserializeWithType(jp, ctxt, typeDeserializer); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithTypeValueString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("string"); [EOL] Object result = deserializeWithType(jp, null, null); [EOL] assertEquals("string", result); [EOL] }
public void testDeserializeWithTypeValueNumberIntUseBigInteger() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(true); [EOL] when(jp.getBigIntegerValue()).thenReturn(new BigInteger("123")); [EOL] Object result = deserializeWithType(jp, ctxt, null); [EOL] assertTrue(result instanceof BigInteger); [EOL] assertEquals(new BigInteger("123"), result); [EOL] }
public void testDeserializeWithTypeValueNumberInt() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(false); [EOL] when(jp.getNumberValue()).thenReturn(123); [EOL] Object result = deserializeWithType(jp, ctxt, null); [EOL] assertEquals(123, result); [EOL] }
public void testDeserializeWithTypeValueNumberFloatUseBigDecimal() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(true); [EOL] when(jp.getDecimalValue()).thenReturn(new BigDecimal("123.45")); [EOL] Object result = deserializeWithType(jp, ctxt, null); [EOL] assertTrue(result instanceof BigDecimal); [EOL] assertEquals(new BigDecimal("123.45"), result); [EOL] }
public void testDeserializeWithTypeValueNumberFloat() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(false); [EOL] when(jp.getDoubleValue()).thenReturn(123.45); [EOL] Object result = deserializeWithType(jp, ctxt, null); [EOL] assertEquals(Double.valueOf(123.45), result); [EOL] }
public void testDeserializeWithTypeValueTrue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] Object result = deserializeWithType(jp, null, null); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testDeserializeWithTypeValueFalse() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] Object result = deserializeWithType(jp, null, null); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testDeserializeWithTypeValueEmbeddedObject() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] Object embeddedObject = new Object(); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(embeddedObject); [EOL] Object result = deserializeWithType(jp, null, null); [EOL] assertSame(embeddedObject, result); [EOL] }
public void testDeserializeWithTypeValueNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] Object result = deserializeWithType(jp, null, null); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithTypeDefaultCase() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(null); [EOL] when(ctxt.mappingException(Object.class)).thenThrow(new JsonMappingException("error")); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] deserializeWithType(jp, ctxt, null); [EOL] }); [EOL] }
public void testMapArrayWithJavaArrayFeatureEnabled() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)).thenReturn(true); [EOL] Object expected = new Object(); [EOL] when(this.mapArrayToArray(jp, ctxt)).thenReturn(expected); [EOL] Object result = this.mapArray(jp, ctxt); [EOL] assertSame(expected, result); [EOL] }
public void testMapArrayWithEmptyArray() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)).thenReturn(false); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] Object result = this.mapArray(jp, ctxt); [EOL] assertTrue(result instanceof ArrayList); [EOL] assertTrue(((ArrayList) result).isEmpty()); [EOL] }
public void testMapArrayWithNonEmptyArray() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ObjectBuffer buffer = mock(ObjectBuffer.class); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)).thenReturn(false); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_ARRAY); [EOL] when(ctxt.leaseObjectBuffer()).thenReturn(buffer); [EOL] when(buffer.resetAndStart()).thenReturn(new Object[4]); [EOL] when(this.deserialize(jp, ctxt)).thenReturn("testValue"); [EOL] Object result = this.mapArray(jp, ctxt); [EOL] assertTrue(result instanceof ArrayList); [EOL] assertFalse(((ArrayList) result).isEmpty()); [EOL] assertEquals("testValue", ((ArrayList) result).get(0)); [EOL] }
public void testMapObjectWithEmptyObject() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); [EOL] Object result = mapObject(jp, ctxt); [EOL] assertTrue(result instanceof LinkedHashMap); [EOL] assertTrue(((LinkedHashMap) result).isEmpty()); [EOL] }
public void testMapObjectWithOneField() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getText()).thenReturn("field1"); [EOL] when(deserialize(jp, ctxt)).thenReturn("value1"); [EOL] Object result = mapObject(jp, ctxt); [EOL] assertTrue(result instanceof LinkedHashMap); [EOL] assertEquals(1, ((LinkedHashMap) result).size()); [EOL] assertEquals("value1", ((LinkedHashMap) result).get("field1")); [EOL] }
public void testMapObjectWithTwoFields() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getText()).thenReturn("field1").thenReturn("field2"); [EOL] when(deserialize(jp, ctxt)).thenReturn("value1").thenReturn("value2"); [EOL] Object result = mapObject(jp, ctxt); [EOL] assertTrue(result instanceof LinkedHashMap); [EOL] assertEquals(2, ((LinkedHashMap) result).size()); [EOL] assertEquals("value1", ((LinkedHashMap) result).get("field1")); [EOL] assertEquals("value2", ((LinkedHashMap) result).get("field2")); [EOL] }
public void testMapObjectWithMultipleFields() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getText()).thenReturn("field1").thenReturn("field2").thenReturn("field3"); [EOL] when(deserialize(jp, ctxt)).thenReturn("value1").thenReturn("value2").thenReturn("value3"); [EOL] Object result = mapObject(jp, ctxt); [EOL] assertTrue(result instanceof LinkedHashMap); [EOL] LinkedHashMap resultMap = (LinkedHashMap) result; [EOL] assertEquals(3, resultMap.size()); [EOL] assertEquals("value1", resultMap.get("field1")); [EOL] assertEquals("value2", resultMap.get("field2")); [EOL] assertEquals("value3", resultMap.get("field3")); [EOL] }
public void testFindWithUnlistedClassName() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Calendar.class, "UnlistedClassName"); [EOL] assertNull(deserializer); [EOL] }
public void testFindWithCalendarClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Calendar.class, "java.util.Calendar"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof CalendarDeserializer); [EOL] }
public void testFindWithUtilDateClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(java.util.Date.class, "java.util.Date"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof DateDeserializer); [EOL] }
public void testFindWithSqlDateClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(java.sql.Date.class, "java.sql.Date"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof SqlDateDeserializer); [EOL] }
public void testFindWithTimestampClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Timestamp.class, "java.sql.Timestamp"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof TimestampDeserializer); [EOL] }
public void testFindWithTimeZoneClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(TimeZone.class, "java.util.TimeZone"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof TimeZoneDeserializer); [EOL] }
public void testFindWithGregorianCalendarClass() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(GregorianCalendar.class, "java.util.GregorianCalendar"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof CalendarDeserializer); [EOL] }
public void testFindWithInvalidClass() { [EOL] try { [EOL] YourClass.find(String.class, "java.lang.String"); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
protected DateBasedDeserializer(Class<?> clz) { [EOL] super(clz); [EOL] _customFormat = null; [EOL] _formatString = null; [EOL] }
public void testCreateContextualWithPropertyAndPattern() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(ai); [EOL] JsonFormat.Value format = new JsonFormat.Value(); [EOL] format = format.withPattern("yyyy-MM-dd"); [EOL] when(ai.findFormat(member)).thenReturn(format); [EOL] when(ctxt.getLocale()).thenReturn(Locale.ENGLISH); [EOL] when(ctxt.getTimeZone()).thenReturn(TimeZone.getTimeZone("GMT")); [EOL] JsonDeserializer<?> deserializer = createContextual(ctxt, property); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof MyCustomDeserializer); // Replace with the actual expected type [EOL] }
public void testCreateContextualWithPropertyAndTimeZone() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(ai); [EOL] JsonFormat.Value format = new JsonFormat.Value(); [EOL] format = format.withTimeZone(TimeZone.getTimeZone("CET")); [EOL] when(ai.findFormat(member)).thenReturn(format); [EOL] DateFormat df = new SimpleDateFormat(); [EOL] when(ctxt.getConfig().getDateFormat()).thenReturn(df); [EOL] JsonDeserializer<?> deserializer = createContextual(ctxt, property); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof MyCustomDeserializer); // Replace with the actual expected type [EOL] }
public void testCreateContextualWithNullProperty() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = null; [EOL] JsonDeserializer<?> deserializer = createContextual(ctxt, property); [EOL] assertSame(this, deserializer); [EOL] }
public void testCreateContextualWithPropertyNoFormat() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(ai); [EOL] when(ai.findFormat(member)).thenReturn(null); [EOL] JsonDeserializer<?> deserializer = createContextual(ctxt, property); [EOL] assertSame(this, deserializer); [EOL] }
public void testCreateContextualWithPropertyAndStdDateFormat() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(property.getMember()).thenReturn(member); [EOL] AnnotationIntrospector ai = mock(AnnotationIntrospector.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(ai); [EOL] JsonFormat.Value format = new JsonFormat.Value(); [EOL] format = format.withTimeZone(TimeZone.getTimeZone("CET")); [EOL] when(ai.findFormat(member)).thenReturn(format); [EOL] StdDateFormat stdDateFormat = mock(StdDateFormat.class); [EOL] when(ctxt.getConfig().getDateFormat()).thenReturn(stdDateFormat); [EOL] when(stdDateFormat.getClass()).thenReturn(StdDateFormat.class); [EOL] when(stdDateFormat.withTimeZone(any(TimeZone.class))).thenReturn(stdDateFormat); [EOL] JsonDeserializer<?> deserializer = createContextual(ctxt, property); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof MyCustomDeserializer); // Replace with the actual expected type [EOL] }
public void testParseDateWithCustomFormatAndValidString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] SimpleDateFormat customFormat = new SimpleDateFormat("yyyy-MM-dd"); [EOL] String validDateString = "2020-01-01"; [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(validDateString); [EOL] YourDeserializationClass deserializer = new YourDeserializationClass(customFormat, "yyyy-MM-dd"); [EOL] Date result = deserializer._parseDate(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(customFormat.parse(validDateString), result); [EOL] }
public void testParseDateWithCustomFormatAndEmptyString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] SimpleDateFormat customFormat = new SimpleDateFormat("yyyy-MM-dd"); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(" "); [EOL] YourDeserializationClass deserializer = new YourDeserializationClass(customFormat, "yyyy-MM-dd"); [EOL] Date result = deserializer._parseDate(jp, ctxt); [EOL] assertEquals(deserializer.getEmptyValue(), result); [EOL] }
public void testParseDateWithCustomFormatAndInvalidString() { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] SimpleDateFormat customFormat = new SimpleDateFormat("yyyy-MM-dd"); [EOL] String invalidDateString = "invalid-date"; [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(invalidDateString); [EOL] YourDeserializationClass deserializer = new YourDeserializationClass(customFormat, "yyyy-MM-dd"); [EOL] assertThrows(IllegalArgumentException.class, () -> { [EOL] deserializer._parseDate(jp, ctxt); [EOL] }); [EOL] }
public void testParseDateWithoutCustomFormat() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] YourDeserializationClass deserializer = new YourDeserializationClass(null, null); [EOL] Date result = deserializer._parseDate(jp, ctxt); [EOL] verify(deserializer, times(1))._parseDate(jp, ctxt); [EOL] }
public void testCalendarDeserializerConstructor() { [EOL] CalendarDeserializer deserializer = new CalendarDeserializer(); [EOL] assertNotNull(deserializer); [EOL] assertNull(deserializer._calendarClass); [EOL] }
public void testCalendarDeserializerWithGregorianCalendarClass() { [EOL] Class<? extends Calendar> calendarClass = GregorianCalendar.class; [EOL] CalendarDeserializer deserializer = new CalendarDeserializer(calendarClass); [EOL] assertEquals(GregorianCalendar.class, deserializer._calendarClass); [EOL] }
public void testCalendarDeserializerWithCustomCalendarClass() { [EOL] Class<? extends Calendar> calendarClass = CustomCalendar.class; [EOL] CalendarDeserializer deserializer = new CalendarDeserializer(calendarClass); [EOL] assertEquals(CustomCalendar.class, deserializer._calendarClass); [EOL] }
public void testDeserializeWithNullDate() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getText()).thenReturn(null); [EOL] StdDeserializer.CalendarDeserializer deserializer = new StdDeserializer.CalendarDeserializer(); [EOL] Calendar result = deserializer.deserialize(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithNonNullDateAndNullCalendarClass() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Date d = new Date(); [EOL] when(jp.getText()).thenReturn("2023-01-01T00:00:00Z"); [EOL] when(ctxt.constructCalendar(d)).thenReturn(Calendar.getInstance()); [EOL] StdDeserializer.CalendarDeserializer deserializer = new StdDeserializer.CalendarDeserializer(); [EOL] Calendar result = deserializer.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(d.getTime(), result.getTimeInMillis()); [EOL] }
public void testDeserializeWithNonNullDateAndNonNullCalendarClass() throws IOException, IllegalAccessException, InstantiationException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Date d = new Date(); [EOL] when(jp.getText()).thenReturn("2023-01-01T00:00:00Z"); [EOL] when(ctxt.getTimeZone()).thenReturn(TimeZone.getDefault()); [EOL] StdDeserializer.CalendarDeserializer deserializer = new StdDeserializer.CalendarDeserializer(Calendar.class); [EOL] Calendar result = deserializer.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(d.getTime(), result.getTimeInMillis()); [EOL] }
public void testDeserializeWithInstantiationException() throws IOException, IllegalAccessException, InstantiationException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Date d = new Date(); [EOL] when(jp.getText()).thenReturn("2023-01-01T00:00:00Z"); [EOL] when(ctxt.instantiationException(any(Class.class), any(Exception.class))).thenThrow(new IOException()); [EOL] StdDeserializer.CalendarDeserializer deserializer = new StdDeserializer.CalendarDeserializer(Calendar.class); [EOL] deserializer._calendarClass = BrokenCalendar.class; // Assuming BrokenCalendar is a class that cannot be instantiated [EOL] assertThrows(IOException.class, () -> { [EOL] deserializer.deserialize(jp, ctxt); [EOL] }); [EOL] }
public void testSqlDateDeserializerConstructor() { [EOL] SqlDateDeserializer deserializer = new SqlDateDeserializer(); [EOL] assertNotNull(deserializer); [EOL] assertEquals(java.sql.Date.class, deserializer.handledType()); [EOL] }
public void testDeserializeWithNullDate() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NULL); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType javaType = mapper.constructType(java.sql.Date.class); [EOL] JsonDeserializer<?> deserializer = mapper.getDeserializationContext().findContextualValueDeserializer(javaType, null); [EOL] java.sql.Date result = (java.sql.Date) deserializer.deserialize(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithNonNullDate() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getText()).thenReturn("1970-01-01"); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JavaType javaType = mapper.constructType(java.sql.Date.class); [EOL] JsonDeserializer<?> deserializer = mapper.getDeserializationContext().findContextualValueDeserializer(javaType, null); [EOL] java.sql.Date result = (java.sql.Date) deserializer.deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(java.sql.Date.valueOf("1970-01-01").getTime(), result.getTime()); [EOL] }
public void testGetRawType() throws NoSuchMethodException { [EOL] Method method = TargetClass.class.getMethod("targetMethod"); [EOL] MethodBasedType methodBasedType = new MethodBasedType(method); [EOL] Class<?> rawType = methodBasedType.getRawType(); [EOL] assertNotNull(rawType); [EOL] assertEquals(TargetClass.class, rawType); [EOL] }
public void testCallWithValidArgs() throws Exception { [EOL] Object[] args = new Object[] {/* some valid arguments for the method */}; [EOL] Method mockMethod = mock(Method.class); [EOL] when(mockMethod.invoke(null, args)).thenReturn(/* expected result */); [EOL] Object result = instance.call(args); [EOL] assertEquals(/* expected result */, result); [EOL] }
public void testCallWithInvalidArgs() throws Exception { [EOL] Object[] args = new Object[] {/* some invalid arguments for the method */}; [EOL] Method mockMethod = mock(Method.class); [EOL] when(mockMethod.invoke(null, args)).thenThrow(new IllegalArgumentException()); [EOL] try { [EOL] instance.call(args); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (Exception e) { [EOL] assertTrue(e instanceof IllegalArgumentException); [EOL] } [EOL] }
public void testCallWithNullArgs() throws Exception { [EOL] Object[] args = null; [EOL] Method mockMethod = mock(Method.class); [EOL] when(mockMethod.invoke(null, args)).thenThrow(new NullPointerException()); [EOL] try { [EOL] instance.call(args); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (Exception e) { [EOL] assertTrue(e instanceof NullPointerException); [EOL] } [EOL] }
public void testSkipChildrenWithStartObject() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.START_OBJECT); [EOL] JsonParser result = parser.skipChildren(); [EOL] assertEquals(JsonToken.END_OBJECT, parser.getCurrentToken()); [EOL] assertSame(parser, result); [EOL] }
public void testSkipChildrenWithStartArray() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.START_ARRAY); [EOL] JsonParser result = parser.skipChildren(); [EOL] assertEquals(JsonToken.END_ARRAY, parser.getCurrentToken()); [EOL] assertSame(parser, result); [EOL] }
public void testSkipChildrenWithOtherToken() throws IOException, JsonParseException { [EOL] JsonParser parser = createParserWithToken(JsonToken.VALUE_STRING); [EOL] JsonParser result = parser.skipChildren(); [EOL] assertNotEquals(JsonToken.START_OBJECT, parser.getCurrentToken()); [EOL] assertNotEquals(JsonToken.START_ARRAY, parser.getCurrentToken()); [EOL] assertSame(parser, result); [EOL] }
public void testGetCurrentNameWhenNodeCursorIsNull() { [EOL] JsonNodeTraversingParser parser = new JsonNodeTraversingParser(null, null); [EOL] String currentName = parser.getCurrentName(); [EOL] assertNull(currentName); [EOL] }
public void testGetCurrentNameWhenNodeCursorIsNotNull() { [EOL] JsonNode mockNode = mock(JsonNode.class); [EOL] NodeCursor mockCursor = new NodeCursor(mockNode, null); [EOL] when(mockCursor.getCurrentName()).thenReturn("testName"); [EOL] JsonNodeTraversingParser parser = new JsonNodeTraversingParser(null, mockCursor); [EOL] String currentName = parser.getCurrentName(); [EOL] assertEquals("testName", currentName); [EOL] }
public void testGetTextWhenClosed() { [EOL] JsonParser parser = createParserWithClosedState(); [EOL] String result = parser.getText(); [EOL] assertNull(result); [EOL] }
public void testGetTextWithFieldName() { [EOL] JsonParser parser = createParserWithState(JsonToken.FIELD_NAME, "fieldName"); [EOL] String result = parser.getText(); [EOL] assertEquals("fieldName", result); [EOL] }
public void testGetTextWithValueString() { [EOL] JsonParser parser = createParserWithState(JsonToken.VALUE_STRING, "stringValue"); [EOL] String result = parser.getText(); [EOL] assertEquals("stringValue", result); [EOL] }
public void testGetTextWithValueNumberInt() { [EOL] JsonParser parser = createParserWithState(JsonToken.VALUE_NUMBER_INT, 123); [EOL] String result = parser.getText(); [EOL] assertEquals("123", result); [EOL] }
public void testGetTextWithValueNumberFloat() { [EOL] JsonParser parser = createParserWithState(JsonToken.VALUE_NUMBER_FLOAT, 123.45); [EOL] String result = parser.getText(); [EOL] assertEquals("123.45", result); [EOL] }
public void testGetTextWithValueEmbeddedObjectBinary() { [EOL] JsonParser parser = createParserWithBinaryNode(); [EOL] String result = parser.getText(); [EOL] assertNotNull(result); [EOL] assertEquals("base64EncodedString", result); [EOL] }
public void testGetTextWithNullCurrentToken() { [EOL] JsonParser parser = createParserWithNullCurrentToken(); [EOL] String result = parser.getText(); [EOL] assertNull(result); [EOL] }
public void testGetTextWithNonBinaryEmbeddedObject() { [EOL] JsonParser parser = createParserWithNonBinaryEmbeddedObject(); [EOL] String result = parser.getText(); [EOL] assertEquals("nonBinaryObjectText", result); [EOL] }
public void testGetTextWithUnrecognizedToken() { [EOL] JsonParser parser = createParserWithUnrecognizedToken(); [EOL] String result = parser.getText(); [EOL] assertEquals("unrecognizedTokenAsString", result); [EOL] }
public void testGetIntValueWithIntNode() throws IOException, JsonParseException { [EOL] JsonNodeFactory nodeFactory = JsonNodeFactory.instance; [EOL] IntNode intNode = nodeFactory.numberNode(5); [EOL] JsonParser parser = new TreeTraversingParser(intNode); [EOL] assertEquals(5, parser.getIntValue()); [EOL] }
public void testGetIntValueWithNonIntNode() throws IOException, JsonParseException { [EOL] JsonNodeFactory nodeFactory = JsonNodeFactory.instance; [EOL] TextNode textNode = nodeFactory.textNode("not an int"); [EOL] JsonParser parser = new TreeTraversingParser(textNode); [EOL] try { [EOL] parser.getIntValue(); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testCurrentNumericNodeWithNullCurrentNode() throws JsonParseException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.currentNode()).thenReturn(null); [EOL] try { [EOL] currentNumericNode(); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] assertEquals("Current token (null) not numeric, can not use numeric value accessors", e.getMessage()); [EOL] } [EOL] }
public void testCurrentNumericNodeWithNonNumberCurrentNode() throws JsonParseException { [EOL] JsonNode nonNumberNode = mock(JsonNode.class); [EOL] when(nonNumberNode.isNumber()).thenReturn(false); [EOL] when(nonNumberNode.asToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.currentNode()).thenReturn(nonNumberNode); [EOL] try { [EOL] currentNumericNode(); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] assertEquals("Current token (VALUE_STRING) not numeric, can not use numeric value accessors", e.getMessage()); [EOL] } [EOL] }
public void testCurrentNumericNodeWithNumberCurrentNode() throws JsonParseException { [EOL] JsonNode numberNode = mock(JsonNode.class); [EOL] when(numberNode.isNumber()).thenReturn(true); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.currentNode()).thenReturn(numberNode); [EOL] JsonNode result = currentNumericNode(); [EOL] assertSame(numberNode, result); [EOL] }
public void testSerializeWithType_NullValue() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] JsonSerializer<Object> serializer = new JsonSerializer<Object>() { [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider serializers) { [EOL] } [EOL] @Override [EOL] public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider serializers, TypeSerializer typeSer) throws IOException { [EOL] super.serializeWithType(value, gen, serializers, typeSer); [EOL] } [EOL] }; [EOL] serializer.serializeWithType(null, jgen, provider, typeSer); [EOL] verify(typeSer).writeTypePrefixForArray(null, jgen); [EOL] verify(typeSer).writeTypeSuffixForArray(null, jgen); [EOL] }
public void testSerializeWithType_NonNullValue() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] Object value = new Object(); [EOL] JsonSerializer<Object> serializer = new JsonSerializer<Object>() { [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider serializers) { [EOL] } [EOL] @Override [EOL] public void serializeContents(Object value, JsonGenerator gen, SerializerProvider serializers) throws IOException { [EOL] gen.writeString("content"); [EOL] } [EOL] @Override [EOL] public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider serializers, TypeSerializer typeSer) throws IOException { [EOL] super.serializeWithType(value, gen, serializers, typeSer); [EOL] } [EOL] }; [EOL] serializer.serializeWithType(value, jgen, provider, typeSer); [EOL] verify(typeSer).writeTypePrefixForArray(value, jgen); [EOL] verify(jgen).writeString("content"); [EOL] verify(typeSer).writeTypeSuffixForArray(value, jgen); [EOL] }
public void testSerializeWithNonNullTimeZone() throws IOException { [EOL] TimeZone timeZone = TimeZone.getTimeZone("GMT"); [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] new TimeZoneSerializer().serialize(timeZone, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeString("GMT"); [EOL] }
public void testBuildWithNullPropertiesAndNullAnyGetter() { [EOL] BeanSerializerBuilder builder = new BeanSerializerBuilder(null); [EOL] builder.setProperties(null); [EOL] builder.setAnyGetter(null); [EOL] JsonSerializer<?> serializer = builder.build(); [EOL] assertNull(serializer); [EOL] }
public void testBuildWithEmptyPropertiesAndNullAnyGetter() { [EOL] BeanSerializerBuilder builder = new BeanSerializerBuilder(null); [EOL] builder.setProperties(Collections.emptyList()); [EOL] builder.setAnyGetter(null); [EOL] JsonSerializer<?> serializer = builder.build(); [EOL] assertNull(serializer); [EOL] }
public void testBuildWithNonEmptyProperties() { [EOL] BeanSerializerBuilder builder = new BeanSerializerBuilder(null); [EOL] List<BeanPropertyWriter> propertyList = new ArrayList<>(); [EOL] propertyList.add(mock(BeanPropertyWriter.class)); [EOL] builder.setProperties(propertyList); [EOL] builder.setAnyGetter(null); [EOL] JsonSerializer<?> serializer = builder.build(); [EOL] assertNotNull(serializer); [EOL] assertTrue(serializer instanceof BeanSerializer); [EOL] }
public void testCreateDummyWithValidType() { [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] JavaType javaType = mock(JavaType.class); [EOL] when(beanDesc.getType()).thenReturn(javaType); [EOL] BeanSerializerFactory factory = new BeanSerializerFactory(null); [EOL] BeanSerializer result = factory.createDummy(); [EOL] assertNotNull(result); [EOL] }
public void testCreateDummyWithNullType() { [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(beanDesc.getType()).thenReturn(null); [EOL] BeanSerializerFactory factory = new BeanSerializerFactory(null); [EOL] try { [EOL] factory.createDummy(); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Type cannot be null", e.getMessage()); [EOL] } [EOL] }
public void testClassIntrospectorConstructor() { [EOL] new ClassIntrospector(); [EOL] }
public void testDeserializeTypedFromArrayWithValidInput() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object expectedResult = new Object(); [EOL] TypedArrayDeserializer deserializer = new TypedArrayDeserializer(); [EOL] when(deserializer._deserialize(jp, ctxt)).thenReturn(expectedResult); [EOL] Object result = deserializer.deserializeTypedFromArray(jp, ctxt); [EOL] assertEquals(expectedResult, result); [EOL] }
public void testDeserializeTypedFromArrayWithIOException() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypedArrayDeserializer deserializer = new TypedArrayDeserializer(); [EOL] when(deserializer._deserialize(jp, ctxt)).thenThrow(new IOException()); [EOL] assertThrows(IOException.class, () -> { [EOL] deserializer.deserializeTypedFromArray(jp, ctxt); [EOL] }); [EOL] }
public void testDeserializeTypedFromArrayWithJsonProcessingException() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypedArrayDeserializer deserializer = new TypedArrayDeserializer(); [EOL] when(deserializer._deserialize(jp, ctxt)).thenThrow(new JsonProcessingException("") {}); [EOL] assertThrows(JsonProcessingException.class, () -> { [EOL] deserializer.deserializeTypedFromArray(jp, ctxt); [EOL] }); [EOL] }
public void testNullNode() { [EOL] JsonNodeFactory factory = new JsonNodeFactory(false); [EOL] NullNode nullNode = factory.nullNode(); [EOL] assertNotNull(nullNode); [EOL] assertTrue(nullNode instanceof NullNode); [EOL] }
public void testNumberNodeWithPositiveFloat() { [EOL] float inputValue = 123.45f; [EOL] NumericNode result = numberNode(inputValue); [EOL] assertTrue(result instanceof FloatNode); [EOL] assertEquals(inputValue, result.floatValue(), 0.0f); [EOL] }
public void testNumberNodeWithNegativeFloat() { [EOL] float inputValue = -123.45f; [EOL] NumericNode result = numberNode(inputValue); [EOL] assertTrue(result instanceof FloatNode); [EOL] assertEquals(inputValue, result.floatValue(), 0.0f); [EOL] }
public void testNumberNodeWithZero() { [EOL] float inputValue = 0.0f; [EOL] NumericNode result = numberNode(inputValue); [EOL] assertTrue(result instanceof FloatNode); [EOL] assertEquals(inputValue, result.floatValue(), 0.0f); [EOL] }
public void testSimpleBeanPropertyDefinitionWithNonNullValues() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] String name = "propertyName"; [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] SimpleBeanPropertyDefinition beanPropDef = new SimpleBeanPropertyDefinition(member, name, intr); [EOL] assertNotNull(beanPropDef); [EOL] assertEquals(member, beanPropDef.getMember()); [EOL] assertEquals(name, beanPropDef.getName()); [EOL] assertEquals(intr, beanPropDef.getIntrospector()); [EOL] }
public void testSimpleBeanPropertyDefinitionWithNullValues() { [EOL] SimpleBeanPropertyDefinition beanPropDef = new SimpleBeanPropertyDefinition(null, null, null); [EOL] assertNotNull(beanPropDef); [EOL] assertNull(beanPropDef.getMember()); [EOL] assertNull(beanPropDef.getName()); [EOL] assertNull(beanPropDef.getIntrospector()); [EOL] }
public void testConstructWithNonNullConfig() { [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(member.getName()).thenReturn("propertyName"); [EOL] AnnotationIntrospector introspector = mock(AnnotationIntrospector.class); [EOL] when(config.getAnnotationIntrospector()).thenReturn(introspector); [EOL] SimpleBeanPropertyDefinition result = SimpleBeanPropertyDefinition.construct(config, member); [EOL] assertNotNull(result); [EOL] assertEquals(member, result.getMember()); [EOL] assertEquals("propertyName", result.getName()); [EOL] assertEquals(introspector, result.getAnnotationIntrospector()); [EOL] }
public void testConstructWithNullConfig() { [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] when(member.getName()).thenReturn("propertyName"); [EOL] SimpleBeanPropertyDefinition result = SimpleBeanPropertyDefinition.construct(null, member); [EOL] assertNotNull(result); [EOL] assertEquals(member, result.getMember()); [EOL] assertEquals("propertyName", result.getName()); [EOL] assertNull(result.getAnnotationIntrospector()); [EOL] }
public void testConstructWithNonNullConfig() { [EOL] MapperConfig<?> config = mock(MapperConfig.class); [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] String name = "propertyName"; [EOL] when(config.getAnnotationIntrospector()).thenReturn(mock(AnnotationIntrospector.class)); [EOL] SimpleBeanPropertyDefinition result = SimpleBeanPropertyDefinition.construct(config, member, name); [EOL] assertNotNull(result); [EOL] assertEquals(member, result.getMember()); [EOL] assertEquals(name, result.getName()); [EOL] assertNotNull(result.getAnnotationIntrospector()); [EOL] }
public void testConstructWithNullConfig() { [EOL] MapperConfig<?> config = null; [EOL] AnnotatedMember member = mock(AnnotatedMember.class); [EOL] String name = "propertyName"; [EOL] SimpleBeanPropertyDefinition result = SimpleBeanPropertyDefinition.construct(config, member, name); [EOL] assertNotNull(result); [EOL] assertEquals(member, result.getMember()); [EOL] assertEquals(name, result.getName()); [EOL] assertNull(result.getAnnotationIntrospector()); [EOL] }
public void testGetName() { [EOL] YourClass instance = new YourClass("TestName"); [EOL] String expected = "TestName"; [EOL] String actual = instance.getName(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetWrapperNameWhenIntrospectorIsNull() { [EOL] MyObject underTest = new MyObject(null, _member); [EOL] PropertyName result = underTest.getWrapperName(); [EOL] assertNull(result); [EOL] }
public void testGetWrapperNameWhenIntrospectorIsNotNull() { [EOL] Introspector mockIntrospector = mock(Introspector.class); [EOL] Member member = ...; // appropriate member initialization [EOL] PropertyName expectedWrapperName = new PropertyName("expectedWrapper"); [EOL] when(mockIntrospector.findWrapperName(member)).thenReturn(expectedWrapperName); [EOL] MyObject underTest = new MyObject(mockIntrospector, member); [EOL] PropertyName result = underTest.getWrapperName(); [EOL] assertNotNull(result); [EOL] assertEquals(expectedWrapperName, result); [EOL] }
public void testGetSetterWithAnnotatedMethodAndOneParameter() { [EOL] AnnotatedMethod annotatedMethod = Mockito.mock(AnnotatedMethod.class); [EOL] Mockito.when(annotatedMethod.getParameterCount()).thenReturn(1); [EOL] MyObjectUnderTest myObjectUnderTest = new MyObjectUnderTest(annotatedMethod); [EOL] AnnotatedMethod result = myObjectUnderTest.getSetter(); [EOL] assertNotNull(result); [EOL] assertEquals(annotatedMethod, result); [EOL] }
public void testGetSetterWithAnnotatedMethodAndMoreThanOneParameter() { [EOL] AnnotatedMethod annotatedMethod = Mockito.mock(AnnotatedMethod.class); [EOL] Mockito.when(annotatedMethod.getParameterCount()).thenReturn(2); [EOL] MyObjectUnderTest myObjectUnderTest = new MyObjectUnderTest(annotatedMethod); [EOL] AnnotatedMethod result = myObjectUnderTest.getSetter(); [EOL] assertNull(result); [EOL] }
public void testGetSetterWithNonAnnotatedMethodMember() { [EOL] Object nonAnnotatedMethodMember = new Object(); [EOL] MyObjectUnderTest myObjectUnderTest = new MyObjectUnderTest(nonAnnotatedMethodMember); [EOL] AnnotatedMethod result = myObjectUnderTest.getSetter(); [EOL] assertNull(result); [EOL] }
public void testGetFieldWhenMemberIsAnnotatedField() { [EOL] AnnotatedField annotatedField = mock(AnnotatedField.class); [EOL] JacksonDatabindClass instance = new JacksonDatabindClass(annotatedField); [EOL] AnnotatedField result = instance.getField(); [EOL] assertEquals(annotatedField, result); [EOL] }
public void testGetFieldWhenMemberIsNotAnnotatedField() { [EOL] Object nonAnnotatedFieldMember = new Object(); [EOL] JacksonDatabindClass instance = new JacksonDatabindClass(nonAnnotatedFieldMember); [EOL] AnnotatedField result = instance.getField(); [EOL] assertNull(result); [EOL] }
public void testGetConstructorParameterWithAnnotatedParameterMember() { [EOL] AnnotatedParameter annotatedParameter = mock(AnnotatedParameter.class); [EOL] JacksonAnnotationIntrospector introspector = new JacksonAnnotationIntrospector() { [EOL] @Override [EOL] public AnnotatedMember getMember() { [EOL] return annotatedParameter; [EOL] } [EOL] }; [EOL] AnnotatedParameter result = introspector.getConstructorParameter(); [EOL] assertNotNull(result); [EOL] assertSame(annotatedParameter, result); [EOL] }
public void testGetConstructorParameterWithNonAnnotatedParameterMember() { [EOL] AnnotatedMember nonAnnotatedParameterMember = mock(AnnotatedMember.class); [EOL] JacksonAnnotationIntrospector introspector = new JacksonAnnotationIntrospector() { [EOL] @Override [EOL] public AnnotatedMember getMember() { [EOL] return nonAnnotatedParameterMember; [EOL] } [EOL] }; [EOL] AnnotatedParameter result = introspector.getConstructorParameter(); [EOL] assertNull(result); [EOL] }
public void testGetMutator_ConstructorParameterNotNull() { [EOL] AnnotatedMember mockConstructorParameter = mock(AnnotatedMember.class); [EOL] when(instance.getConstructorParameter()).thenReturn(mockConstructorParameter); [EOL] AnnotatedMember result = instance.getMutator(); [EOL] assertNotNull(result); [EOL] assertEquals(mockConstructorParameter, result); [EOL] }
public void testGetMutator_ConstructorParameterNull_SetterNotNull() { [EOL] AnnotatedMember mockSetter = mock(AnnotatedMember.class); [EOL] when(instance.getConstructorParameter()).thenReturn(null); [EOL] when(instance.getSetter()).thenReturn(mockSetter); [EOL] AnnotatedMember result = instance.getMutator(); [EOL] assertNotNull(result); [EOL] assertEquals(mockSetter, result); [EOL] }
public void testGetMutator_ConstructorParameterNull_SetterNull_FieldNotNull() { [EOL] AnnotatedMember mockField = mock(AnnotatedMember.class); [EOL] when(instance.getConstructorParameter()).thenReturn(null); [EOL] when(instance.getSetter()).thenReturn(null); [EOL] when(instance.getField()).thenReturn(mockField); [EOL] AnnotatedMember result = instance.getMutator(); [EOL] assertNotNull(result); [EOL] assertEquals(mockField, result); [EOL] }
public void testGetMutator_AllNull() { [EOL] when(instance.getConstructorParameter()).thenReturn(null); [EOL] when(instance.getSetter()).thenReturn(null); [EOL] when(instance.getField()).thenReturn(null); [EOL] AnnotatedMember result = instance.getMutator(); [EOL] assertNull(result); [EOL] }
public void testGetSchemaWithNonOptional() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] Type typeHint = mock(Type.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(false); [EOL] ObjectNode expectedSchema = nodeFactory.objectNode(); [EOL] expectedSchema.put("required", true); [EOL] YourSerializer serializer = new YourSerializer(); [EOL] JsonNode actualSchema = serializer.getSchema(provider, typeHint, false); [EOL] assertEquals(expectedSchema, actualSchema); [EOL] }
public void testGetSchemaWithOptional() throws JsonMappingException { [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] Type typeHint = mock(Type.class); [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(false); [EOL] ObjectNode expectedSchema = nodeFactory.objectNode(); [EOL] YourSerializer serializer = new YourSerializer(); [EOL] JsonNode actualSchema = serializer.getSchema(provider, typeHint, true); [EOL] assertEquals(expectedSchema, actualSchema); [EOL] }
protected ObjectNode createObjectNode() { [EOL] return JsonNodeFactory.instance.objectNode(); [EOL] }
public void testCreateSchemaNodeWithNullType() { [EOL] ObjectNode result = createSchemaNode(null); [EOL] assertNotNull(result); [EOL] assertTrue(result.has("type")); [EOL] assertNull(result.get("type").textValue()); [EOL] }
public void testCreateSchemaNodeWithTypeString() { [EOL] String testType = "string"; [EOL] ObjectNode result = createSchemaNode(testType); [EOL] assertNotNull(result); [EOL] assertTrue(result.has("type")); [EOL] assertEquals(testType, result.get("type").textValue()); [EOL] }
public void testCreateSchemaNodeWithTypeAndIsOptionalFalse() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectNode result = mapper.createSchemaNode("myType", false); [EOL] assertNotNull(result); [EOL] assertEquals("myType", result.get("type").asText()); [EOL] assertTrue(result.get("required").asBoolean()); [EOL] }
public void testCreateSchemaNodeWithTypeAndIsOptionalTrue() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] ObjectNode result = mapper.createSchemaNode("myType", true); [EOL] assertNotNull(result); [EOL] assertEquals("myType", result.get("type").asText()); [EOL] assertNull(result.get("required")); [EOL] }
public void testWrapAndThrowWithInvocationTargetException() throws IOException { [EOL] SerializerProvider provider = null; [EOL] Throwable cause = new IOException("Inner exception"); [EOL] Throwable t = new InvocationTargetException(cause); [EOL] Object bean = new Object(); [EOL] int index = 0; [EOL] try { [EOL] wrapAndThrow(provider, t, bean, index); [EOL] fail("Expected JsonMappingException to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] assertSame(cause, e.getCause()); [EOL] } [EOL] }
public void testWrapAndThrowWithError() { [EOL] SerializerProvider provider = null; [EOL] Throwable t = new Error("Serious error"); [EOL] Object bean = new Object(); [EOL] int index = 0; [EOL] try { [EOL] wrapAndThrow(provider, t, bean, index); [EOL] fail("Expected Error to be thrown"); [EOL] } catch (Error e) { [EOL] assertEquals("Serious error", e.getMessage()); [EOL] } [EOL] }
public void testWrapAndThrowWithIOException() throws IOException { [EOL] SerializerProvider provider = null; [EOL] Throwable t = new IOException("IO exception"); [EOL] Object bean = new Object(); [EOL] int index = 0; [EOL] try { [EOL] wrapAndThrow(provider, t, bean, index); [EOL] fail("Expected IOException to be thrown"); [EOL] } catch (IOException e) { [EOL] assertEquals("IO exception", e.getMessage()); [EOL] } [EOL] }
public void testWrapAndThrowWithRuntimeException() { [EOL] SerializerProvider provider = new SerializerProvider() { [EOL] @Override [EOL] public boolean isEnabled(SerializationFeature feature) { [EOL] return false; [EOL] } [EOL] }; [EOL] Throwable t = new RuntimeException("Runtime exception"); [EOL] Object bean = new Object(); [EOL] int index = 0; [EOL] try { [EOL] wrapAndThrow(provider, t, bean, index); [EOL] fail("Expected RuntimeException to be thrown"); [EOL] } catch (RuntimeException e) { [EOL] assertEquals("Runtime exception", e.getMessage()); [EOL] } [EOL] }
public void testWrapAndThrowWithOtherException() { [EOL] SerializerProvider provider = new SerializerProvider() { [EOL] @Override [EOL] public boolean isEnabled(SerializationFeature feature) { [EOL] return true; [EOL] } [EOL] }; [EOL] Throwable t = new Exception("Other exception"); [EOL] Object bean = new Object(); [EOL] int index = 0; [EOL] try { [EOL] wrapAndThrow(provider, t, bean, index); [EOL] fail("Expected JsonMappingException to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] assertSame(t, e.getCause()); [EOL] } [EOL] }
public void testMapAbstractTypeWithNullNextType() throws JsonMappingException { [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] JavaType type = new SimpleType(Object.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TypeFactory typeFactory = mapper.getTypeFactory(); [EOL] JavaType result = mapper.mapAbstractType(config, type); [EOL] assertEquals(type, result); [EOL] }
public void testMapAbstractTypeWithSameTypeReturned() throws JsonMappingException { [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] JavaType type = new SimpleType(String.class); [EOL] ObjectMapper mapper = new ObjectMapper() { [EOL] @Override [EOL] public JavaType _mapAbstractType2(DeserializationConfig config, JavaType type) { [EOL] return type; [EOL] } [EOL] }; [EOL] try { [EOL] mapper.mapAbstractType(config, type); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testMapAbstractTypeWithSubTypeReturned() throws JsonMappingException { [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] JavaType type = new SimpleType(Number.class); [EOL] ObjectMapper mapper = new ObjectMapper() { [EOL] @Override [EOL] public JavaType _mapAbstractType2(DeserializationConfig config, JavaType type) { [EOL] return new SimpleType(Integer.class); [EOL] } [EOL] }; [EOL] JavaType result = mapper.mapAbstractType(config, type); [EOL] assertEquals(Integer.class, result.getRawClass()); [EOL] }
public void testMapAbstractType2WithNoAbstractTypeResolvers() throws JsonMappingException { [EOL] DeserializationConfig config = new DeserializationConfig(...); [EOL] JavaType type = new JavaType(...); [EOL] _factoryConfig.setAbstractTypeResolvers(Collections.emptyList()); [EOL] JavaType result = _mapAbstractType2(config, type); [EOL] assertNull(result); [EOL] }
public void testMapAbstractType2WithAbstractTypeResolvers() throws JsonMappingException { [EOL] DeserializationConfig config = new DeserializationConfig(...); [EOL] JavaType type = new JavaType(...); [EOL] AbstractTypeResolver resolver = new AbstractTypeResolver() { [EOL] @Override [EOL] public JavaType findTypeMapping(DeserializationConfig config, JavaType type) { [EOL] return new JavaType(...); [EOL] } [EOL] }; [EOL] _factoryConfig.setAbstractTypeResolvers(Collections.singletonList(resolver)); [EOL] JavaType result = _mapAbstractType2(config, type); [EOL] assertNotNull(result); [EOL] assertNotEquals(type.getRawClass(), result.getRawClass()); [EOL] }
public void testMapAbstractType2WithUnresolvedAbstractType() throws JsonMappingException { [EOL] DeserializationConfig config = new DeserializationConfig(...); [EOL] JavaType type = new JavaType(...); [EOL] AbstractTypeResolver resolver = new AbstractTypeResolver() { [EOL] @Override [EOL] public JavaType findTypeMapping(DeserializationConfig config, JavaType type) { [EOL] return null; [EOL] } [EOL] }; [EOL] _factoryConfig.setAbstractTypeResolvers(Collections.singletonList(resolver)); [EOL] JavaType result = _mapAbstractType2(config, type); [EOL] assertNull(result); [EOL] }
public void testAddDeserializerConstructorsWithDefaultConstructor() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor defaultCtor = mock(AnnotatedConstructor.class); [EOL] when(beanDesc.findDefaultConstructor()).thenReturn(defaultCtor); [EOL] when(creators.hasDefaultCreator()).thenReturn(false); [EOL] when(intr.hasCreatorAnnotation(defaultCtor)).thenReturn(false); [EOL] _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators); [EOL] verify(creators).setDefaultCreator(defaultCtor); [EOL] }
public void testAddDeserializerConstructorsWithPropertyConstructor() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor propertyCtor = mock(AnnotatedConstructor.class); [EOL] BeanPropertyDefinition propDef = mock(BeanPropertyDefinition.class); [EOL] AnnotatedParameter param = mock(AnnotatedParameter.class); [EOL] when(beanDesc.findProperties()).thenReturn(Collections.singletonList(propDef)); [EOL] when(propDef.getConstructorParameter()).thenReturn(param); [EOL] when(param.getOwner()).thenReturn(propertyCtor); [EOL] when(propertyCtor.getParameterCount()).thenReturn(1); [EOL] when(param.getIndex()).thenReturn(0); [EOL] when(propDef.getName()).thenReturn("propertyName"); [EOL] _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators); [EOL] verify(creators, never()).setDefaultCreator(any(AnnotatedConstructor.class)); [EOL] }
public void testAddDeserializerConstructorsWithSingleArgumentConstructor() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor singleArgCtor = mock(AnnotatedConstructor.class); [EOL] when(beanDesc.getConstructors()).thenReturn(Collections.singletonList(singleArgCtor)); [EOL] when(singleArgCtor.getParameterCount()).thenReturn(1); [EOL] when(intr.hasCreatorAnnotation(singleArgCtor)).thenReturn(true); [EOL] when(vchecker.isCreatorVisible(singleArgCtor)).thenReturn(true); [EOL] _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators); [EOL] verify(creators, never()).setDefaultCreator(any(AnnotatedConstructor.class)); [EOL] }
public void testAddDeserializerConstructorsWithMultipleArgumentConstructor() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] VisibilityChecker<?> vchecker = mock(VisibilityChecker.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] CreatorCollector creators = mock(CreatorCollector.class); [EOL] AnnotatedConstructor multiArgCtor = mock(AnnotatedConstructor.class); [EOL] AnnotatedParameter param = mock(AnnotatedParameter.class); [EOL] when(beanDesc.getConstructors()).thenReturn(Collections.singletonList(multiArgCtor)); [EOL] when(multiArgCtor.getParameterCount()).thenReturn(2); [EOL] when(multiArgCtor.getParameter(0)).thenReturn(param); [EOL] when(multiArgCtor.getParameter(1)).thenReturn(param); [EOL] when(intr.hasCreatorAnnotation(multiArgCtor)).thenReturn(true); [EOL] when(vchecker.isCreatorVisible(multiArgCtor)).thenReturn(true); [EOL] when(intr.findNameForDeserialization(param)).thenReturn(new PropertyName("paramName")); [EOL] when(intr.findInjectableValueId(param)).thenReturn("injectId"); [EOL] _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators); [EOL] verify(creators).addPropertyCreator(eq(multiArgCtor), any(CreatorProperty[].class)); [EOL] }
public void testAddDeserializerFactoryMethodsWithNoArgFactory() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescriptionWithNoArgFactory(); [EOL] VisibilityChecker<?> vchecker = createVisibilityChecker(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospector(); [EOL] CreatorCollector creators = new CreatorCollector(); [EOL] _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators); [EOL] }
public void testAddDeserializerFactoryMethodsWithSingleArgFactory() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescriptionWithSingleArgFactory(); [EOL] VisibilityChecker<?> vchecker = createVisibilityChecker(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospector(); [EOL] CreatorCollector creators = new CreatorCollector(); [EOL] _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators); [EOL] }
public void testAddDeserializerFactoryMethodsWithMultiArgFactory() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescriptionWithMultiArgFactory(); [EOL] VisibilityChecker<?> vchecker = createVisibilityChecker(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospector(); [EOL] CreatorCollector creators = new CreatorCollector(); [EOL] _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators); [EOL] }
public void testAddDeserializerFactoryMethodsWithInvalidMultiArgFactory() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] BeanDescription beanDesc = createBeanDescriptionWithInvalidMultiArgFactory(); [EOL] VisibilityChecker<?> vchecker = createVisibilityChecker(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospector(); [EOL] CreatorCollector creators = new CreatorCollector(); [EOL] try { [EOL] _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } catch (JsonMappingException e) { [EOL] fail("Expected IllegalArgumentException, got JsonMappingException"); [EOL] } [EOL] }
public void testCreateArrayDeserializerWithCustomDeserializer() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] ArrayType type = mock(ArrayType.class); [EOL] JavaType elemType = mock(JavaType.class); [EOL] JsonDeserializer<Object> contentDeser = mock(JsonDeserializer.class); [EOL] TypeDeserializer elemTypeDeser = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> customDeser = mock(JsonDeserializer.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(type.getContentType()).thenReturn(elemType); [EOL] when(elemType.getValueHandler()).thenReturn(contentDeser); [EOL] when(elemType.getTypeHandler()).thenReturn(null); [EOL] when(elemType.getRawClass()).thenReturn(Object.class); [EOL] DeserializerFactory factory = new DeserializerFactory() { [EOL] @Override [EOL] public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, BeanDescription beanDesc) throws JsonMappingException { [EOL] return customDeser; [EOL] } [EOL] }; [EOL] JsonDeserializer<?> result = factory.createArrayDeserializer(ctxt, type, beanDesc); [EOL] assertSame("Expected custom array deserializer to be returned", customDeser, result); [EOL] }
public void testCreateArrayDeserializerWithPrimitiveType() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] ArrayType type = mock(ArrayType.class); [EOL] JavaType elemType = mock(JavaType.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(type.getContentType()).thenReturn(elemType); [EOL] when(elemType.getValueHandler()).thenReturn(null); [EOL] when(elemType.getTypeHandler()).thenReturn(null); [EOL] when(elemType.getRawClass()).thenReturn(int.class); [EOL] when(elemType.isPrimitive()).thenReturn(true); [EOL] DeserializerFactory factory = new DeserializerFactory() { [EOL] @Override [EOL] public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, BeanDescription beanDesc) throws JsonMappingException { [EOL] return super.createArrayDeserializer(ctxt, type, beanDesc); [EOL] } [EOL] }; [EOL] JsonDeserializer<?> result = factory.createArrayDeserializer(ctxt, type, beanDesc); [EOL] assertTrue("Expected a primitive array deserializer", result instanceof PrimitiveArrayDeserializers); [EOL] }
public void testCreateArrayDeserializerWithStringType() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] ArrayType type = mock(ArrayType.class); [EOL] JavaType elemType = mock(JavaType.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(type.getContentType()).thenReturn(elemType); [EOL] when(elemType.getValueHandler()).thenReturn(null); [EOL] when(elemType.getTypeHandler()).thenReturn(null); [EOL] when(elemType.getRawClass()).thenReturn(String.class); [EOL] DeserializerFactory factory = new DeserializerFactory() { [EOL] @Override [EOL] public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, BeanDescription beanDesc) throws JsonMappingException { [EOL] return super.createArrayDeserializer(ctxt, type, beanDesc); [EOL] } [EOL] }; [EOL] JsonDeserializer<?> result = factory.createArrayDeserializer(ctxt, type, beanDesc); [EOL] assertSame("Expected the string array deserializer", StringArrayDeserializer.instance, result); [EOL] }
public void testCreateArrayDeserializerWithModifiers() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] ArrayType type = mock(ArrayType.class); [EOL] JavaType elemType = mock(JavaType.class); [EOL] JsonDeserializer<Object> contentDeser = mock(JsonDeserializer.class); [EOL] TypeDeserializer elemTypeDeser = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> baseDeser = mock(JsonDeserializer.class); [EOL] BeanDeserializerModifier modifier = mock(BeanDeserializerModifier.class); [EOL] JsonDeserializer<?> modifiedDeser = mock(JsonDeserializer.class); [EOL] when(ctxt.getConfig()).thenReturn(config); [EOL] when(type.getContentType()).thenReturn(elemType); [EOL] when(elemType.getValueHandler()).thenReturn(contentDeser); [EOL] when(elemType.getTypeHandler()).thenReturn(elemTypeDeser); [EOL] when(config.deserializerModifiers()).thenReturn(Collections.singletonList(modifier)); [EOL] when(modifier.modifyArrayDeserializer(eq(config), eq(type), eq(beanDesc), any(JsonDeserializer.class))).thenReturn(modifiedDeser); [EOL] DeserializerFactory factory = new DeserializerFactory() { [EOL] @Override [EOL] public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, BeanDescription beanDesc) throws JsonMappingException { [EOL] return baseDeser; [EOL] } [EOL] @Override [EOL] protected boolean hasDeserializerModifiers() { [EOL] return true; [EOL] } [EOL] }; [EOL] JsonDeserializer<?> result = factory.createArrayDeserializer(ctxt, type, beanDesc); [EOL] assertSame("Expected modified deserializer to be returned", modifiedDeser, result); [EOL] }
public void testFindCustomArrayDeserializerWithNonNullDeserializer() { [EOL] ArrayType type = mock(ArrayType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] TypeDeserializer elementTypeDeserializer = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> elementDeserializer = mock(JsonDeserializer.class); [EOL] Deserializers deserializers = mock(Deserializers.class); [EOL] JsonDeserializer<?> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(_factoryConfig.deserializers()).thenReturn(Collections.singletonList(deserializers)); [EOL] when(deserializers.findArrayDeserializer(eq(type), eq(config), eq(beanDesc), eq(elementTypeDeserializer), eq(elementDeserializer))).thenReturn(expectedDeserializer); [EOL] JsonDeserializer<?> result = _findCustomArrayDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer); [EOL] assertNotNull(result); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testFindCustomArrayDeserializerWithNullDeserializer() { [EOL] ArrayType type = mock(ArrayType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] TypeDeserializer elementTypeDeserializer = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> elementDeserializer = mock(JsonDeserializer.class); [EOL] Deserializers deserializers = mock(Deserializers.class); [EOL] when(_factoryConfig.deserializers()).thenReturn(Collections.singletonList(deserializers)); [EOL] when(deserializers.findArrayDeserializer(eq(type), eq(config), eq(beanDesc), eq(elementTypeDeserializer), eq(elementDeserializer))).thenReturn(null); [EOL] JsonDeserializer<?> result = _findCustomArrayDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer); [EOL] assertNull(result); [EOL] }
public void testCreateCollectionDeserializerWithEnumSet() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] CollectionType type = createCollectionType(EnumSet.class, MyEnum.class); [EOL] BeanDescription beanDesc = createBeanDescription(type); [EOL] JsonDeserializer<?> deserializer = createCollectionDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof EnumSetDeserializer); [EOL] }
public void testCreateCollectionDeserializerWithArrayBlockingQueue() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] CollectionType type = createCollectionType(ArrayBlockingQueue.class, MyBean.class); [EOL] BeanDescription beanDesc = createBeanDescription(type); [EOL] JsonDeserializer<?> deserializer = createCollectionDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof ArrayBlockingQueueDeserializer); [EOL] }
public void testCreateCollectionDeserializerWithAbstractType() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] CollectionType type = createCollectionType(AbstractCollection.class, MyBean.class); [EOL] BeanDescription beanDesc = createBeanDescription(type); [EOL] try { [EOL] createCollectionDeserializer(ctxt, type, beanDesc); [EOL] fail("Expected IllegalArgumentException for abstract collection type"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCreateCollectionDeserializerWithStringCollection() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] CollectionType type = createCollectionType(List.class, String.class); [EOL] BeanDescription beanDesc = createBeanDescription(type); [EOL] JsonDeserializer<?> deserializer = createCollectionDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof StringCollectionDeserializer); [EOL] }
public void testCreateCollectionDeserializerWithCustomDeserializer() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] CollectionType type = createCollectionType(MyCustomCollection.class, MyBean.class); [EOL] BeanDescription beanDesc = createBeanDescription(type); [EOL] JsonDeserializer<?> deserializer = createCollectionDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof MyCustomCollectionDeserializer); [EOL] }
public void testCreateCollectionDeserializerWithModifiers() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] CollectionType type = createCollectionType(List.class, MyBean.class); [EOL] BeanDescription beanDesc = createBeanDescription(type); [EOL] addDeserializerModifier(); // Method to add a deserializer modifier to the _factoryConfig [EOL] JsonDeserializer<?> deserializer = createCollectionDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof ModifierCollectionDeserializer); [EOL] }
public void testFindCustomCollectionDeserializerWithNonNullDeserializer() { [EOL] CollectionType type = mock(CollectionType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] TypeDeserializer elementTypeDeserializer = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> elementDeserializer = mock(JsonDeserializer.class); [EOL] Deserializers deserializers = mock(Deserializers.class); [EOL] JsonDeserializer<?> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(deserializers.findCollectionDeserializer(eq(type), eq(config), eq(beanDesc), eq(elementTypeDeserializer), eq(elementDeserializer))).thenReturn(expectedDeserializer); [EOL] BasicDeserializerFactory factory = new BasicDeserializerFactory(_factoryConfig.withAdditionalDeserializers(deserializers)); [EOL] JsonDeserializer<?> result = factory._findCustomCollectionDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testFindCustomCollectionDeserializerWithNullDeserializer() { [EOL] CollectionType type = mock(CollectionType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] TypeDeserializer elementTypeDeserializer = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> elementDeserializer = mock(JsonDeserializer.class); [EOL] Deserializers deserializers = mock(Deserializers.class); [EOL] when(deserializers.findCollectionDeserializer(eq(type), eq(config), eq(beanDesc), eq(elementTypeDeserializer), eq(elementDeserializer))).thenReturn(null); [EOL] BasicDeserializerFactory factory = new BasicDeserializerFactory(_factoryConfig.withAdditionalDeserializers(deserializers)); [EOL] JsonDeserializer<?> result = factory._findCustomCollectionDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer); [EOL] assertNull(result); [EOL] }
public void testFindDefaultDeserializerWithPrimitiveType() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn(int.class); [EOL] JsonDeserializer<?> result = findDefaultDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof NumberDeserializers.IntDeserializer); [EOL] }
public void testFindDefaultDeserializerWithStringType() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn(String.class); [EOL] JsonDeserializer<?> result = findDefaultDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof StringDeserializer); [EOL] }
public void testFindDefaultDeserializerWithIterableType() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] TypeFactory tf = mock(TypeFactory.class); [EOL] when(ctxt.getTypeFactory()).thenReturn(tf); [EOL] when(type.getRawClass()).thenReturn(Iterable.class); [EOL] when(type.containedTypeCount()).thenReturn(1); [EOL] when(type.containedType(0)).thenReturn(TypeFactory.unknownType()); [EOL] when(tf.constructCollectionType(Collection.class, TypeFactory.unknownType())).thenReturn(mock(CollectionType.class)); [EOL] JsonDeserializer<?> result = findDefaultDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testFindDefaultDeserializerWithUnknownType() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] when(type.getRawClass()).thenReturn(Object.class); [EOL] when(type.getRawClass().getName()).thenReturn("com.unknown.Type"); [EOL] JsonDeserializer<?> result = findDefaultDeserializer(ctxt, type, beanDesc); [EOL] assertNull(result); [EOL] }
public void testFindDefaultDeserializerWithJacksonType() { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JavaType type = mock(JavaType.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] Class<?> rawType = com.fasterxml.jackson.databind.JsonNode.class; [EOL] when(type.getRawClass()).thenReturn(rawType); [EOL] when(type.getRawClass().getName()).thenReturn("com.fasterxml.jackson.databind.JsonNode"); [EOL] JsonDeserializer<?> result = findDefaultDeserializer(ctxt, type, beanDesc); [EOL] assertNotNull(result); [EOL] }
public void testModifyTypeByAnnotationWithSubclass() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] JavaType type = createJavaType(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithDeserializationType(type.getRawClass()); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] JavaType result = modifyTypeByAnnotation(ctxt, a, type); [EOL] assertNotNull(result); [EOL] assertNotSame(type, result); [EOL] }
public void testModifyTypeByAnnotationWithInvalidSubclass() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] JavaType type = createJavaType(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithInvalidDeserializationType(); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] try { [EOL] modifyTypeByAnnotation(ctxt, a, type); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testModifyTypeByAnnotationWithKeyClassForMapLikeType() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] MapLikeType type = createMapLikeType(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithKeyDeserializationType(type.getKeyType().getRawClass()); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] JavaType result = modifyTypeByAnnotation(ctxt, a, type); [EOL] assertNotNull(result); [EOL] assertTrue(result.isContainerType()); [EOL] assertNotSame(type, result); [EOL] }
public void testModifyTypeByAnnotationWithInvalidKeyClassForNonMapLikeType() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] JavaType type = createNonMapLikeType(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithKeyDeserializationType(Object.class); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] try { [EOL] modifyTypeByAnnotation(ctxt, a, type); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testModifyTypeByAnnotationWithContentType() throws JsonMappingException { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] JavaType type = createContainerType(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithContentDeserializationType(type.getContentType().getRawClass()); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] JavaType result = modifyTypeByAnnotation(ctxt, a, type); [EOL] assertNotNull(result); [EOL] assertTrue(result.isContainerType()); [EOL] assertNotSame(type, result); [EOL] }
public void testModifyTypeByAnnotationWithInvalidContentType() { [EOL] DeserializationContext ctxt = createDeserializationContext(); [EOL] Annotated a = createAnnotated(); [EOL] JavaType type = createContainerType(); [EOL] AnnotationIntrospector intr = createAnnotationIntrospectorWithInvalidContentDeserializationType(); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] try { [EOL] modifyTypeByAnnotation(ctxt, a, type); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException { [EOL] if (type.isContainerType()) { [EOL] AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL] JavaType keyType = type.getKeyType(); [EOL] if (keyType != null) { [EOL] Object kdDef = intr.findKeyDeserializer(member); [EOL] KeyDeserializer kd = ctxt.keyDeserializerInstance(member, kdDef); [EOL] if (kd != null) { [EOL] type = ((MapLikeType) type).withKeyValueHandler(kd); [EOL] keyType = type.getKeyType(); [EOL] } [EOL] } [EOL] Object cdDef = intr.findContentDeserializer(member); [EOL] JsonDeserializer<?> cd = ctxt.deserializerInstance(member, cdDef); [EOL] if (cd != null) { [EOL] type = type.withContentValueHandler(cd); [EOL] } [EOL] if (member instanceof AnnotatedMember) { [EOL] TypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(ctxt.getConfig(), type, (AnnotatedMember) member); [EOL] if (contentTypeDeser != null) { [EOL] type = type.withContentTypeHandler(contentTypeDeser); [EOL] } [EOL] } [EOL] } [EOL] TypeDeserializer valueTypeDeser; [EOL] if (member instanceof AnnotatedMember) { [EOL] valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(), type, (AnnotatedMember) member); [EOL] } else { [EOL] valueTypeDeser = findTypeDeserializer(ctxt.getConfig(), type); [EOL] } [EOL] if (valueTypeDeser != null) { [EOL] type = type.withTypeHandler(valueTypeDeser); [EOL] } [EOL] return type; [EOL] }
public void testGenerateJsonSchemaWithNullClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.generateJsonSchema(null); [EOL] fail("Expected IllegalArgumentException for null class"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("A class must be provided", e.getMessage()); [EOL] } catch (JsonMappingException e) { [EOL] fail("Expected IllegalArgumentException, not JsonMappingException"); [EOL] } [EOL] }
public void testGenerateJsonSchemaWithNonJsonClass() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] try { [EOL] mapper.generateJsonSchema(NonJsonClass.class); [EOL] fail("Expected IllegalArgumentException for non-JSON class"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("would not be serialized as a JSON object and therefore has no schema")); [EOL] } catch (JsonMappingException e) { [EOL] fail("Expected IllegalArgumentException, not JsonMappingException"); [EOL] } [EOL] }
public void testGenerateJsonSchemaWithValidClass() throws JsonMappingException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] com.fasterxml.jackson.databind.jsonschema.JsonSchema schema = mapper.generateJsonSchema(ValidJsonClass.class); [EOL] assertNotNull(schema); [EOL] assertTrue(schema.isObjectSchema()); [EOL] }
public void testHasSerializerForWithExistingSerializer() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] boolean result = mapper.hasSerializerFor(String.class); [EOL] assertTrue(result); [EOL] }
public void testHasSerializerForWithNoSerializer() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] boolean result = mapper.hasSerializerFor(Object.class); [EOL] assertFalse(result); [EOL] }
public void testHasSerializerForWithException() { [EOL] ObjectMapper mapper = new ObjectMapper() { [EOL] @Override [EOL] public JsonSerializer<Object> _findExplicitUntypedSerializer(Class<?> cls) throws JsonMappingException { [EOL] throw new JsonMappingException(null, "Exception for test"); [EOL] } [EOL] }; [EOL] boolean result = mapper.hasSerializerFor(Object.class); [EOL] assertFalse(result); [EOL] }
public void testCachedSerializersCount() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] int initialCount = mapper.getSerializerProviderInstance().cachedSerializersCount(); [EOL] String json = mapper.writeValueAsString(new SimpleBean()); [EOL] int countAfterSerialization = mapper.getSerializerProviderInstance().cachedSerializersCount(); [EOL] assertTrue(countAfterSerialization >= initialCount); [EOL] }
public void testFlushCachedSerializers() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonSerializer<Object> serializer = mapper.getSerializerProviderInstance().findValueSerializer(String.class, null); [EOL] assertNotNull(serializer); [EOL] mapper.flushCachedSerializers(); [EOL] assertEquals(0, mapper.getSerializerProviderInstance().cachedSerializerCount()); [EOL] }
public void testSerializerInstanceWithNullSerDef() { [EOL] JsonSerializer<Object> result = serializerInstance(mock(Annotated.class), null); [EOL] assertNull(result); [EOL] }
public void testSerializerInstanceWithJsonSerializerInstance() { [EOL] JsonSerializer<Object> expectedSerializer = mock(JsonSerializer.class); [EOL] JsonSerializer<Object> result = serializerInstance(mock(Annotated.class), expectedSerializer); [EOL] assertSame(expectedSerializer, result); [EOL] }
public void testSerializerInstanceWithInvalidType() { [EOL] Object serDef = new Object(); [EOL] try { [EOL] serializerInstance(mock(Annotated.class), serDef); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("AnnotationIntrospector returned serializer definition of type " + serDef.getClass().getName() + "; expected type JsonSerializer or Class<JsonSerializer> instead", e.getMessage()); [EOL] } [EOL] }
public void testSerializerInstanceWithJsonSerializerNoneClass() { [EOL] JsonSerializer<Object> result = serializerInstance(mock(Annotated.class), JsonSerializer.None.class); [EOL] assertNull(result); [EOL] }
public void testSerializerInstanceWithNoClass() { [EOL] JsonSerializer<Object> result = serializerInstance(mock(Annotated.class), NoClass.class); [EOL] assertNull(result); [EOL] }
public void testSerializerInstanceWithNonAssignableClass() { [EOL] Class<?> serDef = String.class; [EOL] try { [EOL] serializerInstance(mock(Annotated.class), serDef); [EOL] fail("Expected IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("AnnotationIntrospector returned Class " + serDef.getName() + "; expected Class<JsonSerializer>", e.getMessage()); [EOL] } [EOL] }
public void testSerializerInstanceWithAssignableClassAndNoHandlerInstantiator() { [EOL] Class<?> serDef = SomeJsonSerializerSubclass.class; [EOL] JsonSerializer<Object> result = serializerInstance(mock(Annotated.class), serDef); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof SomeJsonSerializerSubclass); [EOL] }
public void testSerializerInstanceWithAssignableClassAndHandlerInstantiator() { [EOL] Class<?> serDef = SomeJsonSerializerSubclass.class; [EOL] HandlerInstantiator hi = mock(HandlerInstantiator.class); [EOL] when(_config.getHandlerInstantiator()).thenReturn(hi); [EOL] when(hi.serializerInstance(any(SerializationConfig.class), any(Annotated.class), eq(serDef))).thenReturn(mock(JsonSerializer.class)); [EOL] JsonSerializer<Object> result = serializerInstance(mock(Annotated.class), serDef); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof JsonSerializer); [EOL] }
protected BeanDeserializer(BeanDeserializerBase src, NameTransformer unwrapper) { [EOL] super(src, unwrapper); [EOL] }
public void testBeanDeserializerWithNullObjectIdReader() { [EOL] BeanDeserializerBase src = mock(BeanDeserializerBase.class); [EOL] BeanDeserializer deserializer = new BeanDeserializer(src, null); [EOL] assertNull(deserializer.getObjectIdReader()); [EOL] }
public void testBeanDeserializerWithNonNullObjectIdReader() { [EOL] BeanDeserializerBase src = mock(BeanDeserializerBase.class); [EOL] ObjectIdReader oir = mock(ObjectIdReader.class); [EOL] BeanDeserializer deserializer = new BeanDeserializer(src, oir); [EOL] assertNotNull(deserializer.getObjectIdReader()); [EOL] assertEquals(oir, deserializer.getObjectIdReader()); [EOL] }
public void testBeanDeserializerWithNullIgnorableProps() { [EOL] BeanDeserializerBase src = mock(BeanDeserializerBase.class); [EOL] HashSet<String> ignorableProps = null; [EOL] BeanDeserializer deserializer = new BeanDeserializer(src, ignorableProps); [EOL] assertNotNull(deserializer); [EOL] }
public void testBeanDeserializerWithEmptyIgnorableProps() { [EOL] BeanDeserializerBase src = mock(BeanDeserializerBase.class); [EOL] HashSet<String> ignorableProps = new HashSet<>(); [EOL] BeanDeserializer deserializer = new BeanDeserializer(src, ignorableProps); [EOL] assertNotNull(deserializer); [EOL] }
public void testBeanDeserializerWithNonEmptyIgnorableProps() { [EOL] BeanDeserializerBase src = mock(BeanDeserializerBase.class); [EOL] HashSet<String> ignorableProps = new HashSet<>(); [EOL] ignorableProps.add("propertyToIgnore"); [EOL] BeanDeserializer deserializer = new BeanDeserializer(src, ignorableProps); [EOL] assertNotNull(deserializer); [EOL] }
public void testUnwrappingDeserializerWithNonBeanDeserializer() { [EOL] NonBeanDeserializer nonBeanDeserializer = new NonBeanDeserializer(); [EOL] NameTransformer unwrapper = mock(NameTransformer.class); [EOL] JsonDeserializer<Object> result = nonBeanDeserializer.unwrappingDeserializer(unwrapper); [EOL] assertSame(nonBeanDeserializer, result); [EOL] }
public void testUnwrappingDeserializerWithBeanDeserializer() { [EOL] BeanDeserializer beanDeserializer = new BeanDeserializer(); [EOL] NameTransformer unwrapper = mock(NameTransformer.class); [EOL] JsonDeserializer<Object> result = beanDeserializer.unwrappingDeserializer(unwrapper); [EOL] assertTrue(result instanceof BeanDeserializer); [EOL] assertNotSame(beanDeserializer, result); [EOL] }
public void testWithObjectIdReaderNonNull() { [EOL] ObjectIdReader objectIdReader = new ObjectIdReader(null, null, null, null, null); [EOL] BeanDeserializer originalDeserializer = new BeanDeserializer(null, null); [EOL] BeanDeserializer deserializerWithObjectId = originalDeserializer.withObjectIdReader(objectIdReader); [EOL] assertNotNull(deserializerWithObjectId); [EOL] assertNotSame(originalDeserializer, deserializerWithObjectId); [EOL] }
public void testWithObjectIdReaderNull() { [EOL] BeanDeserializer originalDeserializer = new BeanDeserializer(null, null); [EOL] BeanDeserializer deserializerWithObjectId = originalDeserializer.withObjectIdReader(null); [EOL] assertNotNull(deserializerWithObjectId); [EOL] assertNotSame(originalDeserializer, deserializerWithObjectId); [EOL] }
public void testWithIgnorableProperties_Null() { [EOL] BeanDeserializer original = new BeanDeserializer(); // Assuming default constructor exists [EOL] BeanDeserializer result = original.withIgnorableProperties(null); [EOL] assertNotNull(result); [EOL] assertNotSame(original, result); [EOL] assertNull(result.getIgnorableProperties()); // Assuming getIgnorableProperties method exists [EOL] }
public void testWithIgnorableProperties_NonEmptySet() { [EOL] BeanDeserializer original = new BeanDeserializer(); // Assuming default constructor exists [EOL] HashSet<String> ignorableProps = new HashSet<>(); [EOL] ignorableProps.add("prop1"); [EOL] ignorableProps.add("prop2"); [EOL] BeanDeserializer result = original.withIgnorableProperties(ignorableProps); [EOL] assertNotNull(result); [EOL] assertNotSame(original, result); [EOL] assertEquals(ignorableProps, result.getIgnorableProperties()); // Assuming getIgnorableProperties method exists [EOL] }
public void testDeserializeWithStartObjectAndVanillaProcessing() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(_vanillaProcessing).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); // Assuming vanillaDeserialize handles END_OBJECT [EOL] Object result = deserialize(jp, ctxt); [EOL] verify(jp).nextToken(); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithStartObjectAndObjectIdReader() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(_vanillaProcessing).thenReturn(false); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); // Assuming deserializeWithObjectId handles END_OBJECT [EOL] when(_objectIdReader).thenReturn(mock(ObjectIdReader.class)); [EOL] Object result = deserialize(jp, ctxt); [EOL] verify(jp).nextToken(); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithStartObjectWithoutSpecialHandling() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(_vanillaProcessing).thenReturn(false); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_OBJECT); // Assuming deserializeFromObject handles END_OBJECT [EOL] when(_objectIdReader).thenReturn(null); [EOL] Object result = deserialize(jp, ctxt); [EOL] verify(jp).nextToken(); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeOther() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); // Any token that is not START_OBJECT [EOL] Object result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeOtherWithNullToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(null); [EOL] Object result = _deserializeOther(jp, ctxt, null); [EOL] } [EOL] public void testDeserializeOtherWithValueString() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.VALUE_STRING); [EOL] }
public void testDeserializeOtherWithValueNumberInt() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.VALUE_NUMBER_INT); [EOL] }
public void testDeserializeOtherWithValueNumberFloat() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.VALUE_NUMBER_FLOAT); [EOL] }
public void testDeserializeOtherWithValueEmbeddedObject() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] Object embeddedObject = new Object(); [EOL] when(jp.getEmbeddedObject()).thenReturn(embeddedObject); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] assertSame(embeddedObject, result); [EOL] }
public void testDeserializeOtherWithValueTrue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.VALUE_TRUE); [EOL] }
public void testDeserializeOtherWithValueFalse() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.VALUE_FALSE); [EOL] }
public void testDeserializeOtherWithStartArray() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.START_ARRAY); [EOL] }
public void testDeserializeOtherWithFieldNameAndVanillaProcessing() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] _vanillaProcessing = true; [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.FIELD_NAME); [EOL] }
public void testDeserializeOtherWithEndObjectAndObjectIdReaderNotNull() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_OBJECT); [EOL] _objectIdReader = mock(ObjectIdReader.class); [EOL] Object result = _deserializeOther(jp, ctxt, JsonToken.END_OBJECT); [EOL] }
public void testDeserializeOtherWithDefaultCase() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] try { [EOL] _deserializeOther(jp, ctxt, JsonToken.NOT_AVAILABLE); [EOL] fail("Expected mappingException to be thrown"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testDeserializeFromObjectWithNonStandardCreationAndUnwrapped() throws IOException, JsonProcessingException { [EOL] setupNonStandardCreationWithUnwrapped(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] verifyDeserializeWithUnwrapped(result); [EOL] }
public void testDeserializeFromObjectWithNonStandardCreationAndExternalTypeId() throws IOException, JsonProcessingException { [EOL] setupNonStandardCreationWithExternalTypeId(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] verifyDeserializeWithExternalTypeId(result); [EOL] }
public void testDeserializeFromObjectWithNonStandardCreationUsingNonDefault() throws IOException, JsonProcessingException { [EOL] setupNonStandardCreationUsingNonDefault(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] verifyDeserializeFromObjectUsingNonDefault(result); [EOL] }
public void testDeserializeFromObjectWithStandardCreationAndInjectables() throws IOException, JsonProcessingException { [EOL] setupStandardCreationWithInjectables(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] verifyInjectValues(result); [EOL] }
public void testDeserializeFromObjectWithStandardCreationAndViewProcessing() throws IOException, JsonProcessingException { [EOL] setupStandardCreationWithViewProcessing(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.getActiveView()).thenReturn(SomeViewClass.class); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] verifyDeserializeWithView(result); [EOL] }
public void testDeserializeFromObjectWithStandardCreationAndUnknownProperty() throws IOException, JsonProcessingException { [EOL] setupStandardCreationWithUnknownProperty(); [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT, JsonToken.FIELD_NAME, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("unknownProperty"); [EOL] Object result = deserializeFromObject(jp, ctxt); [EOL] verifyHandleUnknownProperty(result); [EOL] }
protected Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL] final PropertyBasedCreator creator = _propertyBasedCreator; [EOL] PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader); [EOL] TokenBuffer unknown = null; [EOL] JsonToken t = jp.getCurrentToken(); [EOL] for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL] String propName = jp.getCurrentName(); [EOL] jp.nextToken(); [EOL] SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); [EOL] if (creatorProp != null) { [EOL] Object value = creatorProp.deserialize(jp, ctxt); [EOL] if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) { [EOL] jp.nextToken(); [EOL] Object bean; [EOL] try { [EOL] bean = creator.build(ctxt, buffer); [EOL] } catch (Exception e) { [EOL] wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); [EOL] bean = null; [EOL] } [EOL] if (bean.getClass() != _beanType.getRawClass()) { [EOL] return handlePolymorphic(jp, ctxt, bean, unknown); [EOL] } [EOL] if (unknown != null) { [EOL] bean = handleUnknownProperties(ctxt, bean, unknown); [EOL] } [EOL] return deserialize(jp, ctxt, bean); [EOL] } [EOL] continue; [EOL] } [EOL] if (buffer.readIdProperty(propName)) { [EOL] continue; [EOL] } [EOL] SettableBeanProperty prop = _beanProperties.find(propName); [EOL] if (prop != null) { [EOL] buffer.bufferProperty(prop, prop.deserialize(jp, ctxt)); [EOL] continue; [EOL] } [EOL] if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL] jp.skipChildren(); [EOL] continue; [EOL] } [EOL] if (_anySetter != null) { [EOL] buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt)); [EOL] continue; [EOL] } [EOL] if (unknown == null) { [EOL] unknown = new TokenBuffer(jp.getCodec()); [EOL] } [EOL] unknown.writeFieldName(propName); [EOL] unknown.copyCurrentStructure(jp); [EOL] } [EOL] Object bean; [EOL] try { [EOL] bean = creator.build(ctxt, buffer); [EOL] } catch (Exception e) { [EOL] wrapInstantiationProblem(e, ctxt); [EOL] bean = null; [EOL] } [EOL] if (unknown != null) { [EOL] if (bean.getClass() != _beanType.getRawClass()) { [EOL] return handlePolymorphic(null, ctxt, bean, unknown); [EOL] } [EOL] return handleUnknownProperties(ctxt, bean, unknown); [EOL] } [EOL] return bean; [EOL] }
public void testDeserializeWithUnwrappedDelegateDeserializerNotNull() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] JsonDeserializer<Object> delegateDeserializer = mock(JsonDeserializer.class); [EOL] Object delegateResult = new Object(); [EOL] when(_delegateDeserializer).thenReturn(delegateDeserializer); [EOL] when(delegateDeserializer.deserialize(jp, ctxt)).thenReturn(delegateResult); [EOL] when(valueInstantiator.createUsingDelegate(ctxt, delegateResult)).thenReturn(delegateResult); [EOL] Object result = deserializeWithUnwrapped(jp, ctxt); [EOL] verify(delegateDeserializer).deserialize(jp, ctxt); [EOL] verify(valueInstantiator).createUsingDelegate(ctxt, delegateResult); [EOL] assertEquals(delegateResult, result); [EOL] }
public void testDeserializeWithUnwrappedPropertyBasedCreatorNotNull() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(_propertyBasedCreator).thenReturn(mock(PropertyBasedCreator.class)); [EOL] Object result = deserializeWithUnwrapped(jp, ctxt); [EOL] verify(_propertyBasedCreator).deserializeUsingPropertyBasedWithUnwrapped(jp, ctxt); [EOL] }
public void testDeserializeWithUnwrappedUsingDefault() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] Object bean = new Object(); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(_propertyBasedCreator).thenReturn(null); [EOL] when(valueInstantiator.createUsingDefault(ctxt)).thenReturn(bean); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_OBJECT); [EOL] Object result = deserializeWithUnwrapped(jp, ctxt); [EOL] verify(valueInstantiator).createUsingDefault(ctxt); [EOL] assertEquals(bean, result); [EOL] }
public void testDeserializeWithUnwrappedInjectablesNotNull() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] Object bean = new Object(); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(_propertyBasedCreator).thenReturn(null); [EOL] when(_injectables).thenReturn(new InjectableValues.Std()); [EOL] when(valueInstantiator.createUsingDefault(ctxt)).thenReturn(bean); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_OBJECT); [EOL] Object result = deserializeWithUnwrapped(jp, ctxt); [EOL] verify(_injectables).injectValues(ctxt, bean); [EOL] assertEquals(bean, result); [EOL] }
public void testDeserializeWithUnwrappedActiveViewProcessing() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] Object bean = new Object(); [EOL] Class<?> activeView = Object.class; [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(_propertyBasedCreator).thenReturn(null); [EOL] when(_needViewProcesing).thenReturn(true); [EOL] when(ctxt.getActiveView()).thenReturn(activeView); [EOL] when(valueInstantiator.createUsingDefault(ctxt)).thenReturn(bean); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("propName"); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] when(_beanProperties.find("propName")).thenReturn(prop); [EOL] when(prop.visibleInView(activeView)).thenReturn(true); [EOL] Object result = deserializeWithUnwrapped(jp, ctxt); [EOL] verify(prop).deserializeAndSet(jp, ctxt, bean); [EOL] assertEquals(bean, result); [EOL] }
public void testDeserializeWithUnwrappedIgnorableProps() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] Object bean = new Object(); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(_propertyBasedCreator).thenReturn(null); [EOL] when(_ignorableProps).thenReturn(Collections.singleton("propName")); [EOL] when(valueInstantiator.createUsingDefault(ctxt)).thenReturn(bean); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("propName"); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] Object result = deserializeWithUnwrapped(jp, ctxt); [EOL] verify(jp).skipChildren(); [EOL] assertEquals(bean, result); [EOL] }
public void testDeserializeWithUnwrappedAnySetterNotNull() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] Object bean = new Object(); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(_propertyBasedCreator).thenReturn(null); [EOL] when(_anySetter).thenReturn(mock(SettableAnyProperty.class)); [EOL] when(valueInstantiator.createUsingDefault(ctxt)).thenReturn(bean); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("propName"); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] Object result = deserializeWithUnwrapped(jp, ctxt); [EOL] verify(_anySetter).deserializeAndSet(jp, ctxt, bean, "propName"); [EOL] assertEquals(bean, result); [EOL] }
public void testDeserializeWithUnwrappedUnwrappedPropertyHandlerNotNull() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] Object bean = new Object(); [EOL] TokenBuffer tokens = new TokenBuffer(jp.getCodec(), false); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(_propertyBasedCreator).thenReturn(null); [EOL] when(_unwrappedPropertyHandler).thenReturn(mock(UnwrappedPropertyHandler.class)); [EOL] when(valueInstantiator.createUsingDefault(ctxt)).thenReturn(bean); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_OBJECT); [EOL] when(jp.getCodec()).thenReturn(mock(ObjectCodec.class)); [EOL] Object result = deserializeWithUnwrapped(jp, ctxt); [EOL] verify(_unwrappedPropertyHandler).processUnwrapped(jp, ctxt, bean, tokens); [EOL] assertEquals(bean, result); [EOL] }
public void testDeserializeWithExternalTypeId_PropertyBasedCreatorNotNull() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ExternalTypeHandler extTypeHandler = mock(ExternalTypeHandler.class); [EOL] PropertyBasedCreator propertyBasedCreator = mock(PropertyBasedCreator.class); [EOL] MyBeanDeserializer deserializer = new MyBeanDeserializer(); [EOL] deserializer._propertyBasedCreator = propertyBasedCreator; [EOL] when(propertyBasedCreator.deserializeFromObjectUsingNonDefault(jp, ctxt)).thenReturn(new Object()); [EOL] Object result = deserializer.deserializeWithExternalTypeId(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(propertyBasedCreator).deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL] }
public void testDeserializeWithExternalTypeId_PropertyBasedCreatorNull() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] MyBeanDeserializer deserializer = new MyBeanDeserializer(); [EOL] deserializer._propertyBasedCreator = null; [EOL] deserializer._valueInstantiator = valueInstantiator; [EOL] when(valueInstantiator.createUsingDefault(ctxt)).thenReturn(new Object()); [EOL] Object result = deserializer.deserializeWithExternalTypeId(jp, ctxt); [EOL] assertNotNull(result); [EOL] verify(valueInstantiator).createUsingDefault(ctxt); [EOL] }
protected Object deserializeWithExternalTypeId(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL] final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null; [EOL] final ExternalTypeHandler ext = _externalTypeIdHandler.start(); [EOL] for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL] String propName = jp.getCurrentName(); [EOL] jp.nextToken(); [EOL] SettableBeanProperty prop = _beanProperties.find(propName); [EOL] if (prop != null) { [EOL] if (jp.getCurrentToken().isScalarValue()) { [EOL] ext.handleTypePropertyValue(jp, ctxt, propName, bean); [EOL] } [EOL] if (activeView != null && !prop.visibleInView(activeView)) { [EOL] jp.skipChildren(); [EOL] continue; [EOL] } [EOL] try { [EOL] prop.deserializeAndSet(jp, ctxt, bean); [EOL] } catch (Exception e) { [EOL] wrapAndThrow(e, bean, propName, ctxt); [EOL] } [EOL] continue; [EOL] } [EOL] if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL] jp.skipChildren(); [EOL] continue; [EOL] } [EOL] if (ext.handlePropertyValue(jp, ctxt, propName, bean)) { [EOL] continue; [EOL] } [EOL] if (_anySetter != null) { [EOL] try { [EOL] _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL] } catch (Exception e) { [EOL] wrapAndThrow(e, bean, propName, ctxt); [EOL] } [EOL] continue; [EOL] } [EOL] handleUnknownProperty(jp, ctxt, bean, propName); [EOL] } [EOL] return ext.complete(jp, ctxt, bean); [EOL] }
public void testEnumSerializerWithNullSerializeAsIndex() { [EOL] EnumValues values = EnumValues.construct(null, null); [EOL] EnumSerializer serializer = new EnumSerializer(values, null); [EOL] assertNull(serializer._serializeAsIndex); [EOL] }
public void testEnumSerializerWithTrueSerializeAsIndex() { [EOL] EnumValues values = EnumValues.construct(null, null); [EOL] EnumSerializer serializer = new EnumSerializer(values, Boolean.TRUE); [EOL] assertTrue(serializer._serializeAsIndex); [EOL] }
public void testEnumSerializerWithFalseSerializeAsIndex() { [EOL] EnumValues values = EnumValues.construct(null, null); [EOL] EnumSerializer serializer = new EnumSerializer(values, Boolean.FALSE); [EOL] assertFalse(serializer._serializeAsIndex); [EOL] }
public void testConstructWithWriteEnumsUsingToStringEnabled() { [EOL] SerializationConfig config = new SerializationConfig(...); // provide necessary initialization [EOL] config = config.with(SerializationFeature.WRITE_ENUMS_USING_TO_STRING); [EOL] Class<Enum<?>> enumClass = MyEnum.class; // replace with an actual enum class [EOL] BeanDescription beanDesc = ...; // provide necessary initialization [EOL] JsonFormat.Value format = JsonFormat.Value.forShape(JsonFormat.Shape.STRING); [EOL] EnumSerializer serializer = EnumSerializer.construct(enumClass, config, beanDesc, format); [EOL] assertNotNull(serializer); [EOL] assertTrue(serializer.isUsingToString()); [EOL] }
public void testConstructWithWriteEnumsUsingToStringDisabled() { [EOL] SerializationConfig config = new SerializationConfig(...); // provide necessary initialization [EOL] config = config.without(SerializationFeature.WRITE_ENUMS_USING_TO_STRING); [EOL] Class<Enum<?>> enumClass = MyEnum.class; // replace with an actual enum class [EOL] BeanDescription beanDesc = ...; // provide necessary initialization [EOL] JsonFormat.Value format = JsonFormat.Value.forShape(JsonFormat.Shape.NUMBER_INT); [EOL] EnumSerializer serializer = EnumSerializer.construct(enumClass, config, beanDesc, format); [EOL] assertNotNull(serializer); [EOL] assertFalse(serializer.isUsingToString()); [EOL] }
public void testConstructWithSerializeAsIndexTrue() { [EOL] SerializationConfig config = new SerializationConfig(...); // provide necessary initialization [EOL] Class<Enum<?>> enumClass = MyEnum.class; // replace with an actual enum class [EOL] BeanDescription beanDesc = ...; // provide necessary initialization [EOL] JsonFormat.Value format = JsonFormat.Value.forShape(JsonFormat.Shape.NUMBER_INT); [EOL] EnumSerializer serializer = EnumSerializer.construct(enumClass, config, beanDesc, format); [EOL] assertNotNull(serializer); [EOL] assertEquals(Boolean.TRUE, serializer.getSerializeAsIndex()); [EOL] }
public void testConstructWithSerializeAsIndexFalse() { [EOL] SerializationConfig config = new SerializationConfig(...); // provide necessary initialization [EOL] Class<Enum<?>> enumClass = MyEnum.class; // replace with an actual enum class [EOL] BeanDescription beanDesc = ...; // provide necessary initialization [EOL] JsonFormat.Value format = JsonFormat.Value.forShape(JsonFormat.Shape.STRING); [EOL] EnumSerializer serializer = EnumSerializer.construct(enumClass, config, beanDesc, format); [EOL] assertNotNull(serializer); [EOL] assertEquals(Boolean.FALSE, serializer.getSerializeAsIndex()); [EOL] }
public void testSerializeAsIndexTrue() throws IOException { [EOL] Enum<?> en = TestEnum.VALUE1; // Assuming TestEnum is an existing enum with some values [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX)).thenReturn(true); [EOL] new EnumSerializer(null, true).serialize(en, jgen, provider); [EOL] verify(jgen).writeNumber(en.ordinal()); [EOL] }
public void testSerializeAsIndexFalse() throws IOException { [EOL] Enum<?> en = TestEnum.VALUE2; // Assuming TestEnum is an existing enum with some values [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] EnumValues values = mock(EnumValues.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX)).thenReturn(false); [EOL] when(values.serializedValueFor(en)).thenReturn("VALUE2"); [EOL] new EnumSerializer(values, false).serialize(en, jgen, provider); [EOL] verify(jgen).writeString("VALUE2"); [EOL] }
public void testIsShapeWrittenUsingIndexWithNullFormat() { [EOL] Boolean result = _isShapeWrittenUsingIndex(EnumClass.class, null, true); [EOL] assertNull(result); [EOL] }
public void testIsShapeWrittenUsingIndexWithShapeAny() { [EOL] JsonFormat.Value format = new JsonFormat.Value().withShape(JsonFormat.Shape.ANY); [EOL] Boolean result = _isShapeWrittenUsingIndex(EnumClass.class, format, true); [EOL] assertNull(result); [EOL] }
public void testIsShapeWrittenUsingIndexWithShapeScalar() { [EOL] JsonFormat.Value format = new JsonFormat.Value().withShape(JsonFormat.Shape.SCALAR); [EOL] Boolean result = _isShapeWrittenUsingIndex(EnumClass.class, format, true); [EOL] assertNull(result); [EOL] }
public void testIsShapeWrittenUsingIndexWithShapeString() { [EOL] JsonFormat.Value format = new JsonFormat.Value().withShape(JsonFormat.Shape.STRING); [EOL] Boolean result = _isShapeWrittenUsingIndex(EnumClass.class, format, true); [EOL] assertEquals(Boolean.FALSE, result); [EOL] }
public void testIsShapeWrittenUsingIndexWithNumericShape() { [EOL] JsonFormat.Value format = new JsonFormat.Value().withShape(JsonFormat.Shape.NUMBER); [EOL] Boolean result = _isShapeWrittenUsingIndex(EnumClass.class, format, true); [EOL] assertEquals(Boolean.TRUE, result); [EOL] }
public void testIsShapeWrittenUsingIndexWithUnsupportedShape() { [EOL] JsonFormat.Value format = new JsonFormat.Value().withShape(JsonFormat.Shape.ARRAY); [EOL] try { [EOL] _isShapeWrittenUsingIndex(EnumClass.class, format, true); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSizeWhenEmpty() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] int size = mapper.getDeserializationConfig().size(); [EOL] assert size == 0; [EOL] }
public void testSizeAfterAddingElements() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.getDeserializationConfig().addMixIn(Object.class, Object.class); [EOL] int size = mapper.getDeserializationConfig().size(); [EOL] assert size > 0; [EOL] }
public void testFlushClearsSharedMap() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonNodeFactory nodeFactory = mapper.getNodeFactory(); [EOL] JsonNode node = nodeFactory.objectNode(); [EOL] mapper.setNodeFactory(nodeFactory); [EOL] mapper.flush(); [EOL] assertTrue(mapper.getSharedMap().isEmpty()); [EOL] }
public void testMemberKeyWithConstructor() { [EOL] Constructor<?> constructor = String.class.getConstructor(new Class<?>[0]); [EOL] MemberKey memberKey = new MemberKey(constructor); [EOL] assertNotNull(memberKey); [EOL] }
public void testEquals_Reflexive() { [EOL] MemberKey key = new MemberKey("method", new Class<?>[]{String.class, Integer.class}); [EOL] assertTrue(key.equals(key)); [EOL] }
public void testEquals_Null() { [EOL] MemberKey key = new MemberKey("method", new Class<?>[]{String.class, Integer.class}); [EOL] assertFalse(key.equals(null)); [EOL] }
public void testEquals_DifferentClass() { [EOL] MemberKey key = new MemberKey("method", new Class<?>[]{String.class, Integer.class}); [EOL] Object other = new Object(); [EOL] assertFalse(key.equals(other)); [EOL] }
public void testEquals_DifferentName() { [EOL] MemberKey key1 = new MemberKey("method1", new Class<?>[]{String.class, Integer.class}); [EOL] MemberKey key2 = new MemberKey("method2", new Class<?>[]{String.class, Integer.class}); [EOL] assertFalse(key1.equals(key2)); [EOL] }
public void testEquals_DifferentArgLength() { [EOL] MemberKey key1 = new MemberKey("method", new Class<?>[]{String.class, Integer.class}); [EOL] MemberKey key2 = new MemberKey("method", new Class<?>[]{String.class}); [EOL] assertFalse(key1.equals(key2)); [EOL] }
public void testEquals_DifferentArgTypes() { [EOL] MemberKey key1 = new MemberKey("method", new Class<?>[]{String.class, Integer.class}); [EOL] MemberKey key2 = new MemberKey("method", new Class<?>[]{String.class, Number.class}); [EOL] assertFalse(key1.equals(key2)); [EOL] }
public void testEquals_CompatibleArgTypes() { [EOL] MemberKey key1 = new MemberKey("method", new Class<?>[]{String.class, Number.class}); [EOL] MemberKey key2 = new MemberKey("method", new Class<?>[]{String.class, Integer.class}); [EOL] assertTrue(key1.equals(key2)); [EOL] }
public void testEquals_Identical() { [EOL] MemberKey key1 = new MemberKey("method", new Class<?>[]{String.class, Integer.class}); [EOL] MemberKey key2 = new MemberKey("method", new Class<?>[]{String.class, Integer.class}); [EOL] assertTrue(key1.equals(key2)); [EOL] }
public void testRenameAllWithNullTransformer() { [EOL] BeanPropertyMap originalMap = createBeanPropertyMap(); [EOL] BeanPropertyMap result = originalMap.renameAll(null); [EOL] assertSame("Expected the same BeanPropertyMap instance when transformer is null", originalMap, result); [EOL] } [EOL] public void testRenameAllWithNoOpTransformer() { [EOL] BeanPropertyMap originalMap = createBeanPropertyMap(); [EOL] BeanPropertyMap result = originalMap.renameAll(NameTransformer.NOP); [EOL] assertSame("Expected the same BeanPropertyMap instance when transformer is NameTransformer.NOP", originalMap, result); [EOL] }
public void testRenameAllWithActualTransformer() { [EOL] BeanPropertyMap originalMap = createBeanPropertyMap(); [EOL] NameTransformer transformer = new NameTransformer() { [EOL] @Override [EOL] public String transform(String name) { [EOL] return "prefix_" + name; [EOL] } [EOL] }; [EOL] BeanPropertyMap result = originalMap.renameAll(transformer); [EOL] assertNotNull("Expected a new BeanPropertyMap instance when transformer is provided", result); [EOL] assertNotSame("Expected a different BeanPropertyMap instance when transformer is provided", originalMap, result); [EOL] for (SettableBeanProperty prop : result) { [EOL] assertTrue("Expected property name to be transformed", prop.getName().startsWith("prefix_")); [EOL] } [EOL] }
public void testRenameAllWithUnwrappingDeserializer() { [EOL] BeanPropertyMap originalMap = createBeanPropertyMapWithDeserializer(); [EOL] NameTransformer transformer = new NameTransformer() { [EOL] @Override [EOL] public String transform(String name) { [EOL] return "prefix_" + name; [EOL] } [EOL] }; [EOL] BeanPropertyMap result = originalMap.renameAll(transformer); [EOL] assertNotNull("Expected a new BeanPropertyMap instance when transformer is provided", result); [EOL] assertNotSame("Expected a different BeanPropertyMap instance when transformer is provided", originalMap, result); [EOL] for (SettableBeanProperty prop : result) { [EOL] assertTrue("Expected property name to be transformed", prop.getName().startsWith("prefix_")); [EOL] assertNotNull("Expected property to have a deserializer", prop.getValueDeserializer()); [EOL] assertTrue("Expected deserializer to be an instance of unwrapping deserializer", prop.getValueDeserializer() instanceof UnwrappingDeserializer); [EOL] } [EOL] }
public void testFindWithEqualsWhenKeyExists() { [EOL] SettableBeanProperty expectedProperty = new SettableBeanProperty(); // Mocked or instantiated accordingly [EOL] String key = "testKey"; [EOL] int index = 1; [EOL] Bucket bucket = new Bucket(expectedProperty, key, null); [EOL] _buckets[index] = bucket; // Assuming _buckets is accessible and modifiable [EOL] SettableBeanProperty result = _findWithEquals(key, index); [EOL] assertNotNull(result); [EOL] assertEquals(expectedProperty, result); [EOL] }
public void testFindWithEqualsWhenKeyDoesNotExist() { [EOL] String key = "testKey"; [EOL] int index = 1; [EOL] _buckets[index] = null; // Assuming _buckets is accessible and modifiable [EOL] SettableBeanProperty result = _findWithEquals(key, index); [EOL] assertNull(result); [EOL] }
public void testFindWithEqualsWithMultipleEntries() { [EOL] SettableBeanProperty expectedProperty = new SettableBeanProperty(); // Mocked or instantiated accordingly [EOL] String key = "testKey"; [EOL] int index = 1; [EOL] Bucket bucket1 = new Bucket(new SettableBeanProperty(), "notTestKey", null); [EOL] Bucket bucket2 = new Bucket(expectedProperty, key, bucket1); [EOL] _buckets[index] = bucket2; // Assuming _buckets is accessible and modifiable [EOL] SettableBeanProperty result = _findWithEquals(key, index); [EOL] assertNotNull(result); [EOL] assertEquals(expectedProperty, result); [EOL] }
public void testForTypeWithIntegerType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Integer.TYPE); [EOL] assertTrue(deserializer instanceof IntDeser); [EOL] }
public void testForTypeWithLongType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Long.TYPE); [EOL] assertTrue(deserializer instanceof LongDeser); [EOL] }
public void testForTypeWithByteType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Byte.TYPE); [EOL] assertTrue(deserializer instanceof ByteDeser); [EOL] }
public void testForTypeWithShortType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Short.TYPE); [EOL] assertTrue(deserializer instanceof ShortDeser); [EOL] }
public void testForTypeWithFloatType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Float.TYPE); [EOL] assertTrue(deserializer instanceof FloatDeser); [EOL] }
public void testForTypeWithDoubleType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Double.TYPE); [EOL] assertTrue(deserializer instanceof DoubleDeser); [EOL] }
public void testForTypeWithBooleanType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Boolean.TYPE); [EOL] assertTrue(deserializer instanceof BooleanDeser); [EOL] }
public void testForTypeWithCharacterType() { [EOL] JsonDeserializer<?> deserializer = YourClass.forType(Character.TYPE); [EOL] assertTrue(deserializer instanceof CharDeser); [EOL] }
public void testForTypeWithUnsupportedType() { [EOL] try { [EOL] YourClass.forType(String.class); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testCharDeserConstructor() { [EOL] CharDeser deser = new CharDeser(); [EOL] assertNotNull(deser); [EOL] assertEquals(char[].class, deser.handledType()); [EOL] }
public void testDeserializeWithValueString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getTextCharacters()).thenReturn(new char[]{'t', 'e', 's', 't'}); [EOL] when(jp.getTextOffset()).thenReturn(0); [EOL] when(jp.getTextLength()).thenReturn(4); [EOL] char[] result = deserialize(jp, ctxt); [EOL] assertArrayEquals(new char[]{'t', 'e', 's', 't'}, result); [EOL] }
public void testDeserializeWithStartArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING, JsonToken.VALUE_STRING, JsonToken.END_ARRAY); [EOL] when(jp.getText()).thenReturn("a", "b"); [EOL] char[] result = deserialize(jp, ctxt); [EOL] assertArrayEquals(new char[]{'a', 'b'}, result); [EOL] }
public void testDeserializeWithEmbeddedObjectChar() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(new char[]{'o', 'b', 'j'}); [EOL] char[] result = deserialize(jp, ctxt); [EOL] assertArrayEquals(new char[]{'o', 'b', 'j'}, result); [EOL] }
public void testDeserializeWithEmbeddedObjectString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn("obj"); [EOL] char[] result = deserialize(jp, ctxt); [EOL] assertArrayEquals(new char[]{'o', 'b', 'j'}, result); [EOL] }
public void testDeserializeWithEmbeddedObjectByte() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn("obj".getBytes()); [EOL] char[] result = deserialize(jp, ctxt); [EOL] assertArrayEquals(new char[]{'b', '2', 'J', 'q'}, result); [EOL] }
public void testDeserializeWithUnexpectedToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] deserialize(jp, ctxt); [EOL] }); [EOL] }
public void testDeserializeWithInvalidArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] deserialize(jp, ctxt); [EOL] }); [EOL] }
public void testDeserializeWithInvalidStringLength() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("ab"); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] deserialize(jp, ctxt); [EOL] }); [EOL] }
public void testDeserializeWithNullEmbeddedObject() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(null); [EOL] char[] result = deserialize(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithJsonValueString() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Base64Variant b64variant = mock(Base64Variant.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getBinaryValue(b64variant)).thenReturn(new byte[]{1, 2, 3}); [EOL] when(ctxt.getBase64Variant()).thenReturn(b64variant); [EOL] byte[] result = deserialize(jp, ctxt); [EOL] assertArrayEquals(new byte[]{1, 2, 3}, result); [EOL] }
public void testDeserializeWithJsonEmbeddedObject() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(new byte[]{4, 5, 6}); [EOL] byte[] result = deserialize(jp, null); [EOL] assertArrayEquals(new byte[]{4, 5, 6}, result); [EOL] }
public void testDeserializeWithJsonEmbeddedObjectNull() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_EMBEDDED_OBJECT); [EOL] when(jp.getEmbeddedObject()).thenReturn(null); [EOL] byte[] result = deserialize(jp, null); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithNonArrayToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(false); [EOL] when(ctxt.handleUnexpectedToken(byte[].class, jp)).thenReturn(new byte[]{7, 8, 9}); [EOL] byte[] result = deserialize(jp, ctxt); [EOL] assertArrayEquals(new byte[]{7, 8, 9}, result); [EOL] }
public void testDeserializeWithArrayToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ArrayBuilders.ByteBuilder builder = mock(ArrayBuilders.ByteBuilder.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NUMBER_INT).thenReturn(JsonToken.END_ARRAY); [EOL] when(jp.getByteValue()).thenReturn((byte) 10); [EOL] when(ctxt.getArrayBuilders()).thenReturn(mock(ArrayBuilders.class)); [EOL] when(ctxt.getArrayBuilders().getByteBuilder()).thenReturn(builder); [EOL] when(builder.resetAndStart()).thenReturn(new byte[1]); [EOL] when(builder.completeAndClearBuffer(any(byte[].class), anyInt())).thenReturn(new byte[]{10}); [EOL] byte[] result = deserialize(jp, ctxt); [EOL] assertArrayEquals(new byte[]{10}, result); [EOL] }
public void testDeserializeWithArrayTokenAndNullValue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ArrayBuilders.ByteBuilder builder = mock(ArrayBuilders.ByteBuilder.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NULL).thenReturn(JsonToken.END_ARRAY); [EOL] when(ctxt.getArrayBuilders()).thenReturn(mock(ArrayBuilders.class)); [EOL] when(ctxt.getArrayBuilders().getByteBuilder()).thenReturn(builder); [EOL] when(builder.resetAndStart()).thenReturn(new byte[1]); [EOL] when(builder.completeAndClearBuffer(any(byte[].class), anyInt())).thenReturn(new byte[]{0}); [EOL] byte[] result = deserialize(jp, ctxt); [EOL] assertArrayEquals(new byte[]{0}, result); [EOL] }
public void testDeserializeWithUnexpectedToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_ARRAY); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_TRUE); [EOL] when(ctxt.mappingException(any(Class.class))).thenThrow(new JsonMappingException("Unexpected token")); [EOL] assertThrows(JsonMappingException.class, () -> deserialize(jp, ctxt)); [EOL] }
public void testShortDeserConstructor() { [EOL] ShortDeser deser = new ShortDeser(); [EOL] assertNotNull(deser); [EOL] }
public void testDeserializeWithNonArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(false); [EOL] short[] result = deserialize(jp, ctxt); [EOL] }
public void testDeserializeWithEmptyArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] short[] result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testDeserializeWithNonEmptyArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ArrayBuilders.ShortBuilder builder = ctxt.getArrayBuilders().getShortBuilder(); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NUMBER_INT, JsonToken.END_ARRAY); [EOL] when(jp.getShortValue()).thenReturn((short) 1); [EOL] short[] result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.length); [EOL] assertEquals((short) 1, result[0]); [EOL] }
public void testDeserializeWithFullChunk() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ArrayBuilders.ShortBuilder builder = ctxt.getArrayBuilders().getShortBuilder(); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NUMBER_INT, JsonToken.VALUE_NUMBER_INT, JsonToken.END_ARRAY); [EOL] when(jp.getShortValue()).thenReturn((short) 1, (short) 2); [EOL] short[] result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(2, result.length); [EOL] assertEquals((short) 1, result[0]); [EOL] assertEquals((short) 2, result[1]); [EOL] }
public void testLongDeserConstructor() { [EOL] LongDeser deserializer = new LongDeser(); [EOL] assertNotNull(deserializer); [EOL] }
public void testDeserializeWithNonArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(false); [EOL] long[] result = new CustomDeserializer().deserialize(jp, ctxt); [EOL] }
public void testDeserializeWithEmptyArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] long[] result = new CustomDeserializer().deserialize(jp, ctxt); [EOL] }
public void testDeserializeWithNonEmptyArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NUMBER_INT, JsonToken.END_ARRAY); [EOL] when(jp.getLongValue()).thenReturn(10L); [EOL] long[] result = new CustomDeserializer().deserialize(jp, ctxt); [EOL] }
public void testDeserializeWithLargeArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] ArrayBuilders.LongBuilder builder = ctxt.getArrayBuilders().getLongBuilder(); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NUMBER_INT, JsonToken.VALUE_NUMBER_INT, JsonToken.END_ARRAY); [EOL] when(jp.getLongValue()).thenReturn(10L, 20L); [EOL] when(builder.resetAndStart()).thenReturn(new long[1]); [EOL] long[] result = new CustomDeserializer().deserialize(jp, ctxt); [EOL] }
public void testDoubleDeserConstructor() { [EOL] DoubleDeser deser = new DoubleDeser(); [EOL] assertNotNull(deser); [EOL] }
public void testDeserializeWithNonArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(false); [EOL] double[] result = new double[]{}; [EOL] when(ctxt.handleNonArray(jp, ctxt)).thenReturn(result); [EOL] double[] deserialized = deserialize(jp, ctxt); [EOL] assertArrayEquals(result, deserialized); [EOL] }
public void testDeserializeWithEmptyArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] ArrayBuilders.DoubleBuilder builder = ctxt.getArrayBuilders().getDoubleBuilder(); [EOL] when(ctxt.getArrayBuilders().getDoubleBuilder()).thenReturn(builder); [EOL] double[] deserialized = deserialize(jp, ctxt); [EOL] assertArrayEquals(new double[]{}, deserialized); [EOL] }
public void testDeserializeWithNonEmptyArray() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT, JsonToken.END_ARRAY); [EOL] when(jp.getDoubleValue()).thenReturn(1.0); [EOL] ArrayBuilders.DoubleBuilder builder = ctxt.getArrayBuilders().getDoubleBuilder(); [EOL] when(ctxt.getArrayBuilders().getDoubleBuilder()).thenReturn(builder); [EOL] when(builder.resetAndStart()).thenReturn(new double[1]); [EOL] double[] deserialized = deserialize(jp, ctxt); [EOL] assertArrayEquals(new double[]{1.0}, deserialized); [EOL] }
public void testDeserializeWithArrayNeedingExpansion() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.isExpectedStartArrayToken()).thenReturn(true); [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT, JsonToken.VALUE_NUMBER_FLOAT, JsonToken.END_ARRAY); [EOL] when(jp.getDoubleValue()).thenReturn(1.0, 2.0); [EOL] ArrayBuilders.DoubleBuilder builder = ctxt.getArrayBuilders().getDoubleBuilder(); [EOL] when(ctxt.getArrayBuilders().getDoubleBuilder()).thenReturn(builder); [EOL] double[] initialChunk = new double[1]; [EOL] double[] expandedChunk = new double[2]; [EOL] when(builder.resetAndStart()).thenReturn(initialChunk); [EOL] when(builder.appendCompletedChunk(initialChunk, 1)).thenReturn(expandedChunk); [EOL] double[] deserialized = deserialize(jp, ctxt); [EOL] assertArrayEquals(new double[]{1.0, 2.0}, deserialized); [EOL] }
public void testInjectWithNonNullProperties() { [EOL] SettableBeanProperty[] injectableProperties = new SettableBeanProperty[2]; [EOL] injectableProperties[0] = mock(SettableBeanProperty.class); [EOL] injectableProperties[1] = mock(SettableBeanProperty.class); [EOL] when(injectableProperties[0].getInjectableValueId()).thenReturn("valueId1"); [EOL] when(injectableProperties[1].getInjectableValueId()).thenReturn("valueId2"); [EOL] InjectableValues injectableValues = mock(InjectableValues.class); [EOL] when(_context.findInjectableValue(any(), any(), any())).thenReturn("injectedValue"); [EOL] inject(injectableProperties); [EOL] verify(_context).findInjectableValue("valueId1", injectableProperties[0], null); [EOL] verify(_context).findInjectableValue("valueId2", injectableProperties[1], null); [EOL] assertEquals("injectedValue", _creatorParameters[0]); [EOL] assertEquals("injectedValue", _creatorParameters[1]); [EOL] }
public void testInjectWithSomeNullProperties() { [EOL] SettableBeanProperty[] injectableProperties = new SettableBeanProperty[2]; [EOL] injectableProperties[0] = null; [EOL] injectableProperties[1] = mock(SettableBeanProperty.class); [EOL] when(injectableProperties[1].getInjectableValueId()).thenReturn("valueId2"); [EOL] InjectableValues injectableValues = mock(InjectableValues.class); [EOL] when(_context.findInjectableValue(any(), any(), any())).thenReturn("injectedValue"); [EOL] inject(injectableProperties); [EOL] verify(_context, never()).findInjectableValue(any(), eq(injectableProperties[0]), any()); [EOL] verify(_context).findInjectableValue("valueId2", injectableProperties[1], null); [EOL] assertNull(_creatorParameters[0]); [EOL] assertEquals("injectedValue", _creatorParameters[1]); [EOL] }
public void testInjectWithAllNullProperties() { [EOL] SettableBeanProperty[] injectableProperties = new SettableBeanProperty[2]; [EOL] injectableProperties[0] = null; [EOL] injectableProperties[1] = null; [EOL] inject(injectableProperties); [EOL] verify(_context, never()).findInjectableValue(any(), any(), any()); [EOL] assertNull(_creatorParameters[0]); [EOL] assertNull(_creatorParameters[1]); [EOL] }
public void testGetParametersWithNonNullDefaults() { [EOL] Object[] defaults = new Object[] { "default1", "default2", "default3" }; [EOL] Object[] creatorParameters = new Object[3]; [EOL] TestClass testInstance = new TestClass(creatorParameters); [EOL] Object[] result = testInstance.getParameters(defaults); [EOL] assertArrayEquals(new Object[] { "default1", "default2", "default3" }, result); [EOL] }
public void testGetParametersWithNullDefaults() { [EOL] Object[] defaults = null; [EOL] Object[] creatorParameters = new Object[] { "param1", "param2", "param3" }; [EOL] TestClass testInstance = new TestClass(creatorParameters); [EOL] Object[] result = testInstance.getParameters(defaults); [EOL] assertArrayEquals(new Object[] { "param1", "param2", "param3" }, result); [EOL] }
public void testGetParametersWithPartialNullValues() { [EOL] Object[] defaults = new Object[] { "default1", null, "default3" }; [EOL] Object[] creatorParameters = new Object[] { null, "param2", null }; [EOL] TestClass testInstance = new TestClass(creatorParameters); [EOL] Object[] result = testInstance.getParameters(defaults); [EOL] assertArrayEquals(new Object[] { "default1", "param2", "default3" }, result); [EOL] }
public void testHasSingleElementWithEmptyList() { [EOL] List<Object> emptyList = new ArrayList<>(); [EOL] boolean result = hasSingleElement(emptyList); [EOL] assertFalse(result); [EOL] }
public void testHasSingleElementWithOneElement() { [EOL] List<Object> singleElementList = new ArrayList<>(); [EOL] singleElementList.add(new Object()); [EOL] boolean result = hasSingleElement(singleElementList); [EOL] assertTrue(result); [EOL] }
public void testHasSingleElementWithMultipleElements() { [EOL] List<Object> multipleElementsList = new ArrayList<>(); [EOL] multipleElementsList.add(new Object()); [EOL] multipleElementsList.add(new Object()); [EOL] boolean result = hasSingleElement(multipleElementsList); [EOL] assertFalse(result); [EOL] }
public void testSerializeContentsWithElementSerializer() throws IOException { [EOL] List<?> value = ...; // Initialize with a list that will trigger the _elementSerializer branch [EOL] JsonGenerator jgen = ...; // Mock JsonGenerator [EOL] SerializerProvider provider = ...; // Mock SerializerProvider [EOL] JsonSerializer<Object> elementSerializer = ...; // Mock element serializer [EOL] YourSerializerClass serializer = new YourSerializerClass(elementSerializer, null, null); [EOL] serializer.serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsWithValueTypeSerializer() throws IOException { [EOL] List<?> value = ...; // Initialize with a list that will trigger the _valueTypeSerializer branch [EOL] JsonGenerator jgen = ...; // Mock JsonGenerator [EOL] SerializerProvider provider = ...; // Mock SerializerProvider [EOL] TypeSerializer valueTypeSerializer = ...; // Mock value type serializer [EOL] YourSerializerClass serializer = new YourSerializerClass(null, valueTypeSerializer, null); [EOL] serializer.serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsEmptyList() throws IOException { [EOL] List<?> value = Collections.emptyList(); // Empty list [EOL] JsonGenerator jgen = ...; // Mock JsonGenerator [EOL] SerializerProvider provider = ...; // Mock SerializerProvider [EOL] YourSerializerClass serializer = new YourSerializerClass(null, null, null); [EOL] serializer.serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsDynamicSerializers() throws IOException { [EOL] List<?> value = ...; // Initialize with a list that will trigger the dynamic serializers branch [EOL] JsonGenerator jgen = ...; // Mock JsonGenerator [EOL] SerializerProvider provider = ...; // Mock SerializerProvider [EOL] JavaType elementType = ...; // Mock JavaType for _elementType [EOL] PropertySerializerMap dynamicSerializers = ...; // Mock PropertySerializerMap [EOL] YourSerializerClass serializer = new YourSerializerClass(null, null, elementType); [EOL] serializer.serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsWithException() throws IOException { [EOL] List<?> value = ...; // Initialize with a list that will cause an exception during serialization [EOL] JsonGenerator jgen = ...; // Mock JsonGenerator [EOL] SerializerProvider provider = ...; // Mock SerializerProvider [EOL] YourSerializerClass serializer = new YourSerializerClass(null, null, null); [EOL] try { [EOL] serializer.serializeContents(value, jgen, provider); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (Exception e) { [EOL] } [EOL] }
public void testSerializeTypedContentsEmptyList() throws IOException { [EOL] List<?> value = Collections.emptyList(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] serializeTypedContents(value, jgen, provider); [EOL] verifyNoMoreInteractions(jgen); [EOL] }
public void testSerializeTypedContentsWithNullElement() throws IOException { [EOL] List<Object> value = new ArrayList<>(); [EOL] value.add(null); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] serializeTypedContents(value, jgen, provider); [EOL] verify(provider).defaultSerializeNull(jgen); [EOL] }
public void testSerializeTypedContentsWithNonNullElement() throws IOException { [EOL] List<Object> value = new ArrayList<>(); [EOL] value.add("testString"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] when(_valueTypeSerializer).thenReturn(typeSer); [EOL] when(_dynamicSerializers.serializerFor(any(Class.class))).thenReturn(serializer); [EOL] serializeTypedContents(value, jgen, provider); [EOL] verify(serializer).serializeWithType("testString", jgen, provider, typeSer); [EOL] }
public void testSerializeTypedContentsWithException() throws IOException { [EOL] List<Object> value = new ArrayList<>(); [EOL] value.add("testString"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] JsonSerializer<Object> serializer = mock(JsonSerializer.class); [EOL] when(_valueTypeSerializer).thenReturn(typeSer); [EOL] when(_dynamicSerializers.serializerFor(any(Class.class))).thenReturn(serializer); [EOL] doThrow(new IOException()).when(serializer).serializeWithType(any(), any(JsonGenerator.class), any(SerializerProvider.class), any(TypeSerializer.class)); [EOL] try { [EOL] serializeTypedContents(value, jgen, provider); [EOL] fail("IOException expected"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testWriteCustomTypePrefixForObject() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] String typeId = "customType"; [EOL] Object value = new Object(); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] TypeSerializer typeSer = mapper.getSerializerProviderInstance().findTypeSerializer(mapper.constructType(value.getClass()), null, null); [EOL] typeSer.writeCustomTypePrefixForObject(value, mockJsonGenerator, typeId); [EOL] verify(mockJsonGenerator).writeStartArray(); [EOL] verify(mockJsonGenerator).writeString(typeId); [EOL] verify(mockJsonGenerator).writeStartObject(); [EOL] }
public void testWriteCustomTypeSuffixForObject() throws IOException, JsonProcessingException { [EOL] writeCustomTypeSuffixForObject(value, jgen, typeId); [EOL] }
public void testBooleanNodeTrue() { [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] ObjectMapper mapper = new ObjectMapper(null, null, null); [EOL] mapper.setNodeFactory(nodeFactory); [EOL] BooleanNode result = mapper.booleanNode(true); [EOL] assertTrue(result.booleanValue()); [EOL] }
public void testBooleanNodeFalse() { [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] ObjectMapper mapper = new ObjectMapper(null, null, null); [EOL] mapper.setNodeFactory(nodeFactory); [EOL] BooleanNode result = mapper.booleanNode(false); [EOL] assertFalse(result.booleanValue()); [EOL] }
public void testNumberNodeWithPositiveValue() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] long positiveValue = 123L; [EOL] NumericNode result = mapper.numberNode(positiveValue); [EOL] assertNotNull(result); [EOL] assertEquals(positiveValue, result.longValue()); [EOL] }
public void testNumberNodeWithNegativeValue() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] long negativeValue = -123L; [EOL] NumericNode result = mapper.numberNode(negativeValue); [EOL] assertNotNull(result); [EOL] assertEquals(negativeValue, result.longValue()); [EOL] }
public void testNumberNodeWithZero() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] long zeroValue = 0L; [EOL] NumericNode result = mapper.numberNode(zeroValue); [EOL] assertNotNull(result); [EOL] assertEquals(zeroValue, result.longValue()); [EOL] }
public void testNumberNodeWithPositiveFloat() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] float testValue = 10.5f; [EOL] NumericNode result = mapper.numberNode(testValue); [EOL] assertTrue(result.isFloat()); [EOL] assertEquals(testValue, result.floatValue(), 0.0f); [EOL] }
public void testNumberNodeWithNegativeFloat() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] float testValue = -10.5f; [EOL] NumericNode result = mapper.numberNode(testValue); [EOL] assertTrue(result.isFloat()); [EOL] assertEquals(testValue, result.floatValue(), 0.0f); [EOL] }
public void testNumberNodeWithZero() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] float testValue = 0.0f; [EOL] NumericNode result = mapper.numberNode(testValue); [EOL] assertTrue(result.isFloat()); [EOL] assertEquals(testValue, result.floatValue(), 0.0f); [EOL] }
public void testPOJONodeWithNull() { [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.setNodeFactory(nodeFactory); [EOL] POJONode result = mapper.POJONode(null); [EOL] assertNull(result.getPojo()); [EOL] }
public void testPOJONodeWithNonNull() { [EOL] JsonNodeFactory nodeFactory = new JsonNodeFactory(true); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] mapper.setNodeFactory(nodeFactory); [EOL] Object pojo = new Object(); [EOL] POJONode result = mapper.POJONode(pojo); [EOL] assertSame(pojo, result.getPojo()); [EOL] }
public void testWithResolvedSameDeserializers() { [EOL] JsonDeserializer<?> dd = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> vd = mock(JsonDeserializer.class); [EOL] TypeDeserializer vtd = mock(TypeDeserializer.class); [EOL] CollectionType collectionType = mock(CollectionType.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] CollectionDeserializer original = new CollectionDeserializer(collectionType, vd, vtd, valueInstantiator, dd); [EOL] CollectionDeserializer result = original.withResolved(dd, vd, vtd); [EOL] assertSame("Expected same instance of CollectionDeserializer when deserializers are the same", original, result); [EOL] }
public void testWithResolvedDifferentDeserializers() { [EOL] JsonDeserializer<?> originalDD = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> originalVD = mock(JsonDeserializer.class); [EOL] TypeDeserializer originalVTD = mock(TypeDeserializer.class); [EOL] CollectionType collectionType = mock(CollectionType.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] CollectionDeserializer original = new CollectionDeserializer(collectionType, originalVD, originalVTD, valueInstantiator, originalDD); [EOL] JsonDeserializer<?> newDD = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> newVD = mock(JsonDeserializer.class); [EOL] TypeDeserializer newVTD = mock(TypeDeserializer.class); [EOL] CollectionDeserializer result = original.withResolved(newDD, newVD, newVTD); [EOL] assertNotSame("Expected different instance of CollectionDeserializer when deserializers are different", original, result); [EOL] assertNotNull("Resulting CollectionDeserializer should not be null", result); [EOL] }
public void testEquals_Reflexive() { [EOL] NamedType namedType = new NamedType(SomeClass.class); [EOL] assertTrue(namedType.equals(namedType)); [EOL] } [EOL] public void testEquals_Null() { [EOL] NamedType namedType = new NamedType(SomeClass.class); [EOL] assertFalse(namedType.equals(null)); [EOL] } [EOL] public void testEquals_DifferentClass() { [EOL] NamedType namedType1 = new NamedType(SomeClass.class); [EOL] Object differentClassObject = new Object(); [EOL] assertFalse(namedType1.equals(differentClassObject)); [EOL] } [EOL] public void testEquals_EqualObjects() { [EOL] NamedType namedType1 = new NamedType(SomeClass.class); [EOL] NamedType namedType2 = new NamedType(SomeClass.class); [EOL] assertTrue(namedType1.equals(namedType2)); [EOL] } [EOL] public void testEquals_NotEqualObjects() { [EOL] NamedType namedType1 = new NamedType(SomeClass.class); [EOL] NamedType namedType2 = new NamedType(AnotherClass.class); [EOL] assertFalse(namedType1.equals(namedType2)); [EOL] }
public void testHasSingleElementWithSingleElementArray() { [EOL] Object[] singleElementArray = new Object[]{new Object()}; [EOL] assertTrue(hasSingleElement(singleElementArray)); [EOL] }
public void testHasSingleElementWithEmptyArray() { [EOL] Object[] emptyArray = new Object[]{}; [EOL] assertFalse(hasSingleElement(emptyArray)); [EOL] }
public void testHasSingleElementWithMultipleElementsArray() { [EOL] Object[] multipleElementsArray = new Object[]{new Object(), new Object()}; [EOL] assertFalse(hasSingleElement(multipleElementsArray)); [EOL] }
protected Object _deserializeNonVanilla(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL] if (_nonStandardCreation) { [EOL] return _deserializeWithCreator(jp, ctxt); [EOL] } [EOL] final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL] if (_injectables != null) { [EOL] injectValues(ctxt, bean); [EOL] } [EOL] Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null; [EOL] final SettableBeanProperty[] props = _orderedProperties; [EOL] int i = 0; [EOL] final int propCount = props.length; [EOL] while (true) { [EOL] if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL] return bean; [EOL] } [EOL] if (i == propCount) { [EOL] break; [EOL] } [EOL] SettableBeanProperty prop = props[i]; [EOL] ++i; [EOL] if (prop != null) { [EOL] if (activeView == null || prop.visibleInView(activeView)) { [EOL] try { [EOL] prop.deserializeAndSet(jp, ctxt, bean); [EOL] } catch (Exception e) { [EOL] wrapAndThrow(e, bean, prop.getName(), ctxt); [EOL] } [EOL] continue; [EOL] } [EOL] } [EOL] jp.skipChildren(); [EOL] } [EOL] if (!_ignoreAllUnknown) { [EOL] throw ctxt.mappingException("Unexpected JSON values; expected at most " + propCount + " properties (in JSON Array)"); [EOL] } [EOL] while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL] jp.skipChildren(); [EOL] } [EOL] return bean; [EOL] }
public void testDeserializeWithCreatorDelegateNotNull() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] JsonDeserializer<Object> delegateDeserializer = mock(JsonDeserializer.class); [EOL] ValueInstantiator valueInstantiator = mock(ValueInstantiator.class); [EOL] Object delegateResult = new Object(); [EOL] when(_delegateDeserializer.deserialize(jp, ctxt)).thenReturn(delegateResult); [EOL] when(_valueInstantiator.createUsingDelegate(ctxt, delegateResult)).thenReturn(new Object()); [EOL] _delegateDeserializer = delegateDeserializer; [EOL] _valueInstantiator = valueInstantiator; [EOL] Object result = _deserializeWithCreator(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithCreatorPropertyBasedNotNull() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] _delegateDeserializer = null; [EOL] _propertyBasedCreator = mock(PropertyBasedCreator.class); [EOL] Object result = _deserializeWithCreator(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithCreatorBeanTypeAbstract() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] _delegateDeserializer = null; [EOL] _propertyBasedCreator = null; [EOL] JavaType beanType = mock(JavaType.class); [EOL] when(beanType.isAbstract()).thenReturn(true); [EOL] _beanType = beanType; [EOL] assertThrows(JsonMappingException.class, () -> _deserializeWithCreator(jp, ctxt)); [EOL] }
public void testDeserializeWithCreatorNoSuitableConstructor() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] _delegateDeserializer = null; [EOL] _propertyBasedCreator = null; [EOL] JavaType beanType = mock(JavaType.class); [EOL] when(beanType.isAbstract()).thenReturn(false); [EOL] _beanType = beanType; [EOL] assertThrows(JsonMappingException.class, () -> _deserializeWithCreator(jp, ctxt)); [EOL] }
public void testDeserializeUsingPropertyBasedWithEndArrayToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] PropertyBasedCreator creator = mock(PropertyBasedCreator.class); [EOL] PropertyValueBuffer buffer = mock(PropertyValueBuffer.class); [EOL] SettableBeanProperty[] props = new SettableBeanProperty[0]; [EOL] when(jp.nextToken()).thenReturn(JsonToken.END_ARRAY); [EOL] when(creator.startBuilding(jp, ctxt, null)).thenReturn(buffer); [EOL] when(buffer.getParameters()).thenReturn(new Object[0]); [EOL] Object result = _deserializeUsingPropertyBased(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testDeserializeUsingPropertyBasedWithNonEndArrayTokenAndNoProps() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] PropertyBasedCreator creator = mock(PropertyBasedCreator.class); [EOL] PropertyValueBuffer buffer = mock(PropertyValueBuffer.class); [EOL] SettableBeanProperty[] props = new SettableBeanProperty[0]; [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_ARRAY); [EOL] when(creator.startBuilding(jp, ctxt, null)).thenReturn(buffer); [EOL] when(buffer.getParameters()).thenReturn(new Object[0]); [EOL] Object result = _deserializeUsingPropertyBased(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testDeserializeUsingPropertyBasedWithNonEndArrayTokenAndProps() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] PropertyBasedCreator creator = mock(PropertyBasedCreator.class); [EOL] PropertyValueBuffer buffer = mock(PropertyValueBuffer.class); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] SettableBeanProperty[] props = new SettableBeanProperty[]{prop}; [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_ARRAY); [EOL] when(creator.startBuilding(jp, ctxt, null)).thenReturn(buffer); [EOL] when(buffer.getParameters()).thenReturn(new Object[0]); [EOL] when(prop.getName()).thenReturn("propName"); [EOL] when(creator.findCreatorProperty("propName")).thenReturn(null); [EOL] when(prop.deserialize(jp, ctxt)).thenReturn(new Object()); [EOL] Object result = _deserializeUsingPropertyBased(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeUsingPropertyBasedWithException() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] PropertyBasedCreator creator = mock(PropertyBasedCreator.class); [EOL] PropertyValueBuffer buffer = mock(PropertyValueBuffer.class); [EOL] SettableBeanProperty prop = mock(SettableBeanProperty.class); [EOL] SettableBeanProperty[] props = new SettableBeanProperty[]{prop}; [EOL] when(jp.nextToken()).thenReturn(JsonToken.VALUE_STRING).thenReturn(JsonToken.END_ARRAY); [EOL] when(creator.startBuilding(jp, ctxt, null)).thenReturn(buffer); [EOL] when(buffer.getParameters()).thenReturn(new Object[0]); [EOL] when(prop.getName()).thenReturn("propName"); [EOL] when(creator.findCreatorProperty("propName")).thenReturn(null); [EOL] when(prop.deserialize(jp, ctxt)).thenThrow(new IOException()); [EOL] try { [EOL] _deserializeUsingPropertyBased(jp, ctxt); [EOL] fail("Expected exception was not thrown."); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testUntypedValueSerializerWithNullCacheKey() { [EOL] TypeKey mockTypeKey = Mockito.mock(TypeKey.class); [EOL] JsonSerializer<Object> expectedSerializer = Mockito.mock(JsonSerializer.class); [EOL] SimpleSerializers serializers = new SimpleSerializers(); [EOL] serializers.addSerializer(Object.class, expectedSerializer); [EOL] JsonSerializer<Object> serializer = serializers.untypedValueSerializer(Object.class); [EOL] assertNotNull(serializer); [EOL] assertSame(expectedSerializer, serializer); [EOL] }
public void testUntypedValueSerializerWithNonNullCacheKey() { [EOL] TypeKey mockTypeKey = Mockito.mock(TypeKey.class); [EOL] JsonSerializer<Object> expectedSerializer = Mockito.mock(JsonSerializer.class); [EOL] SimpleSerializers serializers = new SimpleSerializers(); [EOL] serializers.addSerializer(Object.class, expectedSerializer); [EOL] serializers._cacheKey = mockTypeKey; [EOL] JsonSerializer<Object> serializer = serializers.untypedValueSerializer(Object.class); [EOL] assertNotNull(serializer); [EOL] assertSame(expectedSerializer, serializer); [EOL] }
public void testJSONPObjectWithNullJavaType() { [EOL] String expectedFunction = "callback"; [EOL] Object expectedValue = "Test Value"; [EOL] JSONPObject jsonpObject = new JSONPObject(expectedFunction, expectedValue); [EOL] assertNull(jsonpObject.getJavaType()); [EOL] assertEquals(expectedFunction, jsonpObject.getFunction()); [EOL] assertEquals(expectedValue, jsonpObject.getValue()); [EOL] }
public void testJSONPObjectWithNonNullValue() { [EOL] String expectedFunction = "callback"; [EOL] Object expectedValue = new Object(); [EOL] JSONPObject jsonpObject = new JSONPObject(expectedFunction, expectedValue); [EOL] assertNull(jsonpObject.getJavaType()); [EOL] assertEquals(expectedFunction, jsonpObject.getFunction()); [EOL] assertEquals(expectedValue, jsonpObject.getValue()); [EOL] }
public void testSerializeWithNullValue() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] CustomSerializer instance = new CustomSerializer(null, null); [EOL] instance.serialize(mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeRaw(instance._function); [EOL] verify(mockJsonGenerator).writeRaw('('); [EOL] verify(mockProvider).defaultSerializeNull(mockJsonGenerator); [EOL] verify(mockJsonGenerator).writeRaw(')'); [EOL] }
public void testSerializeWithType() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] Object value = new Object(); [EOL] JavaType serializationType = mock(JavaType.class); [EOL] JsonSerializer<Object> mockSerializer = mock(JsonSerializer.class); [EOL] when(mockProvider.findTypedValueSerializer(eq(serializationType), eq(true), isNull())).thenReturn(mockSerializer); [EOL] CustomSerializer instance = new CustomSerializer(value, serializationType); [EOL] instance.serialize(mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeRaw(instance._function); [EOL] verify(mockJsonGenerator).writeRaw('('); [EOL] verify(mockSerializer).serialize(eq(value), eq(mockJsonGenerator), eq(mockProvider)); [EOL] verify(mockJsonGenerator).writeRaw(')'); [EOL] }
public void testSerializeWithoutType() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] Object value = new Object(); [EOL] JsonSerializer<Object> mockSerializer = mock(JsonSerializer.class); [EOL] when(mockProvider.findTypedValueSerializer(eq(value.getClass()), eq(true), isNull())).thenReturn(mockSerializer); [EOL] CustomSerializer instance = new CustomSerializer(value, null); [EOL] instance.serialize(mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeRaw(instance._function); [EOL] verify(mockJsonGenerator).writeRaw('('); [EOL] verify(mockSerializer).serialize(eq(value), eq(mockJsonGenerator), eq(mockProvider)); [EOL] verify(mockJsonGenerator).writeRaw(')'); [EOL] }
public void testFindBeanPropertiesWithEmptyProperties() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanSerializerBuilder builder = new BeanSerializerBuilder(beanDesc); [EOL] when(beanDesc.findProperties()).thenReturn(Collections.emptyList()); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] List<BeanPropertyWriter> result = findBeanProperties(prov, beanDesc, builder); [EOL] assertNull(result); [EOL] }
public void testFindBeanPropertiesWithIgnorableTypes() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanSerializerBuilder builder = new BeanSerializerBuilder(beanDesc); [EOL] List<BeanPropertyDefinition> propertyDefinitions = new ArrayList<>(); [EOL] propertyDefinitions.add(mock(BeanPropertyDefinition.class)); [EOL] when(beanDesc.findProperties()).thenReturn(propertyDefinitions); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)).thenReturn(false); [EOL] findBeanProperties(prov, beanDesc, builder); [EOL] verify(config, times(1)).isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS); [EOL] }
public void testFindBeanPropertiesWithSetterlessGetters() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanSerializerBuilder builder = new BeanSerializerBuilder(beanDesc); [EOL] List<BeanPropertyDefinition> propertyDefinitions = new ArrayList<>(); [EOL] propertyDefinitions.add(mock(BeanPropertyDefinition.class)); [EOL] when(beanDesc.findProperties()).thenReturn(propertyDefinitions); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)).thenReturn(true); [EOL] findBeanProperties(prov, beanDesc, builder); [EOL] verify(config, times(1)).isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS); [EOL] }
public void testFindBeanPropertiesWithTypeId() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanSerializerBuilder builder = new BeanSerializerBuilder(beanDesc); [EOL] BeanPropertyDefinition propertyDefinition = mock(BeanPropertyDefinition.class); [EOL] when(propertyDefinition.isTypeId()).thenReturn(true); [EOL] List<BeanPropertyDefinition> propertyDefinitions = Collections.singletonList(propertyDefinition); [EOL] when(beanDesc.findProperties()).thenReturn(propertyDefinitions); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] List<BeanPropertyWriter> result = findBeanProperties(prov, beanDesc, builder); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testFindBeanPropertiesWithBackReference() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanSerializerBuilder builder = new BeanSerializerBuilder(beanDesc); [EOL] BeanPropertyDefinition propertyDefinition = mock(BeanPropertyDefinition.class); [EOL] AnnotationIntrospector.ReferenceProperty refType = mock(AnnotationIntrospector.ReferenceProperty.class); [EOL] when(refType.isBackReference()).thenReturn(true); [EOL] when(propertyDefinition.findReferenceType()).thenReturn(refType); [EOL] List<BeanPropertyDefinition> propertyDefinitions = Collections.singletonList(propertyDefinition); [EOL] when(beanDesc.findProperties()).thenReturn(propertyDefinitions); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] List<BeanPropertyWriter> result = findBeanProperties(prov, beanDesc, builder); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testFindBeanPropertiesWithValidProperties() throws JsonMappingException { [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] BeanSerializerBuilder builder = new BeanSerializerBuilder(beanDesc); [EOL] BeanPropertyDefinition propertyDefinition = mock(BeanPropertyDefinition.class); [EOL] AnnotatedMember accessor = mock(AnnotatedMember.class); [EOL] when(propertyDefinition.getAccessor()).thenReturn(accessor); [EOL] when(propertyDefinition.isTypeId()).thenReturn(false); [EOL] when(propertyDefinition.findReferenceType()).thenReturn(null); [EOL] List<BeanPropertyDefinition> propertyDefinitions = Collections.singletonList(propertyDefinition); [EOL] when(beanDesc.findProperties()).thenReturn(propertyDefinitions); [EOL] SerializationConfig config = mock(SerializationConfig.class); [EOL] when(prov.getConfig()).thenReturn(config); [EOL] when(config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)).thenReturn(false); [EOL] List<BeanPropertyWriter> result = findBeanProperties(prov, beanDesc, builder); [EOL] assertFalse(result.isEmpty()); [EOL] assertEquals(1, result.size()); [EOL] }
public void testFindWithPrimitiveIntegerType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Integer.TYPE, "java.lang.Integer"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof IntegerDeserializer); [EOL] assertEquals(IntegerDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithPrimitiveBooleanType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Boolean.TYPE, "java.lang.Boolean"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof BooleanDeserializer); [EOL] assertEquals(BooleanDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithPrimitiveLongType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Long.TYPE, "java.lang.Long"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof LongDeserializer); [EOL] assertEquals(LongDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithPrimitiveDoubleType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Double.TYPE, "java.lang.Double"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof DoubleDeserializer); [EOL] assertEquals(DoubleDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithPrimitiveCharacterType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Character.TYPE, "java.lang.Character"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof CharacterDeserializer); [EOL] assertEquals(CharacterDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithPrimitiveByteType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Byte.TYPE, "java.lang.Byte"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof ByteDeserializer); [EOL] assertEquals(ByteDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithPrimitiveShortType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Short.TYPE, "java.lang.Short"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof ShortDeserializer); [EOL] assertEquals(ShortDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithPrimitiveFloatType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Float.TYPE, "java.lang.Float"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof FloatDeserializer); [EOL] assertEquals(FloatDeserializer.primitiveInstance, deserializer); [EOL] }
public void testFindWithWrapperIntegerType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Integer.class, "java.lang.Integer"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof IntegerDeserializer); [EOL] assertEquals(IntegerDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithWrapperBooleanType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Boolean.class, "java.lang.Boolean"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof BooleanDeserializer); [EOL] assertEquals(BooleanDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithWrapperLongType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Long.class, "java.lang.Long"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof LongDeserializer); [EOL] assertEquals(LongDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithWrapperDoubleType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Double.class, "java.lang.Double"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof DoubleDeserializer); [EOL] assertEquals(DoubleDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithWrapperCharacterType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Character.class, "java.lang.Character"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof CharacterDeserializer); [EOL] assertEquals(CharacterDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithWrapperByteType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Byte.class, "java.lang.Byte"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof ByteDeserializer); [EOL] assertEquals(ByteDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithWrapperShortType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Short.class, "java.lang.Short"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof ShortDeserializer); [EOL] assertEquals(ShortDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithWrapperFloatType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Float.class, "java.lang.Float"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof FloatDeserializer); [EOL] assertEquals(FloatDeserializer.wrapperInstance, deserializer); [EOL] }
public void testFindWithWrapperNumberType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Number.class, "java.lang.Number"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof NumberDeserializer); [EOL] assertEquals(NumberDeserializer.instance, deserializer); [EOL] }
public void testFindWithWrapperBigDecimalType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(BigDecimal.class, "java.math.BigDecimal"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof BigDecimalDeserializer); [EOL] assertEquals(BigDecimalDeserializer.instance, deserializer); [EOL] }
public void testFindWithWrapperBigIntegerType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(BigInteger.class, "java.math.BigInteger"); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof BigIntegerDeserializer); [EOL] assertEquals(BigIntegerDeserializer.instance, deserializer); [EOL] }
public void testFindWithUnrecognizedType() { [EOL] JsonDeserializer<?> deserializer = YourClass.find(Object.class, "java.lang.Object"); [EOL] assertNull(deserializer); [EOL] }
public void testFindWithNullType() { [EOL] try { [EOL] YourClass.find(null, "java.lang.Integer"); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testDeserializeValueNumberIntWithBigInteger() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(true); [EOL] when(jp.getBigIntegerValue()).thenReturn(new BigInteger("12345678901234567890")); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertTrue(result instanceof BigInteger); [EOL] assertEquals(new BigInteger("12345678901234567890"), result); [EOL] }
public void testDeserializeValueNumberIntWithoutBigInteger() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(false); [EOL] when(jp.getNumberValue()).thenReturn(123); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertEquals(123, result); [EOL] }
public void testDeserializeValueNumberFloatWithBigDecimal() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(true); [EOL] when(jp.getDecimalValue()).thenReturn(new BigDecimal("123.45")); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertTrue(result instanceof BigDecimal); [EOL] assertEquals(new BigDecimal("123.45"), result); [EOL] }
public void testDeserializeValueNumberFloatWithoutBigDecimal() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(false); [EOL] when(jp.getDoubleValue()).thenReturn(123.45); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertEquals(Double.valueOf(123.45), result); [EOL] }
public void testDeserializeValueStringWithDotAndBigDecimal() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("123.45"); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(true); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertTrue(result instanceof BigDecimal); [EOL] assertEquals(new BigDecimal("123.45"), result); [EOL] }
public void testDeserializeValueStringWithDotWithoutBigDecimal() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("123.45"); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)).thenReturn(false); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertEquals(new Double("123.45"), result); [EOL] }
public void testDeserializeValueStringWithoutDotWithBigInteger() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("12345678901234567890"); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(true); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertTrue(result instanceof BigInteger); [EOL] assertEquals(new BigInteger("12345678901234567890"), result); [EOL] }
public void testDeserializeValueStringWithoutDotWithoutBigIntegerWithinIntRange() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("123"); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(false); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertEquals(Integer.valueOf(123), result); [EOL] }
public void testDeserializeValueStringWithoutDotWithoutBigIntegerOutsideIntRange() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn(Long.toString(Long.MAX_VALUE)); [EOL] when(ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)).thenReturn(false); [EOL] Number result = deserialize(jp, ctxt); [EOL] assertEquals(Long.valueOf(Long.MAX_VALUE), result); [EOL] }
public void testDeserializeInvalidToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.NOT_AVAILABLE); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testDeserializeWithType_ValueNumberInt() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] ObjectDeserializer deserializer = new ObjectDeserializer(); [EOL] Object result = deserializer.deserializeWithType(jp, ctxt, typeDeserializer); [EOL] verify(jp).getCurrentToken(); [EOL] verify(deserializer).deserialize(jp, ctxt); [EOL] }
public void testDeserializeWithType_ValueNumberFloat() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] ObjectDeserializer deserializer = new ObjectDeserializer(); [EOL] Object result = deserializer.deserializeWithType(jp, ctxt, typeDeserializer); [EOL] verify(jp).getCurrentToken(); [EOL] verify(deserializer).deserialize(jp, ctxt); [EOL] }
public void testDeserializeWithType_ValueString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] ObjectDeserializer deserializer = new ObjectDeserializer(); [EOL] Object result = deserializer.deserializeWithType(jp, ctxt, typeDeserializer); [EOL] verify(jp).getCurrentToken(); [EOL] verify(deserializer).deserialize(jp, ctxt); [EOL] }
public void testDeserializeWithType_OtherToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_FALSE); // Assuming VALUE_FALSE is not handled by the switch [EOL] ObjectDeserializer deserializer = new ObjectDeserializer(); [EOL] Object result = deserializer.deserializeWithType(jp, ctxt, typeDeserializer); [EOL] verify(jp).getCurrentToken(); [EOL] verify(typeDeserializer).deserializeTypedFromScalar(jp, ctxt); [EOL] }
public void testBigIntegerDeserializer() { [EOL] BigIntegerDeserializer deserializer = new BigIntegerDeserializer(); [EOL] assertNotNull(deserializer); [EOL] assertEquals(BigInteger.class, deserializer.handledType()); [EOL] }
public void testDeserializeWithNumberIntTokenAndIntType() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.INT); [EOL] when(jp.getLongValue()).thenReturn(123L); [EOL] BigInteger result = deserialize(jp, ctxt); [EOL] assertEquals(BigInteger.valueOf(123L), result); [EOL] }
public void testDeserializeWithNumberIntTokenAndLongType() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_INT); [EOL] when(jp.getNumberType()).thenReturn(JsonParser.NumberType.LONG); [EOL] when(jp.getLongValue()).thenReturn(1234567890123456789L); [EOL] BigInteger result = deserialize(jp, ctxt); [EOL] assertEquals(BigInteger.valueOf(1234567890123456789L), result); [EOL] }
public void testDeserializeWithNumberFloatToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BigDecimal decimalValue = new BigDecimal("123.456"); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_NUMBER_FLOAT); [EOL] when(jp.getDecimalValue()).thenReturn(decimalValue); [EOL] BigInteger result = deserialize(jp, ctxt); [EOL] assertEquals(decimalValue.toBigInteger(), result); [EOL] }
public void testDeserializeWithNonStringValue() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testDeserializeWithEmptyString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("   "); [EOL] BigInteger result = deserialize(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithValidString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("123456789"); [EOL] BigInteger result = deserialize(jp, ctxt); [EOL] assertEquals(new BigInteger("123456789"), result); [EOL] }
public void testDeserializeWithInvalidString() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("not a number"); [EOL] try { [EOL] deserialize(jp, ctxt); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
protected StdKeyDeserializer(Class<?> cls) { [EOL] _keyClass = cls; [EOL] }
public void testStringKDConstructor() { [EOL] Class<?> nominalType = String.class; // Use String class as an example [EOL] StringKD instance = new StringKD(nominalType); [EOL] assertNotNull(instance); [EOL] }
public void testForTypeWithStringClass() { [EOL] StringKD result = StringKD.forType(String.class); [EOL] assertSame(StringKD.sString, result); [EOL] }
public void testForTypeWithObjectClass() { [EOL] StringKD result = StringKD.forType(Object.class); [EOL] assertSame(StringKD.sObject, result); [EOL] }
public void testForTypeWithCustomClass() { [EOL] class CustomClass {} [EOL] StringKD result = StringKD.forType(CustomClass.class); [EOL] assertNotNull(result); [EOL] assertNotSame(StringKD.sString, result); [EOL] assertNotSame(StringKD.sObject, result); [EOL] assertEquals(CustomClass.class, result.getNominalType()); [EOL] }
public void testGetCurrentNameWhenCurrentNameIsNull() { [EOL] JsonParser jp = new JsonParserSubClass(null); [EOL] assertNull(jp.getCurrentName()); [EOL] } [EOL] public void testGetCurrentNameWhenCurrentNameIsNotNull() { [EOL] JsonParser jp = new JsonParserSubClass("testName"); [EOL] assertEquals("testName", jp.getCurrentName()); [EOL] }
class JsonParserSubClass extends JsonParser { [EOL] private String _currentName; [EOL] public JsonParserSubClass(String currentName) { [EOL] _currentName = currentName; [EOL] } [EOL] @Override [EOL] public final String getCurrentName() { [EOL] return _currentName; [EOL] } [EOL] }
public void testFindKeyDeserializerWithStringClass() { [EOL] JavaType type = SimpleType.constructUnsafe(String.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.StringKD); [EOL] }
public void testFindKeyDeserializerWithObjectClass() { [EOL] JavaType type = SimpleType.constructUnsafe(Object.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.StringKD); [EOL] }
public void testFindKeyDeserializerWithUUIDClass() { [EOL] JavaType type = SimpleType.constructUnsafe(UUID.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.UuidKD); [EOL] }
public void testFindKeyDeserializerWithPrimitiveClass() { [EOL] JavaType type = SimpleType.constructUnsafe(int.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.IntKD); [EOL] }
public void testFindKeyDeserializerWithIntegerClass() { [EOL] JavaType type = SimpleType.constructUnsafe(Integer.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.IntKD); [EOL] }
public void testFindKeyDeserializerWithLongClass() { [EOL] JavaType type = SimpleType.constructUnsafe(Long.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.LongKD); [EOL] }
public void testFindKeyDeserializerWithDateClass() { [EOL] JavaType type = SimpleType.constructUnsafe(Date.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.DateKD); [EOL] }
public void testFindKeyDeserializerWithCalendarClass() { [EOL] JavaType type = SimpleType.constructUnsafe(Calendar.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.CalendarKD); [EOL] }
public void testFindKeyDeserializerWithBooleanClass() { [EOL] JavaType type = SimpleType.constructUnsafe(Boolean.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.BoolKD); [EOL] }
public void testFindKeyDeserializerWithByteClass() { [EOL] JavaType type = SimpleType.constructUnsafe(Byte.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.ByteKD); [EOL] }
public void testFindKeyDeserializerWithCharacterClass() { [EOL] JavaType type = SimpleType.constructUnsafe(Character.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.CharKD); [EOL] }
public void testFindKeyDeserializerWithShortClass() { [EOL] JavaType type = SimpleType.constructUnsafe(Short.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.ShortKD); [EOL] }
public void testFindKeyDeserializerWithFloatClass() { [EOL] JavaType type = SimpleType.constructUnsafe(Float.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.FloatKD); [EOL] }
public void testFindKeyDeserializerWithDoubleClass() { [EOL] JavaType type = SimpleType.constructUnsafe(Double.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.DoubleKD); [EOL] }
public void testFindKeyDeserializerWithLocaleClass() { [EOL] JavaType type = SimpleType.constructUnsafe(Locale.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertTrue(deserializer instanceof StdKeyDeserializer.LocaleKD); [EOL] }
public void testFindKeyDeserializerWithUnmappedClass() { [EOL] JavaType type = SimpleType.constructUnsafe(SomeUnmappedClass.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = null; [EOL] KeyDeserializer deserializer = findKeyDeserializer(type, config, beanDesc); [EOL] assertNull(deserializer); [EOL] }
public void testHasSingleElementWithEmptyCollection() { [EOL] Collection<?> emptyCollection = Collections.emptyList(); [EOL] boolean result = hasSingleElement(emptyCollection); [EOL] assertFalse(result); [EOL] }
public void testHasSingleElementWithSingleElementCollection() { [EOL] Collection<?> singleElementCollection = Collections.singleton("element"); [EOL] boolean result = hasSingleElement(singleElementCollection); [EOL] assertTrue(result); [EOL] }
public void testHasSingleElementWithMultipleElementsCollection() { [EOL] Collection<?> multipleElementsCollection = Arrays.asList("element1", "element2"); [EOL] boolean result = hasSingleElement(multipleElementsCollection); [EOL] assertFalse(result); [EOL] }
public void testSerializeContentsWithElementSerializer() throws IOException { [EOL] Collection<?> value = ...; // Initialize with a collection [EOL] JsonGenerator jgen = ...; // Initialize a JsonGenerator [EOL] SerializerProvider provider = ...; // Initialize a SerializerProvider [EOL] JsonSerializer<Object> elementSerializer = ...; // Initialize an element serializer [EOL] _elementSerializer = elementSerializer; [EOL] serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsEmptyCollection() throws IOException { [EOL] Collection<?> value = Collections.emptySet(); // An empty collection [EOL] JsonGenerator jgen = ...; // Initialize a JsonGenerator [EOL] SerializerProvider provider = ...; // Initialize a SerializerProvider [EOL] serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsWithNonNullElements() throws IOException { [EOL] Collection<?> value = ...; // Initialize with a collection with non-null elements [EOL] JsonGenerator jgen = ...; // Initialize a JsonGenerator [EOL] SerializerProvider provider = ...; // Initialize a SerializerProvider [EOL] _dynamicSerializers = ...; // Initialize dynamic serializers [EOL] _valueTypeSerializer = null; // Assuming no type serializer is needed [EOL] serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsWithTypeSerializer() throws IOException { [EOL] Collection<?> value = ...; // Initialize with a collection with non-null elements [EOL] JsonGenerator jgen = ...; // Initialize a JsonGenerator [EOL] SerializerProvider provider = ...; // Initialize a SerializerProvider [EOL] TypeSerializer typeSer = ...; // Initialize a TypeSerializer [EOL] _dynamicSerializers = ...; // Initialize dynamic serializers [EOL] _valueTypeSerializer = typeSer; [EOL] serializeContents(value, jgen, provider); [EOL] }
public void testSerializeContentsWithException() throws IOException { [EOL] Collection<?> value = ...; // Initialize with a collection that will cause an exception [EOL] JsonGenerator jgen = ...; // Initialize a JsonGenerator [EOL] SerializerProvider provider = ...; // Initialize a SerializerProvider [EOL] _dynamicSerializers = ...; // Initialize dynamic serializers [EOL] _valueTypeSerializer = null; // Assuming no type serializer is needed [EOL] try { [EOL] serializeContents(value, jgen, provider); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (Exception e) { [EOL] } [EOL] }
public void testSerializeWithSingleElementUnwrapped() throws IOException { [EOL] List<String> value = Collections.singletonList("singleElement"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)).thenReturn(true); [EOL] CustomSerializer instance = new CustomSerializer(); [EOL] instance.serialize(value, jgen, provider); [EOL] verify(jgen, never()).writeStartArray(); [EOL] verify(jgen, never()).writeEndArray(); [EOL] verify(provider).isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL] }
public void testSerializeWithMultipleElements() throws IOException { [EOL] List<String> value = Arrays.asList("element1", "element2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)).thenReturn(false); [EOL] CustomSerializer instance = new CustomSerializer(); [EOL] instance.serialize(value, jgen, provider); [EOL] verify(jgen).writeStartArray(); [EOL] verify(jgen).writeEndArray(); [EOL] verify(provider, never()).isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL] }
public void testSerializeWithCustomSerializer() throws IOException { [EOL] List<String> value = Arrays.asList("element1", "element2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] CustomSerializer instance = new CustomSerializer(new CustomItemSerializer()); [EOL] instance.serialize(value, jgen, provider); [EOL] verify(jgen).writeStartArray(); [EOL] verify(jgen).writeEndArray(); [EOL] verify(instance._serializer, times(value.size())).serialize(any(), eq(jgen), eq(provider)); [EOL] }
public void testSerializeWithNoCustomSerializer() throws IOException { [EOL] List<String> value = Arrays.asList("element1", "element2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] CustomSerializer instance = new CustomSerializer(); [EOL] instance.serialize(value, jgen, provider); [EOL] verify(jgen).writeStartArray(); [EOL] verify(jgen).writeEndArray(); [EOL] verify(jgen, times(value.size())).writeString(anyString()); [EOL] }
public void testSerializeUnwrappedWithNullSerializer() throws IOException, JsonGenerationException { [EOL] List<String> value = Arrays.asList("value1", "value2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] _serializeUnwrapped(value, jgen, provider); [EOL] verify(jgen, times(2)).writeString(anyString()); [EOL] }
public void testSerializeUnwrappedWithNonNullSerializer() throws IOException, JsonGenerationException { [EOL] List<String> value = Arrays.asList("value1", "value2"); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] _serializer = mock(JsonSerializer.class); [EOL] _serializeUnwrapped(value, jgen, provider); [EOL] verify(_serializer, times(2)).serialize(any(), eq(jgen), eq(provider)); [EOL] }
public void testAtomicBooleanSerializerConstructor() { [EOL] AtomicBooleanSerializer serializer = new AtomicBooleanSerializer(); [EOL] assertNotNull(serializer); [EOL] assertEquals(AtomicBoolean.class, serializer.handledType()); [EOL] assertFalse(serializer.usesObjectId()); [EOL] }
public void testSerializeAtomicBooleanTrue() throws IOException { [EOL] AtomicBoolean trueValue = new AtomicBoolean(true); [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] new AtomicBooleanSerializer().serialize(trueValue, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeBoolean(true); [EOL] }
public void testSerializeAtomicBooleanFalse() throws IOException { [EOL] AtomicBoolean falseValue = new AtomicBoolean(false); [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] new AtomicBooleanSerializer().serialize(falseValue, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeBoolean(false); [EOL] }
public void testAtomicIntegerSerializerConstructor() { [EOL] AtomicIntegerSerializer serializer = new AtomicIntegerSerializer(); [EOL] assertNotNull(serializer); [EOL] assertEquals(AtomicInteger.class, serializer.handledType()); [EOL] assertFalse(serializer.usesObjectId()); [EOL] }
public void testSerializeAtomicInteger() throws IOException { [EOL] AtomicInteger value = new AtomicInteger(123); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] new AtomicIntegerSerializer().serialize(value, jgen, provider); [EOL] verify(jgen).writeNumber(123); [EOL] }
public void testAsToken() { [EOL] JsonNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] assertEquals(JsonToken.START_OBJECT, node.asToken()); [EOL] }
public void testElements_EmptyChildren() { [EOL] JsonNodeFactory nodeFactory = JsonNodeFactory.instance; [EOL] ArrayNode arrayNode = new ArrayNode(nodeFactory); [EOL] Iterator<JsonNode> elements = arrayNode.elements(); [EOL] assertFalse(elements.hasNext()); [EOL] }
public void testElements_NonEmptyChildren() { [EOL] JsonNodeFactory nodeFactory = JsonNodeFactory.instance; [EOL] ArrayNode arrayNode = new ArrayNode(nodeFactory); [EOL] arrayNode.add(nodeFactory.numberNode(1)); [EOL] arrayNode.add(nodeFactory.textNode("test")); [EOL] Iterator<JsonNode> elements = arrayNode.elements(); [EOL] assertTrue(elements.hasNext()); [EOL] assertEquals(1, elements.next().intValue()); [EOL] assertEquals("test", elements.next().textValue()); [EOL] assertFalse(elements.hasNext()); [EOL] }
public void testGetWithValidIndex() { [EOL] JsonNode node = createTestNode(); // You need to implement createTestNode to create a JsonNode with some elements [EOL] JsonNode result = node.get(0); [EOL] assertNull(result); [EOL] } [EOL] public void testGetWithInvalidIndex() { [EOL] JsonNode node = createTestNode(); // You need to implement createTestNode to create a JsonNode with no elements [EOL] JsonNode result = node.get(-1); [EOL] assertNull(result); [EOL] } [EOL] public void testGetWithIndexOutOfBounds() { [EOL] JsonNode node = createTestNode(); // You need to implement createTestNode to create a JsonNode with some elements [EOL] JsonNode result = node.get(node.size()); // Assuming size() gives the number of elements [EOL] assertNull(result); [EOL] }
public void testFieldNames_NonEmptyChildren() { [EOL] JsonNodeFactory factory = JsonNodeFactory.instance; [EOL] ObjectNode objectNode = factory.objectNode(); [EOL] objectNode.put("field1", 1); [EOL] objectNode.put("field2", 2); [EOL] Iterator<String> fieldNames = objectNode.fieldNames(); [EOL] assertTrue(fieldNames.hasNext()); [EOL] assertEquals("field1", fieldNames.next()); [EOL] assertEquals("field2", fieldNames.next()); [EOL] assertFalse(fieldNames.hasNext()); [EOL] }
public void testFieldNames_EmptyChildren() { [EOL] JsonNodeFactory factory = JsonNodeFactory.instance; [EOL] ObjectNode objectNode = factory.objectNode(); [EOL] Iterator<String> fieldNames = objectNode.fieldNames(); [EOL] assertFalse(fieldNames.hasNext()); [EOL] }
public void testPathWithExistingField() { [EOL] ObjectNode objectNode = new ObjectNode(JsonNodeFactory.instance); [EOL] TextNode expectedNode = new TextNode("value"); [EOL] objectNode.set("field", expectedNode); [EOL] JsonNode resultNode = objectNode.path("field"); [EOL] assertSame("The method should return the existing node for the given field name.", expectedNode, resultNode); [EOL] }
public void testPathWithNonExistingField() { [EOL] ObjectNode objectNode = new ObjectNode(JsonNodeFactory.instance); [EOL] JsonNode resultNode = objectNode.path("nonExistingField"); [EOL] assertTrue("The method should return a MissingNode instance for a non-existing field name.", resultNode instanceof MissingNode); [EOL] }
public void testFieldsWhenChildrenAreEmpty() { [EOL] ObjectNode objectNode = new ObjectNode(JsonNodeFactory.instance); [EOL] Iterator<Map.Entry<String, JsonNode>> fields = objectNode.fields(); [EOL] assertFalse(fields.hasNext()); [EOL] }
public void testFieldsWhenChildrenAreNotEmpty() { [EOL] ObjectNode objectNode = new ObjectNode(JsonNodeFactory.instance); [EOL] objectNode.set("key", TextNode.valueOf("value")); [EOL] Iterator<Map.Entry<String, JsonNode>> fields = objectNode.fields(); [EOL] assertTrue(fields.hasNext()); [EOL] Map.Entry<String, JsonNode> entry = fields.next(); [EOL] assertEquals("key", entry.getKey()); [EOL] assertEquals("value", entry.getValue().asText()); [EOL] assertFalse(fields.hasNext()); [EOL] }
public void testWithExistingObjectNode() { [EOL] ObjectNode parent = new ObjectNode(JsonNodeFactory.instance); [EOL] String propertyName = "existing"; [EOL] ObjectNode child = new ObjectNode(JsonNodeFactory.instance); [EOL] parent.set(propertyName, child); [EOL] ObjectNode result = parent.with(propertyName); [EOL] assertSame("The method should return the existing ObjectNode", child, result); [EOL] }
public void testWithNonObjectNode() { [EOL] ObjectNode parent = new ObjectNode(JsonNodeFactory.instance); [EOL] String propertyName = "nonObject"; [EOL] TextNode nonObjectChild = TextNode.valueOf("text"); [EOL] parent.set(propertyName, nonObjectChild); [EOL] try { [EOL] parent.with(propertyName); [EOL] fail("The method should throw an UnsupportedOperationException if the property is not an ObjectNode"); [EOL] } catch (UnsupportedOperationException e) { [EOL] assertEquals("Property 'nonObject' has value that is not of type ObjectNode (but " + nonObjectChild.getClass().getName() + ")", e.getMessage()); [EOL] } [EOL] }
public void testWithNewProperty() { [EOL] ObjectNode parent = new ObjectNode(JsonNodeFactory.instance); [EOL] String propertyName = "newProperty"; [EOL] ObjectNode result = parent.with(propertyName); [EOL] assertNotNull("The method should create a new ObjectNode if property does not exist", result); [EOL] assertTrue("The new property should be an ObjectNode", result instanceof ObjectNode); [EOL] assertSame("The new ObjectNode should be associated with the property", result, parent.get(propertyName)); [EOL] }
public void testWithArrayWhenPropertyExistsAndIsArrayNode() { [EOL] ObjectNode objectNode = JsonNodeFactory.instance.objectNode(); [EOL] String propertyName = "arrayProperty"; [EOL] ArrayNode arrayNode = objectNode.arrayNode(); [EOL] objectNode.set(propertyName, arrayNode); [EOL] ArrayNode result = objectNode.withArray(propertyName); [EOL] assertSame("The method should return the existing ArrayNode", arrayNode, result); [EOL] }
public void testWithArrayWhenPropertyExistsAndIsNotArrayNode() { [EOL] ObjectNode objectNode = JsonNodeFactory.instance.objectNode(); [EOL] String propertyName = "nonArrayProperty"; [EOL] objectNode.set(propertyName, JsonNodeFactory.instance.textNode("Not an array")); [EOL] try { [EOL] objectNode.withArray(propertyName); [EOL] fail("The method should throw an UnsupportedOperationException if property is not an ArrayNode"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public void testWithArrayWhenPropertyDoesNotExist() { [EOL] ObjectNode objectNode = JsonNodeFactory.instance.objectNode(); [EOL] String propertyName = "newArrayProperty"; [EOL] ArrayNode result = objectNode.withArray(propertyName); [EOL] assertNotNull("The method should create a new ArrayNode if property does not exist", result); [EOL] assertTrue("The new node should be an ArrayNode", result instanceof ArrayNode); [EOL] assertSame("The new ArrayNode should be added to the children", result, objectNode.get(propertyName)); [EOL] }
public void testFindValueWhenKeyExistsAtFirstLevel() { [EOL] ObjectNode root = JsonNodeFactory.instance.objectNode(); [EOL] String fieldName = "key1"; [EOL] JsonNode expectedValue = JsonNodeFactory.instance.textNode("value1"); [EOL] root.set(fieldName, expectedValue); [EOL] root.set("key2", JsonNodeFactory.instance.textNode("value2")); [EOL] JsonNode result = root.findValue(fieldName); [EOL] assertEquals(expectedValue, result); [EOL] }
public void testFindValueWhenKeyExistsAtNestedLevel() { [EOL] ObjectNode root = JsonNodeFactory.instance.objectNode(); [EOL] ObjectNode child = JsonNodeFactory.instance.objectNode(); [EOL] String fieldName = "nestedKey"; [EOL] JsonNode expectedValue = JsonNodeFactory.instance.textNode("nestedValue"); [EOL] child.set(fieldName, expectedValue); [EOL] root.set("child", child); [EOL] JsonNode result = root.findValue(fieldName); [EOL] assertEquals(expectedValue, result); [EOL] }
public void testFindValueWhenKeyDoesNotExist() { [EOL] ObjectNode root = JsonNodeFactory.instance.objectNode(); [EOL] root.set("key1", JsonNodeFactory.instance.textNode("value1")); [EOL] root.set("key2", JsonNodeFactory.instance.textNode("value2")); [EOL] JsonNode result = root.findValue("nonExistingKey"); [EOL] assertNull(result); [EOL] }
public void testFindParentWhenFieldNameExistsAsDirectChild() { [EOL] ObjectNode root = JsonNodeFactory.instance.objectNode(); [EOL] root.put("child", "value"); [EOL] ObjectNode result = root.findParent("child"); [EOL] assertNotNull(result); [EOL] assertEquals(root, result); [EOL] }
public void testFindParentWhenFieldNameExistsInNestedChild() { [EOL] ObjectNode root = JsonNodeFactory.instance.objectNode(); [EOL] ObjectNode child = JsonNodeFactory.instance.objectNode(); [EOL] child.put("nestedChild", "value"); [EOL] root.set("child", child); [EOL] ObjectNode result = root.findParent("nestedChild"); [EOL] assertNotNull(result); [EOL] assertEquals(child, result); [EOL] }
public void testFindParentWhenFieldNameDoesNotExist() { [EOL] ObjectNode root = JsonNodeFactory.instance.objectNode(); [EOL] root.put("child", "value"); [EOL] ObjectNode result = root.findParent("nonExistingChild"); [EOL] assertNull(result); [EOL] }
public void testWithoutWithEmptyCollection() { [EOL] ObjectNode objectNode = new ObjectNode(JsonNodeFactory.instance); [EOL] Collection<String> fieldNames = Collections.emptyList(); [EOL] ObjectNode result = objectNode.without(fieldNames); [EOL] assertTrue(result.size() == 0); [EOL] }
public void testWithoutWithNonEmptyCollection() { [EOL] ObjectNode objectNode = new ObjectNode(JsonNodeFactory.instance); [EOL] objectNode.put("field1", 1); [EOL] objectNode.put("field2", 2); [EOL] Collection<String> fieldNames = Arrays.asList("field1"); [EOL] ObjectNode result = objectNode.without(fieldNames); [EOL] assertFalse(result.has("field1")); [EOL] assertTrue(result.has("field2")); [EOL] }
public void testRemoveExistingField() { [EOL] ObjectNode node = JsonNodeFactory.instance.objectNode(); [EOL] String fieldName = "field"; [EOL] node.put(fieldName, 1); [EOL] JsonNode removed = node.remove(fieldName); [EOL] assertNull(node.get(fieldName)); [EOL] assertNotNull(removed); [EOL] }
public void testRemoveNonExistingField() { [EOL] ObjectNode node = JsonNodeFactory.instance.objectNode(); [EOL] String fieldName = "nonExistingField"; [EOL] JsonNode removed = node.remove(fieldName); [EOL] assertNull(node.get(fieldName)); [EOL] assertNull(removed); [EOL] }
public void testRemoveAll_EmptyObjectNode() { [EOL] ObjectNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] ObjectNode result = node.removeAll(); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testRemoveAll_NonEmptyObjectNode() { [EOL] ObjectNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] node.put("key1", "value1"); [EOL] node.put("key2", "value2"); [EOL] assertFalse(node.isEmpty()); [EOL] ObjectNode result = node.removeAll(); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testPutWithFieldNameAndInt() { [EOL] ObjectNode node = JsonNodeFactory.instance.objectNode(); [EOL] int value = 42; [EOL] String fieldName = "age"; [EOL] ObjectNode result = node.put(fieldName, value); [EOL] assertSame("The method should return the same ObjectNode instance", node, result); [EOL] assertTrue("The new field should exist in the ObjectNode", node.has(fieldName)); [EOL] assertEquals("The value of the field should match the input", value, node.get(fieldName).intValue()); [EOL] }
public void testPutWithBoolean() { [EOL] ObjectNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] String fieldName = "field"; [EOL] boolean value = true; [EOL] ObjectNode result = node.put(fieldName, value); [EOL] JsonNode retrieved = node.get(fieldName); [EOL] assertNotNull(retrieved); [EOL] assertTrue(retrieved.isBoolean()); [EOL] assertEquals(value, retrieved.booleanValue()); [EOL] assertSame(result, node); [EOL] }
public void testPutWithBooleanFalse() { [EOL] ObjectNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] String fieldName = "field"; [EOL] boolean value = false; [EOL] ObjectNode result = node.put(fieldName, value); [EOL] JsonNode retrieved = node.get(fieldName); [EOL] assertNotNull(retrieved); [EOL] assertTrue(retrieved.isBoolean()); [EOL] assertEquals(value, retrieved.booleanValue()); [EOL] assertSame(result, node); [EOL] }
public void testEqualsWithSameObject() { [EOL] ObjectNode objectNode = new ObjectNode(JsonNodeFactory.instance); [EOL] assertTrue(objectNode.equals(objectNode)); [EOL] }
public void testEqualsWithNull() { [EOL] ObjectNode objectNode = new ObjectNode(JsonNodeFactory.instance); [EOL] assertFalse(objectNode.equals(null)); [EOL] }
public void testEqualsWithDifferentClass() { [EOL] ObjectNode objectNode = new ObjectNode(JsonNodeFactory.instance); [EOL] assertFalse(objectNode.equals(new String("Not an ObjectNode"))); [EOL] }
public void testEqualsWithEqualObjectNodes() { [EOL] ObjectNode objectNode1 = new ObjectNode(JsonNodeFactory.instance); [EOL] ObjectNode objectNode2 = new ObjectNode(JsonNodeFactory.instance); [EOL] assertTrue(objectNode1.equals(objectNode2)); [EOL] }
public void testEqualsWithDifferentObjectNodes() { [EOL] ObjectNode objectNode1 = new ObjectNode(JsonNodeFactory.instance); [EOL] ObjectNode objectNode2 = new ObjectNode(JsonNodeFactory.instance); [EOL] objectNode2.set("field", new TextNode("value")); [EOL] assertFalse(objectNode1.equals(objectNode2)); [EOL] }
public void testHashCode() { [EOL] JsonNodeFactory factory = JsonNodeFactory.instance; [EOL] ArrayNode arrayNode1 = factory.arrayNode(); [EOL] ArrayNode arrayNode2 = factory.arrayNode(); [EOL] arrayNode1.add(1); [EOL] arrayNode2.add(1); [EOL] int hashCode1 = arrayNode1.hashCode(); [EOL] int hashCode2 = arrayNode2.hashCode(); [EOL] assertEquals(hashCode1, hashCode2); [EOL] }
public void testHashCodeWithDifferentChildren() { [EOL] JsonNodeFactory factory = JsonNodeFactory.instance; [EOL] ArrayNode arrayNode1 = factory.arrayNode(); [EOL] ArrayNode arrayNode2 = factory.arrayNode(); [EOL] arrayNode1.add(1); [EOL] arrayNode2.add(2); [EOL] int hashCode1 = arrayNode1.hashCode(); [EOL] int hashCode2 = arrayNode2.hashCode(); [EOL] assertNotEquals(hashCode1, hashCode2); [EOL] }
public void testToStringEmpty() { [EOL] ObjectNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] String result = node.toString(); [EOL] assertEquals("{}", result); [EOL] }
public void testToStringSingleElement() { [EOL] ObjectNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] node.put("key", "value"); [EOL] String result = node.toString(); [EOL] assertEquals("{\"key\":\"value\"}", result); [EOL] }
public void testToStringMultipleElements() { [EOL] ObjectNode node = new ObjectNode(JsonNodeFactory.instance); [EOL] node.put("key1", "value1"); [EOL] node.put("key2", "value2"); [EOL] String result = node.toString(); [EOL] assertTrue(result.startsWith("{")); [EOL] assertTrue(result.endsWith("}")); [EOL] assertTrue(result.contains("\"key1\":\"value1\"")); [EOL] assertTrue(result.contains("\"key2\":\"value2\"")); [EOL] assertTrue(result.contains(",")); [EOL] }
public void testOkNameForRegularGetterWithGetCallbacks() { [EOL] AnnotatedMethod am = createAnnotatedMethodWithCglibCallbacks(); [EOL] String name = "getCallbacks"; [EOL] String result = JacksonDatabindUtils.okNameForRegularGetter(am, name); [EOL] assertNull(result); [EOL] } [EOL] public void testOkNameForRegularGetterWithGetMetaClass() { [EOL] AnnotatedMethod am = createAnnotatedMethodWithGroovyMetaClass(); [EOL] String name = "getMetaClass"; [EOL] String result = JacksonDatabindUtils.okNameForRegularGetter(am, name); [EOL] assertNull(result); [EOL] } [EOL] public void testOkNameForRegularGetterWithRegularGetMethod() { [EOL] AnnotatedMethod am = createRegularAnnotatedMethod(); [EOL] String name = "getRegularProperty"; [EOL] String result = JacksonDatabindUtils.okNameForRegularGetter(am, name); [EOL] assertEquals("regularProperty", result); [EOL] } [EOL] public void testOkNameForRegularGetterWithNonGetMethod() { [EOL] AnnotatedMethod am = createRegularAnnotatedMethod(); [EOL] String name = "nonGetMethod"; [EOL] String result = JacksonDatabindUtils.okNameForRegularGetter(am, name); [EOL] assertNull(result); [EOL] }
private AnnotatedMethod createAnnotatedMethodWithCglibCallbacks() { [EOL] } [EOL] private AnnotatedMethod createAnnotatedMethodWithGroovyMetaClass() { [EOL] } [EOL] private AnnotatedMethod createRegularAnnotatedMethod() { [EOL] }
public void testOkNameForIsGetterWithIsPrefixAndBooleanReturnType() { [EOL] AnnotatedMethod am = createAnnotatedMethod("isSomething", Boolean.class); [EOL] String name = "isSomething"; [EOL] String result = okNameForIsGetter(am, name); [EOL] assertNotNull(result); [EOL] assertEquals("Something", result); [EOL] } [EOL] public void testOkNameForIsGetterWithIsPrefixAndNonBooleanReturnType() { [EOL] AnnotatedMethod am = createAnnotatedMethod("isSomething", String.class); [EOL] String name = "isSomething"; [EOL] String result = okNameForIsGetter(am, name); [EOL] assertNull(result); [EOL] } [EOL] public void testOkNameForIsGetterWithoutIsPrefix() { [EOL] AnnotatedMethod am = createAnnotatedMethod("getSomething", Boolean.class); [EOL] String name = "getSomething"; [EOL] String result = okNameForIsGetter(am, name); [EOL] assertNull(result); [EOL] }
private AnnotatedMethod createAnnotatedMethod(String methodName, Class<?> returnType) { [EOL] return new AnnotatedMethod(null, null, null, null); [EOL] }
public void testMappingJsonFactoryDefaultConstructor() { [EOL] MappingJsonFactory factory = new MappingJsonFactory(); [EOL] assertNotNull(factory.getCodec()); [EOL] }
public void testMappingJsonFactoryWithNonNullMapper() { [EOL] ObjectMapper nonNullMapper = new ObjectMapper(); [EOL] MappingJsonFactory factory = new MappingJsonFactory(nonNullMapper); [EOL] assertSame("Expected the provided ObjectMapper to be set.", nonNullMapper, factory.getCodec()); [EOL] }
public void testMappingJsonFactoryWithNullMapper() { [EOL] MappingJsonFactory factory = new MappingJsonFactory(null); [EOL] assertNotNull("Expected a new ObjectMapper to be created.", factory.getCodec()); [EOL] assertTrue("Expected the codec to be an instance of ObjectMapper.", factory.getCodec() instanceof ObjectMapper); [EOL] }
public void testGetCodec_WhenCodecIsSet_ShouldReturnObjectMapper() { [EOL] JsonParser jp = new JsonParser() {/* implement necessary abstract methods */}; [EOL] ObjectMapper expectedCodec = new ObjectMapper(); [EOL] jp.setCodec(expectedCodec); [EOL] ObjectMapper actualCodec = jp.getCodec(); [EOL] assertSame("Codec should be the same as the one set", expectedCodec, actualCodec); [EOL] }
public void testGetCodec_WhenCodecIsNotSet_ShouldReturnNull() { [EOL] JsonParser jp = new JsonParser() {/* implement necessary abstract methods */}; [EOL] ObjectMapper actualCodec = jp.getCodec(); [EOL] assertNull("Codec should be null when not set", actualCodec); [EOL] }
public void testAsToken() { [EOL] JsonNumber jsonNumber = new JsonNumber(); [EOL] JsonToken result = jsonNumber.asToken(); [EOL] assertEquals(JsonToken.VALUE_NUMBER_INT, result); [EOL] }
public void testAsTextWithPositiveValue() { [EOL] DoubleNode node = new DoubleNode(10.5); [EOL] String result = node.asText(); [EOL] assertEquals("10.5", result); [EOL] }
public void testAsTextWithNegativeValue() { [EOL] DoubleNode node = new DoubleNode(-10.5); [EOL] String result = node.asText(); [EOL] assertEquals("-10.5", result); [EOL] }
public void testAsTextWithZeroValue() { [EOL] DoubleNode node = new DoubleNode(0.0); [EOL] String result = node.asText(); [EOL] assertEquals("0.0", result); [EOL] }
public void testSerializeWithValidJsonGenerator() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] MyValueSerializer serializer = new MyValueSerializer(); [EOL] serializer.serialize(mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeNumber(anyInt()); [EOL] }
public void testFloatNodeConstructor() { [EOL] float testValue = 5.5f; [EOL] FloatNode node = new FloatNode(testValue); [EOL] assertEquals(testValue, node.floatValue(), 0.0); [EOL] }
public void testValueOf_PositiveFloat() { [EOL] float testValue = 1.23f; [EOL] FloatNode result = FloatNode.valueOf(testValue); [EOL] assertNotNull(result); [EOL] assertEquals(testValue, result.floatValue(), 0.0); [EOL] }
public void testValueOf_NegativeFloat() { [EOL] float testValue = -1.23f; [EOL] FloatNode result = FloatNode.valueOf(testValue); [EOL] assertNotNull(result); [EOL] assertEquals(testValue, result.floatValue(), 0.0); [EOL] }
public void testValueOf_Zero() { [EOL] float testValue = 0.0f; [EOL] FloatNode result = FloatNode.valueOf(testValue); [EOL] assertNotNull(result); [EOL] assertEquals(testValue, result.floatValue(), 0.0); [EOL] }
public void testAsToken() { [EOL] YourClassWithAsTokenMethod instance = new YourClassWithAsTokenMethod(); [EOL] JsonToken result = instance.asToken(); [EOL] assertEquals(JsonToken.VALUE_NUMBER_FLOAT, result); [EOL] }
public void testNumberType() { [EOL] YourClass instance = new YourClass(); [EOL] JsonParser.NumberType expected = JsonParser.NumberType.FLOAT; [EOL] JsonParser.NumberType actual = instance.numberType(); [EOL] assertEquals(expected, actual); [EOL] }
public void testCanConvertToIntWithMinValue() { [EOL] long minValue = Integer.MIN_VALUE; [EOL] boolean result = new YourClass(minValue).canConvertToInt(); [EOL] assertTrue(result); [EOL] }
public void testCanConvertToIntWithMaxValue() { [EOL] long maxValue = Integer.MAX_VALUE; [EOL] boolean result = new YourClass(maxValue).canConvertToInt(); [EOL] assertTrue(result); [EOL] }
public void testCanConvertToIntWithBelowMinValue() { [EOL] long belowMinValue = (long) Integer.MIN_VALUE - 1; [EOL] boolean result = new YourClass(belowMinValue).canConvertToInt(); [EOL] assertFalse(result); [EOL] }
public void testCanConvertToIntWithAboveMaxValue() { [EOL] long aboveMaxValue = (long) Integer.MAX_VALUE + 1; [EOL] boolean result = new YourClass(aboveMaxValue).canConvertToInt(); [EOL] assertFalse(result); [EOL] }
public void testCanConvertToLongWithMinValue() { [EOL] YourClass instance = new YourClass(Long.MIN_VALUE); [EOL] boolean result = instance.canConvertToLong(); [EOL] assert result; // Assuming the use of simple assert statements [EOL] }
public void testCanConvertToLongWithMaxValue() { [EOL] YourClass instance = new YourClass(Long.MAX_VALUE); [EOL] boolean result = instance.canConvertToLong(); [EOL] assert result; [EOL] }
public void testCanConvertToLongWithValueBelowMin() { [EOL] YourClass instance = new YourClass((double) Long.MIN_VALUE - 1); [EOL] boolean result = instance.canConvertToLong(); [EOL] assert !result; [EOL] }
public void testCanConvertToLongWithValueAboveMax() { [EOL] YourClass instance = new YourClass((double) Long.MAX_VALUE + 1); [EOL] boolean result = instance.canConvertToLong(); [EOL] assert !result; [EOL] }
public void testIntValue_Positive() { [EOL] JsonNode node = new IntNode(5); [EOL] int result = node.intValue(); [EOL] assertEquals(5, result); [EOL] }
public void testIntValue_Negative() { [EOL] JsonNode node = new IntNode(-5); [EOL] int result = node.intValue(); [EOL] assertEquals(-5, result); [EOL] }
public void testIntValue_Zero() { [EOL] JsonNode node = new IntNode(0); [EOL] int result = node.intValue(); [EOL] assertEquals(0, result); [EOL] }
public void testLongValue_Positive() { [EOL] YourClass instance = new YourClass(123.0); [EOL] long expected = 123L; [EOL] long actual = instance.longValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testLongValue_Negative() { [EOL] YourClass instance = new YourClass(-123.0); [EOL] long expected = -123L; [EOL] long actual = instance.longValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testLongValue_Zero() { [EOL] YourClass instance = new YourClass(0.0); [EOL] long expected = 0L; [EOL] long actual = instance.longValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testLongValue_MaxLong() { [EOL] YourClass instance = new YourClass(Long.MAX_VALUE); [EOL] long expected = Long.MAX_VALUE; [EOL] long actual = instance.longValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testLongValue_MinLong() { [EOL] YourClass instance = new YourClass(Long.MIN_VALUE); [EOL] long expected = Long.MIN_VALUE; [EOL] long actual = instance.longValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testFloatValue_Positive() { [EOL] JsonNode node = new NumericNode(10); [EOL] float result = node.floatValue(); [EOL] assertEquals(10.0f, result, 0.0f); [EOL] }
public void testFloatValue_Negative() { [EOL] JsonNode node = new NumericNode(-10); [EOL] float result = node.floatValue(); [EOL] assertEquals(-10.0f, result, 0.0f); [EOL] }
public void testFloatValue_Zero() { [EOL] JsonNode node = new NumericNode(0); [EOL] float result = node.floatValue(); [EOL] assertEquals(0.0f, result, 0.0f); [EOL] }
public void testFloatValue_MaxValue() { [EOL] JsonNode node = new NumericNode(Float.MAX_VALUE); [EOL] float result = node.floatValue(); [EOL] assertEquals(Float.MAX_VALUE, result, 0.0f); [EOL] }
public void testFloatValue_MinValue() { [EOL] JsonNode node = new NumericNode(Float.MIN_VALUE); [EOL] float result = node.floatValue(); [EOL] assertEquals(Float.MIN_VALUE, result, 0.0f); [EOL] }
public void testDoubleValue_Positive() { [EOL] DecimalNode node = new DecimalNode(BigDecimal.valueOf(123.456)); [EOL] double result = node.doubleValue(); [EOL] assertEquals(123.456, result, 0.0); [EOL] }
public void testDoubleValue_Negative() { [EOL] DecimalNode node = new DecimalNode(BigDecimal.valueOf(-123.456)); [EOL] double result = node.doubleValue(); [EOL] assertEquals(-123.456, result, 0.0); [EOL] }
public void testDoubleValue_Zero() { [EOL] DecimalNode node = new DecimalNode(BigDecimal.ZERO); [EOL] double result = node.doubleValue(); [EOL] assertEquals(0.0, result, 0.0); [EOL] }
public void testDecimalValue_Positive() { [EOL] LongNode longNode = new LongNode(10L); [EOL] BigDecimal result = longNode.decimalValue(); [EOL] assertEquals(new BigDecimal("10"), result); [EOL] }
public void testDecimalValue_Negative() { [EOL] LongNode longNode = new LongNode(-10L); [EOL] BigDecimal result = longNode.decimalValue(); [EOL] assertEquals(new BigDecimal("-10"), result); [EOL] }
public void testDecimalValue_Zero() { [EOL] LongNode longNode = new LongNode(0L); [EOL] BigDecimal result = longNode.decimalValue(); [EOL] assertEquals(BigDecimal.ZERO, result); [EOL] }
public void testBigIntegerValueWithIntegerValue() { [EOL] JsonNode node = new IntNode(123); [EOL] BigInteger result = node.bigIntegerValue(); [EOL] assertEquals(new BigInteger("123"), result); [EOL] }
public void testBigIntegerValueWithDecimalValue() { [EOL] JsonNode node = new DecimalNode(new BigDecimal("123.45")); [EOL] BigInteger result = node.bigIntegerValue(); [EOL] assertEquals(new BigInteger("123"), result); [EOL] }
public void testEquals_sameObject() { [EOL] FloatNode node = new FloatNode(5.0f); [EOL] assertTrue(node.equals(node)); [EOL] }
public void testEquals_nullObject() { [EOL] FloatNode node = new FloatNode(5.0f); [EOL] assertFalse(node.equals(null)); [EOL] }
public void testEquals_differentClass() { [EOL] FloatNode node = new FloatNode(5.0f); [EOL] Object other = new Object(); [EOL] assertFalse(node.equals(other)); [EOL] }
public void testEquals_differentValue() { [EOL] FloatNode node = new FloatNode(5.0f); [EOL] FloatNode other = new FloatNode(5.1f); [EOL] assertFalse(node.equals(other)); [EOL] }
public void testEquals_sameValue() { [EOL] FloatNode node = new FloatNode(5.0f); [EOL] FloatNode other = new FloatNode(5.0f); [EOL] assertTrue(node.equals(other)); [EOL] }
public void testHashCodeWithPositiveValue() { [EOL] FloatNode node = new FloatNode(1.0f); [EOL] int expectedHashCode = Float.floatToIntBits(1.0f); [EOL] assertEquals(expectedHashCode, node.hashCode()); [EOL] }
public void testHashCodeWithNegativeValue() { [EOL] FloatNode node = new FloatNode(-1.0f); [EOL] int expectedHashCode = Float.floatToIntBits(-1.0f); [EOL] assertEquals(expectedHashCode, node.hashCode()); [EOL] }
public void testHashCodeWithZero() { [EOL] FloatNode node = new FloatNode(0.0f); [EOL] int expectedHashCode = Float.floatToIntBits(0.0f); [EOL] assertEquals(expectedHashCode, node.hashCode()); [EOL] }
public void testHashCodeWithNaN() { [EOL] FloatNode node = new FloatNode(Float.NaN); [EOL] int expectedHashCode = Float.floatToIntBits(Float.NaN); [EOL] assertEquals(expectedHashCode, node.hashCode()); [EOL] }
public void testHashCodeWithPositiveInfinity() { [EOL] FloatNode node = new FloatNode(Float.POSITIVE_INFINITY); [EOL] int expectedHashCode = Float.floatToIntBits(Float.POSITIVE_INFINITY); [EOL] assertEquals(expectedHashCode, node.hashCode()); [EOL] }
public void testHashCodeWithNegativeInfinity() { [EOL] FloatNode node = new FloatNode(Float.NEGATIVE_INFINITY); [EOL] int expectedHashCode = Float.floatToIntBits(Float.NEGATIVE_INFINITY); [EOL] assertEquals(expectedHashCode, node.hashCode()); [EOL] }
public void testAddPropertyCreatorWithNonDuplicateProperties() { [EOL] AnnotatedWithParams creator = mock(AnnotatedWithParams.class); [EOL] CreatorProperty[] properties = new CreatorProperty[2]; [EOL] properties[0] = mock(CreatorProperty.class); [EOL] properties[1] = mock(CreatorProperty.class); [EOL] when(properties[0].getName()).thenReturn("prop1"); [EOL] when(properties[1].getName()).thenReturn("prop2"); [EOL] BeanDeserializerBuilder builder = new BeanDeserializerBuilder(null); [EOL] builder.addPropertyCreator(creator, properties); [EOL] }
public void testAddPropertyCreatorWithDuplicateProperties() { [EOL] AnnotatedWithParams creator = mock(AnnotatedWithParams.class); [EOL] CreatorProperty[] properties = new CreatorProperty[2]; [EOL] properties[0] = mock(CreatorProperty.class); [EOL] properties[1] = mock(CreatorProperty.class); [EOL] when(properties[0].getName()).thenReturn("prop"); [EOL] when(properties[1].getName()).thenReturn("prop"); [EOL] BeanDeserializerBuilder builder = new BeanDeserializerBuilder(null); [EOL] try { [EOL] builder.addPropertyCreator(creator, properties); [EOL] fail("Expected IllegalArgumentException for duplicate properties"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAddPropertyCreatorWithSingleProperty() { [EOL] AnnotatedWithParams creator = mock(AnnotatedWithParams.class); [EOL] CreatorProperty[] properties = new CreatorProperty[1]; [EOL] properties[0] = mock(CreatorProperty.class); [EOL] when(properties[0].getName()).thenReturn("prop"); [EOL] BeanDeserializerBuilder builder = new BeanDeserializerBuilder(null); [EOL] builder.addPropertyCreator(creator, properties); [EOL] }
public void testAddPropertyCreatorWithEmptyPropertyNameAndInjectableValue() { [EOL] AnnotatedWithParams creator = mock(AnnotatedWithParams.class); [EOL] CreatorProperty[] properties = new CreatorProperty[2]; [EOL] properties[0] = mock(CreatorProperty.class); [EOL] properties[1] = mock(CreatorProperty.class); [EOL] when(properties[0].getName()).thenReturn(""); [EOL] when(properties[0].getInjectableValueId()).thenReturn(new Object()); [EOL] when(properties[1].getName()).thenReturn("prop"); [EOL] BeanDeserializerBuilder builder = new BeanDeserializerBuilder(null); [EOL] builder.addPropertyCreator(creator, properties); [EOL] }
public void testFindCollectionDeserializerWithNullClassMappings() { [EOL] CollectionType type = mock(CollectionType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] TypeDeserializer elementTypeDeserializer = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> elementDeserializer = mock(JsonDeserializer.class); [EOL] when(type.getRawClass()).thenReturn(Object.class); [EOL] CustomDeserializerFactory factory = new CustomDeserializerFactory(); [EOL] JsonDeserializer<?> result = factory.findCollectionDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer); [EOL] assertNull(result); [EOL] }
public void testFindCollectionDeserializerWithNonNullClassMappings() { [EOL] CollectionType type = mock(CollectionType.class); [EOL] DeserializationConfig config = mock(DeserializationConfig.class); [EOL] BeanDescription beanDesc = mock(BeanDescription.class); [EOL] TypeDeserializer elementTypeDeserializer = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> elementDeserializer = mock(JsonDeserializer.class); [EOL] when(type.getRawClass()).thenReturn(Object.class); [EOL] CustomDeserializerFactory factory = new CustomDeserializerFactory(); [EOL] factory._classMappings = new HashMap<>(); [EOL] factory._classMappings.put(new ClassKey(Object.class), mock(JsonDeserializer.class)); [EOL] JsonDeserializer<?> result = factory.findCollectionDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer); [EOL] assertNotNull(result); [EOL] }
public void testDecimalNodeWithNull() { [EOL] BigDecimal value = null; [EOL] DecimalNode node = new DecimalNode(value); [EOL] assertNull(node.decimalValue()); [EOL] }
public void testDecimalNodeWithZero() { [EOL] BigDecimal value = BigDecimal.ZERO; [EOL] DecimalNode node = new DecimalNode(value); [EOL] assertEquals(BigDecimal.ZERO, node.decimalValue()); [EOL] }
public void testDecimalNodeWithPositiveValue() { [EOL] BigDecimal value = new BigDecimal("123.456"); [EOL] DecimalNode node = new DecimalNode(value); [EOL] assertEquals(new BigDecimal("123.456"), node.decimalValue()); [EOL] }
public void testDecimalNodeWithNegativeValue() { [EOL] BigDecimal value = new BigDecimal("-123.456"); [EOL] DecimalNode node = new DecimalNode(value); [EOL] assertEquals(new BigDecimal("-123.456"), node.decimalValue()); [EOL] }
public void testValueOfWithNullBigDecimal() { [EOL] BigDecimal d = null; [EOL] try { [EOL] DecimalNode result = DecimalNode.valueOf(d); [EOL] fail("Expected an exception due to null BigDecimal input"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testValueOfWithZeroBigDecimal() { [EOL] BigDecimal d = BigDecimal.ZERO; [EOL] DecimalNode result = DecimalNode.valueOf(d); [EOL] assertNotNull(result); [EOL] assertEquals("0", result.asText()); [EOL] }
public void testValueOfWithPositiveBigDecimal() { [EOL] BigDecimal d = new BigDecimal("123.456"); [EOL] DecimalNode result = DecimalNode.valueOf(d); [EOL] assertNotNull(result); [EOL] assertEquals("123.456", result.asText()); [EOL] }
public void testValueOfWithNegativeBigDecimal() { [EOL] BigDecimal d = new BigDecimal("-123.456"); [EOL] DecimalNode result = DecimalNode.valueOf(d); [EOL] assertNotNull(result); [EOL] assertEquals("-123.456", result.asText()); [EOL] }
public void testIsFloatingPointNumber() { [EOL] JsonNode node = new NumericNode() { [EOL] @Override [EOL] public boolean isFloatingPointNumber() { [EOL] return true; [EOL] } [EOL] }; [EOL] assertTrue(node.isFloatingPointNumber()); [EOL] }
public void testIsBigDecimal() { [EOL] JsonNode node = new NumericNode() { [EOL] @Override [EOL] public boolean isBigDecimal() { [EOL] return true; [EOL] } [EOL] }; [EOL] assertTrue(node.isBigDecimal()); [EOL] }
public void testNumberValueWithNonNullValue() { [EOL] Number expectedValue = 42; [EOL] JsonNumber jsonNumber = new JsonNumber(expectedValue); [EOL] Number result = jsonNumber.numberValue(); [EOL] assertEquals(expectedValue, result); [EOL] }
public void testNumberValueWithNullValue() { [EOL] JsonNumber jsonNumber = new JsonNumber(null); [EOL] Number result = jsonNumber.numberValue(); [EOL] assertNull(result); [EOL] }
public void testAsTextWithNonNullValue() { [EOL] JsonNode node = new JsonNode("TestValue"); [EOL] String result = node.asText(); [EOL] assertEquals("TestValue", result); [EOL] }
public void testAsTextWithNullValue() { [EOL] JsonNode node = new JsonNode(null); [EOL] String result = node.asText(); [EOL] assertEquals("null", result); [EOL] }
public void testEquals_sameObject() { [EOL] DecimalNode node = new DecimalNode(BigDecimal.ONE); [EOL] assertTrue(node.equals(node)); [EOL] }
public void testEquals_nullObject() { [EOL] DecimalNode node = new DecimalNode(BigDecimal.ONE); [EOL] assertFalse(node.equals(null)); [EOL] }
public void testEquals_differentClass() { [EOL] DecimalNode node = new DecimalNode(BigDecimal.ONE); [EOL] Object other = new Object(); [EOL] assertFalse(node.equals(other)); [EOL] }
public void testEquals_equalValues() { [EOL] DecimalNode node1 = new DecimalNode(BigDecimal.ONE); [EOL] DecimalNode node2 = new DecimalNode(BigDecimal.ONE); [EOL] assertTrue(node1.equals(node2)); [EOL] }
public void testEquals_differentValues() { [EOL] DecimalNode node1 = new DecimalNode(BigDecimal.ONE); [EOL] DecimalNode node2 = new DecimalNode(BigDecimal.TEN); [EOL] assertFalse(node1.equals(node2)); [EOL] }
public void testForDeserializationWithNonNullCollector() { [EOL] POJOPropertiesCollector coll = mock(POJOPropertiesCollector.class); [EOL] when(coll.getAnySetterMethod()).thenReturn(null); [EOL] when(coll.getIgnoredPropertyNames()).thenReturn(Collections.emptySet()); [EOL] when(coll.getInjectables()).thenReturn(Collections.emptyList()); [EOL] when(coll.getJsonValueMethod()).thenReturn(null); [EOL] BasicBeanDescription desc = BasicBeanDescription.forDeserialization(coll); [EOL] assertNull(desc.getAnySetterMethod()); [EOL] assertTrue(desc.getIgnoredPropertyNames().isEmpty()); [EOL] assertTrue(desc.getInjectables().isEmpty()); [EOL] assertNull(desc.getJsonValueMethod()); [EOL] }
public void testForDeserializationWithNonNullValues() { [EOL] POJOPropertiesCollector coll = mock(POJOPropertiesCollector.class); [EOL] AnnotatedMethod anySetterMethod = mock(AnnotatedMethod.class); [EOL] Set<String> ignoredPropertyNames = new HashSet<>(Arrays.asList("prop1", "prop2")); [EOL] List<InjectableValues> injectables = new ArrayList<>(); [EOL] injectables.add(mock(InjectableValues.class)); [EOL] AnnotatedMethod jsonValueMethod = mock(AnnotatedMethod.class); [EOL] when(coll.getAnySetterMethod()).thenReturn(anySetterMethod); [EOL] when(coll.getIgnoredPropertyNames()).thenReturn(ignoredPropertyNames); [EOL] when(coll.getInjectables()).thenReturn(injectables); [EOL] when(coll.getJsonValueMethod()).thenReturn(jsonValueMethod); [EOL] BasicBeanDescription desc = BasicBeanDescription.forDeserialization(coll); [EOL] assertEquals(anySetterMethod, desc.getAnySetterMethod()); [EOL] assertEquals(ignoredPropertyNames, desc.getIgnoredPropertyNames()); [EOL] assertEquals(injectables, desc.getInjectables()); [EOL] assertEquals(jsonValueMethod, desc.getJsonValueMethod()); [EOL] }
public void testFindPOJOBuilderWithNullIntrospector() { [EOL] AnnotationIntrospector introspector = null; [EOL] ClassInfo classInfo = new ClassInfo(SomeClass.class); [EOL] POJOBuilderFinder finder = new POJOBuilderFinder(introspector, classInfo); [EOL] Class<?> result = finder.findPOJOBuilder(); [EOL] assertNull(result); [EOL] }
public void testFindPOJOBuilderWithNonNullIntrospector() { [EOL] AnnotationIntrospector introspector = mock(AnnotationIntrospector.class); [EOL] ClassInfo classInfo = new ClassInfo(SomeClass.class); [EOL] when(introspector.findPOJOBuilder(classInfo)).thenReturn(SomeBuilderClass.class); [EOL] POJOBuilderFinder finder = new POJOBuilderFinder(introspector, classInfo); [EOL] Class<?> result = finder.findPOJOBuilder(); [EOL] assertNotNull(result); [EOL] assertEquals(SomeBuilderClass.class, result); [EOL] }
public void testFindDeserializationConverterWithNullIntrospector() { [EOL] _annotationIntrospector = null; [EOL] Converter<Object, Object> converter = findDeserializationConverter(); [EOL] assertNull(converter); [EOL] }
public void testFindDeserializationConverterWithNonNullIntrospector() { [EOL] _annotationIntrospector = mock(AnnotationIntrospector.class); [EOL] when(_annotationIntrospector.findDeserializationConverter(_classInfo)).thenReturn(SomeConverter.class); [EOL] Converter<Object, Object> converter = findDeserializationConverter(); [EOL] assertNotNull(converter); [EOL] assertTrue(converter instanceof SomeConverter); [EOL] }
public void testHasSingleElementWithSingleElementArray() { [EOL] boolean[] singleElementArray = {true}; [EOL] assertTrue(hasSingleElement(singleElementArray)); [EOL] }
public void testHasSingleElementWithEmptyArray() { [EOL] boolean[] emptyArray = {}; [EOL] assertFalse(hasSingleElement(emptyArray)); [EOL] }
public void testHasSingleElementWithMultipleElementsArray() { [EOL] boolean[] multipleElementsArray = {true, false}; [EOL] assertFalse(hasSingleElement(multipleElementsArray)); [EOL] }
public void testSerializeContentsWithEmptyArray() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] boolean[] value = new boolean[0]; [EOL] serializeContents(value, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator, never()).writeBoolean(anyBoolean()); [EOL] }
public void testSerializeContentsWithSingleElementArray() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] boolean[] value = new boolean[]{true}; [EOL] serializeContents(value, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeBoolean(true); [EOL] }
public void testSerializeContentsWithMultipleElementsArray() throws IOException { [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] boolean[] value = new boolean[]{true, false, true}; [EOL] serializeContents(value, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeBoolean(true); [EOL] verify(mockJsonGenerator).writeBoolean(false); [EOL] verify(mockJsonGenerator, times(2)).writeBoolean(true); [EOL] }
public void testSerializeContentsWithValueTypeSerializer() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] TypeSerializer typeSerializer = mock(TypeSerializer.class); [EOL] ShortArraySerializer serializer = new ShortArraySerializer(null, null, typeSerializer); [EOL] short[] value = new short[]{1, 2, 3}; [EOL] serializer.serializeContents(value, jgen, provider); [EOL] verify(typeSerializer, times(value.length)).writeTypePrefixForScalar(null, jgen, Short.TYPE); [EOL] verify(jgen, times(value.length)).writeNumber(anyInt()); [EOL] verify(typeSerializer, times(value.length)).writeTypeSuffixForScalar(null, jgen); [EOL] }
public void testSerializeContentsWithoutValueTypeSerializer() throws IOException { [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] ShortArraySerializer serializer = new ShortArraySerializer(null, null, null); [EOL] short[] value = new short[]{1, 2, 3}; [EOL] serializer.serializeContents(value, jgen, provider); [EOL] verify(jgen, times(value.length)).writeNumber(anyInt()); [EOL] }
public void testHasSingleElementWithSingleElementArray() { [EOL] int[] singleElementArray = {1}; [EOL] assertTrue(hasSingleElement(singleElementArray)); [EOL] }
public void testHasSingleElementWithEmptyArray() { [EOL] int[] emptyArray = {}; [EOL] assertFalse(hasSingleElement(emptyArray)); [EOL] }
public void testHasSingleElementWithMultipleElementsArray() { [EOL] int[] multipleElementsArray = {1, 2, 3}; [EOL] assertFalse(hasSingleElement(multipleElementsArray)); [EOL] }
public void testSerializeContentsEmptyArray() throws IOException { [EOL] JsonGenerator mockGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] int[] emptyArray = new int[0]; [EOL] serializeContents(emptyArray, mockGenerator, mockProvider); [EOL] verify(mockGenerator, never()).writeNumber(anyInt()); [EOL] }
public void testSerializeContentsNonEmptyArray() throws IOException { [EOL] JsonGenerator mockGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] int[] nonEmptyArray = {1, 2, 3}; [EOL] serializeContents(nonEmptyArray, mockGenerator, mockProvider); [EOL] verify(mockGenerator, times(3)).writeNumber(anyInt()); [EOL] verify(mockGenerator).writeNumber(1); [EOL] verify(mockGenerator).writeNumber(2); [EOL] verify(mockGenerator).writeNumber(3); [EOL] }
public void testMapTypeWithNonNullValues() { [EOL] Class<?> mapType = HashMap.class; [EOL] JavaType keyType = TypeFactory.defaultInstance().constructType(String.class); [EOL] JavaType valueType = TypeFactory.defaultInstance().constructType(Integer.class); [EOL] Object valueHandler = new Object(); [EOL] Object typeHandler = new Object(); [EOL] boolean asStatic = true; [EOL] MapType mapTypeInstance = new MapType(mapType, keyType, valueType, valueHandler, typeHandler, asStatic); [EOL] assertNotNull(mapTypeInstance); [EOL] assertEquals(mapType, mapTypeInstance.getRawClass()); [EOL] assertEquals(keyType, mapTypeInstance.getKeyType()); [EOL] assertEquals(valueType, mapTypeInstance.getContentType()); [EOL] assertEquals(valueHandler, mapTypeInstance.getValueHandler()); [EOL] assertEquals(typeHandler, mapTypeInstance.getTypeHandler()); [EOL] assertEquals(asStatic, mapTypeInstance.isStatic()); [EOL] }
public void testMapTypeWithNullHandlers() { [EOL] Class<?> mapType = HashMap.class; [EOL] JavaType keyType = TypeFactory.defaultInstance().constructType(String.class); [EOL] JavaType valueType = TypeFactory.defaultInstance().constructType(Integer.class); [EOL] Object valueHandler = null; [EOL] Object typeHandler = null; [EOL] boolean asStatic = false; [EOL] MapType mapTypeInstance = new MapType(mapType, keyType, valueType, valueHandler, typeHandler, asStatic); [EOL] assertNotNull(mapTypeInstance); [EOL] assertEquals(mapType, mapTypeInstance.getRawClass()); [EOL] assertEquals(keyType, mapTypeInstance.getKeyType()); [EOL] assertEquals(valueType, mapTypeInstance.getContentType()); [EOL] assertNull(mapTypeInstance.getValueHandler()); [EOL] assertNull(mapTypeInstance.getTypeHandler()); [EOL] assertEquals(asStatic, mapTypeInstance.isStatic()); [EOL] }
public void testConstructWithNonNullTypes() { [EOL] Class<?> rawType = Map.class; [EOL] JavaType keyType = TypeFactory.defaultInstance().constructType(String.class); [EOL] JavaType valueType = TypeFactory.defaultInstance().constructType(Integer.class); [EOL] MapType mapType = MapType.construct(rawType, keyType, valueType); [EOL] assertNotNull(mapType); [EOL] assertEquals(rawType, mapType.getRawClass()); [EOL] assertEquals(keyType, mapType.getKeyType()); [EOL] assertEquals(valueType, mapType.getContentType()); [EOL] }
public void testNarrowContentsBy_SameContentClass() { [EOL] Class<?> initialContentClass = String.class; [EOL] JavaType keyType = TypeFactory.defaultInstance().constructType(String.class); [EOL] JavaType valueType = TypeFactory.defaultInstance().constructType(initialContentClass); [EOL] MapType mapType = (MapType) TypeFactory.defaultInstance().constructMapType(HashMap.class, keyType, valueType); [EOL] JavaType result = mapType.narrowContentsBy(initialContentClass); [EOL] assertSame("The narrowed JavaType should be the same as the original when the content class is the same.", mapType, result); [EOL] }
public void testNarrowContentsBy_DifferentContentClass() { [EOL] Class<?> initialContentClass = String.class; [EOL] Class<?> newContentClass = Integer.class; [EOL] JavaType keyType = TypeFactory.defaultInstance().constructType(String.class); [EOL] JavaType valueType = TypeFactory.defaultInstance().constructType(initialContentClass); [EOL] MapType mapType = (MapType) TypeFactory.defaultInstance().constructMapType(HashMap.class, keyType, valueType); [EOL] JavaType result = mapType.narrowContentsBy(newContentClass); [EOL] assertNotSame("The narrowed JavaType should not be the same as the original when the content class is different.", mapType, result); [EOL] assertEquals("The content type of the narrowed JavaType should be the new content class.", newContentClass, result.getContentType().getRawClass()); [EOL] }
public void testWidenContentsBy_SameContentClass() { [EOL] MapType originalType = createMapType(Map.class, String.class, Integer.class); [EOL] JavaType widenedType = originalType.widenContentsBy(Integer.class); [EOL] assertSame("Widening with the same content class should return the original type", originalType, widenedType); [EOL] }
public void testWidenContentsBy_DifferentContentClass() { [EOL] MapType originalType = createMapType(Map.class, String.class, Integer.class); [EOL] JavaType widenedType = originalType.widenContentsBy(Long.class); [EOL] assertNotSame("Widening with a different content class should create a new type", originalType, widenedType); [EOL] assertTrue("The new type should have the content class widened to Long", widenedType.containedType(0).getRawClass().equals(Long.class)); [EOL] }
public void testNarrowKeyWithSameClass() { [EOL] MapType original = createMapType(Map.class, String.class, Object.class); [EOL] JavaType result = original.narrowKey(String.class); [EOL] assertSame("Narrowing with the same key class should return the original MapType", original, result); [EOL] }
public void testNarrowKeyWithDifferentClass() { [EOL] MapType original = createMapType(Map.class, String.class, Object.class); [EOL] JavaType result = original.narrowKey(Integer.class); [EOL] assertNotSame("Narrowing with a different key class should not return the original MapType", original, result); [EOL] assertTrue("Result should be an instance of MapType", result instanceof MapType); [EOL] assertEquals("Key class should be narrowed to the new subclass", Integer.class, result.getKeyType().getRawClass()); [EOL] }
public void testFindBeanDeserializerWithQName() { [EOL] JavaType type = TypeFactory.defaultInstance().constructType(QName.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = new BeanDescription(type); [EOL] JsonDeserializer<?> deserializer = findBeanDeserializer(type, config, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof QNameDeserializer); [EOL] }
public void testFindBeanDeserializerWithXMLGregorianCalendar() { [EOL] JavaType type = TypeFactory.defaultInstance().constructType(XMLGregorianCalendar.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = new BeanDescription(type); [EOL] JsonDeserializer<?> deserializer = findBeanDeserializer(type, config, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof GregorianCalendarDeserializer); [EOL] }
public void testFindBeanDeserializerWithDuration() { [EOL] JavaType type = TypeFactory.defaultInstance().constructType(Duration.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = new BeanDescription(type); [EOL] JsonDeserializer<?> deserializer = findBeanDeserializer(type, config, beanDesc); [EOL] assertNotNull(deserializer); [EOL] assertTrue(deserializer instanceof DurationDeserializer); [EOL] }
public void testFindBeanDeserializerWithUnrecognizedType() { [EOL] JavaType type = TypeFactory.defaultInstance().constructType(String.class); [EOL] DeserializationConfig config = new DeserializationConfig(null, null, null, null, null, null, null); [EOL] BeanDescription beanDesc = new BeanDescription(type); [EOL] JsonDeserializer<?> deserializer = findBeanDeserializer(type, config, beanDesc); [EOL] assertNull(deserializer); [EOL] }
public void testDeserializeWithNullDate() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_parseDate(jp, ctxt)).thenReturn(null); [EOL] XMLGregorianCalendar result = deserialize(jp, ctxt); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithNonNullDateAndNullTimeZone() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Date mockDate = new Date(); [EOL] when(_parseDate(jp, ctxt)).thenReturn(mockDate); [EOL] when(ctxt.getTimeZone()).thenReturn(null); [EOL] XMLGregorianCalendar result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(mockDate.getTime(), result.toGregorianCalendar().getTimeInMillis()); [EOL] }
public void testDeserializeWithNonNullDateAndNonNullTimeZone() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Date mockDate = new Date(); [EOL] TimeZone mockTimeZone = TimeZone.getTimeZone("UTC"); [EOL] when(_parseDate(jp, ctxt)).thenReturn(mockDate); [EOL] when(ctxt.getTimeZone()).thenReturn(mockTimeZone); [EOL] XMLGregorianCalendar result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] assertEquals(mockDate.getTime(), result.toGregorianCalendar().getTimeInMillis()); [EOL] assertEquals(mockTimeZone, result.toGregorianCalendar().getTimeZone()); [EOL] }
public void testUnwrappingWriterWithNullUnwrapper() { [EOL] BeanPropertyWriter originalWriter = new BeanPropertyWriter(); // Assume a constructor or a factory method exists [EOL] NameTransformer unwrapper = null; [EOL] BeanPropertyWriter result = originalWriter.unwrappingWriter(unwrapper); [EOL] assertTrue(result instanceof UnwrappingBeanPropertyWriter); [EOL] assertNull(((UnwrappingBeanPropertyWriter) result).getUnwrapper()); [EOL] }
public void testUnwrappingWriterWithNonNullUnwrapper() { [EOL] BeanPropertyWriter originalWriter = new BeanPropertyWriter(); // Assume a constructor or a factory method exists [EOL] NameTransformer unwrapper = new NameTransformer() { [EOL] @Override [EOL] public String transform(String name) { [EOL] return "prefix_" + name; [EOL] } [EOL] }; [EOL] BeanPropertyWriter result = originalWriter.unwrappingWriter(unwrapper); [EOL] assertTrue(result instanceof UnwrappingBeanPropertyWriter); [EOL] assertNotNull(((UnwrappingBeanPropertyWriter) result).getUnwrapper()); [EOL] assertEquals("prefix_testName", ((UnwrappingBeanPropertyWriter) result).getUnwrapper().transform("testName")); [EOL] }
public void testGetNameWhenNameIsSet() { [EOL] TargetClass target = new TargetClass(); [EOL] target.setName("TestName"); // Assuming setName method is available to set _name [EOL] String result = target.getName(); [EOL] assert "TestName".equals(result); [EOL] }
public void testIsRequiredWhenTrue() { [EOL] YourClass instance = new YourClass(true); // Replace YourClass with the actual class name [EOL] boolean result = instance.isRequired(); [EOL] assertTrue(result); [EOL] }
public void testIsRequiredWhenFalse() { [EOL] YourClass instance = new YourClass(false); // Replace YourClass with the actual class name [EOL] boolean result = instance.isRequired(); [EOL] assertFalse(result); [EOL] }
public void testGetSerializer() { [EOL] SerializerProvider provider = new TestSerializerProvider(); [EOL] JsonSerializer<Object> expectedSerializer = new SomeJsonSerializer(); [EOL] provider._serializer = expectedSerializer; [EOL] JsonSerializer<Object> actualSerializer = provider.getSerializer(); [EOL] assertSame("The returned serializer should be the one that was set", expectedSerializer, actualSerializer); [EOL] }
public void testGetRawSerializationTypeWhenCfgSerializationTypeIsNull() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] assertNull(config.getRawSerializationType()); [EOL] }
public void testGetRawSerializationTypeWhenCfgSerializationTypeIsNotNull() { [EOL] SerializationConfig config = new SerializationConfig(); [EOL] JavaType mockJavaType = Mockito.mock(JavaType.class); [EOL] Mockito.when(mockJavaType.getRawClass()).thenReturn(String.class); [EOL] config.setCfgSerializationType(mockJavaType); [EOL] assertEquals(String.class, config.getRawSerializationType()); [EOL] }
public void testGetPropertyTypeWithAccessorMethod() { [EOL] Method accessorMethod = String.class.getMethod("length"); [EOL] BeanProperty prop = new BeanProperty.Std(null, accessorMethod, null); [EOL] Class<?> propertyType = prop.getPropertyType(); [EOL] assertEquals(int.class, propertyType); [EOL] }
public void testGetPropertyTypeWithField() throws NoSuchFieldException { [EOL] Field field = String.class.getField("CASE_INSENSITIVE_ORDER"); [EOL] BeanProperty prop = new BeanProperty.Std(null, null, field); [EOL] Class<?> propertyType = prop.getPropertyType(); [EOL] assertEquals(Comparator.class, propertyType); [EOL] }
public void testDepositSchemaPropertyWithSerializationTypeAndSchemaAwareSerializer() throws JsonMappingException { [EOL] ObjectNode propertiesNode = JsonNodeFactory.instance.objectNode(); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(getSerializationType()).thenReturn(mock(JavaType.class)); [EOL] when(getSerializer()).thenReturn(mock(SchemaAware.class)); [EOL] when(isRequired()).thenReturn(true); [EOL] JsonSerializer<Object> ser = (JsonSerializer<Object>) getSerializer(); [EOL] when(((SchemaAware) ser).getSchema(provider, null, false)).thenReturn(mock(JsonNode.class)); [EOL] depositSchemaProperty(propertiesNode, provider); [EOL] assertNotNull(propertiesNode.get(getName())); [EOL] }
public void testDepositSchemaPropertyWithNullSerializationTypeAndNonSchemaAwareSerializer() throws JsonMappingException { [EOL] ObjectNode propertiesNode = JsonNodeFactory.instance.objectNode(); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] when(getSerializationType()).thenReturn(null); [EOL] when(getGenericPropertyType()).thenReturn(mock(Type.class)); [EOL] when(getSerializer()).thenReturn(null); [EOL] when(getRawSerializationType()).thenReturn(null); [EOL] when(getPropertyType()).thenReturn(Object.class); [EOL] when(provider.findValueSerializer(Object.class, this)).thenReturn(mock(JsonSerializer.class)); [EOL] when(isRequired()).thenReturn(false); [EOL] depositSchemaProperty(propertiesNode, provider); [EOL] assertNotNull(propertiesNode.get(getName())); [EOL] }
public void testDepositSchemaPropertyWithNonNullSerializationTypeAndNonSchemaAwareSerializer() throws JsonMappingException { [EOL] ObjectNode propertiesNode = JsonNodeFactory.instance.objectNode(); [EOL] SerializerProvider provider = mock(SerializerProvider.class); [EOL] JavaType javaType = mock(JavaType.class); [EOL] when(getSerializationType()).thenReturn(javaType); [EOL] when(javaType.getRawClass()).thenReturn(Object.class); [EOL] when(getSerializer()).thenReturn(null); [EOL] when(getRawSerializationType()).thenReturn(Object.class); [EOL] when(provider.findValueSerializer(Object.class, this)).thenReturn(mock(JsonSerializer.class)); [EOL] when(isRequired()).thenReturn(true); [EOL] depositSchemaProperty(propertiesNode, provider); [EOL] assertNotNull(propertiesNode.get(getName())); [EOL] }
public void testSerializeAsColumnWithNullValueAndNullSerializer() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> nullSerializer = mock(JsonSerializer.class); [EOL] setNullSerializer(nullSerializer); [EOL] serializeAsColumn(bean, jgen, prov); [EOL] verify(nullSerializer).serialize(null, jgen, prov); [EOL] verify(jgen, never()).writeNull(); [EOL] }
public void testSerializeAsColumnWithNullValueNoNullSerializer() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] setNullSerializer(null); [EOL] serializeAsColumn(bean, jgen, prov); [EOL] verify(jgen).writeNull(); [EOL] }
public void testSerializeAsColumnWithNonNullValueAndNoSerializerFound() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] Object value = new Object(); [EOL] setValue(bean, value); [EOL] setSerializer(null); [EOL] PropertySerializerMap map = mock(PropertySerializerMap.class); [EOL] setDynamicSerializers(map); [EOL] setSuppressableValue(null); [EOL] setTypeSerializer(null); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] when(map.serializerFor(any(Class.class))).thenReturn(ser); [EOL] serializeAsColumn(bean, jgen, prov); [EOL] verify(ser).serialize(value, jgen, prov); [EOL] }
public void testSerializeAsColumnWithSuppressableValue() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] Object value = new Object(); [EOL] Object suppressableValue = new Object(); [EOL] setValue(bean, value); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] setSerializer(ser); [EOL] setSuppressableValue(suppressableValue); [EOL] when(ser.isEmpty(value)).thenReturn(true); [EOL] serializeAsColumn(bean, jgen, prov); [EOL] verify(ser, never()).serialize(any(), any(), any()); [EOL] }
public void testSerializeAsColumnWithValueEqualsBean() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] setValue(bean, bean); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] setSerializer(ser); [EOL] setSuppressableValue(null); [EOL] setTypeSerializer(null); [EOL] serializeAsColumn(bean, jgen, prov); [EOL] verify(ser).serialize(bean, jgen, prov); [EOL] }
public void testSerializeAsColumnWithTypeSerializer() throws Exception { [EOL] Object bean = new Object(); [EOL] JsonGenerator jgen = mock(JsonGenerator.class); [EOL] SerializerProvider prov = mock(SerializerProvider.class); [EOL] Object value = new Object(); [EOL] setValue(bean, value); [EOL] JsonSerializer<Object> ser = mock(JsonSerializer.class); [EOL] setSerializer(ser); [EOL] setSuppressableValue(null); [EOL] TypeSerializer typeSer = mock(TypeSerializer.class); [EOL] setTypeSerializer(typeSer); [EOL] serializeAsColumn(bean, jgen, prov); [EOL] verify(ser).serializeWithType(value, jgen, prov, typeSer); [EOL] }
public void testObjectArrayDeserializerWithTypedArray() { [EOL] ArrayType arrayType = ArrayType.construct(SimpleType.constructUnsafe(String[].class), null, null, null); [EOL] JsonDeserializer<Object> elemDeser = new StringDeserializer(); [EOL] TypeDeserializer elemTypeDeser = new MockTypeDeserializer(); [EOL] ObjectArrayDeserializer deserializer = new ObjectArrayDeserializer(arrayType, elemDeser, elemTypeDeser); [EOL] assertEquals(String[].class, deserializer._arrayType.getRawClass()); [EOL] assertEquals(String.class, deserializer._elementClass); [EOL] assertFalse(deserializer._untyped); [EOL] assertEquals(elemDeser, deserializer._elementDeserializer); [EOL] assertEquals(elemTypeDeser, deserializer._elementTypeDeserializer); [EOL] }
public void testObjectArrayDeserializerWithUntypedArray() { [EOL] ArrayType arrayType = ArrayType.construct(SimpleType.constructUnsafe(Object[].class), null, null, null); [EOL] JsonDeserializer<Object> elemDeser = new UntypedObjectDeserializer(); [EOL] TypeDeserializer elemTypeDeser = new MockTypeDeserializer(); [EOL] ObjectArrayDeserializer deserializer = new ObjectArrayDeserializer(arrayType, elemDeser, elemTypeDeser); [EOL] assertEquals(Object[].class, deserializer._arrayType.getRawClass()); [EOL] assertEquals(Object.class, deserializer._elementClass); [EOL] assertTrue(deserializer._untyped); [EOL] assertEquals(elemDeser, deserializer._elementDeserializer); [EOL] assertEquals(elemTypeDeser, deserializer._elementTypeDeserializer); [EOL] }
public void testWithDeserializerSameDeserializers() { [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> jsonDeserializer = mock(JsonDeserializer.class); [EOL] JavaType arrayType = mock(JavaType.class); [EOL] ObjectArrayDeserializer original = new ObjectArrayDeserializer(arrayType, jsonDeserializer, typeDeserializer); [EOL] ObjectArrayDeserializer result = original.withDeserializer(typeDeserializer, jsonDeserializer); [EOL] assertSame("Should return the same ObjectArrayDeserializer instance when deserializers are the same", original, result); [EOL] }
public void testWithDeserializerDifferentElementDeserializer() { [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> jsonDeserializer = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> newJsonDeserializer = mock(JsonDeserializer.class); [EOL] JavaType arrayType = mock(JavaType.class); [EOL] ObjectArrayDeserializer original = new ObjectArrayDeserializer(arrayType, jsonDeserializer, typeDeserializer); [EOL] ObjectArrayDeserializer result = original.withDeserializer(typeDeserializer, newJsonDeserializer); [EOL] assertNotSame("Should not return the same ObjectArrayDeserializer instance when element deserializer is different", original, result); [EOL] assertSame("Element deserializer should be the new one", newJsonDeserializer, result.getElementDeserializer()); [EOL] }
public void testWithDeserializerDifferentTypeDeserializer() { [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] TypeDeserializer newTypeDeserializer = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> jsonDeserializer = mock(JsonDeserializer.class); [EOL] JavaType arrayType = mock(JavaType.class); [EOL] ObjectArrayDeserializer original = new ObjectArrayDeserializer(arrayType, jsonDeserializer, typeDeserializer); [EOL] ObjectArrayDeserializer result = original.withDeserializer(newTypeDeserializer, jsonDeserializer); [EOL] assertNotSame("Should not return the same ObjectArrayDeserializer instance when type deserializer is different", original, result); [EOL] assertSame("Type deserializer should be the new one", newTypeDeserializer, result.getElementTypeDeserializer()); [EOL] }
public void testCreateContextualWithNullDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JavaType contentType = mock(JavaType.class); [EOL] when(_arrayType.getContentType()).thenReturn(contentType); [EOL] JsonDeserializer<?> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(ctxt.findContextualValueDeserializer(contentType, property)).thenReturn(expectedDeserializer); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testCreateContextualWithNonNullDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonDeserializer<?> initialDeserializer = mock(JsonDeserializer.class); [EOL] when(_elementDeserializer).thenReturn(initialDeserializer); [EOL] JsonDeserializer<?> contextualDeserializer = mock(JsonDeserializer.class); [EOL] when(findConvertingContentDeserializer(ctxt, property, initialDeserializer)).thenReturn(contextualDeserializer); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] assertSame(contextualDeserializer, result); [EOL] }
public void testCreateContextualWithNonNullContextualDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonDeserializer<?> initialDeserializer = mock(JsonDeserializer.class); [EOL] when(_elementDeserializer).thenReturn(initialDeserializer); [EOL] ContextualDeserializer contextualDeserializer = mock(ContextualDeserializer.class); [EOL] when(findConvertingContentDeserializer(ctxt, property, initialDeserializer)).thenReturn(contextualDeserializer); [EOL] JsonDeserializer<?> expectedDeserializer = mock(JsonDeserializer.class); [EOL] when(contextualDeserializer.createContextual(ctxt, property)).thenReturn(expectedDeserializer); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] assertSame(expectedDeserializer, result); [EOL] }
public void testCreateContextualWithTypeDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] TypeDeserializer typeDeserializer = mock(TypeDeserializer.class); [EOL] when(_elementTypeDeserializer).thenReturn(typeDeserializer); [EOL] TypeDeserializer propertyTypeDeserializer = mock(TypeDeserializer.class); [EOL] when(typeDeserializer.forProperty(property)).thenReturn(propertyTypeDeserializer); [EOL] JsonDeserializer<?> deserializer = mock(JsonDeserializer.class); [EOL] when(_elementDeserializer).thenReturn(deserializer); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] assertNotSame(deserializer, result); [EOL] }
public void testCreateContextualWithNullProperty() { [EOL] SerializerProvider provider = createMockSerializerProvider(); [EOL] JsonSerializer<?> result = createContextual(provider, null); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndMember() throws JsonMappingException { [EOL] SerializerProvider provider = createMockSerializerProvider(); [EOL] BeanProperty property = createMockBeanPropertyWithMember(); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndNullMember() throws JsonMappingException { [EOL] SerializerProvider provider = createMockSerializerProvider(); [EOL] BeanProperty property = createMockBeanPropertyWithNullMember(); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndNonNullMemberAndKeySerializer() throws JsonMappingException { [EOL] SerializerProvider provider = createMockSerializerProvider(); [EOL] BeanProperty property = createMockBeanPropertyWithMemberAndKeySerializer(); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndNonNullMemberAndContentSerializer() throws JsonMappingException { [EOL] SerializerProvider provider = createMockSerializerProvider(); [EOL] BeanProperty property = createMockBeanPropertyWithMemberAndContentSerializer(); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndNonNullMemberAndBothSerializers() throws JsonMappingException { [EOL] SerializerProvider provider = createMockSerializerProvider(); [EOL] BeanProperty property = createMockBeanPropertyWithMemberAndBothSerializers(); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public void testCreateContextualWithNonNullPropertyAndNonNullMemberAndIgnoredEntries() throws JsonMappingException { [EOL] SerializerProvider provider = createMockSerializerProvider(); [EOL] BeanProperty property = createMockBeanPropertyWithMemberAndIgnoredEntries(); [EOL] JsonSerializer<?> result = createContextual(provider, property); [EOL] assertNotNull(result); [EOL] }
public void testSerializeEmptyMap() throws IOException { [EOL] Map<?, ?> emptyMap = Collections.emptyMap(); [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] serialize(emptyMap, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeStartObject(); [EOL] verify(mockJsonGenerator).writeEndObject(); [EOL] verifyNoMoreInteractions(mockJsonGenerator); [EOL] }
public void testSerializeNonEmptyMapWithoutOrdering() throws IOException { [EOL] Map<String, String> nonEmptyMap = new HashMap<>(); [EOL] nonEmptyMap.put("key", "value"); [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] when(mockProvider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)).thenReturn(false); [EOL] serialize(nonEmptyMap, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeStartObject(); [EOL] verify(mockJsonGenerator, times(1)).writeFieldName(anyString()); [EOL] verify(mockJsonGenerator, times(1)).writeString(anyString()); [EOL] verify(mockJsonGenerator).writeEndObject(); [EOL] }
public void testSerializeNonEmptyMapWithOrdering() throws IOException { [EOL] Map<String, String> nonEmptyMap = new TreeMap<>(); [EOL] nonEmptyMap.put("b", "value2"); [EOL] nonEmptyMap.put("a", "value1"); [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] when(mockProvider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)).thenReturn(true); [EOL] serialize(nonEmptyMap, mockJsonGenerator, mockProvider); [EOL] verify(mockJsonGenerator).writeStartObject(); [EOL] InOrder inOrder = inOrder(mockJsonGenerator); [EOL] inOrder.verify(mockJsonGenerator).writeFieldName("a"); [EOL] inOrder.verify(mockJsonGenerator).writeString("value1"); [EOL] inOrder.verify(mockJsonGenerator).writeFieldName("b"); [EOL] inOrder.verify(mockJsonGenerator).writeString("value2"); [EOL] verify(mockJsonGenerator).writeEndObject(); [EOL] }
public void testSerializeWithNonNullValueSerializer() throws IOException { [EOL] Map<String, String> nonEmptyMap = new HashMap<>(); [EOL] nonEmptyMap.put("key", "value"); [EOL] JsonGenerator mockJsonGenerator = mock(JsonGenerator.class); [EOL] SerializerProvider mockProvider = mock(SerializerProvider.class); [EOL] JsonSerializer<Object> mockValueSerializer = mock(JsonSerializer.class); [EOL] when(mockProvider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)).thenReturn(false); [EOL] serializeFieldsUsing(nonEmptyMap, mockJsonGenerator, mockProvider, mockValueSerializer); [EOL] verify(mockJsonGenerator).writeStartObject(); [EOL] verify(mockValueSerializer, times(1)).serialize(anyString(), any(JsonGenerator.class), any(SerializerProvider.class)); [EOL] verify(mockJsonGenerator).writeEndObject(); [EOL] }
public void testOrderEntriesWithSortedMap() { [EOL] SortedMap<Object, Object> input = new TreeMap<>(); [EOL] input.put("key1", "value1"); [EOL] input.put("key2", "value2"); [EOL] Map<?, ?> result = _orderEntries(input); [EOL] assertSame("Expected the same map to be returned", input, result); [EOL] }
public void testOrderEntriesWithNonSortedMap() { [EOL] Map<Object, Object> input = new HashMap<>(); [EOL] input.put("key1", "value1"); [EOL] input.put("key2", "value2"); [EOL] Map<?, ?> result = _orderEntries(input); [EOL] assertTrue("Expected a new TreeMap to be returned", result instanceof TreeMap); [EOL] assertEquals("Expected the same size for input and result", input.size(), result.size()); [EOL] assertTrue("Expected the same content in both maps", result.entrySet().containsAll(input.entrySet())); [EOL] }
public void testMapDeserializerConstructor() { [EOL] JavaType mapType = TypeFactory.defaultInstance().constructMapType(HashMap.class, String.class, Object.class); [EOL] KeyDeserializer keyDeser = mock(KeyDeserializer.class); [EOL] JsonDeserializer<Object> valueDeser = mock(JsonDeserializer.class); [EOL] TypeDeserializer valueTypeDeser = mock(TypeDeserializer.class); [EOL] HashSet<String> ignorable = new HashSet<>(Arrays.asList("ignoreMe")); [EOL] MapDeserializer src = new MapDeserializer(mapType, null, null, null, null, null); [EOL] MapDeserializer deserializer = new MapDeserializer(src, keyDeser, valueDeser, valueTypeDeser, ignorable); [EOL] assertEquals(mapType, deserializer._mapType); [EOL] assertEquals(keyDeser, deserializer._keyDeserializer); [EOL] assertEquals(valueDeser, deserializer._valueDeserializer); [EOL] assertEquals(valueTypeDeser, deserializer._valueTypeDeserializer); [EOL] assertEquals(src._valueInstantiator, deserializer._valueInstantiator); [EOL] assertEquals(src._propertyBasedCreator, deserializer._propertyBasedCreator); [EOL] assertEquals(src._delegateDeserializer, deserializer._delegateDeserializer); [EOL] assertEquals(src._hasDefaultCreator, deserializer._hasDefaultCreator); [EOL] assertEquals(ignorable, deserializer._ignorableProperties); [EOL] assertEquals(MapDeserializer._isStdKeyDeser(mapType, keyDeser), deserializer._standardStringKey); [EOL] }
public void testWithResolvedSameObjects() { [EOL] KeyDeserializer keyDeser = mock(KeyDeserializer.class); [EOL] TypeDeserializer valueTypeDeser = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> valueDeser = mock(JsonDeserializer.class); [EOL] HashSet<String> ignorable = new HashSet<>(); [EOL] MapDeserializer instance = new MapDeserializer(null, keyDeser, valueDeser, valueTypeDeser, ignorable); [EOL] MapDeserializer result = instance.withResolved(keyDeser, valueTypeDeser, valueDeser, ignorable); [EOL] assertSame(instance, result); [EOL] }
public void testWithResolvedDifferentObjects() { [EOL] KeyDeserializer keyDeser1 = mock(KeyDeserializer.class); [EOL] KeyDeserializer keyDeser2 = mock(KeyDeserializer.class); [EOL] TypeDeserializer valueTypeDeser1 = mock(TypeDeserializer.class); [EOL] TypeDeserializer valueTypeDeser2 = mock(TypeDeserializer.class); [EOL] JsonDeserializer<?> valueDeser1 = mock(JsonDeserializer.class); [EOL] JsonDeserializer<?> valueDeser2 = mock(JsonDeserializer.class); [EOL] HashSet<String> ignorable1 = new HashSet<>(); [EOL] HashSet<String> ignorable2 = new HashSet<>(); [EOL] ignorable2.add("test"); [EOL] MapDeserializer instance = new MapDeserializer(null, keyDeser1, valueDeser1, valueTypeDeser1, ignorable1); [EOL] MapDeserializer result = instance.withResolved(keyDeser2, valueTypeDeser2, valueDeser2, ignorable2); [EOL] assertNotSame(instance, result); [EOL] assertNotSame(keyDeser1, result.getKeyDeserializer()); [EOL] assertNotSame(valueDeser1, result.getValueDeserializer()); [EOL] assertNotSame(valueTypeDeser1, result.getValueTypeDeserializer()); [EOL] assertNotSame(ignorable1, result.getIgnorableProperties()); [EOL] }
public void testIsStdKeyDeserWithNullKeyDeserializer() { [EOL] JavaType mapType = mock(JavaType.class); [EOL] boolean result = _isStdKeyDeser(mapType, null); [EOL] assertTrue(result); [EOL] }
public void testIsStdKeyDeserWithNullKeyType() { [EOL] JavaType mapType = mock(JavaType.class); [EOL] when(mapType.getKeyType()).thenReturn(null); [EOL] KeyDeserializer keyDeser = mock(KeyDeserializer.class); [EOL] boolean result = _isStdKeyDeser(mapType, keyDeser); [EOL] assertTrue(result); [EOL] }
public void testIsStdKeyDeserWithStringClass() { [EOL] JavaType mapType = mock(JavaType.class); [EOL] JavaType keyType = mock(JavaType.class); [EOL] when(mapType.getKeyType()).thenReturn(keyType); [EOL] when(keyType.getRawClass()).thenReturn(String.class); [EOL] KeyDeserializer keyDeser = mock(KeyDeserializer.class); [EOL] when(isDefaultKeyDeserializer(keyDeser)).thenReturn(true); [EOL] boolean result = _isStdKeyDeser(mapType, keyDeser); [EOL] assertTrue(result); [EOL] }
public void testIsStdKeyDeserWithObjectClass() { [EOL] JavaType mapType = mock(JavaType.class); [EOL] JavaType keyType = mock(JavaType.class); [EOL] when(mapType.getKeyType()).thenReturn(keyType); [EOL] when(keyType.getRawClass()).thenReturn(Object.class); [EOL] KeyDeserializer keyDeser = mock(KeyDeserializer.class); [EOL] when(isDefaultKeyDeserializer(keyDeser)).thenReturn(true); [EOL] boolean result = _isStdKeyDeser(mapType, keyDeser); [EOL] assertTrue(result); [EOL] }
public void testIsStdKeyDeserWithNonStdKeyClass() { [EOL] JavaType mapType = mock(JavaType.class); [EOL] JavaType keyType = mock(JavaType.class); [EOL] when(mapType.getKeyType()).thenReturn(keyType); [EOL] when(keyType.getRawClass()).thenReturn(Integer.class); [EOL] KeyDeserializer keyDeser = mock(KeyDeserializer.class); [EOL] when(isDefaultKeyDeserializer(keyDeser)).thenReturn(false); [EOL] boolean result = _isStdKeyDeser(mapType, keyDeser); [EOL] assertFalse(result); [EOL] }
public void testResolveWithDelegateTypeNull() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.getConfig()).thenReturn(mock(DeserializationConfig.class)); [EOL] when(_valueInstantiator.canCreateUsingDelegate()).thenReturn(true); [EOL] when(_valueInstantiator.getDelegateType(any(DeserializationConfig.class))).thenReturn(null); [EOL] try { [EOL] resolve(ctxt); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testResolveWithDelegateTypeNotNull() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.getConfig()).thenReturn(mock(DeserializationConfig.class)); [EOL] when(_valueInstantiator.canCreateUsingDelegate()).thenReturn(true); [EOL] JavaType delegateType = mock(JavaType.class); [EOL] when(_valueInstantiator.getDelegateType(any(DeserializationConfig.class))).thenReturn(delegateType); [EOL] when(findDeserializer(ctxt, delegateType, null)).thenReturn(mock(JsonDeserializer.class)); [EOL] resolve(ctxt); [EOL] assertNotNull(_delegateDeserializer); [EOL] }
public void testResolveCanCreateFromObjectWith() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.getConfig()).thenReturn(mock(DeserializationConfig.class)); [EOL] when(_valueInstantiator.canCreateUsingDelegate()).thenReturn(false); [EOL] when(_valueInstantiator.canCreateFromObjectWith()).thenReturn(true); [EOL] SettableBeanProperty[] creatorProps = new SettableBeanProperty[0]; [EOL] when(_valueInstantiator.getFromObjectArguments(any(DeserializationConfig.class))).thenReturn(creatorProps); [EOL] resolve(ctxt); [EOL] assertNotNull(_propertyBasedCreator); [EOL] }
public void testResolveStandardStringKey() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(ctxt.getConfig()).thenReturn(mock(DeserializationConfig.class)); [EOL] when(_valueInstantiator.canCreateUsingDelegate()).thenReturn(false); [EOL] when(_valueInstantiator.canCreateFromObjectWith()).thenReturn(false); [EOL] resolve(ctxt); [EOL] assertEquals(_standardStringKey, _isStdKeyDeser(_mapType, _keyDeserializer)); [EOL] }
public void testCreateContextualWithNullKeyDeserializerAndValueDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JavaType keyType = mock(JavaType.class); [EOL] JavaType contentType = mock(JavaType.class); [EOL] KeyDeserializer keyDeserializer = null; [EOL] JsonDeserializer<?> valueDeserializer = null; [EOL] TypeDeserializer valueTypeDeserializer = null; [EOL] HashSet<String> ignorableProperties = null; [EOL] when(_mapType.getKeyType()).thenReturn(keyType); [EOL] when(_mapType.getContentType()).thenReturn(contentType); [EOL] when(ctxt.findKeyDeserializer(keyType, property)).thenReturn(keyDeserializer); [EOL] when(ctxt.findContextualValueDeserializer(contentType, property)).thenReturn(valueDeserializer); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] verify(ctxt).findKeyDeserializer(keyType, property); [EOL] verify(ctxt).findContextualValueDeserializer(contentType, property); [EOL] }
public void testCreateContextualWithNonNullKeyDeserializerAndValueDeserializer() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] KeyDeserializer keyDeserializer = mock(KeyDeserializer.class); [EOL] JsonDeserializer<?> valueDeserializer = mock(JsonDeserializer.class); [EOL] TypeDeserializer valueTypeDeserializer = mock(TypeDeserializer.class); [EOL] HashSet<String> ignorableProperties = new HashSet<>(); [EOL] ignorableProperties.add("propertyToIgnore"); [EOL] when(_mapType.getKeyType()).thenReturn(mock(JavaType.class)); [EOL] when(_mapType.getContentType()).thenReturn(mock(JavaType.class)); [EOL] when(_keyDeserializer).thenReturn(keyDeserializer); [EOL] when(_valueDeserializer).thenReturn(valueDeserializer); [EOL] when(_valueTypeDeserializer).thenReturn(valueTypeDeserializer); [EOL] when(_ignorableProperties).thenReturn(ignorableProperties); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(mock(AnnotationIntrospector.class)); [EOL] when(ctxt.getAnnotationIntrospector().findPropertiesToIgnore(any())).thenReturn(new String[]{"propertyToIgnore"}); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MyCustomDeserializer); // Assuming withResolved returns an instance of MyCustomDeserializer [EOL] verify(ctxt, never()).findKeyDeserializer(any(), any()); [EOL] verify(ctxt, never()).findContextualValueDeserializer(any(), any()); [EOL] }
public void testCreateContextualWithAnnotations() throws JsonMappingException { [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] AnnotationIntrospector intr = mock(AnnotationIntrospector.class); [EOL] KeyDeserializer keyDeserializer = mock(KeyDeserializer.class); [EOL] JsonDeserializer<?> valueDeserializer = mock(JsonDeserializer.class); [EOL] TypeDeserializer valueTypeDeserializer = mock(TypeDeserializer.class); [EOL] HashSet<String> ignorableProperties = new HashSet<>(); [EOL] when(_mapType.getKeyType()).thenReturn(mock(JavaType.class)); [EOL] when(_mapType.getContentType()).thenReturn(mock(JavaType.class)); [EOL] when(_keyDeserializer).thenReturn(keyDeserializer); [EOL] when(_valueDeserializer).thenReturn(valueDeserializer); [EOL] when(_valueTypeDeserializer).thenReturn(valueTypeDeserializer); [EOL] when(_ignorableProperties).thenReturn(ignorableProperties); [EOL] when(ctxt.getAnnotationIntrospector()).thenReturn(intr); [EOL] when(intr.findPropertiesToIgnore(any())).thenReturn(new String[]{"propertyToIgnore"}); [EOL] JsonDeserializer<?> result = createContextual(ctxt, property); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof MyCustomDeserializer); // Assuming withResolved returns an instance of MyCustomDeserializer [EOL] verify(intr).findPropertiesToIgnore(any()); [EOL] assertEquals(1, ignorableProperties.size()); [EOL] assertTrue(ignorableProperties.contains("propertyToIgnore")); [EOL] }
public void testDeserializeWithPropertyBasedCreator() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_propertyBasedCreator).thenReturn(true); [EOL] Map<Object, Object> result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithDelegateDeserializer() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_propertyBasedCreator).thenReturn(null); [EOL] when(_delegateDeserializer).thenReturn(true); [EOL] Map<Object, Object> result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithoutDefaultCreator() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_propertyBasedCreator).thenReturn(null); [EOL] when(_delegateDeserializer).thenReturn(null); [EOL] when(_hasDefaultCreator).thenReturn(false); [EOL] assertThrows(JsonMappingException.class, () -> { [EOL] deserialize(jp, ctxt); [EOL] }); [EOL] }
public void testDeserializeFromStringValue() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.VALUE_STRING); [EOL] when(jp.getText()).thenReturn("string value"); [EOL] Map<Object, Object> result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithStartObjectToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] Map<Object, Object> result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithFieldNameToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.FIELD_NAME); [EOL] Map<Object, Object> result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithEndObjectToken() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.END_OBJECT); [EOL] Map<Object, Object> result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testDeserializeWithStandardStringKey() throws IOException, JsonProcessingException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] when(_standardStringKey).thenReturn(true); [EOL] Map<Object, Object> result = deserialize(jp, ctxt); [EOL] assertNotNull(result); [EOL] }
public void testReadAndBindStringMapWithStartObjectToken() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> result = new HashMap<>(); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeser = null; [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.VALUE_STRING, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("key"); [EOL] when(valueDes.deserialize(jp, ctxt)).thenReturn("value"); [EOL] _readAndBindStringMap(jp, ctxt, result); [EOL] assertEquals("value", result.get("key")); [EOL] }
public void testReadAndBindStringMapWithIgnorableProperty() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> result = new HashMap<>(); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] Set<String> ignorableProperties = new HashSet<>(); [EOL] ignorableProperties.add("key"); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("key"); [EOL] this._ignorableProperties = ignorableProperties; [EOL] _readAndBindStringMap(jp, ctxt, result); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testReadAndBindStringMapWithValueNull() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> result = new HashMap<>(); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeser = null; [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.VALUE_NULL, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("key"); [EOL] _readAndBindStringMap(jp, ctxt, result); [EOL] assertNull(result.get("key")); [EOL] }
public void testReadAndBindStringMapWithTypeDeserializer() throws IOException { [EOL] JsonParser jp = mock(JsonParser.class); [EOL] DeserializationContext ctxt = mock(DeserializationContext.class); [EOL] Map<Object, Object> result = new HashMap<>(); [EOL] JsonDeserializer<Object> valueDes = mock(JsonDeserializer.class); [EOL] TypeDeserializer typeDeser = mock(TypeDeserializer.class); [EOL] when(jp.getCurrentToken()).thenReturn(JsonToken.START_OBJECT); [EOL] when(jp.nextToken()).thenReturn(JsonToken.FIELD_NAME, JsonToken.VALUE_STRING, JsonToken.END_OBJECT); [EOL] when(jp.getCurrentName()).thenReturn("key"); [EOL] when(valueDes.deserializeWithType(jp, ctxt, typeDeser)).thenReturn("typedValue"); [EOL] this._valueTypeDeserializer = typeDeser; [EOL] _readAndBindStringMap(jp, ctxt, result); [EOL] assertEquals("typedValue", result.get("key")); [EOL] }
public void testFormatWithNullDate() { [EOL] String result = ClassName.format(null); [EOL] assertNull(result); [EOL] }
public void testFormatWithNonNullDate() { [EOL] Date date = new Date(); [EOL] String result = ClassName.format(date); [EOL] assertNotNull(result); [EOL] assertTrue(result.matches("\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}")); [EOL] }
public void testFormatWithMillisAndZuluTimeZone() { [EOL] Date date = new Date(); [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] String result = YourClass.format(date, true, tz); [EOL] assertTrue(result.endsWith("Z") || result.contains("+00:00") || result.contains("-00:00")); [EOL] }
public void testFormatWithoutMillisAndZuluTimeZone() { [EOL] Date date = new Date(); [EOL] TimeZone tz = TimeZone.getTimeZone("UTC"); [EOL] String result = YourClass.format(date, false, tz); [EOL] assertTrue(result.endsWith("Z") && !result.contains(".")); [EOL] }
public void testFormatWithMillisAndNonZuluTimeZone() { [EOL] Date date = new Date(); [EOL] TimeZone tz = TimeZone.getTimeZone("GMT+2"); [EOL] String result = YourClass.format(date, true, tz); [EOL] assertTrue(result.contains("+") && result.contains(".")); [EOL] }
public void testFormatWithoutMillisAndNonZuluTimeZone() { [EOL] Date date = new Date(); [EOL] TimeZone tz = TimeZone.getTimeZone("GMT-2"); [EOL] String result = YourClass.format(date, false, tz); [EOL] assertTrue(result.contains("-") && !result.contains(".")); [EOL] }
public void testPadIntWithExactLength() { [EOL] StringBuilder buffer = new StringBuilder(); [EOL] int value = 123; [EOL] int length = 3; [EOL] padInt(buffer, value, length); [EOL] assertEquals("123", buffer.toString()); [EOL] }
public void testPadIntWithGreaterLength() { [EOL] StringBuilder buffer = new StringBuilder(); [EOL] int value = 1; [EOL] int length = 5; [EOL] padInt(buffer, value, length); [EOL] assertEquals("00001", buffer.toString()); [EOL] }
public void testPadIntWithZeroLength() { [EOL] StringBuilder buffer = new StringBuilder(); [EOL] int value = 123; [EOL] int length = 0; [EOL] padInt(buffer, value, length); [EOL] assertEquals("123", buffer.toString()); [EOL] }
public void testPadIntWithNegativeLength() { [EOL] StringBuilder buffer = new StringBuilder(); [EOL] int value = 123; [EOL] int length = -1; [EOL] padInt(buffer, value, length); [EOL] assertEquals("123", buffer.toString()); [EOL] }
public void testStdConstructorWithAllVisibilityPublic() { [EOL] Std std = new Std(Visibility.PUBLIC, Visibility.PUBLIC, Visibility.PUBLIC, Visibility.PUBLIC, Visibility.PUBLIC); [EOL] assertEquals(Visibility.PUBLIC, std._getterMinLevel); [EOL] assertEquals(Visibility.PUBLIC, std._isGetterMinLevel); [EOL] assertEquals(Visibility.PUBLIC, std._setterMinLevel); [EOL] assertEquals(Visibility.PUBLIC, std._creatorMinLevel); [EOL] assertEquals(Visibility.PUBLIC, std._fieldMinLevel); [EOL] }
public void testStdConstructorWithAllVisibilityNone() { [EOL] Std std = new Std(Visibility.NONE, Visibility.NONE, Visibility.NONE, Visibility.NONE, Visibility.NONE); [EOL] assertEquals(Visibility.NONE, std._getterMinLevel); [EOL] assertEquals(Visibility.NONE, std._isGetterMinLevel); [EOL] assertEquals(Visibility.NONE, std._setterMinLevel); [EOL] assertEquals(Visibility.NONE, std._creatorMinLevel); [EOL] assertEquals(Visibility.NONE, std._fieldMinLevel); [EOL] }
public void testStdConstructorWithMixedVisibility() { [EOL] Std std = new Std(Visibility.PUBLIC, Visibility.NONE, Visibility.ANY, Visibility.DEFAULT, Visibility.PRIVATE); [EOL] assertEquals(Visibility.PUBLIC, std._getterMinLevel); [EOL] assertEquals(Visibility.NONE, std._isGetterMinLevel); [EOL] assertEquals(Visibility.ANY, std._setterMinLevel); [EOL] assertEquals(Visibility.DEFAULT, std._creatorMinLevel); [EOL] assertEquals(Visibility.PRIVATE, std._fieldMinLevel); [EOL] }
public void testWithNonNullJsonAutoDetect() { [EOL] JsonAutoDetect ann = mock(JsonAutoDetect.class); [EOL] when(ann.getterVisibility()).thenReturn(JsonAutoDetect.Visibility.ANY); [EOL] when(ann.isGetterVisibility()).thenReturn(JsonAutoDetect.Visibility.NONE); [EOL] when(ann.setterVisibility()).thenReturn(JsonAutoDetect.Visibility.DEFAULT); [EOL] when(ann.creatorVisibility()).thenReturn(JsonAutoDetect.Visibility.PUBLIC_ONLY); [EOL] when(ann.fieldVisibility()).thenReturn(JsonAutoDetect.Visibility.PROTECTED_AND_PUBLIC); [EOL] Std std = new Std(JsonAutoDetect.Visibility.DEFAULT, [EOL] JsonAutoDetect.Visibility.DEFAULT, [EOL] JsonAutoDetect.Visibility.DEFAULT, [EOL] JsonAutoDetect.Visibility.DEFAULT, [EOL] JsonAutoDetect.Visibility.DEFAULT); [EOL] Std result = std.with(ann); [EOL] assertNotSame(std, result); [EOL] assertEquals(JsonAutoDetect.Visibility.ANY, result.getGetterVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.NONE, result.getIsGetterVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.DEFAULT, result.getSetterVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.PUBLIC_ONLY, result.getCreatorVisibility()); [EOL] assertEquals(JsonAutoDetect.Visibility.PROTECTED_AND_PUBLIC, result.getFieldVisibility()); [EOL] }
public void testWithNullJsonAutoDetect() { [EOL] Std std = new Std(JsonAutoDetect.Visibility.DEFAULT, [EOL] JsonAutoDetect.Visibility.DEFAULT, [EOL] JsonAutoDetect.Visibility.DEFAULT, [EOL] JsonAutoDetect.Visibility.DEFAULT, [EOL] JsonAutoDetect.Visibility.DEFAULT); [EOL] Std result = std.with(null); [EOL] assertSame(std, result); [EOL] }
public void testWithGetterVisibility_Default() { [EOL] Std std = new Std(Visibility.ANY, true, Visibility.NONE, Visibility.DEFAULT, Visibility.PUBLIC); [EOL] Std result = std.withGetterVisibility(Visibility.DEFAULT); [EOL] assertSame("Should return the same Std instance for default visibility", std, result); [EOL] }
public void testWithGetterVisibility_NonDefault() { [EOL] Std std = new Std(Visibility.ANY, true, Visibility.NONE, Visibility.DEFAULT, Visibility.PUBLIC); [EOL] Std result = std.withGetterVisibility(Visibility.PUBLIC); [EOL] assertNotSame("Should return a new Std instance for non-default visibility", std, result); [EOL] assertEquals("Getter visibility should be changed to PUBLIC", Visibility.PUBLIC, result.getGetterVisibility()); [EOL] }
public void testWithIsGetterVisibility_Default() { [EOL] Std std = new Std(Visibility.ANY, Visibility.ANY, Visibility.ANY, Visibility.ANY, Visibility.ANY); [EOL] Std result = std.withIsGetterVisibility(Visibility.DEFAULT); [EOL] assertSame("Expected same instance when passing DEFAULT visibility", std, result); [EOL] }
public void testWithIsGetterVisibility_NonDefault() { [EOL] Std std = new Std(Visibility.ANY, Visibility.ANY, Visibility.ANY, Visibility.ANY, Visibility.ANY); [EOL] Std result = std.withIsGetterVisibility(Visibility.NONE); [EOL] assertNotSame("Expected different instance when passing non-default visibility", std, result); [EOL] assertEquals("Expected NONE visibility for isGetter", Visibility.NONE, result.getIsGetterVisibility()); [EOL] }
public void testWithSetterVisibility_Default() { [EOL] Std std = new Std(Visibility.ANY, Visibility.ANY, Visibility.DEFAULT, Visibility.ANY, Visibility.ANY); [EOL] Std result = std.withSetterVisibility(Visibility.DEFAULT); [EOL] assertSame("Expected same instance when setting default visibility", std, result); [EOL] }
public void testWithSetterVisibility_NonDefault() { [EOL] Std std = new Std(Visibility.ANY, Visibility.ANY, Visibility.DEFAULT, Visibility.ANY, Visibility.ANY); [EOL] Std result = std.withSetterVisibility(Visibility.NONE); [EOL] assertNotSame("Expected different instance when setting non-default visibility", std, result); [EOL] assertEquals("Expected NONE visibility", Visibility.NONE, result.getSetterVisibility()); [EOL] }
public void testWithCreatorVisibility_Default() { [EOL] Std std = new Std(Visibility.ANY, Visibility.ANY, Visibility.ANY, Visibility.DEFAULT, Visibility.ANY); [EOL] Std result = std.withCreatorVisibility(Visibility.DEFAULT); [EOL] assertSame(std, result); [EOL] }
public void testWithCreatorVisibility_NonDefault() { [EOL] Std std = new Std(Visibility.ANY, Visibility.ANY, Visibility.ANY, Visibility.DEFAULT, Visibility.ANY); [EOL] Std result = std.withCreatorVisibility(Visibility.NONE); [EOL] assertNotSame(std, result); [EOL] assertEquals(Visibility.NONE, result.getCreatorVisibility()); [EOL] }
public void testWithFieldVisibility_DefaultVisibility() { [EOL] Std std = new Std(Visibility.ANY, Visibility.ANY, Visibility.ANY, Visibility.ANY, Visibility.DEFAULT); [EOL] Std result = std.withFieldVisibility(Visibility.DEFAULT); [EOL] assertSame("Should return the same Std instance for default visibility", std, result); [EOL] }
public void testWithFieldVisibility_NonDefaultVisibilitySameAsCurrent() { [EOL] Std std = new Std(Visibility.ANY, Visibility.ANY, Visibility.ANY, Visibility.ANY, Visibility.PUBLIC_ONLY); [EOL] Std result = std.withFieldVisibility(Visibility.PUBLIC_ONLY); [EOL] assertSame("Should return the same Std instance for same non-default visibility", std, result); [EOL] }
public void testWithFieldVisibility_NonDefaultVisibilityDifferent() { [EOL] Std std = new Std(Visibility.ANY, Visibility.ANY, Visibility.ANY, Visibility.ANY, Visibility.PUBLIC_ONLY); [EOL] Std result = std.withFieldVisibility(Visibility.PROTECTED_AND_PUBLIC); [EOL] assertNotSame("Should return a new Std instance for different non-default visibility", std, result); [EOL] assertEquals("The field visibility should be PROTECTED_AND_PUBLIC", Visibility.PROTECTED_AND_PUBLIC, result.getFieldVisibility()); [EOL] }
public void testWrapWithPath_NullSrc() { [EOL] Throwable src = null; [EOL] Object refFrom = new Object(); [EOL] String refFieldName = "fieldName"; [EOL] try { [EOL] JsonMappingException exception = wrapWithPath(src, refFrom, refFieldName); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testWrapWithPath_NullRefFrom() { [EOL] Throwable src = new Exception("Test exception"); [EOL] Object refFrom = null; [EOL] String refFieldName = "fieldName"; [EOL] JsonMappingException exception = wrapWithPath(src, refFrom, refFieldName); [EOL] assertNotNull(exception); [EOL] assertEquals("Test exception", exception.getOriginalMessage()); [EOL] assertNotNull(exception.getPath()); [EOL] assertEquals(1, exception.getPath().size()); [EOL] assertNull(exception.getPath().get(0).getFrom()); [EOL] assertEquals(refFieldName, exception.getPath().get(0).getFieldName()); [EOL] }
public void testWrapWithPath_NullRefFieldName() { [EOL] Throwable src = new Exception("Test exception"); [EOL] Object refFrom = new Object(); [EOL] String refFieldName = null; [EOL] JsonMappingException exception = wrapWithPath(src, refFrom, refFieldName); [EOL] assertNotNull(exception); [EOL] assertEquals("Test exception", exception.getOriginalMessage()); [EOL] assertNotNull(exception.getPath()); [EOL] assertEquals(1, exception.getPath().size()); [EOL] assertEquals(refFrom, exception.getPath().get(0).getFrom()); [EOL] assertNull(exception.getPath().get(0).getFieldName()); [EOL] }
public void testWrapWithPath_ValidArguments() { [EOL] Throwable src = new Exception("Test exception"); [EOL] Object refFrom = new Object(); [EOL] String refFieldName = "fieldName"; [EOL] JsonMappingException exception = wrapWithPath(src, refFrom, refFieldName); [EOL] assertNotNull(exception); [EOL] assertEquals("Test exception", exception.getOriginalMessage()); [EOL] assertNotNull(exception.getPath()); [EOL] assertEquals(1, exception.getPath().size()); [EOL] assertEquals(refFrom, exception.getPath().get(0).getFrom()); [EOL] assertEquals(refFieldName, exception.getPath().get(0).getFieldName()); [EOL] }
public void testWrapWithPath_WithJsonMappingException() { [EOL] Throwable src = new JsonMappingException("Error message"); [EOL] Reference ref = new Reference(new Object(), "testField"); [EOL] JsonMappingException result = JsonMappingException.wrapWithPath(src, ref); [EOL] assertNotNull(result); [EOL] assertEquals("Error message", result.getMessage()); [EOL] assertEquals(ref, result.getPath().get(0)); [EOL] }
public void testWrapWithPath_WithNonJsonMappingExceptionAndNonNullMessage() { [EOL] Throwable src = new Exception("Error message"); [EOL] Reference ref = new Reference(new Object(), "testField"); [EOL] JsonMappingException result = JsonMappingException.wrapWithPath(src, ref); [EOL] assertNotNull(result); [EOL] assertEquals("Error message", result.getMessage()); [EOL] assertEquals(ref, result.getPath().get(0)); [EOL] }
public void testWrapWithPath_WithNonJsonMappingExceptionAndNullMessage() { [EOL] Throwable src = new Exception(); [EOL] Reference ref = new Reference(new Object(), "testField"); [EOL] JsonMappingException result = JsonMappingException.wrapWithPath(src, ref); [EOL] assertNotNull(result); [EOL] assertTrue(result.getMessage().contains("was java.lang.Exception")); [EOL] assertEquals(ref, result.getPath().get(0)); [EOL] }
public void testWrapWithPath_WithNonJsonMappingExceptionAndEmptyMessage() { [EOL] Throwable src = new Exception(""); [EOL] Reference ref = new Reference(new Object(), "testField"); [EOL] JsonMappingException result = JsonMappingException.wrapWithPath(src, ref); [EOL] assertNotNull(result); [EOL] assertTrue(result.getMessage().contains("was java.lang.Exception")); [EOL] assertEquals(ref, result.getPath().get(0)); [EOL] }
public void testSerializerProviderConstructor() { [EOL] SerializerProvider provider = new SerializerProvider(); [EOL] assertNull(provider.getConfig()); [EOL] assertNull(provider.getSerializerFactory()); [EOL] assertNotNull(provider.getSerializerCache()); [EOL] assertNull(provider.getKnownSerializers()); [EOL] assertNotNull(provider.getRootNames()); [EOL] assertNull(provider.getSerializationView()); [EOL] }
public void testSerializerProviderWithNullConfig() { [EOL] SerializerProvider src = createMockSerializerProvider(); [EOL] SerializerFactory f = createMockSerializerFactory(); [EOL] try { [EOL] new SerializerProvider(null, null, f); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] } [EOL] public void testSerializerProviderWithNonNullConfig() { [EOL] SerializerProvider src = createMockSerializerProvider(); [EOL] SerializationConfig config = createMockSerializationConfig(); [EOL] SerializerFactory f = createMockSerializerFactory(); [EOL] SerializerProvider provider = new SerializerProvider(src, config, f); [EOL] assertNotNull(provider); [EOL] }

public void testGetConfig() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] assertNotNull(config); [EOL] }
public void testGetTypeFactory() { [EOL] ObjectMapper objectMapper = new ObjectMapper(); [EOL] TypeFactory typeFactory = objectMapper.getTypeFactory(); [EOL] assertNotNull(typeFactory); [EOL] }
public void testFindValueSerializerWithKnownSerializer() { [EOL] JavaType valueType = ...; // Initialize with a proper JavaType [EOL] BeanProperty property = ...; // Initialize with a proper BeanProperty [EOL] JsonSerializer<Object> expectedSerializer = ...; // Initialize with a proper JsonSerializer [EOL] _knownSerializers.untypedValueSerializer(valueType).thenReturn(expectedSerializer); [EOL] JsonSerializer<Object> actualSerializer = findValueSerializer(valueType, property); [EOL] assertNotNull(actualSerializer); [EOL] assertSame(expectedSerializer, actualSerializer); [EOL] }
public void testFindValueSerializerWithCacheSerializer() { [EOL] JavaType valueType = ...; // Initialize with a proper JavaType [EOL] BeanProperty property = ...; // Initialize with a proper BeanProperty [EOL] JsonSerializer<Object> expectedSerializer = ...; // Initialize with a proper JsonSerializer [EOL] _knownSerializers.untypedValueSerializer(valueType).thenReturn(null); [EOL] _serializerCache.untypedValueSerializer(valueType).thenReturn(expectedSerializer); [EOL] JsonSerializer<Object> actualSerializer = findValueSerializer(valueType, property); [EOL] assertNotNull(actualSerializer); [EOL] assertSame(expectedSerializer, actualSerializer); [EOL] }
public void testFindValueSerializerWithCreateAndCacheSerializer() { [EOL] JavaType valueType = ...; // Initialize with a proper JavaType [EOL] BeanProperty property = ...; // Initialize with a proper BeanProperty [EOL] JsonSerializer<Object> expectedSerializer = ...; // Initialize with a proper JsonSerializer [EOL] _knownSerializers.untypedValueSerializer(valueType).thenReturn(null); [EOL] _serializerCache.untypedValueSerializer(valueType).thenReturn(null); [EOL] _createAndCacheUntypedSerializer(valueType).thenReturn(expectedSerializer); [EOL] JsonSerializer<Object> actualSerializer = findValueSerializer(valueType, property); [EOL] assertNotNull(actualSerializer); [EOL] assertSame(expectedSerializer, actualSerializer); [EOL] }
public void testFindValueSerializerWithUnknownTypeSerializer() { [EOL] JavaType valueType = ...; // Initialize with a proper JavaType [EOL] BeanProperty property = ...; // Initialize with a proper BeanProperty [EOL] JsonSerializer<Object> expectedSerializer = ...; // Initialize with a proper JsonSerializer [EOL] _knownSerializers.untypedValueSerializer(valueType).thenReturn(null); [EOL] _serializerCache.untypedValueSerializer(valueType).thenReturn(null); [EOL] _createAndCacheUntypedSerializer(valueType).thenReturn(null); [EOL] getUnknownTypeSerializer(valueType.getRawClass()).thenReturn(expectedSerializer); [EOL] JsonSerializer<Object> actualSerializer = findValueSerializer(valueType, property); [EOL] assertNotNull(actualSerializer); [EOL] assertSame(expectedSerializer, actualSerializer); [EOL] }
public void testFindKeySerializerWithNonNullProperty() throws JsonMappingException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] SerializerFactory serializerFactory = config.getSerializerFactory(); [EOL] JavaType keyType = config.constructType(String.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] JsonSerializer<Object> keySerializer = serializerFactory.createKeySerializer(config, keyType, null); [EOL] JsonSerializer<Object> result = mapper.getSerializerProviderInstance().findKeySerializer(keyType, property); [EOL] assertNotNull(result); [EOL] }
public void testFindKeySerializerWithNullProperty() throws JsonMappingException { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] SerializationConfig config = mapper.getSerializationConfig(); [EOL] SerializerFactory serializerFactory = config.getSerializerFactory(); [EOL] JavaType keyType = config.constructType(String.class); [EOL] JsonSerializer<Object> keySerializer = serializerFactory.createKeySerializer(config, keyType, null); [EOL] JsonSerializer<Object> result = mapper.getSerializerProviderInstance().findKeySerializer(keyType, null); [EOL] assertNotNull(result); [EOL] }
public void testGetDefaultNullKeySerializer() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonSerializer<Object> nullKeySerializer = mapper.getSerializerProvider().getDefaultNullKeySerializer(); [EOL] assertNotNull(nullKeySerializer); [EOL] }
public void testGetDefaultNullValueSerializer() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonSerializer<Object> serializer = mapper.getSerializerProvider().getDefaultNullValueSerializer(); [EOL] assertNotNull(serializer); [EOL] }
public void testFindNullValueSerializerWithNonNullProperty() throws JsonMappingException { [EOL] JsonSerializer<Object> serializer = findNullValueSerializer(new BeanPropertyMock()); [EOL] assertNotNull(serializer); [EOL] }
public void testFindNullValueSerializerWithNullProperty() throws JsonMappingException { [EOL] JsonSerializer<Object> serializer = findNullValueSerializer(null); [EOL] assertNotNull(serializer); [EOL] }
public void testGetUnknownTypeSerializerWithNonNullType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonSerializer<Object> serializer = mapper.getSerializerProvider().getUnknownTypeSerializer(String.class); [EOL] assertNotNull(serializer); [EOL] }
public void testGetUnknownTypeSerializerWithNullType() { [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] JsonSerializer<Object> serializer = mapper.getSerializerProvider().getUnknownTypeSerializer(null); [EOL] assertNotNull(serializer); [EOL] }
public void testFindExplicitUntypedSerializerWithKnownSerializer() throws JsonMappingException { [EOL] Class<?> runtimeType = Object.class; [EOL] JsonSerializer<Object> expectedSerializer = new SomeJsonSerializerImplementation(); [EOL] _knownSerializers = new SerializerCache(); [EOL] _knownSerializers.addAndResolveNonTypedSerializer(runtimeType, null, expectedSerializer); [EOL] _serializerCache = new SerializerCache(); // Assuming this is a different cache [EOL] JsonSerializer<Object> actualSerializer = _findExplicitUntypedSerializer(runtimeType); [EOL] assertNotNull(actualSerializer); [EOL] assertSame(expectedSerializer, actualSerializer); [EOL] }
public void testFindExplicitUntypedSerializerWithSerializerCache() throws JsonMappingException { [EOL] Class<?> runtimeType = Object.class; [EOL] JsonSerializer<Object> expectedSerializer = new SomeJsonSerializerImplementation(); [EOL] _knownSerializers = new SerializerCache(); // Assuming this is an empty cache [EOL] _serializerCache = new SerializerCache(); [EOL] _serializerCache.addAndResolveNonTypedSerializer(runtimeType, null, expectedSerializer); [EOL] JsonSerializer<Object> actualSerializer = _findExplicitUntypedSerializer(runtimeType); [EOL] assertNotNull(actualSerializer); [EOL] assertSame(expectedSerializer, actualSerializer); [EOL] }
public void testFindExplicitUntypedSerializerWithCreateAndCache() throws JsonMappingException { [EOL] Class<?> runtimeType = Object.class; [EOL] _knownSerializers = new SerializerCache(); // Assuming this is an empty cache [EOL] _serializerCache = new SerializerCache(); // Assuming this is an empty cache [EOL] JsonSerializer<Object> actualSerializer = _findExplicitUntypedSerializer(runtimeType); [EOL] assertNotNull(actualSerializer); [EOL] }
public void testCreateAndCacheUntypedSerializerWithValidType() throws JsonMappingException { [EOL] Class<?> type = String.class; // Use any class for valid type [EOL] JsonSerializer<Object> serializer = _createAndCacheUntypedSerializer(type); [EOL] assertNotNull(serializer); [EOL] assertTrue(isSerializerCached(type, serializer)); [EOL] } [EOL] public void testCreateAndCacheUntypedSerializerWithInvalidType() { [EOL] Class<?> type = void.class; // Use an invalid type that causes IllegalArgumentException [EOL] try { [EOL] _createAndCacheUntypedSerializer(type); [EOL] fail("Expected JsonMappingException"); [EOL] } catch (JsonMappingException e) { [EOL] } [EOL] }
public void testCreateAndCacheUntypedSerializerWithNonNullSerializer() throws JsonMappingException { [EOL] JavaType type = mock(JavaType.class); [EOL] JsonSerializer<Object> expectedSerializer = mock(JsonSerializer.class); [EOL] when(this._createUntypedSerializer(type)).thenReturn(expectedSerializer); [EOL] JsonSerializer<Object> result = this._createAndCacheUntypedSerializer(type); [EOL] assertNotNull(result); [EOL] verify(this._serializerCache).addAndResolveNonTypedSerializer(eq(type), eq(expectedSerializer), eq(this)); [EOL] }
public void testCreateAndCacheUntypedSerializerWithNullSerializer() throws JsonMappingException { [EOL] JavaType type = mock(JavaType.class); [EOL] when(this._createUntypedSerializer(type)).thenReturn(null); [EOL] JsonSerializer<Object> result = this._createAndCacheUntypedSerializer(type); [EOL] assertNull(result); [EOL] verify(this._serializerCache, never()).addAndResolveNonTypedSerializer(any(), any(), any()); [EOL] }
public void testCreateAndCacheUntypedSerializerWithIllegalArgumentException() { [EOL] JavaType type = mock(JavaType.class); [EOL] when(this._createUntypedSerializer(type)).thenThrow(new IllegalArgumentException("Invalid type")); [EOL] try { [EOL] this._createAndCacheUntypedSerializer(type); [EOL] fail("JsonMappingException expected"); [EOL] } catch (JsonMappingException e) { [EOL] assertEquals("Invalid type", e.getMessage()); [EOL] } [EOL] }
protected JsonSerializer<Object> _createUntypedSerializer(JavaType type) throws JsonMappingException { [EOL] return (JsonSerializer<Object>) _serializerFactory.createSerializer(this, type); [EOL] }
public void testHandleContextualResolvableWithResolvableSerializer() throws JsonMappingException { [EOL] JsonSerializer<?> ser = mock(ResolvableSerializer.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DefaultSerializerProvider sp = (DefaultSerializerProvider) mapper.getSerializerProviderInstance(); [EOL] JsonSerializer<Object> result = sp._handleContextualResolvable(ser, property); [EOL] verify((ResolvableSerializer) ser).resolve(sp); [EOL] assertNotNull(result); [EOL] }
public void testHandleContextualResolvableWithNonResolvableSerializer() throws JsonMappingException { [EOL] JsonSerializer<?> ser = mock(JsonSerializer.class); [EOL] BeanProperty property = mock(BeanProperty.class); [EOL] ObjectMapper mapper = new ObjectMapper(); [EOL] DefaultSerializerProvider sp = (DefaultSerializerProvider) mapper.getSerializerProviderInstance(); [EOL] JsonSerializer<Object> result = sp._handleContextualResolvable(ser, property); [EOL] verify(ser, never()).resolve(any(SerializerProvider.class)); [EOL] assertNotNull(result); [EOL] }
public void testHandleContextualWithNonContextualSerializer() { [EOL] JsonSerializer<?> nonContextualSerializer = new JsonSerializer<Object>() { [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider serializers) throws IOException { [EOL] } [EOL] }; [EOL] JsonSerializer<Object> result = _handleContextual(nonContextualSerializer, null); [EOL] assertSame(nonContextualSerializer, result); [EOL] }
public void testHandleContextualWithContextualSerializer() throws JsonMappingException { [EOL] JsonSerializer<?> contextualSerializer = new ContextualSerializer() { [EOL] @Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { [EOL] return this; // Return the same serializer for simplicity [EOL] } [EOL] @Override [EOL] public void serialize(Object value, JsonGenerator gen, SerializerProvider serializers) throws IOException { [EOL] } [EOL] }; [EOL] JsonSerializer<Object> result = _handleContextual(contextualSerializer, null); [EOL] assertSame(contextualSerializer, result); [EOL] }
