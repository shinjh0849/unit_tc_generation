public void testFromDateFieldsWithNullDate() { [EOL] try { [EOL] YearMonthDay.fromDateFields(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The date must not be null", e.getMessage()); [EOL] } [EOL] }
public void testFromDateFieldsWithValidDate() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(2023, Calendar.JANUARY, 1); // January is 0 in Calendar [EOL] Date date = calendar.getTime(); [EOL] YearMonthDay result = YearMonthDay.fromDateFields(date); [EOL] assertEquals(2023, result.getYear()); [EOL] assertEquals(1, result.getMonthOfYear()); // January is 1 in YearMonthDay [EOL] assertEquals(1, result.getDayOfMonth()); [EOL] }
public YearMonthDay(Object instant) { [EOL] super(instant, null, ISODateTimeFormat.dateOptionalTimeParser()); [EOL] } [EOL] public YearMonthDay(); [EOL] public YearMonthDay(DateTimeZone zone); [EOL] public YearMonthDay(Chronology chronology); [EOL] public YearMonthDay(long instant); [EOL] public YearMonthDay(long instant, Chronology chronology); [EOL] public YearMonthDay(Object instant); [EOL] public YearMonthDay(Object instant, Chronology chronology); [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth); [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology); [EOL] YearMonthDay(YearMonthDay partial, int[] values); [EOL] YearMonthDay(YearMonthDay partial, Chronology chrono); [EOL] Property(YearMonthDay partial, int fieldIndex); [EOL] public static YearMonthDay fromCalendarFields(Calendar calendar); [EOL] public static YearMonthDay fromDateFields(Date date); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public YearMonthDay withChronologyRetainFields(Chronology newChronology); [EOL] public YearMonthDay withField(DateTimeFieldType fieldType, int value); [EOL] public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public YearMonthDay plus(ReadablePeriod period); [EOL] public YearMonthDay plusYears(int years); [EOL] public YearMonthDay plusMonths(int months); [EOL] public YearMonthDay plusDays(int days); [EOL] public YearMonthDay minus(ReadablePeriod period); [EOL] public YearMonthDay minusYears(int years); [EOL] public YearMonthDay minusMonths(int months); [EOL] public YearMonthDay minusDays(int days); [EOL] public Property property(DateTimeFieldType type); [EOL] public LocalDate toLocalDate(); [EOL] public DateTime toDateTimeAtMidnight(); [EOL] public DateTime toDateTimeAtMidnight(DateTimeZone zone); [EOL] public DateTime toDateTimeAtCurrentTime(); [EOL] public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); [EOL] public DateMidnight toDateMidnight(); [EOL] public DateMidnight toDateMidnight(DateTimeZone zone); [EOL] public DateTime toDateTime(TimeOfDay time); [EOL] public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); [EOL] public Interval toInterval(); [EOL] public Interval toInterval(DateTimeZone zone); [EOL] public int getYear(); [EOL] public int getMonthOfYear(); [EOL] public int getDayOfMonth(); [EOL] public YearMonthDay withYear(int year); [EOL] public YearMonthDay withMonthOfYear(int monthOfYear); [EOL] public YearMonthDay withDayOfMonth(int dayOfMonth); [EOL] public Property year(); [EOL] public Property monthOfYear(); [EOL] public Property dayOfMonth(); [EOL] public String toString(); [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public YearMonthDay getYearMonthDay(); [EOL] public int get(); [EOL] public YearMonthDay addToCopy(int valueToAdd); [EOL] public YearMonthDay addWrapFieldToCopy(int valueToAdd); [EOL] public YearMonthDay setCopy(int value); [EOL] public YearMonthDay setCopy(String text, Locale locale); [EOL] public YearMonthDay setCopy(String text); [EOL] public YearMonthDay withMaximumValue(); [EOL] public YearMonthDay withMinimumValue(); [EOL] long serialVersionUID=Optional[797544782896179L]; [EOL] DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }];
public void testYearMonthDay_Object_Chronology_NullChronology() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = null; [EOL] YearMonthDay ymd = new YearMonthDay(instant, chronology); [EOL] assertNotNull(ymd); [EOL] } [EOL] public void testYearMonthDay_Object_Chronology_NonNullChronology() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonthDay ymd = new YearMonthDay(instant, chronology); [EOL] assertNotNull(ymd); [EOL] assertEquals(chronology, ymd.getChronology()); [EOL] } [EOL] public void testYearMonthDay_Object_NullInstant() { [EOL] Object instant = null; [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] try { [EOL] new YearMonthDay(instant, chronology); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testYearMonthDay_Object_InvalidTypeInstant() { [EOL] Object instant = "InvalidInstantType"; [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] try { [EOL] new YearMonthDay(instant, chronology); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
YearMonthDay(YearMonthDay partial, int[] values) { [EOL] super(partial, values); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }];
public void testMinusYears() { [EOL] YearMonthDay ymd = new YearMonthDay(2020, 1, 1); [EOL] YearMonthDay result = ymd.minusYears(1); [EOL] assertEquals(new YearMonthDay(2019, 1, 1), result); [EOL] }
public void testMinusYearsWithZero() { [EOL] YearMonthDay ymd = new YearMonthDay(2020, 1, 1); [EOL] YearMonthDay result = ymd.minusYears(0); [EOL] assertEquals(ymd, result); [EOL] }
public void testMinusYearsWithNegative() { [EOL] YearMonthDay ymd = new YearMonthDay(2020, 1, 1); [EOL] YearMonthDay result = ymd.minusYears(-1); [EOL] assertEquals(new YearMonthDay(2021, 1, 1), result); [EOL] }
public void testToDateTimeAtMidnightWithNullZone() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] DateTime result = ymd.toDateTimeAtMidnight(null); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.getHourOfDay()); [EOL] assertEquals(0, result.getMinuteOfHour()); [EOL] assertEquals(0, result.getSecondOfMinute()); [EOL] assertEquals(0, result.getMillisOfSecond()); [EOL] }
public void testToDateTimeAtMidnightWithNonNullZone() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] DateTime result = ymd.toDateTimeAtMidnight(zone); [EOL] assertNotNull(result); [EOL] assertEquals(zone, result.getZone()); [EOL] assertEquals(0, result.getHourOfDay()); [EOL] assertEquals(0, result.getMinuteOfHour()); [EOL] assertEquals(0, result.getSecondOfMinute()); [EOL] assertEquals(0, result.getMillisOfSecond()); [EOL] }
public void testToDateMidnight_Default() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] DateMidnight result = ymd.toDateMidnight(); [EOL] assertNotNull(result); [EOL] }
public void testYearMonthDay_Long() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonthDay ymd = new YearMonthDay(instant); [EOL] assertNotNull(ymd); [EOL] }
public void testYearMonthDay_LongChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonthDay ymd = new YearMonthDay(instant, chronology); [EOL] assertNotNull(ymd); [EOL] }
public void testYearMonthDay_Object() { [EOL] Object instant = new Date(); [EOL] YearMonthDay ymd = new YearMonthDay(instant); [EOL] assertNotNull(ymd); [EOL] }
public void testYearMonthDay_ObjectChronology() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonthDay ymd = new YearMonthDay(instant, chronology); [EOL] assertNotNull(ymd); [EOL] }
public void testYearMonthDay_Ints() { [EOL] int year = 2023; [EOL] int month = 4; [EOL] int day = 1; [EOL] YearMonthDay ymd = new YearMonthDay(year, month, day); [EOL] assertNotNull(ymd); [EOL] assertEquals(year, ymd.getYear()); [EOL] assertEquals(month, ymd.getMonthOfYear()); [EOL] assertEquals(day, ymd.getDayOfMonth()); [EOL] }
public void testYearMonthDay_IntsChronology() { [EOL] int year = 2023; [EOL] int month = 4; [EOL] int day = 1; [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonthDay ymd = new YearMonthDay(year, month, day, chronology); [EOL] assertNotNull(ymd); [EOL] assertEquals(year, ymd.getYear()); [EOL] assertEquals(month, ymd.getMonthOfYear()); [EOL] assertEquals(day, ymd.getDayOfMonth()); [EOL] }
public void testYearMonthDay_Partial() { [EOL] YearMonthDay partial = new YearMonthDay(); [EOL] int[] values = new int[] {2024, 5, 2}; [EOL] YearMonthDay ymd = new YearMonthDay(partial, values); [EOL] assertNotNull(ymd); [EOL] assertEquals(values[0], ymd.getYear()); [EOL] assertEquals(values[1], ymd.getMonthOfYear()); [EOL] assertEquals(values[2], ymd.getDayOfMonth()); [EOL] }
public void testYearMonthDay_PartialChronology() { [EOL] YearMonthDay partial = new YearMonthDay(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonthDay ymd = new YearMonthDay(partial, chronology); [EOL] assertNotNull(ymd); [EOL] }
public void testFromCalendarFields() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] YearMonthDay ymd = YearMonthDay.fromCalendarFields(calendar); [EOL] assertNotNull(ymd); [EOL] assertEquals(calendar.get(Calendar.YEAR), ymd.getYear()); [EOL] assertEquals(calendar.get(Calendar.MONTH) + 1, ymd.getMonthOfYear()); [EOL] assertEquals(calendar.get(Calendar.DAY_OF_MONTH), ymd.getDayOfMonth()); [EOL] }
public void testFromDateFields() { [EOL] Date date = new Date(); [EOL] YearMonthDay ymd = YearMonthDay.fromDateFields(date); [EOL] assertNotNull(ymd); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.setTime(date); [EOL] assertEquals(calendar.get(Calendar.YEAR), ymd.getYear()); [EOL] assertEquals(calendar.get(Calendar.MONTH) + 1, ymd.getMonthOfYear()); [EOL] assertEquals(calendar.get(Calendar.DAY_OF_MONTH), ymd.getDayOfMonth()); [EOL] }
public int getYear() { [EOL] return getValue(YEAR); [EOL] } [EOL] public YearMonthDay(); [EOL] public YearMonthDay(DateTimeZone zone); [EOL] public YearMonthDay(Chronology chronology); [EOL] public YearMonthDay(long instant); [EOL] public YearMonthDay(long instant, Chronology chronology); [EOL] public YearMonthDay(Object instant); [EOL] public YearMonthDay(Object instant, Chronology chronology); [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth); [EOL] public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology); [EOL] YearMonthDay(YearMonthDay partial, int[] values); [EOL] YearMonthDay(YearMonthDay partial, Chronology chrono); [EOL] Property(YearMonthDay partial, int fieldIndex); [EOL] public static YearMonthDay fromCalendarFields(Calendar calendar); [EOL] public static YearMonthDay fromDateFields(Date date); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public YearMonthDay withChronologyRetainFields(Chronology newChronology); [EOL] public YearMonthDay withField(DateTimeFieldType fieldType, int value); [EOL] public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public YearMonthDay plus(ReadablePeriod period); [EOL] public YearMonthDay plusYears(int years); [EOL] public YearMonthDay plusMonths(int months); [EOL] public YearMonthDay plusDays(int days); [EOL] public YearMonthDay minus(ReadablePeriod period); [EOL] public YearMonthDay minusYears(int years); [EOL] public YearMonthDay minusMonths(int months); [EOL] public YearMonthDay minusDays(int days); [EOL] public Property property(DateTimeFieldType type); [EOL] public LocalDate toLocalDate(); [EOL] public DateTime toDateTimeAtMidnight(); [EOL] public DateTime toDateTimeAtMidnight(DateTimeZone zone); [EOL] public DateTime toDateTimeAtCurrentTime(); [EOL] public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); [EOL] public DateMidnight toDateMidnight(); [EOL] public DateMidnight toDateMidnight(DateTimeZone zone); [EOL] public DateTime toDateTime(TimeOfDay time); [EOL] public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); [EOL] public Interval toInterval(); [EOL] public Interval toInterval(DateTimeZone zone); [EOL] public int getYear(); [EOL] public int getMonthOfYear(); [EOL] public int getDayOfMonth(); [EOL] public YearMonthDay withYear(int year); [EOL] public YearMonthDay withMonthOfYear(int monthOfYear); [EOL] public YearMonthDay withDayOfMonth(int dayOfMonth); [EOL] public Property year(); [EOL] public Property monthOfYear(); [EOL] public Property dayOfMonth(); [EOL] public String toString(); [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public YearMonthDay getYearMonthDay(); [EOL] public int get(); [EOL] public YearMonthDay addToCopy(int valueToAdd); [EOL] public YearMonthDay addWrapFieldToCopy(int valueToAdd); [EOL] public YearMonthDay setCopy(int value); [EOL] public YearMonthDay setCopy(String text, Locale locale); [EOL] public YearMonthDay setCopy(String text); [EOL] public YearMonthDay withMaximumValue(); [EOL] public YearMonthDay withMinimumValue(); [EOL] long serialVersionUID=797544782896179L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
public void testGetMonthOfYear() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] int monthOfYear = ymd.getMonthOfYear(); [EOL] assertNotNull(monthOfYear); [EOL] assertTrue(monthOfYear >= 1 && monthOfYear <= 12); [EOL] }
public void testYearMonthDayWithChronology() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(chrono); [EOL] assertNotNull(ymd); [EOL] assertEquals(chrono, ymd.getChronology()); [EOL] }
public void testYearMonthDayFromInstant() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonthDay ymd = new YearMonthDay(instant); [EOL] assertNotNull(ymd); [EOL] assertEquals(instant, ymd.toDateTimeAtMidnight().getMillis()); [EOL] }
public void testYearMonthDayFromObject() { [EOL] Date date = new Date(); [EOL] YearMonthDay ymd = new YearMonthDay(date); [EOL] assertNotNull(ymd); [EOL] assertEquals(date.getTime(), ymd.toDateTimeAtMidnight().getMillis()); [EOL] }
public void testYearMonthDayWithYearMonthDay() { [EOL] YearMonthDay original = new YearMonthDay(); [EOL] int[] values = new int[] {original.getYear(), original.getMonthOfYear(), original.getDayOfMonth()}; [EOL] YearMonthDay ymd = new YearMonthDay(original, values); [EOL] assertNotNull(ymd); [EOL] assertEquals(original, ymd); [EOL] }
public void testYearMonthDayWithField() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] YearMonthDay updatedYMD = ymd.withField(DateTimeFieldType.year(), 2000); [EOL] assertNotNull(updatedYMD); [EOL] assertEquals(2000, updatedYMD.getYear()); [EOL] }
public void testYearMonthDayWithPeriodAdded() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] ReadablePeriod period = new Period().withYears(1); [EOL] YearMonthDay updatedYMD = ymd.withPeriodAdded(period, 1); [EOL] assertNotNull(updatedYMD); [EOL] assertEquals(ymd.getYear() + 1, updatedYMD.getYear()); [EOL] }
public void testYearMonthDayPlusYears() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] YearMonthDay updatedYMD = ymd.plusYears(1); [EOL] assertNotNull(updatedYMD); [EOL] assertEquals(ymd.getYear() + 1, updatedYMD.getYear()); [EOL] }
public void testYearMonthDayMinusYears() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] YearMonthDay updatedYMD = ymd.minusYears(1); [EOL] assertNotNull(updatedYMD); [EOL] assertEquals(ymd.getYear() - 1, updatedYMD.getYear()); [EOL] }
public void testYearMonthDayWithMaximumValue() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] YearMonthDay maxYMD = ymd.withMaximumValue(); [EOL] assertNotNull(maxYMD); [EOL] assertTrue(maxYMD.getDayOfMonth() >= 28); // Assuming that the maximum value for dayOfMonth is at least 28 [EOL] }
public void testGetDayOfMonth() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] int dayOfMonth = ymd.getDayOfMonth(); [EOL] assertEquals(1, dayOfMonth); [EOL] }
public void testYearMonthDayLong() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonthDay ymd = new YearMonthDay(instant); [EOL] assertNotNull(ymd); [EOL] }
public void testYearMonthDayLongChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonthDay ymd = new YearMonthDay(instant, chronology); [EOL] assertNotNull(ymd); [EOL] }
public void testYearMonthDayObject() { [EOL] Date date = new Date(); [EOL] YearMonthDay ymd = new YearMonthDay(date); [EOL] assertNotNull(ymd); [EOL] }
public void testYearMonthDayObjectChronology() { [EOL] Date date = new Date(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonthDay ymd = new YearMonthDay(date, chronology); [EOL] assertNotNull(ymd); [EOL] }
public void testYearMonthDayInts() { [EOL] int year = 2023; [EOL] int monthOfYear = 4; [EOL] int dayOfMonth = 15; [EOL] YearMonthDay ymd = new YearMonthDay(year, monthOfYear, dayOfMonth); [EOL] assertEquals(year, ymd.getYear()); [EOL] assertEquals(monthOfYear, ymd.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, ymd.getDayOfMonth()); [EOL] }
public void testYearMonthDayIntsChronology() { [EOL] int year = 2023; [EOL] int monthOfYear = 4; [EOL] int dayOfMonth = 15; [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonthDay ymd = new YearMonthDay(year, monthOfYear, dayOfMonth, chronology); [EOL] assertEquals(year, ymd.getYear()); [EOL] assertEquals(monthOfYear, ymd.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, ymd.getDayOfMonth()); [EOL] }
public Property monthOfYear() { [EOL] return new Property(this, MONTH_OF_YEAR); [EOL] }
public void testSetCopy_ValidValue() { [EOL] YearMonthDay ymd = new YearMonthDay(2020, 1, 1); [EOL] int newValue = 2; [EOL] YearMonthDay updatedYMD = ymd.setCopy(newValue); [EOL] assertEquals("The value should be updated to the new value", newValue, updatedYMD.getDayOfMonth()); [EOL] }
public void testSetCopy_InvalidValue() { [EOL] YearMonthDay ymd = new YearMonthDay(2020, 1, 1); [EOL] int invalidValue = -1; [EOL] try { [EOL] ymd.setCopy(invalidValue); [EOL] fail("Should have thrown an exception for invalid value"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetCopy_MaxIntValue() { [EOL] YearMonthDay ymd = new YearMonthDay(2020, 1, 1); [EOL] int maxValue = Integer.MAX_VALUE; [EOL] try { [EOL] ymd.setCopy(maxValue); [EOL] fail("Should have thrown an exception for max int value"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetCopy_MinIntValue() { [EOL] YearMonthDay ymd = new YearMonthDay(2020, 1, 1); [EOL] int minValue = Integer.MIN_VALUE; [EOL] try { [EOL] ymd.setCopy(minValue); [EOL] fail("Should have thrown an exception for min int value"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetCopyWithValidTextAndLocale() { [EOL] YearMonthDay ymd = new YearMonthDay(2020, 1, 1); [EOL] Locale locale = Locale.ENGLISH; [EOL] String validText = "2021-02-02"; [EOL] YearMonthDay updatedYmd = ymd.setCopy(validText, locale); [EOL] assertEquals(new YearMonthDay(2021, 2, 2), updatedYmd); [EOL] }
public void testSetCopyWithInvalidText() { [EOL] YearMonthDay ymd = new YearMonthDay(2020, 1, 1); [EOL] Locale locale = Locale.ENGLISH; [EOL] String invalidText = "invalid-date"; [EOL] try { [EOL] ymd.setCopy(invalidText, locale); [EOL] fail("Should have thrown an exception due to invalid text"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetCopyWithNullLocale() { [EOL] YearMonthDay ymd = new YearMonthDay(2020, 1, 1); [EOL] String validText = "2021-02-02"; [EOL] try { [EOL] ymd.setCopy(validText, null); [EOL] fail("Should have thrown an exception due to null locale"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testSetCopyWithText() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] String text = "2000-10-01"; [EOL] YearMonthDay result = ymd.setCopy(text); [EOL] assertNotNull(result); [EOL] assertEquals(new YearMonthDay(2000, 10, 1), result); [EOL] }
public void testYearMonthDayDefaultConstructor() { [EOL] YearMonthDay ymd = new YearMonthDay(); [EOL] assertNotNull(ymd); [EOL] assertEquals(new LocalDate(), ymd.toLocalDate()); [EOL] }
public void testYearMonthDayChronologyConstructor() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(chrono); [EOL] assertNotNull(ymd); [EOL] assertEquals(chrono, ymd.getChronology()); [EOL] }
public void testYearMonthDayLongConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonthDay ymd = new YearMonthDay(instant); [EOL] assertNotNull(ymd); [EOL] assertEquals(new LocalDate(instant), ymd.toLocalDate()); [EOL] }
public void testYearMonthDayLongChronologyConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(instant, chrono); [EOL] assertNotNull(ymd); [EOL] assertEquals(new LocalDate(instant, chrono), ymd.toLocalDate()); [EOL] assertEquals(chrono, ymd.getChronology()); [EOL] }
public void testYearMonthDayObjectConstructor() { [EOL] Object instant = new LocalDate(); [EOL] YearMonthDay ymd = new YearMonthDay(instant); [EOL] assertNotNull(ymd); [EOL] assertEquals(instant, ymd.toLocalDate()); [EOL] }
public void testYearMonthDayObjectChronologyConstructor() { [EOL] Object instant = new LocalDate(); [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(instant, chrono); [EOL] assertNotNull(ymd); [EOL] assertEquals(instant, ymd.toLocalDate()); [EOL] assertEquals(chrono, ymd.getChronology()); [EOL] }
public void testYearMonthDayIntIntIntConstructor() { [EOL] int year = 2000; [EOL] int month = 10; [EOL] int day = 1; [EOL] YearMonthDay ymd = new YearMonthDay(year, month, day); [EOL] assertNotNull(ymd); [EOL] assertEquals(year, ymd.getYear()); [EOL] assertEquals(month, ymd.getMonthOfYear()); [EOL] assertEquals(day, ymd.getDayOfMonth()); [EOL] }
public void testYearMonthDayIntIntIntChronologyConstructor() { [EOL] int year = 2000; [EOL] int month = 10; [EOL] int day = 1; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] YearMonthDay ymd = new YearMonthDay(year, month, day, chrono); [EOL] assertNotNull(ymd); [EOL] assertEquals(year, ymd.getYear()); [EOL] assertEquals(month, ymd.getMonthOfYear()); [EOL] assertEquals(day, ymd.getDayOfMonth()); [EOL] assertEquals(chrono, ymd.getChronology()); [EOL] }
public void testGetChronologyWithNullObjectAndNonNullZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] Chronology result = getChronology(null, zone); [EOL] assertNotNull(result); [EOL] assertEquals(zone, result.getZone()); [EOL] } [EOL] public void testGetChronologyWithNonNullObjectAndNonNullZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] Object object = new LocalDate(2023, 3, 25); [EOL] Chronology result = getChronology(object, zone); [EOL] assertNotNull(result); [EOL] assertEquals(zone, result.getZone()); [EOL] }

public void testGetPartialValues_ValidInput() { [EOL] ReadablePartial mockFieldSource = createMockFieldSourceWithSize(3); [EOL] Object mockObject = createMockReadablePartialWithValues(new int[]{10, 20, 30}); [EOL] Chronology mockChrono = createMockChronology(); [EOL] int[] result = getPartialValues(mockFieldSource, mockObject, mockChrono); [EOL] assertEquals(3, result.length); [EOL] assertEquals(10, result[0]); [EOL] assertEquals(20, result[1]); [EOL] assertEquals(30, result[2]); [EOL] }
public void testGetPartialValues_EmptyInput() { [EOL] ReadablePartial mockFieldSource = createMockFieldSourceWithSize(0); [EOL] Object mockObject = createMockReadablePartialWithValues(new int[]{}); [EOL] Chronology mockChrono = createMockChronology(); [EOL] int[] result = getPartialValues(mockFieldSource, mockObject, mockChrono); [EOL] assertEquals(0, result.length); [EOL] }
public void testGetInstantMillisWithValidLongObject() { [EOL] long expected = 1234567890L; [EOL] Long inputObject = expected; [EOL] Chronology chrono = null; // Assuming Chronology is not used in the method [EOL] long result = getInstantMillis(inputObject, chrono); [EOL] assert result == expected; [EOL] }
public void testGetInstantMillisWithNull() { [EOL] try { [EOL] Long inputObject = null; [EOL] Chronology chrono = null; // Assuming Chronology is not used in the method [EOL] getInstantMillis(inputObject, chrono); [EOL] assert false : "Expected an exception to be thrown"; [EOL] } catch (NullPointerException e) { [EOL] assert true; [EOL] } [EOL] }
public void testGetSupportedType() { [EOL] Time time = new Time(); [EOL] Class<?> supportedType = time.getSupportedType(); [EOL] assertEquals(Long.class, supportedType); [EOL] }
public void testParseWithNullString() { [EOL] try { [EOL] Period.parse(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseWithEmptyString() { [EOL] try { [EOL] Period.parse(""); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseWithValidString() { [EOL] Period period = Period.parse("P1Y2M3W4D"); [EOL] assertNotNull(period); [EOL] assertEquals(1, period.getYears()); [EOL] assertEquals(2, period.getMonths()); [EOL] assertEquals(3, period.getWeeks()); [EOL] assertEquals(4, period.getDays()); [EOL] }
public static Period parse(String str, PeriodFormatter formatter) { [EOL] return formatter.parsePeriod(str); [EOL] }
public void testYears_Zero() { [EOL] Period result = Time.years(0); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.getYears()); [EOL] }
public void testYears_Positive() { [EOL] Period result = Time.years(5); [EOL] assertNotNull(result); [EOL] assertEquals(5, result.getYears()); [EOL] }
public void testYears_Negative() { [EOL] Period result = Time.years(-5); [EOL] assertNotNull(result); [EOL] assertEquals(-5, result.getYears()); [EOL] }
public void testMonths_Zero() { [EOL] Period result = Time.months(0); [EOL] assertEquals(0, result.getMonths()); [EOL] }
public void testMonths_Positive() { [EOL] Period result = Time.months(5); [EOL] assertEquals(5, result.getMonths()); [EOL] }
public void testMonths_Negative() { [EOL] Period result = Time.months(-5); [EOL] assertEquals(-5, result.getMonths()); [EOL] }
public void testWeeks_Zero() { [EOL] Period result = Time.weeks(0); [EOL] assertEquals(0, result.getWeeks()); [EOL] }
public void testWeeks_Positive() { [EOL] Period result = Time.weeks(5); [EOL] assertEquals(5, result.getWeeks()); [EOL] }
public void testWeeks_Negative() { [EOL] Period result = Time.weeks(-3); [EOL] assertEquals(-3, result.getWeeks()); [EOL] }
public void testDays_Positive() { [EOL] int days = 5; [EOL] Period result = Time.days(days); [EOL] assertEquals("Period should have 5 days", 5, result.getDays()); [EOL] }
public void testDays_Negative() { [EOL] int days = -5; [EOL] Period result = Time.days(days); [EOL] assertEquals("Period should have -5 days", -5, result.getDays()); [EOL] }
public void testDays_Zero() { [EOL] int days = 0; [EOL] Period result = Time.days(days); [EOL] assertEquals("Period should have 0 days", 0, result.getDays()); [EOL] }
public void testHours_Zero() { [EOL] Period result = Time.hours(0); [EOL] assertEquals(0, result.getHours()); [EOL] } [EOL] public void testHours_Positive() { [EOL] Period result = Time.hours(5); [EOL] assertEquals(5, result.getHours()); [EOL] } [EOL] public void testHours_Negative() { [EOL] Period result = Time.hours(-3); [EOL] assertEquals(-3, result.getHours()); [EOL] }
public void testMinutes_Zero() { [EOL] Period result = Time.minutes(0); [EOL] assertEquals(0, result.getMinutes()); [EOL] }
public void testMinutes_Positive() { [EOL] Period result = Time.minutes(5); [EOL] assertEquals(5, result.getMinutes()); [EOL] }
public void testMinutes_Negative() { [EOL] Period result = Time.minutes(-5); [EOL] assertEquals(-5, result.getMinutes()); [EOL] }
public void testSeconds_Zero() { [EOL] Period result = Time.seconds(0); [EOL] assertEquals(0, result.getSeconds()); [EOL] assertEquals(PeriodType.standard(), result.getPeriodType()); [EOL] }
public void testSeconds_Positive() { [EOL] Period result = Time.seconds(5); [EOL] assertEquals(5, result.getSeconds()); [EOL] assertEquals(PeriodType.standard(), result.getPeriodType()); [EOL] }
public void testSeconds_Negative() { [EOL] Period result = Time.seconds(-5); [EOL] assertEquals(-5, result.getSeconds()); [EOL] assertEquals(PeriodType.standard(), result.getPeriodType()); [EOL] }
public void testMillis_Zero() { [EOL] Period result = Time.millis(0); [EOL] assertEquals(0, result.getMillis()); [EOL] }
public void testMillis_Positive() { [EOL] Period result = Time.millis(123); [EOL] assertEquals(123, result.getMillis()); [EOL] }
public void testMillis_Negative() { [EOL] Period result = Time.millis(-456); [EOL] assertEquals(-456, result.getMillis()); [EOL] }
public void testFieldDifference_WithNullStart() { [EOL] try { [EOL] Period.fieldDifference(null, new LocalDate()); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("ReadablePartial objects must not be null", e.getMessage()); [EOL] } [EOL] }
public void testFieldDifference_WithNullEnd() { [EOL] try { [EOL] Period.fieldDifference(new LocalDate(), null); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("ReadablePartial objects must not be null", e.getMessage()); [EOL] } [EOL] }
public void testFieldDifference_WithDifferentSizes() { [EOL] try { [EOL] Period.fieldDifference(new LocalDate(), new LocalTime()); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("ReadablePartial objects must have the same set of fields", e.getMessage()); [EOL] } [EOL] }
public void testFieldDifference_WithDifferentFieldTypes() { [EOL] ReadablePartial start = new LocalDate(); [EOL] ReadablePartial end = new LocalDate() { [EOL] @Override [EOL] public DateTimeFieldType getFieldType(int index) { [EOL] if (index == 0) { [EOL] return DateTimeFieldType.clockhourOfDay(); // Different field type [EOL] } [EOL] return super.getFieldType(index); [EOL] } [EOL] }; [EOL] try { [EOL] Period.fieldDifference(start, end); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("ReadablePartial objects must have the same set of fields", e.getMessage()); [EOL] } [EOL] }
public void testFieldDifference_WithOverlappingFields() { [EOL] ReadablePartial start = new LocalDate(); [EOL] ReadablePartial end = new LocalDate() { [EOL] @Override [EOL] public DurationFieldType getFieldType(int index) { [EOL] if (index == 1) { [EOL] return DurationFieldType.days(); // Overlapping field type [EOL] } [EOL] return super.getFieldType(index).getDurationType(); [EOL] } [EOL] }; [EOL] try { [EOL] Period.fieldDifference(start, end); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("ReadablePartial objects must not have overlapping fields", e.getMessage()); [EOL] } [EOL] }
public void testFieldDifference_ValidInput() { [EOL] ReadablePartial start = new LocalDate(2020, 1, 1); [EOL] ReadablePartial end = new LocalDate(2020, 1, 2); [EOL] Period result = Period.fieldDifference(start, end); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.getDays()); [EOL] }
public void testPeriodConstructor_ValidValues() { [EOL] int hours = 5; [EOL] int minutes = 30; [EOL] int seconds = 45; [EOL] int millis = 100; [EOL] Period period = new Period(hours, minutes, seconds, millis); [EOL] assertEquals(hours, period.getHours()); [EOL] assertEquals(minutes, period.getMinutes()); [EOL] assertEquals(seconds, period.getSeconds()); [EOL] assertEquals(millis, period.getMillis()); [EOL] }
public void testPeriod_AllFields() { [EOL] PeriodType type = PeriodType.standard(); [EOL] Period period = new Period(1, 2, 3, 4, 5, 6, 7, 8, type); [EOL] assertEquals(1, period.getYears()); [EOL] assertEquals(2, period.getMonths()); [EOL] assertEquals(3, period.getWeeks()); [EOL] assertEquals(4, period.getDays()); [EOL] assertEquals(5, period.getHours()); [EOL] assertEquals(6, period.getMinutes()); [EOL] assertEquals(7, period.getSeconds()); [EOL] assertEquals(8, period.getMillis()); [EOL] assertEquals(type, period.getPeriodType()); [EOL] }
public void testPeriodWithNullType() { [EOL] long duration = 1000L; [EOL] PeriodType type = null; [EOL] Period period = new Period(duration, type); [EOL] assertNull(period.getPeriodType()); [EOL] assertEquals(duration, period.getDuration()); [EOL] }
public void testPeriodWithNonNullType() { [EOL] long duration = 1000L; [EOL] PeriodType type = PeriodType.standard(); [EOL] Period period = new Period(duration, type); [EOL] assertNotNull(period.getPeriodType()); [EOL] assertEquals(type, period.getPeriodType()); [EOL] assertEquals(duration, period.getDuration()); [EOL] }
public void testPeriodWithNull() { [EOL] try { [EOL] new Period(null); [EOL] fail("Should have thrown IllegalArgumentException for null period"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testPeriodWithValidObject() { [EOL] Object validPeriod = new Object(); // Assuming Object can be a valid period [EOL] Period period = new Period(validPeriod); [EOL] assertNotNull("Period should not be null", period); [EOL] }
private Period(int[] values, PeriodType type) { [EOL] super(values, type); [EOL] }
public void testWithPeriodType_SameType() { [EOL] PeriodType type = PeriodType.yearMonthDay(); [EOL] Period period = new Period(1, 1, 1, 1, 1, 1, 1, type); [EOL] Period result = period.withPeriodType(type); [EOL] assertSame(period, result); [EOL] }
public void testWithPeriodType_DifferentType() { [EOL] PeriodType type = PeriodType.yearMonthDay(); [EOL] PeriodType newType = PeriodType.yearWeekDay(); [EOL] Period period = new Period(1, 1, 1, 1, 1, 1, 1, type); [EOL] Period result = period.withPeriodType(newType); [EOL] assertNotSame(period, result); [EOL] assertEquals(newType, result.getPeriodType()); [EOL] }
public void testWithPeriodType_NullType() { [EOL] Period period = new Period(1, 1, 1, 1, 1, 1, 1, PeriodType.yearMonthDay()); [EOL] Period result = period.withPeriodType(null); [EOL] assertNotNull(result); [EOL] assertEquals(PeriodType.standard(), result.getPeriodType()); [EOL] }
public void testWithYears_NewYearsValue() { [EOL] Period period = new Period(); [EOL] int newYears = 5; [EOL] Period newPeriod = period.withYears(newYears); [EOL] assertEquals(newYears, newPeriod.getYears()); [EOL] }
public void testWithYears_SameYearsValue() { [EOL] Period period = new Period(); [EOL] int newYears = period.getYears(); [EOL] Period newPeriod = period.withYears(newYears); [EOL] assertEquals(newYears, newPeriod.getYears()); [EOL] }
public void testWithMonths_NewPeriodWithDifferentMonths() { [EOL] Period period = new Period(); [EOL] int newMonths = 5; [EOL] Period newPeriod = period.withMonths(newMonths); [EOL] assertEquals(newMonths, newPeriod.getMonths()); [EOL] }
public void testWithHours_NewHours() { [EOL] Period period = new Period(); [EOL] int newHours = 5; [EOL] Period updatedPeriod = period.withHours(newHours); [EOL] assertEquals(newHours, updatedPeriod.getHours()); [EOL] }
public void testWithHours_SameHours() { [EOL] Period period = new Period(); [EOL] int currentHours = period.getHours(); [EOL] Period updatedPeriod = period.withHours(currentHours); [EOL] assertEquals(currentHours, updatedPeriod.getHours()); [EOL] }
public void testPlusYears_ZeroYears() { [EOL] Period period = new Period(1, 2, 3, 4, 5, 6, 7, 8); [EOL] Period result = period.plusYears(0); [EOL] assertSame(period, result); [EOL] } [EOL] public void testPlusYears_NonZeroYears() { [EOL] Period period = new Period(1, 2, 3, 4, 5, 6, 7, 8); [EOL] PeriodType type = period.getPeriodType(); [EOL] int[] values = period.getValues(); [EOL] int yearsToAdd = 5; [EOL] type.addIndexedField(period, PeriodType.YEAR_INDEX, values, yearsToAdd); [EOL] Period result = period.plusYears(yearsToAdd); [EOL] Period expected = new Period(values, type); [EOL] assertEquals(expected, result); [EOL] }
public void testPlusMonths_ZeroMonths() { [EOL] Period period = new Period(); [EOL] Period result = period.plusMonths(0); [EOL] assertSame("Expected the same period instance when adding zero months", period, result); [EOL] } [EOL] public void testPlusMonths_NonZeroMonths() { [EOL] Period period = new Period(); [EOL] Period result = period.plusMonths(5); [EOL] assertNotNull("Expected a new period instance when adding non-zero months", result); [EOL] assertNotSame("Expected a different period instance when adding non-zero months", period, result); [EOL] }
public void testPlusWeeks_ZeroWeeks() { [EOL] Period period = new Period(); [EOL] Period result = period.plusWeeks(0); [EOL] assertSame("Expected the same period instance when adding zero weeks", period, result); [EOL] }
public void testPlusWeeks_NonZeroWeeks() { [EOL] Period period = new Period(); [EOL] Period result = period.plusWeeks(1); [EOL] assertNotNull("Expected a new period instance when adding non-zero weeks", result); [EOL] assertNotSame("Expected a different period instance when adding non-zero weeks", period, result); [EOL] }
public void testPlusDays_ZeroDays() { [EOL] Period period = new Period(); [EOL] Period result = period.plusDays(0); [EOL] assertSame("Expected the same period instance when adding zero days", period, result); [EOL] }
public void testPlusDays_NonZeroDays() { [EOL] Period period = new Period(); [EOL] PeriodType mockPeriodType = Mockito.mock(PeriodType.class); [EOL] int[] values = new int[] {1, 2, 3, 4, 5, 6, 7, 8}; [EOL] Mockito.when(period.getValues()).thenReturn(values); [EOL] Mockito.when(period.getPeriodType()).thenReturn(mockPeriodType); [EOL] Period result = period.plusDays(5); [EOL] Mockito.verify(mockPeriodType).addIndexedField(period, PeriodType.DAY_INDEX, values, 5); [EOL] assertNotNull("Expected a new period instance when adding non-zero days", result); [EOL] assertNotSame("Expected a different period instance when adding non-zero days", period, result); [EOL] }
public void testPlusHours_ZeroHours() { [EOL] Period period = new Period(); [EOL] Period result = period.plusHours(0); [EOL] assertSame("Expected the same period instance when adding zero hours", period, result); [EOL] }
public void testPlusHours_NonZeroHours() { [EOL] Period period = new Period(); [EOL] Period result = period.plusHours(5); [EOL] assertNotNull("Expected a new period instance when adding non-zero hours", result); [EOL] assertNotSame("Expected a different period instance when adding non-zero hours", period, result); [EOL] assertEquals("Expected the hours to be increased by the amount added", 5, result.getHours()); [EOL] }
public void testPlusMinutes_Zero() { [EOL] Period period = new Period(); [EOL] Period result = period.plusMinutes(0); [EOL] assertSame("Expected the same period instance when adding zero minutes", period, result); [EOL] } [EOL] public void testPlusMinutes_NonZero() { [EOL] Period period = new Period(); [EOL] int minutesToAdd = 5; [EOL] Period result = period.plusMinutes(minutesToAdd); [EOL] assertNotNull("Expected a new period instance when adding non-zero minutes", result); [EOL] assertNotSame("Expected a different period instance when adding non-zero minutes", period, result); [EOL] }
public void testPlusSeconds_Zero() { [EOL] Period period = new Period(); [EOL] Period result = period.plusSeconds(0); [EOL] assertSame("Expected the same period instance when adding zero seconds", period, result); [EOL] } [EOL] public void testPlusSeconds_NonZero() { [EOL] Period period = new Period(); [EOL] Period result = period.plusSeconds(1); [EOL] assertNotNull("Expected a new period instance when adding non-zero seconds", result); [EOL] assertNotSame("Expected a different period instance when adding non-zero seconds", period, result); [EOL] assertEquals("Expected the seconds to be incremented by 1", 1, result.getSeconds()); [EOL] }
public void testPlusMillis_Zero() { [EOL] Period period = new Period(); [EOL] Period result = period.plusMillis(0); [EOL] assertSame(period, result); [EOL] }
public void testPlusMillis_NonZero() { [EOL] Period period = new Period(); [EOL] Period result = period.plusMillis(1); [EOL] assertNotNull(result); [EOL] assertNotSame(period, result); [EOL] assertEquals(new Period(new int[]{0, 0, 0, 0, 0, 0, 0, 1}, period.getPeriodType()), result); [EOL] }
public void testMinusYears_PositiveYears() { [EOL] Period period = Period.ofYears(10); [EOL] Period result = period.minusYears(5); [EOL] assertEquals(Period.ofYears(5), result); [EOL] }
public void testMinusYears_NegativeYears() { [EOL] Period period = Period.ofYears(10); [EOL] Period result = period.minusYears(-5); [EOL] assertEquals(Period.ofYears(15), result); [EOL] }
public void testMinusYears_ZeroYears() { [EOL] Period period = Period.ofYears(10); [EOL] Period result = period.minusYears(0); [EOL] assertEquals(Period.ofYears(10), result); [EOL] }
public void testMinusMonths() { [EOL] Period period = Period.ofMonths(6); [EOL] Period result = period.minusMonths(3); [EOL] assertEquals(Period.ofMonths(3), result); [EOL] }
public void testMinusMonthsNegative() { [EOL] Period period = Period.ofMonths(6); [EOL] Period result = period.minusMonths(-3); [EOL] assertEquals(Period.ofMonths(9), result); [EOL] }
public void testMinusMonthsZero() { [EOL] Period period = Period.ofMonths(6); [EOL] Period result = period.minusMonths(0); [EOL] assertEquals(Period.ofMonths(6), result); [EOL] }
public void testMinusWeeks_ZeroWeeks() { [EOL] Period period = Period.ofWeeks(5); [EOL] Period result = period.minusWeeks(0); [EOL] assertEquals(Period.ofWeeks(5), result); [EOL] }
public void testMinusWeeks_PositiveWeeks() { [EOL] Period period = Period.ofWeeks(5); [EOL] Period result = period.minusWeeks(3); [EOL] assertEquals(Period.ofWeeks(2), result); [EOL] }
public void testMinusWeeks_NegativeWeeks() { [EOL] Period period = Period.ofWeeks(5); [EOL] Period result = period.minusWeeks(-3); [EOL] assertEquals(Period.ofWeeks(8), result); [EOL] }
public void testMinusDays_PositiveDays() { [EOL] Period period = Period.ofDays(10); [EOL] Period result = period.minusDays(5); [EOL] assertEquals(Period.ofDays(5), result); [EOL] }
public void testMinusDays_NegativeDays() { [EOL] Period period = Period.ofDays(10); [EOL] Period result = period.minusDays(-5); [EOL] assertEquals(Period.ofDays(15), result); [EOL] }
public void testMinusDays_ZeroDays() { [EOL] Period period = Period.ofDays(10); [EOL] Period result = period.minusDays(0); [EOL] assertEquals(Period.ofDays(10), result); [EOL] }
public void testMinusHours() { [EOL] Period period = new Period(1, 2, 3, 4, 5, 6, 7, 8); [EOL] Period result = period.minusHours(5); [EOL] assertEquals(new Period(1, 2, 2, 23, 5, 6, 7, 8), result); [EOL] }
public void testMinusHoursWithNegativeInput() { [EOL] Period period = new Period(1, 2, 3, 4, 5, 6, 7, 8); [EOL] Period result = period.minusHours(-5); [EOL] assertEquals(new Period(1, 2, 3, 9, 5, 6, 7, 8), result); [EOL] }
public void testMinusHoursWithZero() { [EOL] Period period = new Period(1, 2, 3, 4, 5, 6, 7, 8); [EOL] Period result = period.minusHours(0); [EOL] assertEquals(period, result); [EOL] }
public void testMinusMinutes() { [EOL] Period period = new Period(1, 30); [EOL] Period result = period.minusMinutes(45); [EOL] assertEquals(0, result.getHours()); [EOL] assertEquals(45, result.getMinutes()); [EOL] }
public void testMinusMinutesWithNegativeInput() { [EOL] Period period = new Period(1, 30); [EOL] Period result = period.minusMinutes(-15); [EOL] assertEquals(1, result.getHours()); [EOL] assertEquals(45, result.getMinutes()); [EOL] }
public void testMinusMinutesWithZeroInput() { [EOL] Period period = new Period(1, 30); [EOL] Period result = period.minusMinutes(0); [EOL] assertEquals(1, result.getHours()); [EOL] assertEquals(30, result.getMinutes()); [EOL] }
public void testMinusSeconds_Positive() { [EOL] Period period = new Period(1, 2, 3, 4, 5, 6, 7, 8); [EOL] Period result = period.minusSeconds(10); [EOL] assertEquals(new Period(1, 2, 3, 4, 5, 5, 57, 8), result); [EOL] }
public void testMinusSeconds_Negative() { [EOL] Period period = new Period(1, 2, 3, 4, 5, 6, 7, 8); [EOL] Period result = period.minusSeconds(-10); [EOL] assertEquals(new Period(1, 2, 3, 4, 5, 6, 17, 8), result); [EOL] }
public void testMinusSeconds_Zero() { [EOL] Period period = new Period(1, 2, 3, 4, 5, 6, 7, 8); [EOL] Period result = period.minusSeconds(0); [EOL] assertEquals(period, result); [EOL] }
public void testMinusMillis_Positive() { [EOL] Period period = Period.ofMinutes(1); [EOL] Period result = period.minusMillis(500); [EOL] assertEquals(Period.of(0, 0, 0, 0, 1, 0, -500), result); [EOL] }
public void testMinusMillis_Negative() { [EOL] Period period = Period.ofMinutes(1); [EOL] Period result = period.minusMillis(-500); [EOL] assertEquals(Period.of(0, 0, 0, 0, 1, 0, 500), result); [EOL] }
public void testMinusMillis_Zero() { [EOL] Period period = Period.ofMinutes(1); [EOL] Period result = period.minusMillis(0); [EOL] assertEquals(Period.ofMinutes(1), result); [EOL] }
public void testNormalizedStandard() { [EOL] Period testPeriod = new Period(0, 0, 0, 0, 0, 0, 0, 0); [EOL] Period normalized = testPeriod.normalizedStandard(); [EOL] assertNotNull(normalized); [EOL] assertEquals(PeriodType.standard(), normalized.getPeriodType()); [EOL] }
public void testNormalizedStandardWithUnsupportedType() { [EOL] PeriodType type = PeriodType.days(); // Assuming this type does not support years and months [EOL] Period period = new Period(1, 1, 0, 0, 0, 0, 0, 0); // 1 year, 1 month [EOL] try { [EOL] period.normalizedStandard(type); [EOL] fail("Should have thrown UnsupportedOperationException"); [EOL] } catch (UnsupportedOperationException e) { [EOL] } [EOL] }
public void testNormalizedStandardWithSupportedType() { [EOL] PeriodType type = PeriodType.standard(); // Assuming this type supports years and months [EOL] Period period = new Period(1, 1, 0, 0, 0, 0, 0, 0); // 1 year, 1 month [EOL] Period result = period.normalizedStandard(type); [EOL] assertEquals(1, result.getYears()); [EOL] assertEquals(1, result.getMonths()); [EOL] }
public void testNormalizedStandardWithNoYearsOrMonths() { [EOL] PeriodType type = PeriodType.standard(); // Assuming this type supports years and months [EOL] Period period = new Period(0, 0, 0, 0, 0, 0, 0, 0); // No years, no months [EOL] Period result = period.normalizedStandard(type); [EOL] assertEquals(0, result.getYears()); [EOL] assertEquals(0, result.getMonths()); [EOL] }
public void testNormalizedStandardWithOnlyYears() { [EOL] PeriodType type = PeriodType.standard(); // Assuming this type supports years and months [EOL] Period period = new Period(1, 0, 0, 0, 0, 0, 0, 0); // 1 year [EOL] Period result = period.normalizedStandard(type); [EOL] assertEquals(1, result.getYears()); [EOL] assertEquals(0, result.getMonths()); [EOL] }
public void testNormalizedStandardWithOnlyMonths() { [EOL] PeriodType type = PeriodType.standard(); // Assuming this type supports years and months [EOL] Period period = new Period(0, 1, 0, 0, 0, 0, 0, 0); // 1 month [EOL] Period result = period.normalizedStandard(type); [EOL] assertEquals(0, result.getYears()); [EOL] assertEquals(1, result.getMonths()); [EOL] }
public void testGetInstanceUTC() { [EOL] IslamicChronology result = IslamicChronology.getInstanceUTC(); [EOL] assertNotNull(result); [EOL] assertSame(IslamicChronology.INSTANCE_UTC, result); [EOL] }
public void testGetDaysInYearMax() { [EOL] Time time = new Time(); [EOL] int days = time.getDaysInYearMax(); [EOL] assertEquals(355, days); [EOL] }
public void testGetDaysInYear_LeapYear() { [EOL] int year = 2020; // Example leap year [EOL] int expectedDays = 355; [EOL] int actualDays = getDaysInYear(year); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testGetDaysInYear_NonLeapYear() { [EOL] int year = 2021; // Example non-leap year [EOL] int expectedDays = 354; [EOL] int actualDays = getDaysInYear(year); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testGetDaysInMonthMax() { [EOL] Time time = new Time(); [EOL] int days = time.getDaysInMonthMax(); [EOL] assertEquals(Time.LONG_MONTH_LENGTH, days); [EOL] }
public void testCalculateFirstDayOfYearMillis_MaxYear() { [EOL] int year = MAX_YEAR; [EOL] try { [EOL] long millis = calculateFirstDayOfYearMillis(year); [EOL] } catch (ArithmeticException e) { [EOL] fail("Should not throw an exception for max year"); [EOL] } [EOL] }
public void testCalculateFirstDayOfYearMillis_TooLargeYear() { [EOL] int year = MAX_YEAR + 1; [EOL] try { [EOL] calculateFirstDayOfYearMillis(year); [EOL] fail("Should have thrown an exception for year too large"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("Year is too large: " + year + " > " + MAX_YEAR, e.getMessage()); [EOL] } [EOL] }
public void testCalculateFirstDayOfYearMillis_MinYear() { [EOL] int year = MIN_YEAR; [EOL] try { [EOL] long millis = calculateFirstDayOfYearMillis(year); [EOL] } catch (ArithmeticException e) { [EOL] fail("Should not throw an exception for min year"); [EOL] } [EOL] }
public void testCalculateFirstDayOfYearMillis_TooSmallYear() { [EOL] int year = MIN_YEAR - 1; [EOL] try { [EOL] calculateFirstDayOfYearMillis(year); [EOL] fail("Should have thrown an exception for year too small"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("Year is too small: " + year + " < " + MIN_YEAR, e.getMessage()); [EOL] } [EOL] }
public void testCalculateFirstDayOfYearMillis_LeapYear() { [EOL] int year = SOME_LEAP_YEAR; // Replace with an actual leap year within the valid range [EOL] long millis = calculateFirstDayOfYearMillis(year); [EOL] }
public void testCalculateFirstDayOfYearMillis_NonLeapYear() { [EOL] int year = SOME_NON_LEAP_YEAR; // Replace with an actual non-leap year within the valid range [EOL] long millis = calculateFirstDayOfYearMillis(year); [EOL] }
public void testGetInstanceWithNullZoneAndNullCutover() { [EOL] GJChronology chrono = GJChronology.getInstance(null, null, 4); [EOL] assertNotNull(chrono); [EOL] assertEquals(DateTimeZone.UTC, chrono.getZone()); [EOL] assertEquals(GJChronology.DEFAULT_CUTOVER, chrono.getGregorianCutover()); [EOL] assertEquals(4, chrono.getMinimumDaysInFirstWeek()); [EOL] }
public void testGetInstanceWithNullZoneAndValidCutover() { [EOL] ReadableInstant cutover = new Instant(new LocalDate(1582, 10, 15).toDateTimeAtStartOfDay(DateTimeZone.UTC)); [EOL] GJChronology chrono = GJChronology.getInstance(null, cutover, 4); [EOL] assertNotNull(chrono); [EOL] assertEquals(DateTimeZone.UTC, chrono.getZone()); [EOL] assertEquals(cutover.toInstant(), chrono.getGregorianCutover()); [EOL] assertEquals(4, chrono.getMinimumDaysInFirstWeek()); [EOL] }
public void testGetInstanceWithInvalidCutover() { [EOL] ReadableInstant cutover = new Instant(new LocalDate(0, 1, 1).toDateTimeAtStartOfDay(DateTimeZone.UTC)); [EOL] try { [EOL] GJChronology.getInstance(null, cutover, 4); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetInstanceWithNonUTCZoneAndNullCutover() { [EOL] DateTimeZone nonUTC = DateTimeZone.forID("Europe/Paris"); [EOL] GJChronology chrono = GJChronology.getInstance(nonUTC, null, 4); [EOL] assertNotNull(chrono); [EOL] assertEquals(nonUTC, chrono.getZone()); [EOL] assertEquals(GJChronology.DEFAULT_CUTOVER, chrono.getGregorianCutover()); [EOL] assertEquals(4, chrono.getMinimumDaysInFirstWeek()); [EOL] }
public void testGetInstanceWithNonUTCZoneAndValidCutover() { [EOL] DateTimeZone nonUTC = DateTimeZone.forID("Europe/Paris"); [EOL] ReadableInstant cutover = new Instant(new LocalDate(1582, 10, 15).toDateTimeAtStartOfDay(nonUTC)); [EOL] GJChronology chrono = GJChronology.getInstance(nonUTC, cutover, 4); [EOL] assertNotNull(chrono); [EOL] assertEquals(nonUTC, chrono.getZone()); [EOL] assertEquals(cutover.toInstant(), chrono.getGregorianCutover()); [EOL] assertEquals(4, chrono.getMinimumDaysInFirstWeek()); [EOL] }
public void testGetInstanceWithCachedChronology() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] ReadableInstant cutover = new Instant(new LocalDate(1582, 10, 15).toDateTimeAtStartOfDay(zone)); [EOL] GJChronology firstChrono = GJChronology.getInstance(zone, cutover, 4); [EOL] GJChronology secondChrono = GJChronology.getInstance(zone, cutover, 4); [EOL] assertSame(firstChrono, secondChrono); [EOL] }
public void testGetInstanceWithDifferentMinDaysInFirstWeek() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] ReadableInstant cutover = new Instant(new LocalDate(1582, 10, 15).toDateTimeAtStartOfDay(zone)); [EOL] GJChronology firstChrono = GJChronology.getInstance(zone, cutover, 4); [EOL] GJChronology secondChrono = GJChronology.getInstance(zone, cutover, 2); [EOL] assertNotSame(firstChrono, secondChrono); [EOL] assertEquals(2, secondChrono.getMinimumDaysInFirstWeek()); [EOL] }
public int getDifference(long minuendInstant, long subtrahendInstant) { [EOL] if (minuendInstant >= iCutover) { [EOL] if (subtrahendInstant >= iCutover) { [EOL] return iGregorianField.getDifference(minuendInstant, subtrahendInstant); [EOL] } [EOL] minuendInstant = gregorianToJulian(minuendInstant); [EOL] return iJulianField.getDifference(minuendInstant, subtrahendInstant); [EOL] } else { [EOL] if (subtrahendInstant < iCutover) { [EOL] return iJulianField.getDifference(minuendInstant, subtrahendInstant); [EOL] } [EOL] minuendInstant = julianToGregorian(minuendInstant); [EOL] return iGregorianField.getDifference(minuendInstant, subtrahendInstant); [EOL] } [EOL] }
public void testGetPartialValuesWithValidInput() { [EOL] ReadablePartial mockPartial = Mockito.mock(ReadablePartial.class); [EOL] Object mockObject = new Object(); [EOL] Chronology mockChrono = Mockito.mock(Chronology.class); [EOL] long expectedInstant = 1234567890L; [EOL] int[] expectedValues = new int[]{1, 2, 3}; [EOL] Mockito.when(mockChrono.getInstantMillis(mockObject, mockChrono)).thenReturn(expectedInstant); [EOL] Mockito.when(mockChrono.get(mockPartial, expectedInstant)).thenReturn(expectedValues); [EOL] int[] actualValues = getPartialValues(mockPartial, mockObject, mockChrono); [EOL] assertArrayEquals(expectedValues, actualValues); [EOL] }
public void testGetPartialValuesWithNullChronology() { [EOL] ReadablePartial mockPartial = Mockito.mock(ReadablePartial.class); [EOL] Object mockObject = new Object(); [EOL] Chronology nullChrono = null; [EOL] long expectedInstant = 1234567890L; [EOL] int[] expectedValues = new int[]{1, 2, 3}; [EOL] Mockito.when(getInstantMillis(mockObject, nullChrono)).thenReturn(expectedInstant); [EOL] Mockito.when(ISOChronology.getInstance().get(mockPartial, expectedInstant)).thenReturn(expectedValues); [EOL] int[] actualValues = getPartialValues(mockPartial, mockObject, nullChrono); [EOL] assertArrayEquals(expectedValues, actualValues); [EOL] }
public int[] getPartialValuesTestWithNullFieldSource() { [EOL] try { [EOL] getPartialValues(null, new Object(), Chronology.getISO(), new DateTimeFormatter()); [EOL] fail("Should have thrown IllegalArgumentException because fieldSource is null"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public int[] getPartialValuesTestWithNullObject() { [EOL] try { [EOL] getPartialValues(new ReadablePartialMock(), null, Chronology.getISO(), new DateTimeFormatter()); [EOL] fail("Should have thrown IllegalArgumentException because object is null"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public int[] getPartialValuesTestWithNullChronology() { [EOL] try { [EOL] getPartialValues(new ReadablePartialMock(), new Object(), null, new DateTimeFormatter()); [EOL] fail("Should have thrown IllegalArgumentException because chrono is null"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public int[] getPartialValuesTestWithValidArguments() { [EOL] int[] values = getPartialValues(new ReadablePartialMock(), new Object(), Chronology.getISO(), new DateTimeFormatter()); [EOL] assertNotNull("Values should not be null", values); [EOL] }
public boolean isReadableInterval(Object object, Chronology chrono) { [EOL] return false; [EOL] }
public void testGetDurationMillis_ValidFormat_Positive() { [EOL] Time time = new Time(); [EOL] String input = "PT15S"; [EOL] long expected = 15000L; [EOL] long result = time.getDurationMillis(input); [EOL] assertEquals(expected, result); [EOL] }
public void testGetDurationMillis_ValidFormat_Negative() { [EOL] Time time = new Time(); [EOL] String input = "PT-15S"; [EOL] long expected = -15000L; [EOL] long result = time.getDurationMillis(input); [EOL] assertEquals(expected, result); [EOL] }
public void testGetDurationMillis_ValidFormat_WithMillis() { [EOL] Time time = new Time(); [EOL] String input = "PT15.123S"; [EOL] long expected = 15123L; [EOL] long result = time.getDurationMillis(input); [EOL] assertEquals(expected, result); [EOL] }
public void testGetDurationMillis_InvalidFormat() { [EOL] Time time = new Time(); [EOL] String input = "Invalid"; [EOL] try { [EOL] time.getDurationMillis(input); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDurationMillis_InvalidNumberFormat() { [EOL] Time time = new Time(); [EOL] String input = "PT15.S"; [EOL] try { [EOL] time.getDurationMillis(input); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetPeriodTypeWithValidPeriod() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] when(mockPeriod.getPeriodType()).thenReturn(PeriodType.standard()); [EOL] PeriodType result = getPeriodType(mockPeriod); [EOL] assertEquals(PeriodType.standard(), result); [EOL] }
public void testGetPeriodTypeWithNull() { [EOL] try { [EOL] getPeriodType(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testGetSupportedType() { [EOL] Time time = new Time(); [EOL] Class<?> supportedType = time.getSupportedType(); [EOL] assertEquals(ReadablePeriod.class, supportedType); [EOL] }
public void testSet_ValueWithinBounds() { [EOL] long millis = System.currentTimeMillis(); [EOL] int value = iMinValue + 1; // Assuming iMinValue is a valid minimum value for the field [EOL] if (value <= iSkip) { [EOL] value--; [EOL] } [EOL] long expected = super.set(millis, value); // Assuming super.set() is correctly implemented [EOL] long actual = set(millis, value); [EOL] assertEquals(expected, actual); [EOL] }
public void testSet_ValueAtMinBoundary() { [EOL] long millis = System.currentTimeMillis(); [EOL] int value = iMinValue; [EOL] if (value <= iSkip) { [EOL] value--; [EOL] } [EOL] long expected = super.set(millis, value); [EOL] long actual = set(millis, value); [EOL] assertEquals(expected, actual); [EOL] }
public void testSet_ValueAtMaxBoundary() { [EOL] long millis = System.currentTimeMillis(); [EOL] int value = getMaximumValue(); // Assuming getMaximumValue() returns the valid maximum value for the field [EOL] if (value <= iSkip) { [EOL] value--; [EOL] } [EOL] long expected = super.set(millis, value); [EOL] long actual = set(millis, value); [EOL] assertEquals(expected, actual); [EOL] }
public void testSet_ValueBelowMinBoundary() { [EOL] long millis = System.currentTimeMillis(); [EOL] int value = iMinValue - 1; // This should trigger an IllegalArgumentException [EOL] try { [EOL] set(millis, value); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSet_ValueAboveMaxBoundary() { [EOL] long millis = System.currentTimeMillis(); [EOL] int value = getMaximumValue() + 1; // This should trigger an IllegalArgumentException [EOL] try { [EOL] set(millis, value); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSet_ValueEqualToSkip() { [EOL] long millis = System.currentTimeMillis(); [EOL] int value = iSkip; // Assuming iSkip is a valid skip value for the field [EOL] value--; // Adjust for skip [EOL] long expected = super.set(millis, value); [EOL] long actual = set(millis, value); [EOL] assertEquals(expected, actual); [EOL] }
public void testAppendWithNullFormatter() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] try { [EOL] builder.append(null); [EOL] fail("Should have thrown IllegalArgumentException for null formatter"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendWithNonNullFormatter() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] PeriodFormatter formatter = new PeriodFormatterBuilder().toFormatter(); [EOL] builder.append(formatter); [EOL] }
public void testMinimumPrintedDigits_ValidInput() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] PeriodFormatterBuilder returnedBuilder = builder.minimumPrintedDigits(2); [EOL] assertNotNull(returnedBuilder); [EOL] assertSame(builder, returnedBuilder); [EOL] }
public void testMinimumPrintedDigits_NegativeInput() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] try { [EOL] builder.minimumPrintedDigits(-1); [EOL] fail("Should have thrown IllegalArgumentException for negative input"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testPrintZeroRarelyFirst() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] PeriodFormatterBuilder returnedBuilder = builder.printZeroRarelyFirst(); [EOL] assertNotNull(returnedBuilder); [EOL] assertSame(builder, returnedBuilder); [EOL] }
public void testAppendYears() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] PeriodFormatterBuilder result = builder.appendYears(); [EOL] assertNotNull(result); [EOL] assertSame(builder, result); [EOL] }
public void testAppendMinutes() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] PeriodFormatterBuilder result = builder.appendMinutes(); [EOL] assertNotNull(result); [EOL] assertSame(builder, result); [EOL] }
public void testAppendSecondsWithOptionalMillis() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] builder.appendSecondsWithOptionalMillis(); [EOL] assertTrue("Should have appended seconds with optional millis", builder.isSecondsWithOptionalMillisAppended()); [EOL] }
public void testAppendSuffix_WithValidSingularAndPluralText() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] String singularText = "day"; [EOL] String pluralText = "days"; [EOL] builder.appendSuffix(singularText, pluralText); [EOL] } [EOL] public void testAppendSuffix_WithNullSingularText() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] String singularText = null; [EOL] String pluralText = "days"; [EOL] try { [EOL] builder.appendSuffix(singularText, pluralText); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testAppendSuffix_WithNullPluralText() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] String singularText = "day"; [EOL] String pluralText = null; [EOL] try { [EOL] builder.appendSuffix(singularText, pluralText); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendSeparatorWithNonNullText() { [EOL] PeriodFormatterBuilder builder = new PeriodFormatterBuilder(); [EOL] String separatorText = "separator"; [EOL] PeriodFormatterBuilder result = builder.appendSeparator(separatorText); [EOL] assertNotNull(result); [EOL] }

public void testToFormatterThrowsIllegalStateException() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] boolean notPrinter = true; [EOL] boolean notParser = true; [EOL] try { [EOL] toFormatter(elementPairs, notPrinter, notParser); [EOL] fail("Should have thrown IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testToFormatterWithSeparatorAsFirstElement() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] elementPairs.add(new Separator(null, null)); [EOL] elementPairs.add(new Object()); // Dummy to satisfy size >= 2 condition [EOL] boolean notPrinter = false; [EOL] boolean notParser = false; [EOL] PeriodFormatter result = toFormatter(elementPairs, notPrinter, notParser); [EOL] assertNotNull(result); [EOL] }
public void testToFormatterWithNotPrinter() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] elementPairs.add(new Object()); // Dummy to avoid Separator condition [EOL] boolean notPrinter = true; [EOL] boolean notParser = false; [EOL] PeriodFormatter result = toFormatter(elementPairs, notPrinter, notParser); [EOL] assertNull(result.getPrinter()); [EOL] assertNotNull(result.getParser()); [EOL] }
public void testToFormatterWithNotParser() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] elementPairs.add(new Object()); // Dummy to avoid Separator condition [EOL] boolean notPrinter = false; [EOL] boolean notParser = true; [EOL] PeriodFormatter result = toFormatter(elementPairs, notPrinter, notParser); [EOL] assertNotNull(result.getPrinter()); [EOL] assertNull(result.getParser()); [EOL] }
public void testToFormatterWithPrinterAndParser() { [EOL] List<Object> elementPairs = new ArrayList<>(); [EOL] elementPairs.add(new Object()); // Dummy to avoid Separator condition [EOL] boolean notPrinter = false; [EOL] boolean notParser = false; [EOL] PeriodFormatter result = toFormatter(elementPairs, notPrinter, notParser); [EOL] assertNotNull(result.getPrinter()); [EOL] assertNotNull(result.getParser()); [EOL] }
public void testParseMatch() { [EOL] String periodStr = "testString"; [EOL] int position = 0; [EOL] int expected = "testString".length(); [EOL] int actual = parse(periodStr, position); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testParseNoMatch() { [EOL] String periodStr = "differentString"; [EOL] int position = 0; [EOL] int expected = ~position; [EOL] int actual = parse(periodStr, position); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testParsePartialMatch() { [EOL] String periodStr = "test"; [EOL] int position = 0; [EOL] int expected = ~position; [EOL] int actual = parse(periodStr, position); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testParseMatchWithOffset() { [EOL] String periodStr = "randomtestString"; [EOL] int position = 6; [EOL] int expected = position + "testString".length(); [EOL] int actual = parse(periodStr, position); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testParseNoMatchWithOffset() { [EOL] String periodStr = "randomDifferentString"; [EOL] int position = 6; [EOL] int expected = ~position; [EOL] int actual = parse(periodStr, position); [EOL] assertEquals(expected, actual); [EOL] }
public void testScanWithMatchingString() { [EOL] int position = 0; [EOL] String periodStr = "testString"; [EOL] int result = scan(periodStr, position); [EOL] assertEquals("Expected position where string matches", position, result); [EOL] } [EOL] public void testScanWithNoMatchAndNoSpecialCharacters() { [EOL] int position = 0; [EOL] String periodStr = "nomatch"; [EOL] int result = scan(periodStr, position); [EOL] assertEquals("Expected negative position when no match is found", ~position, result); [EOL] } [EOL] public void testScanWithSpecialCharacterBreakingSearch() { [EOL] int position = 0; [EOL] String periodStr = "test#String"; [EOL] int result = scan(periodStr, position); [EOL] assertEquals("Expected negative position when search breaks on special character", ~position, result); [EOL] } [EOL] public void testScanWithSpecialCharacterNotBreakingSearch() { [EOL] int position = 0; [EOL] String periodStr = "test1String"; [EOL] int result = scan(periodStr, position); [EOL] assertEquals("Expected negative position when search continues with special character", ~position, result); [EOL] } [EOL] public void testScanWithPositionBeyondSourceLength() { [EOL] int position = 20; [EOL] String periodStr = "short"; [EOL] int result = scan(periodStr, position); [EOL] assertEquals("Expected negative position when initial position is beyond source length", ~position, result); [EOL] }
public void testParseInto_PositionGreaterThanTextLength_PrintZeroAlways() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String text = ""; [EOL] int position = 1; [EOL] Locale locale = Locale.getDefault(); [EOL] int result = parseInto(mockPeriod, text, position, locale); [EOL] assertEquals(~position, result); [EOL] } [EOL] public void testParseInto_PositionGreaterThanTextLength_PrintZeroNever() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String text = ""; [EOL] int position = 1; [EOL] Locale locale = Locale.getDefault(); [EOL] setPrintZeroSetting(PRINT_ZERO_NEVER); [EOL] int result = parseInto(mockPeriod, text, position, locale); [EOL] assertEquals(position, result); [EOL] }
public void testParseInto_PrefixNotNullAndPositionNegative_MustParseFalse() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String text = "prefix"; [EOL] int position = 0; [EOL] Locale locale = Locale.getDefault(); [EOL] setPrefix(new MockPrefix(-1)); [EOL] setPrintZeroSetting(PRINT_ZERO_NEVER); [EOL] int result = parseInto(mockPeriod, text, position, locale); [EOL] assertEquals(~(-1), result); [EOL] } [EOL] public void testParseInto_PrefixNotNullAndPositionNegative_MustParseTrue() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String text = "prefix"; [EOL] int position = 0; [EOL] Locale locale = Locale.getDefault(); [EOL] setPrefix(new MockPrefix(-1)); [EOL] setPrintZeroSetting(PRINT_ZERO_ALWAYS); [EOL] int result = parseInto(mockPeriod, text, position, locale); [EOL] assertEquals(-1, result); [EOL] }
public void testParseInto_SuffixNotNullAndMustParseFalse_SuffixPosNegative() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String text = "suffix"; [EOL] int position = 0; [EOL] Locale locale = Locale.getDefault(); [EOL] setSuffix(new MockSuffix(-1)); [EOL] setPrintZeroSetting(PRINT_ZERO_NEVER); [EOL] int result = parseInto(mockPeriod, text, position, locale); [EOL] assertEquals(~(-1), result); [EOL] } [EOL] public void testParseInto_SuffixNotNullAndMustParseFalse_SuffixPosPositive() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String text = "suffix"; [EOL] int position = 0; [EOL] Locale locale = Locale.getDefault(); [EOL] setSuffix(new MockSuffix(1)); [EOL] setPrintZeroSetting(PRINT_ZERO_NEVER); [EOL] int result = parseInto(mockPeriod, text, position, locale); [EOL] assertEquals(position, result); [EOL] }
public void testParseInto_PeriodNotSupportedAndMustParseFalse() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String text = "text"; [EOL] int position = 0; [EOL] Locale locale = Locale.getDefault(); [EOL] setPrintZeroSetting(PRINT_ZERO_NEVER); [EOL] setFieldType(UNSUPPORTED_FIELD_TYPE); [EOL] int result = parseInto(mockPeriod, text, position, locale); [EOL] assertEquals(position, result); [EOL] }
public void testParseInto_HasDigitsAndSuffixPosNotEqualToPositionPlusLength() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String text = "123suffix"; [EOL] int position = 0; [EOL] Locale locale = Locale.getDefault(); [EOL] setSuffix(new MockSuffix(6)); [EOL] setPrintZeroSetting(PRINT_ZERO_ALWAYS); [EOL] int result = parseInto(mockPeriod, text, position, locale); [EOL] assertEquals(position, result); [EOL] }
public void testParseInto_HasDigitsAndFieldTypeNotSecondsMillis() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String text = "123"; [EOL] int position = 0; [EOL] Locale locale = Locale.getDefault(); [EOL] setFieldType(NOT_SECONDS_MILLIS_FIELD_TYPE); [EOL] setPrintZeroSetting(PRINT_ZERO_ALWAYS); [EOL] int result = parseInto(mockPeriod, text, position, locale); [EOL] assertNotEquals(~position, result); [EOL] }
public void testParseInto_HasDigitsAndFieldTypeSecondsMillis_NoFraction() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String text = "123"; [EOL] int position = 0; [EOL] Locale locale = Locale.getDefault(); [EOL] setFieldType(SECONDS_MILLIS); [EOL] setPrintZeroSetting(PRINT_ZERO_ALWAYS); [EOL] int result = parseInto(mockPeriod, text, position, locale); [EOL] assertNotEquals(~position, result); [EOL] }
public void testParseInto_HasDigitsAndFieldTypeSecondsMillis_WithFraction() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String text = "123.456"; [EOL] int position = 0; [EOL] Locale locale = Locale.getDefault(); [EOL] setFieldType(SECONDS_MILLIS); [EOL] setPrintZeroSetting(PRINT_ZERO_ALWAYS); [EOL] int result = parseInto(mockPeriod, text, position, locale); [EOL] assertNotEquals(~position, result); [EOL] }
public void testParseInto_SuffixNotNullAndPositionPositive() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String text = "123suffix"; [EOL] int position = 0; [EOL] Locale locale = Locale.getDefault(); [EOL] setSuffix(new MockSuffix(3)); [EOL] setPrintZeroSetting(PRINT_ZERO_ALWAYS); [EOL] int result = parseInto(mockPeriod, text, position, locale); [EOL] assertNotEquals(~position, result); [EOL] }
public void testParseIntWithLengthGreaterThanNine() { [EOL] int result = parseInt("12345678901", 0, 10); [EOL] assertEquals(1234567890, result); [EOL] }
public void testParseIntWithLengthLessThanOrEqualToZero() { [EOL] int result = parseInt("123", 1, 0); [EOL] assertEquals(0, result); [EOL] }
public void testParseIntWithNegativeNumber() { [EOL] int result = parseInt("-123", 0, 4); [EOL] assertEquals(-123, result); [EOL] }
public void testParseIntWithPositiveNumber() { [EOL] int result = parseInt("123", 0, 3); [EOL] assertEquals(123, result); [EOL] }
public void testParseIntWithMaxLengthJustBelowTen() { [EOL] int result = parseInt("123456789", 0, 9); [EOL] assertEquals(123456789, result); [EOL] }
public void testParseIntWithNegativeAndLengthBelowZeroAfterDecrement() { [EOL] int result = parseInt("-1", 0, 2); [EOL] assertEquals(0, result); [EOL] }
public void testGetFieldValue_PrintZeroAlwaysAndTypeNotNullAndFieldTypeNotSupported() { [EOL] ReadablePeriod period = createPeriodWithUnsupportedType(); [EOL] setPrintZeroSetting(PRINT_ZERO_ALWAYS); [EOL] long result = getFieldValue(period); [EOL] assertEquals(Long.MAX_VALUE, result); [EOL] }
public void testGetFieldValue_PrintZeroAlwaysAndTypeNotNullAndFieldTypeSupported() { [EOL] ReadablePeriod period = createPeriodWithType(); [EOL] setPrintZeroSetting(PRINT_ZERO_ALWAYS); [EOL] long result = getFieldValue(period); [EOL] assertNotEquals(Long.MAX_VALUE, result); [EOL] }
public void testGetFieldValue_TypeNotNullAndFieldTypeSupportedAndValueIsZero_PrintZeroNever() { [EOL] ReadablePeriod period = createPeriodWithZeroValue(); [EOL] setPrintZeroSetting(PRINT_ZERO_NEVER); [EOL] long result = getFieldValue(period); [EOL] assertEquals(Long.MAX_VALUE, result); [EOL] }
public void testGetFieldValue_TypeNotNullAndFieldTypeSupportedAndValueIsZero_PrintZeroRarelyLast() { [EOL] ReadablePeriod period = createPeriodWithZeroValue(); [EOL] setPrintZeroSetting(PRINT_ZERO_RARELY_LAST); [EOL] long result = getFieldValue(period); [EOL] assertEquals(Long.MAX_VALUE, result); [EOL] }
public void testGetFieldValue_TypeNotNullAndFieldTypeSupportedAndValueIsZero_PrintZeroRarelyFirst() { [EOL] ReadablePeriod period = createPeriodWithZeroValue(); [EOL] setPrintZeroSetting(PRINT_ZERO_RARELY_FIRST); [EOL] long result = getFieldValue(period); [EOL] assertEquals(Long.MAX_VALUE, result); [EOL] }
public void testGetFieldValue_TypeNotNullAndFieldTypeSupportedAndValueNonZero() { [EOL] ReadablePeriod period = createPeriodWithNonZeroValue(); [EOL] setPrintZeroSetting(PRINT_ZERO_ALWAYS); // This can be any setting since the value is non-zero [EOL] long result = getFieldValue(period); [EOL] assertNotEquals(Long.MAX_VALUE, result); [EOL] long expectedValue = calculateExpectedValue(period); [EOL] assertEquals(expectedValue, result); [EOL] }
public void testGetFieldValue_TypeNull() { [EOL] ReadablePeriod period = createPeriodWithNullType(); [EOL] setPrintZeroSetting(PRINT_ZERO_ALWAYS); // This can be any setting since type is null [EOL] long result = getFieldValue(period); [EOL] assertNotEquals(Long.MAX_VALUE, result); [EOL] }
public void testIsSupported_WithUnsupportedField() { [EOL] PeriodType mockType = Mockito.mock(PeriodType.class); [EOL] boolean result = isSupported(mockType, -1); // Assuming -1 is an unsupported field [EOL] assertFalse(result); [EOL] }
public void testIsSupported_WithYearsField() { [EOL] PeriodType mockType = Mockito.mock(PeriodType.class); [EOL] Mockito.when(mockType.isSupported(DurationFieldType.years())).thenReturn(true); [EOL] boolean result = isSupported(mockType, YEARS); [EOL] assertTrue(result); [EOL] }
public void testIsSupported_WithMonthsField() { [EOL] PeriodType mockType = Mockito.mock(PeriodType.class); [EOL] Mockito.when(mockType.isSupported(DurationFieldType.months())).thenReturn(true); [EOL] boolean result = isSupported(mockType, MONTHS); [EOL] assertTrue(result); [EOL] }
public void testIsSupported_WithWeeksField() { [EOL] PeriodType mockType = Mockito.mock(PeriodType.class); [EOL] Mockito.when(mockType.isSupported(DurationFieldType.weeks())).thenReturn(true); [EOL] boolean result = isSupported(mockType, WEEKS); [EOL] assertTrue(result); [EOL] }
public void testIsSupported_WithDaysField() { [EOL] PeriodType mockType = Mockito.mock(PeriodType.class); [EOL] Mockito.when(mockType.isSupported(DurationFieldType.days())).thenReturn(true); [EOL] boolean result = isSupported(mockType, DAYS); [EOL] assertTrue(result); [EOL] }
public void testIsSupported_WithHoursField() { [EOL] PeriodType mockType = Mockito.mock(PeriodType.class); [EOL] Mockito.when(mockType.isSupported(DurationFieldType.hours())).thenReturn(true); [EOL] boolean result = isSupported(mockType, HOURS); [EOL] assertTrue(result); [EOL] }
public void testIsSupported_WithMinutesField() { [EOL] PeriodType mockType = Mockito.mock(PeriodType.class); [EOL] Mockito.when(mockType.isSupported(DurationFieldType.minutes())).thenReturn(true); [EOL] boolean result = isSupported(mockType, MINUTES); [EOL] assertTrue(result); [EOL] }
public void testIsSupported_WithSecondsField() { [EOL] PeriodType mockType = Mockito.mock(PeriodType.class); [EOL] Mockito.when(mockType.isSupported(DurationFieldType.seconds())).thenReturn(true); [EOL] boolean result = isSupported(mockType, SECONDS); [EOL] assertTrue(result); [EOL] }
public void testIsSupported_WithMillisField() { [EOL] PeriodType mockType = Mockito.mock(PeriodType.class); [EOL] Mockito.when(mockType.isSupported(DurationFieldType.millis())).thenReturn(true); [EOL] boolean result = isSupported(mockType, MILLIS); [EOL] assertTrue(result); [EOL] }
public void testIsSupported_WithSecondsMillisField() { [EOL] PeriodType mockType = Mockito.mock(PeriodType.class); [EOL] Mockito.when(mockType.isSupported(DurationFieldType.seconds())).thenReturn(false); [EOL] Mockito.when(mockType.isSupported(DurationFieldType.millis())).thenReturn(true); [EOL] boolean result = isSupported(mockType, SECONDS_MILLIS); [EOL] assertTrue(result); [EOL] }
public void testIsSupported_WithSecondsOptionalMillisField_WhenBothSupported() { [EOL] PeriodType mockType = Mockito.mock(PeriodType.class); [EOL] Mockito.when(mockType.isSupported(DurationFieldType.seconds())).thenReturn(true); [EOL] Mockito.when(mockType.isSupported(DurationFieldType.millis())).thenReturn(true); [EOL] boolean result = isSupported(mockType, SECONDS_OPTIONAL_MILLIS); [EOL] assertTrue(result); [EOL] }
public void testSetFieldValueWithYears() { [EOL] ReadWritablePeriod mockPeriod = Mockito.mock(ReadWritablePeriod.class); [EOL] int field = YEARS; [EOL] int value = 10; [EOL] setFieldValue(mockPeriod, field, value); [EOL] Mockito.verify(mockPeriod).setYears(value); [EOL] }
public void testSetFieldValueWithMonths() { [EOL] ReadWritablePeriod mockPeriod = Mockito.mock(ReadWritablePeriod.class); [EOL] int field = MONTHS; [EOL] int value = 5; [EOL] setFieldValue(mockPeriod, field, value); [EOL] Mockito.verify(mockPeriod).setMonths(value); [EOL] }
public void testSetFieldValueWithWeeks() { [EOL] ReadWritablePeriod mockPeriod = Mockito.mock(ReadWritablePeriod.class); [EOL] int field = WEEKS; [EOL] int value = 3; [EOL] setFieldValue(mockPeriod, field, value); [EOL] Mockito.verify(mockPeriod).setWeeks(value); [EOL] }
public void testSetFieldValueWithDays() { [EOL] ReadWritablePeriod mockPeriod = Mockito.mock(ReadWritablePeriod.class); [EOL] int field = DAYS; [EOL] int value = 7; [EOL] setFieldValue(mockPeriod, field, value); [EOL] Mockito.verify(mockPeriod).setDays(value); [EOL] }
public void testSetFieldValueWithHours() { [EOL] ReadWritablePeriod mockPeriod = Mockito.mock(ReadWritablePeriod.class); [EOL] int field = HOURS; [EOL] int value = 24; [EOL] setFieldValue(mockPeriod, field, value); [EOL] Mockito.verify(mockPeriod).setHours(value); [EOL] }
public void testSetFieldValueWithMinutes() { [EOL] ReadWritablePeriod mockPeriod = Mockito.mock(ReadWritablePeriod.class); [EOL] int field = MINUTES; [EOL] int value = 45; [EOL] setFieldValue(mockPeriod, field, value); [EOL] Mockito.verify(mockPeriod).setMinutes(value); [EOL] }
public void testSetFieldValueWithSeconds() { [EOL] ReadWritablePeriod mockPeriod = Mockito.mock(ReadWritablePeriod.class); [EOL] int field = SECONDS; [EOL] int value = 30; [EOL] setFieldValue(mockPeriod, field, value); [EOL] Mockito.verify(mockPeriod).setSeconds(value); [EOL] }
public void testSetFieldValueWithMillis() { [EOL] ReadWritablePeriod mockPeriod = Mockito.mock(ReadWritablePeriod.class); [EOL] int field = MILLIS; [EOL] int value = 100; [EOL] setFieldValue(mockPeriod, field, value); [EOL] Mockito.verify(mockPeriod).setMillis(value); [EOL] }
public void testSetFieldValueWithInvalidField() { [EOL] ReadWritablePeriod mockPeriod = Mockito.mock(ReadWritablePeriod.class); [EOL] int field = -1; // Assuming -1 is an invalid field value [EOL] int value = 100; [EOL] setFieldValue(mockPeriod, field, value); [EOL] Mockito.verifyNoInteractions(mockPeriod); [EOL] }
public void testCalculatePrintedLength_BothBeforeAndAfterUsedWithMultipleFields() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] Locale mockLocale = Locale.ENGLISH; [EOL] PeriodPrinter mockBeforePrinter = mock(PeriodPrinter.class); [EOL] PeriodPrinter mockAfterPrinter = mock(PeriodPrinter.class); [EOL] when(mockBeforePrinter.calculatePrintedLength(mockPeriod, mockLocale)).thenReturn(5); [EOL] when(mockAfterPrinter.calculatePrintedLength(mockPeriod, mockLocale)).thenReturn(3); [EOL] when(mockBeforePrinter.countFieldsToPrint(mockPeriod, 1, mockLocale)).thenReturn(1); [EOL] when(mockAfterPrinter.countFieldsToPrint(mockPeriod, 2, mockLocale)).thenReturn(2); [EOL] when(iText.length()).thenReturn(4); [EOL] when(iFinalText.length()).thenReturn(6); [EOL] int result = calculatePrintedLength(mockPeriod, mockLocale); [EOL] assertEquals(14, result); [EOL] }
public void testCalculatePrintedLength_OnlyBeforeUsed() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] Locale mockLocale = Locale.ENGLISH; [EOL] PeriodPrinter mockBeforePrinter = mock(PeriodPrinter.class); [EOL] PeriodPrinter mockAfterPrinter = mock(PeriodPrinter.class); [EOL] when(mockBeforePrinter.calculatePrintedLength(mockPeriod, mockLocale)).thenReturn(5); [EOL] when(mockAfterPrinter.calculatePrintedLength(mockPeriod, mockLocale)).thenReturn(3); [EOL] when(mockBeforePrinter.countFieldsToPrint(mockPeriod, 1, mockLocale)).thenReturn(1); [EOL] when(mockAfterPrinter.countFieldsToPrint(mockPeriod, 2, mockLocale)).thenReturn(0); [EOL] when(iText.length()).thenReturn(4); [EOL] int result = calculatePrintedLength(mockPeriod, mockLocale); [EOL] assertEquals(9, result); [EOL] }
public void testCalculatePrintedLength_OnlyAfterUsed() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] Locale mockLocale = Locale.ENGLISH; [EOL] PeriodPrinter mockBeforePrinter = mock(PeriodPrinter.class); [EOL] PeriodPrinter mockAfterPrinter = mock(PeriodPrinter.class); [EOL] when(mockBeforePrinter.calculatePrintedLength(mockPeriod, mockLocale)).thenReturn(5); [EOL] when(mockAfterPrinter.calculatePrintedLength(mockPeriod, mockLocale)).thenReturn(3); [EOL] when(mockBeforePrinter.countFieldsToPrint(mockPeriod, 1, mockLocale)).thenReturn(0); [EOL] when(mockAfterPrinter.countFieldsToPrint(mockPeriod, 1, mockLocale)).thenReturn(1); [EOL] when(iText.length()).thenReturn(4); [EOL] int result = calculatePrintedLength(mockPeriod, mockLocale); [EOL] assertEquals(7, result); [EOL] }
public void testCalculatePrintedLength_NeitherBeforeNorAfterUsed() { [EOL] ReadablePeriod mockPeriod = mock(ReadablePeriod.class); [EOL] Locale mockLocale = Locale.ENGLISH; [EOL] PeriodPrinter mockBeforePrinter = mock(PeriodPrinter.class); [EOL] PeriodPrinter mockAfterPrinter = mock(PeriodPrinter.class); [EOL] when(mockBeforePrinter.calculatePrintedLength(mockPeriod, mockLocale)).thenReturn(5); [EOL] when(mockAfterPrinter.calculatePrintedLength(mockPeriod, mockLocale)).thenReturn(3); [EOL] when(mockBeforePrinter.countFieldsToPrint(mockPeriod, 1, mockLocale)).thenReturn(0); [EOL] when(mockAfterPrinter.countFieldsToPrint(mockPeriod, 1, mockLocale)).thenReturn(0); [EOL] int result = calculatePrintedLength(mockPeriod, mockLocale); [EOL] assertEquals(8, result); [EOL] }
public void testPrintToWithBeforeAndAfter() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = createMockReadablePeriod(); [EOL] PeriodPrinter before = createMockPeriodPrinter(1, "BeforeText"); [EOL] PeriodPrinter after = createMockPeriodPrinter(1, "AfterText"); [EOL] Locale locale = Locale.ENGLISH; [EOL] boolean useBefore = true; [EOL] boolean useAfter = true; [EOL] String text = "Text"; [EOL] String finalText = "FinalText"; [EOL] TwoPeriodPrinter printer = new TwoPeriodPrinter(before, after, useBefore, useAfter, text, finalText); [EOL] printer.printTo(buf, period, locale); [EOL] assertEquals("BeforeTextTextAfterText", buf.toString()); [EOL] }
public void testPrintToWithBeforeOnly() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = createMockReadablePeriod(); [EOL] PeriodPrinter before = createMockPeriodPrinter(1, "BeforeText"); [EOL] PeriodPrinter after = createMockPeriodPrinter(0, ""); [EOL] Locale locale = Locale.ENGLISH; [EOL] boolean useBefore = true; [EOL] boolean useAfter = false; [EOL] String text = "Text"; [EOL] String finalText = "FinalText"; [EOL] TwoPeriodPrinter printer = new TwoPeriodPrinter(before, after, useBefore, useAfter, text, finalText); [EOL] printer.printTo(buf, period, locale); [EOL] assertEquals("BeforeText", buf.toString()); [EOL] }
public void testPrintToWithAfterOnly() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = createMockReadablePeriod(); [EOL] PeriodPrinter before = createMockPeriodPrinter(0, ""); [EOL] PeriodPrinter after = createMockPeriodPrinter(1, "AfterText"); [EOL] Locale locale = Locale.ENGLISH; [EOL] boolean useBefore = false; [EOL] boolean useAfter = true; [EOL] String text = "Text"; [EOL] String finalText = "FinalText"; [EOL] TwoPeriodPrinter printer = new TwoPeriodPrinter(before, after, useBefore, useAfter, text, finalText); [EOL] printer.printTo(buf, period, locale); [EOL] assertEquals("TextAfterText", buf.toString()); [EOL] }
public void testPrintToWithNeitherBeforeNorAfter() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = createMockReadablePeriod(); [EOL] PeriodPrinter before = createMockPeriodPrinter(0, ""); [EOL] PeriodPrinter after = createMockPeriodPrinter(0, ""); [EOL] Locale locale = Locale.ENGLISH; [EOL] boolean useBefore = false; [EOL] boolean useAfter = false; [EOL] String text = "Text"; [EOL] String finalText = "FinalText"; [EOL] TwoPeriodPrinter printer = new TwoPeriodPrinter(before, after, useBefore, useAfter, text, finalText); [EOL] printer.printTo(buf, period, locale); [EOL] assertEquals("", buf.toString()); [EOL] }
public void testPrintToWithBeforeAndMultipleAfter() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] ReadablePeriod period = createMockReadablePeriod(); [EOL] PeriodPrinter before = createMockPeriodPrinter(1, "BeforeText"); [EOL] PeriodPrinter after = createMockPeriodPrinter(2, "AfterText"); [EOL] Locale locale = Locale.ENGLISH; [EOL] boolean useBefore = true; [EOL] boolean useAfter = true; [EOL] String text = "Text"; [EOL] String finalText = "FinalText"; [EOL] TwoPeriodPrinter printer = new TwoPeriodPrinter(before, after, useBefore, useAfter, text, finalText); [EOL] printer.printTo(buf, period, locale); [EOL] assertEquals("BeforeTextFinalTextAfterText", buf.toString()); [EOL] }
public void testParseIntoWithNegativePosition() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String periodStr = "test"; [EOL] int position = -1; [EOL] Locale locale = Locale.getDefault(); [EOL] int result = parseInto(mockPeriod, periodStr, position, locale); [EOL] assertEquals("Negative initial position should return negative", position, result); [EOL] } [EOL] public void testParseIntoWithFoundParsedForm() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String periodStr = "testForm"; [EOL] int position = 0; [EOL] Locale locale = Locale.getDefault(); [EOL] setupParsedForms(new String[]{"Form"}); [EOL] int result = parseInto(mockPeriod, periodStr, position, locale); [EOL] assertTrue("Position should advance if parsed form is found", result > position); [EOL] } [EOL] public void testParseIntoWithUnfoundParsedFormAndUseBeforeFalse() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String periodStr = "test"; [EOL] int position = 0; [EOL] Locale locale = Locale.getDefault(); [EOL] setupParsedForms(new String[]{""}); [EOL] setUseBefore(false); [EOL] int result = parseInto(mockPeriod, periodStr, position, locale); [EOL] assertEquals("Position should not change if parsed form is not found and useBefore is false", position, result); [EOL] } [EOL] public void testParseIntoWithFoundParsedFormAndNoChangeInPosition() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String periodStr = "test"; [EOL] int position = 0; [EOL] Locale locale = Locale.getDefault(); [EOL] setupParsedForms(new String[]{"test"}); [EOL] setAfterParserToNoChange(); [EOL] int result = parseInto(mockPeriod, periodStr, position, locale); [EOL] assertEquals("Should return negated original position if no change in position after finding parsed form", ~position, result); [EOL] } [EOL] public void testParseIntoWithNoFoundParsedFormAndPositionAdvancedAndUseBeforeTrue() { [EOL] ReadWritablePeriod mockPeriod = createMockPeriod(); [EOL] String periodStr = "test"; [EOL] int position = 0; [EOL] Locale locale = Locale.getDefault(); [EOL] setupParsedForms(new String[]{""}); [EOL] setUseBefore(true); [EOL] setAfterParserToAdvancePosition(); [EOL] int result = parseInto(mockPeriod, periodStr, position, locale); [EOL] assertTrue("Position should advance if no parsed form is found but position is advanced and useBefore is true", result > position); [EOL] }
private ReadWritablePeriod createMockPeriod() { [EOL] return null; [EOL] } [EOL] private void setupParsedForms(String[] parsedForms) { [EOL] } [EOL] private void setUseBefore(boolean useBefore) { [EOL] } [EOL] private void setAfterParserToNoChange() { [EOL] } [EOL] private void setAfterParserToAdvancePosition() { [EOL] }
public void testBasicWeekyearDateTimeFieldWithNullChronology() { [EOL] try { [EOL] new BasicWeekyearDateTimeField(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testBasicWeekyearDateTimeFieldWithValidChronology() { [EOL] BasicChronology chronology = Mockito.mock(BasicChronology.class); [EOL] Mockito.when(chronology.getAverageMillisPerYear()).thenReturn(31556952000L); [EOL] BasicWeekyearDateTimeField field = new BasicWeekyearDateTimeField(chronology); [EOL] assertNotNull(field); [EOL] assertEquals(DateTimeFieldType.weekyear(), field.getType()); [EOL] }

public void testSetWithSameYear() { [EOL] long instant = /* some instant */; [EOL] int year = /* the year corresponding to the instant */; [EOL] long expected = instant; [EOL] long actual = set(instant, year); [EOL] assertEquals(expected, actual); [EOL] }
public void testSetWithDifferentYearWithinBounds() { [EOL] long instant = /* some instant */; [EOL] int year = /* a different year within min and max bounds */; [EOL] int expectedWeeksInYear = /* expected weeks in year after setting */; [EOL] int expectedDayOfWeek = /* expected day of week after setting */; [EOL] long expected = /* expected instant after setting the year */; [EOL] long actual = set(instant, year); [EOL] assertEquals(expected, actual); [EOL] }
public void testSetWithYearExceedingMaxOutWeeks() { [EOL] long instant = /* some instant */; [EOL] int year = /* a year such that weeks in year is less than current weeks in year */; [EOL] int maxOutWeeks = /* max out weeks for the year */; [EOL] long expected = /* expected instant after setting the year and adjusting the week */; [EOL] long actual = set(instant, year); [EOL] assertEquals(expected, actual); [EOL] }
public void testSetWithYearAndAdjustWeekUpwards() { [EOL] long instant = /* some instant */; [EOL] int year = /* a year such that the work year is less than the set year */; [EOL] long expected = /* expected instant after setting the year and adjusting the week upwards */; [EOL] long actual = set(instant, year); [EOL] assertEquals(expected, actual); [EOL] }
public void testSetWithYearAndAdjustWeekDownwards() { [EOL] long instant = /* some instant */; [EOL] int year = /* a year such that the work year is greater than the set year */; [EOL] long expected = /* expected instant after setting the year and adjusting the week downwards */; [EOL] long actual = set(instant, year); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetMinimumValue() { [EOL] int expectedValue = /* some expected min year value */; [EOL] int actualValue = /* create an instance of the class containing getMinimumValue() method */.getMinimumValue(); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetMaximumValue() { [EOL] int expectedMaxValue = 9999; // Assuming 9999 is the max year value for the chronology used [EOL] Chronology chronology = new MockChronology(expectedMaxValue); // MockChronology is a hypothetical subclass of Chronology [EOL] Time time = new Time(chronology); [EOL] int actualMaxValue = time.getMaximumValue(); [EOL] assertEquals(expectedMaxValue, actualMaxValue); [EOL] }
@Override [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) { [EOL] return size() > PATTERN_CACHE_SIZE; [EOL] } protected DateTimeFormat(); [EOL] StyleFormatter(int dateStyle, int timeStyle, int type); [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); [EOL] public static DateTimeFormatter forPattern(String pattern); [EOL] public static DateTimeFormatter forStyle(String style); [EOL] public static String patternForStyle(String style, Locale locale); [EOL] public static DateTimeFormatter shortDate(); [EOL] public static DateTimeFormatter shortTime(); [EOL] public static DateTimeFormatter shortDateTime(); [EOL] public static DateTimeFormatter mediumDate(); [EOL] public static DateTimeFormatter mediumTime(); [EOL] public static DateTimeFormatter mediumDateTime(); [EOL] public static DateTimeFormatter longDate(); [EOL] public static DateTimeFormatter longTime(); [EOL] public static DateTimeFormatter longDateTime(); [EOL] public static DateTimeFormatter fullDate(); [EOL] public static DateTimeFormatter fullTime(); [EOL] public static DateTimeFormatter fullDateTime(); [EOL] static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static String parseToken(String pattern, int[] indexRef); [EOL] private static boolean isNumericToken(String token); [EOL] private static DateTimeFormatter createFormatterForPattern(String pattern); [EOL] private static DateTimeFormatter createFormatterForStyle(String style); [EOL] private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); [EOL] private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); [EOL] private static int selectStyle(char ch); [EOL] public int estimatePrintedLength(); [EOL] public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); [EOL] public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; [EOL] public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); [EOL] public void printTo(Writer out, Readable Partial partial, Locale locale) throws IOException; [EOL] public int estimateParsedLength(); [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position); [EOL] private DateTimeFormatter getFormatter(Locale locale); [EOL] String getPattern(Locale locale); [EOL] int FULL=Optional[0]; [EOL] int LONG=Optional[1]; [EOL] int MEDIUM=Optional[2]; [EOL] int SHORT=Optional[3]; [EOL] int NONE=Optional[4]; [EOL] int DATE=Optional[0]; [EOL] int TIME=Optional[1]; [EOL] int DATETIME=Optional[2]; [EOL] int PATTERN_CACHE_SIZE=Optional[500]; [EOL] Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }]
public static DateTimeFormatter forPattern(String pattern) { [EOL] return createFormatterForPattern(pattern); [EOL] }
public static DateTimeFormatter mediumDate() { [EOL] return createFormatterForStyleIndex(MEDIUM, NONE); [EOL] } [EOL] protected DateTimeFormat(); [EOL] StyleFormatter(int dateStyle, int timeStyle, int type); [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); [EOL] public static DateTimeFormatter forPattern(String pattern); [EOL] public static DateTimeFormatter forStyle(String style); [EOL] public static String patternForStyle(String style, Locale locale); [EOL] public static DateTimeFormatter shortDate(); [EOL] public static DateTimeFormatter shortTime(); [EOL] public static DateTimeFormatter shortDateTime(); [EOL] public static DateTimeFormatter mediumDate(); [EOL] public static DateTimeFormatter mediumTime(); [EOL] public static DateTimeFormatter mediumDateTime(); [EOL] public static DateTimeFormatter longDate(); [EOL] public static DateTimeFormatter longTime(); [EOL] public static DateTimeFormatter longDateTime(); [EOL] public static DateTimeFormatter fullDate(); [EOL] public static DateTimeFormatter fullTime(); [EOL] public static DateTimeFormatter fullDateTime(); [EOL] static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static String parseToken(String pattern, int[] indexRef); [EOL] private static boolean isNumericToken(String token); [EOL] private static DateTimeFormatter createFormatterForPattern(String pattern); [EOL] private static DateTimeFormatter createFormatterForStyle(String style); [EOL] private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); [EOL] private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); [EOL] private static int selectStyle(char ch); [EOL] public int estimatePrintedLength(); [EOL] public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); [EOL] public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; [EOL] public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); [EOL] public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; [EOL] public int estimateParsedLength(); [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position); [EOL] private DateTimeFormatter getFormatter(Locale locale); [EOL] String getPattern(Locale locale); [EOL] int FULL=Optional[0]; [EOL] int LONG=Optional[1]; [EOL] int MEDIUM=Optional[2]; [EOL] int SHORT=Optional[3]; [EOL] int NONE=Optional[4]; [EOL] int DATE=Optional[0]; [EOL] int TIME=Optional[1]; [EOL] int DATETIME=Optional[2]; [EOL] int PATTERN_CACHE_SIZE=Optional[500]; [EOL] Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) { [EOL] private static final long serialVersionUID = 23L; [EOL] @Override [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) { [EOL] return size() > PATTERN_CACHE_SIZE; [EOL] }; [EOL] }
public void testLongDate() { [EOL] DateTimeFormatter formatter = DateTimeFormatter.longDate(); [EOL] assertNotNull(formatter); [EOL] }
public void testShortDate() { [EOL] DateTimeFormatter formatter = DateTimeFormatter.shortDate(); [EOL] assertNotNull(formatter); [EOL] }
public void testShortTime() { [EOL] DateTimeFormatter formatter = DateTimeFormatter.shortTime(); [EOL] assertNotNull(formatter); [EOL] }
public void testShortDateTime() { [EOL] DateTimeFormatter formatter = DateTimeFormatter.shortDateTime(); [EOL] assertNotNull(formatter); [EOL] }
public void testMediumDate() { [EOL] DateTimeFormatter formatter = DateTimeFormatter.mediumDate(); [EOL] assertNotNull(formatter); [EOL] }
public void testMediumTime() { [EOL] DateTimeFormatter formatter = DateTimeFormatter.mediumTime(); [EOL] assertNotNull(formatter); [EOL] }
public void testMediumDateTime() { [EOL] DateTimeFormatter formatter = DateTimeFormatter.mediumDateTime(); [EOL] assertNotNull(formatter); [EOL] }
public void testLongTime() { [EOL] DateTimeFormatter formatter = DateTimeFormatter.longTime(); [EOL] assertNotNull(formatter); [EOL] }
public void testLongDateTime() { [EOL] DateTimeFormatter formatter = DateTimeFormatter.longDateTime(); [EOL] assertNotNull(formatter); [EOL] }
public void testFullDate() { [EOL] DateTimeFormatter formatter = DateTimeFormatter.fullDate(); [EOL] assertNotNull(formatter); [EOL] }
public void testFullTime() { [EOL] DateTimeFormatter formatter = DateTimeFormatter.fullTime(); [EOL] assertNotNull(formatter); [EOL] }
public void testFullDateTime() { [EOL] DateTimeFormatter formatter = DateTimeFormatter.fullDateTime(); [EOL] assertNotNull(formatter); [EOL] }
public void testForPattern() { [EOL] String pattern = "yyyy-MM-dd"; [EOL] DateTimeFormatter formatter = DateTimeFormatter.forPattern(pattern); [EOL] assertNotNull(formatter); [EOL] }
public void testForStyle() { [EOL] String style = "SS"; [EOL] DateTimeFormatter formatter = DateTimeFormatter.forStyle(style); [EOL] assertNotNull(formatter); [EOL] }
public void testPatternForStyle() { [EOL] String style = "SS"; [EOL] Locale locale = Locale.US; [EOL] String pattern = DateTimeFormatter.patternForStyle(style, locale); [EOL] assertNotNull(pattern); [EOL] }
private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) { [EOL] int length = pattern.length(); [EOL] int[] indexRef = new int[1]; [EOL] for (int i = 0; i < length; i++) { [EOL] indexRef[0] = i; [EOL] String token = parseToken(pattern, indexRef); [EOL] i = indexRef[0]; [EOL] int tokenLen = token.length(); [EOL] if (tokenLen == 0) { [EOL] break; [EOL] } [EOL] char c = token.charAt(0); [EOL] switch(c) { [EOL] case 'G': [EOL] builder.appendEraText(); [EOL] break; [EOL] case 'C': [EOL] builder.appendCenturyOfEra(tokenLen, tokenLen); [EOL] break; [EOL] case 'x': [EOL] case 'y': [EOL] case 'Y': [EOL] if (tokenLen == 2) { [EOL] boolean lenientParse = true; [EOL] if (i + 1 < length) { [EOL] indexRef[0]++; [EOL] if (isNumericToken(parseToken(pattern, indexRef))) { [EOL] lenientParse = false; [EOL] } [EOL] indexRef[0]--; [EOL] } [EOL] switch(c) { [EOL] case 'x': [EOL] builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30, lenientParse); [EOL] break; [EOL] case 'y': [EOL] case 'Y': [EOL] default: [EOL] builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse); [EOL] break; [EOL] } [EOL] } else { [EOL] int maxDigits = 9; [EOL] if (i + 1 < length) { [EOL] indexRef[0]++; [EOL] if (isNumericToken(parseToken(pattern, indexRef))) { [EOL] maxDigits = tokenLen; [EOL] } [EOL] indexRef[0]--; [EOL] } [EOL] switch(c) { [EOL] case 'x': [EOL] builder.appendWeekyear(tokenLen, maxDigits); [EOL] break; [EOL] case 'y': [EOL] builder.appendYear(tokenLen, maxDigits); [EOL] break; [EOL] case 'Y': [EOL] builder.appendYearOfEra(tokenLen, maxDigits); [EOL] break; [EOL] } [EOL] } [EOL] break; [EOL] case 'M': [EOL] if (tokenLen >= 3) { [EOL] if (tokenLen >= 4) { [EOL] builder.appendMonthOfYearText(); [EOL] } else { [EOL] builder.appendMonthOfYearShortText(); [EOL] } [EOL] } else { [EOL] builder.appendMonthOfYear(tokenLen); [EOL] } [EOL] break; [EOL] case 'd': [EOL] builder.appendDayOfMonth(tokenLen); [EOL] break; [EOL] case 'a': [EOL] builder.appendHalfdayOfDayText(); [EOL] break; [EOL] case 'h': [EOL] builder.appendClockhourOfHalfday(tokenLen); [EOL] break; [EOL] case 'H': [EOL] builder.appendHourOfDay(tokenLen); [EOL] break; [EOL] case 'k': [EOL] builder.appendClockhourOfDay(tokenLen); [EOL] break; [EOL] case 'K': [EOL] builder.appendHourOfHalfday(tokenLen); [EOL] break; [EOL] case 'm': [EOL] builder.appendMinuteOfHour(tokenLen); [EOL] break; [EOL] case 's': [EOL] builder.appendSecondOfMinute(tokenLen); [EOL] break; [EOL] case 'S': [EOL] builder.appendFractionOfSecond(tokenLen, tokenLen); [EOL] break; [EOL] case 'e': [EOL] builder.appendDayOfWeek(tokenLen); [EOL] break; [EOL] case 'E': [EOL] if (tokenLen >= 4) { [EOL] builder.appendDayOfWeekText(); [EOL] } else { [EOL] builder.appendDayOfWeekShortText(); [EOL] } [EOL] break; [EOL] case 'D': [EOL] builder.appendDayOfYear(tokenLen); [EOL] break; [EOL] case 'w': [EOL] builder.appendWeekOfWeekyear(tokenLen); [EOL] break; [EOL] case 'z': [EOL] if (tokenLen >= 4) { [EOL] builder.appendTimeZoneName(); [EOL] } else { [EOL] builder.appendTimeZoneShortName(null); [EOL] } [EOL] break; [EOL] case 'Z': [EOL] if (tokenLen == 1) { [EOL] builder.appendTimeZoneOffset(null, "Z", false, 2, 2); [EOL] } else if (tokenLen == 2) { [EOL] builder.appendTimeZoneOffset(null, "Z", true, 2, 2); [EOL] } else { [EOL] builder.appendTimeZoneId(); [EOL] } [EOL] break; [EOL] case '\'': [EOL] String sub = token.substring(1); [EOL] if (sub.length() == 1) { [EOL] builder.appendLiteral(sub.charAt(0)); [EOL] } else { [EOL] builder.appendLiteral(new String(sub)); [EOL] } [EOL] break; [EOL] default: [EOL] throw new IllegalArgumentException("Illegal pattern component: " + token); [EOL] } [EOL] } [EOL] }
private static String parseToken(String pattern, int[] indexRef) { [EOL] StringBuilder buf = new StringBuilder(); [EOL] int i = indexRef[0]; [EOL] int length = pattern.length(); [EOL] char c = pattern.charAt(i); [EOL] if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') { [EOL] buf.append(c); [EOL] while (i + 1 < length) { [EOL] char peek = pattern.charAt(i + 1); [EOL] if (peek == c) { [EOL] buf.append(c); [EOL] i++; [EOL] } else { [EOL] break; [EOL] } [EOL] } [EOL] } else { [EOL] buf.append('\''); [EOL] boolean inLiteral = false; [EOL] for (; i < length; i++) { [EOL] c = pattern.charAt(i); [EOL] if (c == '\'') { [EOL] if (i + 1 < length && pattern.charAt(i + 1) == '\'') { [EOL] i++; [EOL] buf.append(c); [EOL] } else { [EOL] inLiteral = !inLiteral; [EOL] } [EOL] } else if (!inLiteral && (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) { [EOL] i--; [EOL] break; [EOL] } else { [EOL] buf.append(c); [EOL] } [EOL] } [EOL] } [EOL] indexRef[0] = i; [EOL] return buf.toString(); [EOL] } [EOL] protected DateTimeFormat(); [EOL] StyleFormatter(int dateStyle, int timeStyle, int type); [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); [EOL] public static DateTimeFormatter forPattern(String pattern); [EOL] public static DateTimeFormatter forStyle(String style); [EOL] public static String patternForStyle(String style, Locale locale); [EOL] public static DateTimeFormatter shortDate(); [EOL] public static DateTimeFormatter shortTime(); [EOL] public static DateTimeFormatter shortDateTime(); [EOL] public static DateTimeFormatter mediumDate(); [EOL] public static DateTimeFormatter mediumTime(); [EOL] public static DateTimeFormatter mediumDateTime(); [EOL] public static DateTimeFormatter longDate(); [EOL] public static DateTimeFormatter longTime(); [EOL] public static DateTimeFormatter longDateTime(); [EOL] public static DateTimeFormatter fullDate(); [EOL] public static DateTimeFormatter fullTime(); [EOL] public static DateTimeFormatter fullDateTime(); [EOL] static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static String parseToken(String pattern, int[] indexRef); [EOL] private static boolean isNumericToken(String token); [EOL] private static DateTimeFormatter createFormatterForPattern(String pattern); [EOL] private static DateTimeFormatter createFormatterForStyle(String style); [EOL] private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); [EOL] private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); [EOL] private static int selectStyle(char ch); [EOL] public int estimatePrintedLength(); [EOL] public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); [EOL] public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; [EOL] public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); [EOL] public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; [EOL] public int estimateParsedLength(); [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position); [EOL] private DateTimeFormatter getFormatter(Locale locale); [EOL] String getPattern(Locale locale); [EOL] int FULL=Optional[0]; [EOL] int LONG=Optional[1]; [EOL] int MEDIUM=Optional[2]; [EOL] int SHORT=Optional[3]; [EOL] int NONE=Optional[4]; [EOL] int DATE=Optional[0]; [EOL] int TIME=Optional[1]; [EOL] int DATETIME=Optional[2]; [EOL] int PATTERN_CACHE_SIZE=Optional[500]; [EOL] Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ; [EOL] private static final long serialVersionUID = 23L;; ; [EOL] @Override; [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {; [EOL] return size() > PATTERN_CACHE_SIZE;; [EOL] }; [EOL] }]
private static DateTimeFormatter createFormatterForPattern(String pattern) { [EOL] if (pattern == null || pattern.length() == 0) { [EOL] throw new IllegalArgumentException("Invalid pattern specification"); [EOL] } [EOL] DateTimeFormatter formatter = null; [EOL] synchronized (PATTERN_CACHE) { [EOL] formatter = PATTERN_CACHE.get(pattern); [EOL] if (formatter == null) { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] parsePatternTo(builder, pattern); [EOL] formatter = builder.toFormatter(); [EOL] PATTERN_CACHE.put(pattern, formatter); [EOL] } [EOL] } [EOL] return formatter; [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
public void testCreateFormatterForStyleWithNullStyle() { [EOL] try { [EOL] DateTimeFormatter.createFormatterForStyle(null); [EOL] fail("Should have thrown IllegalArgumentException for null style"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCreateFormatterForStyleWithInvalidLengthStyle() { [EOL] try { [EOL] DateTimeFormatter.createFormatterForStyle("S"); // Invalid length [EOL] fail("Should have thrown IllegalArgumentException for style with invalid length"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCreateFormatterForStyleWithInvalidStyle() { [EOL] try { [EOL] DateTimeFormatter.createFormatterForStyle("--"); // Both date and time styles are NONE [EOL] fail("Should have thrown IllegalArgumentException for style '--'"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testCreateFormatterForStyleWithValidStyle() { [EOL] DateTimeFormatter formatter = DateTimeFormatter.createFormatterForStyle("SS"); [EOL] assertNotNull("Formatter should not be null for valid style", formatter); [EOL] }
private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle) { [EOL] int type = DATETIME; [EOL] if (dateStyle == NONE) { [EOL] type = TIME; [EOL] } else if (timeStyle == NONE) { [EOL] type = DATE; [EOL] } [EOL] StyleFormatter llf = new StyleFormatter(dateStyle, timeStyle, type); [EOL] return new DateTimeFormatter(llf, llf); [EOL] } [EOL] protected DateTimeFormat(); [EOL] StyleFormatter(int dateStyle, int timeStyle, int type); [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); [EOL] public static DateTimeFormatter forPattern(String pattern); [EOL] public static DateTimeFormatter forStyle(String style); [EOL] public static String patternForStyle(String style, Locale locale); [EOL] public static DateTimeFormatter shortDate(); [EOL] public static DateTimeFormatter shortTime(); [EOL] public static DateTimeFormatter shortDateTime(); [EOL] public static DateTimeFormatter mediumDate(); [EOL] public static DateTimeFormatter mediumTime(); [EOL] public static DateTimeFormatter mediumDateTime(); [EOL] public static DateTimeFormatter longDate(); [EOL] public static DateTimeFormatter longTime(); [EOL] public static DateTimeFormatter longDateTime(); [EOL] public static DateTimeFormatter fullDate(); [EOL] public static DateTimeFormatter fullTime(); [EOL] public static DateTimeFormatter fullDateTime(); [EOL] static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static String parseToken(String pattern, int[] indexRef); [EOL] private static boolean isNumericToken(String token); [EOL] private static DateTimeFormatter createFormatterForPattern(String pattern); [EOL] private static DateTimeFormatter createFormatterForStyle(String style); [EOL] private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); [EOL] private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); [EOL] private static int selectStyle(char ch); [EOL] public int estimatePrintedLength(); [EOL] public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); [EOL] public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; [EOL] public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); [EOL] public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; [EOL] public int estimateParsedLength(); [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position); [EOL] private DateTimeFormatter getFormatter(Locale locale); [EOL] String getPattern(Locale locale); [EOL] int FULL=Optional[0]; [EOL] int LONG=Optional[1]; [EOL] int MEDIUM=Optional[2]; [EOL] int SHORT=Optional[3]; [EOL] int NONE=Optional[4]; [EOL] int DATE=Optional[0]; [EOL] int TIME=Optional[1]; [EOL] int DATETIME=Optional[2]; [EOL] int PATTERN_CACHE_SIZE=Optional[500]; [EOL] Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; [EOL] private static final long serialVersionUID = 23L; [EOL] @Override [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) { [EOL] return size() > PATTERN_CACHE_SIZE; [EOL] }; [EOL] }]
public void testSelectStyleWithShort() { [EOL] int result = selectStyle('S'); [EOL] assertEquals(SHORT, result); [EOL] } [EOL] public void testSelectStyleWithMedium() { [EOL] int result = selectStyle('M'); [EOL] assertEquals(MEDIUM, result); [EOL] } [EOL] public void testSelectStyleWithLong() { [EOL] int result = selectStyle('L'); [EOL] assertEquals(LONG, result); [EOL] } [EOL] public void testSelectStyleWithFull() { [EOL] int result = selectStyle('F'); [EOL] assertEquals(FULL, result); [EOL] } [EOL] public void testSelectStyleWithNone() { [EOL] int result = selectStyle('-'); [EOL] assertEquals(NONE, result); [EOL] } [EOL] public void testSelectStyleWithInvalidCharacter() { [EOL] try { [EOL] selectStyle('X'); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Invalid style character: X", e.getMessage()); [EOL] } [EOL] }
String getPattern(Locale locale) { [EOL] DateFormat f = null; [EOL] switch(iType) { [EOL] case DATE: [EOL] f = DateFormat.getDateInstance(iDateStyle, locale); [EOL] break; [EOL] case TIME: [EOL] f = DateFormat.getTimeInstance(iTimeStyle, locale); [EOL] break; [EOL] case DATETIME: [EOL] f = DateFormat.getDateTimeInstance(iDateStyle, iTimeStyle, locale); [EOL] break; [EOL] } [EOL] if (f instanceof SimpleDateFormat == false) { [EOL] throw new IllegalArgumentException("No datetime pattern for locale: " + locale); [EOL] } [EOL] return ((SimpleDateFormat) f).toPattern(); [EOL] } [EOL] protected DateTimeFormat(); [EOL] StyleFormatter(int dateStyle, int timeStyle, int type); [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); [EOL] public static DateTimeFormatter forPattern(String pattern); [EOL] public static DateTimeFormatter forStyle(String style); [EOL] public static String patternForStyle(String style, Locale locale); [EOL] public static DateTimeFormatter shortDate(); [EOL] public static DateTimeFormatter shortTime(); [EOL] public static DateTimeFormatter shortDateTime(); [EOL] public static DateTimeFormatter mediumDate(); [EOL] public static DateTimeFormatter mediumTime(); [EOL] public static DateTimeFormatter mediumDateTime(); [EOL] public static DateTimeFormatter longDate(); [EOL] public static DateTimeFormatter longTime(); [EOL] public static DateTimeFormatter longDateTime(); [EOL] public static DateTimeFormatter fullDate(); [EOL] public static DateTimeFormatter fullTime(); [EOL] public static DateTimeFormatter fullDateTime(); [EOL] static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); [EOL] private static String parseToken(String pattern, int[] indexRef); [EOL] private static boolean isNumericToken(String token); [EOL] private static DateTimeFormatter createFormatterForPattern(String pattern); [EOL] private static DateTimeFormatter createFormatterForStyle(String style); [EOL] private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); [EOL] private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); [EOL] private static int selectStyle(char ch); [EOL] public int estimatePrintedLength(); [EOL] public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); [EOL] public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; [EOL] public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); [EOL] public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; [EOL] public int estimateParsedLength(); [EOL] public int parseInto(DateTimeParserBucket bucket, String text, int position); [EOL] private DateTimeFormatter getFormatter(Locale locale); [EOL] String getPattern(Locale locale); [EOL] int FULL=Optional[0]; [EOL] int LONG=Optional[1]; [EOL] int MEDIUM=Optional[2]; [EOL] int SHORT=Optional[3]; [EOL] int NONE=Optional[4]; [EOL] int DATE=Optional[0]; [EOL] int TIME=Optional[1]; [EOL] int DATETIME=Optional[2]; [EOL] int PATTERN_CACHE_SIZE=Optional[500]; [EOL] Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; [EOL] private static final long serialVersionUID = 23L; [EOL] @Override [EOL] protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) { [EOL] return size() > PATTERN_CACHE_SIZE; [EOL] }; [EOL] }
public long getStandardSeconds() { [EOL] return getMillis() / DateTimeConstants.MILLIS_PER_SECOND; [EOL] }
public void testToStandardSeconds_Positive() { [EOL] long expectedSeconds = 1234L; [EOL] TimePeriodStub timePeriod = new TimePeriodStub(expectedSeconds); [EOL] Seconds result = timePeriod.toStandardSeconds(); [EOL] assertEquals(expectedSeconds, result.getSeconds()); [EOL] } [EOL] public void testToStandardSeconds_Negative() { [EOL] long expectedSeconds = -1234L; [EOL] TimePeriodStub timePeriod = new TimePeriodStub(expectedSeconds); [EOL] Seconds result = timePeriod.toStandardSeconds(); [EOL] assertEquals(expectedSeconds, result.getSeconds()); [EOL] } [EOL] public void testToStandardSeconds_Zero() { [EOL] long expectedSeconds = 0L; [EOL] TimePeriodStub timePeriod = new TimePeriodStub(expectedSeconds); [EOL] Seconds result = timePeriod.toStandardSeconds(); [EOL] assertEquals(expectedSeconds, result.getSeconds()); [EOL] } [EOL] public void testToStandardSeconds_MaxInt() { [EOL] long expectedSeconds = Integer.MAX_VALUE; [EOL] TimePeriodStub timePeriod = new TimePeriodStub(expectedSeconds); [EOL] Seconds result = timePeriod.toStandardSeconds(); [EOL] assertEquals(expectedSeconds, result.getSeconds()); [EOL] } [EOL] public void testToStandardSeconds_MinInt() { [EOL] long expectedSeconds = Integer.MIN_VALUE; [EOL] TimePeriodStub timePeriod = new TimePeriodStub(expectedSeconds); [EOL] Seconds result = timePeriod.toStandardSeconds(); [EOL] assertEquals(expectedSeconds, result.getSeconds()); [EOL] } [EOL] public void testToStandardSeconds_Overflow() { [EOL] long expectedSeconds = (long) Integer.MAX_VALUE + 1; [EOL] TimePeriodStub timePeriod = new TimePeriodStub(expectedSeconds); [EOL] Seconds result = timePeriod.toStandardSeconds(); [EOL] assertEquals(Integer.MAX_VALUE, result.getSeconds()); [EOL] } [EOL] public void testToStandardSeconds_Underflow() { [EOL] long expectedSeconds = (long) Integer.MIN_VALUE - 1; [EOL] TimePeriodStub timePeriod = new TimePeriodStub(expectedSeconds); [EOL] Seconds result = timePeriod.toStandardSeconds(); [EOL] assertEquals(Integer.MIN_VALUE, result.getSeconds()); [EOL] }
public Duration plus(long amount) { [EOL] return withDurationAdded(amount, 1); [EOL] }
public void testPlus_withNullAmount() { [EOL] Duration duration = new Duration(1000); [EOL] Duration result = duration.plus(null); [EOL] assertEquals("Duration should not change when adding null", 1000, result.getMillis()); [EOL] }
public void testPlus_withValidAmount() { [EOL] Duration duration = new Duration(1000); [EOL] ReadableDuration amountToAdd = new Duration(500); [EOL] Duration result = duration.plus(amountToAdd); [EOL] assertEquals("Duration should increase by 500 millis", 1500, result.getMillis()); [EOL] }
public void testMultipliedBy_One() { [EOL] Duration duration = new Duration(1000); [EOL] Duration result = duration.multipliedBy(1); [EOL] assertSame("Duration should be the same when multiplied by 1", duration, result); [EOL] } [EOL] public void testMultipliedBy_Positive() { [EOL] Duration duration = new Duration(1000); [EOL] Duration result = duration.multipliedBy(2); [EOL] assertEquals("Duration should be doubled when multiplied by 2", 2000, result.getMillis()); [EOL] } [EOL] public void testMultipliedBy_Negative() { [EOL] Duration duration = new Duration(1000); [EOL] Duration result = duration.multipliedBy(-1); [EOL] assertEquals("Duration should be negative when multiplied by -1", -1000, result.getMillis()); [EOL] } [EOL] public void testMultipliedBy_Zero() { [EOL] Duration duration = new Duration(1000); [EOL] Duration result = duration.multipliedBy(0); [EOL] assertEquals("Duration should be zero when multiplied by 0", 0, result.getMillis()); [EOL] }

public void testDividedBy_DivisorIsOne() { [EOL] Duration duration = new Duration(1000); [EOL] Duration result = duration.dividedBy(1); [EOL] assertSame("Duration should be the same when divided by 1", duration, result); [EOL] }
public void testDividedBy_DivisorIsNotOne() { [EOL] Duration duration = new Duration(1000); [EOL] Duration result = duration.dividedBy(2); [EOL] assertNotNull("Result should not be null", result); [EOL] assertEquals("Duration should be half when divided by 2", 500, result.getMillis()); [EOL] }
public void testDividedBy_DivisorIsZero() { [EOL] Duration duration = new Duration(1000); [EOL] try { [EOL] duration.dividedBy(0); [EOL] fail("Should throw ArithmeticException when divided by 0"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testNegated_Normal() { [EOL] Duration duration = new Duration(10); [EOL] Duration result = duration.negated(); [EOL] assertEquals(-10, result.getMillis()); [EOL] } [EOL] public void testNegated_MaxValue() { [EOL] Duration duration = new Duration(Long.MAX_VALUE); [EOL] Duration result = duration.negated(); [EOL] assertEquals(-Long.MAX_VALUE, result.getMillis()); [EOL] } [EOL] public void testNegated_MinValue() { [EOL] try { [EOL] Duration duration = new Duration(Long.MIN_VALUE); [EOL] duration.negated(); [EOL] fail("Should have thrown ArithmeticException"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("Negation of this duration would overflow", e.getMessage()); [EOL] } [EOL] }
public void testStandardFormatterInitialization() { [EOL] PeriodFormatter formatter = Time.standard(); [EOL] assertNotNull(formatter); [EOL] }
public void testStandardFormatterSingletonProperty() { [EOL] PeriodFormatter firstCall = Time.standard(); [EOL] PeriodFormatter secondCall = Time.standard(); [EOL] assertSame(firstCall, secondCall); [EOL] }
public void testGetLeapDurationField() { [EOL] DurationField mockField = mock(DurationField.class); [EOL] DateTimeField dateTimeField = new DelegatingDateTimeField(mockField) { [EOL] public DurationField getLeapDurationField() { [EOL] return getWrappedField().getLeapDurationField(); [EOL] } [EOL] }; [EOL] when(mockField.getLeapDurationField()).thenReturn(mockField); [EOL] DurationField result = dateTimeField.getLeapDurationField(); [EOL] assertNotNull(result); [EOL] assertSame(mockField, result); [EOL] }
public void testToDateTimeZoneWithNullId() { [EOL] try { [EOL] toDateTimeZone(null, true); [EOL] fail("Should have thrown IllegalArgumentException for null id"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testToDateTimeZoneWithEmptyTransitionsAndNonNullTailZone() { [EOL] DSTZone mockTailZone = createMockTailZone(); [EOL] setRuleSetsForEmptyTransitions(); [EOL] DateTimeZone result = toDateTimeZone("TestZone", true); [EOL] assertSame("Expected tailZone when transitions are empty", mockTailZone, result); [EOL] }
public void testToDateTimeZoneWithOneTransitionAndNoTailZone() { [EOL] Transition singleTransition = createSingleTransition(); [EOL] setRuleSetsForSingleTransition(singleTransition); [EOL] DateTimeZone result = toDateTimeZone("TestZone", true); [EOL] assertEquals("Expected fixed zone built from single transition", buildFixedZone("TestZone", singleTransition.getNameKey(), singleTransition.getWallOffset(), singleTransition.getStandardOffset()), result); [EOL] }
public void testToDateTimeZoneWithMultipleTransitions() { [EOL] ArrayList<Transition> multipleTransitions = createMultipleTransitions(); [EOL] setRuleSetsForMultipleTransitions(multipleTransitions); [EOL] DateTimeZone result = toDateTimeZone("TestZone", true); [EOL] assertTrue("Expected PrecalculatedZone", result instanceof PrecalculatedZone); [EOL] }
public void testToDateTimeZoneWithCachableZone() { [EOL] ArrayList<Transition> multipleTransitions = createMultipleTransitions(); [EOL] setRuleSetsForCachableZone(multipleTransitions); [EOL] DateTimeZone result = toDateTimeZone("TestZone", true); [EOL] assertTrue("Expected CachedDateTimeZone", result instanceof CachedDateTimeZone); [EOL] }
public long previous(long instant, int standardOffset, int saveMillis) { [EOL] int offset; [EOL] if (iMode == 'w') { [EOL] offset = standardOffset + saveMillis; [EOL] } else if (iMode == 's') { [EOL] offset = standardOffset; [EOL] } else { [EOL] offset = 0; [EOL] } [EOL] instant += offset; [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] long prev = chrono.monthOfYear().set(instant, iMonthOfYear); [EOL] prev = chrono.millisOfDay().set(prev, 0); [EOL] prev = chrono.millisOfDay().add(prev, iMillisOfDay); [EOL] prev = setDayOfMonthPrevious(chrono, prev); [EOL] if (iDayOfWeek == 0) { [EOL] if (prev >= instant) { [EOL] prev = chrono.year().add(prev, -1); [EOL] prev = setDayOfMonthPrevious(chrono, prev); [EOL] } [EOL] } else { [EOL] prev = setDayOfWeek(chrono, prev); [EOL] if (prev >= instant) { [EOL] prev = chrono.year().add(prev, -1); [EOL] prev = chrono.monthOfYear().set(prev, iMonthOfYear); [EOL] prev = setDayOfMonthPrevious(chrono, prev); [EOL] prev = setDayOfWeek(chrono, prev); [EOL] } [EOL] } [EOL] return prev - offset; [EOL] }
public void testSetDayOfMonthPrevious_ValidDate() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] long prev = chrono.dayOfMonth().set(chrono.monthOfYear().set(chrono.year().set(0, 2020), 3), 1); [EOL] long result = setDayOfMonthPrevious(chrono, prev); [EOL] assertEquals("Should return the same valid date", prev, result); [EOL] }
public void testSetDayOfMonthPrevious_LeapYearAdjustment() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] long prev = chrono.dayOfMonth().set(chrono.monthOfYear().set(chrono.year().set(0, 2021), 2), 29); [EOL] long result = setDayOfMonthPrevious(chrono, prev); [EOL] assertTrue("Should adjust to previous leap year", chrono.year().isLeap(result)); [EOL] assertEquals("Should set to February 29 of the leap year", 29, chrono.dayOfMonth().get(result)); [EOL] }
public void testSetDayOfMonthPrevious_IllegalArgument() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] long prev = chrono.dayOfMonth().set(chrono.monthOfYear().set(chrono.year().set(0, 2021), 4), 31); [EOL] try { [EOL] setDayOfMonthPrevious(chrono, prev); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetDayOfWeek_SameDay() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] long instant = DateTimeUtils.currentTimeMillis(); [EOL] int dayOfWeek = chrono.dayOfWeek().get(instant); [EOL] long updatedInstant = setDayOfWeek(chrono, instant, dayOfWeek, true); [EOL] assertEquals(instant, updatedInstant); [EOL] } [EOL] public void testSetDayOfWeek_NextWeek() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] long instant = DateTimeUtils.currentTimeMillis(); [EOL] int dayOfWeek = chrono.dayOfWeek().get(instant); [EOL] long updatedInstant = setDayOfWeek(chrono, instant, (dayOfWeek % 7) + 1, true); [EOL] long expectedInstant = chrono.dayOfWeek().add(instant, 7); [EOL] assertEquals(expectedInstant, updatedInstant); [EOL] } [EOL] public void testSetDayOfWeek_PreviousWeek() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] long instant = DateTimeUtils.currentTimeMillis(); [EOL] int dayOfWeek = chrono.dayOfWeek().get(instant); [EOL] long updatedInstant = setDayOfWeek(chrono, instant, (dayOfWeek + 6) % 7 + 1, false); [EOL] long expectedInstant = chrono.dayOfWeek().add(instant, -7); [EOL] assertEquals(expectedInstant, updatedInstant); [EOL] } [EOL] public void testSetDayOfWeek_AdvanceToNextWeek() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] long instant = DateTimeUtils.currentTimeMillis(); [EOL] int dayOfWeek = chrono.dayOfWeek().get(instant); [EOL] long updatedInstant = setDayOfWeek(chrono, instant, (dayOfWeek % 7) + 1, true); [EOL] assertTrue(updatedInstant > instant); [EOL] } [EOL] public void testSetDayOfWeek_RetreatToPreviousWeek() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] long instant = DateTimeUtils.currentTimeMillis(); [EOL] int dayOfWeek = chrono.dayOfWeek().get(instant); [EOL] long updatedInstant = setDayOfWeek(chrono, instant, (dayOfWeek + 6) % 7 + 1, false); [EOL] assertTrue(updatedInstant < instant); [EOL] }
public long previous(long instant, int standardOffset, int saveMillis) { [EOL] return iOfYear.previous(instant, standardOffset, saveMillis); [EOL] }
public void testPreviousTransitionWithPositiveInstant() { [EOL] long instant = 1; // Any positive value to avoid instant < 0 condition [EOL] long expected = instant; // Assuming the method calls return the incremented instant [EOL] long actual = previousTransition(instant); [EOL] assertEquals(expected - 1, actual); // Check if the result is instant - 1 [EOL] } [EOL] public void testPreviousTransitionWithNegativeInstantAndStartBeforeEpoch() { [EOL] long instant = -1; // Any negative value to trigger instant < 0 condition [EOL] long expected = instant; // Assuming startRecurrence.previous returns a value > 0 [EOL] long actual = previousTransition(instant); [EOL] assertEquals(expected - 1, actual); // Check if the result is instant - 1 [EOL] } [EOL] public void testPreviousTransitionWithNegativeInstantAndEndBeforeEpoch() { [EOL] long instant = -1; // Any negative value to trigger instant < 0 condition [EOL] long expected = instant; // Assuming endRecurrence.previous returns a value > 0 [EOL] long actual = previousTransition(instant); [EOL] assertEquals(expected - 1, actual); // Check if the result is instant - 1 [EOL] } [EOL] public void testPreviousTransitionWithStartRecurrenceThrowingIllegalArgumentException() { [EOL] long instant = 1; // Any value that could cause an IllegalArgumentException [EOL] long expected = instant; // Assuming the exception is caught and instant is returned [EOL] long actual = previousTransition(instant); [EOL] assertEquals(expected - 1, actual); // Check if the result is instant - 1 [EOL] } [EOL] public void testPreviousTransitionWithStartRecurrenceThrowingArithmeticException() { [EOL] long instant = 1; // Any value that could cause an ArithmeticException [EOL] long expected = instant; // Assuming the exception is caught and instant is returned [EOL] long actual = previousTransition(instant); [EOL] assertEquals(expected - 1, actual); // Check if the result is instant - 1 [EOL] } [EOL] public void testPreviousTransitionWithEndRecurrenceThrowingIllegalArgumentException() { [EOL] long instant = 1; // Any value that could cause an IllegalArgumentException [EOL] long expected = instant; // Assuming the exception is caught and instant is returned [EOL] long actual = previousTransition(instant); [EOL] assertEquals(expected - 1, actual); // Check if the result is instant - 1 [EOL] } [EOL] public void testPreviousTransitionWithEndRecurrenceThrowingArithmeticException() { [EOL] long instant = 1; // Any value that could cause an ArithmeticException [EOL] long expected = instant; // Assuming the exception is caught and instant is returned [EOL] long actual = previousTransition(instant); [EOL] assertEquals(expected - 1, actual); // Check if the result is instant - 1 [EOL] } [EOL] public void testPreviousTransitionWithStartGreaterThanEnd() { [EOL] long instant = 1; // Any value where start > end [EOL] long expected = instant; // Assuming startRecurrence.previous returns a value greater than endRecurrence.previous [EOL] long actual = previousTransition(instant); [EOL] assertEquals(expected - 1, actual); // Check if the result is start - 1 [EOL] } [EOL] public void testPreviousTransitionWithEndGreaterThanStart() { [EOL] long instant = 1; // Any value where end > start [EOL] long expected = instant; // Assuming endRecurrence.previous returns a value greater than startRecurrence.previous [EOL] long actual = previousTransition(instant); [EOL] assertEquals(expected - 1, actual); // Check if the result is end - 1 [EOL] }
public long nextTransition(long instant) { [EOL] long[] transitions = iTransitions; [EOL] int i = Arrays.binarySearch(transitions, instant); [EOL] i = (i >= 0) ? (i + 1) : ~i; [EOL] if (i < transitions.length) { [EOL] return transitions[i]; [EOL] } [EOL] if (iTailZone == null) { [EOL] return instant; [EOL] } [EOL] long end = transitions[transitions.length - 1]; [EOL] if (instant < end) { [EOL] instant = end; [EOL] } [EOL] return iTailZone.nextTransition(instant); [EOL] }
public void testPreviousTransition_ExactMatchNotMinValue() { [EOL] long instant = 10L; // Exact match and not Long.MIN_VALUE [EOL] long expected = instant - 1; [EOL] long actual = previousTransition(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testPreviousTransition_ExactMatchMinValue() { [EOL] long instant = Long.MIN_VALUE; // Exact match but is Long.MIN_VALUE [EOL] long expected = instant; [EOL] long actual = previousTransition(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testPreviousTransition_NotFoundInTransitionsAndNotLast() { [EOL] long instant = 5L; // Not found, not last, and previous is not Long.MIN_VALUE [EOL] long[] transitions = new long[] {1L, 10L, 20L}; [EOL] long expected = transitions[0] - 1; [EOL] long actual = previousTransition(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testPreviousTransition_NotFoundInTransitionsAndLast() { [EOL] long instant = 25L; // Not found and is last in transitions [EOL] long[] transitions = new long[] {1L, 10L, 20L}; [EOL] long expected = transitions[transitions.length - 1] - 1; [EOL] long actual = previousTransition(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testPreviousTransition_NotFoundInTransitionsAndPreviousIsMinValue() { [EOL] long instant = 0L; // Not found, previous is Long.MIN_VALUE [EOL] long[] transitions = new long[] {Long.MIN_VALUE, 10L, 20L}; [EOL] long expected = instant; [EOL] long actual = previousTransition(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testPreviousTransition_WithTailZoneAndPreviousBeforeInstant() { [EOL] long instant = 30L; // TailZone is not null and previous is before instant [EOL] long expected = 29L; // Assuming iTailZone.previousTransition(instant) returns 29L [EOL] long actual = previousTransition(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testPreviousTransition_WithTailZoneAndPreviousAfterInstant() { [EOL] long instant = 30L; // TailZone is not null but previous is after instant [EOL] long expected = instant; // Assuming iTailZone.previousTransition(instant) returns 35L [EOL] long actual = previousTransition(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testIsCachableWithTailZoneNotNull() { [EOL] setTailZone(new Object()); // Replace Object with the actual type of iTailZone [EOL] boolean result = isCachable(); [EOL] assertTrue(result); [EOL] }
public void testIsCachableWithEmptyTransitions() { [EOL] iTransitions = new long[0]; [EOL] boolean result = isCachable(); [EOL] assertFalse(result); [EOL] }
public void testIsCachableWithOneTransition() { [EOL] iTransitions = new long[1]; [EOL] boolean result = isCachable(); [EOL] assertFalse(result); [EOL] }
public void testIsCachableWithTransitionsLessThanYearApart() { [EOL] iTransitions = new long[]{0L, (365L * 24 * 60 * 60 * 1000) - 1}; [EOL] boolean result = isCachable(); [EOL] assertFalse(result); [EOL] }
public void testIsCachableWithTransitionsMoreThanYearApart() { [EOL] iTransitions = new long[]{0L, (366L * 24 * 60 * 60 * 1000) + 1}; [EOL] boolean result = isCachable(); [EOL] assertTrue(result); [EOL] }
public void testIsCachableWithAverageDistanceLessThan25() { [EOL] iTransitions = new long[]{ [EOL] 0L, [EOL] (365L * 24 * 60 * 60 * 1000), [EOL] (365L * 24 * 60 * 60 * 1000) * 2, [EOL] ((365L * 24 * 60 * 60 * 1000) * 3) - 1 [EOL] }; [EOL] boolean result = isCachable(); [EOL] assertFalse(result); [EOL] }
public void testIsCachableWithAverageDistanceEqualTo25() { [EOL] iTransitions = new long[]{ [EOL] 0L, [EOL] (365L * 24 * 60 * 60 * 1000), [EOL] (365L * 24 * 60 * 60 * 1000) * 2, [EOL] ((365L * 24 * 60 * 60 * 1000) * 3) + (25L * 24 * 60 * 60 * 1000) [EOL] }; [EOL] boolean result = isCachable(); [EOL] assertTrue(result); [EOL] }
public long nextTransition(long instant) { [EOL] return iZone.nextTransition(instant); [EOL] }
public long previousTransition(long instant) { [EOL] return iZone.previousTransition(instant); [EOL] }
public int testGetValue_ZeroDuration() { [EOL] int iScalar = 10; // Assume iScalar is a field in the class and initialized somewhere [EOL] long duration = 0L; [EOL] int expectedValue = 0; [EOL] int actualValue = getValue(duration); [EOL] assert actualValue == expectedValue : "Expected value for zero duration should be zero"; [EOL] } [EOL] public int testGetValue_PositiveDuration() { [EOL] int iScalar = 10; // Assume iScalar is a field in the class and initialized somewhere [EOL] long duration = 100L; [EOL] int expectedValue = getWrappedField().getValue(duration) / iScalar; // Assume getWrappedField().getValue() is a valid call [EOL] int actualValue = getValue(duration); [EOL] assert actualValue == expectedValue : "Expected value did not match actual value for positive duration"; [EOL] } [EOL] public int testGetValue_NegativeDuration() { [EOL] int iScalar = 10; // Assume iScalar is a field in the class and initialized somewhere [EOL] long duration = -100L; [EOL] int expectedValue = getWrappedField().getValue(duration) / iScalar; // Assume getWrappedField().getValue() is a valid call [EOL] int actualValue = getValue(duration); [EOL] assert actualValue == expectedValue : "Expected value did not match actual value for negative duration"; [EOL] }
public void testGetValueAsLong_ZeroDuration() { [EOL] long duration = 0L; [EOL] long instant = System.currentTimeMillis(); [EOL] long expectedValue = 0L / iScalar; // Assuming iScalar is a known field in the test class [EOL] long actualValue = getValueAsLong(duration, instant); [EOL] assertEquals(expectedValue, actualValue); [EOL] } [EOL] public void testGetValueAsLong_PositiveDuration() { [EOL] long duration = 1000L; [EOL] long instant = System.currentTimeMillis(); [EOL] long expectedValue = getWrappedField().getValueAsLong(duration, instant) / iScalar; // Assuming getWrappedField() can be mocked or controlled [EOL] long actualValue = getValueAsLong(duration, instant); [EOL] assertEquals(expectedValue, actualValue); [EOL] } [EOL] public void testGetValueAsLong_NegativeDuration() { [EOL] long duration = -1000L; [EOL] long instant = System.currentTimeMillis(); [EOL] long expectedValue = getWrappedField().getValueAsLong(duration, instant) / iScalar; // Assuming getWrappedField() can be mocked or controlled [EOL] long actualValue = getValueAsLong(duration, instant); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetMillis_withPositiveValue() { [EOL] long value = 10L; [EOL] long expected = FieldUtils.safeMultiply(value, iScalar); [EOL] expected = getWrappedField().getMillis(expected); [EOL] long result = getMillis(value); [EOL] assertEquals(expected, result); [EOL] }
public void testGetMillis_withNegativeValue() { [EOL] long value = -10L; [EOL] long expected = FieldUtils.safeMultiply(value, iScalar); [EOL] expected = getWrappedField().getMillis(expected); [EOL] long result = getMillis(value); [EOL] assertEquals(expected, result); [EOL] }
public void testGetMillis_withZeroValue() { [EOL] long value = 0L; [EOL] long expected = FieldUtils.safeMultiply(value, iScalar); [EOL] expected = getWrappedField().getMillis(expected); [EOL] long result = getMillis(value); [EOL] assertEquals(expected, result); [EOL] }
public void testGetMillis_withMaxValue() { [EOL] long value = Long.MAX_VALUE; [EOL] long expected = FieldUtils.safeMultiply(value, iScalar); [EOL] expected = getWrappedField().getMillis(expected); [EOL] long result = getMillis(value); [EOL] assertEquals(expected, result); [EOL] }
public void testGetMillis_withMinValue() { [EOL] long value = Long.MIN_VALUE; [EOL] long expected = FieldUtils.safeMultiply(value, iScalar); [EOL] expected = getWrappedField().getMillis(expected); [EOL] long result = getMillis(value); [EOL] assertEquals(expected, result); [EOL] }
public void testGetDifferenceAsLongWithPositiveScalar() { [EOL] long minuendInstant = 10000L; [EOL] long subtrahendInstant = 5000L; [EOL] int scalar = 2; [EOL] TimeField field = new TimeField(scalar); [EOL] long expected = (minuendInstant - subtrahendInstant) / scalar; [EOL] long actual = field.getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetDifferenceAsLongWithNegativeScalar() { [EOL] long minuendInstant = 5000L; [EOL] long subtrahendInstant = 10000L; [EOL] int scalar = -2; [EOL] TimeField field = new TimeField(scalar); [EOL] long expected = (minuendInstant - subtrahendInstant) / scalar; [EOL] long actual = field.getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetDifferenceAsLongWithZeroScalar() { [EOL] long minuendInstant = 5000L; [EOL] long subtrahendInstant = 10000L; [EOL] int scalar = 0; [EOL] TimeField field = new TimeField(scalar); [EOL] try { [EOL] field.getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] fail("Should have thrown ArithmeticException due to division by zero"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testGetUnitMillis_PositiveScalar() { [EOL] int positiveScalar = 5; [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] when(mockField.getUnitMillis()).thenReturn(10L); [EOL] TimeTestClass testClass = new TimeTestClass(mockField, positiveScalar); [EOL] long result = testClass.getUnitMillis(); [EOL] assertEquals(50L, result); [EOL] }
public void testGetUnitMillis_NegativeScalar() { [EOL] int negativeScalar = -5; [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] when(mockField.getUnitMillis()).thenReturn(10L); [EOL] TimeTestClass testClass = new TimeTestClass(mockField, negativeScalar); [EOL] long result = testClass.getUnitMillis(); [EOL] assertEquals(-50L, result); [EOL] }
public void testGetUnitMillis_ZeroScalar() { [EOL] int zeroScalar = 0; [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] when(mockField.getUnitMillis()).thenReturn(10L); [EOL] TimeTestClass testClass = new TimeTestClass(mockField, zeroScalar); [EOL] long result = testClass.getUnitMillis(); [EOL] assertEquals(0L, result); [EOL] }
public void testGetScalar() { [EOL] Time time = new Time(); [EOL] int expected = 0; // Assuming default value of iScalar is 0 [EOL] int actual = time.getScalar(); [EOL] assertEquals(expected, actual); [EOL] }
public void testEquals_Reflexive() { [EOL] ScaledDurationField field = new ScaledDurationField(null, null, 1); [EOL] assertTrue(field.equals(field)); [EOL] }
public void testEquals_SameContent() { [EOL] ScaledDurationField field1 = new ScaledDurationField(mock(DurationFieldType.class), mock(DurationField.class), 10); [EOL] ScaledDurationField field2 = new ScaledDurationField(field1.getType(), field1.getWrappedField(), field1.getScalar()); [EOL] assertTrue(field1.equals(field2)); [EOL] }
public void testEquals_DifferentType() { [EOL] ScaledDurationField field1 = new ScaledDurationField(mock(DurationFieldType.class), mock(DurationField.class), 10); [EOL] Object differentType = new Object(); [EOL] assertFalse(field1.equals(differentType)); [EOL] }
public void testEquals_DifferentContent() { [EOL] ScaledDurationField field1 = new ScaledDurationField(mock(DurationFieldType.class), mock(DurationField.class), 10); [EOL] ScaledDurationField field2 = new ScaledDurationField(mock(DurationFieldType.class), mock(DurationField.class), 20); [EOL] assertFalse(field1.equals(field2)); [EOL] }
public void testEquals_Null() { [EOL] ScaledDurationField field = new ScaledDurationField(null, null, 1); [EOL] assertFalse(field.equals(null)); [EOL] }
public void testEquals_SameObject() { [EOL] ISOChronology chrono = ISOChronology.getInstance(); [EOL] boolean result = chrono.equals(chrono); [EOL] assertTrue(result); [EOL] }
public void testEquals_DifferentObjectSameZone() { [EOL] ISOChronology chrono1 = ISOChronology.getInstance(); [EOL] ISOChronology chrono2 = ISOChronology.getInstance(); [EOL] boolean result = chrono1.equals(chrono2); [EOL] assertTrue(result); [EOL] }
public void testEquals_DifferentObjectDifferentZone() { [EOL] ISOChronology chrono1 = ISOChronology.getInstance(); [EOL] ISOChronology chrono2 = ISOChronology.getInstance(ZoneId.of("Europe/Paris")); [EOL] boolean result = chrono1.equals(chrono2); [EOL] assertFalse(result); [EOL] }
public void testEquals_Null() { [EOL] ISOChronology chrono = ISOChronology.getInstance(); [EOL] boolean result = chrono.equals(null); [EOL] assertFalse(result); [EOL] }
public void testEquals_NonChronologyObject() { [EOL] ISOChronology chrono = ISOChronology.getInstance(); [EOL] Object obj = new Object(); [EOL] boolean result = chrono.equals(obj); [EOL] assertFalse(result); [EOL] }
public long getValueAsLong(long duration) { [EOL] return duration / getUnitMillis(); [EOL] }
public int getValue(long duration, long instant) { [EOL] return FieldUtils.safeToInt(getValueAsLong(duration, instant)); [EOL] }
public long getMillis(int value) { [EOL] return value * getUnitMillis(); [EOL] }
public long getMillis(long value) { [EOL] return FieldUtils.safeMultiply(value, getUnitMillis()); [EOL] }
public void testReadResolve_BaseIsNull() { [EOL] setBase(null); [EOL] setMinimumDaysInFirstWeek(0); [EOL] Object result = readResolve(); [EOL] assertTrue(result instanceof YourExpectedType); [EOL] assertEquals(DateTimeZone.UTC, ((YourExpectedType) result).getZone()); [EOL] assertEquals(4, ((YourExpectedType) result).getMinimumDaysInFirstWeek()); [EOL] } [EOL] public void testReadResolve_BaseIsNotNull() { [EOL] Chronology mockChronology = createMockChronology(); [EOL] setBase(mockChronology); [EOL] setMinimumDaysInFirstWeek(1); [EOL] Object result = readResolve(); [EOL] assertTrue(result instanceof YourExpectedType); [EOL] assertEquals(mockChronology.getZone(), ((YourExpectedType) result).getZone()); [EOL] assertEquals(1, ((YourExpectedType) result).getMinimumDaysInFirstWeek()); [EOL] } [EOL] public void testReadResolve_MinimumDaysIsZero() { [EOL] setBase(null); [EOL] setMinimumDaysInFirstWeek(0); [EOL] Object result = readResolve(); [EOL] assertTrue(result instanceof YourExpectedType); [EOL] assertEquals(4, ((YourExpectedType) result).getMinimumDaysInFirstWeek()); [EOL] }
public void testReadResolve_MinimumDaysIsNotZero() { [EOL] setBase(null); [EOL] setMinimumDaysInFirstWeek(3); [EOL] Object result = readResolve(); [EOL] assertTrue(result instanceof YourExpectedType); [EOL] assertEquals(3, ((YourExpectedType) result).getMinimumDaysInFirstWeek()); [EOL] }
protected void assemble(Fields fields) { [EOL] if (getBase() == null) { [EOL] super.assemble(fields); [EOL] fields.year = new SkipDateTimeField(this, fields.year); [EOL] fields.weekyear = new SkipDateTimeField(this, fields.weekyear); [EOL] fields.era = ERA_FIELD; [EOL] fields.monthOfYear = new BasicMonthOfYearDateTimeField(this, 13); [EOL] fields.months = fields.monthOfYear.getDurationField(); [EOL] } [EOL] }
public void testMonthsZero() { [EOL] Months result = Time.months(0); [EOL] assertEquals(Months.ZERO, result); [EOL] }
public void testMonthsOne() { [EOL] Months result = Time.months(1); [EOL] assertEquals(Months.ONE, result); [EOL] }
public void testMonthsTwo() { [EOL] Months result = Time.months(2); [EOL] assertEquals(Months.TWO, result); [EOL] }
public void testMonthsThree() { [EOL] Months result = Time.months(3); [EOL] assertEquals(Months.THREE, result); [EOL] }
public void testMonthsFour() { [EOL] Months result = Time.months(4); [EOL] assertEquals(Months.FOUR, result); [EOL] }
public void testMonthsFive() { [EOL] Months result = Time.months(5); [EOL] assertEquals(Months.FIVE, result); [EOL] }
public void testMonthsSix() { [EOL] Months result = Time.months(6); [EOL] assertEquals(Months.SIX, result); [EOL] }
public void testMonthsSeven() { [EOL] Months result = Time.months(7); [EOL] assertEquals(Months.SEVEN, result); [EOL] }
public void testMonthsEight() { [EOL] Months result = Time.months(8); [EOL] assertEquals(Months.EIGHT, result); [EOL] }
public void testMonthsNine() { [EOL] Months result = Time.months(9); [EOL] assertEquals(Months.NINE, result); [EOL] }
public void testMonthsTen() { [EOL] Months result = Time.months(10); [EOL] assertEquals(Months.TEN, result); [EOL] }
public void testMonthsEleven() { [EOL] Months result = Time.months(11); [EOL] assertEquals(Months.ELEVEN, result); [EOL] }
public void testMonthsTwelve() { [EOL] Months result = Time.months(12); [EOL] assertEquals(Months.TWELVE, result); [EOL] }
public void testMonthsMaxValue() { [EOL] Months result = Time.months(Integer.MAX_VALUE); [EOL] assertEquals(Months.MAX_VALUE, result); [EOL] }
public void testMonthsMinValue() { [EOL] Months result = Time.months(Integer.MIN_VALUE); [EOL] assertEquals(Months.MIN_VALUE, result); [EOL] }
public void testMonthsDefault() { [EOL] int arbitraryNonSpecialCaseMonth = 13; [EOL] Months result = Time.months(arbitraryNonSpecialCaseMonth); [EOL] assertNotNull(result); [EOL] assertEquals(arbitraryNonSpecialCaseMonth, result.getMonths()); [EOL] }
public void testParseMonths_NullInput() { [EOL] Months result = parseMonths(null); [EOL] assertEquals(Months.ZERO, result); [EOL] }
public void testParseMonths_ValidInput() { [EOL] String periodStr = "P2M"; // Assuming P2M represents a period of 2 months [EOL] Months result = parseMonths(periodStr); [EOL] assertEquals(Months.months(2), result); [EOL] }
public void testParseMonths_InvalidInput() { [EOL] String periodStr = "InvalidInput"; [EOL] try { [EOL] parseMonths(periodStr); [EOL] fail("Should have thrown an exception for invalid input"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public int getMonths() { [EOL] return getValue(); [EOL] }
public void testPlus_Zero() { [EOL] Months initialMonths = Months.months(5); [EOL] Months resultMonths = initialMonths.plus(0); [EOL] assertSame("Expected the same object to be returned", initialMonths, resultMonths); [EOL] }
public void testPlus_NonZero() { [EOL] Months initialMonths = Months.months(5); [EOL] Months resultMonths = initialMonths.plus(3); [EOL] assertEquals("Expected the sum of months", Months.months(8), resultMonths); [EOL] }
public void testPlusWithNull() { [EOL] Months original = Months.JANUARY; [EOL] Months result = original.plus(null); [EOL] assertEquals("Adding null to a month should return the original month", original, result); [EOL] }
public void testPlusWithValidMonths() { [EOL] Months original = Months.JANUARY; [EOL] Months toAdd = Months.FEBRUARY; [EOL] Months expectedResult = Months.MARCH; [EOL] Months result = original.plus(toAdd); [EOL] assertEquals("Adding February to January should result in March", expectedResult, result); [EOL] }
public void testMinus_Zero() { [EOL] Months testMonths = Months.months(5); [EOL] Months result = testMonths.minus(0); [EOL] assertEquals(Months.months(5), result); [EOL] }
public void testMinus_Positive() { [EOL] Months testMonths = Months.months(5); [EOL] Months result = testMonths.minus(3); [EOL] assertEquals(Months.months(2), result); [EOL] }
public void testMinus_Negative() { [EOL] Months testMonths = Months.months(5); [EOL] Months result = testMonths.minus(-3); [EOL] assertEquals(Months.months(8), result); [EOL] }
public void testMinusWithNull() { [EOL] Months originalMonths = Months.of(5); [EOL] Months result = originalMonths.minus(null); [EOL] assertEquals(originalMonths, result); [EOL] }
public void testMinusWithNonNullMonths() { [EOL] Months originalMonths = Months.of(5); [EOL] Months monthsToSubtract = Months.of(3); [EOL] Months expectedResult = Months.of(2); [EOL] Months result = originalMonths.minus(monthsToSubtract); [EOL] assertEquals(expectedResult, result); [EOL] }
public void testToString() { [EOL] Time time = new Time(5); // Assuming there is a constructor that sets the value [EOL] String result = time.toString(); [EOL] assertEquals("P5M", result); [EOL] }
public void testIntervalWithSameStartAndEndInstant() { [EOL] long startInstant = 1000L; [EOL] long endInstant = 1000L; [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] Interval interval = new Interval(startInstant, endInstant, zone); [EOL] assertEquals(startInstant, interval.getStartMillis()); [EOL] assertEquals(endInstant, interval.getEndMillis()); [EOL] assertEquals(ISOChronology.getInstance(zone), interval.getChronology()); [EOL] }
public void testIntervalWithDifferentStartAndEndInstant() { [EOL] long startInstant = 1000L; [EOL] long endInstant = 2000L; [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] Interval interval = new Interval(startInstant, endInstant, zone); [EOL] assertEquals(startInstant, interval.getStartMillis()); [EOL] assertEquals(endInstant, interval.getEndMillis()); [EOL] assertEquals(ISOChronology.getInstance(zone), interval.getChronology()); [EOL] }
public void testIntervalWithDifferentZone() { [EOL] long startInstant = 1000L; [EOL] long endInstant = 2000L; [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] Interval interval = new Interval(startInstant, endInstant, zone); [EOL] assertEquals(startInstant, interval.getStartMillis()); [EOL] assertEquals(endInstant, interval.getEndMillis()); [EOL] assertEquals(ISOChronology.getInstance(zone), interval.getChronology()); [EOL] }
public void testGap_ThisStartAfterOtherEnd() { [EOL] ReadableInterval interval = mock(ReadableInterval.class); [EOL] when(interval.getStartMillis()).thenReturn(1000L); [EOL] when(interval.getEndMillis()).thenReturn(2000L); [EOL] Interval testInterval = new Interval(3000L, 4000L, ISOChronology.getInstance()); [EOL] Interval result = testInterval.gap(interval); [EOL] assertNotNull(result); [EOL] assertEquals(2000L, result.getStartMillis()); [EOL] assertEquals(3000L, result.getEndMillis()); [EOL] assertEquals(ISOChronology.getInstance(), result.getChronology()); [EOL] }
public void testGap_OtherStartAfterThisEnd() { [EOL] ReadableInterval interval = mock(ReadableInterval.class); [EOL] when(interval.getStartMillis()).thenReturn(5000L); [EOL] when(interval.getEndMillis()).thenReturn(6000L); [EOL] Interval testInterval = new Interval(3000L, 4000L, ISOChronology.getInstance()); [EOL] Interval result = testInterval.gap(interval); [EOL] assertNotNull(result); [EOL] assertEquals(4000L, result.getStartMillis()); [EOL] assertEquals(5000L, result.getEndMillis()); [EOL] assertEquals(ISOChronology.getInstance(), result.getChronology()); [EOL] }
public void testGap_NoGap() { [EOL] ReadableInterval interval = mock(ReadableInterval.class); [EOL] when(interval.getStartMillis()).thenReturn(2000L); [EOL] when(interval.getEndMillis()).thenReturn(3000L); [EOL] Interval testInterval = new Interval(1000L, 4000L, ISOChronology.getInstance()); [EOL] Interval result = testInterval.gap(interval); [EOL] assertNull(result); [EOL] }
public void testAbutsWithNullInterval() { [EOL] long now = DateTimeUtils.currentTimeMillis(); [EOL] ReadableInterval interval = null; [EOL] MyClass instance = new MyClass(now - 1, now + 1); // Assuming MyClass has a constructor that takes start and end millis [EOL] boolean result = instance.abuts(interval); [EOL] assertTrue("The intervals should abut when interval is null and current time is at the boundaries", result); [EOL] }
public void testAbutsWithNonAbuttingInterval() { [EOL] ReadableInterval interval1 = new Interval(0, 10); // Assuming Interval is a concrete implementation of ReadableInterval [EOL] ReadableInterval interval2 = new Interval(20, 30); [EOL] MyClass instance = new MyClass(10, 20); // The instance does not abut with interval2 [EOL] boolean result = instance.abuts(interval2); [EOL] assertFalse("The intervals should not abut", result); [EOL] }
public void testAbutsWithAbuttingIntervalAtStart() { [EOL] ReadableInterval interval1 = new Interval(0, 10); [EOL] MyClass instance = new MyClass(10, 20); // The instance abuts with interval1 at the start [EOL] boolean result = instance.abuts(interval1); [EOL] assertTrue("The intervals should abut at the start", result); [EOL] }
public void testAbutsWithAbuttingIntervalAtEnd() { [EOL] ReadableInterval interval2 = new Interval(20, 30); [EOL] MyClass instance = new MyClass(10, 20); // The instance abuts with interval2 at the end [EOL] boolean result = instance.abuts(interval2); [EOL] assertTrue("The intervals should abut at the end", result); [EOL] }
public void testWithChronology_SameChronology() { [EOL] Interval interval = new Interval(0, 10, ISOChronology.getInstance()); [EOL] Chronology sameChronology = ISOChronology.getInstance(); [EOL] Interval result = interval.withChronology(sameChronology); [EOL] assertSame(interval, result); [EOL] }
public void testWithChronology_DifferentChronology() { [EOL] Interval interval = new Interval(0, 10, ISOChronology.getInstance()); [EOL] Chronology differentChronology = GregorianChronology.getInstance(); [EOL] Interval result = interval.withChronology(differentChronology); [EOL] assertNotNull(result); [EOL] assertNotSame(interval, result); [EOL] assertEquals(differentChronology, result.getChronology()); [EOL] }
public void testWithStartMillis_SameStartMillis() { [EOL] long startMillis = System.currentTimeMillis(); [EOL] long endMillis = startMillis + 1000; [EOL] Interval interval = new Interval(startMillis, endMillis); [EOL] Interval result = interval.withStartMillis(startMillis); [EOL] assertSame(interval, result); [EOL] }
public void testWithStartMillis_DifferentStartMillis() { [EOL] long startMillis = System.currentTimeMillis(); [EOL] long newStartMillis = startMillis - 1000; [EOL] long endMillis = startMillis + 1000; [EOL] Interval interval = new Interval(startMillis, endMillis); [EOL] Interval result = interval.withStartMillis(newStartMillis); [EOL] assertNotSame(interval, result); [EOL] assertEquals(newStartMillis, result.getStartMillis()); [EOL] assertEquals(endMillis, result.getEndMillis()); [EOL] }
public void testWithStart_Null() { [EOL] Interval interval = new Interval(0, 10); [EOL] Interval result = interval.withStart(null); [EOL] assertEquals(0, result.getStartMillis()); [EOL] assertEquals(10, result.getEndMillis()); [EOL] } [EOL] public void testWithStart_SameInstant() { [EOL] Instant instant = new Instant(0); [EOL] Interval interval = new Interval(0, 10); [EOL] Interval result = interval.withStart(instant); [EOL] assertEquals(0, result.getStartMillis()); [EOL] assertEquals(10, result.getEndMillis()); [EOL] } [EOL] public void testWithStart_DifferentInstant() { [EOL] Instant instant = new Instant(5); [EOL] Interval interval = new Interval(0, 10); [EOL] Interval result = interval.withStart(instant); [EOL] assertEquals(5, result.getStartMillis()); [EOL] assertEquals(10, result.getEndMillis()); [EOL] }
public void testWithDurationAfterStart_SameDuration() { [EOL] Interval interval = new Interval(0, 1000, ISOChronology.getInstanceUTC()); [EOL] ReadableDuration duration = new Duration(1000); [EOL] Interval result = interval.withDurationAfterStart(duration); [EOL] assertEquals(interval, result); [EOL] }
public void testWithDurationAfterStart_DifferentDuration() { [EOL] Interval interval = new Interval(0, 1000, ISOChronology.getInstanceUTC()); [EOL] ReadableDuration duration = new Duration(2000); [EOL] Interval result = interval.withDurationAfterStart(duration); [EOL] assertNotSame(interval, result); [EOL] assertEquals(0, result.getStartMillis()); [EOL] assertEquals(2000, result.getEndMillis()); [EOL] }
public void testWithPeriodBeforeEnd_NullPeriod() { [EOL] Interval interval = new Interval(0, 1000); // Assuming constructor Interval(long startMillis, long endMillis) [EOL] Interval result = interval.withPeriodBeforeEnd(null); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.getStartMillis()); [EOL] assertEquals(1000, result.getEndMillis()); [EOL] }
public void testWithPeriodBeforeEnd_NonNullPeriod() { [EOL] Interval interval = new Interval(0, 1000); // Assuming constructor Interval(long startMillis, long endMillis) [EOL] ReadablePeriod period = new Period(0, 0, 0, 1); // Assuming constructor Period(int hours, int minutes, int seconds, int millis) [EOL] Interval result = interval.withPeriodBeforeEnd(period); [EOL] assertNotNull(result); [EOL] long expectedStartMillis = interval.getChronology().add(period, interval.getEndMillis(), -1); [EOL] assertEquals(expectedStartMillis, result.getStartMillis()); [EOL] assertEquals(1000, result.getEndMillis()); [EOL] }
public void testNowWithNullZone() { [EOL] try { [EOL] YearMonth.now(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("Zone must not be null", e.getMessage()); [EOL] } [EOL] }
public void testNowWithNonNullZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonth result = YearMonth.now(zone); [EOL] assertNotNull(result); [EOL] assertEquals(zone, result.getChronology().getZone()); [EOL] }
public static YearMonth parse(String str) { [EOL] return parse(str, ISODateTimeFormat.localDateParser()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=797544782896179L; DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };
public void testParseWithFormatter() { [EOL] DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM"); [EOL] String input = "2023-04"; [EOL] YearMonth result = YearMonth.parse(input, formatter); [EOL] assertEquals(2023, result.getYear()); [EOL] assertEquals(4, result.getMonthOfYear()); [EOL] } [EOL] public void testParseWithFormatterNullInput() { [EOL] try { [EOL] YearMonth.parse(null, DateTimeFormatter.ofPattern("yyyy-MM")); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testParseWithFormatterNullFormatter() { [EOL] try { [EOL] YearMonth.parse("2023-04", null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }

public void testYearMonthWithZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonth ym = new YearMonth(zone); [EOL] assertNotNull(ym); [EOL] assertEquals(ISOChronology.getInstance(zone), ym.getChronology()); [EOL] }
public void testYearMonthWithChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth ym = new YearMonth(chronology); [EOL] assertNotNull(ym); [EOL] assertEquals(chronology, ym.getChronology()); [EOL] }
public void testYearMonthWithInstant() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonth ym = new YearMonth(instant); [EOL] assertNotNull(ym); [EOL] assertEquals(ISOChronology.getInstance(), ym.getChronology()); [EOL] }
public void testYearMonthWithInstantAndChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth ym = new YearMonth(instant, chronology); [EOL] assertNotNull(ym); [EOL] assertEquals(chronology, ym.getChronology()); [EOL] }
public void testYearMonthWithObject() { [EOL] Instant instant = new Instant(); [EOL] YearMonth ym = new YearMonth(instant); [EOL] assertNotNull(ym); [EOL] assertEquals(ISOChronology.getInstance(), ym.getChronology()); [EOL] }
public void testYearMonthWithObjectAndChronology() { [EOL] Instant instant = new Instant(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth ym = new YearMonth(instant, chronology); [EOL] assertNotNull(ym); [EOL] assertEquals(chronology, ym.getChronology()); [EOL] }
public void testYearMonthWithYearAndMonth() { [EOL] int year = 2023; [EOL] int month = 4; [EOL] YearMonth ym = new YearMonth(year, month); [EOL] assertNotNull(ym); [EOL] assertEquals(year, ym.getYear()); [EOL] assertEquals(month, ym.getMonthOfYear()); [EOL] }
public void testYearMonthWithYearMonthAndChronology() { [EOL] int year = 2023; [EOL] int month = 4; [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth ym = new YearMonth(year, month, chronology); [EOL] assertNotNull(ym); [EOL] assertEquals(year, ym.getYear()); [EOL] assertEquals(month, ym.getMonthOfYear()); [EOL] assertEquals(chronology, ym.getChronology()); [EOL] }
public void testYearMonthNow() { [EOL] YearMonth ym = YearMonth.now(); [EOL] assertNotNull(ym); [EOL] assertEquals(ISOChronology.getInstance(), ym.getChronology()); [EOL] }
public void testYearMonthNowWithZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonth ym = YearMonth.now(zone); [EOL] assertNotNull(ym); [EOL] assertEquals(ISOChronology.getInstance(zone), ym.getChronology()); [EOL] }
public void testYearMonthNowWithChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth ym = YearMonth.now(chronology); [EOL] assertNotNull(ym); [EOL] assertEquals(chronology, ym.getChronology()); [EOL] }
public void testYearMonthChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonth yearMonth = new YearMonth(chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testYearMonthDefaultConstructor() { [EOL] YearMonth yearMonth = new YearMonth(); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(ISOChronology.getInstance(), yearMonth.getChronology()); [EOL] }
public void testYearMonthZoneConstructor() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonth yearMonth = new YearMonth(zone); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(ISOChronology.getInstance(zone), yearMonth.getChronology()); [EOL] }
public void testYearMonthLongConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonth yearMonth = new YearMonth(instant); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(ISOChronology.getInstance(), yearMonth.getChronology()); [EOL] }
public void testYearMonthLongChronologyConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(instant, chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testYearMonthObjectConstructor() { [EOL] Object instant = new Date(); [EOL] YearMonth yearMonth = new YearMonth(instant); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(ISOChronology.getInstance(), yearMonth.getChronology()); [EOL] }
public void testYearMonthObjectChronologyConstructor() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(instant, chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testYearMonthYearMonthConstructor() { [EOL] YearMonth original = new YearMonth(); [EOL] int[] values = new int[] {2023, 4}; [EOL] YearMonth yearMonth = new YearMonth(original, values); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(original.getChronology(), yearMonth.getChronology()); [EOL] assertEquals(2023, yearMonth.getYear()); [EOL] assertEquals(4, yearMonth.getMonthOfYear()); [EOL] }
public void testYearMonthYearMonthChronologyConstructor() { [EOL] YearMonth original = new YearMonth(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(original, chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testYearMonthIntIntConstructor() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(2023, yearMonth.getYear()); [EOL] assertEquals(4, yearMonth.getMonthOfYear()); [EOL] }
public void testYearMonthIntIntChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(2023, 4, chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] assertEquals(2023, yearMonth.getYear()); [EOL] assertEquals(4, yearMonth.getMonthOfYear()); [EOL] }
public void testYearMonthLongChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonth yearMonth = new YearMonth(instant, chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testYearMonth() { [EOL] YearMonth yearMonth = new YearMonth(); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthDateTimeZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonth yearMonth = new YearMonth(zone); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(zone, yearMonth.getChronology().getZone()); [EOL] }
public void testYearMonthChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = new YearMonth(chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testYearMonthLong() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonth yearMonth = new YearMonth(instant); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthObject() { [EOL] Object instant = new Date(); [EOL] YearMonth yearMonth = new YearMonth(instant); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthObjectChronology() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonth yearMonth = new YearMonth(instant, chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testYearMonthIntInt() { [EOL] int year = 2023; [EOL] int monthOfYear = 4; [EOL] YearMonth yearMonth = new YearMonth(year, monthOfYear); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(year, yearMonth.getYear()); [EOL] assertEquals(monthOfYear, yearMonth.getMonthOfYear()); [EOL] }
public void testYearMonthIntIntChronology() { [EOL] int year = 2023; [EOL] int monthOfYear = 4; [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] YearMonth yearMonth = new YearMonth(year, monthOfYear, chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(year, yearMonth.getYear()); [EOL] assertEquals(monthOfYear, yearMonth.getMonthOfYear()); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testYearMonthNow() { [EOL] YearMonth yearMonth = YearMonth.now(); [EOL] assertNotNull(yearMonth); [EOL] }
public void testYearMonthNowDateTimeZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonth yearMonth = YearMonth.now(zone); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(zone, yearMonth.getChronology().getZone()); [EOL] }
public void testYearMonthNowChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth yearMonth = YearMonth.now(chronology); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(chronology, yearMonth.getChronology()); [EOL] }
public void testYearMonthParseString() { [EOL] String str = "2023-04"; [EOL] YearMonth yearMonth = YearMonth.parse(str); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(2023, yearMonth.getYear()); [EOL] assertEquals(4, yearMonth.getMonthOfYear()); [EOL] }
public void testYearMonthParseStringDateTimeFormatter() { [EOL] String str = "2023-04"; [EOL] DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM"); [EOL] YearMonth yearMonth = YearMonth.parse(str, formatter); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(2023, yearMonth.getYear()); [EOL] assertEquals(4, yearMonth.getMonthOfYear()); [EOL] }
public void testYearMonthFromCalendarFields() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(2023, Calendar.APRIL, 1); [EOL] YearMonth yearMonth = YearMonth.fromCalendarFields(calendar); [EOL] assertNotNull(yearMonth); [EOL] assertEquals(2023, yearMonth.getYear()); [EOL] assertEquals(4, yearMonth.getMonthOfYear()); [EOL] }
public void testYearMonthFromDateFields() { [EOL] Date date = new Date(); [EOL] YearMonth yearMonth = YearMonth.fromDateFields(date); [EOL] assertNotNull(yearMonth); [EOL] }
private Object readResolve() { [EOL] if (DateTimeZone.UTC.equals(getChronology().getZone()) == false) { [EOL] return new YearMonth(this, getChronology().withUTC()); [EOL] } [EOL] return this; [EOL] } [EOL] public YearMonth() {} [EOL] public YearMonth(DateTimeZone zone) {} [EOL] public YearMonth(Chronology chronology) {} [EOL] public YearMonth(long instant) {} [EOL] public YearMonth(long instant, Chronology chronology) {} [EOL] public YearMonth(Object instant) {} [EOL] public YearMonth(Object instant, Chronology chronology) {} [EOL] public YearMonth(int year, int monthOfYear) {} [EOL] public YearMonth(int year, int monthOfYear, Chronology chronology) {} [EOL] YearMonth(YearMonth partial, int[] values) {} [EOL] YearMonth(YearMonth partial, Chronology chrono) {} [EOL] Property(YearMonth partial, int fieldIndex) {} [EOL] public static YearMonth now() {} [EOL] public static YearMonth now(DateTimeZone zone) {} [EOL] public static YearMonth now(Chronology chronology) {} [EOL] public static YearMonth parse(String str) {} [EOL] public static YearMonth parse(String str, DateTimeFormatter formatter) {} [EOL] public static YearMonth fromCalendarFields(Calendar calendar) {} [EOL] public static YearMonth fromDateFields(Date date) {} [EOL] private Object readResolve() {} [EOL] public int size() {} [EOL] protected DateTimeField getField(int index, Chronology chrono) {} [EOL] public DateTimeFieldType getFieldType(int index) {} [EOL] public DateTimeFieldType[] getFieldTypes() {} [EOL] public YearMonth withChronologyRetainFields(Chronology newChronology) {} [EOL] public YearMonth withField(DateTimeFieldType fieldType, int value) {} [EOL] public YearMonth withFieldAdded(DurationFieldType fieldType, int amount) {} [EOL] public YearMonth withPeriodAdded(ReadablePeriod period, int scalar) {} [EOL] public YearMonth plus(ReadablePeriod period) {} [EOL] public YearMonth plusYears(int years) {} [EOL] public YearMonth plusMonths(int months) {} [EOL] public YearMonth minus(ReadablePeriod period) {} [EOL] public YearMonth minusYears(int years) {} [EOL] public YearMonth minusMonths(int months) {} [EOL] public LocalDate toLocalDate(int dayOfMonth) {} [EOL] public Interval toInterval() {} [EOL] public Interval toInterval(DateTimeZone zone) {} [EOL] public int getYear() {} [EOL] public int getMonthOfYear() {} [EOL] public YearMonth withYear(int year) {} [EOL] public YearMonth withMonthOfYear(int monthOfYear) {} [EOL] public Property property(DateTimeFieldType type) {} [EOL] public Property year() {} [EOL] public Property monthOfYear() {} [EOL] public String toString() {} [EOL] public String toString(String pattern) {} [EOL] public String toString(String pattern, Locale locale) throws IllegalArgumentException {} [EOL] public DateTimeField getField() {} [EOL] protected ReadablePartial getReadablePartial() {} [EOL] public YearMonth getYearMonth() {} [EOL] public int get() {} [EOL] public YearMonth addToCopy(int valueToAdd) {} [EOL] public YearMonth addWrapFieldToCopy(int valueToAdd) {} [EOL] public YearMonth setCopy(int value) {} [EOL] public YearMonth setCopy(String text, Locale locale) {} [EOL] public YearMonth setCopy(String text) {} [EOL] long serialVersionUID=797544782896179L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };
protected DateTimeField getField(int index, Chronology chrono) { [EOL] switch(index) { [EOL] case YEAR: [EOL] return chrono.year(); [EOL] case MONTH_OF_YEAR: [EOL] return chrono.monthOfYear(); [EOL] default: [EOL] throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL] } [EOL] } [EOL] public YearMonth(); [EOL] public YearMonth(DateTimeZone zone); [EOL] public YearMonth(Chronology chronology); [EOL] public YearMonth(long instant); [EOL] public YearMonth(long instant, Chronology chronology); [EOL] public YearMonth(Object instant); [EOL] public YearMonth(Object instant, Chronology chronology); [EOL] public YearMonth(int year, int monthOfYear); [EOL] public YearMonth(int year, int monthOfYear, Chronology chronology); [EOL] YearMonth(YearMonth partial, int[] values); [EOL] YearMonth(YearMonth partial, Chronology chrono); [EOL] Property(YearMonth partial, int fieldIndex); [EOL] public static YearMonth now(); [EOL] public static YearMonth now(DateTimeZone zone); [EOL] public static YearMonth now(Chronology chronology); [EOL] public static YearMonth parse(String str); [EOL] public static YearMonth parse(String str, DateTimeFormatter formatter); [EOL] public static YearMonth fromCalendarFields(Calendar calendar); [EOL] public static YearMonth fromDateFields(Date date); [EOL] private Object readResolve(); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public YearMonth withChronologyRetainFields(Chronology newChronology); [EOL] public YearMonth withField(DateTimeFieldType fieldType, int value); [EOL] public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public YearMonth plus(ReadablePeriod period); [EOL] public YearMonth plusYears(int years); [EOL] public YearMonth plusMonths(int months); [EOL] public YearMonth minus(ReadablePeriod period); [EOL] public YearMonth minusYears(int years); [EOL] public YearMonth minusMonths(int months); [EOL] public LocalDate toLocalDate(int dayOfMonth); [EOL] public Interval toInterval(); [EOL] public Interval toInterval(DateTimeZone zone); [EOL] public int getYear(); [EOL] public int getMonthOfYear(); [EOL] public YearMonth withYear(int year); [EOL] public YearMonth withMonthOfYear(int monthOfYear); [EOL] public Property property(DateTimeFieldType type); [EOL] public Property year(); [EOL] public Property monthOfYear(); [EOL] public String toString(); [EOL] public String toString(String pattern); [EOL] public String toString(String pattern, Locale locale) throws IllegalArgumentException; [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public YearMonth getYearMonth(); [EOL] public int get(); [EOL] public YearMonth addToCopy(int valueToAdd); [EOL] public YearMonth addWrapFieldToCopy(int valueToAdd); [EOL] public YearMonth setCopy(int value); [EOL] public YearMonth setCopy(String text, Locale locale); [EOL] public YearMonth setCopy(String text); [EOL] long serialVersionUID=Optional[797544782896179L]; [EOL] DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }];
public void testGetFieldType_ValidIndex() { [EOL] YearMonth yearMonth = new YearMonth(); [EOL] DateTimeFieldType fieldType = yearMonth.getFieldType(0); [EOL] assertEquals(DateTimeFieldType.year(), fieldType); [EOL] }
public void testGetFieldType_InvalidIndex() { [EOL] YearMonth yearMonth = new YearMonth(); [EOL] try { [EOL] yearMonth.getFieldType(-1); [EOL] fail("Should have thrown IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException ex) { [EOL] } [EOL] try { [EOL] yearMonth.getFieldType(2); [EOL] fail("Should have thrown IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException ex) { [EOL] } [EOL] }
public void testMinusMonths() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); // April 2023 [EOL] YearMonth result = yearMonth.minusMonths(1); [EOL] assertEquals(new YearMonth(2023, 3), result); // March 2023 [EOL] }
public void testMinusMonthsAcrossYear() { [EOL] YearMonth yearMonth = new YearMonth(2023, 1); // January 2023 [EOL] YearMonth result = yearMonth.minusMonths(2); [EOL] assertEquals(new YearMonth(2022, 11), result); // November 2022 [EOL] }
public void testMinusMonthsNegative() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); // April 2023 [EOL] YearMonth result = yearMonth.minusMonths(-3); [EOL] assertEquals(new YearMonth(2023, 7), result); // July 2023 [EOL] }
public void testMinusMonthsToZero() { [EOL] YearMonth yearMonth = new YearMonth(2023, 4); // April 2023 [EOL] YearMonth result = yearMonth.minusMonths(4); [EOL] assertEquals(new YearMonth(2023, 12), result); // December 2023 [EOL] }
public void testMinusMonthsFromZero() { [EOL] YearMonth yearMonth = new YearMonth(2023, 1); // January 2023 [EOL] YearMonth result = yearMonth.minusMonths(12); [EOL] assertEquals(new YearMonth(2022, 1), result); // January 2022 [EOL] }
public void testYearProperty() { [EOL] YearMonth ym = new YearMonth(); [EOL] Property prop = ym.year(); [EOL] assertNotNull(prop); [EOL] assertEquals(DateTimeFieldType.year(), prop.getFieldType()); [EOL] }
public void testNow() { [EOL] YearMonth now = YearMonth.now(); [EOL] assertNotNull(now); [EOL] }
public void testNowWithZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonth now = YearMonth.now(zone); [EOL] assertNotNull(now); [EOL] assertEquals(zone, now.getChronology().getZone()); [EOL] }
public void testNowWithChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth now = YearMonth.now(chronology); [EOL] assertNotNull(now); [EOL] assertEquals(chronology, now.getChronology()); [EOL] }
public void testParseString() { [EOL] String str = "2010-06"; [EOL] YearMonth parsed = YearMonth.parse(str); [EOL] assertNotNull(parsed); [EOL] assertEquals(2010, parsed.getYear()); [EOL] assertEquals(6, parsed.getMonthOfYear()); [EOL] }
public void testParseStringWithFormatter() { [EOL] String str = "2010-06"; [EOL] DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM"); [EOL] YearMonth parsed = YearMonth.parse(str, formatter); [EOL] assertNotNull(parsed); [EOL] assertEquals(2010, parsed.getYear()); [EOL] assertEquals(6, parsed.getMonthOfYear()); [EOL] }
public void testFromCalendarFields() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(2010, Calendar.JUNE, 1); [EOL] YearMonth fromCalendar = YearMonth.fromCalendarFields(calendar); [EOL] assertNotNull(fromCalendar); [EOL] assertEquals(2010, fromCalendar.getYear()); [EOL] assertEquals(6, fromCalendar.getMonthOfYear()); [EOL] }
public void testFromDateFields() { [EOL] Date date = new Date(110, 5, 1); // Year is 1900-based, month is 0-based [EOL] YearMonth fromDate = YearMonth.fromDateFields(date); [EOL] assertNotNull(fromDate); [EOL] assertEquals(2010, fromDate.getYear()); [EOL] assertEquals(6, fromDate.getMonthOfYear()); [EOL] }
public void testWithChronologyRetainFields() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth ym = new YearMonth(); [EOL] YearMonth updatedYm = ym.withChronologyRetainFields(chronology); [EOL] assertNotNull(updatedYm); [EOL] assertEquals(chronology, updatedYm.getChronology()); [EOL] }
public void testWithField() { [EOL] YearMonth ym = new YearMonth(); [EOL] YearMonth updatedYm = ym.withField(DateTimeFieldType.year(), 2015); [EOL] assertNotNull(updatedYm); [EOL] assertEquals(2015, updatedYm.getYear()); [EOL] }
public void testWithFieldAdded() { [EOL] YearMonth ym = new YearMonth(); [EOL] YearMonth updatedYm = ym.withFieldAdded(DurationFieldType.months(), 2); [EOL] assertNotNull(updatedYm); [EOL] assertEquals(ym.getMonthOfYear() + 2, updatedYm.getMonthOfYear()); [EOL] }
public void testPlusYears() { [EOL] YearMonth ym = new YearMonth(); [EOL] YearMonth updatedYm = ym.plusYears(1); [EOL] assertNotNull(updatedYm); [EOL] assertEquals(ym.getYear() + 1, updatedYm.getYear()); [EOL] }
public void testPlusMonths() { [EOL] YearMonth ym = new YearMonth(); [EOL] YearMonth updatedYm = ym.plusMonths(1); [EOL] assertNotNull(updatedYm); [EOL] assertEquals(ym.getMonthOfYear() + 1, updatedYm.getMonthOfYear()); [EOL] }
public void testMinusYears() { [EOL] YearMonth ym = new YearMonth(); [EOL] YearMonth updatedYm = ym.minusYears(1); [EOL] assertNotNull(updatedYm); [EOL] assertEquals(ym.getYear() - 1, updatedYm.getYear()); [EOL] }
public void testMinusMonths() { [EOL] YearMonth ym = new YearMonth(); [EOL] YearMonth updatedYm = ym.minusMonths(1); [EOL] assertNotNull(updatedYm); [EOL] assertEquals(ym.getMonthOfYear() - 1, updatedYm.getMonthOfYear()); [EOL] }
public void testToInterval() { [EOL] YearMonth ym = new YearMonth(); [EOL] Interval interval = ym.toInterval(); [EOL] assertNotNull(interval); [EOL] assertEquals(ym.toLocalDate(1), interval.getStart().toLocalDate()); [EOL] }
public void testToIntervalWithZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonth ym = new YearMonth(); [EOL] Interval interval = ym.toInterval(zone); [EOL] assertNotNull(interval); [EOL] assertEquals(zone, interval.getStart().getZone()); [EOL] }
public void testWithYear() { [EOL] YearMonth ym = new YearMonth(); [EOL] YearMonth updatedYm = ym.withYear(2015); [EOL] assertNotNull(updatedYm); [EOL] assertEquals(2015, updatedYm.getYear()); [EOL] }
public void testWithMonthOfYear() { [EOL] YearMonth ym = new YearMonth(); [EOL] YearMonth updatedYm = ym.withMonthOfYear(2); [EOL] assertNotNull(updatedYm); [EOL] assertEquals(2, updatedYm.getMonthOfYear()); [EOL] }
public void testToString() { [EOL] YearMonth ym = new YearMonth(2010, 6); [EOL] String str = ym.toString(); [EOL] assertNotNull(str); [EOL] assertEquals("2010-06", str); [EOL] }
public void testToStringWithPattern() { [EOL] YearMonth ym = new YearMonth(2010, 6); [EOL] String pattern = "yyyy/MM"; [EOL] String str = ym.toString(pattern); [EOL] assertNotNull(str); [EOL] assertEquals("2010/06", str); [EOL] }
public void testToStringWithPatternAndLocale() { [EOL] YearMonth ym = new YearMonth(2010, 6); [EOL] String pattern = "yyyy/MM"; [EOL] Locale locale = Locale.US; [EOL] String str = ym.toString(pattern, locale); [EOL] assertNotNull(str); [EOL] assertEquals("2010/06", str); [EOL] }
public void testSetCopyWithValidTextAndLocale() { [EOL] YearMonth testYearMonth = new YearMonth(2020, 6); [EOL] Locale testLocale = Locale.ENGLISH; [EOL] String validText = "2022-09"; [EOL] YearMonth updatedYearMonth = testYearMonth.setCopy(validText, testLocale); [EOL] assertEquals(new YearMonth(2022, 9), updatedYearMonth); [EOL] }
public void testSetCopyWithInvalidTextAndLocale() { [EOL] YearMonth testYearMonth = new YearMonth(2020, 6); [EOL] Locale testLocale = Locale.ENGLISH; [EOL] String invalidText = "invalid"; [EOL] try { [EOL] testYearMonth.setCopy(invalidText, testLocale); [EOL] fail("Should have thrown an exception due to invalid text input"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetCopyWithNullText() { [EOL] YearMonth testYearMonth = new YearMonth(2020, 6); [EOL] Locale testLocale = Locale.ENGLISH; [EOL] try { [EOL] testYearMonth.setCopy(null, testLocale); [EOL] fail("Should have thrown an exception due to null text input"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetCopyWithNullLocale() { [EOL] YearMonth testYearMonth = new YearMonth(2020, 6); [EOL] String validText = "2022-09"; [EOL] try { [EOL] testYearMonth.setCopy(validText, null); [EOL] fail("Should have thrown an exception due to null locale input"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetCopyWithText() { [EOL] YearMonth testYearMonth = new YearMonth(2023, 4); [EOL] YearMonth resultYearMonth = testYearMonth.setCopy("2024-05"); [EOL] assertEquals(new YearMonth(2024, 5), resultYearMonth); [EOL] }
public void testYearMonthDefaultConstructor() { [EOL] YearMonth testYearMonth = new YearMonth(); [EOL] assertNotNull(testYearMonth); [EOL] }
public void testYearMonthZoneConstructor() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonth testYearMonth = new YearMonth(zone); [EOL] assertNotNull(testYearMonth); [EOL] }
public void testYearMonthChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth testYearMonth = new YearMonth(chronology); [EOL] assertNotNull(testYearMonth); [EOL] }
public void testYearMonthInstantConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] YearMonth testYearMonth = new YearMonth(instant); [EOL] assertNotNull(testYearMonth); [EOL] }
public void testYearMonthInstantChronologyConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth testYearMonth = new YearMonth(instant, chronology); [EOL] assertNotNull(testYearMonth); [EOL] }
public void testYearMonthObjectConstructor() { [EOL] Object instant = new Date(); [EOL] YearMonth testYearMonth = new YearMonth(instant); [EOL] assertNotNull(testYearMonth); [EOL] }
public void testYearMonthObjectChronologyConstructor() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth testYearMonth = new YearMonth(instant, chronology); [EOL] assertNotNull(testYearMonth); [EOL] }
public void testYearMonthYearMonthConstructor() { [EOL] YearMonth partial = new YearMonth(2023, 4); [EOL] int[] values = new int[] {2024, 5}; [EOL] YearMonth testYearMonth = new YearMonth(partial, values); [EOL] assertEquals(new YearMonth(2024, 5), testYearMonth); [EOL] }
public void testYearMonthYearMonthChronologyConstructor() { [EOL] YearMonth partial = new YearMonth(2023, 4); [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] YearMonth testYearMonth = new YearMonth(partial, chrono); [EOL] assertNotNull(testYearMonth); [EOL] }
public void testYearMonthNow() { [EOL] YearMonth testYearMonth = YearMonth.now(); [EOL] assertNotNull(testYearMonth); [EOL] }
public void testYearMonthNowZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] YearMonth testYearMonth = YearMonth.now(zone); [EOL] assertNotNull(testYearMonth); [EOL] }
public void testYearMonthNowChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] YearMonth testYearMonth = YearMonth.now(chronology); [EOL] assertNotNull(testYearMonth); [EOL] }
public void testYearMonthParseString() { [EOL] YearMonth testYearMonth = YearMonth.parse("2023-04"); [EOL] assertEquals(new YearMonth(2023, 4), testYearMonth); [EOL] }
public void testYearMonthParseStringFormatter() { [EOL] DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM"); [EOL] YearMonth testYearMonth = YearMonth.parse("2023-04", formatter); [EOL] assertEquals(new YearMonth(2023, 4), testYearMonth); [EOL] }
public void testYearMonthFromCalendarFields() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.set(2023, Calendar.APRIL, 1); [EOL] YearMonth testYearMonth = YearMonth.fromCalendarFields(calendar); [EOL] assertEquals(new YearMonth(2023, 4), testYearMonth); [EOL] }
public void testYearMonthFromDateFields() { [EOL] Date date = new GregorianCalendar(2023, Calendar.APRIL, 1).getTime(); [EOL] YearMonth testYearMonth = YearMonth.fromDateFields(date); [EOL] assertEquals(new YearMonth(2023, 4), testYearMonth); [EOL] }
public void testGetAsShortTextWithCurrentInstant() { [EOL] DateTimeFormatter formatter = DateTimeFormat.forPattern("MMM"); [EOL] long currentInstant = System.currentTimeMillis(); [EOL] String shortText = formatter.getAsShortText(currentInstant); [EOL] assertNotNull("The short text should not be null", shortText); [EOL] }
public void testGetAsShortTextWithSpecificInstant() { [EOL] DateTimeFormatter formatter = DateTimeFormat.forPattern("MMM"); [EOL] long specificInstant = new DateTime(2023, 3, 15, 0, 0).getMillis(); [EOL] String shortText = formatter.getAsShortText(specificInstant); [EOL] assertEquals("The short text should match the expected month abbreviation", "Mar", shortText); [EOL] }
public void testAddWrapField_WithinBounds() { [EOL] long instant = /* some instant value */; [EOL] int value = /* some value within min and max bounds */; [EOL] long expected = /* expected result of adding value to instant */; [EOL] long result = addWrapField(instant, value); [EOL] assertEquals(expected, result); [EOL] }
public void testAddWrapField_BelowMinimum() { [EOL] long instant = /* some instant value */; [EOL] int value = /* some value below minimum */; [EOL] long expected = /* expected result of wrapping value to stay within bounds */; [EOL] long result = addWrapField(instant, value); [EOL] assertEquals(expected, result); [EOL] }
public void testAddWrapField_AboveMaximum() { [EOL] long instant = /* some instant value */; [EOL] int value = /* some value above maximum */; [EOL] long expected = /* expected result of wrapping value to stay within bounds */; [EOL] long result = addWrapField(instant, value); [EOL] assertEquals(expected, result); [EOL] }
public int[] addWrapFieldTestWithPositiveValueToAdd() { [EOL] ReadablePartial mockInstant = Mockito.mock(ReadablePartial.class); [EOL] int fieldIndex = 0; [EOL] int[] values = new int[] { 5 }; [EOL] int valueToAdd = 3; [EOL] DateTimeField field = new MockDateTimeField(); [EOL] Mockito.when(mockInstant.size()).thenReturn(1); [EOL] Mockito.when(mockInstant.getField(fieldIndex)).thenReturn(field); [EOL] Mockito.when(field.getMinimumValue(mockInstant)).thenReturn(1); [EOL] Mockito.when(field.getMaximumValue(mockInstant)).thenReturn(10); [EOL] int[] result = field.addWrapField(mockInstant, fieldIndex, values, valueToAdd); [EOL] assertEquals(8, result[fieldIndex]); [EOL] }
public int[] addWrapFieldTestWithNegativeValueToAdd() { [EOL] ReadablePartial mockInstant = Mockito.mock(ReadablePartial.class); [EOL] int fieldIndex = 0; [EOL] int[] values = new int[] { 5 }; [EOL] int valueToAdd = -3; [EOL] DateTimeField field = new MockDateTimeField(); [EOL] Mockito.when(mockInstant.size()).thenReturn(1); [EOL] Mockito.when(mockInstant.getField(fieldIndex)).thenReturn(field); [EOL] Mockito.when(field.getMinimumValue(mockInstant)).thenReturn(1); [EOL] Mockito.when(field.getMaximumValue(mockInstant)).thenReturn(10); [EOL] int[] result = field.addWrapField(mockInstant, fieldIndex, values, valueToAdd); [EOL] assertEquals(2, result[fieldIndex]); [EOL] }
public int[] addWrapFieldTestWithWrapAround() { [EOL] ReadablePartial mockInstant = Mockito.mock(ReadablePartial.class); [EOL] int fieldIndex = 0; [EOL] int[] values = new int[] { 9 }; [EOL] int valueToAdd = 5; [EOL] DateTimeField field = new MockDateTimeField(); [EOL] Mockito.when(mockInstant.size()).thenReturn(1); [EOL] Mockito.when(mockInstant.getField(fieldIndex)).thenReturn(field); [EOL] Mockito.when(field.getMinimumValue(mockInstant)).thenReturn(1); [EOL] Mockito.when(field.getMaximumValue(mockInstant)).thenReturn(10); [EOL] int[] result = field.addWrapField(mockInstant, fieldIndex, values, valueToAdd); [EOL] assertEquals(4, result[fieldIndex]); [EOL] }
public int[] addWrapFieldTestWithExactBounds() { [EOL] ReadablePartial mockInstant = Mockito.mock(ReadablePartial.class); [EOL] int fieldIndex = 0; [EOL] int[] values = new int[] { 1 }; [EOL] int valueToAdd = 0; [EOL] DateTimeField field = new MockDateTimeField(); [EOL] Mockito.when(mockInstant.size()).thenReturn(1); [EOL] Mockito.when(mockInstant.getField(fieldIndex)).thenReturn(field); [EOL] Mockito.when(field.getMinimumValue(mockInstant)).thenReturn(1); [EOL] Mockito.when(field.getMaximumValue(mockInstant)).thenReturn(10); [EOL] int[] result = field.addWrapField(mockInstant, fieldIndex, values, valueToAdd); [EOL] assertEquals(1, result[fieldIndex]); [EOL] }
public long set(long instant, String text, Locale locale) { [EOL] int value = convertText(text, locale); [EOL] return set(instant, value); [EOL] }
public boolean isLeap(long instant) { [EOL] return false; [EOL] }
public long remainder(long instant) { [EOL] return instant - roundFloor(instant); [EOL] }
public void testRemainderDateTimeFieldWithValidDivisor() { [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] DurationField mockRangeField = mock(DurationField.class); [EOL] DateTimeFieldType mockType = mock(DateTimeFieldType.class); [EOL] int validDivisor = 2; [EOL] RemainderDateTimeField remainderDateTimeField = new RemainderDateTimeField(mockField, mockRangeField, mockType, validDivisor); [EOL] assertNotNull(remainderDateTimeField); [EOL] assertEquals(mockRangeField, remainderDateTimeField.iRangeField); [EOL] assertNotNull(remainderDateTimeField.iDurationField); [EOL] assertEquals(validDivisor, remainderDateTimeField.iDivisor); [EOL] }
public void testRemainderDateTimeFieldWithInvalidDivisor() { [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] DurationField mockRangeField = mock(DurationField.class); [EOL] DateTimeFieldType mockType = mock(DateTimeFieldType.class); [EOL] int invalidDivisor = 1; [EOL] try { [EOL] new RemainderDateTimeField(mockField, mockRangeField, mockType, invalidDivisor); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The divisor must be at least 2", e.getMessage()); [EOL] } [EOL] }
public void testRemainderDateTimeFieldWithNullDividedField() { [EOL] try { [EOL] new RemainderDateTimeField(null); [EOL] fail("Should have thrown IllegalArgumentException because dividedField is null"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testRemainderDateTimeFieldWithValidDividedField() { [EOL] DividedDateTimeField dividedField = mock(DividedDateTimeField.class); [EOL] when(dividedField.getType()).thenReturn(mock(DateTimeFieldType.class)); [EOL] RemainderDateTimeField remainderDateTimeField = new RemainderDateTimeField(dividedField); [EOL] assertNotNull("RemainderDateTimeField should not be null", remainderDateTimeField); [EOL] }
public void testRemainderDateTimeFieldWithValidInput() { [EOL] DividedDateTimeField dividedField = mock(DividedDateTimeField.class); [EOL] DurationField mockDurationField = mock(DurationField.class); [EOL] DateTimeFieldType mockType = mock(DateTimeFieldType.class); [EOL] when(dividedField.getWrappedField()).thenReturn(new MockDateTimeField(mockDurationField)); [EOL] RemainderDateTimeField remainderDateTimeField = new RemainderDateTimeField(dividedField, mockType); [EOL] assertNotNull(remainderDateTimeField); [EOL] assertEquals(mockDurationField, remainderDateTimeField.getDurationField()); [EOL] assertEquals(mockType, remainderDateTimeField.getType()); [EOL] }
public void testRemainderDateTimeFieldConstructor() { [EOL] DividedDateTimeField mockDividedField = Mockito.mock(DividedDateTimeField.class); [EOL] DurationField mockDurationField = Mockito.mock(DurationField.class); [EOL] DateTimeFieldType mockType = Mockito.mock(DateTimeFieldType.class); [EOL] Mockito.when(mockDividedField.getWrappedField()).thenReturn(Mockito.mock(DateTimeField.class)); [EOL] Mockito.when(mockDividedField.iDivisor).thenReturn(10); [EOL] Mockito.when(mockDividedField.iDurationField).thenReturn(Mockito.mock(DurationField.class)); [EOL] RemainderDateTimeField remainderDateTimeField = new RemainderDateTimeField(mockDividedField, mockDurationField, mockType); [EOL] assertNotNull(remainderDateTimeField); [EOL] assertEquals(mockDurationField, remainderDateTimeField.iDurationField); [EOL] assertEquals(mockDividedField.iDurationField, remainderDateTimeField.iRangeField); [EOL] assertEquals(10, remainderDateTimeField.iDivisor); [EOL] }
public void testGetWithPositiveValue() { [EOL] long instant = /* some positive instant value */; [EOL] int expectedValue = /* expected result for positive value */; [EOL] int actualValue = get(instant); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetWithNegativeValue() { [EOL] long instant = /* some negative instant value */; [EOL] int expectedValue = /* expected result for negative value */; [EOL] int actualValue = get(instant); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testSet_WithinBounds() { [EOL] long instant = System.currentTimeMillis(); [EOL] int value = 5; // Assuming iDivisor is greater than 5 for this test [EOL] long expected = instant; // Replace with the expected result of the set method [EOL] long actual = set(instant, value); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testSet_BelowBounds() { [EOL] long instant = System.currentTimeMillis(); [EOL] int value = -1; // Value is out of bounds, should throw an exception [EOL] try { [EOL] set(instant, value); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testSet_AboveBounds() { [EOL] long instant = System.currentTimeMillis(); [EOL] int value = Integer.MAX_VALUE; // Assuming iDivisor is less than Integer.MAX_VALUE for this test [EOL] try { [EOL] set(instant, value); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }

public void testGetDurationField() { [EOL] MyTimeClass instance = new MyTimeClass(); [EOL] DurationField result = instance.getDurationField(); [EOL] assertNotNull(result); [EOL] }
public void testGetRangeDurationField() { [EOL] MyClass testClass = new MyClass(); // Assuming MyClass is the class that contains getRangeDurationField [EOL] DurationField expected = // initialize with expected DurationField [EOL] testClass.iRangeField = expected; [EOL] DurationField actual = testClass.getRangeDurationField(); [EOL] assertEquals(expected, actual); [EOL] }
public int getMinimumValue() { [EOL] return 0; [EOL] }
public int getMaximumValue() { [EOL] return iDivisor - 1; [EOL] }
public void testGetDividedWithPositiveValue() { [EOL] Time time = new Time(); [EOL] time.iDivisor = 5; // Assuming iDivisor is accessible, otherwise use a setter or constructor [EOL] int result = time.getDivided(10); [EOL] assertEquals(2, result); [EOL] }
public void testGetDividedWithZeroValue() { [EOL] Time time = new Time(); [EOL] time.iDivisor = 5; [EOL] int result = time.getDivided(0); [EOL] assertEquals(0, result); [EOL] }
public void testGetDividedWithNegativeValue() { [EOL] Time time = new Time(); [EOL] time.iDivisor = 5; [EOL] int result = time.getDivided(-10); [EOL] assertEquals(-2, result); [EOL] }
public int getMinimumValue() { [EOL] return 1; [EOL] }
public void testGetMaximumValueForSet() { [EOL] long testInstant = 1234567890L; // A sample instant, this value might need to be adjusted depending on the Chronology used [EOL] int testValue = 5; // A sample value, this value might need to be adjusted depending on the Chronology used [EOL] int expectedMaxValue = 31; // Expected max days in a month, this value might need to be adjusted depending on the Chronology used [EOL] int actualMaxValue = getMaximumValueForSet(testInstant, testValue); [EOL] assertEquals(expectedMaxValue, actualMaxValue); [EOL] }

public void testAppendPaddedInteger_NegativeValueNotMinInt() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendPaddedInteger(buf, -1, 3); [EOL] assertEquals("-001", buf.toString()); [EOL] } [EOL] public void testAppendPaddedInteger_NegativeMinInt() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendPaddedInteger(buf, Integer.MIN_VALUE, 3); [EOL] assertEquals("-" + -(long) Integer.MIN_VALUE, buf.toString()); [EOL] } [EOL] public void testAppendPaddedInteger_SingleDigitValue() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendPaddedInteger(buf, 5, 3); [EOL] assertEquals("005", buf.toString()); [EOL] } [EOL] public void testAppendPaddedInteger_TwoDigitValue() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendPaddedInteger(buf, 50, 4); [EOL] assertEquals("0050", buf.toString()); [EOL] } [EOL] public void testAppendPaddedInteger_ThreeDigitValue() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendPaddedInteger(buf, 123, 5); [EOL] assertEquals("00123", buf.toString()); [EOL] } [EOL] public void testAppendPaddedInteger_FourDigitValue() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendPaddedInteger(buf, 1234, 6); [EOL] assertEquals("001234", buf.toString()); [EOL] } [EOL] public void testAppendPaddedInteger_LargeValue() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendPaddedInteger(buf, 123456, 8); [EOL] assertEquals("00123456", buf.toString()); [EOL] }
public void testAppendUnpaddedInteger_NegativeValue() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendUnpaddedInteger(buf, -1); [EOL] assertEquals("-1", buf.toString()); [EOL] } [EOL] public void testAppendUnpaddedInteger_MinValue() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendUnpaddedInteger(buf, Integer.MIN_VALUE); [EOL] assertEquals("-" + -(long) Integer.MIN_VALUE, buf.toString()); [EOL] } [EOL] public void testAppendUnpaddedInteger_SingleDigit() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendUnpaddedInteger(buf, 5); [EOL] assertEquals("5", buf.toString()); [EOL] } [EOL] public void testAppendUnpaddedInteger_TwoDigits() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendUnpaddedInteger(buf, 42); [EOL] assertEquals("42", buf.toString()); [EOL] } [EOL] public void testAppendUnpaddedInteger_ThreeDigits() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] appendUnpaddedInteger(buf, 123); [EOL] assertEquals("123", buf.toString()); [EOL] }

public void testCalculateDigitCountNegativeValueNotMinLong() { [EOL] int result = Time.calculateDigitCount(-123); [EOL] assertEquals(4, result); [EOL] } [EOL] public void testCalculateDigitCountMinLong() { [EOL] int result = Time.calculateDigitCount(Long.MIN_VALUE); [EOL] assertEquals(20, result); [EOL] } [EOL] public void testCalculateDigitCountSingleDigit() { [EOL] int result = Time.calculateDigitCount(5); [EOL] assertEquals(1, result); [EOL] } [EOL] public void testCalculateDigitCountTwoDigits() { [EOL] int result = Time.calculateDigitCount(99); [EOL] assertEquals(2, result); [EOL] } [EOL] public void testCalculateDigitCountThreeDigits() { [EOL] int result = Time.calculateDigitCount(123); [EOL] assertEquals(3, result); [EOL] } [EOL] public void testCalculateDigitCountFourDigits() { [EOL] int result = Time.calculateDigitCount(9999); [EOL] assertEquals(4, result); [EOL] } [EOL] public void testCalculateDigitCountLargeNumber() { [EOL] int result = Time.calculateDigitCount(123456); [EOL] assertEquals(6, result); [EOL] }
public void testCreateErrorMessageWithShortTextAndNegativeErrorPos() { [EOL] String result = createErrorMessage("short text", -1); [EOL] assertEquals("Invalid format: \"short text\"", result); [EOL] } [EOL] public void testCreateErrorMessageWithShortTextAndErrorPosBeyondLength() { [EOL] String result = createErrorMessage("short text", 20); [EOL] assertEquals("Invalid format: \"short text\" is too short", result); [EOL] } [EOL] public void testCreateErrorMessageWithShortTextAndValidErrorPos() { [EOL] String result = createErrorMessage("short text", 5); [EOL] assertEquals("Invalid format: \"short text\" is malformed at \"t text\"", result); [EOL] }
public void testCreateErrorMessageWithLongTextAndNegativeErrorPos() { [EOL] String result = createErrorMessage("This is a very long text that exceeds the maximum length of the sample text", -1); [EOL] assertEquals("Invalid format: \"This is a very long text that exceeds the maximum length of the sample text\"", result); [EOL] } [EOL] public void testCreateErrorMessageWithLongTextAndErrorPosBeyondLength() { [EOL] String result = createErrorMessage("This is a very long text that exceeds the maximum length of the sample text", 100); [EOL] assertEquals("Invalid format: \"This is a very long text that exceeds the maximum length of the sample text\" is too short", result); [EOL] } [EOL] public void testCreateErrorMessageWithLongTextAndValidErrorPos() { [EOL] String result = createErrorMessage("This is a very long text that exceeds the maximum length of the sample text", 5); [EOL] assertTrue(result.startsWith("Invalid format: \"This is a very long text that exceeds the maximum length of the samp...\" is malformed at")); [EOL] }
public void testAdjustYearForSetWithNegativeYear() { [EOL] int year = -1; [EOL] int adjustedYear = Time.adjustYearForSet(year); [EOL] assertEquals("Negative year should be incremented", 0, adjustedYear); [EOL] } [EOL] public void testAdjustYearForSetWithZeroYear() { [EOL] try { [EOL] Time.adjustYearForSet(0); [EOL] fail("Should have thrown IllegalFieldValueException for year 0"); [EOL] } catch (IllegalFieldValueException e) { [EOL] } [EOL] } [EOL] public void testAdjustYearForSetWithPositiveYear() { [EOL] int year = 1; [EOL] int adjustedYear = Time.adjustYearForSet(year); [EOL] assertEquals("Positive year should not change", 1, adjustedYear); [EOL] }

public void testGetDateMidnightMillis_ValidDate() { [EOL] int year = 2021; [EOL] int monthOfYear = 5; // May [EOL] int dayOfMonth = 15; [EOL] long expectedMillis = /* some expected value, e.g., the result of calling the method with these parameters */; [EOL] long actualMillis = getDateMidnightMillis(year, monthOfYear, dayOfMonth); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetDateMidnightMillis_InvalidDate() { [EOL] int year = 2021; [EOL] int monthOfYear = 13; // Invalid month [EOL] int dayOfMonth = 15; [EOL] try { [EOL] getDateMidnightMillis(year, monthOfYear, dayOfMonth); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDateMidnightMillis_LeapYear() { [EOL] int year = 2020; // Leap year [EOL] int monthOfYear = 2; // February [EOL] int dayOfMonth = 29; // Valid day in a leap year [EOL] long expectedMillis = /* some expected value, e.g., the result of calling the method with these parameters */; [EOL] long actualMillis = getDateMidnightMillis(year, monthOfYear, dayOfMonth); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testIsLeapYear_LeapYear() { [EOL] boolean result = isLeapYear(2020); [EOL] assertTrue(result); [EOL] }
public void testIsLeapYear_NotLeapYear() { [EOL] boolean result = isLeapYear(2021); [EOL] assertFalse(result); [EOL] }
public void testCalculateFirstDayOfYearMillis_ForYearLessThanOrEqualTo1968() { [EOL] int year = 1968; [EOL] long expectedMillis = -DateTimeConstants.MILLIS_PER_DAY * (366L + 352); [EOL] long actualMillis = calculateFirstDayOfYearMillis(year); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testCalculateFirstDayOfYearMillis_ForNonLeapYearGreaterThan1968() { [EOL] int year = 1970; // 1970 is not a leap year [EOL] long expectedMillis = 2 * 365L * DateTimeConstants.MILLIS_PER_DAY - (366L + 352) * DateTimeConstants.MILLIS_PER_DAY; [EOL] long actualMillis = calculateFirstDayOfYearMillis(year); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testCalculateFirstDayOfYearMillis_ForLeapYearGreaterThan1968() { [EOL] int year = 1972; // 1972 is a leap year [EOL] long expectedMillis = (4 * 365L + 1) * DateTimeConstants.MILLIS_PER_DAY - (366L + 352) * DateTimeConstants.MILLIS_PER_DAY; [EOL] long actualMillis = calculateFirstDayOfYearMillis(year); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetAverageMillisPerYearDividedByTwo() { [EOL] long expected = TimeConstants.MILLIS_PER_YEAR / 2; [EOL] long actual = time.getAverageMillisPerYearDividedByTwo(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetApproxMillisAtEpochDividedByTwo() { [EOL] long expected = (1969L * 31536000000L + 352L * 86400000L) / 2; [EOL] long actual = getApproxMillisAtEpochDividedByTwo(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetChronologyWithNullChrono() { [EOL] ReadableInstant mockInstant = mock(ReadableInstant.class); [EOL] Chronology expectedChronology = ISOChronology.getInstance(); [EOL] when(mockInstant.getChronology()).thenReturn(expectedChronology); [EOL] Chronology result = getChronology(mockInstant, null); [EOL] assertNotNull(result); [EOL] assertEquals(expectedChronology, result); [EOL] }
public void testGetChronologyWithNonNullChrono() { [EOL] Chronology inputChronology = ISOChronology.getInstance(); [EOL] ReadableInstant mockInstant = mock(ReadableInstant.class); [EOL] Chronology result = getChronology(mockInstant, inputChronology); [EOL] assertNotNull(result); [EOL] assertEquals(inputChronology, result); [EOL] }
public void testGetInstanceWithNullZone() { [EOL] BuddhistChronology result = BuddhistChronology.getInstance(null); [EOL] assertNotNull(result); [EOL] assertEquals(DateTimeZone.getDefault(), result.getZone()); [EOL] }
public void testGetInstanceWithSpecificZone() { [EOL] DateTimeZone specificZone = DateTimeZone.forID("Asia/Tokyo"); [EOL] BuddhistChronology result = BuddhistChronology.getInstance(specificZone); [EOL] assertNotNull(result); [EOL] assertEquals(specificZone, result.getZone()); [EOL] }
public int getMinimumValueTest() { [EOL] int expectedMinimumValue = /* some expected minimum value based on the context */; [EOL] int actualMinimumValue = instance.getMinimumValue(); [EOL] assertEquals(expectedMinimumValue, actualMinimumValue); [EOL] }
public void testPreciseDurationFieldConstructorWithValidTypeAndUnitMillis() { [EOL] DurationFieldType type = DurationFieldType.seconds(); [EOL] long unitMillis = 1000; [EOL] PreciseDurationField field = new PreciseDurationField(type, unitMillis); [EOL] assertNotNull(field); [EOL] assertEquals(type, field.getType()); [EOL] assertEquals(unitMillis, field.getUnitMillis()); [EOL] }
public void testIsPrecise_ShouldReturnTrue() { [EOL] Time time = new Time(); [EOL] assertTrue(time.isPrecise()); [EOL] }
public void testGetUnitMillis() { [EOL] long expectedMillis = 1000L; [EOL] Time time = new Time(expectedMillis); [EOL] long actualMillis = time.getUnitMillis(); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public long getValueAsLong(long duration, long instant) { [EOL] return duration / iUnitMillis; [EOL] }
public void testGetMillis_withPositiveValues() { [EOL] long value = 5; [EOL] long instant = 10; // instant is not used in the method [EOL] long expected = value * iUnitMillis; // Assuming iUnitMillis is a valid field in the class and properly initialized [EOL] long result = getMillis(value, instant); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testGetMillis_withNegativeValue() { [EOL] long value = -5; [EOL] long instant = 10; // instant is not used in the method [EOL] long expected = value * iUnitMillis; // Assuming iUnitMillis is a valid field in the class and properly initialized [EOL] long result = getMillis(value, instant); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testGetMillis_withZeroValue() { [EOL] long value = 0; [EOL] long instant = 10; // instant is not used in the method [EOL] long expected = 0; [EOL] long result = getMillis(value, instant); [EOL] assertEquals(expected, result); [EOL] }
public void testGetMillis_withMaxLongValue() { [EOL] long value = Long.MAX_VALUE; [EOL] long instant = 10; // instant is not used in the method [EOL] try { [EOL] getMillis(value, instant); [EOL] fail("Should have thrown an ArithmeticException due to overflow"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] } [EOL] public void testGetMillis_withMinLongValue() { [EOL] long value = Long.MIN_VALUE; [EOL] long instant = 10; // instant is not used in the method [EOL] try { [EOL] getMillis(value, instant); [EOL] fail("Should have thrown an ArithmeticException due to overflow"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testAdd_WithZeroValue() { [EOL] long instant = 1234567890L; [EOL] long value = 0L; [EOL] long expected = instant; [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testAdd_WithPositiveValue() { [EOL] long instant = 1234567890L; [EOL] long value = 10L; [EOL] long expected = instant + (value * iUnitMillis); [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testAdd_WithNegativeValue() { [EOL] long instant = 1234567890L; [EOL] long value = -10L; [EOL] long expected = instant + (value * iUnitMillis); [EOL] long result = add(instant, value); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testAdd_WithMaxLongValue() { [EOL] long instant = 1234567890L; [EOL] long value = Long.MAX_VALUE; [EOL] try { [EOL] add(instant, value); [EOL] fail("Should have thrown an ArithmeticException due to overflow"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] } [EOL] public void testAdd_WithMinLongValue() { [EOL] long instant = 1234567890L; [EOL] long value = Long.MIN_VALUE; [EOL] try { [EOL] add(instant, value); [EOL] fail("Should have thrown an ArithmeticException due to overflow"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testGetDifferenceAsLong_WithPositiveDifference() { [EOL] long minuendInstant = 10000L; [EOL] long subtrahendInstant = 5000L; [EOL] long expected = 5L; // Assuming iUnitMillis is 1000L [EOL] long actual = getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetDifferenceAsLong_WithNegativeDifference() { [EOL] long minuendInstant = 5000L; [EOL] long subtrahendInstant = 10000L; [EOL] long expected = -5L; // Assuming iUnitMillis is 1000L [EOL] long actual = getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetDifferenceAsLong_WithNoDifference() { [EOL] long minuendInstant = 10000L; [EOL] long subtrahendInstant = 10000L; [EOL] long expected = 0L; // Assuming iUnitMillis is 1000L [EOL] long actual = getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] }
public void testAddWithZeroMonths() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant value [EOL] int months = 0; [EOL] long expected = instant; [EOL] long result = add(instant, months); [EOL] assertEquals(expected, result); [EOL] }
public void testAddWithPositiveMonthsNotExceedingYear() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant value [EOL] int months = SOME_POSITIVE_MONTHS; // Replace with a positive number of months that doesn't exceed a year [EOL] long expected = SOME_EXPECTED_RESULT; // Replace with the expected result [EOL] long result = add(instant, months); [EOL] assertEquals(expected, result); [EOL] }
public void testAddWithPositiveMonthsExceedingYear() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant value [EOL] int months = SOME_POSITIVE_MONTHS_EXCEEDING_YEAR; // Replace with a positive number of months that exceeds a year [EOL] long expected = SOME_EXPECTED_RESULT; // Replace with the expected result [EOL] long result = add(instant, months); [EOL] assertEquals(expected, result); [EOL] }
public void testAddWithNegativeMonthsNotExceedingYear() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant value [EOL] int months = SOME_NEGATIVE_MONTHS; // Replace with a negative number of months that doesn't exceed a year [EOL] long expected = SOME_EXPECTED_RESULT; // Replace with the expected result [EOL] long result = add(instant, months); [EOL] assertEquals(expected, result); [EOL] }
public void testAddWithNegativeMonthsExceedingYear() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant value [EOL] int months = SOME_NEGATIVE_MONTHS_EXCEEDING_YEAR; // Replace with a negative number of months that exceeds a year [EOL] long expected = SOME_EXPECTED_RESULT; // Replace with the expected result [EOL] long result = add(instant, months); [EOL] assertEquals(expected, result); [EOL] }
public void testAddWithMonthChangeCausingYearChange() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant value [EOL] int months = MONTHS_CAUSING_YEAR_CHANGE; // Replace with the number of months that will cause the year to change [EOL] long expected = SOME_EXPECTED_RESULT; // Replace with the expected result [EOL] long result = add(instant, months); [EOL] assertEquals(expected, result); [EOL] }
public void testAddWithDayOfMonthAdjustment() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant value [EOL] int months = MONTHS_WITH_DAY_OF_MONTH_ADJUSTMENT; // Replace with the number of months that will require day of month adjustment [EOL] long expected = SOME_EXPECTED_RESULT; // Replace with the expected result [EOL] long result = add(instant, months); [EOL] assertEquals(expected, result); [EOL] }
public void testGetDifferenceAsLong_MinuendLessThanSubtrahend() { [EOL] long minuendInstant = 100L; [EOL] long subtrahendInstant = 200L; [EOL] long expected = -getDifference(subtrahendInstant, minuendInstant); [EOL] long actual = getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testGetDifferenceAsLong_MinuendGreaterThanSubtrahend() { [EOL] long minuendInstant = 300L; [EOL] long subtrahendInstant = 200L; [EOL] long expected = (iChronology.getYear(minuendInstant) - iChronology.getYear(subtrahendInstant)) * ((long) iMax) [EOL] + iChronology.getMonthOfYear(minuendInstant, iChronology.getYear(minuendInstant)) [EOL] - iChronology.getMonthOfYear(subtrahendInstant, iChronology.getYear(subtrahendInstant)); [EOL] long actual = getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testGetDifferenceAsLong_WithDayOfMonthAdjustment() { [EOL] long minuendInstant = 300L; [EOL] long subtrahendInstant = 200L; [EOL] int minuendYear = iChronology.getYear(minuendInstant); [EOL] int minuendMonth = iChronology.getMonthOfYear(minuendInstant, minuendYear); [EOL] when(iChronology.getDayOfMonth(minuendInstant, minuendYear, minuendMonth)) [EOL] .thenReturn(iChronology.getDaysInYearMonth(minuendYear, minuendMonth)); [EOL] int subtrahendYear = iChronology.getYear(subtrahendInstant); [EOL] int subtrahendMonth = iChronology.getMonthOfYear(subtrahendInstant, subtrahendYear); [EOL] when(iChronology.getDayOfMonth(subtrahendInstant, subtrahendYear, subtrahendMonth)) [EOL] .thenReturn(iChronology.getDaysInYearMonth(minuendYear, minuendMonth) + 1); [EOL] long actual = getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] verify(iChronology).dayOfMonth().set(subtrahendInstant, iChronology.getDayOfMonth(minuendInstant, minuendYear, minuendMonth)); [EOL] } [EOL] public void testGetDifferenceAsLong_WithDifferenceDecrement() { [EOL] long minuendInstant = 300L; [EOL] long subtrahendInstant = 200L; [EOL] int minuendYear = iChronology.getYear(minuendInstant); [EOL] int minuendMonth = iChronology.getMonthOfYear(minuendInstant, minuendYear); [EOL] int subtrahendYear = iChronology.getYear(subtrahendInstant); [EOL] int subtrahendMonth = iChronology.getMonthOfYear(subtrahendInstant, subtrahendYear); [EOL] long minuendRem = minuendInstant - iChronology.getYearMonthMillis(minuendYear, minuendMonth); [EOL] long subtrahendRem = subtrahendInstant - iChronology.getYearMonthMillis(subtrahendYear, subtrahendMonth); [EOL] when(minuendRem).thenReturn(subtrahendRem + 1); [EOL] long actual = getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] long expectedDifference = (iChronology.getYear(minuendInstant) - iChronology.getYear(subtrahendInstant)) * ((long) iMax) [EOL] + iChronology.getMonthOfYear(minuendInstant, iChronology.getYear(minuendInstant)) [EOL] - iChronology.getMonthOfYear(subtrahendInstant, iChronology.getYear(subtrahendInstant)) - 1; [EOL] assertEquals(expectedDifference, actual); [EOL] }
public void testSetWithMinimumMonth() { [EOL] long instant = /* some initial instant */; [EOL] int month = /* minimum month value */; [EOL] long expected = /* expected instant after setting minimum month */; [EOL] long actual = set(instant, month); [EOL] assertEquals(expected, actual); [EOL] }
public void testSetWithMaximumMonth() { [EOL] long instant = /* some initial instant */; [EOL] int month = /* maximum month value */; [EOL] long expected = /* expected instant after setting maximum month */; [EOL] long actual = set(instant, month); [EOL] assertEquals(expected, actual); [EOL] }
public void testSetWithMonthGreaterThanMaxDom() { [EOL] long instant = /* some initial instant */; [EOL] int thisYear = /* year of the initial instant */; [EOL] int month = /* a month value such that the day of month of the instant is greater than the max day of month for this year and month */; [EOL] int expectedDom = /* expected day of month after adjustment */; [EOL] long expected = /* expected instant after setting month and adjusting day of month */; [EOL] long actual = set(instant, month); [EOL] assertEquals(expected, actual); [EOL] }
public void testBasicDayOfYearDateTimeFieldWithNullChronology() { [EOL] try { [EOL] new BasicDayOfYearDateTimeField(null, new MockDurationField()); [EOL] fail("Should have thrown IllegalArgumentException because chronology is null"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testBasicDayOfYearDateTimeFieldWithNullDurationField() { [EOL] try { [EOL] new BasicDayOfYearDateTimeField(new MockBasicChronology(), null); [EOL] fail("Should have thrown IllegalArgumentException because duration field is null"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testBasicDayOfYearDateTimeFieldWithValidInput() { [EOL] BasicDayOfYearDateTimeField field = new BasicDayOfYearDateTimeField(new MockBasicChronology(), new MockDurationField()); [EOL] assertNotNull("The field should not be null", field); [EOL] assertEquals("The field type should be dayOfYear", DateTimeFieldType.dayOfYear(), field.getType()); [EOL] }
public int getMaximumValueTest() { [EOL] int expectedMaxValue = SOME_EXPECTED_VALUE; // Replace with the actual expected max value [EOL] int actualMaxValue = iChronology.getMaximumValue(); [EOL] assertEquals(expectedMaxValue, actualMaxValue); [EOL] }
public void testSafeAdd_NoOverflow() { [EOL] int val1 = 1000; [EOL] int val2 = 2000; [EOL] int expected = 3000; [EOL] int result = time.safeAdd(val1, val2); [EOL] assertEquals(expected, result); [EOL] }
public void testSafeAdd_PositiveOverflow() { [EOL] int val1 = Integer.MAX_VALUE; [EOL] int val2 = 1; [EOL] try { [EOL] time.safeAdd(val1, val2); [EOL] fail("Expected an ArithmeticException to be thrown"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("The calculation caused an overflow: " + val1 + " + " + val2, e.getMessage()); [EOL] } [EOL] }
public void testSafeAdd_NegativeOverflow() { [EOL] int val1 = Integer.MIN_VALUE; [EOL] int val2 = -1; [EOL] try { [EOL] time.safeAdd(val1, val2); [EOL] fail("Expected an ArithmeticException to be thrown"); [EOL] } catch (ArithmeticException e) { [EOL] assertEquals("The calculation caused an overflow: " + val1 + " + " + val2, e.getMessage()); [EOL] } [EOL] }
public void testSafeMultiplyWithNoOverflow() { [EOL] int result = Time.safeMultiply(10000, 20000); [EOL] assertEquals(200000000, result); [EOL] }
public void testSafeMultiplyWithOverflow() { [EOL] try { [EOL] Time.safeMultiply(Integer.MAX_VALUE, 2); [EOL] fail("Should have thrown ArithmeticException due to overflow"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testSafeMultiplyWithUnderflow() { [EOL] try { [EOL] Time.safeMultiply(Integer.MIN_VALUE, 2); [EOL] fail("Should have thrown ArithmeticException due to underflow"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testSafeMultiplyWithOneAsFirstOperand() { [EOL] long result = Time.safeMultiply(1, 5); [EOL] assertEquals(5, result); [EOL] }
public void testSafeMultiplyWithOneAsSecondOperand() { [EOL] long result = Time.safeMultiply(5, 1); [EOL] assertEquals(5, result); [EOL] }
public void testSafeMultiplyWithZeroAsFirstOperand() { [EOL] long result = Time.safeMultiply(0, 5); [EOL] assertEquals(0, result); [EOL] }
public void testSafeMultiplyWithZeroAsSecondOperand() { [EOL] long result = Time.safeMultiply(5, 0); [EOL] assertEquals(0, result); [EOL] }
public void testSafeMultiplyWithNonOneOperands() { [EOL] long result = Time.safeMultiply(2, 3); [EOL] assertEquals(6, result); [EOL] }
public void testSafeMultiplyOverflow() { [EOL] try { [EOL] Time.safeMultiply(Long.MAX_VALUE, 2); [EOL] fail("Should have thrown ArithmeticException due to overflow"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testSafeMultiplyUnderflow() { [EOL] try { [EOL] Time.safeMultiply(Long.MIN_VALUE, -1); [EOL] fail("Should have thrown ArithmeticException due to underflow"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testVerifyValueBoundsWithinLimits() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); [EOL] DateTimeField field = fieldType.getField(ISOChronology.getInstanceUTC()); [EOL] int lowerBound = 1; [EOL] int upperBound = 31; [EOL] int value = 15; [EOL] verifyValueBounds(field, value, lowerBound, upperBound); [EOL] }
public void testVerifyValueBoundsBelowLowerLimit() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); [EOL] DateTimeField field = fieldType.getField(ISOChronology.getInstanceUTC()); [EOL] int lowerBound = 1; [EOL] int upperBound = 31; [EOL] int value = 0; [EOL] try { [EOL] verifyValueBounds(field, value, lowerBound, upperBound); [EOL] fail("Should have thrown IllegalFieldValueException"); [EOL] } catch (IllegalFieldValueException e) { [EOL] } [EOL] }
public void testVerifyValueBoundsAboveUpperLimit() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); [EOL] DateTimeField field = fieldType.getField(ISOChronology.getInstanceUTC()); [EOL] int lowerBound = 1; [EOL] int upperBound = 31; [EOL] int value = 32; [EOL] try { [EOL] verifyValueBounds(field, value, lowerBound, upperBound); [EOL] fail("Should have thrown IllegalFieldValueException"); [EOL] } catch (IllegalFieldValueException e) { [EOL] } [EOL] }
public void testGetInstance_FirstCall() { [EOL] ConverterManager instance = ConverterManager.getInstance(); [EOL] assertNotNull(instance); [EOL] }
public void testGetInstance_SubsequentCall() { [EOL] ConverterManager firstInstance = ConverterManager.getInstance(); [EOL] ConverterManager secondInstance = ConverterManager.getInstance(); [EOL] assertSame(firstInstance, secondInstance); [EOL] }
public void testGetDurationConverterWithNull() { [EOL] try { [EOL] getDurationConverter(null); [EOL] fail("Expected IllegalArgumentException for null input"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("No duration converter found for type: null", e.getMessage()); [EOL] } [EOL] }
public void testGetDurationConverterWithValidObject() { [EOL] Object validObject = new Object() { [EOL] }; [EOL] DurationConverter expectedConverter = new DurationConverter() { [EOL] }; [EOL] iDurationConverters.add(validObject.getClass(), expectedConverter); [EOL] DurationConverter actualConverter = getDurationConverter(validObject); [EOL] assertSame("Expected the correct duration converter to be returned", expectedConverter, actualConverter); [EOL] }
public void testAddDurationConverter_WithNullConverter() { [EOL] DurationConverter result = addDurationConverter(null); [EOL] assertNull(result); [EOL] } [EOL] public void testAddDurationConverter_WithNonNullConverter() throws SecurityException { [EOL] DurationConverter mockConverter = new MockDurationConverter(); [EOL] DurationConverter result = addDurationConverter(mockConverter); [EOL] assertNotNull(result); [EOL] assertEquals(mockConverter, iDurationConverters[iDurationConverters.length - 1]); [EOL] assertEquals(result, removed[0]); [EOL] }

public void testRemoveDurationConverter_WithNullConverter() { [EOL] DurationConverter testConverter = null; [EOL] DurationConverter result = removeDurationConverter(testConverter); [EOL] assertNull(result); [EOL] }
public void testRemoveDurationConverter_WithNonNullConverter_NotInList() { [EOL] DurationConverter testConverter = new MockDurationConverter(); [EOL] DurationConverter result = removeDurationConverter(testConverter); [EOL] assertNull(result); [EOL] }
public void testRemoveDurationConverter_WithNonNullConverter_InList() throws SecurityException { [EOL] DurationConverter testConverter = new MockDurationConverter(); [EOL] addDurationConverter(testConverter); [EOL] DurationConverter result = removeDurationConverter(testConverter); [EOL] assertNotNull(result); [EOL] assertEquals(testConverter, result); [EOL] }
public void testGetPeriodConverterWithNull() { [EOL] try { [EOL] PeriodConverter result = getPeriodConverter(null); [EOL] fail("Should have thrown IllegalArgumentException for null input"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("No period converter found for type: null", e.getMessage()); [EOL] } [EOL] }
public void testGetPeriodConverterWithValidObject() { [EOL] Object validObject = new MockPeriodType(); [EOL] PeriodConverter expectedConverter = new MockPeriodConverter(); [EOL] iPeriodConverters.add(validObject.getClass(), expectedConverter); [EOL] PeriodConverter result = getPeriodConverter(validObject); [EOL] assertNotNull("Expected non-null converter", result); [EOL] assertSame("Expected converter to be the one registered for MockPeriodType", expectedConverter, result); [EOL] }
public void testGetPeriodConverterWithInvalidObject() { [EOL] Object invalidObject = new Object(); [EOL] try { [EOL] PeriodConverter result = getPeriodConverter(invalidObject); [EOL] fail("Should have thrown IllegalArgumentException for invalid input"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("No period converter found for type: " + invalidObject.getClass().getName(), e.getMessage()); [EOL] } [EOL] }
public void testAddPeriodConverter_WithNullConverter() { [EOL] PeriodConverter result = addPeriodConverter(null); [EOL] assertNull(result); [EOL] }
public void testAddPeriodConverter_WithNonNullConverter() throws SecurityException { [EOL] PeriodConverter mockConverter = createMockPeriodConverter(); [EOL] PeriodConverter[] originalConverters = getPeriodConvertersArray(); [EOL] PeriodConverter result = addPeriodConverter(mockConverter); [EOL] assertNotNull(getPeriodConvertersArray()); [EOL] assertTrue(Arrays.asList(getPeriodConvertersArray()).contains(mockConverter)); [EOL] if (originalConverters.length > 0) { [EOL] assertEquals(originalConverters[0], result); [EOL] } else { [EOL] assertNull(result); [EOL] } [EOL] } [EOL] private PeriodConverter createMockPeriodConverter() { [EOL] return new PeriodConverter() { [EOL] }; [EOL] } [EOL] private PeriodConverter[] getPeriodConvertersArray() { [EOL] return new PeriodConverter[0]; // Placeholder return [EOL] }
public void testGetIntervalConverterWithNull() { [EOL] IntervalConverter result = instance.getIntervalConverter(null); [EOL] assertNull("Expected null result for null input", result); [EOL] }
public void testGetIntervalConverterWithKnownType() { [EOL] Object knownTypeObject = // create an instance of a known type that has a registered converter [EOL] IntervalConverter expectedConverter = // get the expected converter for the known type [EOL] IntervalConverter result = instance.getIntervalConverter(knownTypeObject); [EOL] assertSame("Expected known converter for known type", expectedConverter, result); [EOL] }
public void testGetIntervalConverterWithUnknownType() { [EOL] Object unknownTypeObject = new Object(); // an object of a type that has no registered converter [EOL] try { [EOL] instance.getIntervalConverter(unknownTypeObject); [EOL] fail("Expected IllegalArgumentException for unknown type"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAddIntervalConverterWithNull() { [EOL] IntervalConverter result = timeObject.addIntervalConverter(null); [EOL] assertNull(result); [EOL] }
public void testAddIntervalConverterWithNonNull() throws SecurityException { [EOL] IntervalConverter mockConverter = new MockIntervalConverter(); [EOL] IntervalConverter result = timeObject.addIntervalConverter(mockConverter); [EOL] assertNotNull(timeObject.getIntervalConverters()); [EOL] assertTrue(Arrays.asList(timeObject.getIntervalConverters()).contains(mockConverter)); [EOL] }
public boolean isLenient() { [EOL] return iField.isLenient(); [EOL] }
public void testBetweenWithNullStart() { [EOL] try { [EOL] int result = Time.between(null, new Instant(), DurationFieldType.days()); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("ReadableInstant objects must not be null", e.getMessage()); [EOL] } [EOL] }
public void testBetweenWithNullEnd() { [EOL] try { [EOL] int result = Time.between(new Instant(), null, DurationFieldType.days()); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("ReadableInstant objects must not be null", e.getMessage()); [EOL] } [EOL] }
public void testBetweenWithValidArguments() { [EOL] Instant start = new Instant(0); [EOL] Instant end = new Instant(86400000); // 1 day later [EOL] int result = Time.between(start, end, DurationFieldType.days()); [EOL] assertEquals(1, result); [EOL] }
public void testBetween_NullStartReadablePartial() { [EOL] try { [EOL] Time.between(null, new LocalDate(), Period.ZERO); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("ReadablePartial objects must not be null", ex.getMessage()); [EOL] } [EOL] } [EOL] public void testBetween_NullEndReadablePartial() { [EOL] try { [EOL] Time.between(new LocalDate(), null, Period.ZERO); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("ReadablePartial objects must not be null", ex.getMessage()); [EOL] } [EOL] } [EOL] public void testBetween_DifferentSizeReadablePartials() { [EOL] try { [EOL] Time.between(new LocalDate(), new LocalTime(), Period.ZERO); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("ReadablePartial objects must have the same set of fields", ex.getMessage()); [EOL] } [EOL] } [EOL] public void testBetween_DifferentFieldTypesReadablePartials() { [EOL] try { [EOL] Time.between(new LocalDate(), new LocalDateTime(), Period.ZERO); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("ReadablePartial objects must have the same set of fields", ex.getMessage()); [EOL] } [EOL] } [EOL] public void testBetween_NonContiguousReadablePartials() { [EOL] try { [EOL] Time.between(new YearMonth(), new YearMonth(), Period.ZERO); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("ReadablePartial objects must be contiguous", ex.getMessage()); [EOL] } [EOL] } [EOL] public void testBetween_ValidReadablePartials() { [EOL] LocalDate start = new LocalDate(1972, 1, 1); [EOL] LocalDate end = new LocalDate(1972, 1, 2); [EOL] int result = Time.between(start, end, Period.days(1)); [EOL] assertEquals(1, result); [EOL] }

public void testBaseSingleFieldPeriodWithZero() { [EOL] BaseSingleFieldPeriod period = new BaseSingleFieldPeriod(0); [EOL] assertEquals(0, period.getFieldValue()); [EOL] }
public void testBaseSingleFieldPeriodWithPositive() { [EOL] BaseSingleFieldPeriod period = new BaseSingleFieldPeriod(1); [EOL] assertEquals(1, period.getFieldValue()); [EOL] }
public void testBaseSingleFieldPeriodWithNegative() { [EOL] BaseSingleFieldPeriod period = new BaseSingleFieldPeriod(-1); [EOL] assertEquals(-1, period.getFieldValue()); [EOL] }
protected int getValue() { [EOL] return iPeriod; [EOL] }
protected void setValue(int value) { [EOL] iPeriod = value; [EOL] }
public int size() { [EOL] return 1; [EOL] }
public void testGetFieldType_ValidIndex() { [EOL] YourClass instance = new YourClass(); [EOL] DurationFieldType fieldType = instance.getFieldType(0); [EOL] assertNotNull(fieldType); [EOL] }
public void testGetFieldType_InvalidIndex() { [EOL] YourClass instance = new YourClass(); [EOL] try { [EOL] instance.getFieldType(1); [EOL] fail("Expected an IndexOutOfBoundsException to be thrown"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] assertEquals("1", e.getMessage()); [EOL] } [EOL] }
public void testGet_WithMatchingType() { [EOL] DurationFieldType testType = mock(DurationFieldType.class); [EOL] when(testType.getFieldType()).thenReturn(testType); [EOL] int expectedValue = 5; [EOL] when(testType.getValue()).thenReturn(expectedValue); [EOL] int result = testType.get(testType); [EOL] assertEquals(expectedValue, result); [EOL] }
public void testGet_WithNonMatchingType() { [EOL] DurationFieldType testType = mock(DurationFieldType.class); [EOL] DurationFieldType differentType = mock(DurationFieldType.class); [EOL] when(testType.getFieldType()).thenReturn(testType); [EOL] when(testType.getValue()).thenReturn(5); [EOL] int result = testType.get(differentType); [EOL] assertEquals(0, result); [EOL] }
public boolean isSupported(DurationFieldType type) { [EOL] return (type == getFieldType()); [EOL] }
public void testToPeriod_WithZeroPeriod() { [EOL] Period input = Period.ZERO; [EOL] Period result = input.toPeriod(); [EOL] assertEquals(Period.ZERO, result); [EOL] }
public void testEquals_SameObject() { [EOL] ReadablePeriod period1 = new MockPeriod(); [EOL] assertTrue(period1.equals(period1)); [EOL] }
public void testEquals_DifferentType() { [EOL] ReadablePeriod period1 = new MockPeriod(); [EOL] Object period2 = new Object(); [EOL] assertFalse(period1.equals(period2)); [EOL] }
public void testEquals_Null() { [EOL] ReadablePeriod period1 = new MockPeriod(); [EOL] Object period2 = null; [EOL] assertFalse(period1.equals(period2)); [EOL] }
public void testEquals_DifferentPeriodType() { [EOL] ReadablePeriod period1 = new MockPeriod(PeriodType.standard()); [EOL] ReadablePeriod period2 = new MockPeriod(PeriodType.yearMonthDayTime()); [EOL] assertFalse(period1.equals(period2)); [EOL] }
public void testEquals_DifferentValue() { [EOL] ReadablePeriod period1 = new MockPeriod(PeriodType.standard(), 5); [EOL] ReadablePeriod period2 = new MockPeriod(PeriodType.standard(), 10); [EOL] assertFalse(period1.equals(period2)); [EOL] }
public void testEquals_SameFields() { [EOL] ReadablePeriod period1 = new MockPeriod(PeriodType.standard(), 5); [EOL] ReadablePeriod period2 = new MockPeriod(PeriodType.standard(), 5); [EOL] assertTrue(period1.equals(period2)); [EOL] }
public void testHashCode_WithDifferentValues() { [EOL] Time time1 = new Time(10, FieldType.HOUR); [EOL] Time time2 = new Time(20, FieldType.HOUR); [EOL] assertNotEquals(time1.hashCode(), time2.hashCode()); [EOL] }
public void testHashCode_WithDifferentFieldTypes() { [EOL] Time time1 = new Time(10, FieldType.HOUR); [EOL] Time time2 = new Time(10, FieldType.MINUTE); [EOL] assertNotEquals(time1.hashCode(), time2.hashCode()); [EOL] }
public void testHashCode_WithSameValuesAndFieldTypes() { [EOL] Time time1 = new Time(10, FieldType.HOUR); [EOL] Time time2 = new Time(10, FieldType.HOUR); [EOL] assertEquals(time1.hashCode(), time2.hashCode()); [EOL] }
int getMonthOfYear(long millis, int year) { [EOL] int i = (int) ((millis - getYearMillis(year)) >> 10); [EOL] return (isLeapYear(year)) ? ((i < 182 * 84375) ? ((i < 91 * 84375) ? ((i < 31 * 84375) ? 1 : (i < 60 * 84375) ? 2 : 3) : ((i < 121 * 84375) ? 4 : (i < 152 * 84375) ? 5 : 6)) : ((i < 274 * 84375) ? ((i < 213 * 84375) ? 7 : (i < 244 * 84375) ? 8 : 9) : ((i < 305 * 84375) ? 10 : (i < 335 * 84375) ? 11 : 12))) : ((i < 181 * 84375) ? ((i < 90 * 84375) ? ((i < 31 * 84375) ? 1 : (i < 59 * 84375) ? 2 : 3) : ((i < 120 * 84375) ? 4 : (i < 151 * 84375) ? 5 : 6)) : ((i < 273 * 84375) ? ((i < 212 * 84375) ? 7 : (i < 243 * 84375) ? 8 : 9) : ((i < 304 * 84375) ? 10 : (i < 334 * 84375) ? 11 : 12))); [EOL] } [EOL] BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek); [EOL] int getMonthOfYear(long millis, int year); [EOL] int getDaysInYearMonth(int year, int month); [EOL] int getDaysInMonthMax(int month); [EOL] int getDaysInMonthMaxForSet(long instant, int value); [EOL] long getTotalMillisByYearMonth(int year, int month); [EOL] long getYearDifference(long minuendInstant, long subtrahendInstant); [EOL] long setYear(long instant, int year); [EOL] long serialVersionUID=538276888268L; [EOL] int[] MIN_DAYS_PER_MONTH_ARRAY={ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }; [EOL] int[] MAX_DAYS_PER_MONTH_ARRAY={ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
public void testGetDaysInYearMonth_LeapYear_February() { [EOL] int year = 2020; // Example leap year [EOL] int month = 2; // February [EOL] int expectedDays = 29; // February has 29 days in a leap year [EOL] int actualDays = getDaysInYearMonth(year, month); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testGetDaysInYearMonth_NonLeapYear_February() { [EOL] int year = 2021; // Example non-leap year [EOL] int month = 2; // February [EOL] int expectedDays = 28; // February has 28 days in a non-leap year [EOL] int actualDays = getDaysInYearMonth(year, month); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testGetDaysInYearMonth_LeapYear_April() { [EOL] int year = 2020; // Example leap year [EOL] int month = 4; // April [EOL] int expectedDays = 30; // April has 30 days [EOL] int actualDays = getDaysInYearMonth(year, month); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testGetDaysInYearMonth_NonLeapYear_April() { [EOL] int year = 2021; // Example non-leap year [EOL] int month = 4; // April [EOL] int expectedDays = 30; // April has 30 days [EOL] int actualDays = getDaysInYearMonth(year, month); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testGetDaysInMonthMaxForSetValueGreaterThan28() { [EOL] long instant = 0L; // Replace with a valid instant if necessary [EOL] int value = 29; [EOL] BasicGJChronology chronology = new BasicGJChronology(null, null, 1); [EOL] int expectedDays = chronology.getDaysInMonthMax(instant); [EOL] int actualDays = chronology.getDaysInMonthMaxForSet(instant, value); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testGetDaysInMonthMaxForSetValueLessThan1() { [EOL] long instant = 0L; // Replace with a valid instant if necessary [EOL] int value = 0; [EOL] BasicGJChronology chronology = new BasicGJChronology(null, null, 1); [EOL] int expectedDays = chronology.getDaysInMonthMax(instant); [EOL] int actualDays = chronology.getDaysInMonthMaxForSet(instant, value); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testGetDaysInMonthMaxForSetValueBetween1And28() { [EOL] long instant = 0L; // Replace with a valid instant if necessary [EOL] int value = 1; // Can be any value between 1 and 28 [EOL] BasicGJChronology chronology = new BasicGJChronology(null, null, 1); [EOL] int expectedDays = 28; [EOL] int actualDays = chronology.getDaysInMonthMaxForSet(instant, value); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testGetTotalMillisByYearMonth_LeapYear_February() { [EOL] int year = 2020; // Example leap year [EOL] int month = 2; // February [EOL] long expectedMillis = MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1]; [EOL] long actualMillis = getTotalMillisByYearMonth(year, month); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetTotalMillisByYearMonth_NonLeapYear_February() { [EOL] int year = 2021; // Example non-leap year [EOL] int month = 2; // February [EOL] long expectedMillis = MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1]; [EOL] long actualMillis = getTotalMillisByYearMonth(year, month); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetTotalMillisByYearMonth_LeapYear_January() { [EOL] int year = 2020; // Example leap year [EOL] int month = 1; // January [EOL] long expectedMillis = MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1]; [EOL] long actualMillis = getTotalMillisByYearMonth(year, month); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetTotalMillisByYearMonth_NonLeapYear_January() { [EOL] int year = 2021; // Example non-leap year [EOL] int month = 1; // January [EOL] long expectedMillis = MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1]; [EOL] long actualMillis = getTotalMillisByYearMonth(year, month); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetYearDifferenceWithEqualYearsAndNoLeapYear() { [EOL] long minuendInstant = getYearMillis(2020); // Assume this is not a leap year [EOL] long subtrahendInstant = getYearMillis(2020); [EOL] long expectedDifference = 0; [EOL] long actualDifference = getYearDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testGetYearDifferenceWithDifferentYearsAndNoLeapYear() { [EOL] long minuendInstant = getYearMillis(2021); // Assume this is not a leap year [EOL] long subtrahendInstant = getYearMillis(2020); [EOL] long expectedDifference = 1; [EOL] long actualDifference = getYearDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testGetYearDifferenceWithSubtrahendLeapYear() { [EOL] long minuendInstant = getYearMillis(2021); // Assume this is not a leap year [EOL] long subtrahendInstant = getYearMillis(2020); // Assume this is a leap year [EOL] long expectedDifference = 1; [EOL] long actualDifference = getYearDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testGetYearDifferenceWithMinuendLeapYear() { [EOL] long minuendInstant = getYearMillis(2020); // Assume this is a leap year [EOL] long subtrahendInstant = getYearMillis(2019); // Assume this is not a leap year [EOL] long expectedDifference = 1; [EOL] long actualDifference = getYearDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testGetYearDifferenceWithBothLeapYears() { [EOL] long minuendInstant = getYearMillis(2020); // Assume this is a leap year [EOL] long subtrahendInstant = getYearMillis(2016); // Assume this is a leap year [EOL] long expectedDifference = 4; [EOL] long actualDifference = getYearDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testGetYearDifferenceWithMinuendBeforeFeb29AndSubtrahendAfter() { [EOL] long minuendInstant = getYearMillis(2020) + FEB_28; // Assume this is a leap year and FEB_28 is the millis for Feb 28 [EOL] long subtrahendInstant = getYearMillis(2019) + FEB_29; // Assume this is not a leap year and FEB_29 is the millis for Feb 29 [EOL] long expectedDifference = 0; [EOL] long actualDifference = getYearDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testGetYearDifferenceWithMinuendAfterFeb29AndSubtrahendBefore() { [EOL] long minuendInstant = getYearMillis(2020) + FEB_29; // Assume this is a leap year and FEB_29 is the millis for Feb 29 [EOL] long subtrahendInstant = getYearMillis(2019) + FEB_28; // Assume this is not a leap year and FEB_28 is the millis for Feb 28 [EOL] long expectedDifference = 1; [EOL] long actualDifference = getYearDifference(minuendInstant, subtrahendInstant); [EOL] assertEquals(expectedDifference, actualDifference); [EOL] }
public void testSetYearWithNonLeapYearToLeapYear() { [EOL] long instant = /* some instant representing a non-leap year */; [EOL] int year = /* a leap year */; [EOL] long expected = /* expected instant after setting year */; [EOL] long actual = setYear(instant, year); [EOL] assertEquals(expected, actual); [EOL] }
public void testSetYearWithLeapYearToNonLeapYear() { [EOL] long instant = /* some instant representing a leap year */; [EOL] int year = /* a non-leap year */; [EOL] long expected = /* expected instant after setting year */; [EOL] long actual = setYear(instant, year); [EOL] assertEquals(expected, actual); [EOL] }
public void testSetYearWithNoLeapYearChange() { [EOL] long instant = /* some instant representing a year */; [EOL] int year = /* the same type of year (leap or non-leap) */; [EOL] long expected = /* expected instant after setting year */; [EOL] long actual = setYear(instant, year); [EOL] assertEquals(expected, actual); [EOL] }
public void testToString_PositiveValue() { [EOL] Time time = new Time(10); [EOL] String result = time.toString(); [EOL] assertEquals("PT10S", result); [EOL] }
public void testToString_NegativeValue() { [EOL] Time time = new Time(-5); [EOL] String result = time.toString(); [EOL] assertEquals("PT-5S", result); [EOL] }
public void testToString_ZeroValue() { [EOL] Time time = new Time(0); [EOL] String result = time.toString(); [EOL] assertEquals("PT0S", result); [EOL] }
public void testAdd_WithinLimits() { [EOL] long instant = 0L; // Assuming 0 is within limits [EOL] long amount = 5L; // Assuming 5 is a valid amount that keeps the result within limits [EOL] long expected = 5L; // Assuming the wrapped field adds the amount directly to the instant [EOL] long result = add(instant, amount); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testAdd_ResultExceedsLimits() { [EOL] long instant = Long.MAX_VALUE; [EOL] long amount = 1L; // This should cause the result to exceed limits [EOL] try { [EOL] add(instant, amount); [EOL] fail("Should have thrown an exception due to exceeding limits"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testAdd_InstantExceedsLimits() { [EOL] long instant = Long.MAX_VALUE; // Assuming this exceeds the limits [EOL] long amount = 0L; // Amount is not relevant here as the instant already exceeds limits [EOL] try { [EOL] add(instant, amount); [EOL] fail("Should have thrown an exception due to instant exceeding limits"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testAdd_AmountCausesUnderflow() { [EOL] long instant = Long.MIN_VALUE; [EOL] long amount = -1L; // This should cause underflow [EOL] try { [EOL] add(instant, amount); [EOL] fail("Should have thrown an exception due to underflow"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public int getLeapAmountTestWithValidInstant() { [EOL] long validInstant = /* some valid instant value */; [EOL] int expectedLeapAmount = /* expected leap amount for the given instant */; [EOL] int actualLeapAmount = getLeapAmount(validInstant); [EOL] assertEquals(expectedLeapAmount, actualLeapAmount); [EOL] }
public int getLeapAmountTestWithLimitsChecked() { [EOL] long instantAtLimit = /* an instant at the limit to trigger checkLimits */; [EOL] try { [EOL] getLeapAmount(instantAtLimit); [EOL] assertTrue(true); // Assuming checkLimits does not throw an exception for this test case [EOL] } catch (Exception e) { [EOL] fail("Should not throw an exception"); [EOL] } [EOL] }
public void testGetMinimumValue_ValidInstant() { [EOL] long instant = /* valid instant value */; [EOL] int expected = /* expected minimum value */; [EOL] int actual = /* your time object */.getMinimumValue(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetMinimumValue_LowerLimitInstant() { [EOL] long instant = /* lower limit instant value */; [EOL] int expected = /* expected minimum value at lower limit */; [EOL] int actual = /* your time object */.getMinimumValue(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetMinimumValue_UpperLimitInstant() { [EOL] long instant = /* upper limit instant value */; [EOL] int expected = /* expected minimum value at upper limit */; [EOL] int actual = /* your time object */.getMinimumValue(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetEra() { [EOL] DateTime testDateTime = new DateTime(); // Assuming DateTime is the class containing getEra [EOL] int era = testDateTime.getEra(); [EOL] assertEquals(1, era); [EOL] }
public int getCenturyOfEra() { [EOL] return getChronology().centuryOfEra().get(getMillis()); [EOL] }
public int getYearOfEra() { [EOL] return getChronology().yearOfEra().get(getMillis()); [EOL] }
public int getYearOfCentury() { [EOL] return getChronology().yearOfCentury().get(getMillis()); [EOL] }
public int getYear() { [EOL] return getChronology().year().get(getMillis()); [EOL] }
public int getDayOfYear() { [EOL] return getChronology().dayOfYear().get(getMillis()); [EOL] }
public int getDayOfWeek() { [EOL] return getChronology().dayOfWeek().get(getMillis()); [EOL] }
public void testEquals_Reflexive() { [EOL] LenientChronology chrono = LenientChronology.getInstance(); [EOL] assertTrue(chrono.equals(chrono)); [EOL] }
public void testEquals_Null() { [EOL] LenientChronology chrono = LenientChronology.getInstance(); [EOL] assertFalse(chrono.equals(null)); [EOL] }
public void testEquals_DifferentClass() { [EOL] LenientChronology chrono = LenientChronology.getInstance(); [EOL] assertFalse(chrono.equals(new Object())); [EOL] }
public void testEquals_EqualInstance() { [EOL] LenientChronology chrono1 = LenientChronology.getInstance(); [EOL] LenientChronology chrono2 = LenientChronology.getInstance(); [EOL] assertTrue(chrono1.equals(chrono2)); [EOL] }
public void testEquals_DifferentBase() { [EOL] LenientChronology chrono1 = LenientChronology.getInstance(); [EOL] LenientChronology chrono2 = LenientChronology.getInstance(ISOChronology.getInstanceUTC()); [EOL] assertFalse(chrono1.equals(chrono2)); [EOL] }
public void testHashCode() { [EOL] Time time = new Time(); [EOL] int expectedHashCode = 236548278 + time.getBase().hashCode() * 7; [EOL] assertEquals(expectedHashCode, time.hashCode()); [EOL] }
public void testWeeksBetween_SameChronology() { [EOL] LocalDate start = new LocalDate(2020, 1, 1); [EOL] LocalDate end = new LocalDate(2020, 1, 15); [EOL] Weeks result = time.weeksBetween(start, end); [EOL] assertEquals(2, result.getWeeks()); [EOL] }
public void testWeeksBetween_DifferentChronology() { [EOL] ReadablePartial start = new YearMonth(2020, 1); [EOL] ReadablePartial end = new YearMonth(2020, 4); [EOL] Weeks result = time.weeksBetween(start, end); [EOL] assertEquals(13, result.getWeeks()); [EOL] }
public void testWeeksInWithNullInterval() { [EOL] Weeks result = Time.weeksIn(null); [EOL] assertEquals(Weeks.ZERO, result); [EOL] }
public void testWeeksInWithValidInterval() { [EOL] ReadableInterval interval = new Interval(0, DurationFieldType.weeks().getField(null).getDurationUnitMillis() * 2); [EOL] Weeks result = Time.weeksIn(interval); [EOL] assertEquals(Weeks.weeks(2), result); [EOL] }
public void testToStandardMinutes() { [EOL] Weeks testWeeks = Weeks.weeks(1); [EOL] Minutes expectedMinutes = Minutes.minutes(7 * 24 * 60); [EOL] assertEquals(expectedMinutes, testWeeks.toStandardMinutes()); [EOL] }
public void testToStandardMinutes_ZeroWeeks() { [EOL] Weeks testWeeks = Weeks.weeks(0); [EOL] Minutes expectedMinutes = Minutes.minutes(0); [EOL] assertEquals(expectedMinutes, testWeeks.toStandardMinutes()); [EOL] }
public void testPlus_ZeroWeeks() { [EOL] Weeks initialWeeks = Weeks.weeks(1); [EOL] Weeks resultWeeks = initialWeeks.plus(0); [EOL] assertSame("Expected the same object to be returned", initialWeeks, resultWeeks); [EOL] }
public void testPlus_NonZeroWeeks() { [EOL] Weeks initialWeeks = Weeks.weeks(1); [EOL] Weeks resultWeeks = initialWeeks.plus(2); [EOL] assertEquals("Expected the sum of weeks", Weeks.weeks(3), resultWeeks); [EOL] }
public void testPlus_withNullWeeks() { [EOL] Weeks initialWeeks = Weeks.weeks(5); [EOL] Weeks result = initialWeeks.plus(null); [EOL] assertEquals(initialWeeks, result); [EOL] }
public void testPlus_withNonNullWeeks() { [EOL] Weeks initialWeeks = Weeks.weeks(5); [EOL] Weeks additionalWeeks = Weeks.weeks(3); [EOL] Weeks result = initialWeeks.plus(additionalWeeks); [EOL] assertEquals(Weeks.weeks(8), result); [EOL] }
public void testMinus_Zero() { [EOL] Weeks weeks = Weeks.weeks(5); [EOL] Weeks result = weeks.minus(0); [EOL] assertEquals(5, result.getWeeks()); [EOL] }
public void testMinus_Positive() { [EOL] Weeks weeks = Weeks.weeks(5); [EOL] Weeks result = weeks.minus(3); [EOL] assertEquals(2, result.getWeeks()); [EOL] }
public void testMinus_Negative() { [EOL] Weeks weeks = Weeks.weeks(5); [EOL] Weeks result = weeks.minus(-3); [EOL] assertEquals(8, result.getWeeks()); [EOL] }
public void testGJMonthOfYearDateTimeFieldWithNullChronology() { [EOL] try { [EOL] new GJMonthOfYearDateTimeField(null); [EOL] fail("Should have thrown IllegalArgumentException for null chronology"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGJMonthOfYearDateTimeFieldWithNonNullChronology() { [EOL] BasicChronology mockChronology = Mockito.mock(BasicChronology.class); [EOL] GJMonthOfYearDateTimeField field = new GJMonthOfYearDateTimeField(mockChronology); [EOL] assertNotNull("The GJMonthOfYearDateTimeField should not be null", field); [EOL] assertEquals("The field type should be monthOfYear", DateTimeFieldType.monthOfYear(), field.getType()); [EOL] assertEquals("The duration field should be months", mockChronology.months(), field.getDurationField()); [EOL] assertEquals("The range duration field should be years", mockChronology.years(), field.getRangeDurationField()); [EOL] }
public void testGetAsTextWithValidMonthValue() { [EOL] String result = getAsText(1, Locale.ENGLISH); [EOL] assertEquals("January", result); [EOL] }
public void testGetAsTextWithInvalidMonthValue() { [EOL] try { [EOL] getAsText(13, Locale.ENGLISH); [EOL] fail("Should have thrown an exception for invalid month value"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetAsTextWithDifferentLocale() { [EOL] String result = getAsText(1, Locale.FRENCH); [EOL] assertEquals("janvier", result); [EOL] }
public void testGetMaximumTextLengthWithNullLocale() { [EOL] try { [EOL] int result = getMaximumTextLength(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testGetMaximumTextLengthWithUSLocale() { [EOL] int result = getMaximumTextLength(Locale.US); [EOL] assertTrue("The result should be a positive integer", result > 0); [EOL] }
public void testGetMaximumTextLengthWithFrenchLocale() { [EOL] int result = getMaximumTextLength(Locale.FRENCH); [EOL] assertTrue("The result should be a positive integer", result > 0); [EOL] }
public void testNowWithNullChronology() { [EOL] try { [EOL] DateTime.now(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("Chronology must not be null", e.getMessage()); [EOL] } [EOL] }
public void testNowWithNonNullChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] DateTime result = DateTime.now(chronology); [EOL] assertNotNull(result); [EOL] assertEquals(chronology, result.getChronology()); [EOL] }
public void testParseWithNullString() { [EOL] try { [EOL] DateTime result = DateTime.parse(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseWithEmptyString() { [EOL] try { [EOL] DateTime result = DateTime.parse(""); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseWithValidString() { [EOL] String validDateTimeString = "2023-04-01T13:01:02.123Z"; [EOL] DateTime result = DateTime.parse(validDateTimeString); [EOL] assertNotNull(result); [EOL] assertEquals(2023, result.getYear()); [EOL] assertEquals(4, result.getMonthOfYear()); [EOL] assertEquals(1, result.getDayOfMonth()); [EOL] assertEquals(13, result.getHourOfDay()); [EOL] assertEquals(1, result.getMinuteOfHour()); [EOL] assertEquals(2, result.getSecondOfMinute()); [EOL] assertEquals(123, result.getMillisOfSecond()); [EOL] }
public void testDateTimeWithNullInstant() { [EOL] DateTime dateTime = new DateTime((Object) null); [EOL] assertNull(dateTime.getChronology()); [EOL] }
public void testDateTimeWithDateInstant() { [EOL] Date date = new Date(); [EOL] DateTime dateTime = new DateTime((Object) date); [EOL] assertEquals(date.getTime(), dateTime.getMillis()); [EOL] }
public void testDateTimeWithCalendarInstant() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] DateTime dateTime = new DateTime((Object) calendar); [EOL] assertEquals(calendar.getTimeInMillis(), dateTime.getMillis()); [EOL] }
public void testDateTimeWithLongInstant() { [EOL] long now = System.currentTimeMillis(); [EOL] DateTime dateTime = new DateTime((Object) now); [EOL] assertEquals(now, dateTime.getMillis()); [EOL] }
public void testDateTimeWithDateTimeInstant() { [EOL] DateTime original = new DateTime(); [EOL] DateTime dateTime = new DateTime((Object) original); [EOL] assertEquals(original.getMillis(), dateTime.getMillis()); [EOL] }
public void testDateTimeWithValidValues() { [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int hourOfDay = 15; [EOL] int minuteOfHour = 30; [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] DateTime dateTime = new DateTime(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, chronology); [EOL] assertEquals(year, dateTime.getYear()); [EOL] assertEquals(monthOfYear, dateTime.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, dateTime.getDayOfMonth()); [EOL] assertEquals(hourOfDay, dateTime.getHourOfDay()); [EOL] assertEquals(minuteOfHour, dateTime.getMinuteOfHour()); [EOL] assertEquals(chronology, dateTime.getChronology()); [EOL] }
public void testDateTimeWithValidValues() { [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int hourOfDay = 15; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 45; [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] DateTime dateTime = new DateTime(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, chronology); [EOL] assertEquals(year, dateTime.getYear()); [EOL] assertEquals(monthOfYear, dateTime.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, dateTime.getDayOfMonth()); [EOL] assertEquals(hourOfDay, dateTime.getHourOfDay()); [EOL] assertEquals(minuteOfHour, dateTime.getMinuteOfHour()); [EOL] assertEquals(secondOfMinute, dateTime.getSecondOfMinute()); [EOL] assertEquals(chronology, dateTime.getChronology()); [EOL] }
public void testToDateTimeISO_WithISOChronology() { [EOL] DateTime dateTime = new DateTime(ISOChronology.getInstance()); [EOL] DateTime result = dateTime.toDateTimeISO(); [EOL] assertSame("Expected same DateTime object for ISOChronology", dateTime, result); [EOL] }
public void testToDateTimeISO_WithNonISOChronology() { [EOL] DateTime dateTime = new DateTime(GregorianChronology.getInstance()); [EOL] DateTime result = dateTime.toDateTimeISO(); [EOL] assertNotSame("Expected different DateTime object for non-ISOChronology", dateTime, result); [EOL] assertEquals("Expected ISOChronology instance", ISOChronology.getInstance(), result.getChronology()); [EOL] }
public void testToDateTimeWithSameZone() { [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] DateTime dateTime = new DateTime(2023, 1, 1, 12, 0, zone); [EOL] DateTime result = dateTime.toDateTime(zone); [EOL] assertSame("Should return the same DateTime object for the same zone", dateTime, result); [EOL] }
public void testToDateTimeWithDifferentZone() { [EOL] DateTimeZone initialZone = DateTimeZone.UTC; [EOL] DateTimeZone newZone = DateTimeZone.forID("Europe/Paris"); [EOL] DateTime dateTime = new DateTime(2023, 1, 1, 12, 0, initialZone); [EOL] DateTime result = dateTime.toDateTime(newZone); [EOL] assertNotSame("Should return a new DateTime object for a different zone", dateTime, result); [EOL] assertEquals("The new DateTime should have the new zone", newZone, result.getZone()); [EOL] }
public void testToDateTimeWithSameChronology() { [EOL] DateTime dateTime = new DateTime(); [EOL] Chronology chronology = dateTime.getChronology(); [EOL] DateTime result = dateTime.toDateTime(chronology); [EOL] assertSame("DateTime should be the same when chronology is the same", dateTime, result); [EOL] }
public void testToDateTimeWithDifferentChronology() { [EOL] DateTime dateTime = new DateTime(); [EOL] Chronology differentChronology = ISOChronology.getInstanceUTC(); [EOL] if (!dateTime.getChronology().equals(differentChronology)) { [EOL] DateTime result = dateTime.toDateTime(differentChronology); [EOL] assertNotSame("DateTime should not be the same when chronology is different", dateTime, result); [EOL] assertEquals("Chronology should be the one passed to the method", differentChronology, result.getChronology()); [EOL] } else { [EOL] fail("The test case setup is incorrect, the chronologies should be different."); [EOL] } [EOL] }
public void testWithChronology_SameChronology() { [EOL] DateTime dateTime = new DateTime(); [EOL] Chronology chronology = dateTime.getChronology(); [EOL] DateTime sameChronologyDateTime = dateTime.withChronology(chronology); [EOL] assertSame(dateTime, sameChronologyDateTime); [EOL] }
public void testWithChronology_DifferentChronology() { [EOL] DateTime dateTime = new DateTime(); [EOL] Chronology newChronology = ISOChronology.getInstanceUTC(); [EOL] if (dateTime.getChronology().equals(newChronology)) { [EOL] newChronology = GregorianChronology.getInstanceUTC(); [EOL] } [EOL] DateTime differentChronologyDateTime = dateTime.withChronology(newChronology); [EOL] assertNotSame(dateTime, differentChronologyDateTime); [EOL] assertEquals(newChronology, differentChronologyDateTime.getChronology()); [EOL] }
public void testWithChronology_NullChronology() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime nullChronologyDateTime = dateTime.withChronology(null); [EOL] assertNotSame(dateTime, nullChronologyDateTime); [EOL] assertNotNull(nullChronologyDateTime.getChronology()); [EOL] }
public void testWithZone_NewZone() { [EOL] DateTimeZone newZone = DateTimeZone.forID("Europe/Paris"); [EOL] DateTime dateTime = new DateTime(2023, 4, 1, 12, 0, DateTimeZone.UTC); [EOL] DateTime result = dateTime.withZone(newZone); [EOL] assertEquals(newZone, result.getZone()); [EOL] }
public void testWithZone_SameZone() { [EOL] DateTimeZone sameZone = DateTimeZone.UTC; [EOL] DateTime dateTime = new DateTime(2023, 4, 1, 12, 0, sameZone); [EOL] DateTime result = dateTime.withZone(sameZone); [EOL] assertEquals(sameZone, result.getZone()); [EOL] }
public void testWithZone_NullZone() { [EOL] DateTime dateTime = new DateTime(2023, 4, 1, 12, 0, DateTimeZone.UTC); [EOL] DateTime result = dateTime.withZone(null); [EOL] assertNull(result.getZone()); [EOL] }
public void testWithFieldAdded_NullFieldType() { [EOL] try { [EOL] DateTime dateTime = new DateTime(); [EOL] dateTime.withFieldAdded(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Field must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testWithFieldAdded_ZeroAmount() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.withFieldAdded(DurationFieldType.days(), 0); [EOL] assertSame("The same instance should be returned", dateTime, result); [EOL] }
public void testWithFieldAdded_NonZeroAmount() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.withFieldAdded(DurationFieldType.days(), 1); [EOL] assertNotSame("A different instance should be returned", dateTime, result); [EOL] assertTrue("The new DateTime should have a different millis value", dateTime.getMillis() != result.getMillis()); [EOL] }
public void testPlusYears_ZeroYears() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusYears(0); [EOL] assertSame("Expected the same instance when adding zero years", dateTime, result); [EOL] }
public void testPlusYears_PositiveYears() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusYears(5); [EOL] assertNotSame("Expected a different instance when adding positive years", dateTime, result); [EOL] assertEquals("Expected the years to be added correctly", dateTime.getYear() + 5, result.getYear()); [EOL] }
public void testPlusYears_NegativeYears() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusYears(-5); [EOL] assertNotSame("Expected a different instance when subtracting years", dateTime, result); [EOL] assertEquals("Expected the years to be subtracted correctly", dateTime.getYear() - 5, result.getYear()); [EOL] }
public void testPlusMonths_ZeroMonths() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusMonths(0); [EOL] assertSame("Expected the same instance when adding zero months", dateTime, result); [EOL] }
public void testPlusMonths_PositiveMonths() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusMonths(1); [EOL] assertNotSame("Expected a different instance when adding months", dateTime, result); [EOL] assertTrue("Expected the result to be after the original dateTime", result.isAfter(dateTime)); [EOL] }
public void testPlusMonths_NegativeMonths() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusMonths(-1); [EOL] assertNotSame("Expected a different instance when subtracting months", dateTime, result); [EOL] assertTrue("Expected the result to be before the original dateTime", result.isBefore(dateTime)); [EOL] }
public void testPlusDays_ZeroDays() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusDays(0); [EOL] assertSame("Expected same instance when adding zero days", dateTime, result); [EOL] }
public void testPlusDays_PositiveDays() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusDays(1); [EOL] assertNotSame("Expected different instance when adding positive days", dateTime, result); [EOL] assertEquals("Expected result to be one day ahead", dateTime.getMillis() + 24 * 60 * 60 * 1000, result.getMillis()); [EOL] }
public void testPlusDays_NegativeDays() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusDays(-1); [EOL] assertNotSame("Expected different instance when adding negative days", dateTime, result); [EOL] assertEquals("Expected result to be one day behind", dateTime.getMillis() - 24 * 60 * 60 * 1000, result.getMillis()); [EOL] }
public void testPlusMillis_Zero() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.plusMillis(0); [EOL] assertSame("Expected the same instance when adding zero milliseconds", dateTime, result); [EOL] }
public void testPlusMillis_Positive() { [EOL] DateTime dateTime = new DateTime(); [EOL] int millisToAdd = 100; [EOL] DateTime result = dateTime.plusMillis(millisToAdd); [EOL] assertEquals("Expected the millis to be added correctly", dateTime.getMillis() + millisToAdd, result.getMillis()); [EOL] }
public void testPlusMillis_Negative() { [EOL] DateTime dateTime = new DateTime(); [EOL] int millisToSubtract = -100; [EOL] DateTime result = dateTime.plusMillis(millisToSubtract); [EOL] assertEquals("Expected the millis to be subtracted correctly", dateTime.getMillis() + millisToSubtract, result.getMillis()); [EOL] }
public void testMinusDays_ZeroDays() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.minusDays(0); [EOL] assertSame("Should return the same DateTime object for zero days", dateTime, result); [EOL] }
public void testMinusDays_PositiveDays() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.minusDays(10); [EOL] assertNotSame("Should return a different DateTime object for positive days", dateTime, result); [EOL] assertTrue("The result should be before the original DateTime", result.isBefore(dateTime)); [EOL] }
public void testMinusDays_NegativeDays() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.minusDays(-10); [EOL] assertNotSame("Should return a different DateTime object for negative days", dateTime, result); [EOL] assertTrue("The result should be after the original DateTime", result.isAfter(dateTime)); [EOL] }
public void testMinusHours_Zero() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.minusHours(0); [EOL] assertSame("Should return the same DateTime object for zero hours subtraction", dateTime, result); [EOL] }
public void testMinusHours_Positive() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.minusHours(1); [EOL] assertNotSame("Should return a different DateTime object for positive hours subtraction", dateTime, result); [EOL] assertEquals("The time should be decreased by one hour", dateTime.getMillis() - DateTimeConstants.MILLIS_PER_HOUR, result.getMillis()); [EOL] }
public void testMinusHours_Negative() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateTime result = dateTime.minusHours(-1); [EOL] assertNotSame("Should return a different DateTime object for negative hours subtraction", dateTime, result); [EOL] assertEquals("The time should be increased by one hour", dateTime.getMillis() + DateTimeConstants.MILLIS_PER_HOUR, result.getMillis()); [EOL] }
public void testWithEra_ValidEra() { [EOL] DateTime dateTime = new DateTime(); [EOL] int validEra = DateTimeConstants.BC; // Assuming BC is a valid era constant [EOL] DateTime updatedDateTime = dateTime.withEra(validEra); [EOL] assertEquals(validEra, updatedDateTime.getEra()); [EOL] }
public void testWithEra_InvalidEra() { [EOL] DateTime dateTime = new DateTime(); [EOL] int invalidEra = -1; // Assuming -1 is an invalid era [EOL] try { [EOL] dateTime.withEra(invalidEra); [EOL] fail("Should have thrown IllegalArgumentException for invalid era"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithCenturyOfEra_ValidCentury() { [EOL] DateTime dateTime = new DateTime(); [EOL] int validCentury = 20; [EOL] DateTime updatedDateTime = dateTime.withCenturyOfEra(validCentury); [EOL] assertEquals(validCentury, updatedDateTime.getCenturyOfEra()); [EOL] }
public void testWithCenturyOfEra_NegativeCentury() { [EOL] DateTime dateTime = new DateTime(); [EOL] int negativeCentury = -1; [EOL] try { [EOL] dateTime.withCenturyOfEra(negativeCentury); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithCenturyOfEra_MaxCentury() { [EOL] DateTime dateTime = new DateTime(); [EOL] int maxCentury = Integer.MAX_VALUE; [EOL] DateTime updatedDateTime = dateTime.withCenturyOfEra(maxCentury); [EOL] assertEquals(maxCentury, updatedDateTime.getCenturyOfEra()); [EOL] }
public void testWithYearOfEra_ValidYear() { [EOL] DateTime dateTime = new DateTime(); [EOL] int yearOfEra = 2023; [EOL] DateTime updatedDateTime = dateTime.withYearOfEra(yearOfEra); [EOL] assertEquals(yearOfEra, updatedDateTime.getYearOfEra()); [EOL] }
public void testWithYearOfEra_NegativeYear() { [EOL] DateTime dateTime = new DateTime(); [EOL] int yearOfEra = -1; [EOL] try { [EOL] dateTime.withYearOfEra(yearOfEra); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithYearOfEra_ZeroYear() { [EOL] DateTime dateTime = new DateTime(); [EOL] int yearOfEra = 0; [EOL] try { [EOL] dateTime.withYearOfEra(yearOfEra); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithYearOfCentury_ValidYear() { [EOL] DateTime dateTime = new DateTime(); [EOL] int yearOfCentury = 50; [EOL] DateTime updatedDateTime = dateTime.withYearOfCentury(yearOfCentury); [EOL] assertEquals(yearOfCentury, updatedDateTime.getYearOfCentury()); [EOL] }
public void testWithYearOfCentury_InvalidYear() { [EOL] DateTime dateTime = new DateTime(); [EOL] int yearOfCentury = -1; [EOL] try { [EOL] dateTime.withYearOfCentury(yearOfCentury); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithYear_ValidYear() { [EOL] DateTime dateTime = new DateTime(); [EOL] int validYear = 2023; [EOL] DateTime updatedDateTime = dateTime.withYear(validYear); [EOL] assertEquals(validYear, updatedDateTime.getYear()); [EOL] }
public void testWithYear_InvalidYear() { [EOL] DateTime dateTime = new DateTime(); [EOL] int invalidYear = -1; // Assuming the year cannot be negative [EOL] try { [EOL] dateTime.withYear(invalidYear); [EOL] fail("Should have thrown an exception for invalid year"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithWeekyear_ValidWeekyear() { [EOL] DateTime dateTime = new DateTime(); [EOL] int validWeekyear = 2023; [EOL] DateTime updatedDateTime = dateTime.withWeekyear(validWeekyear); [EOL] assertEquals(validWeekyear, updatedDateTime.getWeekyear()); [EOL] }
public void testWithWeekyear_NegativeWeekyear() { [EOL] DateTime dateTime = new DateTime(); [EOL] int negativeWeekyear = -1; [EOL] DateTime updatedDateTime = dateTime.withWeekyear(negativeWeekyear); [EOL] assertEquals(negativeWeekyear, updatedDateTime.getWeekyear()); [EOL] }
public void testWithWeekyear_ZeroWeekyear() { [EOL] DateTime dateTime = new DateTime(); [EOL] int zeroWeekyear = 0; [EOL] DateTime updatedDateTime = dateTime.withWeekyear(zeroWeekyear); [EOL] assertEquals(zeroWeekyear, updatedDateTime.getWeekyear()); [EOL] }
public void testWithMonthOfYear_ValidMonth() { [EOL] DateTime dateTime = new DateTime(); [EOL] int monthOfYear = 6; // Assuming 6 is a valid month [EOL] DateTime updatedDateTime = dateTime.withMonthOfYear(monthOfYear); [EOL] assertEquals(monthOfYear, updatedDateTime.getMonthOfYear()); [EOL] }
public void testWithMonthOfYear_InvalidMonth() { [EOL] DateTime dateTime = new DateTime(); [EOL] int monthOfYear = 13; // Assuming the valid range is 1-12 [EOL] try { [EOL] dateTime.withMonthOfYear(monthOfYear); [EOL] fail("Should have thrown an exception for invalid month"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithDayOfYear_ValidDay() { [EOL] DateTime dateTime = new DateTime(); [EOL] int dayOfYear = 1; // Assuming 1 is a valid day of the year [EOL] DateTime result = dateTime.withDayOfYear(dayOfYear); [EOL] assertEquals(dayOfYear, result.getDayOfYear()); [EOL] }
public void testWithDayOfYear_InvalidDay() { [EOL] DateTime dateTime = new DateTime(); [EOL] int dayOfYear = -1; // Assuming -1 is an invalid day of the year [EOL] try { [EOL] dateTime.withDayOfYear(dayOfYear); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithDayOfYear_EndOfYear() { [EOL] DateTime dateTime = new DateTime(); [EOL] int dayOfYear = dateTime.getChronology().dayOfYear().getMaximumValue(); [EOL] DateTime result = dateTime.withDayOfYear(dayOfYear); [EOL] assertEquals(dayOfYear, result.getDayOfYear()); [EOL] }
public void testWithSecondOfMinute_ValidSecond() { [EOL] DateTime dateTime = new DateTime(); [EOL] int validSecond = 30; [EOL] DateTime updatedDateTime = dateTime.withSecondOfMinute(validSecond); [EOL] assertEquals(validSecond, updatedDateTime.getSecondOfMinute()); [EOL] }
public void testWithSecondOfMinute_InvalidSecond() { [EOL] DateTime dateTime = new DateTime(); [EOL] int invalidSecond = 60; [EOL] try { [EOL] dateTime.withSecondOfMinute(invalidSecond); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithMillisOfDay_ValidValue() { [EOL] DateTime dateTime = new DateTime(); [EOL] int validMillis = 12345; [EOL] DateTime updatedDateTime = dateTime.withMillisOfDay(validMillis); [EOL] assertEquals(validMillis, updatedDateTime.getMillisOfDay()); [EOL] }
public void testWithMillisOfDay_MaxValue() { [EOL] DateTime dateTime = new DateTime(); [EOL] int maxMillis = DateTimeConstants.MILLIS_PER_DAY - 1; [EOL] DateTime updatedDateTime = dateTime.withMillisOfDay(maxMillis); [EOL] assertEquals(maxMillis, updatedDateTime.getMillisOfDay()); [EOL] }
public void testWithMillisOfDay_MinValue() { [EOL] DateTime dateTime = new DateTime(); [EOL] int minMillis = 0; [EOL] DateTime updatedDateTime = dateTime.withMillisOfDay(minMillis); [EOL] assertEquals(minMillis, updatedDateTime.getMillisOfDay()); [EOL] }
public void testMonthOfYear() { [EOL] DateTime testDateTime = new DateTime(); [EOL] Property monthProperty = testDateTime.monthOfYear(); [EOL] assertNotNull(monthProperty); [EOL] assertEquals(testDateTime.getChronology().monthOfYear(), monthProperty.getField()); [EOL] assertEquals(testDateTime, monthProperty.getReadableInstant()); [EOL] }
public void testDayOfMonth() { [EOL] LocalDate date = LocalDate.now(); [EOL] Property dom = date.dayOfMonth(); [EOL] assertNotNull(dom); [EOL] assertEquals(date.getChronology().dayOfMonth(), dom.getField()); [EOL] assertEquals(date, dom.getLocalDate()); [EOL] }
public void testSecondOfDay() { [EOL] DateTime dateTime = new DateTime(); [EOL] Property property = dateTime.secondOfDay(); [EOL] assertNotNull(property); [EOL] assertEquals(dateTime.getChronology().secondOfDay().get(), property.get()); [EOL] }
public void testRoundFloorCopy() { [EOL] DateTime instant = new DateTime(); [EOL] DateTimeField field = instant.getChronology().dayOfMonth(); [EOL] DateTime rounded = new DateTime(instant.withMillis(field.roundFloor(instant.getMillis()))); [EOL] assertEquals(rounded, instant.roundFloorCopy()); [EOL] }
public void testRoundHalfEvenCopy() { [EOL] DateTime dateTime = new DateTime(0); // Replace 0 with the actual initial milliseconds [EOL] DateTime roundedDateTime = dateTime.roundHalfEvenCopy(); [EOL] long expectedMillis = dateTime.getMillis(); // Replace with the expected rounded milliseconds [EOL] assertEquals(expectedMillis, roundedDateTime.getMillis()); [EOL] }
public void testGetZoneWithNullId() { [EOL] DateTimeZone result = getZone(null); [EOL] assertNull(result); [EOL] }
public void testGetZoneWithUnknownId() { [EOL] String unknownId = "Unknown"; [EOL] when(iZoneInfoMap.get(unknownId)).thenReturn(null); [EOL] DateTimeZone result = getZone(unknownId); [EOL] assertNull(result); [EOL] }
public void testGetZoneWithSameIdAsObject() { [EOL] String knownId = "Known"; [EOL] when(iZoneInfoMap.get(knownId)).thenReturn(knownId); [EOL] DateTimeZone result = getZone(knownId); [EOL] assertNotNull(result); [EOL] }
public void testGetZoneWithSoftReferenceNotNull() { [EOL] String knownId = "Known"; [EOL] SoftReference<DateTimeZone> softRef = new SoftReference<>(new DateTimeZone(knownId)); [EOL] when(iZoneInfoMap.get(knownId)).thenReturn(softRef); [EOL] DateTimeZone result = getZone(knownId); [EOL] assertNotNull(result); [EOL] }
public void testGetZoneWithSoftReferenceNull() { [EOL] String knownId = "Known"; [EOL] SoftReference<DateTimeZone> softRef = new SoftReference<>(null); [EOL] when(iZoneInfoMap.get(knownId)).thenReturn(softRef); [EOL] DateTimeZone result = getZone(knownId); [EOL] assertNotNull(result); [EOL] }
public void testGetZoneWithRedirectedId() { [EOL] String initialId = "Initial"; [EOL] String redirectedId = "Redirected"; [EOL] when(iZoneInfoMap.get(initialId)).thenReturn(redirectedId); [EOL] when(iZoneInfoMap.get(redirectedId)).thenReturn(redirectedId); [EOL] DateTimeZone result = getZone(initialId); [EOL] assertNotNull(result); [EOL] }
public void testPartialConstructorWithNullTypes() { [EOL] try { [EOL] new Partial(null, new int[]{1, 2, 3}); [EOL] fail("Should have thrown IllegalArgumentException because of null types"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testPartialConstructorWithNullValues() { [EOL] try { [EOL] new Partial(new DateTimeFieldType[]{DateTimeFieldType.year(), DateTimeFieldType.monthOfYear()}, null); [EOL] fail("Should have thrown IllegalArgumentException because of null values"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testPartialConstructorWithMismatchedArrays() { [EOL] try { [EOL] new Partial(new DateTimeFieldType[]{DateTimeFieldType.year()}, new int[]{1, 2}); [EOL] fail("Should have thrown IllegalArgumentException because of mismatched array lengths"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testPartialConstructorWithValidArguments() { [EOL] DateTimeFieldType[] types = new DateTimeFieldType[]{DateTimeFieldType.year(), DateTimeFieldType.monthOfYear()}; [EOL] int[] values = new int[]{2023, 4}; [EOL] Partial partial = new Partial(types, values); [EOL] assertNotNull("Partial object should be created", partial); [EOL] assertEquals("Year should be 2023", 2023, partial.get(DateTimeFieldType.year())); [EOL] assertEquals("Month should be 4", 4, partial.get(DateTimeFieldType.monthOfYear())); [EOL] }
public void testPartialConstructor_NullTypes() { [EOL] try { [EOL] new Partial(null, new int[]{1, 2, 3}, null); [EOL] fail("Should have thrown IllegalArgumentException for null types array"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Types array must not be null", e.getMessage()); [EOL] } [EOL] }
public void testPartialConstructor_NullValues() { [EOL] try { [EOL] new Partial(new DateTimeFieldType[]{DateTimeFieldType.year(), DateTimeFieldType.monthOfYear()}, null, null); [EOL] fail("Should have thrown IllegalArgumentException for null values array"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Values array must not be null", e.getMessage()); [EOL] } [EOL] }
public void testPartialConstructor_InequalLengthArrays() { [EOL] try { [EOL] new Partial(new DateTimeFieldType[]{DateTimeFieldType.year()}, new int[]{1, 2}, null); [EOL] fail("Should have thrown IllegalArgumentException for types and values array of different lengths"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Values array must be the same length as the types array", e.getMessage()); [EOL] } [EOL] }
public void testPartialConstructor_EmptyArrays() { [EOL] Partial partial = new Partial(new DateTimeFieldType[0], new int[0], null); [EOL] assertNotNull(partial); [EOL] }
public void testPartialConstructor_NullTypeElement() { [EOL] try { [EOL] new Partial(new DateTimeFieldType[]{null, DateTimeFieldType.monthOfYear()}, new int[]{1, 2}, null); [EOL] fail("Should have thrown IllegalArgumentException for null element in types array"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("Types array must not contain null: index 0")); [EOL] } [EOL] }
public void testPartialConstructor_UnsupportedType() { [EOL] try { [EOL] DateTimeFieldType unsupportedType = new DateTimeFieldType("unsupported") { [EOL] public DurationFieldType getDurationType() { [EOL] return new DurationFieldType("unsupported") { [EOL] public DurationField getField(Chronology chronology) { [EOL] return UnsupportedDurationField.getInstance(this); [EOL] } [EOL] }; [EOL] } [EOL] public DurationFieldType getRangeDurationType() { [EOL] return null; [EOL] } [EOL] }; [EOL] new Partial(new DateTimeFieldType[]{DateTimeFieldType.year(), unsupportedType}, new int[]{1, 2}, null); [EOL] fail("Should have thrown IllegalArgumentException for unsupported type following a supported one"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("Types array must not contain duplicate unsupported: year and unsupported")); [EOL] } [EOL] }
public void testPartialConstructor_TypesNotInOrder() { [EOL] try { [EOL] new Partial(new DateTimeFieldType[]{DateTimeFieldType.hourOfDay(), DateTimeFieldType.year()}, new int[]{1, 2}, null); [EOL] fail("Should have thrown IllegalArgumentException for types not in order largest-smallest"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("Types array must be in order largest-smallest: hourOfDay < year")); [EOL] } [EOL] }
public void testPartialConstructor_DuplicateTypes() { [EOL] try { [EOL] new Partial(new DateTimeFieldType[]{DateTimeFieldType.year(), DateTimeFieldType.year()}, new int[]{1, 2}, null); [EOL] fail("Should have thrown IllegalArgumentException for duplicate types"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("Types array must not contain duplicate: year and year")); [EOL] } [EOL] }
public void testPartialConstructorWithValidInput() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] DateTimeFieldType[] types = new DateTimeFieldType[] {DateTimeFieldType.year(), DateTimeFieldType.monthOfYear()}; [EOL] int[] values = new int[] {2023, 4}; [EOL] Partial partial = new Partial(chronology, types, values); [EOL] int[] newValues = new int[] {2021, 3}; [EOL] Partial newPartial = new Partial(partial, newValues); [EOL] assertNotNull(newPartial); [EOL] assertEquals(chronology, newPartial.getChronology()); [EOL] assertArrayEquals(types, newPartial.getTypes()); [EOL] assertArrayEquals(newValues, newPartial.getValues()); [EOL] }
public void testPartialConstructorWithValidInput() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] DateTimeFieldType[] types = new DateTimeFieldType[] {DateTimeFieldType.year(), DateTimeFieldType.monthOfYear()}; [EOL] int[] values = new int[] {2023, 4}; [EOL] Partial partial = new Partial(chronology, types, values); [EOL] assertNotNull(partial); [EOL] assertEquals(chronology, partial.getChronology()); [EOL] assertArrayEquals(types, partial.getTypes()); [EOL] assertArrayEquals(values, partial.getValues()); [EOL] }
public void testPartialConstructorWithNullChronology() { [EOL] DateTimeFieldType[] types = new DateTimeFieldType[] {DateTimeFieldType.year(), DateTimeFieldType.monthOfYear()}; [EOL] int[] values = new int[] {2023, 4}; [EOL] Partial partial = new Partial(null, types, values); [EOL] assertNotNull(partial); [EOL] assertNull(partial.getChronology()); [EOL] assertArrayEquals(types, partial.getTypes()); [EOL] assertArrayEquals(values, partial.getValues()); [EOL] }
public void testPartialConstructorWithNullTypes() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int[] values = new int[] {2023, 4}; [EOL] try { [EOL] new Partial(chronology, null, values); [EOL] fail("Should have thrown an exception due to null types"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testPartialConstructorWithNullValues() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] DateTimeFieldType[] types = new DateTimeFieldType[] {DateTimeFieldType.year(), DateTimeFieldType.monthOfYear()}; [EOL] try { [EOL] new Partial(chronology, types, null); [EOL] fail("Should have thrown an exception due to null values"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testPartialConstructorWithMismatchedTypesAndValues() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] DateTimeFieldType[] types = new DateTimeFieldType[] {DateTimeFieldType.year()}; [EOL] int[] values = new int[] {2023, 4}; [EOL] try { [EOL] new Partial(chronology, types, values); [EOL] fail("Should have thrown an exception due to mismatched types and values lengths"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetFieldTypeWithValidIndex() { [EOL] DateTimeFieldType[] types = new DateTimeFieldType[] {DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth()}; [EOL] DateTimeFieldType expectedType = types[1]; [EOL] DateTimeFieldType actualType = new DateTime(types).getFieldType(1); [EOL] assertEquals(expectedType, actualType); [EOL] }
public void testGetFieldTypeWithInvalidIndex() { [EOL] try { [EOL] new DateTime(new DateTimeFieldType[] {DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth()}).getFieldType(3); [EOL] fail("Should have thrown ArrayIndexOutOfBoundsException"); [EOL] } catch (ArrayIndexOutOfBoundsException ex) { [EOL] } [EOL] }
public int testGetValue_ValidIndex() { [EOL] Time time = new Time(new int[]{10, 20, 30}); [EOL] int value = time.getValue(1); [EOL] assert value == 20; [EOL] } [EOL] public int testGetValue_InvalidIndex() { [EOL] Time time = new Time(new int[]{10, 20, 30}); [EOL] try { [EOL] time.getValue(3); [EOL] assert false; // Expected an exception [EOL] } catch (IndexOutOfBoundsException e) { [EOL] assert true; [EOL] } [EOL] }
public void testGetValues() { [EOL] Time time = new Time(); [EOL] int[] expectedValues = new int[] { /* some expected values based on the Time object state */ }; [EOL] int[] actualValues = time.getValues(); [EOL] assertArrayEquals(expectedValues, actualValues); [EOL] }
public void testWithChronologyRetainFields_SameChronology() { [EOL] Chronology initialChronology = ISOChronology.getInstanceUTC(); [EOL] Partial partial = new Partial(initialChronology, new int[]{}, new int[]{}); [EOL] Partial result = partial.withChronologyRetainFields(initialChronology); [EOL] assertSame("Should be the same object as the chronology is the same", partial, result); [EOL] }
public void testWithChronologyRetainFields_DifferentChronology() { [EOL] Chronology initialChronology = ISOChronology.getInstanceUTC(); [EOL] Partial partial = new Partial(initialChronology, new int[]{}, new int[]{}); [EOL] Chronology newChronology = GregorianChronology.getInstanceUTC(); [EOL] Partial result = partial.withChronologyRetainFields(newChronology); [EOL] assertNotSame("Should not be the same object as the chronology is different", partial, result); [EOL] assertEquals("The chronology should be the new chronology", newChronology, result.getChronology()); [EOL] }
public void testWithFieldTypeNull() { [EOL] try { [EOL] Partial partial = new Partial(); [EOL] partial.with(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithFieldTypeNotInPartial() { [EOL] DateTimeFieldType fakeFieldType = new DateTimeFieldType("fake") { [EOL] public DurationFieldType getDurationType() { [EOL] return DurationFieldType.days(); [EOL] } [EOL] public DurationFieldType getRangeDurationType() { [EOL] return null; [EOL] } [EOL] public DateTimeField getField(Chronology chronology) { [EOL] return UnsupportedDateTimeField.getInstance(this, UnsupportedDurationField.getInstance(getDurationType())); [EOL] } [EOL] }; [EOL] Partial partial = new Partial(); [EOL] Partial result = partial.with(fakeFieldType, 1); [EOL] assertEquals("Partial should have added field type", 1, result.size()); [EOL] assertEquals("Value should be set to 1", 1, result.getValue(0)); [EOL] }
public void testWithExistingFieldTypeSameValue() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); [EOL] Partial partial = new Partial(fieldType, 10); [EOL] Partial result = partial.with(fieldType, 10); [EOL] assertSame("Should return same Partial object", partial, result); [EOL] }
public void testWithExistingFieldTypeDifferentValue() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); [EOL] Partial partial = new Partial(fieldType, 10); [EOL] Partial result = partial.with(fieldType, 20); [EOL] assertNotSame("Should return new Partial object", partial, result); [EOL] assertEquals("Value should be updated to 20", 20, result.getValue(0)); [EOL] }
public void testWithoutFieldTypePresent() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.year(); [EOL] Partial partial = new Partial().with(fieldType, 2020); [EOL] int initialSize = partial.size(); [EOL] Partial result = partial.without(fieldType); [EOL] assertEquals(initialSize - 1, result.size()); [EOL] assertEquals(-1, result.indexOf(fieldType)); [EOL] }
public void testWithoutFieldTypeAbsent() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.year(); [EOL] Partial partial = new Partial(); [EOL] int initialSize = partial.size(); [EOL] Partial result = partial.without(fieldType); [EOL] assertEquals(initialSize, result.size()); [EOL] assertSame(partial, result); [EOL] }
public void testWithField_SameValue() { [EOL] Partial partial = createPartial(); // Assume createPartial() creates a valid Partial instance [EOL] DateTimeFieldType fieldType = DateTimeFieldType.year(); // Assume this is a supported field type [EOL] int originalValue = partial.getValue(partial.indexOfSupported(fieldType)); [EOL] Partial result = partial.withField(fieldType, originalValue); [EOL] assertSame("Expected same instance when setting same value", partial, result); [EOL] }
public void testWithField_DifferentValue() { [EOL] Partial partial = createPartial(); // Assume createPartial() creates a valid Partial instance [EOL] DateTimeFieldType fieldType = DateTimeFieldType.year(); // Assume this is a supported field type [EOL] int originalValue = partial.getValue(partial.indexOfSupported(fieldType)); [EOL] int newValue = originalValue + 1; [EOL] Partial result = partial.withField(fieldType, newValue); [EOL] assertNotNull("Expected new Partial instance", result); [EOL] assertNotSame("Expected different instance when setting new value", partial, result); [EOL] assertEquals("Expected new value to be set", newValue, result.getValue(partial.indexOfSupported(fieldType))); [EOL] }
public void testWithField_UnsupportedType() { [EOL] Partial partial = createPartial(); // Assume createPartial() creates a valid Partial instance [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); // Assume this is an unsupported field type [EOL] try { [EOL] partial.withField(fieldType, 1); [EOL] fail("Expected exception when setting unsupported field type"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithFieldAdded_ZeroAmount() { [EOL] Partial partial = createPartial(); // You need to implement createPartial to create an instance of Partial [EOL] DurationFieldType fieldType = DurationFieldType.minutes(); // Use the correct method to obtain a DurationFieldType [EOL] Partial result = partial.withFieldAdded(fieldType, 0); [EOL] assertEquals(partial, result); [EOL] }
public void testWithFieldAdded_NonZeroAmount() { [EOL] Partial partial = createPartial(); // You need to implement createPartial to create an instance of Partial [EOL] DurationFieldType fieldType = DurationFieldType.minutes(); // Use the correct method to obtain a DurationFieldType [EOL] int amountToAdd = 5; [EOL] Partial result = partial.withFieldAdded(fieldType, amountToAdd); [EOL] assertNotEquals(partial, result); // Assuming that the Partial object is immutable and a new object is returned [EOL] }
public void testWithFieldAddWrapped_ZeroAmount() { [EOL] Partial partial = createPartial(); // You need to implement createPartial to create an instance of Partial [EOL] DurationFieldType fieldType = DurationFieldType.minutes(); // Use the correct method to obtain a DurationFieldType [EOL] Partial result = partial.withFieldAddWrapped(fieldType, 0); [EOL] assertEquals(partial, result); [EOL] }
public void testWithFieldAddWrapped_NonZeroAmount() { [EOL] Partial partial = createPartial(); // You need to implement createPartial to create an instance of Partial [EOL] DurationFieldType fieldType = DurationFieldType.minutes(); // Use the correct method to obtain a DurationFieldType [EOL] int amount = 5; [EOL] Partial result = partial.withFieldAddWrapped(fieldType, amount); [EOL] assertNotEquals(partial, result); // Assuming that the result should not be equal to the original partial [EOL] }
public void testPropertyWithSupportedType() { [EOL] DateTimeFieldType type = DateTimeFieldType.dayOfMonth(); [EOL] DateTime dateTime = new DateTime(); [EOL] Property property = dateTime.property(type); [EOL] assertNotNull(property); [EOL] assertEquals(type, property.getFieldType()); [EOL] }
public void testPropertyWithUnsupportedType() { [EOL] DateTimeFieldType type = UnsupportedDateTimeFieldType.unsupported(); [EOL] DateTime dateTime = new DateTime(); [EOL] try { [EOL] dateTime.property(type); [EOL] fail("Should have thrown an exception for unsupported type"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testPropertyConstructorWithValidPartialAndFieldIndex() { [EOL] Partial partial = new Partial(); [EOL] int fieldIndex = 0; [EOL] Property property = new Property(partial, fieldIndex); [EOL] assertNotNull(property); [EOL] assertSame(partial, property.iPartial); [EOL] assertEquals(fieldIndex, property.iFieldIndex); [EOL] }
public void testPropertyConstructorWithNullPartial() { [EOL] int fieldIndex = 0; [EOL] try { [EOL] new Property(null, fieldIndex); [EOL] fail("Should have thrown IllegalArgumentException for null Partial"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetField_ValidIndex() { [EOL] Partial partial = new Partial(); [EOL] int fieldIndex = 0; // Assuming fieldIndex is within the valid range of fields in Partial [EOL] DateTimeField field = partial.getField(fieldIndex); [EOL] assertNotNull(field); [EOL] }
public void testGetField_InvalidIndex() { [EOL] Partial partial = new Partial(); [EOL] int fieldIndex = -1; // Assuming fieldIndex is out of the valid range [EOL] try { [EOL] partial.getField(fieldIndex); [EOL] fail("Should have thrown an exception for invalid index"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testGetReadablePartial() { [EOL] ReadablePartial expected = instance.iPartial; [EOL] ReadablePartial actual = instance.getReadablePartial(); [EOL] assertSame("The getReadablePartial method should return the expected iPartial object.", expected, actual); [EOL] }
public void testSetCopy_ValidValue() { [EOL] Partial partial = new Partial(); // Assuming constructor and other necessary setup [EOL] int value = 10; // Assuming a valid value for the field [EOL] Partial result = partial.setCopy(value); [EOL] int[] expectedValues = new int[]{value}; // Assuming expected values after set [EOL] assertArrayEquals(expectedValues, result.getValues()); [EOL] }
public void testSetCopy_InvalidValue() { [EOL] Partial partial = new Partial(); // Assuming constructor and other necessary setup [EOL] int value = -1; // Assuming an invalid value for the field [EOL] try { [EOL] partial.setCopy(value); [EOL] fail("Should have thrown an exception for invalid value"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetCopyWithValidTextAndLocale() { [EOL] Partial partial = new Partial(); [EOL] Locale locale = Locale.ENGLISH; [EOL] String validText = "validText"; [EOL] Partial result = partial.setCopy(validText, locale); [EOL] assertNotNull(result); [EOL] assertNotSame(partial, result); [EOL] }
public void testSetCopyWithNullText() { [EOL] Partial partial = new Partial(); [EOL] Locale locale = Locale.ENGLISH; [EOL] String nullText = null; [EOL] try { [EOL] partial.setCopy(nullText, locale); [EOL] fail("Should have thrown IllegalArgumentException for null text"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetCopyWithNullLocale() { [EOL] Partial partial = new Partial(); [EOL] String validText = "validText"; [EOL] Locale nullLocale = null; [EOL] Partial result = partial.setCopy(validText, nullLocale); [EOL] assertNotNull(result); [EOL] assertNotSame(partial, result); [EOL] }
public void testSetCopyWithValidText() { [EOL] Partial partial = new Partial(); [EOL] String text = "ValidText"; [EOL] Partial result = partial.setCopy(text); [EOL] assertNotNull(result); [EOL] }
public void testSetCopyWithNullText() { [EOL] Partial partial = new Partial(); [EOL] String text = null; [EOL] Partial result = partial.setCopy(text); [EOL] assertNotNull(result); [EOL] }
public void testWithMinimumValue() { [EOL] Partial partial = new Partial(); [EOL] Partial result = partial.withMinimumValue(); [EOL] assertEquals(result.get(), partial.getMinimumValue()); [EOL] }
public void testToPeriodWithNullType() { [EOL] DateTime dateTime = new DateTime(); [EOL] Period result = dateTime.toPeriod(null); [EOL] assertNotNull(result); [EOL] assertEquals(new Period(dateTime.getMillis(), (PeriodType) null), result); [EOL] }
public void testToPeriodWithSpecificType() { [EOL] DateTime dateTime = new DateTime(); [EOL] PeriodType type = PeriodType.yearMonthDayTime(); [EOL] Period result = dateTime.toPeriod(type); [EOL] assertNotNull(result); [EOL] assertEquals(new Period(dateTime.getMillis(), type), result); [EOL] }
public void testToPeriodToWithDifferentEndInstantAndType() { [EOL] DateTime start = new DateTime(2020, 1, 1, 0, 0, 0); [EOL] DateTime end = new DateTime(2021, 1, 1, 0, 0, 0); [EOL] PeriodType type = PeriodType.yearMonthDayTime(); [EOL] Period result = start.toPeriodTo(end, type); [EOL] assertNotNull(result); [EOL] assertEquals(1, result.getYears()); [EOL] assertEquals(0, result.getMonths()); [EOL] assertEquals(0, result.getDays()); [EOL] assertEquals(0, result.getHours()); [EOL] }
public void testToPeriodToWithNullEndInstant() { [EOL] DateTime start = new DateTime(2020, 1, 1, 0, 0, 0); [EOL] PeriodType type = PeriodType.yearMonthDayTime(); [EOL] try { [EOL] start.toPeriodTo(null, type); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testToPeriodToWithNullType() { [EOL] DateTime start = new DateTime(2020, 1, 1, 0, 0, 0); [EOL] DateTime end = new DateTime(2021, 1, 1, 0, 0, 0); [EOL] Period result = start.toPeriodTo(end, null); [EOL] assertNotNull(result); [EOL] }
public void testParseYearsWithNullInput() { [EOL] Years result = Time.parseYears(null); [EOL] assertEquals(Years.ZERO, result); [EOL] }
public void testParseYearsWithValidInput() { [EOL] Years expected = Years.years(5); [EOL] Years result = Time.parseYears("P5Y"); [EOL] assertEquals(expected, result); [EOL] }
public void testParseYearsWithInvalidInput() { [EOL] try { [EOL] Time.parseYears("InvalidInput"); [EOL] fail("Should have thrown an exception for invalid input"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testMinusWithNull() { [EOL] Years years = Years.years(5); [EOL] Years result = years.minus(null); [EOL] assertEquals(years, result); [EOL] }
public void testMinusWithNonNullYears() { [EOL] Years years = Years.years(5); [EOL] Years otherYears = Years.years(3); [EOL] Years result = years.minus(otherYears); [EOL] assertEquals(Years.years(2), result); [EOL] }
public void testParseWithValidString() { [EOL] String validDateTimeString = "2023-04-01T10:15:30Z"; [EOL] Instant expected = Instant.parse(validDateTimeString); [EOL] Instant actual = Time.parse(validDateTimeString); [EOL] assertEquals(expected, actual); [EOL] }
public void testParseWithInvalidString() { [EOL] String invalidDateTimeString = "invalid-date-time"; [EOL] try { [EOL] Time.parse(invalidDateTimeString); [EOL] fail("Should have thrown DateTimeParseException"); [EOL] } catch (DateTimeParseException e) { [EOL] } [EOL] }
public void testParseWithValidInput() { [EOL] String str = "2023-04-01T10:15:30Z"; [EOL] DateTimeFormatter formatter = DateTimeFormatter.ISO_INSTANT; [EOL] Instant expected = Instant.parse(str); [EOL] Instant actual = parse(str, formatter); [EOL] assertEquals(expected, actual); [EOL] }
public void testParseWithInvalidInput() { [EOL] String str = "invalid-date-time"; [EOL] DateTimeFormatter formatter = DateTimeFormatter.ISO_INSTANT; [EOL] try { [EOL] parse(str, formatter); [EOL] fail("Should have thrown DateTimeParseException"); [EOL] } catch (DateTimeParseException e) { [EOL] } [EOL] }
public void testLocalDateWithValidDate() { [EOL] LocalDate date = new LocalDate(2021, 3, 15); [EOL] assertEquals(2021, date.getYear()); [EOL] assertEquals(3, date.getMonthOfYear()); [EOL] assertEquals(15, date.getDayOfMonth()); [EOL] }
public void testLocalDateWithInvalidMonth() { [EOL] try { [EOL] new LocalDate(2021, 13, 15); [EOL] fail("Should have thrown an exception for invalid month"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testLocalDateWithInvalidDay() { [EOL] try { [EOL] new LocalDate(2021, 3, 32); [EOL] fail("Should have thrown an exception for invalid day"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testLocalDateWithInvalidYear() { [EOL] try { [EOL] new LocalDate(-1, 3, 15); [EOL] fail("Should have thrown an exception for invalid year"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetFieldYear() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] DateTimeField field = getField(YEAR, chrono); [EOL] assertNotNull(field); [EOL] assertEquals(chrono.year(), field); [EOL] }
public void testGetFieldMonthOfYear() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] DateTimeField field = getField(MONTH_OF_YEAR, chrono); [EOL] assertNotNull(field); [EOL] assertEquals(chrono.monthOfYear(), field); [EOL] }
public void testGetFieldDayOfMonth() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] DateTimeField field = getField(DAY_OF_MONTH, chrono); [EOL] assertNotNull(field); [EOL] assertEquals(chrono.dayOfMonth(), field); [EOL] }
public void testGetFieldInvalidIndex() { [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] try { [EOL] getField(-1, chrono); [EOL] fail("Should have thrown IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException ex) { [EOL] } [EOL] }
public void testIsSupportedWithNullType() { [EOL] boolean result = instance.isSupported(null); [EOL] assertFalse(result); [EOL] }
public void testIsSupportedWithUnsupportedType() { [EOL] DateTimeFieldType type = mock(DateTimeFieldType.class); [EOL] when(type.getDurationType()).thenReturn(DurationFieldType.seconds()); [EOL] when(type.getField(getChronology()).getUnitMillis()).thenReturn(1000L); [EOL] when(getChronology().days().getUnitMillis()).thenReturn(86400000L); [EOL] when(type.getField(getChronology()).isSupported()).thenReturn(false); [EOL] boolean result = instance.isSupported(type); [EOL] assertFalse(result); [EOL] }
public void testIsSupportedWithSupportedTypeByDuration() { [EOL] DateTimeFieldType type = mock(DateTimeFieldType.class); [EOL] DurationFieldType durType = DurationFieldType.days(); [EOL] when(type.getDurationType()).thenReturn(durType); [EOL] when(DATE_DURATION_TYPES.contains(durType)).thenReturn(true); [EOL] when(type.getField(getChronology()).isSupported()).thenReturn(true); [EOL] boolean result = instance.isSupported(type); [EOL] assertTrue(result); [EOL] }
public void testIsSupportedWithSupportedTypeByUnitMillis() { [EOL] DateTimeFieldType type = mock(DateTimeFieldType.class); [EOL] when(type.getDurationType()).thenReturn(DurationFieldType.hours()); [EOL] when(type.getField(getChronology()).getUnitMillis()).thenReturn(3600000L); [EOL] when(getChronology().days().getUnitMillis()).thenReturn(86400000L); [EOL] when(type.getField(getChronology()).isSupported()).thenReturn(true); [EOL] boolean result = instance.isSupported(type); [EOL] assertTrue(result); [EOL] }
public void testToDateMidnight_WithNullZone() { [EOL] DateTime dateTime = new DateTime(); // Assuming this is the class where toDateMidnight is defined [EOL] DateMidnight result = dateTime.toDateMidnight(null); [EOL] assertNotNull(result); [EOL] assertEquals(dateTime.getYear(), result.getYear()); [EOL] assertEquals(dateTime.getMonthOfYear(), result.getMonthOfYear()); [EOL] assertEquals(dateTime.getDayOfMonth(), result.getDayOfMonth()); [EOL] assertEquals(dateTime.getChronology().withZone(DateTimeZone.UTC), result.getChronology()); [EOL] }
public void testToDateMidnight_WithSpecificZone() { [EOL] DateTimeZone specificZone = DateTimeZone.forID("Europe/Paris"); [EOL] DateTime dateTime = new DateTime(); // Assuming this is the class where toDateMidnight is defined [EOL] DateMidnight result = dateTime.toDateMidnight(specificZone); [EOL] assertNotNull(result); [EOL] assertEquals(dateTime.getYear(), result.getYear()); [EOL] assertEquals(dateTime.getMonthOfYear(), result.getMonthOfYear()); [EOL] assertEquals(dateTime.getDayOfMonth(), result.getDayOfMonth()); [EOL] assertEquals(dateTime.getChronology().withZone(specificZone), result.getChronology()); [EOL] }
public void testToDateTimeWithNullTimeAndMatchingChronology() { [EOL] LocalTime time = null; [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] DateTime dateTime = new DateTime(0L, DateTimeZone.UTC); [EOL] DateTime result = dateTime.toDateTime(time, zone); [EOL] assertNotNull(result); [EOL] assertEquals(DateTimeZone.UTC, result.getZone()); [EOL] }
public void testToDateTimeWithNonNullTimeAndMatchingChronology() { [EOL] LocalTime time = new LocalTime(0L, DateTimeZone.UTC); [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] DateTime dateTime = new DateTime(0L, DateTimeZone.UTC); [EOL] DateTime result = dateTime.toDateTime(time, zone); [EOL] assertNotNull(result); [EOL] assertEquals(DateTimeZone.UTC, result.getZone()); [EOL] assertEquals(time.getMillisOfDay(), result.getMillisOfDay()); [EOL] }
public void testToDateTimeWithNonNullTimeAndMismatchingChronology() { [EOL] LocalTime time = new LocalTime(0L, DateTimeZone.forID("Europe/Paris")); [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] DateTime dateTime = new DateTime(0L, DateTimeZone.UTC); [EOL] try { [EOL] dateTime.toDateTime(time, zone); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithField_NullField() { [EOL] LocalDate testDate = new LocalDate(); [EOL] try { [EOL] testDate.withField(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithField_UnsupportedField() { [EOL] LocalDate testDate = new LocalDate(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); // Assuming this is unsupported for LocalDate [EOL] try { [EOL] testDate.withField(fieldType, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testWithField_SupportedField() { [EOL] LocalDate testDate = new LocalDate(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); // Assuming this is supported for LocalDate [EOL] int newValue = 15; [EOL] LocalDate updatedDate = testDate.withField(fieldType, newValue); [EOL] assertEquals("Field should be updated with new value", newValue, updatedDate.get(fieldType)); [EOL] }
public void testPlusYears_ZeroYears() { [EOL] LocalDate date = LocalDate.now(); [EOL] LocalDate result = date.plusYears(0); [EOL] assertEquals(date, result); [EOL] }
public void testPlusYears_PositiveYears() { [EOL] LocalDate date = LocalDate.now(); [EOL] LocalDate result = date.plusYears(5); [EOL] assertNotEquals(date, result); [EOL] assertEquals(date.getYear() + 5, result.getYear()); [EOL] }
public void testPlusYears_NegativeYears() { [EOL] LocalDate date = LocalDate.now(); [EOL] LocalDate result = date.plusYears(-5); [EOL] assertNotEquals(date, result); [EOL] assertEquals(date.getYear() - 5, result.getYear()); [EOL] }
public void testMinusWeeks_ZeroWeeks() { [EOL] LocalDate date = LocalDate.now(); [EOL] LocalDate result = date.minusWeeks(0); [EOL] assertEquals(date, result); [EOL] }
public void testMinusWeeks_PositiveWeeks() { [EOL] LocalDate date = LocalDate.now(); [EOL] LocalDate result = date.minusWeeks(3); [EOL] LocalDate expected = date.minus(Period.weeks(3)); [EOL] assertEquals(expected, result); [EOL] }
public void testMinusWeeks_NegativeWeeks() { [EOL] LocalDate date = LocalDate.now(); [EOL] LocalDate result = date.minusWeeks(-2); [EOL] LocalDate expected = date.plus(Period.weeks(2)); [EOL] assertEquals(expected, result); [EOL] }
public void testPropertyWithNullFieldType() { [EOL] try { [EOL] DateTime testDateTime = new DateTime(); [EOL] testDateTime.property(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The DateTimeFieldType must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testPropertyWithUnsupportedFieldType() { [EOL] try { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.centuryOfEra(); [EOL] if (!testDateTime.isSupported(fieldType)) { [EOL] testDateTime.property(fieldType); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } [EOL] } catch (IllegalArgumentException ex) { [EOL] assertTrue(ex.getMessage().contains("Field '")); [EOL] assertTrue(ex.getMessage().contains("' is not supported")); [EOL] } [EOL] }
public void testPropertyWithSupportedFieldType() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.year(); [EOL] if (testDateTime.isSupported(fieldType)) { [EOL] Property property = testDateTime.property(fieldType); [EOL] assertNotNull(property); [EOL] } [EOL] }
public void testEraProperty() { [EOL] DateTime dateTime = new DateTime(); [EOL] Property eraProperty = dateTime.era(); [EOL] assertNotNull("Era property should not be null", eraProperty); [EOL] assertEquals("Era property should be the same as chronology era", dateTime.getChronology().era(), eraProperty.getField()); [EOL] }
public void testCenturyOfEra() { [EOL] DateTime dateTime = new DateTime(); [EOL] Property centuryOfEraProperty = dateTime.centuryOfEra(); [EOL] assertNotNull(centuryOfEraProperty); [EOL] assertEquals(centuryOfEraProperty.getField(), dateTime.getChronology().centuryOfEra()); [EOL] }
public void testYearOfCentury() { [EOL] Time time = new Time(); // Assuming Time is the class where yearOfCentury() is defined [EOL] Property result = time.yearOfCentury(); [EOL] assertNotNull(result); [EOL] assertEquals(result.getField(), time.getChronology().yearOfCentury()); [EOL] }
public void testYearOfEra() { [EOL] Time time = new Time(); // Assuming Time is the class where yearOfEra method exists [EOL] Property result = time.yearOfEra(); [EOL] assertNotNull(result); [EOL] assertEquals(time.getChronology().yearOfEra(), result.getField()); [EOL] }
public void testWeekyearProperty() { [EOL] Time time = new Time(); // Assuming Time is the class where the weekyear method exists [EOL] Property property = time.weekyear(); [EOL] assertNotNull(property); [EOL] assertEquals(time.getChronology().weekyear(), property.getField()); [EOL] }
public void testWeekOfWeekyear() { [EOL] Time time = new Time(); [EOL] Property property = time.weekOfWeekyear(); [EOL] assertNotNull(property); [EOL] assertEquals(time.getChronology().weekOfWeekyear(), property.getField()); [EOL] }
public void testDayOfYear() { [EOL] DateTime dateTime = new DateTime(); [EOL] Property property = dateTime.dayOfYear(); [EOL] assertNotNull(property); [EOL] assertEquals(dateTime.getChronology().dayOfYear(), property.getField()); [EOL] assertEquals(dateTime.get(DateTimeFieldType.dayOfYear()), property.get()); [EOL] }
public void testDayOfWeek() { [EOL] DateTime dateTime = new DateTime(); [EOL] Property property = dateTime.dayOfWeek(); [EOL] assertNotNull(property); [EOL] assertEquals(dateTime.getChronology().dayOfWeek(), property.getField()); [EOL] assertEquals(dateTime, property.getReadableInstant()); [EOL] }
public void testToString() { [EOL] Time time = new Time(2023, 4, 1); [EOL] String expected = ISODateTimeFormat.date().print(time); [EOL] String actual = time.toString(); [EOL] assertEquals(expected, actual); [EOL] }
protected Chronology getChronology() { [EOL] return iInstant.getChronology(); [EOL] }
public LocalDate getLocalDate() { [EOL] return iInstant; [EOL] }
public void testAddToCopy_Zero() { [EOL] LocalDate initialDate = new LocalDate(); [EOL] LocalDate resultDate = initialDate.addToCopy(0); [EOL] assertEquals(initialDate, resultDate); [EOL] }
public void testAddToCopy_Positive() { [EOL] LocalDate initialDate = new LocalDate(); [EOL] LocalDate resultDate = initialDate.addToCopy(5); [EOL] assertFalse(initialDate.equals(resultDate)); [EOL] }
public void testAddToCopy_Negative() { [EOL] LocalDate initialDate = new LocalDate(); [EOL] LocalDate resultDate = initialDate.addToCopy(-5); [EOL] assertFalse(initialDate.equals(resultDate)); [EOL] }
public void testWordBasedWithExistingLocale() { [EOL] Locale existingLocale = Locale.ENGLISH; // Assuming English locale is already in the FORMATTERS map [EOL] PeriodFormatter result = Time.wordBased(existingLocale); [EOL] assertNotNull(result); [EOL] }
public void testWordBasedWithNewLocale() { [EOL] Locale newLocale = new Locale("fr", "CA"); // Assuming French Canadian locale is not in the FORMATTERS map [EOL] PeriodFormatter result = Time.wordBased(newLocale); [EOL] assertNotNull(result); [EOL] }
public void testGetInstance_NullZone() { [EOL] EthiopicChronology chrono = EthiopicChronology.getInstance(null, 4); [EOL] assertNotNull(chrono); [EOL] assertEquals(DateTimeZone.getDefault(), chrono.getZone()); [EOL] }
public void testGetInstance_MinDaysInFirstWeekTooLow() { [EOL] try { [EOL] EthiopicChronology.getInstance(DateTimeZone.getDefault(), 0); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetInstance_MinDaysInFirstWeekTooHigh() { [EOL] try { [EOL] EthiopicChronology.getInstance(DateTimeZone.getDefault(), 8); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetInstance_CacheHit() { [EOL] DateTimeZone zone = DateTimeZone.getDefault(); [EOL] EthiopicChronology firstInstance = EthiopicChronology.getInstance(zone, 4); [EOL] EthiopicChronology secondInstance = EthiopicChronology.getInstance(zone, 4); [EOL] assertSame(firstInstance, secondInstance); [EOL] }
public void testGetInstance_CacheMiss() { [EOL] DateTimeZone zone = DateTimeZone.getDefault(); [EOL] EthiopicChronology firstInstance = EthiopicChronology.getInstance(zone, 4); [EOL] EthiopicChronology secondInstance = EthiopicChronology.getInstance(zone, 5); [EOL] assertNotSame(firstInstance, secondInstance); [EOL] }
public void testGetInstance_UTCZone() { [EOL] EthiopicChronology chrono = EthiopicChronology.getInstance(DateTimeZone.UTC, 4); [EOL] assertNotNull(chrono); [EOL] assertEquals(DateTimeZone.UTC, chrono.getZone()); [EOL] }
public void testGJEraDateTimeFieldWithNullChronology() { [EOL] try { [EOL] new GJEraDateTimeField(null); [EOL] fail("Should have thrown IllegalArgumentException for null chronology"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGJEraDateTimeFieldWithNonNullChronology() { [EOL] BasicChronology chronology = Mockito.mock(BasicChronology.class); [EOL] GJEraDateTimeField field = new GJEraDateTimeField(chronology); [EOL] assertNotNull("GJEraDateTimeField should not be null", field); [EOL] assertEquals("Chronology should match", chronology, field.getChronology()); [EOL] }
public long set_instantWithValidEraTextAndLocale(long instant, String text, Locale locale) { [EOL] long expected = SOME_EXPECTED_VALUE; // Replace with the actual expected value [EOL] long actual = set(instant, text, locale); [EOL] assertEquals(expected, actual); [EOL] }
public long set_instantWithInvalidEraText(long instant, String text, Locale locale) { [EOL] try { [EOL] set(instant, text, locale); [EOL] fail("Should have thrown IllegalArgumentException for invalid era text"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public long set_instantWithNullLocale(long instant, String text) { [EOL] try { [EOL] set(instant, text, null); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testYearMonthDay_InitialCall() { [EOL] PeriodType result = Time.yearMonthDay(); [EOL] assertNotNull(result); [EOL] assertEquals("YearMonthDay", result.getName()); [EOL] assertTrue(result.isSupported(DurationFieldType.years())); [EOL] assertTrue(result.isSupported(DurationFieldType.months())); [EOL] assertFalse(result.isSupported(DurationFieldType.weeks())); [EOL] assertTrue(result.isSupported(DurationFieldType.days())); [EOL] assertFalse(result.isSupported(DurationFieldType.hours())); [EOL] }
public void testYearMonthDay_SubsequentCall() { [EOL] PeriodType initialResult = Time.yearMonthDay(); [EOL] assertNotNull(initialResult); [EOL] PeriodType subsequentResult = Time.yearMonthDay(); [EOL] assertSame(initialResult, subsequentResult); [EOL] }
public void testYearWeekDayTime_InitialCreation() { [EOL] PeriodType actual = Time.yearWeekDayTime(); [EOL] assertNotNull(actual); [EOL] assertEquals("YearWeekDayTime", actual.getName()); [EOL] assertTrue(actual.isSupported(DurationFieldType.years())); [EOL] assertFalse(actual.isSupported(DurationFieldType.months())); [EOL] assertTrue(actual.isSupported(DurationFieldType.weeks())); [EOL] assertTrue(actual.isSupported(DurationFieldType.days())); [EOL] assertTrue(actual.isSupported(DurationFieldType.hours())); [EOL] assertTrue(actual.isSupported(DurationFieldType.minutes())); [EOL] assertTrue(actual.isSupported(DurationFieldType.seconds())); [EOL] assertTrue(actual.isSupported(DurationFieldType.millis())); [EOL] }
public void testYearWeekDayTime_SubsequentRetrieval() { [EOL] PeriodType firstRetrieval = Time.yearWeekDayTime(); [EOL] PeriodType secondRetrieval = Time.yearWeekDayTime(); [EOL] assertSame(firstRetrieval, secondRetrieval); [EOL] }
public void testYearWeekDay_WhenTypeIsNull() { [EOL] PeriodType actual = Time.yearWeekDay(); [EOL] assertNotNull(actual); [EOL] assertEquals("YearWeekDay", actual.getName()); [EOL] assertTrue(Arrays.asList(actual.getFieldTypes()).contains(DurationFieldType.years())); [EOL] assertTrue(Arrays.asList(actual.getFieldTypes()).contains(DurationFieldType.weeks())); [EOL] assertTrue(Arrays.asList(actual.getFieldTypes()).contains(DurationFieldType.days())); [EOL] } [EOL] public void testYearWeekDay_WhenTypeIsNotNull() { [EOL] PeriodType expected = Time.yearWeekDay(); [EOL] PeriodType actual = Time.yearWeekDay(); [EOL] assertSame(expected, actual); [EOL] }
public void testYearDay_InitialCall() { [EOL] PeriodType result = YourClass.yearDay(); [EOL] assertNotNull(result); [EOL] assertEquals("YearDay", result.getName()); [EOL] assertTrue(result.isSupported(DurationFieldType.years())); [EOL] assertFalse(result.isSupported(DurationFieldType.months())); [EOL] assertTrue(result.isSupported(DurationFieldType.days())); [EOL] assertFalse(result.isSupported(DurationFieldType.hours())); [EOL] }
public void testYearDay_SubsequentCall() { [EOL] YourClass.yearDay(); [EOL] PeriodType result = YourClass.yearDay(); [EOL] assertNotNull(result); [EOL] assertSame("Subsequent calls should return the same PeriodType instance", YourClass.yearDay(), result); [EOL] }
public void testYearsSingleton() { [EOL] PeriodType type1 = PeriodType.years(); [EOL] assertNotNull("The 'years' period type should not be null", type1); [EOL] PeriodType type2 = PeriodType.years(); [EOL] assertSame("The 'years' period type should be a singleton", type1, type2); [EOL] }
public void testMonths_InitiallyNull() { [EOL] PeriodType type = PeriodType.months(); [EOL] assertNotNull(type); [EOL] assertEquals("Months", type.getName()); [EOL] assertTrue(type.isSupported(DurationFieldType.months())); [EOL] assertFalse(type.isSupported(DurationFieldType.years())); [EOL] }
public void testMonths_AlreadyInstantiated() { [EOL] PeriodType type = PeriodType.months(); [EOL] PeriodType secondCallType = PeriodType.months(); [EOL] assertSame(type, secondCallType); [EOL] }
public void testWeeksNotNull() { [EOL] PeriodType type = ClassName.weeks(); [EOL] assertNotNull(type); [EOL] }
public void testWeeksSingleton() { [EOL] PeriodType firstCall = ClassName.weeks(); [EOL] PeriodType secondCall = ClassName.weeks(); [EOL] assertSame(firstCall, secondCall); [EOL] }
public void testSecondsSingleton() { [EOL] PeriodType type1 = PeriodType.seconds(); [EOL] assertNotNull(type1); [EOL] PeriodType type2 = PeriodType.seconds(); [EOL] assertSame(type1, type2); [EOL] }
public void testMillis_initialCall() { [EOL] PeriodType type = PeriodType.millis(); [EOL] assertNotNull(type); [EOL] assertEquals("Millis", type.getName()); [EOL] assertTrue(Arrays.asList(type.getFieldTypes()).contains(DurationFieldType.millis())); [EOL] }
public void testMillis_subsequentCall() { [EOL] PeriodType type1 = PeriodType.millis(); [EOL] PeriodType type2 = PeriodType.millis(); [EOL] assertSame(type1, type2); [EOL] }
public void testForFields_NullOrEmptyTypesArray_ThrowsIllegalArgumentException() { [EOL] try { [EOL] PeriodType.forFields(null); [EOL] fail("Should have thrown IllegalArgumentException for null types array"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Types array must not be null or empty", e.getMessage()); [EOL] } [EOL] try { [EOL] PeriodType.forFields(new DurationFieldType[0]); [EOL] fail("Should have thrown IllegalArgumentException for empty types array"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Types array must not be null or empty", e.getMessage()); [EOL] } [EOL] }
public void testForFields_TypesArrayContainsNull_ThrowsIllegalArgumentException() { [EOL] try { [EOL] PeriodType.forFields(new DurationFieldType[]{null}); [EOL] fail("Should have thrown IllegalArgumentException for types array containing null"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Types array must not contain null", e.getMessage()); [EOL] } [EOL] }
public void testForFields_ValidTypesArray_ReturnsCorrectPeriodType() { [EOL] DurationFieldType[] types = new DurationFieldType[]{ [EOL] DurationFieldType.years(), [EOL] DurationFieldType.months() [EOL] }; [EOL] PeriodType type = PeriodType.forFields(types); [EOL] assertNotNull(type); [EOL] assertTrue(type.isSupported(DurationFieldType.years())); [EOL] assertTrue(type.isSupported(DurationFieldType.months())); [EOL] }
public void testForFields_UnsupportedFields_ThrowsIllegalArgumentException() { [EOL] DurationFieldType[] types = new DurationFieldType[]{ [EOL] DurationFieldType.years(), [EOL] DurationFieldType.months(), [EOL] new DurationFieldType("unsupported") { [EOL] public String getName() { [EOL] return "unsupported"; [EOL] } [EOL] } [EOL] }; [EOL] try { [EOL] PeriodType.forFields(types); [EOL] fail("Should have thrown IllegalArgumentException for unsupported fields"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertTrue(e.getMessage().contains("PeriodType does not support fields")); [EOL] } [EOL] }
public void testSetIndexedField_SupportedIndex() { [EOL] ReadablePeriod period = null; // Assuming period is not used in the method [EOL] int index = 0; // Assuming this is a valid index for the test [EOL] int[] values = new int[1]; // Assuming array size of 1 for simplicity [EOL] int newValue = 10; [EOL] int[] iIndices = {0}; // Assuming this is the iIndices array from the class [EOL] boolean result = setIndexedField(period, index, values, newValue); [EOL] assertEquals("The value should be set correctly", newValue, values[iIndices[index]]); [EOL] assertTrue("The method should return true", result); [EOL] } [EOL] public void testSetIndexedField_UnsupportedIndex() { [EOL] ReadablePeriod period = null; // Assuming period is not used in the method [EOL] int index = 0; // Assuming this is an invalid index for the test [EOL] int[] values = new int[1]; // Assuming array size of 1 for simplicity [EOL] int newValue = 10; [EOL] int[] iIndices = {-1}; // Assuming this is the iIndices array from the class [EOL] try { [EOL] setIndexedField(period, index, values, newValue); [EOL] fail("An UnsupportedOperationException should have been thrown"); [EOL] } catch (UnsupportedOperationException e) { [EOL] assertEquals("Field is not supported", e.getMessage()); [EOL] } [EOL] }
public void testAddIndexedField_ValueToAddIsZero() { [EOL] ReadablePeriod period = null; // Assuming a mock or concrete implementation is available [EOL] int index = 0; [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int valueToAdd = 0; [EOL] boolean result = addIndexedField(period, index, values, valueToAdd); [EOL] assertFalse(result); [EOL] }
public void testAddIndexedField_UnsupportedField() { [EOL] ReadablePeriod period = null; // Assuming a mock or concrete implementation is available [EOL] int index = 0; [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int valueToAdd = 1; [EOL] iIndices = new int[] {-1}; // Assuming iIndices is accessible and mutable [EOL] try { [EOL] addIndexedField(period, index, values, valueToAdd); [EOL] fail("Expected an UnsupportedOperationException to be thrown"); [EOL] } catch (UnsupportedOperationException e) { [EOL] assertEquals("Field is not supported", e.getMessage()); [EOL] } [EOL] }
public void testAddIndexedField_SuccessfulAddition() { [EOL] ReadablePeriod period = null; // Assuming a mock or concrete implementation is available [EOL] int index = 0; [EOL] int[] values = new int[] {1, 2, 3}; [EOL] int valueToAdd = 1; [EOL] iIndices = new int[] {1}; // Assuming iIndices is accessible and mutable [EOL] boolean result = addIndexedField(period, index, values, valueToAdd); [EOL] assertTrue(result); [EOL] assertEquals(3, values[1]); // Assuming that the value at index 1 was 2 before the addition [EOL] }
public void testCurrentTimeMillis() { [EOL] long result = Time.currentTimeMillis(); [EOL] assertNotNull("Result should not be null", result); [EOL] assertTrue("Result should be a positive value", result > 0); [EOL] }
public void testSetCurrentMillisSystem_WithPermission() throws SecurityException { [EOL] System.setSecurityManager(new SecurityManager() { [EOL] @Override [EOL] public void checkPermission(Permission perm) { [EOL] } [EOL] }); [EOL] Time.setCurrentMillisSystem(); [EOL] } [EOL] public void testSetCurrentMillisSystem_WithoutPermission() { [EOL] System.setSecurityManager(new SecurityManager() { [EOL] @Override [EOL] public void checkPermission(Permission perm) { [EOL] throw new SecurityException(); [EOL] } [EOL] }); [EOL] try { [EOL] Time.setCurrentMillisSystem(); [EOL] fail("Expected SecurityException was not thrown"); [EOL] } catch (SecurityException e) { [EOL] } [EOL] }
public void testSetCurrentMillisOffsetWithZeroOffset() { [EOL] try { [EOL] Time.setCurrentMillisOffset(0); [EOL] assertTrue("Expected SYSTEM_MILLIS_PROVIDER", Time.getMillisProvider() instanceof SystemMillisProvider); [EOL] } catch (SecurityException e) { [EOL] fail("Should not throw SecurityException"); [EOL] } [EOL] }
public void testSetCurrentMillisOffsetWithNonZeroOffset() { [EOL] long offset = 100L; [EOL] try { [EOL] Time.setCurrentMillisOffset(offset); [EOL] MillisProvider provider = Time.getMillisProvider(); [EOL] assertTrue("Expected OffsetMillisProvider", provider instanceof OffsetMillisProvider); [EOL] assertEquals("Offset should be 100", offset, ((OffsetMillisProvider) provider).getOffset()); [EOL] } catch (SecurityException e) { [EOL] fail("Should not throw SecurityException"); [EOL] } [EOL] }
public void testSetCurrentMillisOffsetWithSecurityException() { [EOL] System.setSecurityManager(new SecurityManager() { [EOL] @Override [EOL] public void checkPermission(Permission perm) { [EOL] if ("setCurrentMillis".equals(perm.getName())) { [EOL] throw new SecurityException(); [EOL] } [EOL] } [EOL] }); [EOL] try { [EOL] Time.setCurrentMillisOffset(100L); [EOL] fail("Should have thrown SecurityException"); [EOL] } catch (SecurityException e) { [EOL] } finally { [EOL] System.setSecurityManager(null); // Reset SecurityManager [EOL] } [EOL] }
public void testCheckPermissionWithNoSecurityManager() { [EOL] System.setSecurityManager(null); [EOL] try { [EOL] Time.checkPermission(); [EOL] } finally { [EOL] } [EOL] }
public void testCheckPermissionWithSecurityManager() throws SecurityException { [EOL] SecurityManager originalSecurityManager = System.getSecurityManager(); [EOL] try { [EOL] SecurityManager sm = new SecurityManager() { [EOL] @Override [EOL] public void checkPermission(Permission perm) { [EOL] if (perm instanceof JodaTimePermission && "CurrentTime.setProvider".equals(perm.getName())) { [EOL] throw new SecurityException("Permission denied."); [EOL] } [EOL] } [EOL] }; [EOL] System.setSecurityManager(sm); [EOL] Time.checkPermission(); [EOL] } catch (SecurityException e) { [EOL] } finally { [EOL] System.setSecurityManager(originalSecurityManager); [EOL] } [EOL] }
public void testGetIntervalChronology_BothStartAndEndNotNull() { [EOL] ReadableInstant start = new DateTime(2020, 1, 1, 0, 0, ISOChronology.getInstance()); [EOL] ReadableInstant end = new DateTime(2020, 12, 31, 23, 59, ISOChronology.getInstance()); [EOL] Chronology result = getIntervalChronology(start, end); [EOL] assertNotNull(result); [EOL] assertEquals(ISOChronology.getInstance(), result); [EOL] }
public void testGetIntervalChronology_StartNotNullEndNull() { [EOL] ReadableInstant start = new DateTime(2020, 1, 1, 0, 0, ISOChronology.getInstance()); [EOL] ReadableInstant end = null; [EOL] Chronology result = getIntervalChronology(start, end); [EOL] assertNotNull(result); [EOL] assertEquals(ISOChronology.getInstance(), result); [EOL] }
public void testGetIntervalChronology_StartNullEndNotNull() { [EOL] ReadableInstant start = null; [EOL] ReadableInstant end = new DateTime(2020, 12, 31, 23, 59, ISOChronology.getInstance()); [EOL] Chronology result = getIntervalChronology(start, end); [EOL] assertNotNull(result); [EOL] assertEquals(ISOChronology.getInstance(), result); [EOL] }
public void testGetIntervalChronology_BothStartAndEndNull() { [EOL] ReadableInstant start = null; [EOL] ReadableInstant end = null; [EOL] Chronology result = getIntervalChronology(start, end); [EOL] assertNotNull(result); [EOL] assertEquals(ISOChronology.getInstance(), result); [EOL] }
public void testGetReadableIntervalWithNullInput() { [EOL] ReadableInterval result = Time.getReadableInterval(null); [EOL] assertNotNull(result); [EOL] assertEquals(result.getStartMillis(), result.getEndMillis()); [EOL] }
public void testGetReadableIntervalWithNonNullInput() { [EOL] ReadableInterval inputInterval = new Interval(0, 10); [EOL] ReadableInterval result = Time.getReadableInterval(inputInterval); [EOL] assertSame(inputInterval, result); [EOL] }
public void testGetZoneWithNullInput() { [EOL] DateTimeZone result = ClassName.getZone(null); [EOL] assertEquals(DateTimeZone.getDefault(), result); [EOL] }
public void testGetZoneWithNonNullInput() { [EOL] DateTimeZone expectedZone = DateTimeZone.forID("Europe/Paris"); [EOL] DateTimeZone result = ClassName.getZone(expectedZone); [EOL] assertSame(expectedZone, result); [EOL] }
public void testToJulianDayWithEpochMillisZero() { [EOL] long epochMillis = 0L; [EOL] double expected = 2440587.5d; [EOL] double result = Time.toJulianDay(epochMillis); [EOL] assertEquals(expected, result, 0.0); [EOL] } [EOL] public void testToJulianDayWithPositiveEpochMillis() { [EOL] long epochMillis = 86400000L; // 1 day in milliseconds [EOL] double expected = 2440588.5d; [EOL] double result = Time.toJulianDay(epochMillis); [EOL] assertEquals(expected, result, 0.0); [EOL] } [EOL] public void testToJulianDayWithNegativeEpochMillis() { [EOL] long epochMillis = -86400000L; // -1 day in milliseconds [EOL] double expected = 2440586.5d; [EOL] double result = Time.toJulianDay(epochMillis); [EOL] assertEquals(expected, result, 0.0); [EOL] }
public void testToJulianDayNumber_PositiveEpochMillis() { [EOL] long epochMillis = 1588291200000L; // 2020-05-01T00:00:00Z [EOL] long expected = 2458970L; // Julian day number for the above date [EOL] long actual = time.toJulianDayNumber(epochMillis); [EOL] assertEquals(expected, actual); [EOL] }
public void testToJulianDayNumber_NegativeEpochMillis() { [EOL] long epochMillis = -210866803200000L; // 1900-01-01T00:00:00Z [EOL] long expected = 2415021L; // Julian day number for the above date [EOL] long actual = time.toJulianDayNumber(epochMillis); [EOL] assertEquals(expected, actual); [EOL] }
public void testToJulianDayNumber_ZeroEpochMillis() { [EOL] long epochMillis = 0L; // 1970-01-01T00:00:00Z [EOL] long expected = 2440588L; // Julian day number for the above date [EOL] long actual = time.toJulianDayNumber(epochMillis); [EOL] assertEquals(expected, actual); [EOL] }
public void testFromJulianDay_Positive() { [EOL] double julianDay = 2451545.0; // January 1, 2000, 12:00 UTC [EOL] long expected = 946728000000L; // Corresponding milliseconds since epoch [EOL] long actual = Time.fromJulianDay(julianDay); [EOL] assertEquals(expected, actual); [EOL] }
public void testFromJulianDay_Negative() { [EOL] double julianDay = 2430000.5; // A date before epoch [EOL] long expected = -101178000000L; // Corresponding milliseconds before epoch [EOL] long actual = Time.fromJulianDay(julianDay); [EOL] assertEquals(expected, actual); [EOL] }
public void testFromJulianDay_Zero() { [EOL] double julianDay = 2440587.5; // Epoch (January 1, 1970, 00:00 UTC) [EOL] long expected = 0L; // Epoch as milliseconds since itself [EOL] long actual = Time.fromJulianDay(julianDay); [EOL] assertEquals(expected, actual); [EOL] }
public long getMillis() { [EOL] return System.currentTimeMillis(); [EOL] }
public void testOffsetMillisProvider_PositiveOffset() { [EOL] long offsetMillis = 1000; [EOL] OffsetMillisProvider provider = new OffsetMillisProvider(offsetMillis); [EOL] assertEquals(offsetMillis, provider.iMillis); [EOL] }
public void testOffsetMillisProvider_NegativeOffset() { [EOL] long offsetMillis = -1000; [EOL] OffsetMillisProvider provider = new OffsetMillisProvider(offsetMillis); [EOL] assertEquals(offsetMillis, provider.iMillis); [EOL] }
public void testOffsetMillisProvider_ZeroOffset() { [EOL] long offsetMillis = 0; [EOL] OffsetMillisProvider provider = new OffsetMillisProvider(offsetMillis); [EOL] assertEquals(offsetMillis, provider.iMillis); [EOL] }
public void testGetMillis() { [EOL] Time time = new Time(0); [EOL] long millis = time.getMillis(); [EOL] long currentMillis = System.currentTimeMillis(); [EOL] assertTrue(millis >= currentMillis && millis < currentMillis + 100); [EOL] }
public void testGetMillisWithPositiveOffset() { [EOL] Time time = new Time(1000); [EOL] long millis = time.getMillis(); [EOL] long currentMillis = System.currentTimeMillis(); [EOL] assertEquals(currentMillis + 1000, millis); [EOL] }
public void testGetMillisWithNegativeOffset() { [EOL] Time time = new Time(-1000); [EOL] long millis = time.getMillis(); [EOL] long currentMillis = System.currentTimeMillis(); [EOL] assertEquals(currentMillis - 1000, millis); [EOL] }
public void setInto_ReadWritableIntervalWithNonNullChrono() { [EOL] ReadWritableInterval writableInterval = mock(ReadWritableInterval.class); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] Object object = new Object(); [EOL] long expectedNow = DateTimeUtils.currentTimeMillis(); [EOL] new Time().setInto(writableInterval, object, chrono); [EOL] verify(writableInterval).setChronology(chrono); [EOL] verify(writableInterval).setInterval(expectedNow, expectedNow); [EOL] }
public void setInto_ReadWritableIntervalWithNullChrono() { [EOL] ReadWritableInterval writableInterval = mock(ReadWritableInterval.class); [EOL] Object object = new Object(); [EOL] long expectedNow = DateTimeUtils.currentTimeMillis(); [EOL] new Time().setInto(writableInterval, object, null); [EOL] verify(writableInterval).setChronology(null); [EOL] verify(writableInterval).setInterval(expectedNow, expectedNow); [EOL] }
public void testBaseIntervalWithStartInstantAndDuration() { [EOL] Instant start = new Instant(); [EOL] Duration duration = new Duration(12345); [EOL] BaseInterval interval = new BaseInterval(start, duration); [EOL] assertEquals(start.getMillis(), interval.getStartMillis()); [EOL] assertEquals(start.getMillis() + duration.getMillis(), interval.getEndMillis()); [EOL] assertNotNull(interval.getChronology()); [EOL] }
public void testBaseIntervalWithStartInstantAndZeroDuration() { [EOL] Instant start = new Instant(); [EOL] Duration duration = new Duration(0); [EOL] BaseInterval interval = new BaseInterval(start, duration); [EOL] assertEquals(start.getMillis(), interval.getStartMillis()); [EOL] assertEquals(start.getMillis(), interval.getEndMillis()); [EOL] assertNotNull(interval.getChronology()); [EOL] }
public void testBaseIntervalWithStartInstantAndNegativeDuration() { [EOL] Instant start = new Instant(); [EOL] Duration duration = new Duration(-12345); [EOL] BaseInterval interval = new BaseInterval(start, duration); [EOL] assertEquals(start.getMillis(), interval.getStartMillis()); [EOL] assertEquals(start.getMillis() + duration.getMillis(), interval.getEndMillis()); [EOL] assertNotNull(interval.getChronology()); [EOL] }
public void testBaseIntervalWithNullStartInstant() { [EOL] try { [EOL] new BaseInterval(null, new Duration(12345)); [EOL] fail("Should have thrown IllegalArgumentException for null start instant"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testBaseIntervalWithNullDuration() { [EOL] Instant start = new Instant(); [EOL] try { [EOL] new BaseInterval(start, null); [EOL] fail("Should have thrown IllegalArgumentException for null duration"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testBaseIntervalWithNullPeriodAndNonNullEnd() { [EOL] ReadableInstant end = new Instant(); [EOL] BaseInterval interval = new BaseInterval(null, end); [EOL] assertEquals(end.getMillis(), interval.getEndMillis()); [EOL] assertEquals(end.getMillis(), interval.getStartMillis()); [EOL] }
public void testBaseIntervalWithNonNullPeriodAndNonNullEnd() { [EOL] ReadablePeriod period = new Period(hours(1)); [EOL] ReadableInstant end = new Instant(); [EOL] BaseInterval interval = new BaseInterval(period, end); [EOL] assertEquals(end.getMillis(), interval.getEndMillis()); [EOL] assertNotEquals(end.getMillis(), interval.getStartMillis()); [EOL] }
protected BaseInterval(Object interval, Chronology chrono) { [EOL] super(); [EOL] IntervalConverter converter = ConverterManager.getInstance().getIntervalConverter(interval); [EOL] if (converter.isReadableInterval(interval, chrono)) { [EOL] ReadableInterval input = (ReadableInterval) interval; [EOL] iChronology = (chrono != null ? chrono : input.getChronology()); [EOL] iStartMillis = input.getStartMillis(); [EOL] iEndMillis = input.getEndMillis(); [EOL] } else if (this instanceof ReadWritableInterval) { [EOL] converter.setInto((ReadWritableInterval) this, interval, chrono); [EOL] } else { [EOL] MutableInterval mi = new MutableInterval(); [EOL] converter.setInto(mi, interval, chrono); [EOL] iChronology = mi.getChronology(); [EOL] iStartMillis = mi.getStartMillis(); [EOL] iEndMillis = mi.getEndMillis(); [EOL] } [EOL] checkInterval(iStartMillis, iEndMillis); [EOL] }
public void testSetInterval_NormalChronology() { [EOL] long startInstant = 1000L; [EOL] long endInstant = 2000L; [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] setInterval(startInstant, endInstant, chrono); [EOL] assertEquals("Start instant should be set to 1000", 1000L, iStartMillis); [EOL] assertEquals("End instant should be set to 2000", 2000L, iEndMillis); [EOL] assertNotNull("Chronology should not be null", iChronology); [EOL] }
public void testSetInterval_NullChronology() { [EOL] long startInstant = 1000L; [EOL] long endInstant = 2000L; [EOL] setInterval(startInstant, endInstant, null); [EOL] assertEquals("Start instant should be set to 1000", 1000L, iStartMillis); [EOL] assertEquals("End instant should be set to 2000", 2000L, iEndMillis); [EOL] assertNotNull("Chronology should default to ISOChronology", iChronology); [EOL] }
public void testFixedOffsetZoneWithZeroOffset() { [EOL] DateTimeZone result = Time.fixedOffsetZone("UTC", 0); [EOL] assertEquals(DateTimeZone.UTC, result); [EOL] }
public void testFixedOffsetZoneWithNonZeroOffsetAndCacheMiss() { [EOL] String id = "GMT+1"; [EOL] int offset = 3600000; [EOL] DateTimeZone result = Time.fixedOffsetZone(id, offset); [EOL] assertNotNull(result); [EOL] assertEquals(id, result.getID()); [EOL] assertEquals(offset, result.getOffset(null)); [EOL] }
public void testFixedOffsetZoneWithNonZeroOffsetAndCacheHit() { [EOL] String id = "GMT+1"; [EOL] int offset = 3600000; [EOL] Time.fixedOffsetZone(id, offset); [EOL] DateTimeZone result = Time.fixedOffsetZone(id, offset); [EOL] assertNotNull(result); [EOL] assertEquals(id, result.getID()); [EOL] assertEquals(offset, result.getOffset(null)); [EOL] }
public void testPrintOffsetPositive() { [EOL] int offset = 3600000; // 1 hour in milliseconds [EOL] String result = printOffset(offset); [EOL] assertEquals("+01:00", result); [EOL] }
public void testPrintOffsetNegative() { [EOL] int offset = -3600000; // -1 hour in milliseconds [EOL] String result = printOffset(offset); [EOL] assertEquals("-01:00", result); [EOL] }
public void testPrintOffsetPositiveWithMinutes() { [EOL] int offset = 3660000; // 1 hour and 1 minute in milliseconds [EOL] String result = printOffset(offset); [EOL] assertEquals("+01:01", result); [EOL] }
public void testPrintOffsetNegativeWithMinutes() { [EOL] int offset = -3660000; // -1 hour and -1 minute in milliseconds [EOL] String result = printOffset(offset); [EOL] assertEquals("-01:01", result); [EOL] }
public void testPrintOffsetPositiveWithSeconds() { [EOL] int offset = 3661000; // 1 hour, 1 minute, and 1 second in milliseconds [EOL] String result = printOffset(offset); [EOL] assertEquals("+01:01:01", result); [EOL] }
public void testPrintOffsetNegativeWithSeconds() { [EOL] int offset = -3661000; // -1 hour, -1 minute, and -1 second in milliseconds [EOL] String result = printOffset(offset); [EOL] assertEquals("-01:01:01", result); [EOL] }
public void testPrintOffsetPositiveWithMillis() { [EOL] int offset = 3661001; // 1 hour, 1 minute, 1 second, and 1 millisecond [EOL] String result = printOffset(offset); [EOL] assertEquals("+01:01:01.001", result); [EOL] }
public void testPrintOffsetNegativeWithMillis() { [EOL] int offset = -3661001; // -1 hour, -1 minute, -1 second, and -1 millisecond [EOL] String result = printOffset(offset); [EOL] assertEquals("-01:01:01.001", result); [EOL] }
public void testGetOffsetFromLocal_SameOffsets() { [EOL] long instantLocal = 0L; [EOL] when(getOffset(instantLocal)).thenReturn(0); [EOL] when(getOffset(instantLocal - 0)).thenReturn(0); [EOL] int result = getOffsetFromLocal(instantLocal); [EOL] assertEquals(0, result); [EOL] }
public void testGetOffsetFromLocal_DifferentOffsets_PositiveOffsetChange() { [EOL] long instantLocal = 0L; [EOL] when(getOffset(instantLocal)).thenReturn(-1); [EOL] when(getOffset(instantLocal + 1)).thenReturn(0); [EOL] when(nextTransition(instantLocal + 1)).thenReturn(1L); [EOL] when(nextTransition(instantLocal)).thenReturn(2L); [EOL] int result = getOffsetFromLocal(instantLocal); [EOL] assertEquals(-1, result); [EOL] }
public void testGetOffsetFromLocal_DifferentOffsets_NegativeOffsetChange() { [EOL] long instantLocal = 0L; [EOL] when(getOffset(instantLocal)).thenReturn(1); [EOL] when(getOffset(instantLocal - 1)).thenReturn(0); [EOL] when(previousTransition(instantLocal - 1)).thenReturn(-1L); [EOL] when(getOffset(-1L)).thenReturn(-1); [EOL] int result = getOffsetFromLocal(instantLocal); [EOL] assertEquals(-1, result); [EOL] }
public void testGetOffsetFromLocal_DifferentOffsets_NoTransition() { [EOL] long instantLocal = 0L; [EOL] when(getOffset(instantLocal)).thenReturn(-1); [EOL] when(getOffset(instantLocal + 1)).thenReturn(0); [EOL] when(nextTransition(instantLocal + 1)).thenReturn(1L); [EOL] when(nextTransition(instantLocal)).thenReturn(1L); [EOL] int result = getOffsetFromLocal(instantLocal); [EOL] assertEquals(0, result); [EOL] }
public void testGetOffsetFromLocal_PositiveOffset_NoPreviousTransition() { [EOL] long instantLocal = 0L; [EOL] when(getOffset(instantLocal)).thenReturn(1); [EOL] when(getOffset(instantLocal - 1)).thenReturn(1); [EOL] when(previousTransition(instantLocal - 1)).thenReturn(instantLocal); [EOL] int result = getOffsetFromLocal(instantLocal); [EOL] assertEquals(1, result); [EOL] }
public void testAdjustOffsetWithOffsetBeforeLessThanOrEqualToOffsetAfter() { [EOL] long instant = 1000000L; [EOL] Time time = new Time() { [EOL] public long getOffset(long instant) { [EOL] return instant % 2 == 0 ? 2 : 1; [EOL] } [EOL] public long nextTransition(long instant) { [EOL] return instant + 5; [EOL] } [EOL] }; [EOL] long expected = instant; [EOL] long actual = time.adjustOffset(instant, true); [EOL] assertEquals(expected, actual); [EOL] }
public void testAdjustOffsetWithInstantBeforeOverlapStart() { [EOL] long instant = 1000000L; [EOL] Time time = new Time() { [EOL] public long getOffset(long instant) { [EOL] return instant % 2 == 0 ? 4 : 1; [EOL] } [EOL] public long nextTransition(long instant) { [EOL] return instant + 5; [EOL] } [EOL] }; [EOL] long expected = instant; [EOL] long actual = time.adjustOffset(instant, true); [EOL] assertEquals(expected, actual); [EOL] }
public void testAdjustOffsetWithInstantAfterOverlapStartAndEarlier() { [EOL] long instant = 1000003L; [EOL] Time time = new Time() { [EOL] public long getOffset(long instant) { [EOL] return instant % 2 == 0 ? 4 : 1; [EOL] } [EOL] public long nextTransition(long instant) { [EOL] return instant + 5; [EOL] } [EOL] }; [EOL] long expected = instant - 3; [EOL] long actual = time.adjustOffset(instant, false); [EOL] assertEquals(expected, actual); [EOL] }
public void testAdjustOffsetWithInstantAfterOverlapStartAndLater() { [EOL] long instant = 1000003L; [EOL] Time time = new Time() { [EOL] public long getOffset(long instant) { [EOL] return instant % 2 == 0 ? 4 : 1; [EOL] } [EOL] public long nextTransition(long instant) { [EOL] return instant + 5; [EOL] } [EOL] }; [EOL] long expected = instant + 3; [EOL] long actual = time.adjustOffset(instant, true); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetYearWithNegativeInstant() { [EOL] long instant = -1L; // some negative instant [EOL] int expectedYear = -1970; // expected year for the given instant [EOL] int actualYear = getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetYearWithInstantAtEpoch() { [EOL] long instant = 0L; // instant at epoch [EOL] int expectedYear = 1970; // expected year for the given instant [EOL] int actualYear = getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetYearWithInstantJustBeforeLeapYear() { [EOL] long instant = DateTimeConstants.MILLIS_PER_DAY * (365L * 3 + 1) - 1; // just before a leap year [EOL] int expectedYear = 1973; // expected year for the given instant [EOL] int actualYear = getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetYearWithInstantAtLeapYear() { [EOL] long instant = DateTimeConstants.MILLIS_PER_DAY * (365L * 3 + 1); // instant at a leap year [EOL] int expectedYear = 1974; // expected year for the given instant [EOL] int actualYear = getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetYearWithInstantAfterLeapYear() { [EOL] long instant = DateTimeConstants.MILLIS_PER_DAY * (366L + 365L * 3 + 1) + 1; // instant after a leap year [EOL] int expectedYear = 1975; // expected year for the given instant [EOL] int actualYear = getYear(instant); [EOL] assertEquals(expectedYear, actualYear); [EOL] }
public void testGetDayOfMonth() { [EOL] long millis = System.currentTimeMillis(); [EOL] int year = 2023; [EOL] int expectedDayOfMonth = LocalDate.ofInstant(Instant.ofEpochMilli(millis), ZoneId.systemDefault()).getDayOfMonth(); [EOL] int actualDayOfMonth = getDayOfMonth(millis, year); [EOL] assertEquals(expectedDayOfMonth, actualDayOfMonth); [EOL] }
public void testGetDayOfYear_StartOfYear() { [EOL] long instant = new DateTime(year, 1, 1, 0, 0, DateTimeZone.UTC).getMillis(); [EOL] int year = 2020; [EOL] int expectedDayOfYear = 1; [EOL] int actualDayOfYear = getDayOfYear(instant, year); [EOL] assertEquals(expectedDayOfYear, actualDayOfYear); [EOL] }
public void testGetDayOfYear_EndOfYear() { [EOL] long instant = new DateTime(year, 12, 31, 0, 0, DateTimeZone.UTC).getMillis(); [EOL] int year = 2020; [EOL] int expectedDayOfYear = 366; // 2020 is a leap year [EOL] int actualDayOfYear = getDayOfYear(instant, year); [EOL] assertEquals(expectedDayOfYear, actualDayOfYear); [EOL] }
public void testGetDayOfYear_MiddleOfYear() { [EOL] long instant = new DateTime(year, 6, 15, 0, 0, DateTimeZone.UTC).getMillis(); [EOL] int year = 2020; [EOL] int expectedDayOfYear = 167; // June 15th is the 167th day of 2020 [EOL] int actualDayOfYear = getDayOfYear(instant, year); [EOL] assertEquals(expectedDayOfYear, actualDayOfYear); [EOL] }
public void testGetDayOfWeek_PositiveInstant() { [EOL] long instant = DateTimeConstants.MILLIS_PER_DAY * 4; // Assuming this is a positive instant representing 4 days after 1970-01-01 [EOL] int expectedDayOfWeek = 1 + (int) ((4 + 3) % 7); [EOL] int actualDayOfWeek = getDayOfWeek(instant); [EOL] assertEquals(expectedDayOfWeek, actualDayOfWeek); [EOL] }
public void testGetDayOfWeek_NegativeInstantGreaterThanNegativeFour() { [EOL] long instant = -DateTimeConstants.MILLIS_PER_DAY * 2; // Assuming this is a negative instant representing 2 days before 1970-01-01 [EOL] int expectedDayOfWeek = 1 + (int) ((-2 + 3) % 7); [EOL] int actualDayOfWeek = getDayOfWeek(instant); [EOL] assertEquals(expectedDayOfWeek, actualDayOfWeek); [EOL] }
public void testGetDayOfWeek_NegativeInstantLessThanNegativeThree() { [EOL] long instant = -DateTimeConstants.MILLIS_PER_DAY * 5; // Assuming this is a negative instant representing 5 days before 1970-01-01 [EOL] int expectedDayOfWeek = 7 + (int) ((-5 + 4) % 7); [EOL] int actualDayOfWeek = getDayOfWeek(instant); [EOL] assertEquals(expectedDayOfWeek, actualDayOfWeek); [EOL] }
public void testGetMillisOfDayWithPositiveInstant() { [EOL] long instant = 1000; // Any positive value [EOL] int expected = (int) (instant % DateTimeConstants.MILLIS_PER_DAY); [EOL] int actual = getMillisOfDay(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetMillisOfDayWithNegativeInstant() { [EOL] long instant = -1000; // Any negative value [EOL] int expected = (DateTimeConstants.MILLIS_PER_DAY - 1) + (int) ((instant + 1) % DateTimeConstants.MILLIS_PER_DAY); [EOL] int actual = getMillisOfDay(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testSetWithValidHalfdayText() { [EOL] long millis = 0; [EOL] String text = "AM"; // Assuming "AM" is a valid halfday text [EOL] Locale locale = Locale.US; [EOL] long result = set(millis, text, locale); [EOL] }
public void testSetWithInvalidHalfdayText() { [EOL] long millis = 0; [EOL] String text = "InvalidHalfdayText"; // Assuming this is an invalid halfday text [EOL] Locale locale = Locale.US; [EOL] try { [EOL] set(millis, text, locale); [EOL] fail("Should have thrown an exception for invalid halfday text"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetWithNullLocale() { [EOL] long millis = 0; [EOL] String text = "AM"; // Assuming "AM" is a valid halfday text [EOL] Locale locale = null; [EOL] try { [EOL] set(millis, text, locale); [EOL] fail("Should have thrown an exception for null locale"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type) { [EOL] super(); [EOL] if (start == null || end == null) { [EOL] throw new IllegalArgumentException("ReadablePartial objects must not be null"); [EOL] } [EOL] if (start instanceof BaseLocal && end instanceof BaseLocal && start.getClass() == end.getClass()) { [EOL] type = checkPeriodType(type); [EOL] long startMillis = ((BaseLocal) start).getLocalMillis(); [EOL] long endMillis = ((BaseLocal) end).getLocalMillis(); [EOL] Chronology chrono = start.getChronology(); [EOL] chrono = DateTimeUtils.getChronology(chrono); [EOL] iType = type; [EOL] iValues = chrono.get(this, startMillis, endMillis); [EOL] } else { [EOL] if (start.size() != end.size()) { [EOL] throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL] } [EOL] for (int i = 0, isize = start.size(); i < isize; i++) { [EOL] if (start.getFieldType(i) != end.getFieldType(i)) { [EOL] throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL] } [EOL] } [EOL] if (DateTimeUtils.isContiguous(start) == false) { [EOL] throw new IllegalArgumentException("ReadablePartial objects must be contiguous"); [EOL] } [EOL] iType = checkPeriodType(type); [EOL] Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC(); [EOL] iValues = chrono.get(this, chrono.set(start, 0L), chrono.set(end, 0L)); [EOL] } [EOL] } [EOL] protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); [EOL] protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); [EOL] protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(long duration); [EOL] protected BasePeriod(long duration, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(Object period, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(int[] values, PeriodType type); [EOL] public int getValue(int index); [EOL] public PeriodType getPeriodType(); [EOL] protected PeriodType checkPeriodType(PeriodType type); [EOL] public PeriodType getPeriodType(); [EOL] public int getValue(int index); [EOL] public Duration toDurationFrom(ReadableInstant startInstant); [EOL] public Duration toDurationTo(ReadableInstant endInstant); [EOL] private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); [EOL] protected void setPeriod(ReadablePeriod period); [EOL] private void setPeriodInternal(ReadablePeriod period); [EOL] protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] protected void setField(DurationFieldType field, int value); [EOL] protected void setFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void addField(DurationFieldType field, int value); [EOL] protected void addFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void mergePeriod(ReadablePeriod period); [EOL] protected int[] mergePeriodInto(int[] values, ReadablePeriod period); [EOL] protected void addPeriod(ReadablePeriod period); [EOL] protected int[] addPeriodInto(int[] values, ReadablePeriod period); [EOL] protected void setValue(int index, int value); [EOL] protected void setValues(int[] values); [EOL] long serialVersionUID=Optional[-2110953284060001145L]; [EOL] ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() { [EOL] public int getValue(int index) { [EOL] return 0; [EOL] }; [EOL] public PeriodType getPeriodType() { [EOL] return PeriodType.time(); [EOL] }; [EOL] }];
protected BasePeriod(Object period, PeriodType type, Chronology chrono) { [EOL] super(); [EOL] PeriodConverter converter = ConverterManager.getInstance().getPeriodConverter(period); [EOL] type = (type == null ? converter.getPeriodType(period) : type); [EOL] type = checkPeriodType(type); [EOL] iType = type; [EOL] if (this instanceof ReadWritablePeriod) { [EOL] iValues = new int[size()]; [EOL] chrono = DateTimeUtils.getChronology(chrono); [EOL] converter.setInto((ReadWritablePeriod) this, period, chrono); [EOL] } else { [EOL] iValues = new MutablePeriod(period, type, chrono).getValues(); [EOL] } [EOL] } [EOL] protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); [EOL] protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); [EOL] protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(long duration); [EOL] protected BasePeriod(long duration, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(Object period, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(int[] values, PeriodType type); [EOL] public int getValue(int index); [EOL] public PeriodType getPeriodType(); [EOL] protected PeriodType checkPeriodType(PeriodType type); [EOL] public PeriodType getPeriodType(); [EOL] public int getValue(int index); [EOL] public Duration toDurationFrom(ReadableInstant startInstant); [EOL] public Duration toDurationTo(ReadableInstant endInstant); [EOL] private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); [EOL] protected void setPeriod(ReadablePeriod period); [EOL] private void setPeriodInternal(ReadablePeriod period); [EOL] protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] protected void setField(DurationFieldType field, int value); [EOL] protected void setFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void addField(DurationFieldType field, int value); [EOL] protected void addFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void mergePeriod(ReadablePeriod period); [EOL] protected int[] mergePeriodInto(int[] values, ReadablePeriod period); [EOL] protected void addPeriod(ReadablePeriod period); [EOL] protected int[] addPeriodInto(int[] values, ReadablePeriod period); [EOL] protected void setValue(int index, int value); [EOL] protected void setValues(int[] values); [EOL] long serialVersionUID=Optional[-2110953284060001145L]; [EOL] ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() { [EOL] public int getValue(int index) { [EOL] return 0; [EOL] }; [EOL] public PeriodType getPeriodType() { [EOL] return PeriodType.time(); [EOL] }; [EOL] }]
protected void setPeriod(ReadablePeriod period) { [EOL] if (period == null) { [EOL] setValues(new int[size()]); [EOL] } else { [EOL] setPeriodInternal(period); [EOL] } [EOL] } [EOL] protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); [EOL] protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); [EOL] protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(long duration); [EOL] protected BasePeriod(long duration, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(Object period, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(int[] values, PeriodType type); [EOL] public int getValue(int index); [EOL] public PeriodType getPeriodType(); [EOL] protected PeriodType checkPeriodType(PeriodType type); [EOL] public PeriodType getPeriodType(); [EOL] public int getValue(int index); [EOL] public Duration toDurationFrom(ReadableInstant startInstant); [EOL] public Duration toDurationTo(ReadableInstant endInstant); [EOL] private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); [EOL] protected void setPeriod(ReadablePeriod period); [EOL] private void setPeriodInternal(ReadablePeriod period); [EOL] protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] protected void setField(DurationFieldType field, int value); [EOL] protected void setFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void addField(DurationFieldType field, int value); [EOL] protected void addFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void mergePeriod(ReadablePeriod period); [EOL] protected int[] mergePeriodInto(int[] values, ReadablePeriod period); [EOL] protected void addPeriod(ReadablePeriod period); [EOL] protected int[] addPeriodInto(int[] values, ReadablePeriod period); [EOL] protected void setValue(int index, int value); [EOL] protected void setValues(int[] values); [EOL] long serialVersionUID=Optional[-2110953284060001145L]; [EOL] ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() { [EOL] public int getValue(int index) { [EOL] return 0; [EOL] }; [EOL] public PeriodType getPeriodType() { [EOL] return PeriodType.time(); [EOL] }; [EOL] }]
private void setPeriodInternal(ReadablePeriod period) { [EOL] int[] newValues = new int[size()]; [EOL] for (int i = 0, isize = period.size(); i < isize; i++) { [EOL] DurationFieldType type = period.getFieldType(i); [EOL] int value = period.getValue(i); [EOL] checkAndUpdate(type, newValues, value); [EOL] } [EOL] setValues(newValues); [EOL] } [EOL] protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); [EOL] protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); [EOL] protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(long duration); [EOL] protected BasePeriod(long duration, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(Object period, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(int[] values, PeriodType type); [EOL] public int getValue(int index); [EOL] public PeriodType getPeriodType(); [EOL] protected PeriodType checkPeriodType(PeriodType type); [EOL] public PeriodType getPeriodType(); [EOL] public int getValue(int index); [EOL] public Duration toDurationFrom(ReadableInstant startInstant); [EOL] public Duration toDurationTo(ReadableInstant endInstant); [EOL] private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); [EOL] protected void setPeriod(ReadablePeriod period); [EOL] private void setPeriodInternal(ReadablePeriod period); [EOL] protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] protected void setField(DurationFieldType field, int value); [EOL] protected void setFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void addField(DurationFieldType field, int value); [EOL] protected void addFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void mergePeriod(ReadablePeriod period); [EOL] protected int[] mergePeriodInto(int[] values, ReadablePeriod period); [EOL] protected void addPeriod(ReadablePeriod period); [EOL] protected int[] addPeriodInto(int[] values, ReadablePeriod period); [EOL] protected void setValue(int index, int value); [EOL] protected void setValues(int[] values); [EOL] long serialVersionUID=Optional[-2110953284060001145L]; [EOL] ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() { [EOL] public int getValue(int index) { [EOL] return 0; [EOL] }; [EOL] public PeriodType getPeriodType() { [EOL] return PeriodType.time(); [EOL] }; [EOL] }]
protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis) { [EOL] int[] newValues = setPeriodInternal(years, months, weeks, days, hours, minutes, seconds, millis); [EOL] setValues(newValues); [EOL] } [EOL] protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); [EOL] protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); [EOL] protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); [EOL] protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); [EOL] protected BasePeriod(long duration); [EOL] protected BasePeriod(long duration, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(Object period, PeriodType type, Chronology chrono); [EOL] protected BasePeriod(int[] values, PeriodType type); [EOL] public int getValue(int index); [EOL] public PeriodType getPeriodType(); [EOL] protected PeriodType checkPeriodType(PeriodType type); [EOL] public PeriodType getPeriodType(); [EOL] public int getValue(int index); [EOL] public Duration toDurationFrom(ReadableInstant startInstant); [EOL] public Duration toDurationTo(ReadableInstant endInstant); [EOL] private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); [EOL] protected void setPeriod(ReadablePeriod period); [EOL] private void setPeriodInternal(ReadablePeriod period); [EOL] protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); [EOL] protected void setField(DurationFieldType field, int value); [EOL] protected void setFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void addField(DurationFieldType field, int value); [EOL] protected void addFieldInto(int[] values, DurationFieldType field, int value); [EOL] protected void mergePeriod(ReadablePeriod period); [EOL] protected int[] mergePeriodInto(int[] values, ReadablePeriod period); [EOL] protected void addPeriod(ReadablePeriod period); [EOL] protected int[] addPeriodInto(int[] values, ReadablePeriod period); [EOL] protected void setValue(int index, int value); [EOL] protected void setValues(int[] values); [EOL] long serialVersionUID=Optional[-2110953284060001145L]; [EOL] ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() { [EOL] public int getValue(int index) { [EOL] return 0; [EOL] }; [EOL] public PeriodType getPeriodType() { [EOL] return PeriodType.time(); [EOL] }; [EOL] }]
public void testForFieldsWithNullFields() { [EOL] try { [EOL] DateTimeFormatter.forFields(null, true, true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The fields must not be null or empty", e.getMessage()); [EOL] } [EOL] }
public void testForFieldsWithEmptyFields() { [EOL] try { [EOL] DateTimeFormatter.forFields(Collections.emptyList(), true, true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The fields must not be null or empty", e.getMessage()); [EOL] } [EOL] }
public void testForFieldsWithMonthOfYear() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.monthOfYear()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithDayOfYear() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.dayOfYear()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithWeekOfWeekyear() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekOfWeekyear()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithDayOfMonth() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.dayOfMonth()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithDayOfWeek() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.dayOfWeek()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithYear() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.year()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithWeekyear() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekyear()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithUnsupportedOperationException() { [EOL] Set<DateTimeFieldType> fields = new HashSet<DateTimeFieldType>() { [EOL] @Override [EOL] public boolean retainAll(Collection<?> c) { [EOL] throw new UnsupportedOperationException(); [EOL] } [EOL] }; [EOL] fields.add(DateTimeFieldType.year()); [EOL] DateTimeFormatter formatter = DateTimeFormatter.forFields(fields, true, true); [EOL] assertNotNull(formatter); [EOL] }
public void testForFieldsWithInvalidFields() { [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.hourOfDay()); [EOL] try { [EOL] DateTimeFormatter.forFields(fields, true, true); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("No valid format for fields: " + fields, e.getMessage()); [EOL] } [EOL] }
public void testDateByOrdinalWithYearAndDayOfYear() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.year()); [EOL] fields.add(DateTimeFieldType.dayOfYear()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByOrdinal(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByOrdinalWithYearOnly() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.year()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByOrdinal(bld, fields, extended, strictISO); [EOL] assertTrue(result); [EOL] }
public void testDateByOrdinalWithDayOfYearOnly() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.dayOfYear()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByOrdinal(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByOrdinalWithNeitherYearNorDayOfYear() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Collection<DateTimeFieldType> fields = new HashSet<>(); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByOrdinal(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByWeekWithWeekYearWeekOfWeekYearDayOfWeek() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekyear()); [EOL] fields.add(DateTimeFieldType.weekOfWeekyear()); [EOL] fields.add(DateTimeFieldType.dayOfWeek()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByWeek(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByWeekWithWeekYearWeekOfWeekYear() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekyear()); [EOL] fields.add(DateTimeFieldType.weekOfWeekyear()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByWeek(bld, fields, extended, strictISO); [EOL] assertTrue(result); [EOL] }
public void testDateByWeekWithWeekYearDayOfWeek() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekyear()); [EOL] fields.add(DateTimeFieldType.dayOfWeek()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByWeek(bld, fields, extended, strictISO); [EOL] assertTrue(result); [EOL] }
public void testDateByWeekWithWeekOfWeekYearDayOfWeek() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekOfWeekyear()); [EOL] fields.add(DateTimeFieldType.dayOfWeek()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByWeek(bld, fields, extended, strictISO); [EOL] assertTrue(result); [EOL] }
public void testDateByWeekWithWeekOfWeekYear() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.weekOfWeekyear()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByWeek(bld, fields, extended, strictISO); [EOL] assertTrue(result); [EOL] }
public void testDateByWeekWithDayOfWeek() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] fields.add(DateTimeFieldType.dayOfWeek()); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByWeek(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testDateByWeekWithEmptyFields() { [EOL] DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL] Set<DateTimeFieldType> fields = new HashSet<>(); [EOL] boolean extended = true; [EOL] boolean strictISO = false; [EOL] boolean result = dateByWeek(bld, fields, extended, strictISO); [EOL] assertFalse(result); [EOL] }
public void testLocalDateParser() { [EOL] DateTimeFormatter result = YourClass.localDateParser(); [EOL] assertNotNull(result); [EOL] }
public void testDateElementParser() { [EOL] DateTimeFormatter result = ClassName.dateElementParser(); [EOL] assertNotNull(result); [EOL] assertEquals(Constants.dpe, result); [EOL] }
public void testTTimeNoMillis() { [EOL] DateTimeFormatter formatter = ClassName.tTimeNoMillis(); [EOL] assertNotNull(formatter); [EOL] assertEquals("Expected formatter pattern", Constants.ttx.toPattern(), formatter.toPattern()); [EOL] }
public void testWeekDateTimeNoMillis() { [EOL] DateTimeFormatter formatter = ClassName.weekDateTimeNoMillis(); [EOL] assertNotNull(formatter); [EOL] }
public void testBasicTTimeNoMillis() { [EOL] DateTimeFormatter formatter = ClassName.basicTTimeNoMillis(); [EOL] assertNotNull(formatter); [EOL] }
public void testBasicDateTime() { [EOL] DateTimeFormatter result = ClassName.basicDateTime(); [EOL] assertNotNull(result); [EOL] }
public void testBasicOrdinalDateTime() { [EOL] DateTimeFormatter formatter = Time.basicOrdinalDateTime(); [EOL] assertNotNull(formatter); [EOL] }
public void testBasicOrdinalDateTimeNoMillis() { [EOL] DateTimeFormatter formatter = Time.basicOrdinalDateTimeNoMillis(); [EOL] assertNotNull(formatter); [EOL] }
public void testWeekyearWeek() { [EOL] DateTimeFormatter formatter = Time.weekyearWeek(); [EOL] assertNotNull(formatter); [EOL] assertEquals("ww", formatter.toString()); [EOL] }
public void testDateHourMinuteSecond() { [EOL] DateTimeFormatter formatter = ClassName.dateHourMinuteSecond(); [EOL] assertNotNull(formatter); [EOL] assertEquals("Expected formatter pattern", Constants.dhms.toPattern(), formatter.toPattern()); [EOL] }
public void testToStandardDays_ZeroMinutes() { [EOL] Minutes minutes = Minutes.minutes(0); [EOL] Days days = minutes.toStandardDays(); [EOL] assertEquals(0, days.getDays()); [EOL] }
public void testToStandardDays_LessThanOneDay() { [EOL] Minutes minutes = Minutes.minutes(DateTimeConstants.MINUTES_PER_DAY - 1); [EOL] Days days = minutes.toStandardDays(); [EOL] assertEquals(0, days.getDays()); [EOL] }
public void testToStandardDays_ExactlyOneDay() { [EOL] Minutes minutes = Minutes.minutes(DateTimeConstants.MINUTES_PER_DAY); [EOL] Days days = minutes.toStandardDays(); [EOL] assertEquals(1, days.getDays()); [EOL] }
public void testToStandardDays_MoreThanOneDay() { [EOL] Minutes minutes = Minutes.minutes(DateTimeConstants.MINUTES_PER_DAY + 1); [EOL] Days days = minutes.toStandardDays(); [EOL] assertEquals(1, days.getDays()); [EOL] }
public void testMultipliedBy_Positive() { [EOL] Minutes minutes = Minutes.minutes(2); [EOL] Minutes result = minutes.multipliedBy(3); [EOL] assertEquals(6, result.getMinutes()); [EOL] }
public void testMultipliedBy_Negative() { [EOL] Minutes minutes = Minutes.minutes(2); [EOL] Minutes result = minutes.multipliedBy(-3); [EOL] assertEquals(-6, result.getMinutes()); [EOL] }
public void testMultipliedBy_Zero() { [EOL] Minutes minutes = Minutes.minutes(2); [EOL] Minutes result = minutes.multipliedBy(0); [EOL] assertEquals(0, result.getMinutes()); [EOL] }
public void testMultipliedBy_One() { [EOL] Minutes minutes = Minutes.minutes(2); [EOL] Minutes result = minutes.multipliedBy(1); [EOL] assertEquals(2, result.getMinutes()); [EOL] }
public void testIsGreaterThanWithNullOther() { [EOL] Minutes minutes = new Minutes(10); [EOL] boolean result = minutes.isGreaterThan(null); [EOL] assertTrue(result); [EOL] }
public void testIsGreaterThanWithGreaterValue() { [EOL] Minutes baseMinutes = new Minutes(10); [EOL] Minutes otherMinutes = new Minutes(5); [EOL] boolean result = baseMinutes.isGreaterThan(otherMinutes); [EOL] assertTrue(result); [EOL] }
public void testIsGreaterThanWithLesserValue() { [EOL] Minutes baseMinutes = new Minutes(5); [EOL] Minutes otherMinutes = new Minutes(10); [EOL] boolean result = baseMinutes.isGreaterThan(otherMinutes); [EOL] assertFalse(result); [EOL] }
public void testIsGreaterThanWithEqualValue() { [EOL] Minutes baseMinutes = new Minutes(10); [EOL] Minutes otherMinutes = new Minutes(10); [EOL] boolean result = baseMinutes.isGreaterThan(otherMinutes); [EOL] assertFalse(result); [EOL] }
public void testGetInstanceUTC() { [EOL] GregorianChronology instance = GregorianChronology.getInstanceUTC(); [EOL] assertNotNull(instance); [EOL] assertTrue(instance == GregorianChronology.getInstanceUTC()); // Check that the same instance is returned [EOL] }
public void testGetInstanceWithNullZone() { [EOL] GregorianChronology chronology = GregorianChronology.getInstance(null); [EOL] assertNotNull(chronology); [EOL] assertEquals("UTC", chronology.getZone().getID()); [EOL] }
public void testGetInstanceWithNonNullZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] GregorianChronology chronology = GregorianChronology.getInstance(zone); [EOL] assertNotNull(chronology); [EOL] assertEquals("Europe/Paris", chronology.getZone().getID()); [EOL] }
public void testBaseDateTimeWithNullInstantAndNullChronology() { [EOL] BaseDateTime baseDateTime = new BaseDateTime((Object) null, (Chronology) null); [EOL] assertNotNull(baseDateTime); [EOL] assertEquals(ISOChronology.getInstance(), baseDateTime.getChronology()); [EOL] assertEquals(System.currentTimeMillis(), baseDateTime.getMillis(), 1000); [EOL] }
public void testBaseDateTimeWithNonNullInstantAndNullChronology() { [EOL] Long instant = System.currentTimeMillis(); [EOL] BaseDateTime baseDateTime = new BaseDateTime(instant, (Chronology) null); [EOL] assertNotNull(baseDateTime); [EOL] assertEquals(ISOChronology.getInstance(), baseDateTime.getChronology()); [EOL] assertEquals(instant.longValue(), baseDateTime.getMillis()); [EOL] }
public void testBaseDateTimeWithNonNullInstantAndNonNullChronology() { [EOL] Long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] BaseDateTime baseDateTime = new BaseDateTime(instant, chronology); [EOL] assertNotNull(baseDateTime); [EOL] assertEquals(chronology, baseDateTime.getChronology()); [EOL] assertEquals(instant.longValue(), baseDateTime.getMillis()); [EOL] }
public void testBaseDateTimeWithValidValues() { [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 45; [EOL] int secondOfMinute = 30; [EOL] int millisOfSecond = 500; [EOL] BaseDateTime dateTime = new BaseDateTime(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] assertNotNull(dateTime); [EOL] assertEquals(year, dateTime.getYear()); [EOL] assertEquals(monthOfYear, dateTime.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, dateTime.getDayOfMonth()); [EOL] assertEquals(hourOfDay, dateTime.getHourOfDay()); [EOL] assertEquals(minuteOfHour, dateTime.getMinuteOfHour()); [EOL] assertEquals(secondOfMinute, dateTime.getSecondOfMinute()); [EOL] assertEquals(millisOfSecond, dateTime.getMillisOfSecond()); [EOL] }
public void testBaseDateTime_ValidArguments() { [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 45; [EOL] int secondOfMinute = 30; [EOL] int millisOfSecond = 500; [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] BaseDateTime dateTime = new BaseDateTime(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); [EOL] assertEquals(year, dateTime.getYear()); [EOL] assertEquals(monthOfYear, dateTime.getMonthOfYear()); [EOL] assertEquals(dayOfMonth, dateTime.getDayOfMonth()); [EOL] assertEquals(hourOfDay, dateTime.getHourOfDay()); [EOL] assertEquals(minuteOfHour, dateTime.getMinuteOfHour()); [EOL] assertEquals(secondOfMinute, dateTime.getSecondOfMinute()); [EOL] assertEquals(millisOfSecond, dateTime.getMillisOfSecond()); [EOL] assertEquals(chronology, dateTime.getChronology()); [EOL] }
public void testBaseDateTime_NullChronology() { [EOL] int year = 2021; [EOL] int monthOfYear = 5; [EOL] int dayOfMonth = 20; [EOL] int hourOfDay = 13; [EOL] int minuteOfHour = 45; [EOL] int secondOfMinute = 30; [EOL] int millisOfSecond = 500; [EOL] Chronology chronology = null; [EOL] BaseDateTime dateTime = new BaseDateTime(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); [EOL] assertNotNull(dateTime.getChronology()); [EOL] assertEquals(ISOChronology.getInstanceUTC(), dateTime.getChronology()); [EOL] }
public void testFixedDateTimeZoneConstructor() { [EOL] String id = "UTC"; [EOL] String nameKey = "UTCKey"; [EOL] int wallOffset = 0; [EOL] int standardOffset = 0; [EOL] FixedDateTimeZone zone = new FixedDateTimeZone(id, nameKey, wallOffset, standardOffset); [EOL] assertNotNull(zone); [EOL] assertEquals(id, zone.getID()); [EOL] assertEquals(nameKey, zone.getNameKey()); [EOL] assertEquals(wallOffset, zone.getWallOffset()); [EOL] assertEquals(standardOffset, zone.getStandardOffset()); [EOL] }
public void testHashCode_WithDifferentID() { [EOL] Time time1 = new Time("ID1", 10, 20); [EOL] Time time2 = new Time("ID2", 10, 20); [EOL] assertNotEquals(time1.hashCode(), time2.hashCode()); [EOL] } [EOL] public void testHashCode_WithDifferentStandardOffset() { [EOL] Time time1 = new Time("ID", 10, 20); [EOL] Time time2 = new Time("ID", 15, 20); [EOL] assertNotEquals(time1.hashCode(), time2.hashCode()); [EOL] } [EOL] public void testHashCode_WithDifferentWallOffset() { [EOL] Time time1 = new Time("ID", 10, 20); [EOL] Time time2 = new Time("ID", 10, 25); [EOL] assertNotEquals(time1.hashCode(), time2.hashCode()); [EOL] } [EOL] public void testHashCode_WithSameFields() { [EOL] Time time1 = new Time("ID", 10, 20); [EOL] Time time2 = new Time("ID", 10, 20); [EOL] assertEquals(time1.hashCode(), time2.hashCode()); [EOL] }
public void testGetDurationMillis_withReadableDuration() { [EOL] ReadableDuration duration = new StubReadableDuration(1000L); [EOL] long result = getDurationMillis(duration); [EOL] assertEquals(1000L, result); [EOL] } [EOL] public void testGetDurationMillis_withNull() { [EOL] try { [EOL] getDurationMillis(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testAbstractReadableInstantFieldPropertyConstructor() { [EOL] ConcreteReadableInstantFieldProperty instance = new ConcreteReadableInstantFieldProperty(); [EOL] assertNotNull("The instance should be created", instance); [EOL] }
public long remainder() { [EOL] return getField().remainder(getMillis()); [EOL] }
public void testEquals_SameObject() { [EOL] AbstractReadableInstantFieldProperty property = new ConcreteReadableInstantFieldProperty(); [EOL] assertTrue(property.equals(property)); [EOL] }
public void testEquals_DifferentType() { [EOL] AbstractReadableInstantFieldProperty property = new ConcreteReadableInstantFieldProperty(); [EOL] assertFalse(property.equals(new Object())); [EOL] }
public void testEquals_Null() { [EOL] AbstractReadableInstantFieldProperty property = new ConcreteReadableInstantFieldProperty(); [EOL] assertFalse(property.equals(null)); [EOL] }
public void testEquals_BothPropertiesEqual() { [EOL] AbstractReadableInstantFieldProperty property1 = new ConcreteReadableInstantFieldProperty(); [EOL] AbstractReadableInstantFieldProperty property2 = new ConcreteReadableInstantFieldProperty(); [EOL] when(property1.get()).thenReturn(1); [EOL] when(property1.getFieldType()).thenReturn(DateTimeFieldType.dayOfMonth()); [EOL] when(property1.getChronology()).thenReturn(ISOChronology.getInstance()); [EOL] when(property2.get()).thenReturn(1); [EOL] when(property2.getFieldType()).thenReturn(DateTimeFieldType.dayOfMonth()); [EOL] when(property2.getChronology()).thenReturn(ISOChronology.getInstance()); [EOL] assertTrue(property1.equals(property2)); [EOL] }
public void testEquals_PropertiesNotEqual_Value() { [EOL] AbstractReadableInstantFieldProperty property1 = new ConcreteReadableInstantFieldProperty(); [EOL] AbstractReadableInstantFieldProperty property2 = new ConcreteReadableInstantFieldProperty(); [EOL] when(property1.get()).thenReturn(1); [EOL] when(property1.getFieldType()).thenReturn(DateTimeFieldType.dayOfMonth()); [EOL] when(property1.getChronology()).thenReturn(ISOChronology.getInstance()); [EOL] when(property2.get()).thenReturn(2); [EOL] when(property2.getFieldType()).thenReturn(DateTimeFieldType.dayOfMonth()); [EOL] when(property2.getChronology()).thenReturn(ISOChronology.getInstance()); [EOL] assertFalse(property1.equals(property2)); [EOL] }
public void testEquals_PropertiesNotEqual_FieldType() { [EOL] AbstractReadableInstantFieldProperty property1 = new ConcreteReadableInstantFieldProperty(); [EOL] AbstractReadableInstantFieldProperty property2 = new ConcreteReadableInstantFieldProperty(); [EOL] when(property1.get()).thenReturn(1); [EOL] when(property1.getFieldType()).thenReturn(DateTimeFieldType.dayOfMonth()); [EOL] when(property1.getChronology()).thenReturn(ISOChronology.getInstance()); [EOL] when(property2.get()).thenReturn(1); [EOL] when(property2.getFieldType()).thenReturn(DateTimeFieldType.year()); [EOL] when(property2.getChronology()).thenReturn(ISOChronology.getInstance()); [EOL] assertFalse(property1.equals(property2)); [EOL] }
public void testEquals_PropertiesNotEqual_Chronology() { [EOL] AbstractReadableInstantFieldProperty property1 = new ConcreteReadableInstantFieldProperty(); [EOL] AbstractReadableInstantFieldProperty property2 = new ConcreteReadableInstantFieldProperty(); [EOL] when(property1.get()).thenReturn(1); [EOL] when(property1.getFieldType()).thenReturn(DateTimeFieldType.dayOfMonth()); [EOL] when(property1.getChronology()).thenReturn(ISOChronology.getInstance()); [EOL] when(property2.get()).thenReturn(1); [EOL] when(property2.getFieldType()).thenReturn(DateTimeFieldType.dayOfMonth()); [EOL] when(property2.getChronology()).thenReturn(GregorianChronology.getInstance()); [EOL] assertFalse(property1.equals(property2)); [EOL] }
public void testGetInstance_NewField() { [EOL] DateTimeFieldType testType = DateTimeFieldType.secondOfMinute(); [EOL] DurationField testDurationField = UnsupportedDurationField.getInstance(DurationFieldType.seconds()); [EOL] UnsupportedDateTimeField result = UnsupportedDateTimeField.getInstance(testType, testDurationField); [EOL] assertNotNull(result); [EOL] assertSame(testType, result.getType()); [EOL] assertSame(testDurationField, result.getDurationField()); [EOL] }
public void testGetInstance_CachedField() { [EOL] DateTimeFieldType testType = DateTimeFieldType.secondOfMinute(); [EOL] DurationField testDurationField = UnsupportedDurationField.getInstance(DurationFieldType.seconds()); [EOL] UnsupportedDateTimeField firstResult = UnsupportedDateTimeField.getInstance(testType, testDurationField); [EOL] UnsupportedDateTimeField secondResult = UnsupportedDateTimeField.getInstance(testType, testDurationField); [EOL] assertNotNull(secondResult); [EOL] assertSame(firstResult, secondResult); [EOL] }
public void testGetInstance_CachedFieldDifferentDuration() { [EOL] DateTimeFieldType testType = DateTimeFieldType.secondOfMinute(); [EOL] DurationField testDurationField1 = UnsupportedDurationField.getInstance(DurationFieldType.seconds()); [EOL] DurationField testDurationField2 = UnsupportedDurationField.getInstance(DurationFieldType.minutes()); [EOL] UnsupportedDateTimeField firstResult = UnsupportedDateTimeField.getInstance(testType, testDurationField1); [EOL] UnsupportedDateTimeField secondResult = UnsupportedDateTimeField.getInstance(testType, testDurationField2); [EOL] assertNotNull(secondResult); [EOL] assertNotSame(firstResult, secondResult); [EOL] assertSame(testType, secondResult.getType()); [EOL] assertSame(testDurationField2, secondResult.getDurationField()); [EOL] }
public void testUnsupportedDateTimeFieldWithValidArguments() { [EOL] DateTimeFieldType type = DateTimeFieldType.year(); [EOL] DurationField durationField = DurationFieldType.weeks().getField(null); [EOL] UnsupportedDateTimeField field = new UnsupportedDateTimeField(type, durationField); [EOL] assertNotNull(field); [EOL] } [EOL] public void testUnsupportedDateTimeFieldWithNullType() { [EOL] try { [EOL] new UnsupportedDateTimeField(null, DurationFieldType.weeks().getField(null)); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testUnsupportedDateTimeFieldWithNullDurationField() { [EOL] try { [EOL] new UnsupportedDateTimeField(DateTimeFieldType.year(), null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public long add(long instant, int value) { [EOL] return getDurationField().add(instant, value); [EOL] }
public long addTestWithPositiveValues() { [EOL] long instant = 1000L; [EOL] long value = 500L; [EOL] long expected = 1500L; // Assuming getDurationField().add() works as simple addition [EOL] long result = add(instant, value); [EOL] assert result == expected : "Adding positive values failed"; [EOL] } [EOL] public long addTestWithNegativeValues() { [EOL] long instant = 1000L; [EOL] long value = -500L; [EOL] long expected = 500L; // Assuming getDurationField().add() works as simple addition [EOL] long result = add(instant, value); [EOL] assert result == expected : "Adding negative value failed"; [EOL] } [EOL] public long addTestWithZero() { [EOL] long instant = 1000L; [EOL] long value = 0L; [EOL] long expected = 1000L; // Assuming getDurationField().add() works as simple addition [EOL] long result = add(instant, value); [EOL] assert result == expected : "Adding zero failed"; [EOL] }
public int getDifferenceTestWithPositiveDifference() { [EOL] long minuendInstant = 1000L; [EOL] long subtrahendInstant = 500L; [EOL] int expected = 500; [EOL] int actual = getDifference(minuendInstant, subtrahendInstant); [EOL] assert actual == expected; [EOL] } [EOL] public int getDifferenceTestWithNegativeDifference() { [EOL] long minuendInstant = 500L; [EOL] long subtrahendInstant = 1000L; [EOL] int expected = -500; [EOL] int actual = getDifference(minuendInstant, subtrahendInstant); [EOL] assert actual == expected; [EOL] } [EOL] public int getDifferenceTestWithNoDifference() { [EOL] long minuendInstant = 1000L; [EOL] long subtrahendInstant = 1000L; [EOL] int expected = 0; [EOL] int actual = getDifference(minuendInstant, subtrahendInstant); [EOL] assert actual == expected; [EOL] }
public void testGetDifferenceAsLong_SameValues() { [EOL] long minuendInstant = 1000L; [EOL] long subtrahendInstant = 1000L; [EOL] long expected = 0L; [EOL] long result = getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, result); [EOL] }
public void testGetDifferenceAsLong_PositiveDifference() { [EOL] long minuendInstant = 2000L; [EOL] long subtrahendInstant = 1000L; [EOL] long expected = 1000L; [EOL] long result = getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, result); [EOL] }
public void testGetDifferenceAsLong_NegativeDifference() { [EOL] long minuendInstant = 1000L; [EOL] long subtrahendInstant = 2000L; [EOL] long expected = -1000L; [EOL] long result = getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, result); [EOL] }
public void testReadResolve() { [EOL] YourClass instance = YourClass.createInstance(expectedType, expectedDurationField); [EOL] Object resolvedInstance = instance.readResolve(); [EOL] assertNotNull("Resolved instance should not be null", resolvedInstance); [EOL] assertTrue("Resolved instance should be of type YourClass", resolvedInstance instanceof YourClass); [EOL] YourClass resolvedYourClass = (YourClass) resolvedInstance; [EOL] assertEquals("Type should be the same as expected", expectedType, resolvedYourClass.getType()); [EOL] assertEquals("Duration field should be the same as expected", expectedDurationField, resolvedYourClass.getDurationField()); [EOL] }
public void testPreciseDateTimeField_WithPreciseRange() { [EOL] DateTimeFieldType mockType = mock(DateTimeFieldType.class); [EOL] DurationField mockUnit = mock(DurationField.class); [EOL] DurationField mockRange = mock(DurationField.class); [EOL] when(mockUnit.getUnitMillis()).thenReturn(1L); [EOL] when(mockRange.isPrecise()).thenReturn(true); [EOL] when(mockRange.getUnitMillis()).thenReturn(2L); [EOL] PreciseDateTimeField field = new PreciseDateTimeField(mockType, mockUnit, mockRange); [EOL] assertEquals(2, field.getRange()); [EOL] }
public void testPreciseDateTimeField_WithImpreciseRange_ShouldThrow() { [EOL] DateTimeFieldType mockType = mock(DateTimeFieldType.class); [EOL] DurationField mockUnit = mock(DurationField.class); [EOL] DurationField mockRange = mock(DurationField.class); [EOL] when(mockUnit.getUnitMillis()).thenReturn(1L); [EOL] when(mockRange.isPrecise()).thenReturn(false); [EOL] try { [EOL] new PreciseDateTimeField(mockType, mockUnit, mockRange); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("Range duration field must be precise", ex.getMessage()); [EOL] } [EOL] }
public void testPreciseDateTimeField_WithInvalidRange_ShouldThrow() { [EOL] DateTimeFieldType mockType = mock(DateTimeFieldType.class); [EOL] DurationField mockUnit = mock(DurationField.class); [EOL] DurationField mockRange = mock(DurationField.class); [EOL] when(mockUnit.getUnitMillis()).thenReturn(1L); [EOL] when(mockRange.isPrecise()).thenReturn(true); [EOL] when(mockRange.getUnitMillis()).thenReturn(1L); // This will cause iRange to be less than 2 [EOL] try { [EOL] new PreciseDateTimeField(mockType, mockUnit, mockRange); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The effective range must be at least 2", ex.getMessage()); [EOL] } [EOL] }
public void testGetWithPositiveInstant() { [EOL] long instant = 1000; // Assume this is a positive instant [EOL] int expected = (int) ((instant / getUnitMillis()) % iRange); // Replace getUnitMillis() and iRange with actual values [EOL] int actual = get(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetWithNegativeInstant() { [EOL] long instant = -1000; // Assume this is a negative instant [EOL] int expected = iRange - 1 + (int) (((instant + 1) / getUnitMillis()) % iRange); // Replace getUnitMillis() and iRange with actual values [EOL] int actual = get(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testAddWrapField_WithinBounds() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant value [EOL] int amount = SOME_AMOUNT; // Replace with an amount that when added to instant, stays within bounds [EOL] long expected = EXPECTED_INSTANT; // Replace with the expected instant after wrapping [EOL] long actual = addWrapField(instant, amount); [EOL] assertEquals(expected, actual); [EOL] }
public void testAddWrapField_BelowMinimum() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant value [EOL] int amount = -SOME_LARGE_AMOUNT; // Replace with an amount that when subtracted from instant, goes below the minimum value [EOL] long expected = EXPECTED_INSTANT; // Replace with the expected instant after wrapping below minimum [EOL] long actual = addWrapField(instant, amount); [EOL] assertEquals(expected, actual); [EOL] }
public void testAddWrapField_AboveMaximum() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant value [EOL] int amount = SOME_LARGE_AMOUNT; // Replace with an amount that when added to instant, goes above the maximum value [EOL] long expected = EXPECTED_INSTANT; // Replace with the expected instant after wrapping above maximum [EOL] long actual = addWrapField(instant, amount); [EOL] assertEquals(expected, actual); [EOL] }
public int getMaximumValue() { [EOL] return iRange - 1; [EOL] }
public int getRange() { [EOL] return iRange; [EOL] }
public void testGetDateTimeMillis_ValidDate() { [EOL] long expectedMillis = 1234567890L; // Example expected value [EOL] when(getBase().getDateTimeMillis(2023, 4, 1, 12, 0, 0, 0)).thenReturn(expectedMillis); [EOL] long actualMillis = getDateTimeMillis(2023, 4, 1, 12, 0, 0, 0); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testGetDateTimeMillis_InvalidDate() { [EOL] try { [EOL] getDateTimeMillis(2023, 13, 1, 12, 0, 0, 0); // Invalid month [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testLocalToUTC_withConstantOffset() { [EOL] DateTimeZone zone = DateTimeZone.forOffsetHours(1); [EOL] long localInstant = System.currentTimeMillis(); [EOL] int offset = zone.getOffsetFromLocal(localInstant); [EOL] long expected = localInstant - offset; [EOL] long actual = localToUTC(localInstant); [EOL] assertEquals(expected, actual); [EOL] }
public void testLocalToUTC_withChangingOffset() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] long localInstant = zone.nextTransition(System.currentTimeMillis()); [EOL] try { [EOL] localToUTC(localInstant); [EOL] fail("Should have thrown IllegalInstantException"); [EOL] } catch (IllegalInstantException e) { [EOL] } [EOL] }
public void testGetWithPositiveInstant() { [EOL] long instant = 1000L; // A positive instant [EOL] int expected = SOME_EXPECTED_VALUE; // Replace with the actual expected value [EOL] int actual = get(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetWithNegativeInstant() { [EOL] long instant = -1000L; // A negative instant [EOL] int expected = SOME_EXPECTED_VALUE; // Replace with the actual expected value [EOL] int actual = get(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetWithZeroInstant() { [EOL] long instant = 0L; // Zero instant [EOL] int expected = SOME_EXPECTED_VALUE; // Replace with the actual expected value [EOL] int actual = get(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testAdd_WithTimeField() { [EOL] TimeField timeField = new TimeField(true); // Assuming true means iTimeField is active [EOL] long instant = 0L; [EOL] int value = 5; [EOL] long result = timeField.add(instant, value); [EOL] long expected = /* expected result when iTimeField is true */; [EOL] assertEquals(expected, result); [EOL] }
public void testAdd_WithoutTimeField() { [EOL] TimeField timeField = new TimeField(false); // Assuming false means iTimeField is not active [EOL] long instant = 0L; [EOL] int value = 5; [EOL] long result = timeField.add(instant, value); [EOL] long expected = /* expected result when iTimeField is false */; [EOL] assertEquals(expected, result); [EOL] }
public void testRoundFloorWithTimeFieldTrue() { [EOL] long instant = 123456789L; [EOL] int offset = 5; // Example offset [EOL] long expected = instant - offset; // Adjust according to the mock behavior [EOL] long result = roundFloor(instant); [EOL] assertEquals(expected, result); [EOL] }
public void testRoundFloorWithTimeFieldFalse() { [EOL] long instant = 123456789L; [EOL] long localInstant = instant + 7; // Example local instant [EOL] long expected = localInstant - 3; // Adjust according to the mock behavior [EOL] long result = roundFloor(instant); [EOL] assertEquals(expected, result); [EOL] }
public void testRoundCeiling_WithTimeFieldTrue() { [EOL] long instant = 0L; [EOL] long expected = 10L; [EOL] when(iField.roundCeiling(anyLong())).thenReturn(expected); [EOL] when(getOffsetToAdd(anyLong())).thenReturn(5L); [EOL] long result = roundCeiling(instant); [EOL] assertEquals(expected - 5L, result); [EOL] }
public void testRoundCeiling_WithTimeFieldFalse() { [EOL] long instant = 0L; [EOL] long localInstant = 5L; [EOL] long expected = 10L; [EOL] when(iZone.convertUTCToLocal(anyLong())).thenReturn(localInstant); [EOL] when(iField.roundCeiling(anyLong())).thenReturn(expected); [EOL] when(iZone.convertLocalToUTC(anyLong(), anyBoolean(), anyLong())).thenReturn(expected); [EOL] long result = roundCeiling(instant); [EOL] assertEquals(expected, result); [EOL] }
public void testRemainder_PositiveInstant() { [EOL] DateTimeZone mockZone = mock(DateTimeZone.class); [EOL] when(mockZone.convertUTCToLocal(anyLong())).thenReturn(1000L); [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] when(mockField.remainder(1000L)).thenReturn(500L); [EOL] Time time = new Time(mockZone, mockField); [EOL] long result = time.remainder(500L); [EOL] assertEquals(500L, result); [EOL] }
public void testRemainder_NegativeInstant() { [EOL] DateTimeZone mockZone = mock(DateTimeZone.class); [EOL] when(mockZone.convertUTCToLocal(anyLong())).thenReturn(-1000L); [EOL] DateTimeField mockField = mock(DateTimeField.class); [EOL] when(mockField.remainder(-1000L)).thenReturn(-500L); [EOL] Time time = new Time(mockZone, mockField); [EOL] long result = time.remainder(-500L); [EOL] assertEquals(-500L, result); [EOL] }
public void testGetOffsetToAdd_NoOverflow() { [EOL] long instant = 0L; // Use a value that will not cause overflow when added to offset [EOL] int expectedOffset = 0; // Replace with the actual expected offset from the time zone [EOL] int actualOffset = getOffsetToAdd(instant); [EOL] assertEquals(expectedOffset, actualOffset); [EOL] } [EOL] public void testGetOffsetToAdd_Overflow() { [EOL] long instant = Long.MAX_VALUE; // Use a value that will cause overflow when added to offset [EOL] try { [EOL] getOffsetToAdd(instant); [EOL] fail("Should have thrown ArithmeticException due to overflow"); [EOL] } catch (ArithmeticException e) { [EOL] } [EOL] }
public void testIsLenient() { [EOL] Time time = new Time(); [EOL] boolean result = time.isLenient(); [EOL] assertFalse(result); [EOL] }
public void testIllegalInstantExceptionWithNullMessage() { [EOL] String message = null; [EOL] IllegalInstantException exception = new IllegalInstantException(message); [EOL] assertNull(exception.getMessage()); [EOL] }
public void testIllegalInstantExceptionWithEmptyMessage() { [EOL] String message = ""; [EOL] IllegalInstantException exception = new IllegalInstantException(message); [EOL] assertEquals("", exception.getMessage()); [EOL] }
public void testIllegalInstantExceptionWithNonEmptyMessage() { [EOL] String message = "Non-empty message"; [EOL] IllegalInstantException exception = new IllegalInstantException(message); [EOL] assertEquals("Non-empty message", exception.getMessage()); [EOL] }
public void testGetAsTextWithValidFieldValueAndLocale() { [EOL] int fieldValue = 1; // Assuming 1 is a valid day of the week index [EOL] Locale locale = Locale.US; [EOL] String expected = "Sunday"; // Assuming Sunday is the text for the first day of the week [EOL] String actual = getAsText(fieldValue, locale); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetAsTextWithInvalidFieldValue() { [EOL] int fieldValue = 8; // Assuming there are only 7 days in a week [EOL] Locale locale = Locale.US; [EOL] try { [EOL] getAsText(fieldValue, locale); [EOL] fail("Should have thrown an exception for invalid field value"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetAsTextWithNullLocale() { [EOL] int fieldValue = 1; [EOL] Locale locale = null; [EOL] try { [EOL] getAsText(fieldValue, locale); [EOL] fail("Should have thrown an exception for null locale"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public int getMaximumTextLength(Locale locale) { [EOL] return GJLocaleSymbols.forLocale(locale).getDayOfWeekMaxTextLength(); [EOL] }
public void testCreateMessageWithValue() { [EOL] String fieldName = "testField"; [EOL] String value = "testValue"; [EOL] String expected = "Value \"testValue\" for testField is not supported"; [EOL] String actual = createMessage(fieldName, value); [EOL] assertEquals(expected, actual); [EOL] }
public void testCreateMessageWithNullValue() { [EOL] String fieldName = "testField"; [EOL] String value = null; [EOL] String expected = "Value null for testField is not supported"; [EOL] String actual = createMessage(fieldName, value); [EOL] assertEquals(expected, actual); [EOL] }
public void testIllegalFieldValueExceptionWithValidInput() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); [EOL] String value = "10"; [EOL] IllegalFieldValueException exception = new IllegalFieldValueException(fieldType, value); [EOL] assertEquals(fieldType, exception.getDateTimeFieldType()); [EOL] assertNull(exception.getDurationFieldType()); [EOL] assertEquals("dayOfMonth", exception.getFieldName()); [EOL] assertEquals(value, exception.getStringValue()); [EOL] assertNull(exception.getNumberValue()); [EOL] assertNull(exception.getLowerBound()); [EOL] assertNull(exception.getUpperBound()); [EOL] assertEquals("Value 10 for dayOfMonth must be in the range [null,null]", exception.getMessage()); [EOL] }
public void testIllegalFieldValueExceptionWithNullFieldType() { [EOL] String value = "10"; [EOL] try { [EOL] new IllegalFieldValueException(null, value); [EOL] fail("Should have thrown IllegalArgumentException because fieldType is null"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testIsSupportedWithNullType() { [EOL] boolean result = isSupported(null); [EOL] assertFalse(result); [EOL] }
public void testIsSupportedWithUnsupportedDurationType() { [EOL] DateTimeFieldType type = mock(DateTimeFieldType.class); [EOL] when(type.getDurationType()).thenReturn(DurationFieldType.weeks()); [EOL] when(isSupported(DurationFieldType.weeks())).thenReturn(false); [EOL] boolean result = isSupported(type); [EOL] assertFalse(result); [EOL] }
public void testIsSupportedWithSupportedDurationTypeAndUnsupportedRange() { [EOL] DateTimeFieldType type = mock(DateTimeFieldType.class); [EOL] DurationFieldType durationType = DurationFieldType.hours(); [EOL] when(type.getDurationType()).thenReturn(durationType); [EOL] when(isSupported(durationType)).thenReturn(true); [EOL] DurationFieldType rangeType = DurationFieldType.weeks(); [EOL] when(type.getRangeDurationType()).thenReturn(rangeType); [EOL] when(isSupported(rangeType)).thenReturn(false); [EOL] boolean result = isSupported(type); [EOL] assertFalse(result); [EOL] }
public void testIsSupportedWithSupportedDurationTypeAndSupportedRange() { [EOL] DateTimeFieldType type = mock(DateTimeFieldType.class); [EOL] DurationFieldType durationType = DurationFieldType.hours(); [EOL] when(type.getDurationType()).thenReturn(durationType); [EOL] when(isSupported(durationType)).thenReturn(true); [EOL] DurationFieldType rangeType = DurationFieldType.days(); [EOL] when(type.getRangeDurationType()).thenReturn(rangeType); [EOL] when(isSupported(rangeType)).thenReturn(true); [EOL] boolean result = isSupported(type); [EOL] assertTrue(result); [EOL] }
public void testIsSupportedWithSupportedDurationTypeAndRangeIsDays() { [EOL] DateTimeFieldType type = mock(DateTimeFieldType.class); [EOL] DurationFieldType durationType = DurationFieldType.hours(); [EOL] when(type.getDurationType()).thenReturn(durationType); [EOL] when(isSupported(durationType)).thenReturn(true); [EOL] DurationFieldType rangeType = DurationFieldType.days(); [EOL] when(type.getRangeDurationType()).thenReturn(rangeType); [EOL] boolean result = isSupported(type); [EOL] assertTrue(result); [EOL] }
public void testIsSupportedWithNullType() { [EOL] boolean result = instance.isSupported(null); [EOL] assertFalse(result); [EOL] }
public void testIsSupportedWithUnsupportedType() { [EOL] DurationFieldType unsupportedType = DurationFieldType.centuries(); [EOL] boolean result = instance.isSupported(unsupportedType); [EOL] assertFalse(result); [EOL] }
public void testIsSupportedWithSupportedType() { [EOL] DurationFieldType supportedType = DurationFieldType.minutes(); [EOL] boolean result = instance.isSupported(supportedType); [EOL] assertTrue(result); [EOL] }
public void testEquals_SameObject() { [EOL] LocalTime time = new LocalTime(10, 0, 0); [EOL] assertTrue(time.equals(time)); [EOL] }
public void testEquals_DifferentObjectSameTime() { [EOL] LocalTime time1 = new LocalTime(10, 0, 0); [EOL] LocalTime time2 = new LocalTime(10, 0, 0); [EOL] assertTrue(time1.equals(time2)); [EOL] }
public void testEquals_DifferentObjectDifferentTime() { [EOL] LocalTime time1 = new LocalTime(10, 0, 0); [EOL] LocalTime time2 = new LocalTime(11, 0, 0); [EOL] assertFalse(time1.equals(time2)); [EOL] }
public void testEquals_NonLocalTimeObject() { [EOL] LocalTime time = new LocalTime(10, 0, 0); [EOL] Object obj = new Object(); [EOL] assertFalse(time.equals(obj)); [EOL] }
public void testEquals_Null() { [EOL] LocalTime time = new LocalTime(10, 0, 0); [EOL] assertFalse(time.equals(null)); [EOL] }
public void testMinusMillis_Zero() { [EOL] LocalTime time = LocalTime.now(); [EOL] LocalTime result = time.minusMillis(0); [EOL] assertEquals(time, result); [EOL] }
public void testMinusMillis_NonZero() { [EOL] LocalTime time = LocalTime.now(); [EOL] int millis = 500; [EOL] LocalTime result = time.minusMillis(millis); [EOL] long expectedMillis = time.getChronology().millis().subtract(time.getLocalMillis(), millis); [EOL] LocalTime expectedTime = time.withLocalMillis(expectedMillis); [EOL] assertEquals(expectedTime, result); [EOL] }
public void testHourOfDayProperty() { [EOL] DateTime dateTime = new DateTime(); [EOL] Property property = dateTime.hourOfDay(); [EOL] assertNotNull(property); [EOL] assertEquals(dateTime.getChronology().hourOfDay(), property.getField()); [EOL] assertEquals(dateTime, property.getReadableInstant()); [EOL] }
public void testSecondOfMinute() { [EOL] Time time = new Time(); [EOL] Property property = time.secondOfMinute(); [EOL] assertNotNull(property); [EOL] assertEquals(time.getChronology().secondOfMinute(), property.getField()); [EOL] }
public void testToDateTimeToday_WithNonNullZone() { [EOL] DateTimeZone mockZone = DateTimeZone.forID("Europe/London"); [EOL] LocalDate localDate = new LocalDate(); [EOL] DateTime result = localDate.toDateTimeToday(mockZone); [EOL] assertNotNull(result); [EOL] assertEquals(mockZone, result.getZone()); [EOL] assertEquals(localDate.toDateTimeAtStartOfDay(mockZone), result.withTimeAtStartOfDay()); [EOL] }
public void testToDateTimeToday_WithNullZone() { [EOL] LocalDate localDate = new LocalDate(); [EOL] DateTime result = localDate.toDateTimeToday(null); [EOL] assertNotNull(result); [EOL] assertEquals(DateTimeZone.getDefault(), result.getZone()); [EOL] assertEquals(localDate.toDateTimeAtStartOfDay(DateTimeZone.getDefault()), result.withTimeAtStartOfDay()); [EOL] }
public void testAddNoWrapToCopy_WithinDay() { [EOL] LocalTime time = new LocalTime(10, 0); // Assuming 10 AM [EOL] int valueToAdd = 2 * 60 * 60 * 1000; // 2 hours in milliseconds [EOL] LocalTime result = time.addNoWrapToCopy(valueToAdd); [EOL] assertEquals(new LocalTime(12, 0), result); // Expecting 12 PM [EOL] }
public void testAddNoWrapToCopy_ExceedsDay() { [EOL] LocalTime time = new LocalTime(23, 0); // Assuming 11 PM [EOL] int valueToAdd = 2 * 60 * 60 * 1000; // 2 hours in milliseconds [EOL] try { [EOL] time.addNoWrapToCopy(valueToAdd); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetCopy_ValidValue() { [EOL] LocalTime time = new LocalTime(10, 0); [EOL] int newValue = 11; [EOL] LocalTime updatedTime = time.setCopy(newValue); [EOL] assertEquals(newValue, updatedTime.getHourOfDay()); [EOL] }
public void testSetCopy_InvalidValue() { [EOL] LocalTime time = new LocalTime(10, 0); [EOL] int invalidValue = 25; // Assuming hour of day field [EOL] try { [EOL] time.setCopy(invalidValue); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testSetCopyWithValidTextAndLocale() { [EOL] LocalTime initialTime = new LocalTime(10, 0); // Assuming LocalTime and DateTimeField are part of the Joda-Time library [EOL] DateTimeField field = initialTime.getChronology().hourOfDay(); [EOL] LocalTime updatedTime = initialTime.setCopy("12", Locale.ENGLISH); [EOL] assertEquals(new LocalTime(12, 0), updatedTime); [EOL] }
public void testSetCopyWithInvalidText() { [EOL] LocalTime initialTime = new LocalTime(10, 0); [EOL] DateTimeField field = initialTime.getChronology().hourOfDay(); [EOL] try { [EOL] initialTime.setCopy("invalid", Locale.ENGLISH); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetCopyWithNullLocale() { [EOL] LocalTime initialTime = new LocalTime(10, 0); [EOL] DateTimeField field = initialTime.getChronology().hourOfDay(); [EOL] LocalTime updatedTime = initialTime.setCopy("12", null); [EOL] assertEquals(new LocalTime(12, 0), updatedTime); [EOL] }
public void testSetCopyWithNonNullText() { [EOL] LocalTime time = new LocalTime(); [EOL] String text = "12:00"; [EOL] LocalTime updatedTime = time.setCopy(text); [EOL] assertNotNull(updatedTime); [EOL] assertNotSame(time, updatedTime); [EOL] }
public void testSetCopyWithNullText() { [EOL] LocalTime time = new LocalTime(); [EOL] String text = null; [EOL] try { [EOL] time.setCopy(text); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testMillisFieldType() { [EOL] DurationFieldType type = Time.millis(); [EOL] assertNotNull(type); [EOL] assertEquals("millis", type.getName()); [EOL] }
public void testSeconds() { [EOL] DurationFieldType secondsType = Time.seconds(); [EOL] assertNotNull(secondsType); [EOL] assertEquals("seconds", secondsType.getName()); [EOL] }
public void testMinutes() { [EOL] DurationFieldType fieldType = ClassName.minutes(); [EOL] assertNotNull(fieldType); [EOL] assertSame(DurationFieldType.MINUTES_TYPE, fieldType); [EOL] }
public void testHours() { [EOL] DurationFieldType hoursType = Time.hours(); [EOL] assertNotNull(hoursType); [EOL] assertEquals("hours", hoursType.getName()); [EOL] }
public void testGetFieldForEras() { [EOL] Chronology chronology = createMockChronology(); [EOL] DurationFieldType type = DurationFieldType.ERAS; [EOL] DurationField field = type.getField(chronology); [EOL] assertEquals(chronology.eras(), field); [EOL] } [EOL] public void testGetFieldForCenturies() { [EOL] Chronology chronology = createMockChronology(); [EOL] DurationFieldType type = DurationFieldType.CENTURIES; [EOL] DurationField field = type.getField(chronology); [EOL] assertEquals(chronology.centuries(), field); [EOL] } [EOL] public void testGetFieldForWeekyears() { [EOL] Chronology chronology = createMockChronology(); [EOL] DurationFieldType type = DurationFieldType.WEEKYEARS; [EOL] DurationField field = type.getField(chronology); [EOL] assertEquals(chronology.weekyears(), field); [EOL] } [EOL] public void testGetFieldForYears() { [EOL] Chronology chronology = createMockChronology(); [EOL] DurationFieldType type = DurationFieldType.YEARS; [EOL] DurationField field = type.getField(chronology); [EOL] assertEquals(chronology.years(), field); [EOL] } [EOL] public void testGetFieldForMonths() { [EOL] Chronology chronology = createMockChronology(); [EOL] DurationFieldType type = DurationFieldType.MONTHS; [EOL] DurationField field = type.getField(chronology); [EOL] assertEquals(chronology.months(), field); [EOL] } [EOL] public void testGetFieldForWeeks() { [EOL] Chronology chronology = createMockChronology(); [EOL] DurationFieldType type = DurationFieldType.WEEKS; [EOL] DurationField field = type.getField(chronology); [EOL] assertEquals(chronology.weeks(), field); [EOL] } [EOL] public void testGetFieldForDays() { [EOL] Chronology chronology = createMockChronology(); [EOL] DurationFieldType type = DurationFieldType.DAYS; [EOL] DurationField field = type.getField(chronology); [EOL] assertEquals(chronology.days(), field); [EOL] } [EOL] public void testGetFieldForHalfdays() { [EOL] Chronology chronology = createMockChronology(); [EOL] DurationFieldType type = DurationFieldType.HALFDAYS; [EOL] DurationField field = type.getField(chronology); [EOL] assertEquals(chronology.halfdays(), field); [EOL] } [EOL] public void testGetFieldForHours() { [EOL] Chronology chronology = createMockChronology(); [EOL] DurationFieldType type = DurationFieldType.HOURS; [EOL] DurationField field = type.getField(chronology); [EOL] assertEquals(chronology.hours(), field); [EOL] } [EOL] public void testGetFieldForMinutes() { [EOL] Chronology chronology = createMockChronology(); [EOL] DurationFieldType type = DurationFieldType.MINUTES; [EOL] DurationField field = type.getField(chronology); [EOL] assertEquals(chronology.minutes(), field); [EOL] } [EOL] public void testGetFieldForSeconds() { [EOL] Chronology chronology = createMockChronology(); [EOL] DurationFieldType type = DurationFieldType.SECONDS; [EOL] DurationField field = type.getField(chronology); [EOL] assertEquals(chronology.seconds(), field); [EOL] } [EOL] public void testGetFieldForMillis() { [EOL] Chronology chronology = createMockChronology(); [EOL] DurationFieldType type = DurationFieldType.MILLIS; [EOL] DurationField field = type.getField(chronology); [EOL] assertEquals(chronology.millis(), field); [EOL] } [EOL] public void testGetFieldForInvalidType() { [EOL] Chronology chronology = createMockChronology(); [EOL] DurationFieldType type = createInvalidDurationFieldType(); [EOL] try { [EOL] type.getField(chronology); [EOL] fail("Should have thrown InternalError for invalid type"); [EOL] } catch (InternalError e) { [EOL] } [EOL] } [EOL] private Chronology createMockChronology() { [EOL] } [EOL] private DurationFieldType createInvalidDurationFieldType() { [EOL] }
public void testReadResolveForEras() { [EOL] MyClass instance = new MyClass(MyClass.ERAS); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.ERAS_TYPE, result); [EOL] }
public void testReadResolveForCenturies() { [EOL] MyClass instance = new MyClass(MyClass.CENTURIES); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.CENTURIES_TYPE, result); [EOL] }
public void testReadResolveForWeekyears() { [EOL] MyClass instance = new MyClass(MyClass.WEEKYEARS); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.WEEKYEARS_TYPE, result); [EOL] }
public void testReadResolveForYears() { [EOL] MyClass instance = new MyClass(MyClass.YEARS); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.YEARS_TYPE, result); [EOL] }
public void testReadResolveForMonths() { [EOL] MyClass instance = new MyClass(MyClass.MONTHS); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.MONTHS_TYPE, result); [EOL] }
public void testReadResolveForWeeks() { [EOL] MyClass instance = new MyClass(MyClass.WEEKS); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.WEEKS_TYPE, result); [EOL] }
public void testReadResolveForDays() { [EOL] MyClass instance = new MyClass(MyClass.DAYS); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.DAYS_TYPE, result); [EOL] }
public void testReadResolveForHalfdays() { [EOL] MyClass instance = new MyClass(MyClass.HALFDAYS); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.HALFDAYS_TYPE, result); [EOL] }
public void testReadResolveForHours() { [EOL] MyClass instance = new MyClass(MyClass.HOURS); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.HOURS_TYPE, result); [EOL] }
public void testReadResolveForMinutes() { [EOL] MyClass instance = new MyClass(MyClass.MINUTES); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.MINUTES_TYPE, result); [EOL] }
public void testReadResolveForSeconds() { [EOL] MyClass instance = new MyClass(MyClass.SECONDS); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.SECONDS_TYPE, result); [EOL] }
public void testReadResolveForMillis() { [EOL] MyClass instance = new MyClass(MyClass.MILLIS); [EOL] Object result = instance.readResolve(); [EOL] assertEquals(MyClass.MILLIS_TYPE, result); [EOL] }
public void testReadResolveForDefault() { [EOL] MyClass instance = new MyClass(-1); // Assuming -1 is not a valid iOrdinal [EOL] Object result = instance.readResolve(); [EOL] assertSame(instance, result); [EOL] }
public void testGetInstance_NewType() { [EOL] DurationFieldType newType = DurationFieldType.seconds(); [EOL] UnsupportedDurationField result = UnsupportedDurationField.getInstance(newType); [EOL] assertNotNull(result); [EOL] assertSame(newType, result.getType()); [EOL] }
public void testGetInstance_ExistingType() { [EOL] DurationFieldType existingType = DurationFieldType.seconds(); [EOL] UnsupportedDurationField firstCallResult = UnsupportedDurationField.getInstance(existingType); [EOL] UnsupportedDurationField secondCallResult = UnsupportedDurationField.getInstance(existingType); [EOL] assertNotNull(secondCallResult); [EOL] assertSame(firstCallResult, secondCallResult); [EOL] }
public boolean isSupported() { [EOL] return false; [EOL] }
public long add(long instant, int value) { [EOL] throw unsupported(); [EOL] }
public long add(long instant, long value) { [EOL] throw unsupported(); [EOL] }
public int getDifference(long minuendInstant, long subtrahendInstant) { [EOL] throw unsupported(); [EOL] }
public void testGetDifferenceAsLongThrowsException() { [EOL] try { [EOL] getDifferenceAsLong(0L, 0L); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (Exception e) { [EOL] assertEquals("UnsupportedOperationException expected", UnsupportedOperationException.class, e.getClass()); [EOL] } [EOL] }
private Object readResolve() { [EOL] return getInstance(iType); [EOL] }
private UnsupportedOperationException unsupported() { [EOL] return new UnsupportedOperationException(iType + " field is unsupported"); [EOL] }
public void testMutableDateTimeWithInstantAndZone() { [EOL] long instant = System.currentTimeMillis(); [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] MutableDateTime dateTime = new MutableDateTime(instant, zone); [EOL] assertEquals(instant, dateTime.getMillis()); [EOL] assertEquals(zone, dateTime.getZone()); [EOL] }
public void testMutableDateTimeWithInstantAndUTCZone() { [EOL] long instant = System.currentTimeMillis(); [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] MutableDateTime dateTime = new MutableDateTime(instant, zone); [EOL] assertEquals(instant, dateTime.getMillis()); [EOL] assertEquals(zone, dateTime.getZone()); [EOL] }
public void testMutableDateTime_ValidValues() { [EOL] MutableDateTime dateTime = new MutableDateTime(2023, 3, 14, 15, 9, 26, 500); [EOL] assertEquals(2023, dateTime.getYear()); [EOL] assertEquals(3, dateTime.getMonthOfYear()); [EOL] assertEquals(14, dateTime.getDayOfMonth()); [EOL] assertEquals(15, dateTime.getHourOfDay()); [EOL] assertEquals(9, dateTime.getMinuteOfHour()); [EOL] assertEquals(26, dateTime.getSecondOfMinute()); [EOL] assertEquals(500, dateTime.getMillisOfSecond()); [EOL] }
public void testMutableDateTimeWithValidValues() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] MutableDateTime dateTime = new MutableDateTime(2023, 3, 25, 10, 20, 30, 500, zone); [EOL] assertEquals(2023, dateTime.getYear()); [EOL] assertEquals(3, dateTime.getMonthOfYear()); [EOL] assertEquals(25, dateTime.getDayOfMonth()); [EOL] assertEquals(10, dateTime.getHourOfDay()); [EOL] assertEquals(20, dateTime.getMinuteOfHour()); [EOL] assertEquals(30, dateTime.getSecondOfMinute()); [EOL] assertEquals(500, dateTime.getMillisOfSecond()); [EOL] assertEquals(zone, dateTime.getZone()); [EOL] }
public void testSetMillisWithRoundNone() { [EOL] iRoundingMode = ROUND_NONE; [EOL] long expected = SOME_INSTANT; [EOL] setMillis(expected); [EOL] assertEquals(expected, getMillis()); [EOL] }
public void testSetMillisWithRoundFloor() { [EOL] iRoundingMode = ROUND_FLOOR; [EOL] long instant = SOME_INSTANT; [EOL] long expected = iRoundingField.roundFloor(instant); [EOL] setMillis(instant); [EOL] assertEquals(expected, getMillis()); [EOL] }
public void testSetMillisWithRoundCeiling() { [EOL] iRoundingMode = ROUND_CEILING; [EOL] long instant = SOME_INSTANT; [EOL] long expected = iRoundingField.roundCeiling(instant); [EOL] setMillis(instant); [EOL] assertEquals(expected, getMillis()); [EOL] }
public void testSetMillisWithRoundHalfFloor() { [EOL] iRoundingMode = ROUND_HALF_FLOOR; [EOL] long instant = SOME_INSTANT; [EOL] long expected = iRoundingField.roundHalfFloor(instant); [EOL] setMillis(instant); [EOL] assertEquals(expected, getMillis()); [EOL] }
public void testSetMillisWithRoundHalfCeiling() { [EOL] iRoundingMode = ROUND_HALF_CEILING; [EOL] long instant = SOME_INSTANT; [EOL] long expected = iRoundingField.roundHalfCeiling(instant); [EOL] setMillis(instant); [EOL] assertEquals(expected, getMillis()); [EOL] }
public void testSetMillisWithRoundHalfEven() { [EOL] iRoundingMode = ROUND_HALF_EVEN; [EOL] long instant = SOME_INSTANT; [EOL] long expected = iRoundingField.roundHalfEven(instant); [EOL] setMillis(instant); [EOL] assertEquals(expected, getMillis()); [EOL] }
public void add_withNullDuration_throwsException() { [EOL] TimePeriod timePeriod = new TimePeriod(); [EOL] try { [EOL] timePeriod.add(null); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Duration must not be null", e.getMessage()); [EOL] } [EOL] } [EOL] public void add_withValidDuration_incrementsTimePeriod() { [EOL] TimePeriod timePeriod = new TimePeriod(); [EOL] ReadableDuration duration = new Duration(1000); [EOL] timePeriod.add(duration); [EOL] assertEquals(1000, timePeriod.getMillis()); [EOL] }
public void add_withNonNullDurationAndPositiveScalar_shouldAddScaledDuration() { [EOL] TimePeriod timePeriod = new TimePeriod(); [EOL] ReadableDuration duration = mock(ReadableDuration.class); [EOL] when(duration.getMillis()).thenReturn(1000L); [EOL] int scalar = 2; [EOL] timePeriod.add(duration, scalar); [EOL] assertEquals(2000, timePeriod.getMillis()); [EOL] }
public void add_withNonNullDurationAndNegativeScalar_shouldAddScaledDuration() { [EOL] TimePeriod timePeriod = new TimePeriod(); [EOL] ReadableDuration duration = mock(ReadableDuration.class); [EOL] when(duration.getMillis()).thenReturn(1000L); [EOL] int scalar = -2; [EOL] timePeriod.add(duration, scalar); [EOL] assertEquals(-2000, timePeriod.getMillis()); [EOL] }
public void add_withNullDuration_shouldNotChangeTimePeriod() { [EOL] TimePeriod timePeriod = new TimePeriod(); [EOL] ReadableDuration duration = null; [EOL] int scalar = 2; [EOL] timePeriod.add(duration, scalar); [EOL] assertEquals(0, timePeriod.getMillis()); [EOL] }
public void add_withNullPeriod() { [EOL] ReadablePeriod period = null; [EOL] try { [EOL] add(period); [EOL] fail("Expected IllegalArgumentException for null period"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void add_withNonNullPeriod() { [EOL] ReadablePeriod period = new MockPeriod(); [EOL] add(period); [EOL] }
public void add_WithNonNullPeriod_ShouldAddPeriod() { [EOL] MockReadablePeriod period = new MockReadablePeriod(); [EOL] int scalar = 1; [EOL] long initialMillis = System.currentTimeMillis(); [EOL] DateTime testDateTime = new DateTime(initialMillis, MockChronology.getInstance()); [EOL] long expectedMillis = initialMillis + period.getMillis(); [EOL] testDateTime.add(period, scalar); [EOL] assertEquals(expectedMillis, testDateTime.getMillis()); [EOL] }
public void add_WithNullPeriod_ShouldNotChangeMillis() { [EOL] ReadablePeriod period = null; [EOL] int scalar = 1; [EOL] long initialMillis = System.currentTimeMillis(); [EOL] DateTime testDateTime = new DateTime(initialMillis, MockChronology.getInstance()); [EOL] testDateTime.add(period, scalar); [EOL] assertEquals(initialMillis, testDateTime.getMillis()); [EOL] }
public void testSetChronology() { [EOL] YourClass instance = new YourClass(); [EOL] Chronology chronology = IsoChronology.INSTANCE; // Using IsoChronology as an example implementation of Chronology [EOL] instance.setChronology(chronology); [EOL] assertEquals("Chronology should be set to the provided instance.", chronology, instance.getChronology()); [EOL] }
public void testSetZoneRetainFields_SameZone() { [EOL] DateTimeZone originalZone = DateTimeZone.UTC; [EOL] DateTime testDateTime = new DateTime(originalZone); [EOL] DateTimeZone newZone = originalZone; // Same as original [EOL] testDateTime.setZoneRetainFields(newZone); [EOL] assertEquals(originalZone, testDateTime.getZone()); [EOL] }
public void testSetZoneRetainFields_DifferentZone() { [EOL] DateTimeZone originalZone = DateTimeZone.UTC; [EOL] DateTime testDateTime = new DateTime(originalZone); [EOL] DateTimeZone newZone = DateTimeZone.forID("Europe/Paris"); [EOL] long originalMillis = testDateTime.getMillis(); [EOL] testDateTime.setZoneRetainFields(newZone); [EOL] assertNotEquals(originalZone, testDateTime.getZone()); [EOL] assertEquals(newZone, testDateTime.getZone()); [EOL] assertEquals(originalMillis, originalZone.getMillisKeepLocal(newZone, testDateTime.getMillis())); [EOL] }
public void addMonths_ZeroMonths_NoChange() { [EOL] Time time = new Time(); // Assuming Time is the class name and it has a default constructor [EOL] long initialMillis = time.getMillis(); // Assuming getMillis() method exists and returns the current millis [EOL] time.addMonths(0); [EOL] assertEquals(initialMillis, time.getMillis()); [EOL] }
public void addMonths_PositiveMonths_Change() { [EOL] Time time = new Time(); // Assuming Time is the class name and it has a default constructor [EOL] long initialMillis = time.getMillis(); // Assuming getMillis() method exists and returns the current millis [EOL] time.addMonths(5); // Assuming 5 is a positive number of months [EOL] assertNotEquals(initialMillis, time.getMillis()); [EOL] }
public void addMonths_NegativeMonths_Change() { [EOL] Time time = new Time(); // Assuming Time is the class name and it has a default constructor [EOL] long initialMillis = time.getMillis(); // Assuming getMillis() method exists and returns the current millis [EOL] time.addMonths(-5); // Assuming -5 is a negative number of months [EOL] assertNotEquals(initialMillis, time.getMillis()); [EOL] }
public void setWeekOfWeekyear_ValidWeek_SetsValue() { [EOL] Time time = new Time(); // Assuming Time is the class where setWeekOfWeekyear is defined [EOL] int validWeek = 1; // Assuming 1 is a valid week of the year [EOL] time.setWeekOfWeekyear(validWeek); [EOL] assertEquals(validWeek, time.getWeekOfWeekyear()); [EOL] }
public void setWeekOfWeekyear_InvalidWeek_ThrowsException() { [EOL] Time time = new Time(); [EOL] int invalidWeek = 54; // Assuming 54 is an invalid week of the year [EOL] assertThrows(IllegalArgumentException.class, () -> time.setWeekOfWeekyear(invalidWeek)); [EOL] }
public void addWeeks_ZeroWeeks_NoChange() { [EOL] Time time = new Time(); // Assuming Time is the class name and it has a default constructor [EOL] long initialMillis = time.getMillis(); // Assuming getMillis() method is available to get the current milliseconds [EOL] time.addWeeks(0); [EOL] assertEquals(initialMillis, time.getMillis()); [EOL] }
public void addWeeks_PositiveWeeks_ChangeMillis() { [EOL] Time time = new Time(); // Assuming Time is the class name and it has a default constructor [EOL] long initialMillis = time.getMillis(); // Assuming getMillis() method is available to get the current milliseconds [EOL] int weeksToAdd = 3; // A positive number of weeks to add [EOL] time.addWeeks(weeksToAdd); [EOL] assertNotEquals(initialMillis, time.getMillis()); [EOL] }
public void addWeeks_NegativeWeeks_ChangeMillis() { [EOL] Time time = new Time(); // Assuming Time is the class name and it has a default constructor [EOL] long initialMillis = time.getMillis(); // Assuming getMillis() method is available to get the current milliseconds [EOL] int weeksToSubtract = -2; // A negative number of weeks to subtract [EOL] time.addWeeks(weeksToSubtract); [EOL] assertNotEquals(initialMillis, time.getMillis()); [EOL] }
public void testSetDayOfYear_ValidDay() { [EOL] DateTime dateTime = new DateTime(); [EOL] int dayOfYear = 1; // Assuming 1 is a valid day of the year [EOL] dateTime.setDayOfYear(dayOfYear); [EOL] assertEquals(dayOfYear, dateTime.getDayOfYear()); [EOL] }
public void testSetDayOfYear_InvalidDay() { [EOL] DateTime dateTime = new DateTime(); [EOL] int dayOfYear = -1; // Assuming -1 is an invalid day of the year [EOL] try { [EOL] dateTime.setDayOfYear(dayOfYear); [EOL] fail("Should have thrown an exception for invalid day of year"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void addSeconds_ZeroSeconds_NoChange() { [EOL] Time time = new Time(); // Assuming Time is the class name and it has a default constructor [EOL] long initialMillis = time.getMillis(); // Assuming getMillis() method is available to get the current milliseconds [EOL] time.addSeconds(0); [EOL] assertEquals(initialMillis, time.getMillis()); [EOL] }
public void addSeconds_PositiveSeconds_ChangesMillis() { [EOL] Time time = new Time(); // Assuming Time is the class name and it has a default constructor [EOL] int secondsToAdd = 10; // A positive number of seconds to add [EOL] long initialMillis = time.getMillis(); [EOL] long expectedMillis = time.getChronology().seconds().add(initialMillis, secondsToAdd); // Assuming this is how we expect the millis to be calculated [EOL] time.addSeconds(secondsToAdd); [EOL] assertEquals(expectedMillis, time.getMillis()); [EOL] }
public void addSeconds_NegativeSeconds_ChangesMillis() { [EOL] Time time = new Time(); // Assuming Time is the class name and it has a default constructor [EOL] int secondsToSubtract = -10; // A negative number of seconds to subtract [EOL] long initialMillis = time.getMillis(); [EOL] long expectedMillis = time.getChronology().seconds().add(initialMillis, secondsToSubtract); // Assuming this is how we expect the millis to be calculated [EOL] time.addSeconds(secondsToSubtract); [EOL] assertEquals(expectedMillis, time.getMillis()); [EOL] }
public void testAddMillis_Zero() { [EOL] DateTime dateTime = new DateTime(); [EOL] long initialMillis = dateTime.getMillis(); [EOL] dateTime.addMillis(0); [EOL] assertEquals(initialMillis, dateTime.getMillis()); [EOL] }
public void testAddMillis_NonZero() { [EOL] DateTime dateTime = new DateTime(); [EOL] long initialMillis = dateTime.getMillis(); [EOL] int millisToAdd = 1000; // 1 second [EOL] dateTime.addMillis(millisToAdd); [EOL] assertEquals(initialMillis + millisToAdd, dateTime.getMillis()); [EOL] }
public void testSetDateWithValidInstant() { [EOL] long instant = System.currentTimeMillis(); [EOL] int expectedMillisOfDay = timeObj.getMillisOfDay(); [EOL] timeObj.setDate(instant); [EOL] long actualMillis = timeObj.getMillis(); [EOL] assertEquals(expectedMillisOfDay, actualMillis); [EOL] }
public void testSetDateWithReadableDateTimeAndNonNullZone() { [EOL] ReadableDateTime mockReadableDateTime = mock(ReadableDateTime.class); [EOL] Chronology mockChronology = mock(Chronology.class); [EOL] DateTimeZone mockZone = mock(DateTimeZone.class); [EOL] when(mockReadableDateTime.getChronology()).thenReturn(mockChronology); [EOL] when(mockChronology.getZone()).thenReturn(mockZone); [EOL] when(mockZone.getMillisKeepLocal(any(DateTimeZone.class), anyLong())).thenReturn(12345L); [EOL] YourClass instance = new YourClass(); [EOL] instance.setDate(mockReadableDateTime); [EOL] verify(mockZone).getMillisKeepLocal(any(DateTimeZone.class), anyLong()); [EOL] verify(mockReadableDateTime).getChronology(); [EOL] }
public void testSetDateWithReadableDateTimeAndNullZone() { [EOL] ReadableDateTime mockReadableDateTime = mock(ReadableDateTime.class); [EOL] Chronology mockChronology = mock(Chronology.class); [EOL] when(mockReadableDateTime.getChronology()).thenReturn(mockChronology); [EOL] when(mockChronology.getZone()).thenReturn(null); [EOL] YourClass instance = new YourClass(); [EOL] instance.setDate(mockReadableDateTime); [EOL] verify(mockReadableDateTime).getChronology(); [EOL] verify(mockChronology).getZone(); [EOL] }
public void testSetDateWithNonReadableDateTime() { [EOL] ReadableInstant mockReadableInstant = mock(ReadableInstant.class); [EOL] when(DateTimeUtils.getInstantMillis(mockReadableInstant)).thenReturn(12345L); [EOL] YourClass instance = new YourClass(); [EOL] instance.setDate(mockReadableInstant); [EOL] verifyNoInteractions(mockReadableInstant); [EOL] }
public void testPropertyWithNullType() { [EOL] try { [EOL] DateTime testDateTime = new DateTime(); [EOL] testDateTime.property(null); [EOL] fail("Should have thrown IllegalArgumentException for null DateTimeFieldType"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The DateTimeFieldType must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testPropertyWithUnsupportedType() { [EOL] try { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeFieldType unsupportedType = DateTimeFieldType.centuryOfEra(); [EOL] when(unsupportedType.getField(getChronology())).thenReturn(new UnsupportedDateTimeField(unsupportedType, UnsupportedDurationField.getInstance(DurationFieldType.centuries()))); [EOL] testDateTime.property(unsupportedType); [EOL] fail("Should have thrown IllegalArgumentException for unsupported DateTimeFieldType"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertTrue(ex.getMessage().contains("Field '" + unsupportedType + "' is not supported")); [EOL] } [EOL] }
public void testPropertyWithSupportedType() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeFieldType supportedType = DateTimeFieldType.year(); [EOL] when(supportedType.getField(getChronology())).thenReturn(ISOChronology.getInstance().year()); [EOL] Property property = testDateTime.property(supportedType); [EOL] assertNotNull(property); [EOL] assertEquals(supportedType.getField(getChronology()), property.getField()); [EOL] }
public void testCloneSuccessful() throws Exception { [EOL] YourClass instance = new YourClass(); [EOL] Object clonedInstance = instance.clone(); [EOL] assertNotNull(clonedInstance); [EOL] assertNotSame(instance, clonedInstance); [EOL] assertEquals(instance.getClass(), clonedInstance.getClass()); [EOL] }
public void testCloneThrowsInternalError() { [EOL] YourClass instance = new NonCloneableYourClass(); [EOL] try { [EOL] instance.clone(); [EOL] fail("Expected an InternalError to be thrown"); [EOL] } catch (InternalError ex) { [EOL] assertEquals("Clone error", ex.getMessage()); [EOL] } [EOL] }
public void testToString() { [EOL] DateTime dateTime = new DateTime(2023, 4, 1, 12, 0); [EOL] String expected = ISODateTimeFormat.dateTime().print(dateTime); [EOL] assertEquals(expected, dateTime.toString()); [EOL] }
public void testPropertyWithNonNullInstantAndField() { [EOL] MutableDateTime instant = new MutableDateTime(); [EOL] DateTimeField field = new MockDateTimeField(); [EOL] Property property = new Property(instant, field); [EOL] assertNotNull(property.iInstant); [EOL] assertNotNull(property.iField); [EOL] }
public void testPropertyWithNullInstant() { [EOL] DateTimeField field = new MockDateTimeField(); [EOL] try { [EOL] new Property(null, field); [EOL] fail("Should have thrown IllegalArgumentException for null instant"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testPropertyWithNullField() { [EOL] MutableDateTime instant = new MutableDateTime(); [EOL] try { [EOL] new Property(instant, null); [EOL] fail("Should have thrown IllegalArgumentException for null field"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testGetField() { [EOL] DateTimeField expectedField = // initialize with a valid DateTimeField instance [EOL] YourClass instance = new YourClass(expectedField); [EOL] DateTimeField actualField = instance.getField(); [EOL] assertEquals(expectedField, actualField); [EOL] }
protected long getMillis() { [EOL] return iInstant.getMillis(); [EOL] }
public void testGetMutableDateTime_NonNullInstance() { [EOL] MutableDateTime expected = new MutableDateTime(); [EOL] TimeClass instance = new TimeClass(expected); [EOL] MutableDateTime result = instance.getMutableDateTime(); [EOL] assertNotNull(result); [EOL] assertEquals(expected, result); [EOL] }
public void testSetWithValidTextAndLocale() { [EOL] MutableDateTime dateTime = new MutableDateTime(); [EOL] long initialMillis = dateTime.getMillis(); [EOL] String validText = "some valid text for the field"; [EOL] Locale locale = Locale.ENGLISH; [EOL] MutableDateTime updatedDateTime = dateTime.set(validText, locale); [EOL] assertNotEquals(initialMillis, updatedDateTime.getMillis()); [EOL] }
public void testSetWithInvalidText() { [EOL] MutableDateTime dateTime = new MutableDateTime(); [EOL] String invalidText = "invalid text"; [EOL] Locale locale = Locale.ENGLISH; [EOL] try { [EOL] dateTime.set(invalidText, locale); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetWithNullLocale() { [EOL] MutableDateTime dateTime = new MutableDateTime(); [EOL] String validText = "some valid text for the field"; [EOL] MutableDateTime updatedDateTime = dateTime.set(validText, null); [EOL] assertNotNull(updatedDateTime); [EOL] }
public void testSetWithNullFormatter() { [EOL] MutableDateTime dateTime = new MutableDateTime(); [EOL] MutableDateTime result = dateTime.set("2023-01-01T00:00:00.000Z", null); [EOL] assertNotNull(result); [EOL] assertEquals(dateTime, result); [EOL] }
public void testSetWithValidText() { [EOL] MutableDateTime dateTime = new MutableDateTime(); [EOL] MutableDateTime result = dateTime.set("2023-01-01T00:00:00.000Z"); [EOL] assertNotNull(result); [EOL] assertEquals(dateTime, result); [EOL] assertEquals(new DateTime("2023-01-01T00:00:00.000Z").getMillis(), dateTime.getMillis()); [EOL] }
public void testRoundFloor() { [EOL] MutableDateTime mutableDateTime = new MutableDateTime(); [EOL] long originalMillis = mutableDateTime.getMillis(); [EOL] DateTimeField field = mutableDateTime.getField(); [EOL] long expectedMillis = field.roundFloor(originalMillis); [EOL] MutableDateTime roundedDateTime = mutableDateTime.roundFloor(); [EOL] assertEquals(expectedMillis, roundedDateTime.getMillis()); [EOL] }
public void testRoundHalfEven_RoundsDown() { [EOL] MutableDateTime dateTime = new MutableDateTime(2023, 4, 15, 12, 30, 0, 0); // Assume this is half to even [EOL] MutableDateTime rounded = dateTime.roundHalfEven(); [EOL] assertEquals(new MutableDateTime(2023, 4, 15, 12, 0, 0, 0), rounded); [EOL] }
public void testRoundHalfEven_RoundsUp() { [EOL] MutableDateTime dateTime = new MutableDateTime(2023, 4, 15, 12, 30, 1, 0); // Assume this is over half [EOL] MutableDateTime rounded = dateTime.roundHalfEven(); [EOL] assertEquals(new MutableDateTime(2023, 4, 15, 13, 0, 0, 0), rounded); [EOL] }
public void testRoundHalfEven_ExactHalfToEven() { [EOL] MutableDateTime dateTime = new MutableDateTime(2023, 4, 15, 12, 30, 0, 0); // Assume this is exactly half [EOL] dateTime.addMinutes(15); // Make it exactly half [EOL] MutableDateTime rounded = dateTime.roundHalfEven(); [EOL] assertEquals(new MutableDateTime(2023, 4, 15, 12, 0, 0, 0), rounded); [EOL] }
public void testRoundHalfEven_ExactHalfToOdd() { [EOL] MutableDateTime dateTime = new MutableDateTime(2023, 4, 15, 11, 30, 0, 0); // Assume this is exactly half [EOL] dateTime.addMinutes(15); // Make it exactly half [EOL] MutableDateTime rounded = dateTime.roundHalfEven(); [EOL] assertEquals(new MutableDateTime(2023, 4, 15, 13, 0, 0, 0), rounded); [EOL] }
private Object readResolve() { [EOL] return Hours.hours(getValue()); [EOL] }
public void testPlus_ZeroHours() { [EOL] Hours initialHours = Hours.hours(5); [EOL] Hours result = initialHours.plus(0); [EOL] assertSame("Expected the same object to be returned", initialHours, result); [EOL] }
public void testPlus_NonZeroHours() { [EOL] Hours initialHours = Hours.hours(5); [EOL] Hours result = initialHours.plus(3); [EOL] assertEquals("Expected the sum of hours", 8, result.getValue()); [EOL] }
public void testMinus_Zero() { [EOL] Hours hours = Hours.hours(5); [EOL] Hours result = hours.minus(0); [EOL] assertEquals(5, result.getHours()); [EOL] }
public void testMinus_Positive() { [EOL] Hours hours = Hours.hours(5); [EOL] Hours result = hours.minus(3); [EOL] assertEquals(2, result.getHours()); [EOL] }
public void testMinus_Negative() { [EOL] Hours hours = Hours.hours(5); [EOL] Hours result = hours.minus(-3); [EOL] assertEquals(8, result.getHours()); [EOL] }
public void testMultipliedBy_Positive() { [EOL] Hours hours = Hours.hours(2); [EOL] Hours result = hours.multipliedBy(3); [EOL] assertEquals(6, result.getHours()); [EOL] }
public void testMultipliedBy_Negative() { [EOL] Hours hours = Hours.hours(2); [EOL] Hours result = hours.multipliedBy(-3); [EOL] assertEquals(-6, result.getHours()); [EOL] }
public void testMultipliedBy_Zero() { [EOL] Hours hours = Hours.hours(2); [EOL] Hours result = hours.multipliedBy(0); [EOL] assertEquals(0, result.getHours()); [EOL] }
public void testMultipliedBy_One() { [EOL] Hours hours = Hours.hours(2); [EOL] Hours result = hours.multipliedBy(1); [EOL] assertEquals(2, result.getHours()); [EOL] }
public void testAddWithEqualConverterAndNonNullRemoved() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{converter1, converter2}); [EOL] Converter[] removed = new Converter[1]; [EOL] ConverterSet result = set.add(converter1, removed); [EOL] assertSame(set, result); [EOL] assertNull(removed[0]); [EOL] }
public void testAddWithSameSupportedTypeAndNonNullRemoved() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{converter1, converter2}); [EOL] Converter[] removed = new Converter[1]; [EOL] ConverterSet result = set.add(converter3, removed); [EOL] assertNotSame(set, result); [EOL] assertNotNull(removed[0]); [EOL] assertEquals(converter2, removed[0]); [EOL] }
public void testAddWithDifferentConverterAndNonNullRemoved() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{converter1, converter2}); [EOL] Converter[] removed = new Converter[1]; [EOL] ConverterSet result = set.add(converter3, removed); [EOL] assertNotSame(set, result); [EOL] assertNull(removed[0]); [EOL] }
public void testAddWithEqualConverterAndNullRemoved() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{converter1, converter2}); [EOL] ConverterSet result = set.add(converter1, null); [EOL] assertSame(set, result); [EOL] }
public void testAddWithDifferentConverterAndNullRemoved() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{converter1, converter2}); [EOL] ConverterSet result = set.add(converter3, null); [EOL] assertNotSame(set, result); [EOL] }
public void testSelectSlowWithMatchingType() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{new MockConverter(String.class), new MockConverter(Integer.class)}); [EOL] Converter result = selectSlow(set, String.class); [EOL] assertNotNull(result); [EOL] assertEquals(MockConverter.class, result.getClass()); [EOL] assertEquals(String.class, result.getSupportedType()); [EOL] }
public void testSelectSlowWithNonMatchingType() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{new MockConverter(String.class), new MockConverter(Integer.class)}); [EOL] Converter result = selectSlow(set, Double.class); [EOL] assertNull(result); [EOL] }
public void testSelectSlowWithNullType() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{new MockConverter(String.class), new MockConverter(Integer.class)}); [EOL] Converter result = selectSlow(set, null); [EOL] assertNull(result); [EOL] }
public void testSelectSlowWithEmptyConverterSet() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{}); [EOL] Converter result = selectSlow(set, String.class); [EOL] assertNull(result); [EOL] }
public void testSelectSlowWithSingleConverter() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{new MockConverter(String.class)}); [EOL] Converter result = selectSlow(set, String.class); [EOL] assertNotNull(result); [EOL] assertEquals(MockConverter.class, result.getClass()); [EOL] assertEquals(String.class, result.getSupportedType()); [EOL] }
public void testSelectSlowWithAmbiguousConverters() { [EOL] ConverterSet set = new ConverterSet(new Converter[]{new MockConverter(CharSequence.class), new MockConverter(String.class)}); [EOL] try { [EOL] selectSlow(set, String.class); [EOL] fail("Expected an IllegalStateException to be thrown"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
public void testToParser_WhenFormatterIsParser() { [EOL] DateTimeFormatter dtf = createFormatterThatIsParser(); [EOL] DateTimeParser result = dtf.toParser(); [EOL] assertNotNull(result); [EOL] } [EOL] public void testToParser_WhenFormatterIsNotParser_ThrowsException() { [EOL] DateTimeFormatter dtf = createFormatterThatIsNotParser(); [EOL] try { [EOL] dtf.toParser(); [EOL] fail("Expected UnsupportedOperationException to be thrown"); [EOL] } catch (UnsupportedOperationException e) { [EOL] assertEquals("Parsing is not supported", e.getMessage()); [EOL] } [EOL] }
public boolean isFormatter(String formatter) { [EOL] if (formatter == null || formatter.isEmpty()) { [EOL] return false; [EOL] } [EOL] return isValidFormatter(formatter); [EOL] } [EOL] public boolean canBuildFormatter() { [EOL] return isFormatter(getFormatter()); [EOL] }
public void testAppendDateTimeParserWithNull() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.append(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendDateTimeParserWithValidParser() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeParser parser = new DateTimeParser() { [EOL] public int estimateParsedLength() { [EOL] return 0; [EOL] } [EOL] public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) { [EOL] return position; [EOL] } [EOL] }; [EOL] builder.append(parser); [EOL] assertNotNull("Builder should not return null after appending parser", builder); [EOL] }
public void testAppendWithValidPrinterAndParser() { [EOL] DateTimePrinter printer = mock(DateTimePrinter.class); [EOL] DateTimeParser parser = mock(DateTimeParser.class); [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder returnedBuilder = builder.append(printer, parser); [EOL] assertNotNull(returnedBuilder); [EOL] assertSame(builder, returnedBuilder); [EOL] }
public void testAppendWithNullPrinter() { [EOL] DateTimeParser parser = mock(DateTimeParser.class); [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.append(null, parser); [EOL] fail("Should have thrown IllegalArgumentException for null printer"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendWithNullParser() { [EOL] DateTimePrinter printer = mock(DateTimePrinter.class); [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.append(printer, null); [EOL] fail("Should have thrown IllegalArgumentException for null parser"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendOptionalWithNullParser() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendOptional(null); [EOL] fail("Should have thrown IllegalArgumentException for null parser"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testAppendOptionalWithValidParser() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeParser parser = mock(DateTimeParser.class); [EOL] DateTimeFormatterBuilder returnedBuilder = builder.appendOptional(parser); [EOL] assertNotNull("Returned builder should not be null", returnedBuilder); [EOL] assertNotSame("Returned builder should be a new instance", builder, returnedBuilder); [EOL] }

public void testCheckParserWithNullParser() { [EOL] try { [EOL] checkParser(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("No parser supplied", e.getMessage()); [EOL] } [EOL] }
public void testAppendClockhourOfDay_MinDigitsLessThanOne() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] try { [EOL] builder.appendClockhourOfDay(0); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAppendClockhourOfDay_ValidMinDigits() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] builder.appendClockhourOfDay(1); [EOL] }
public void testAppendTwoDigitYearWithPivot() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder result = builder.appendTwoDigitYear(2000, false); [EOL] assertNotNull(result); [EOL] }
public void testAppendTwoDigitYearWithLenientParse() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder result = builder.appendTwoDigitYear(2000, true); [EOL] assertNotNull(result); [EOL] }
public void testAppendMonthOfYearText() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder returnedBuilder = builder.appendMonthOfYearText(); [EOL] assertNotNull(returnedBuilder); [EOL] assertSame(builder, returnedBuilder); [EOL] }
public void testAppendTimeZoneId() { [EOL] DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder(); [EOL] DateTimeFormatterBuilder result = builder.appendTimeZoneId(); [EOL] assertNotNull(result); [EOL] }
private boolean isPrinter(Object f) { [EOL] return f instanceof Printer; [EOL] } [EOL] private boolean isParser(Object f) { [EOL] return f instanceof Parser; [EOL] } [EOL] class Printer {} [EOL] class Parser {} [EOL] public void testIsFormatterWithPrinter() { [EOL] Printer printer = new Printer(); [EOL] assertTrue(isFormatter(printer)); [EOL] } [EOL] public void testIsFormatterWithParser() { [EOL] Parser parser = new Parser(); [EOL] assertTrue(isFormatter(parser)); [EOL] } [EOL] public void testIsFormatterWithNonFormatter() { [EOL] Object nonFormatter = new Object(); [EOL] assertFalse(isFormatter(nonFormatter)); [EOL] }
public void testParseInto_PositiveNumber() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(); [EOL] String text = "12345"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(5, result); [EOL] assertEquals(12345, bucket.getFieldValue(iFieldType)); [EOL] }
public void testParseInto_NegativeNumber() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(); [EOL] String text = "-123"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(4, result); [EOL] assertEquals(-123, bucket.getFieldValue(iFieldType)); [EOL] }
public void testParseInto_InvalidPosition() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(); [EOL] String text = "12345"; [EOL] int position = 6; // position out of bounds [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] }
public void testParseInto_EmptyString() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(); [EOL] String text = ""; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] }
public void testParseInto_InvalidCharacter() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(); [EOL] String text = "12a45"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(2, result); [EOL] assertEquals(12, bucket.getFieldValue(iFieldType)); [EOL] }
public void testParseInto_SignedWithNoDigits() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(); [EOL] String text = "-"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] }
public void testParseInto_SignedWithInvalidNextChar() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(); [EOL] String text = "-a"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] }
public void testParseInto_LongNumber() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(); [EOL] String text = "1234567890"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(10, result); [EOL] assertEquals(1234567890, bucket.getFieldValue(iFieldType)); [EOL] }
public void testParseInto_MaxParsedDigits() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(); [EOL] String text = "123456789012345"; [EOL] int position = 0; [EOL] iMaxParsedDigits = 5; // Assuming iMaxParsedDigits is a modifiable field [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(5, result); [EOL] assertEquals(12345, bucket.getFieldValue(iFieldType)); [EOL] }
public void testParseInto_StringIndexOutOfBoundsException() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(); [EOL] String text = "+"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] }
public void testTwoDigitYearWithValidInput() { [EOL] DateTimeFieldType type = DateTimeFieldType.year(); [EOL] int pivot = 2000; [EOL] boolean lenientParse = true; [EOL] TwoDigitYear twoDigitYear = new TwoDigitYear(type, pivot, lenientParse); [EOL] assertNotNull(twoDigitYear); [EOL] assertEquals(type, twoDigitYear.iType); [EOL] assertEquals(pivot, twoDigitYear.iPivot); [EOL] assertEquals(lenientParse, twoDigitYear.iLenientParse); [EOL] }
public void testTwoDigitYearWithNonLenientParse() { [EOL] DateTimeFieldType type = DateTimeFieldType.year(); [EOL] int pivot = 2000; [EOL] boolean lenientParse = false; [EOL] TwoDigitYear twoDigitYear = new TwoDigitYear(type, pivot, lenientParse); [EOL] assertNotNull(twoDigitYear); [EOL] assertEquals(type, twoDigitYear.iType); [EOL] assertEquals(pivot, twoDigitYear.iPivot); [EOL] assertEquals(lenientParse, twoDigitYear.iLenientParse); [EOL] }
public void testParseInto_LenientParseFalse_ShortInput() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "1"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] }
public void testParseInto_LenientParseFalse_ExactLength() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "12"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + 2, result); [EOL] }
public void testParseInto_LenientParseTrue_SignChar() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "+34"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + 3, result); [EOL] }
public void testParseInto_LenientParseTrue_NegativeSignChar() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "-34"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + 3, result); [EOL] }
public void testParseInto_LenientParseTrue_NonDigit() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "a5"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] }
public void testParseInto_LenientParseTrue_LongInput() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "123456789"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + 9, result); [EOL] }
public void testParseInto_LenientParseTrue_EmptyInput() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = ""; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] }
public void testParseInto_LenientParseTrue_InvalidChar() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "+-"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] }
public void testParseInto_LenientParseTrue_InvalidCharAfterSign() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "+a"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] }
public void testParseInto_LenientParseTrue_SingleDigit() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "3"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] }
public void testParseInto_LenientParseTrue_SingleDigitWithSign() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "+3"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] }
public void testParseInto_LenientParseTrue_TwoDigits() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "34"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + 2, result); [EOL] }
public void testParseInto_LenientParseTrue_ThreeDigits() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "345"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + 3, result); [EOL] }
public void testParseInto_LenientParseTrue_InvalidFirstChar() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "a1"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] }
public void testParseInto_LenientParseTrue_InvalidSecondChar() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "1a"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] }
public int estimatePrintedLength() { [EOL] return 2; [EOL] }
public void printTo_validInstantAndChrono() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] int displayOffset = 0; [EOL] DateTimeZone displayZone = DateTimeZone.getDefault(); [EOL] Locale locale = Locale.getDefault(); [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] int year = getTwoDigitYear(instant, chrono); [EOL] assertTrue(buf.length() > 0); [EOL] assertTrue(buf.toString().contains(String.valueOf(year))); [EOL] }
public void printTo_negativeTwoDigitYear() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] int displayOffset = 0; [EOL] DateTimeZone displayZone = DateTimeZone.getDefault(); [EOL] Locale locale = Locale.getDefault(); [EOL] instant -= 100L * 365 * 24 * 60 * 60 * 1000; // Subtract 100 years approximately [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertTrue(buf.length() > 0); [EOL] assertTrue(buf.toString().contains("\ufffd\ufffd")); [EOL] }
public void testGetTwoDigitYearWithPositiveYear() { [EOL] long instant = /* some positive instant representing a year */; [EOL] Chronology chrono = /* obtain a Chronology instance */; [EOL] int expected = /* expected two digit year */; [EOL] int actual = getTwoDigitYear(instant, chrono); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetTwoDigitYearWithNegativeYear() { [EOL] long instant = /* some negative instant representing a year */; [EOL] Chronology chrono = /* obtain a Chronology instance */; [EOL] int expected = /* expected two digit year */; [EOL] int actual = getTwoDigitYear(instant, chrono); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetTwoDigitYearWithRuntimeException() { [EOL] long instant = /* some instant that will cause a RuntimeException */; [EOL] Chronology chrono = /* obtain a Chronology instance that will cause the exception */; [EOL] int expected = -1; [EOL] int actual = getTwoDigitYear(instant, chrono); [EOL] assertEquals(expected, actual); [EOL] }
public void testParseInto_CacheMissAndMaxDifferenceGreaterThan32() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "SomeText"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] }
public void testParseInto_CacheMissAndLocaleEnglishEraField() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, Locale.ENGLISH, 0); [EOL] String text = "CE"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertTrue(result > 0); [EOL] }
public void testParseInto_CacheHit() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, Locale.ENGLISH, 0); [EOL] String text = "CE"; [EOL] int position = 0; [EOL] parseInto(bucket, text, position); [EOL] int result = parseInto(bucket, text, position); [EOL] assertTrue(result > 0); [EOL] }
public void testParseInto_ValidValueNotInSet() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, Locale.ENGLISH, 0); [EOL] String text = "InvalidValue"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] }
public void testParseInto_ValidValueInSet() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, Locale.ENGLISH, 0); [EOL] String text = "BCE"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertTrue(result > 0); [EOL] }
public void testParseInto_ValidInput() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "12345"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(5, result); [EOL] }
public void testParseInto_InvalidPosition() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "12345"; [EOL] int position = 6; // position out of bounds [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] }
public void testParseInto_InvalidCharacter() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "12a45"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] }
public void testParseInto_ValueTooLarge() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "9999999999"; // value larger than Integer.MAX_VALUE after parsing [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] }
public void testParseInto_EmptyString() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = ""; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] }
public void testParseInto_MaxDigits() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, null, 0); [EOL] String text = "123456789012345"; // longer than iMaxDigits [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + 5, result); [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL] int limit = text.length() - position; [EOL] if (iZeroOffsetParseText != null) { [EOL] if (iZeroOffsetParseText.length() == 0) { [EOL] if (limit > 0) { [EOL] char c = text.charAt(position); [EOL] if (c == '-' || c == '+') { [EOL] break zeroOffset; [EOL] } [EOL] } [EOL] bucket.setOffset(Integer.valueOf(0)); [EOL] return position; [EOL] } [EOL] if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) { [EOL] bucket.setOffset(Integer.valueOf(0)); [EOL] return position + iZeroOffsetParseText.length(); [EOL] } [EOL] } [EOL] if (limit <= 1) { [EOL] return ~position; [EOL] } [EOL] boolean negative; [EOL] char c = text.charAt(position); [EOL] if (c == '-') { [EOL] negative = true; [EOL] } else if (c == '+') { [EOL] negative = false; [EOL] } else { [EOL] return ~position; [EOL] } [EOL] limit--; [EOL] position++; [EOL] if (digitCount(text, position, 2) < 2) { [EOL] return ~position; [EOL] } [EOL] int offset; [EOL] int hours = FormatUtils.parseTwoDigits(text, position); [EOL] if (hours > 23) { [EOL] return ~position; [EOL] } [EOL] offset = hours * DateTimeConstants.MILLIS_PER_HOUR; [EOL] limit -= 2; [EOL] position += 2; [EOL] if (limit <= 0) { [EOL] break parse; [EOL] } [EOL] boolean expectSeparators; [EOL] c = text.charAt(position); [EOL] if (c == ':') { [EOL] expectSeparators = true; [EOL] limit--; [EOL] position++; [EOL] } else if (c >= '0' && c <= '9') { [EOL] expectSeparators = false; [EOL] } else { [EOL] break parse; [EOL] } [EOL] int count = digitCount(text, position, 2); [EOL] if (count == 0 && !expectSeparators) { [EOL] break parse; [EOL] } else if (count < 2) { [EOL] return ~position; [EOL] } [EOL] int minutes = FormatUtils.parseTwoDigits(text, position); [EOL] if (minutes > 59) { [EOL] return ~position; [EOL] } [EOL] offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL] limit -= 2; [EOL] position += 2; [EOL] if (limit <= 0) { [EOL] break parse; [EOL] } [EOL] if (expectSeparators) { [EOL] if (text.charAt(position) != ':') { [EOL] break parse; [EOL] } [EOL] limit--; [EOL] position++; [EOL] } [EOL] count = digitCount(text, position, 2); [EOL] if (count == 0 && !expectSeparators) { [EOL] break parse; [EOL] } else if (count < 2) { [EOL] return ~position; [EOL] } [EOL] int seconds = FormatUtils.parseTwoDigits(text, position); [EOL] if (seconds > 59) { [EOL] return ~position; [EOL] } [EOL] offset += seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL] limit -= 2; [EOL] position += 2; [EOL] if (limit <= 0) { [EOL] break parse; [EOL] } [EOL] if (expectSeparators) { [EOL] if (text.charAt(position) != '.' && text.charAt(position) != ',') { [EOL] break parse; [EOL] } [EOL] limit--; [EOL] position++; [EOL] } [EOL] count = digitCount(text, position, 3); [EOL] if (count == 0 && !expectSeparators) { [EOL] break parse; [EOL] } else if (count < 1) { [EOL] return ~position; [EOL] } [EOL] offset += (text.charAt(position++) - '0') * 100; [EOL] if (count > 1) { [EOL] offset += (text.charAt(position++) - '0') * 10; [EOL] if (count > 2) { [EOL] offset += text.charAt(position++) - '0'; [EOL] } [EOL] } [EOL] bucket.setOffset(Integer.valueOf(negative ? -offset : offset)); [EOL] return position; [EOL] }
public void testEstimatePrintedLength() { [EOL] Time time = new Time(); [EOL] int estimatedLength = time.estimatePrintedLength(); [EOL] assertEquals(Time.MAX_LENGTH, estimatedLength); [EOL] }
public void testPrintToWithNonNullDisplayZone() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] int displayOffset = 0; [EOL] DateTimeZone displayZone = DateTimeZone.forID("Europe/London"); [EOL] Locale locale = Locale.UK; [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertTrue(buf.toString().equals(displayZone.getID())); [EOL] }
public void testPrintToWithNullDisplayZone() { [EOL] StringBuffer buf = new StringBuffer(); [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] int displayOffset = 0; [EOL] DateTimeZone displayZone = null; [EOL] Locale locale = Locale.UK; [EOL] printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL] assertTrue(buf.toString().equals("")); [EOL] }
public int estimateParsedLength() { [EOL] return MAX_LENGTH; [EOL] }
public void testParseInto_NoMatch() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "NoMatchZone"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(~position, result); [EOL] } [EOL] public void testParseInto_MatchAtStart() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "Europe/London and some other text"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + "Europe/London".length(), result); [EOL] } [EOL] public void testParseInto_MatchNotAtStart() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "Some text followed by Europe/London"; [EOL] int position = 17; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + "Europe/London".length(), result); [EOL] } [EOL] public void testParseInto_MatchWithLongerID() { [EOL] DateTimeParserBucket bucket = new DateTimeParserBucket(0, null, null, 0, 0); [EOL] String text = "Europe/London/SomeOtherText Europe/London"; [EOL] int position = 0; [EOL] int result = parseInto(bucket, text, position); [EOL] assertEquals(position + "Europe/London/SomeOtherText".length(), result); [EOL] }
public void testMatchingParserWithNullArray() { [EOL] DateTimeParser[] parsers = null; [EOL] try { [EOL] new MatchingParser(parsers); [EOL] fail("Should have thrown IllegalArgumentException for null array"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testMatchingParserWithEmptyArray() { [EOL] DateTimeParser[] parsers = new DateTimeParser[0]; [EOL] MatchingParser parser = new MatchingParser(parsers); [EOL] assertEquals(0, parser.iParsedLengthEstimate); [EOL] } [EOL] public void testMatchingParserWithAllNullParsers() { [EOL] DateTimeParser[] parsers = new DateTimeParser[3]; [EOL] MatchingParser parser = new MatchingParser(parsers); [EOL] assertEquals(0, parser.iParsedLengthEstimate); [EOL] } [EOL] public void testMatchingParserWithMixedNullParsers() { [EOL] DateTimeParser[] parsers = new DateTimeParser[3]; [EOL] parsers[1] = new DateTimeParser() { [EOL] public int estimateParsedLength() { [EOL] return 5; [EOL] } [EOL] public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) { [EOL] return position; [EOL] } [EOL] }; [EOL] MatchingParser parser = new MatchingParser(parsers); [EOL] assertEquals(5, parser.iParsedLengthEstimate); [EOL] } [EOL] public void testMatchingParserWithNonNullParsers() { [EOL] DateTimeParser[] parsers = new DateTimeParser[2]; [EOL] parsers[0] = new DateTimeParser() { [EOL] public int estimateParsedLength() { [EOL] return 10; [EOL] } [EOL] public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) { [EOL] return position; [EOL] } [EOL] }; [EOL] parsers[1] = new DateTimeParser() { [EOL] public int estimateParsedLength() { [EOL] return 20; [EOL] } [EOL] public int parseInto(DateTimeParserBucket bucket, CharSequence text, int position) { [EOL] return position; [EOL] } [EOL] }; [EOL] MatchingParser parser = new MatchingParser(parsers); [EOL] assertEquals(20, parser.iParsedLengthEstimate); [EOL] }
public void testEstimateParsedLength() { [EOL] TimeParser parser = new TimeParser(); [EOL] int expected = 10; // Example value that might be set during object initialization [EOL] parser.iParsedLengthEstimate = expected; // Directly setting the value for the test case [EOL] int actual = parser.estimateParsedLength(); [EOL] assertEquals(expected, actual); [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL] DateTimeParser[] parsers = iParsers; [EOL] int length = parsers.length; [EOL] final Object originalState = bucket.saveState(); [EOL] boolean isOptional = false; [EOL] int bestValidPos = position; [EOL] Object bestValidState = null; [EOL] int bestInvalidPos = position; [EOL] for (int i = 0; i < length; i++) { [EOL] DateTimeParser parser = parsers[i]; [EOL] if (parser == null) { [EOL] if (bestValidPos <= position) { [EOL] return position; [EOL] } [EOL] isOptional = true; [EOL] break; [EOL] } [EOL] int parsePos = parser.parseInto(bucket, text, position); [EOL] if (parsePos >= position) { [EOL] if (parsePos > bestValidPos) { [EOL] if (parsePos >= text.length() || (i + 1) >= length || parsers[i + 1] == null) { [EOL] return parsePos; [EOL] } [EOL] bestValidPos = parsePos; [EOL] bestValidState = bucket.saveState(); [EOL] } [EOL] } else { [EOL] if (parsePos < 0) { [EOL] parsePos = ~parsePos; [EOL] if (parsePos > bestInvalidPos) { [EOL] bestInvalidPos = parsePos; [EOL] } [EOL] } [EOL] } [EOL] bucket.restoreState(originalState); [EOL] } [EOL] if (bestValidPos > position || (bestValidPos == position && isOptional)) { [EOL] if (bestValidState != null) { [EOL] bucket.restoreState(bestValidState); [EOL] } [EOL] return bestValidPos; [EOL] } [EOL] return ~bestInvalidPos; [EOL] }
public void testFromDateFieldsWithNullDate() { [EOL] try { [EOL] TimeOfDay.fromDateFields(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The date must not be null", e.getMessage()); [EOL] } [EOL] }
public void testFromDateFieldsWithValidDate() { [EOL] Date date = new Date(); [EOL] date.setHours(13); [EOL] date.setMinutes(45); [EOL] date.setSeconds(30); [EOL] date.setTime(date.getTime() - date.getTime() % 1000 + 500); // Set milliseconds to 500 [EOL] TimeOfDay result = TimeOfDay.fromDateFields(date); [EOL] assertEquals(13, result.getHourOfDay()); [EOL] assertEquals(45, result.getMinuteOfHour()); [EOL] assertEquals(30, result.getSecondOfMinute()); [EOL] assertEquals(500, result.getMillisOfSecond()); [EOL] }
public void testTimeOfDayWithChronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(chronology); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(chronology, timeOfDay.getChronology()); [EOL] }
public void testTimeOfDayDefaultConstructor() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayWithDateTimeZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] TimeOfDay timeOfDay = new TimeOfDay(zone); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(zone, timeOfDay.getChronology().getZone()); [EOL] }
public void testTimeOfDayWithLong() { [EOL] long instant = System.currentTimeMillis(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayWithLongAndChronology() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant, chronology); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(chronology, timeOfDay.getChronology()); [EOL] }
public void testTimeOfDayWithObject() { [EOL] Object instant = new Date(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayWithObjectAndChronology() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant, chronology); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(chronology, timeOfDay.getChronology()); [EOL] }
public void testTimeOfDayWithHourAndMinute() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 30); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(10, timeOfDay.getHourOfDay()); [EOL] assertEquals(30, timeOfDay.getMinuteOfHour()); [EOL] }
public void testTimeOfDayWithHourMinuteAndChronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 30, chronology); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(chronology, timeOfDay.getChronology()); [EOL] }
public void testTimeOfDayWithHourMinuteSecond() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 30, 20); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(10, timeOfDay.getHourOfDay()); [EOL] assertEquals(30, timeOfDay.getMinuteOfHour()); [EOL] assertEquals(20, timeOfDay.getSecondOfMinute()); [EOL] }
public void testTimeOfDayWithHourMinuteSecondAndChronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 30, 20, chronology); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(chronology, timeOfDay.getChronology()); [EOL] }
public void testTimeOfDayWithHourMinuteSecondMillis() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 30, 20, 500); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(10, timeOfDay.getHourOfDay()); [EOL] assertEquals(30, timeOfDay.getMinuteOfHour()); [EOL] assertEquals(20, timeOfDay.getSecondOfMinute()); [EOL] assertEquals(500, timeOfDay.getMillisOfSecond()); [EOL] }
public void testTimeOfDayWithHourMinuteSecondMillisAndChronology() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 30, 20, 500, chronology); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(chronology, timeOfDay.getChronology()); [EOL] }
public void testTimeOfDayWithHourAndMinute() { [EOL] TimeOfDay time = new TimeOfDay(9, 30); [EOL] assertEquals(9, time.getHourOfDay()); [EOL] assertEquals(30, time.getMinuteOfHour()); [EOL] assertEquals(0, time.getSecondOfMinute()); [EOL] assertEquals(0, time.getMillisOfSecond()); [EOL] }
public void testTimeOfDayWithHourMinuteSecond() { [EOL] TimeOfDay time = new TimeOfDay(9, 30, 15); [EOL] assertEquals(9, time.getHourOfDay()); [EOL] assertEquals(30, time.getMinuteOfHour()); [EOL] assertEquals(15, time.getSecondOfMinute()); [EOL] assertEquals(0, time.getMillisOfSecond()); [EOL] }
public void testTimeOfDayWithHourMinuteSecondMillis() { [EOL] TimeOfDay time = new TimeOfDay(9, 30, 15, 250); [EOL] assertEquals(9, time.getHourOfDay()); [EOL] assertEquals(30, time.getMinuteOfHour()); [EOL] assertEquals(15, time.getSecondOfMinute()); [EOL] assertEquals(250, time.getMillisOfSecond()); [EOL] }
public void testTimeOfDayWithChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay time = new TimeOfDay(9, 30, chronology); [EOL] assertEquals(9, time.getHourOfDay()); [EOL] assertEquals(30, time.getMinuteOfHour()); [EOL] assertEquals(0, time.getSecondOfMinute()); [EOL] assertEquals(0, time.getMillisOfSecond()); [EOL] assertSame(chronology, time.getChronology()); [EOL] }
public void testTimeOfDayWithHourMinuteSecondChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay time = new TimeOfDay(9, 30, 15, chronology); [EOL] assertEquals(9, time.getHourOfDay()); [EOL] assertEquals(30, time.getMinuteOfHour()); [EOL] assertEquals(15, time.getSecondOfMinute()); [EOL] assertEquals(0, time.getMillisOfSecond()); [EOL] assertSame(chronology, time.getChronology()); [EOL] }
public void testTimeOfDayWithHourMinuteSecondMillisChronology() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay time = new TimeOfDay(9, 30, 15, 250, chronology); [EOL] assertEquals(9, time.getHourOfDay()); [EOL] assertEquals(30, time.getMinuteOfHour()); [EOL] assertEquals(15, time.getSecondOfMinute()); [EOL] assertEquals(250, time.getMillisOfSecond()); [EOL] assertSame(chronology, time.getChronology()); [EOL] }
public void testTimeOfDayConstructorWithHourMinuteSecond() { [EOL] int hour = 13; [EOL] int minute = 15; [EOL] int second = 10; [EOL] TimeOfDay timeOfDay = new TimeOfDay(hour, minute, second); [EOL] assertEquals(hour, timeOfDay.getHourOfDay()); [EOL] assertEquals(minute, timeOfDay.getMinuteOfHour()); [EOL] assertEquals(second, timeOfDay.getSecondOfMinute()); [EOL] }
public void testTimeOfDayConstructorWithHourMinute() { [EOL] int hour = 13; [EOL] int minute = 15; [EOL] TimeOfDay timeOfDay = new TimeOfDay(hour, minute); [EOL] assertEquals(hour, timeOfDay.getHourOfDay()); [EOL] assertEquals(minute, timeOfDay.getMinuteOfHour()); [EOL] assertEquals(0, timeOfDay.getSecondOfMinute()); [EOL] }
public void testTimeOfDayConstructorWithMillisOfSecond() { [EOL] int hour = 13; [EOL] int minute = 15; [EOL] int second = 10; [EOL] int millis = 200; [EOL] TimeOfDay timeOfDay = new TimeOfDay(hour, minute, second, millis); [EOL] assertEquals(hour, timeOfDay.getHourOfDay()); [EOL] assertEquals(minute, timeOfDay.getMinuteOfHour()); [EOL] assertEquals(second, timeOfDay.getSecondOfMinute()); [EOL] assertEquals(millis, timeOfDay.getMillisOfSecond()); [EOL] }
public void testTimeOfDayWithPartialAndChronology() { [EOL] TimeOfDay partial = new TimeOfDay(10, 20, 30, 400); [EOL] Chronology chrono = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay result = new TimeOfDay(partial, chrono); [EOL] assertEquals(10, result.getHourOfDay()); [EOL] assertEquals(20, result.getMinuteOfHour()); [EOL] assertEquals(30, result.getSecondOfMinute()); [EOL] assertEquals(400, result.getMillisOfSecond()); [EOL] assertSame(chrono, result.getChronology()); [EOL] }
public void testTimeOfDayWithNullPartial() { [EOL] try { [EOL] new TimeOfDay((TimeOfDay) null, ISOChronology.getInstanceUTC()); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testTimeOfDayWithNullChronology() { [EOL] TimeOfDay partial = new TimeOfDay(10, 20, 30, 400); [EOL] TimeOfDay result = new TimeOfDay(partial, null); [EOL] assertEquals(10, result.getHourOfDay()); [EOL] assertEquals(20, result.getMinuteOfHour()); [EOL] assertEquals(30, result.getSecondOfMinute()); [EOL] assertEquals(400, result.getMillisOfSecond()); [EOL] assertNotNull(result.getChronology()); [EOL] assertEquals(ISOChronology.getInstance(), result.getChronology()); [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL] switch(index) { [EOL] case HOUR_OF_DAY: [EOL] return chrono.hourOfDay(); [EOL] case MINUTE_OF_HOUR: [EOL] return chrono.minuteOfHour(); [EOL] case SECOND_OF_MINUTE: [EOL] return chrono.secondOfMinute(); [EOL] case MILLIS_OF_SECOND: [EOL] return chrono.millisOfSecond(); [EOL] default: [EOL] throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL] } [EOL] }
public DateTimeFieldType[] getFieldTypes() { [EOL] return (DateTimeFieldType[]) FIELD_TYPES.clone(); [EOL] } [EOL] public TimeOfDay(); [EOL] public TimeOfDay(DateTimeZone zone); [EOL] public TimeOfDay(Chronology chronology); [EOL] public TimeOfDay(long instant); [EOL] public TimeOfDay(long instant, Chronology chronology); [EOL] public TimeOfDay(Object instant); [EOL] public TimeOfDay(Object instant, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology); [EOL] TimeOfDay(TimeOfDay partial, int[] values); [EOL] TimeOfDay(TimeOfDay partial, Chronology chrono); [EOL] Property(TimeOfDay partial, int fieldIndex); [EOL] public static TimeOfDay fromCalendarFields(Calendar calendar); [EOL] public static TimeOfDay fromDateFields(Date date); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public TimeOfDay withChronologyRetainFields(Chronology newChronology); [EOL] public TimeOfDay withField(DateTimeFieldType fieldType, int value); [EOL] public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public TimeOfDay plus(ReadablePeriod period); [EOL] public TimeOfDay plusHours(int hours); [EOL] public TimeOfDay plusMinutes(int minutes); [EOL] public TimeOfDay plusSeconds(int seconds); [EOL] public TimeOfDay plusMillis(int millis); [EOL] public TimeOfDay minus(ReadablePeriod period); [EOL] public TimeOfDay minusHours(int hours); [EOL] public TimeOfDay minusMinutes(int minutes); [EOL] public TimeOfDay minusSeconds(int seconds); [EOL] public TimeOfDay minusMillis(int millis); [EOL] public Property property(DateTimeFieldType type); [EOL] public LocalTime toLocalTime(); [EOL] public DateTime toDateTimeToday(); [EOL] public DateTime toDateTimeToday(DateTimeZone zone); [EOL] public int getHourOfDay(); [EOL] public int getMinuteOfHour(); [EOL] public int getSecondOfMinute(); [EOL] public int getMillisOfSecond(); [EOL] public TimeOfDay withHourOfDay(int hour); [EOL] public TimeOfDay withMinuteOfHour(int minute); [EOL] public TimeOfDay withSecondOfMinute(int second); [EOL] public TimeOfDay withMillisOfSecond(int millis); [EOL] public Property hourOfDay(); [EOL] public Property minuteOfHour(); [EOL] public Property secondOfMinute(); [EOL] public Property millisOfSecond(); [EOL] public String toString(); [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public TimeOfDay getTimeOfDay(); [EOL] public int get(); [EOL] public TimeOfDay addToCopy(int valueToAdd); [EOL] public TimeOfDay addNoWrapToCopy(int valueToAdd); [EOL] public TimeOfDay addWrapFieldToCopy(int valueToAdd); [EOL] public TimeOfDay setCopy(int value); [EOL] public TimeOfDay setCopy(String text, Locale locale); [EOL] public TimeOfDay setCopy(String text); [EOL] public TimeOfDay withMaximumValue(); [EOL] public TimeOfDay withMinimumValue(); [EOL] long serialVersionUID=3633353405803318660L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() };
public TimeOfDay withChronologyRetainFields(Chronology newChronology) { [EOL] newChronology = DateTimeUtils.getChronology(newChronology); [EOL] newChronology = newChronology.withUTC(); [EOL] if (newChronology == getChronology()) { [EOL] return this; [EOL] } else { [EOL] TimeOfDay newTimeOfDay = new TimeOfDay(this, newChronology); [EOL] newChronology.validate(newTimeOfDay, getValues()); [EOL] return newTimeOfDay; [EOL] } [EOL] }
public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount) { [EOL] int index = indexOfSupported(fieldType); [EOL] if (amount == 0) { [EOL] return this; [EOL] } [EOL] int[] newValues = getValues(); [EOL] newValues = getField(index).addWrapPartial(this, index, newValues, amount); [EOL] return new TimeOfDay(this, newValues); [EOL] } [EOL] public TimeOfDay() {} [EOL] public TimeOfDay(DateTimeZone zone) {} [EOL] public TimeOfDay(Chronology chronology) {} [EOL] public TimeOfDay(long instant) {} [EOL] public TimeOfDay(long instant, Chronology chronology) {} [EOL] public TimeOfDay(Object instant) {} [EOL] public TimeOfDay(Object instant, Chronology chronology) {} [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour) {} [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology) {} [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute) {} [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology) {} [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) {} [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology) {} [EOL] TimeOfDay(TimeOfDay partial, int[] values) {} [EOL] TimeOfDay(TimeOfDay partial, Chronology chrono) {} [EOL] Property(TimeOfDay partial, int fieldIndex) {} [EOL] public static TimeOfDay fromCalendarFields(Calendar calendar) {} [EOL] public static TimeOfDay fromDateFields(Date date) {} [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay) {} [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono) {} [EOL] public int size() {} [EOL] protected DateTimeField getField(int index, Chronology chrono) {} [EOL] public DateTimeFieldType getFieldType(int index) {} [EOL] public DateTimeFieldType[] getFieldTypes() {} [EOL] public TimeOfDay withChronologyRetainFields(Chronology newChronology) {} [EOL] public TimeOfDay withField(DateTimeFieldType fieldType, int value) {} [EOL] public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount) {} [EOL] public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar) {} [EOL] public TimeOfDay plus(ReadablePeriod period) {} [EOL] public TimeOfDay plusHours(int hours) {} [EOL] public TimeOfDay plusMinutes(int minutes) {} [EOL] public TimeOfDay plusSeconds(int seconds) {} [EOL] public TimeOfDay plusMillis(int millis) {} [EOL] public TimeOfDay minus(ReadablePeriod period) {} [EOL] public TimeOfDay minusHours(int hours) {} [EOL] public TimeOfDay minusMinutes(int minutes) {} [EOL] public TimeOfDay minusSeconds(int seconds) {} [EOL] public TimeOfDay minusMillis(int millis) {} [EOL] public Property property(DateTimeFieldType type) {} [EOL] public LocalTime toLocalTime() {} [EOL] public DateTime toDateTimeToday() {} [EOL] public DateTime toDateTimeToday(DateTimeZone zone) {} [EOL] public int getHourOfDay() {} [EOL] public int getMinuteOfHour() {} [EOL] public int getSecondOfMinute() {} [EOL] public int getMillisOfSecond() {} [EOL] public TimeOfDay withHourOfDay(int hour) {} [EOL] public TimeOfDay withMinuteOfHour(int minute) {} [EOL] public TimeOfDay withSecondOfMinute(int second) {} [EOL] public TimeOfDay withMillisOfSecond(int millis) {} [EOL] public Property hourOfDay() {} [EOL] public Property minuteOfHour() {} [EOL] public Property secondOfMinute() {} [EOL] public Property millisOfSecond() {} [EOL] public String toString() {} [EOL] public DateTimeField getField() {} [EOL] protected ReadablePartial getReadablePartial() {} [EOL] public TimeOfDay getTimeOfDay() {} [EOL] public int get() {} [EOL] public TimeOfDay addToCopy(int valueToAdd) {} [EOL] public TimeOfDay addNoWrapToCopy(int valueToAdd) {} [EOL] public TimeOfDay addWrapFieldToCopy(int valueToAdd) {} [EOL] public TimeOfDay setCopy(int value) {} [EOL] public TimeOfDay setCopy(String text, Locale locale) {} [EOL] public TimeOfDay setCopy(String text) {} [EOL] public TimeOfDay withMaximumValue() {} [EOL] public TimeOfDay withMinimumValue() {} [EOL] long serialVersionUID=3633353405803318660L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() };
public TimeOfDay plusMillis(int millis) { [EOL] return withFieldAdded(DurationFieldType.millis(), millis); [EOL] }
public TimeOfDay minusSeconds(int seconds) { [EOL] return withFieldAdded(DurationFieldType.seconds(), FieldUtils.safeNegate(seconds)); [EOL] } [EOL] public TimeOfDay(); [EOL] public TimeOfDay(DateTimeZone zone); [EOL] public TimeOfDay(Chronology chronology); [EOL] public TimeOfDay(long instant); [EOL] public TimeOfDay(long instant, Chronology chronology); [EOL] public TimeOfDay(Object instant); [EOL] public TimeOfDay(Object instant, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); [EOL] public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology); [EOL] TimeOfDay(TimeOfDay partial, int[] values); [EOL] TimeOfDay(TimeOfDay partial, Chronology chrono); [EOL] Property(TimeOfDay partial, int fieldIndex); [EOL] public static TimeOfDay fromCalendarFields(Calendar calendar); [EOL] public static TimeOfDay fromDateFields(Date date); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay); [EOL] public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public TimeOfDay withChronologyRetainFields(Chronology newChronology); [EOL] public TimeOfDay withField(DateTimeFieldType fieldType, int value); [EOL] public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public TimeOfDay plus(ReadablePeriod period); [EOL] public TimeOfDay plusHours(int hours); [EOL] public TimeOfDay plusMinutes(int minutes); [EOL] public TimeOfDay plusSeconds(int seconds); [EOL] public TimeOfDay plusMillis(int millis); [EOL] public TimeOfDay minus(ReadablePeriod period); [EOL] public TimeOfDay minusHours(int hours); [EOL] public TimeOfDay minusMinutes(int minutes); [EOL] public TimeOfDay minusSeconds(int seconds); [EOL] public TimeOfDay minusMillis(int millis); [EOL] public Property property(DateTimeFieldType type); [EOL] public LocalTime toLocalTime(); [EOL] public DateTime toDateTimeToday(); [EOL] public DateTime toDateTimeToday(DateTimeZone zone); [EOL] public int getHourOfDay(); [EOL] public int getMinuteOfHour(); [EOL] public int getSecondOfMinute(); [EOL] public int getMillisOfSecond(); [EOL] public TimeOfDay withHourOfDay(int hour); [EOL] public TimeOfDay withMinuteOfHour(int minute); [EOL] public TimeOfDay withSecondOfMinute(int second); [EOL] public TimeOfDay withMillisOfSecond(int millis); [EOL] public Property hourOfDay(); [EOL] public Property minuteOfHour(); [EOL] public Property secondOfMinute(); [EOL] public Property millisOfSecond(); [EOL] public String toString(); [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public TimeOfDay getTimeOfDay(); [EOL] public int get(); [EOL] public TimeOfDay addToCopy(int valueToAdd); [EOL] public TimeOfDay addNoWrapToCopy(int valueToAdd); [EOL] public TimeOfDay addWrapFieldToCopy(int valueToAdd); [EOL] public TimeOfDay setCopy(int value); [EOL] public TimeOfDay setCopy(String text, Locale locale); [EOL] public TimeOfDay setCopy(String text); [EOL] public TimeOfDay withMaximumValue(); [EOL] public TimeOfDay withMinimumValue(); [EOL] long serialVersionUID=Optional[3633353405803318660L]; [EOL] DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }];
public void testHourOfDayProperty() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(); [EOL] Property property = timeOfDay.hourOfDay(); [EOL] assertNotNull(property); [EOL] assertEquals(DateTimeFieldType.hourOfDay(), property.getFieldType()); [EOL] }
public void testTimeOfDayDefaultConstructor() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayZoneConstructor() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/London"); [EOL] TimeOfDay timeOfDay = new TimeOfDay(zone); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(zone, timeOfDay.getChronology().getZone()); [EOL] }
public void testTimeOfDayChronologyConstructor() { [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(chronology); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(chronology, timeOfDay.getChronology()); [EOL] }
public void testTimeOfDayInstantConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayInstantChronologyConstructor() { [EOL] long instant = System.currentTimeMillis(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant, chronology); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(chronology, timeOfDay.getChronology()); [EOL] }
public void testTimeOfDayObjectConstructor() { [EOL] Object instant = new Date(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testTimeOfDayObjectChronologyConstructor() { [EOL] Object instant = new Date(); [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(instant, chronology); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(chronology, timeOfDay.getChronology()); [EOL] }
public void testTimeOfDayHourAndMinuteConstructor() { [EOL] int hourOfDay = 10; [EOL] int minuteOfHour = 30; [EOL] TimeOfDay timeOfDay = new TimeOfDay(hourOfDay, minuteOfHour); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(hourOfDay, timeOfDay.getHourOfDay()); [EOL] assertEquals(minuteOfHour, timeOfDay.getMinuteOfHour()); [EOL] }
public void testTimeOfDayFullConstructor() { [EOL] int hourOfDay = 10; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 20; [EOL] int millisOfSecond = 250; [EOL] TimeOfDay timeOfDay = new TimeOfDay(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(hourOfDay, timeOfDay.getHourOfDay()); [EOL] assertEquals(minuteOfHour, timeOfDay.getMinuteOfHour()); [EOL] assertEquals(secondOfMinute, timeOfDay.getSecondOfMinute()); [EOL] assertEquals(millisOfSecond, timeOfDay.getMillisOfSecond()); [EOL] }
public void testTimeOfDayFullChronologyConstructor() { [EOL] int hourOfDay = 10; [EOL] int minuteOfHour = 30; [EOL] int secondOfMinute = 20; [EOL] int millisOfSecond = 250; [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay timeOfDay = new TimeOfDay(hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(chronology, timeOfDay.getChronology()); [EOL] }
public void testFromCalendarFields() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] TimeOfDay timeOfDay = TimeOfDay.fromCalendarFields(calendar); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(calendar.get(Calendar.HOUR_OF_DAY), timeOfDay.getHourOfDay()); [EOL] assertEquals(calendar.get(Calendar.MINUTE), timeOfDay.getMinuteOfHour()); [EOL] assertEquals(calendar.get(Calendar.SECOND), timeOfDay.getSecondOfMinute()); [EOL] assertEquals(calendar.get(Calendar.MILLISECOND), timeOfDay.getMillisOfSecond()); [EOL] }
public void testFromDateFields() { [EOL] Date date = new Date(); [EOL] TimeOfDay timeOfDay = TimeOfDay.fromDateFields(date); [EOL] assertNotNull(timeOfDay); [EOL] Calendar calendar = Calendar.getInstance(); [EOL] calendar.setTime(date); [EOL] assertEquals(calendar.get(Calendar.HOUR_OF_DAY), timeOfDay.getHourOfDay()); [EOL] assertEquals(calendar.get(Calendar.MINUTE), timeOfDay.getMinuteOfHour()); [EOL] assertEquals(calendar.get(Calendar.SECOND), timeOfDay.getSecondOfMinute()); [EOL] assertEquals(calendar.get(Calendar.MILLISECOND), timeOfDay.getMillisOfSecond()); [EOL] }
public void testFromMillisOfDay() { [EOL] long millisOfDay = System.currentTimeMillis() % DateTimeConstants.MILLIS_PER_DAY; [EOL] TimeOfDay timeOfDay = TimeOfDay.fromMillisOfDay(millisOfDay); [EOL] assertNotNull(timeOfDay); [EOL] }
public void testFromMillisOfDayChronology() { [EOL] long millisOfDay = System.currentTimeMillis() % DateTimeConstants.MILLIS_PER_DAY; [EOL] Chronology chronology = ISOChronology.getInstanceUTC(); [EOL] TimeOfDay timeOfDay = TimeOfDay.fromMillisOfDay(millisOfDay, chronology); [EOL] assertNotNull(timeOfDay); [EOL] assertEquals(chronology, timeOfDay.getChronology()); [EOL] }
public void testAddNoWrapToCopy_PositiveValue() { [EOL] TimeOfDay initialTime = new TimeOfDay(10, 20, 30, 400); [EOL] TimeOfDay resultTime = initialTime.addNoWrapToCopy(1); [EOL] assertEquals(new TimeOfDay(10, 20, 30, 401), resultTime); [EOL] }
public void testAddNoWrapToCopy_NegativeValue() { [EOL] TimeOfDay initialTime = new TimeOfDay(10, 20, 30, 400); [EOL] TimeOfDay resultTime = initialTime.addNoWrapToCopy(-1); [EOL] assertEquals(new TimeOfDay(10, 20, 30, 399), resultTime); [EOL] }
public void testAddNoWrapToCopy_ZeroValue() { [EOL] TimeOfDay initialTime = new TimeOfDay(10, 20, 30, 400); [EOL] TimeOfDay resultTime = initialTime.addNoWrapToCopy(0); [EOL] assertEquals(initialTime, resultTime); [EOL] }
public void testAddNoWrapToCopy_MaxValue() { [EOL] TimeOfDay initialTime = new TimeOfDay(23, 59, 59, 999); [EOL] try { [EOL] initialTime.addNoWrapToCopy(1); [EOL] fail("Should have thrown an exception"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAddNoWrapToCopy_MinValue() { [EOL] TimeOfDay initialTime = new TimeOfDay(0, 0, 0, 0); [EOL] try { [EOL] initialTime.addNoWrapToCopy(-1); [EOL] fail("Should have thrown an exception"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetCopyWithValidTextAndLocale() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 20, 30, 400); [EOL] Locale locale = Locale.ENGLISH; [EOL] String validText = "12:00"; // Assuming this is a valid text representation for the TimeOfDay [EOL] TimeOfDay updatedTimeOfDay = timeOfDay.setCopy(validText, locale); [EOL] assertNotNull(updatedTimeOfDay); [EOL] }
public void testSetCopyWithInvalidText() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 20, 30, 400); [EOL] Locale locale = Locale.ENGLISH; [EOL] String invalidText = "invalid"; // Assuming this is an invalid text representation for the TimeOfDay [EOL] try { [EOL] timeOfDay.setCopy(invalidText, locale); [EOL] fail("Should have thrown an exception due to invalid text format"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetCopyWithNullLocale() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(10, 20, 30, 400); [EOL] String validText = "12:00"; // Assuming this is a valid text representation for the TimeOfDay [EOL] try { [EOL] timeOfDay.setCopy(validText, null); [EOL] fail("Should have thrown an exception due to null locale"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testSetCopyWithNullText() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(); [EOL] TimeOfDay result = timeOfDay.setCopy(null); [EOL] } [EOL] public void testSetCopyWithValidText() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(); [EOL] String validText = "12:00"; // Assuming this is a valid text representation of a TimeOfDay [EOL] TimeOfDay result = timeOfDay.setCopy(validText); [EOL] } [EOL] public void testSetCopyWithInvalidText() { [EOL] TimeOfDay timeOfDay = new TimeOfDay(); [EOL] String invalidText = "invalid"; // Assuming this is an invalid text representation of a TimeOfDay [EOL] try { [EOL] timeOfDay.setCopy(invalidText); [EOL] fail("Should have thrown an exception for invalid text"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testWithMaximumValue() { [EOL] TimeOfDay time = new TimeOfDay(); [EOL] TimeOfDay maxTime = time.withMaximumValue(); [EOL] assertNotNull(maxTime); [EOL] assertEquals(maxTime.getHourOfDay(), maxTime.getMaximumValue(DateTimeFieldType.hourOfDay())); [EOL] assertEquals(maxTime.getMinuteOfHour(), maxTime.getMaximumValue(DateTimeFieldType.minuteOfHour())); [EOL] assertEquals(maxTime.getSecondOfMinute(), maxTime.getMaximumValue(DateTimeFieldType.secondOfMinute())); [EOL] assertEquals(maxTime.getMillisOfSecond(), maxTime.getMaximumValue(DateTimeFieldType.millisOfSecond())); [EOL] }
public void testOverlaps_WithNullInterval_CurrentTimeWithinInterval() { [EOL] long now = DateTimeUtils.currentTimeMillis(); [EOL] ReadableInterval interval = null; // Represents the current time [EOL] MyClass testInstance = new MyClass(now - 1000, now + 1000); // Assuming constructor MyClass(long start, long end) [EOL] boolean result = testInstance.overlaps(interval); [EOL] assertTrue(result); [EOL] }
public void testOverlaps_WithInterval_NotOverlappingBefore() { [EOL] ReadableInterval interval = new MockReadableInterval(1000, 2000); // Assuming MockReadableInterval implements ReadableInterval [EOL] MyClass testInstance = new MyClass(3000, 4000); [EOL] boolean result = testInstance.overlaps(interval); [EOL] assertFalse(result); [EOL] }
public void testOverlaps_WithInterval_NotOverlappingAfter() { [EOL] ReadableInterval interval = new MockReadableInterval(5000, 6000); [EOL] MyClass testInstance = new MyClass(3000, 4000); [EOL] boolean result = testInstance.overlaps(interval); [EOL] assertFalse(result); [EOL] }
public void testOverlaps_WithInterval_Overlapping() { [EOL] ReadableInterval interval = new MockReadableInterval(3500, 4500); [EOL] MyClass testInstance = new MyClass(3000, 4000); [EOL] boolean result = testInstance.overlaps(interval); [EOL] assertTrue(result); [EOL] }
public void testIsBeforeWithNullInstant() { [EOL] Time time = new Time(); [EOL] boolean result = time.isBefore(null); [EOL] assertTrue(result == time.isBeforeNow()); [EOL] }
public void testIsBeforeWithInstantInThePast() { [EOL] Time time = new Time(); [EOL] ReadableInstant pastInstant = new MockReadableInstant(System.currentTimeMillis() - 10000); [EOL] boolean result = time.isBefore(pastInstant); [EOL] assertTrue(result); [EOL] }
public void testIsBeforeWithInstantInTheFuture() { [EOL] Time time = new Time(); [EOL] ReadableInstant futureInstant = new MockReadableInstant(System.currentTimeMillis() + 10000); [EOL] boolean result = time.isBefore(futureInstant); [EOL] assertFalse(result); [EOL] }
public void testToMutableInterval() { [EOL] DateTime start = new DateTime(2020, 1, 1, 0, 0, 0); [EOL] DateTime end = new DateTime(2020, 12, 31, 23, 59, 59); [EOL] Interval interval = new Interval(start, end); [EOL] MutableInterval mutableInterval = interval.toMutableInterval(); [EOL] assertEquals(start.getMillis(), mutableInterval.getStartMillis()); [EOL] assertEquals(end.getMillis(), mutableInterval.getEndMillis()); [EOL] assertEquals(interval.getChronology(), mutableInterval.getChronology()); [EOL] }
public void testGetFieldTypes_Empty() { [EOL] PeriodType test = PeriodType.forFields(new DurationFieldType[0]); [EOL] DurationFieldType[] result = test.getFieldTypes(); [EOL] assertNotNull(result); [EOL] assertEquals(0, result.length); [EOL] }
public void testGetFieldTypes_NonEmpty() { [EOL] PeriodType test = PeriodType.yearMonthDayTime(); [EOL] DurationFieldType[] result = test.getFieldTypes(); [EOL] assertNotNull(result); [EOL] assertEquals(4, result.length); [EOL] assertEquals(DurationFieldType.years(), result[0]); [EOL] assertEquals(DurationFieldType.months(), result[1]); [EOL] assertEquals(DurationFieldType.days(), result[2]); [EOL] assertEquals(DurationFieldType.millis(), result[3]); [EOL] }
public void testToPeriod() { [EOL] Time time = new Time(); [EOL] Period result = time.toPeriod(); [EOL] assertNotNull(result); [EOL] assertEquals(time, result.getTime()); [EOL] }
public void testEquals_SameObject() { [EOL] ReadablePeriod period = createPeriod(); [EOL] assertTrue(period.equals(period)); [EOL] } [EOL] public void testEquals_DifferentType() { [EOL] ReadablePeriod period = createPeriod(); [EOL] assertFalse(period.equals(new Object())); [EOL] } [EOL] public void testEquals_Null() { [EOL] ReadablePeriod period = createPeriod(); [EOL] assertFalse(period.equals(null)); [EOL] } [EOL] public void testEquals_DifferentSize() { [EOL] ReadablePeriod period1 = createPeriod(); [EOL] ReadablePeriod period2 = createPeriodWithDifferentSize(); [EOL] assertFalse(period1.equals(period2)); [EOL] } [EOL] public void testEquals_DifferentValues() { [EOL] ReadablePeriod period1 = createPeriod(); [EOL] ReadablePeriod period2 = createPeriodWithDifferentValues(); [EOL] assertFalse(period1.equals(period2)); [EOL] } [EOL] public void testEquals_DifferentFieldTypes() { [EOL] ReadablePeriod period1 = createPeriod(); [EOL] ReadablePeriod period2 = createPeriodWithDifferentFieldTypes(); [EOL] assertFalse(period1.equals(period2)); [EOL] } [EOL] public void testEquals_EqualPeriods() { [EOL] ReadablePeriod period1 = createPeriod(); [EOL] ReadablePeriod period2 = createPeriod(); [EOL] assertTrue(period1.equals(period2)); [EOL] }
public void testHashCodeEmpty() { [EOL] setupEmptyInstance(); [EOL] int expected = 17; // As per the initial value of total in the hashCode method [EOL] int actual = instance.hashCode(); [EOL] assertEquals(expected, actual); [EOL] }
public void testHashCodeSingleElement() { [EOL] setupSingleElementInstance(); [EOL] int expected = 17; [EOL] expected = 27 * expected + singleElementValue; [EOL] expected = 27 * expected + singleFieldTypeHashCode; [EOL] int actual = instance.hashCode(); [EOL] assertEquals(expected, actual); [EOL] }
public void testHashCodeMultipleElements() { [EOL] setupMultipleElementsInstance(); [EOL] int expected = 17; [EOL] for (int i = 0, isize = instance.size(); i < isize; i++) { [EOL] expected = 27 * expected + instance.getValue(i); [EOL] expected = 27 * expected + instance.getFieldType(i).hashCode(); [EOL] } [EOL] int actual = instance.hashCode(); [EOL] assertEquals(expected, actual); [EOL] }
public void testToStringWithNullFormatter() { [EOL] Period testPeriod = new Period(); [EOL] String result = testPeriod.toString(null); [EOL] assertNotNull(result); [EOL] assertEquals("Default toString behavior not met", testPeriod.toString(), result); [EOL] }
public void testToStringWithNonNullFormatter() { [EOL] Period testPeriod = new Period(); [EOL] PeriodFormatter formatter = new PeriodFormatter(); // Assuming PeriodFormatter is a valid class that can format Period objects [EOL] String expected = formatter.print(testPeriod); [EOL] String result = testPeriod.toString(formatter); [EOL] assertNotNull(result); [EOL] assertEquals("Formatter's print method not used", expected, result); [EOL] }
public void testMutablePeriodWithNullPeriodAndTypeAndChrono() { [EOL] MutablePeriod mp = new MutablePeriod(null, null, null); [EOL] assertNotNull(mp); [EOL] assertNull(mp.getPeriodType()); [EOL] assertNull(mp.getChronology()); [EOL] }
public void testMutablePeriodWithNonNullPeriodAndNullTypeAndChrono() { [EOL] Period period = new Period(); [EOL] MutablePeriod mp = new MutablePeriod(period, null, null); [EOL] assertNotNull(mp); [EOL] assertEquals(period.getPeriodType(), mp.getPeriodType()); [EOL] assertNull(mp.getChronology()); [EOL] }
public void testMutablePeriodWithNonNullPeriodAndTypeAndNullChrono() { [EOL] Period period = new Period(); [EOL] PeriodType type = PeriodType.standard(); [EOL] MutablePeriod mp = new MutablePeriod(period, type, null); [EOL] assertNotNull(mp); [EOL] assertEquals(type, mp.getPeriodType()); [EOL] assertNull(mp.getChronology()); [EOL] }
public void testMutablePeriodWithNonNullPeriodTypeAndChrono() { [EOL] Period period = new Period(); [EOL] PeriodType type = PeriodType.standard(); [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] MutablePeriod mp = new MutablePeriod(period, type, chrono); [EOL] assertNotNull(mp); [EOL] assertEquals(type, mp.getPeriodType()); [EOL] assertEquals(chrono, mp.getChronology()); [EOL] }
public void testClear() { [EOL] Time time = new Time(); [EOL] time.setValues(new int[]{1, 2, 3}); [EOL] time.clear(); [EOL] assertNotNull("Values should not be null after clear", time.getValues()); [EOL] assertEquals("Values should be empty after clear", 0, time.size()); [EOL] }
public void testAddWithNullDuration() { [EOL] TimePeriod timePeriod = new TimePeriod(); [EOL] timePeriod.add(null); [EOL] }
public void testAddWithNonNullDuration() { [EOL] TimePeriod timePeriod = new TimePeriod(); [EOL] ReadableDuration duration = new MockDuration(1000); [EOL] timePeriod.add(duration); [EOL] }
public void testMergePeriodWithNonNullPeriod() { [EOL] ReadablePeriod period = // obtain a non-null ReadablePeriod instance [EOL] TimeClass instance = new TimeClass(); [EOL] instance.mergePeriod(period); [EOL] }
public void addYearsTestWithPositiveYears() { [EOL] DateTime testDateTime = new DateTime(); [EOL] int yearsToAdd = 5; [EOL] DateTime expectedDateTime = testDateTime.plusYears(yearsToAdd); [EOL] testDateTime.addYears(yearsToAdd); [EOL] assertEquals(expectedDateTime, testDateTime); [EOL] }
public void addYearsTestWithNegativeYears() { [EOL] DateTime testDateTime = new DateTime(); [EOL] int yearsToAdd = -3; [EOL] DateTime expectedDateTime = testDateTime.plusYears(yearsToAdd); [EOL] testDateTime.addYears(yearsToAdd); [EOL] assertEquals(expectedDateTime, testDateTime); [EOL] }
public void addYearsTestWithZeroYears() { [EOL] DateTime testDateTime = new DateTime(); [EOL] int yearsToAdd = 0; [EOL] DateTime expectedDateTime = testDateTime.plusYears(yearsToAdd); [EOL] testDateTime.addYears(yearsToAdd); [EOL] assertEquals(expectedDateTime, testDateTime); [EOL] }
public void testRoundCeiling_PositiveInstant() { [EOL] long instant = 1; // Any positive number [EOL] long expected = iUnitMillis; // Assuming iUnitMillis is a positive constant and accessible in the test [EOL] long result = roundCeiling(instant); [EOL] assertEquals(expected, result); [EOL] }
public void testRoundCeiling_NegativeInstant() { [EOL] long instant = -1; // Any negative number [EOL] long expected = -1 % iUnitMillis; // Assuming iUnitMillis is a positive constant and accessible in the test [EOL] long result = roundCeiling(instant); [EOL] assertEquals(expected, result); [EOL] }
public void testRoundCeiling_ZeroInstant() { [EOL] long instant = 0; // Zero case [EOL] long expected = 0; // Zero remains unchanged [EOL] long result = roundCeiling(instant); [EOL] assertEquals(expected, result); [EOL] }
public void testRemainderWithPositiveInstant() { [EOL] long instant = 50; // Assume iUnitMillis is initialized to 10 [EOL] long expected = instant % 10; [EOL] long actual = remainder(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRemainderWithNegativeInstant() { [EOL] long instant = -50; // Assume iUnitMillis is initialized to 10 [EOL] long expected = (instant + 1) % 10 + 10 - 1; [EOL] long actual = remainder(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRemainderWithZeroInstant() { [EOL] long instant = 0; // Boundary case where instant is zero [EOL] long expected = 0; // Zero modulo any positive number is zero [EOL] long actual = remainder(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRemainderWithInstantEqualToUnitMillis() { [EOL] long instant = 10; // Assume iUnitMillis is initialized to 10, boundary case where instant equals iUnitMillis [EOL] long expected = 0; // Any number modulo itself is zero [EOL] long actual = remainder(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testAdd_WithZeroYears() { [EOL] long instant = System.currentTimeMillis(); // Replace with a fixed instant if needed [EOL] long expected = instant; [EOL] long actual = add(instant, 0); [EOL] assertEquals(expected, actual); [EOL] }
public void testAdd_WithPositiveYears() { [EOL] long instant = System.currentTimeMillis(); // Replace with a fixed instant if needed [EOL] int yearsToAdd = 5; // Example positive number of years [EOL] int thisYear = get(instant); [EOL] int newYear = FieldUtils.safeAdd(thisYear, yearsToAdd); [EOL] long expected = set(instant, newYear); [EOL] long actual = add(instant, yearsToAdd); [EOL] assertEquals(expected, actual); [EOL] }
public void testAdd_WithNegativeYears() { [EOL] long instant = System.currentTimeMillis(); // Replace with a fixed instant if needed [EOL] int yearsToSubtract = -5; // Example negative number of years [EOL] int thisYear = get(instant); [EOL] int newYear = FieldUtils.safeAdd(thisYear, yearsToSubtract); [EOL] long expected = set(instant, newYear); [EOL] long actual = add(instant, yearsToSubtract); [EOL] assertEquals(expected, actual); [EOL] }
public void testSetWithMinYear() { [EOL] long instant = System.currentTimeMillis(); // Replace with a fixed instant if needed [EOL] int minYear = iChronology.getMinYear(); [EOL] long expected = iChronology.setYear(instant, minYear); [EOL] long actual = set(instant, minYear); [EOL] assertEquals(expected, actual); [EOL] }
public void testSetWithMaxYear() { [EOL] long instant = System.currentTimeMillis(); // Replace with a fixed instant if needed [EOL] int maxYear = iChronology.getMaxYear(); [EOL] long expected = iChronology.setYear(instant, maxYear); [EOL] long actual = set(instant, maxYear); [EOL] assertEquals(expected, actual); [EOL] }
public void testSetWithYearOutOfBounds() { [EOL] long instant = System.currentTimeMillis(); // Replace with a fixed instant if needed [EOL] int yearBelowMin = iChronology.getMinYear() - 1; [EOL] try { [EOL] set(instant, yearBelowMin); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] int yearAboveMax = iChronology.getMaxYear() + 1; [EOL] try { [EOL] set(instant, yearAboveMax); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDifferenceAsLongWithMinuendLessThanSubtrahend() { [EOL] long minuendInstant = 1000L; [EOL] long subtrahendInstant = 2000L; [EOL] long expected = -iChronology.getYearDifference(subtrahendInstant, minuendInstant); [EOL] long actual = getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetDifferenceAsLongWithMinuendGreaterThanSubtrahend() { [EOL] long minuendInstant = 3000L; [EOL] long subtrahendInstant = 2000L; [EOL] long expected = iChronology.getYearDifference(minuendInstant, subtrahendInstant); [EOL] long actual = getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetDifferenceAsLongWithMinuendEqualToSubtrahend() { [EOL] long minuendInstant = 2000L; [EOL] long subtrahendInstant = 2000L; [EOL] long expected = iChronology.getYearDifference(minuendInstant, subtrahendInstant); [EOL] long actual = getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundFloor_PositiveInstant() { [EOL] long instant = 1234567890L; [EOL] long expected = iChronology.getYearMillis(get(instant)); [EOL] long actual = roundFloor(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundFloor_NegativeInstant() { [EOL] long instant = -1234567890L; [EOL] long expected = iChronology.getYearMillis(get(instant)); [EOL] long actual = roundFloor(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testRoundFloor_ZeroInstant() { [EOL] long instant = 0L; [EOL] long expected = iChronology.getYearMillis(get(instant)); [EOL] long actual = roundFloor(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetLocale() { [EOL] Locale expectedLocale = Locale.ENGLISH; // Replace with the actual expected locale [EOL] MyClass myClassInstance = new MyClass(expectedLocale); [EOL] Locale actualLocale = myClassInstance.getLocale(); [EOL] assertEquals("The locale should be the expected one", expectedLocale, actualLocale); [EOL] }
public void testSetZoneWithNonNullZone() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeZone newZone = DateTimeZone.forID("Europe/Paris"); [EOL] testDateTime.setZone(newZone); [EOL] assertEquals(newZone, testDateTime.getZone()); [EOL] }
public void testSetZoneWithNullZone() { [EOL] DateTime testDateTime = new DateTime(); [EOL] testDateTime.setZone(null); [EOL] assertNull(testDateTime.getZone()); [EOL] }
public Integer getPivotYear() { [EOL] return iPivotYear; [EOL] }
public void testSaveFieldWithValidArguments() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); [EOL] String text = "10"; [EOL] Locale locale = Locale.US; [EOL] saveField(fieldType, text, locale); [EOL] }
public void testSaveFieldWithNullFieldType() { [EOL] String text = "10"; [EOL] Locale locale = Locale.US; [EOL] try { [EOL] saveField(null, text, locale); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSaveFieldWithNullText() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); [EOL] Locale locale = Locale.US; [EOL] try { [EOL] saveField(fieldType, null, locale); [EOL] fail("Expected an IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSaveFieldWithNullLocale() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.hourOfDay(); [EOL] String text = "10"; [EOL] saveField(fieldType, text, null); [EOL] }
public long computeMillis(boolean resetFields, String text) { [EOL] SavedField[] savedFields = iSavedFields; [EOL] int count = iSavedFieldsCount; [EOL] if (iSavedFieldsShared) { [EOL] iSavedFields = savedFields = (SavedField[]) iSavedFields.clone(); [EOL] iSavedFieldsShared = false; [EOL] } [EOL] sort(savedFields, count); [EOL] if (count > 0) { [EOL] DurationField months = DurationFieldType.months().getField(iChrono); [EOL] DurationField days = DurationFieldType.days().getField(iChrono); [EOL] DurationField first = savedFields[0].iField.getDurationField(); [EOL] if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) { [EOL] saveField(DateTimeFieldType.year(), iDefaultYear); [EOL] return computeMillis(resetFields, text); [EOL] } [EOL] } [EOL] long millis = iMillis; [EOL] try { [EOL] for (int i = 0; i < count; i++) { [EOL] millis = savedFields[i].set(millis, resetFields); [EOL] } [EOL] if (resetFields) { [EOL] for (int i = 0; i < count; i++) { [EOL] millis = savedFields[i].set(millis, i == (count - 1)); [EOL] } [EOL] } [EOL] } catch (IllegalFieldValueException e) { [EOL] if (text != null) { [EOL] e.prependMessage("Cannot parse \"" + text + '"'); [EOL] } [EOL] throw e; [EOL] } [EOL] if (iOffset != null) { [EOL] millis -= iOffset; [EOL] } else if (iZone != null) { [EOL] int offset = iZone.getOffsetFromLocal(millis); [EOL] millis -= offset; [EOL] if (offset != iZone.getOffset(millis)) { [EOL] String message = "Illegal instant due to time zone offset transition (" + iZone + ')'; [EOL] if (text != null) { [EOL] message = "Cannot parse \"" + text + "\": " + message; [EOL] } [EOL] throw new IllegalInstantException(message); [EOL] } [EOL] } [EOL] return millis; [EOL] }
public void testSortWithHighGreaterThan10() { [EOL] SavedField[] array = new SavedField[20]; [EOL] for (int i = 0; i < array.length; i++) { [EOL] array[i] = new SavedField(); [EOL] array[i].setValue(i); [EOL] } [EOL] Time.sort(array, 15); [EOL] for (int i = 0; i < 14; i++) { [EOL] assertTrue(array[i].compareTo(array[i + 1]) <= 0); [EOL] } [EOL] }
public void testSortWithHighNotGreaterThan10() { [EOL] SavedField[] array = new SavedField[10]; [EOL] for (int i = 0; i < array.length; i++) { [EOL] array[i] = new SavedField(); [EOL] array[i].setValue(array.length - i); [EOL] } [EOL] Time.sort(array, 9); [EOL] for (int i = 0; i < 8; i++) { [EOL] assertTrue(array[i].compareTo(array[i + 1]) <= 0); [EOL] } [EOL] }
public void testSavedFieldWithNonNullValues() { [EOL] DateTimeField field = new MockDateTimeField(); [EOL] String text = "testText"; [EOL] Locale locale = Locale.ENGLISH; [EOL] SavedField savedField = new SavedField(field, text, locale); [EOL] assertNotNull(savedField.iField); [EOL] assertEquals(0, savedField.iValue); [EOL] assertEquals("testText", savedField.iText); [EOL] assertEquals(Locale.ENGLISH, savedField.iLocale); [EOL] }
public void testSavedFieldWithNullValues() { [EOL] DateTimeField field = null; [EOL] String text = null; [EOL] Locale locale = null; [EOL] SavedField savedField = new SavedField(field, text, locale); [EOL] assertNull(savedField.iField); [EOL] assertEquals(0, savedField.iValue); [EOL] assertNull(savedField.iText); [EOL] assertNull(savedField.iLocale); [EOL] }
public void testSetWithNullTextAndResetTrue() { [EOL] long initialMillis = 1000L; [EOL] long expectedMillis = 2000L; // Expected value after setting and rounding [EOL] boolean reset = true; [EOL] YourClass instance = new YourClass(); [EOL] instance.iText = null; [EOL] instance.iValue = 10; // Example value [EOL] instance.iField = Mockito.mock(YourFieldClass.class); [EOL] Mockito.when(instance.iField.set(initialMillis, instance.iValue)).thenReturn(expectedMillis); [EOL] Mockito.when(instance.iField.roundFloor(expectedMillis)).thenReturn(expectedMillis); [EOL] long result = instance.set(initialMillis, reset); [EOL] assertEquals(expectedMillis, result); [EOL] }
public void testSetWithNonNullTextAndResetFalse() { [EOL] long initialMillis = 1000L; [EOL] long expectedMillis = 3000L; // Expected value after setting without rounding [EOL] boolean reset = false; [EOL] String text = "SomeText"; [EOL] Locale locale = Locale.getDefault(); [EOL] YourClass instance = new YourClass(); [EOL] instance.iText = text; [EOL] instance.iLocale = locale; [EOL] instance.iField = Mockito.mock(YourFieldClass.class); [EOL] Mockito.when(instance.iField.set(initialMillis, text, locale)).thenReturn(expectedMillis); [EOL] long result = instance.set(initialMillis, reset); [EOL] assertEquals(expectedMillis, result); [EOL] }
public void testCompareReverseBothNull() { [EOL] DurationField a = null; [EOL] DurationField b = null; [EOL] int result = compareReverse(a, b); [EOL] assertEquals(0, result); [EOL] }
public void testCompareReverseAIsNotSupported() { [EOL] DurationField a = new UnsupportedDurationField(); [EOL] DurationField b = new SupportedDurationField(); [EOL] int result = compareReverse(a, b); [EOL] assertEquals(-1, result); [EOL] }
public void testCompareReverseBIsNotSupported() { [EOL] DurationField a = new SupportedDurationField(); [EOL] DurationField b = new UnsupportedDurationField(); [EOL] int result = compareReverse(a, b); [EOL] assertEquals(1, result); [EOL] }
public void testCompareReverseBothSupported() { [EOL] DurationField a = new SupportedDurationField(); [EOL] DurationField b = new SupportedDurationField(); [EOL] when(a.compareTo(b)).thenReturn(1); [EOL] int result = compareReverse(a, b); [EOL] assertEquals(-1, result); [EOL] }
public void testAdd_WithinBounds() { [EOL] long instant = SOME_VALID_INSTANT; // Replace with a valid instant value [EOL] int amount = SOME_VALID_AMOUNT; // Replace with a valid amount that keeps the result within bounds [EOL] long expected = EXPECTED_INSTANT; // Replace with the expected instant after addition [EOL] long result = add(instant, amount); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testAdd_BelowMinimum() { [EOL] long instant = SOME_VALID_INSTANT; // Replace with a valid instant value [EOL] int amount = AMOUNT_BELOW_MIN; // Replace with an amount that would cause the result to be below iMin [EOL] try { [EOL] add(instant, amount); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testAdd_AboveMaximum() { [EOL] long instant = SOME_VALID_INSTANT; // Replace with a valid instant value [EOL] int amount = AMOUNT_ABOVE_MAX; // Replace with an amount that would cause the result to be above iMax [EOL] try { [EOL] add(instant, amount); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAdd_WithinBounds() { [EOL] long instant = SOME_VALID_INSTANT; // Replace with a valid instant value [EOL] long amount = SOME_VALID_AMOUNT; // Replace with a valid amount that keeps the result within bounds [EOL] long expected = EXPECTED_INSTANT; // Replace with the expected result instant [EOL] long result = add(instant, amount); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testAdd_BelowMinimum() { [EOL] long instant = SOME_VALID_INSTANT; // Replace with a valid instant value [EOL] long amount = AMOUNT_BELOW_MIN; // Replace with an amount that causes the result to be below iMin [EOL] try { [EOL] add(instant, amount); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testAdd_AboveMaximum() { [EOL] long instant = SOME_VALID_INSTANT; // Replace with a valid instant value [EOL] long amount = AMOUNT_ABOVE_MAX; // Replace with an amount that causes the result to be above iMax [EOL] try { [EOL] add(instant, amount); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testAddWrapField_Min() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant value [EOL] int amount = -1; [EOL] long expected = instant - 1; // Adjust expected value based on the field's range and instant [EOL] long result = addWrapField(instant, amount); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testAddWrapField_Max() { [EOL] long instant = SOME_INSTANT; // Replace with an actual instant value [EOL] int amount = 1; [EOL] long expected = instant + 1; // Adjust expected value based on the field's range and instant [EOL] long result = addWrapField(instant, amount); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testAddWrapField_Wrap() { [EOL] long instant = SOME_INSTANT_AT_MAX; // Replace with an instant value at the max of the field's range [EOL] int amount = 1; [EOL] long expected = SOME_INSTANT_AT_MIN; // Replace with the min of the field's range [EOL] long result = addWrapField(instant, amount); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testAddWrapField_WrapNegative() { [EOL] long instant = SOME_INSTANT_AT_MIN; // Replace with an instant value at the min of the field's range [EOL] int amount = -1; [EOL] long expected = SOME_INSTANT_AT_MAX; // Replace with the max of the field's range [EOL] long result = addWrapField(instant, amount); [EOL] assertEquals(expected, result); [EOL] }
public void testSetWithinBounds() { [EOL] long instant = System.currentTimeMillis(); [EOL] int value = iMin; // Assuming iMin is within valid bounds and iOffset is known [EOL] long expected = super.set(instant, value - iOffset); // Assuming super.set() behavior is known [EOL] long result = set(instant, value); [EOL] assertEquals(expected, result); [EOL] }
public void testSetBelowMinimum() { [EOL] long instant = System.currentTimeMillis(); [EOL] int value = iMin - 1; // Value below minimum [EOL] try { [EOL] set(instant, value); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testSetAboveMaximum() { [EOL] long instant = System.currentTimeMillis(); [EOL] int value = iMax + 1; // Value above maximum [EOL] try { [EOL] set(instant, value); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public long roundHalfFloorTest() { [EOL] long instant = SOME_INSTANT_VALUE; [EOL] long expected = SOME_EXPECTED_RESULT; [EOL] long actual = roundHalfFloor(instant); [EOL] assert actual == expected : "Expected rounded value to be " + expected + " but was " + actual; [EOL] }
public long remainder(long instant) { [EOL] return getWrappedField().remainder(instant); [EOL] }
public void testGetTotalMillisByYearMonth_January() { [EOL] long millis = getTotalMillisByYearMonth(2021, 1); [EOL] assertEquals(0, millis); [EOL] }
public void testGetTotalMillisByYearMonth_February() { [EOL] long millis = getTotalMillisByYearMonth(2021, 2); [EOL] assertEquals(MILLIS_PER_MONTH, millis); [EOL] }
public void testGetTotalMillisByYearMonth_December() { [EOL] long millis = getTotalMillisByYearMonth(2021, 12); [EOL] assertEquals(11 * MILLIS_PER_MONTH, millis); [EOL] }
int getDayOfMonth(long millis) { [EOL] return (getDayOfYear(millis) - 1) % MONTH_LENGTH + 1; [EOL] }
public void testGetDaysInYearMonth_NotThirteenthMonth() { [EOL] int year = 2020; // Any year [EOL] int month = 1; // Not the 13th month [EOL] int expectedDays = MONTH_LENGTH; // Assuming MONTH_LENGTH is a constant representing the length of the month [EOL] int actualDays = getDaysInYearMonth(year, month); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testGetDaysInYearMonth_ThirteenthMonth_LeapYear() { [EOL] int year = 2020; // Leap year [EOL] int month = 13; [EOL] int expectedDays = 6; // 6 days for the 13th month in a leap year [EOL] int actualDays = getDaysInYearMonth(year, month); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testGetDaysInYearMonth_ThirteenthMonth_NonLeapYear() { [EOL] int year = 2019; // Non-leap year [EOL] int month = 13; [EOL] int expectedDays = 5; // 5 days for the 13th month in a non-leap year [EOL] int actualDays = getDaysInYearMonth(year, month); [EOL] assertEquals(expectedDays, actualDays); [EOL] }
public void testGetMonthOfYear_January() { [EOL] long januaryMillis = new GregorianCalendar(2021, Calendar.JANUARY, 1).getTimeInMillis(); [EOL] int month = getMonthOfYear(januaryMillis); [EOL] assertEquals(1, month); [EOL] }
public void testGetMonthOfYear_December() { [EOL] long decemberMillis = new GregorianCalendar(2021, Calendar.DECEMBER, 31).getTimeInMillis(); [EOL] int month = getMonthOfYear(decemberMillis); [EOL] assertEquals(12, month); [EOL] }
public void testGetMaxMonth() { [EOL] Time time = new Time(); [EOL] int maxMonth = time.getMaxMonth(); [EOL] assertEquals(13, maxMonth); [EOL] }
public void testGetAverageMillisPerYear() { [EOL] long expected = MILLIS_PER_YEAR; [EOL] long actual = getAverageMillisPerYear(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetAverageMillisPerMonth() { [EOL] Time time = new Time(); [EOL] long expected = Time.MILLIS_PER_MONTH; [EOL] long actual = time.getAverageMillisPerMonth(); [EOL] assertEquals(expected, actual); [EOL] }
public void testBasicWeekOfWeekyearDateTimeFieldWithNonNullChronology() { [EOL] BasicChronology chronology = new GregorianChronology(); [EOL] DurationField weeks = chronology.weeks(); [EOL] BasicWeekOfWeekyearDateTimeField field = new BasicWeekOfWeekyearDateTimeField(chronology, weeks); [EOL] assertNotNull(field); [EOL] assertEquals(DateTimeFieldType.weekOfWeekyear(), field.getType()); [EOL] assertEquals(chronology, field.getChronology()); [EOL] }
public void testBasicWeekOfWeekyearDateTimeFieldWithNullChronology() { [EOL] try { [EOL] new BasicWeekOfWeekyearDateTimeField(null, new MockDurationField()); [EOL] fail("Should have thrown IllegalArgumentException for null chronology"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetMaximumValue_WithWeekYearField() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.size()).thenReturn(1); [EOL] when(mockPartial.getFieldType(0)).thenReturn(DateTimeFieldType.weekyear()); [EOL] int[] values = {2023}; [EOL] when(iChronology.getWeeksInYear(2023)).thenReturn(52); [EOL] int result = instance.getMaximumValue(mockPartial, values); [EOL] assertEquals(52, result); [EOL] }
public void testGetMaximumValue_WithoutWeekYearField() { [EOL] ReadablePartial mockPartial = mock(ReadablePartial.class); [EOL] when(mockPartial.size()).thenReturn(1); [EOL] when(mockPartial.getFieldType(0)).thenReturn(DateTimeFieldType.year()); [EOL] int[] values = {2023}; [EOL] int result = instance.getMaximumValue(mockPartial, values); [EOL] assertEquals(53, result); [EOL] }
public void testMillisOfDay() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeField millisField = testDateTime.millisOfDay(); [EOL] assertNotNull(millisField); [EOL] assertEquals(millisField, testDateTime.getChronology().millisOfDay()); [EOL] }
public void testDayOfWeek() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeField dayOfWeekField = testDateTime.dayOfWeek(); [EOL] assertNotNull(dayOfWeekField); [EOL] }
public void testDays_Zero() { [EOL] Days result = Time.days(0); [EOL] assertEquals(Time.ZERO, result); [EOL] }
public void testDays_One() { [EOL] Days result = Time.days(1); [EOL] assertEquals(Time.ONE, result); [EOL] }
public void testDays_Two() { [EOL] Days result = Time.days(2); [EOL] assertEquals(Time.TWO, result); [EOL] }
public void testDays_Three() { [EOL] Days result = Time.days(3); [EOL] assertEquals(Time.THREE, result); [EOL] }
public void testDays_Four() { [EOL] Days result = Time.days(4); [EOL] assertEquals(Time.FOUR, result); [EOL] }
public void testDays_Five() { [EOL] Days result = Time.days(5); [EOL] assertEquals(Time.FIVE, result); [EOL] }
public void testDays_Six() { [EOL] Days result = Time.days(6); [EOL] assertEquals(Time.SIX, result); [EOL] }
public void testDays_Seven() { [EOL] Days result = Time.days(7); [EOL] assertEquals(Time.SEVEN, result); [EOL] }
public void testDays_MaxValue() { [EOL] Days result = Time.days(Integer.MAX_VALUE); [EOL] assertEquals(Time.MAX_VALUE, result); [EOL] }
public void testDays_MinValue() { [EOL] Days result = Time.days(Integer.MIN_VALUE); [EOL] assertEquals(Time.MIN_VALUE, result); [EOL] }
public void testDays_Default() { [EOL] int anyOtherDay = 8; // This can be any value not covered by the cases above [EOL] Days result = Time.days(anyOtherDay); [EOL] assertNotNull(result); [EOL] assertEquals(anyOtherDay, result.getDays()); [EOL] }
public void testDaysBetweenWithSameInstant() { [EOL] ReadableInstant start = new DateTime(); [EOL] ReadableInstant end = new DateTime(start); [EOL] Days result = Time.daysBetween(start, end); [EOL] assertEquals("The days between the same instants should be zero.", 0, result.getDays()); [EOL] } [EOL] public void testDaysBetweenWithDifferentInstant() { [EOL] ReadableInstant start = new DateTime(); [EOL] ReadableInstant end = start.plusDays(5); [EOL] Days result = Time.daysBetween(start, end); [EOL] assertEquals("The days between the two instants should be five.", 5, result.getDays()); [EOL] }
public void testDaysConstructor() { [EOL] int expectedDays = 5; [EOL] Days days = new Days(expectedDays); [EOL] assertEquals(expectedDays, days.getValue()); [EOL] }
public void testReadResolve() { [EOL] Days testDays = Days.days(5); [EOL] Object result = testDays.readResolve(); [EOL] assertTrue(result instanceof Days); [EOL] assertEquals(testDays, result); [EOL] }
public void testToStandardWeeks_ExactWeeks() { [EOL] Days days = Days.days(7); // exactly one week [EOL] Weeks weeks = days.toStandardWeeks(); [EOL] assertEquals(1, weeks.getWeeks()); [EOL] }
public void testToStandardWeeks_LessThanAWeek() { [EOL] Days days = Days.days(6); // less than one week [EOL] Weeks weeks = days.toStandardWeeks(); [EOL] assertEquals(0, weeks.getWeeks()); [EOL] }
public void testToStandardWeeks_MoreThanAWeek() { [EOL] Days days = Days.days(8); // more than one week [EOL] Weeks weeks = days.toStandardWeeks(); [EOL] assertEquals(1, weeks.getWeeks()); [EOL] }
public void testToStandardWeeks_NegativeDays() { [EOL] Days days = Days.days(-3); // negative days [EOL] Weeks weeks = days.toStandardWeeks(); [EOL] assertEquals(0, weeks.getWeeks()); [EOL] }
public void testToStandardWeeks_ZeroDays() { [EOL] Days days = Days.days(0); // zero days [EOL] Weeks weeks = days.toStandardWeeks(); [EOL] assertEquals(0, weeks.getWeeks()); [EOL] }
public void testToStandardMinutes() { [EOL] Days days = Days.days(1); [EOL] Minutes expectedMinutes = Minutes.minutes(1440); // 1 day = 1440 minutes [EOL] Minutes actualMinutes = days.toStandardMinutes(); [EOL] assertEquals(expectedMinutes, actualMinutes); [EOL] }
public void testToStandardMinutesWithZeroDays() { [EOL] Days days = Days.days(0); [EOL] Minutes expectedMinutes = Minutes.minutes(0); [EOL] Minutes actualMinutes = days.toStandardMinutes(); [EOL] assertEquals(expectedMinutes, actualMinutes); [EOL] }
public void testToStandardMinutesWithNegativeDays() { [EOL] Days days = Days.days(-1); [EOL] Minutes expectedMinutes = Minutes.minutes(-1440); // -1 day = -1440 minutes [EOL] Minutes actualMinutes = days.toStandardMinutes(); [EOL] assertEquals(expectedMinutes, actualMinutes); [EOL] }
public void testIsGreaterThanWithNull() { [EOL] Days days = new Days(1); [EOL] boolean result = days.isGreaterThan(null); [EOL] assert result; [EOL] }
public void testIsGreaterThanWithGreaterValue() { [EOL] Days days1 = new Days(2); [EOL] Days days2 = new Days(1); [EOL] boolean result = days1.isGreaterThan(days2); [EOL] assert result; [EOL] }
public void testIsGreaterThanWithLesserValue() { [EOL] Days days1 = new Days(1); [EOL] Days days2 = new Days(2); [EOL] boolean result = days1.isGreaterThan(days2); [EOL] assert !result; [EOL] }
public void testIsGreaterThanWithEqualValue() { [EOL] Days days1 = new Days(1); [EOL] Days days2 = new Days(1); [EOL] boolean result = days1.isGreaterThan(days2); [EOL] assert !result; [EOL] }
public void testIsLessThanWithNullOther() { [EOL] Days days = new Days(-1); [EOL] boolean result = days.isLessThan(null); [EOL] assertTrue(result); [EOL] }
public void testIsLessThanWithNullOtherAndPositiveDays() { [EOL] Days days = new Days(1); [EOL] boolean result = days.isLessThan(null); [EOL] assertFalse(result); [EOL] }
public void testIsLessThanWithNonNullOtherLess() { [EOL] Days days = new Days(1); [EOL] Days other = new Days(2); [EOL] boolean result = days.isLessThan(other); [EOL] assertTrue(result); [EOL] }
public void testIsLessThanWithNonNullOtherGreater() { [EOL] Days days = new Days(2); [EOL] Days other = new Days(1); [EOL] boolean result = days.isLessThan(other); [EOL] assertFalse(result); [EOL] }
public void testIsLessThanWithEqualDays() { [EOL] Days days = new Days(1); [EOL] Days other = new Days(1); [EOL] boolean result = days.isLessThan(other); [EOL] assertFalse(result); [EOL] }
public void testGJYearOfEraDateTimeField() { [EOL] DateTimeField mockYearField = mock(DateTimeField.class); [EOL] BasicChronology mockChronology = mock(BasicChronology.class); [EOL] GJYearOfEraDateTimeField field = new GJYearOfEraDateTimeField(mockYearField, mockChronology); [EOL] assertNotNull(field); [EOL] assertSame(mockYearField, field.iYearField); [EOL] assertSame(mockChronology, field.iChronology); [EOL] }
public void testGetRangeDurationField() { [EOL] DurationField rangeDurationField = instance.getRangeDurationField(); [EOL] assertNotNull("Range duration field should not be null", rangeDurationField); [EOL] }
public void testGetWithPositiveYear() { [EOL] long instant = /* some positive year instant */; [EOL] int expected = /* expected year */; [EOL] int actual = get(instant); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testGetWithNegativeYear() { [EOL] long instant = /* some negative year instant */; [EOL] int expected = 1 - /* expected negative year */; [EOL] int actual = get(instant); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testGetWithYearZero() { [EOL] long instant = /* instant representing year 0 */; [EOL] int expected = 1; // since year 0 should be converted to 1 [EOL] int actual = get(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testSetWithYearWithinBounds() { [EOL] long instant = System.currentTimeMillis(); // Replace with a fixed instant if needed [EOL] int year = 5; [EOL] long expected = /* some expected value based on the fixed instant and year */; [EOL] long result = set(instant, year); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testSetWithYearAtLowerBound() { [EOL] long instant = System.currentTimeMillis(); // Replace with a fixed instant if needed [EOL] int year = 1; [EOL] long expected = /* some expected value based on the fixed instant and year */; [EOL] long result = set(instant, year); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testSetWithYearAtUpperBound() { [EOL] long instant = System.currentTimeMillis(); // Replace with a fixed instant if needed [EOL] int year = getMaximumValue(); // This should be the maximum value that getMaximumValue() would return [EOL] long expected = /* some expected value based on the fixed instant and year */; [EOL] long result = set(instant, year); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testSetWithYearBelowLowerBound() { [EOL] long instant = System.currentTimeMillis(); // Replace with a fixed instant if needed [EOL] int year = 0; [EOL] try { [EOL] set(instant, year); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testSetWithYearAboveUpperBound() { [EOL] long instant = System.currentTimeMillis(); // Replace with a fixed instant if needed [EOL] int year = getMaximumValue() + 1; // This should be above the maximum value that getMaximumValue() would return [EOL] try { [EOL] set(instant, year); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testSetWithNegativeYearInBC() { [EOL] long instant = /* an instant that represents a year in BC */; [EOL] int year = -5; [EOL] long expected = /* some expected value based on the fixed instant and year */; [EOL] long result = set(instant, year); [EOL] assertEquals(expected, result); [EOL] } [EOL] public void testSetWithPositiveYearInBC() { [EOL] long instant = /* an instant that represents a year in BC */; [EOL] int year = 5; [EOL] long expected = /* some expected value based on the fixed instant and year */; [EOL] long result = set(instant, year); [EOL] assertEquals(expected, result); [EOL] }
public int getMaximumValue() { [EOL] return getWrappedField().getMaximumValue(); [EOL] }
@FromString [EOL] public static MonthDay parse(String str) { [EOL] return parse(str, PARSER); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=2954560699050434609L; DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
public void testParseWithFormatter() { [EOL] DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MM-dd"); [EOL] String input = "12-25"; [EOL] MonthDay expected = new MonthDay(12, 25); [EOL] MonthDay result = MonthDay.parse(input, formatter); [EOL] assertEquals(expected, result); [EOL] }
public void testParseWithFormatterInvalidInput() { [EOL] DateTimeFormatter formatter = DateTimeFormatter.ofPattern("MM-dd"); [EOL] String input = "invalid-date"; [EOL] try { [EOL] MonthDay.parse(input, formatter); [EOL] fail("Should have thrown an exception due to invalid input"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL] switch(index) { [EOL] case MONTH_OF_YEAR: [EOL] return chrono.monthOfYear(); [EOL] case DAY_OF_MONTH: [EOL] return chrono.dayOfMonth(); [EOL] default: [EOL] throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL] } [EOL] } [EOL] public MonthDay(); [EOL] public MonthDay(DateTimeZone zone); [EOL] public MonthDay(Chronology chronology); [EOL] public MonthDay(long instant); [EOL] public MonthDay(long instant, Chronology chronology); [EOL] public MonthDay(Object instant); [EOL] public MonthDay(Object instant, Chronology chronology); [EOL] public MonthDay(int monthOfYear, int dayOfMonth); [EOL] public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology); [EOL] MonthDay(MonthDay partial, int[] values); [EOL] MonthDay(MonthDay partial, Chronology chrono); [EOL] Property(MonthDay partial, int fieldIndex); [EOL] public static MonthDay now(); [EOL] public static MonthDay now(DateTimeZone zone); [EOL] public static MonthDay now(Chronology chronology); [EOL] public static MonthDay parse(String str); [EOL] public static MonthDay parse(String str, DateTimeFormatter formatter); [EOL] public static MonthDay fromCalendarFields(Calendar calendar); [EOL] public static MonthDay fromDateFields(Date date); [EOL] private Object readResolve(); [EOL] public int size(); [EOL] protected DateTimeField getField(int index, Chronology chrono); [EOL] public DateTimeFieldType getFieldType(int index); [EOL] public DateTimeFieldType[] getFieldTypes(); [EOL] public MonthDay withChronologyRetainFields(Chronology newChronology); [EOL] public MonthDay withField(DateTimeFieldType fieldType, int value); [EOL] public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); [EOL] public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); [EOL] public MonthDay plus(ReadablePeriod period); [EOL] public MonthDay plusMonths(int months); [EOL] public MonthDay plusDays(int days); [EOL] public MonthDay minus(ReadablePeriod period); [EOL] public MonthDay minusMonths(int months); [EOL] public MonthDay minusDays(int days); [EOL] public LocalDate toLocalDate(int year); [EOL] public int getMonthOfYear(); [EOL] public int getDayOfMonth(); [EOL] public MonthDay withMonthOfYear(int monthOfYear); [EOL] public MonthDay withDayOfMonth(int dayOfMonth); [EOL] public Property property(DateTimeFieldType type); [EOL] public Property monthOfYear(); [EOL] public Property dayOfMonth(); [EOL] public String toString(); [EOL] public String toString(String pattern); [EOL] public String toString(String pattern, Locale locale) throws IllegalArgumentException; [EOL] public DateTimeField getField(); [EOL] protected ReadablePartial getReadablePartial(); [EOL] public MonthDay getMonthDay(); [EOL] public int get(); [EOL] public MonthDay addToCopy(int valueToAdd); [EOL] public MonthDay addWrapFieldToCopy(int valueToAdd); [EOL] public MonthDay setCopy(int value); [EOL] public MonthDay setCopy(String text, Locale locale); [EOL] public MonthDay setCopy(String text); [EOL] long serialVersionUID=2954560699050434609L; [EOL] DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
@ToString [EOL] public String toString() { [EOL] List<DateTimeFieldType> fields = new ArrayList<DateTimeFieldType>(); [EOL] fields.add(DateTimeFieldType.monthOfYear()); [EOL] fields.add(DateTimeFieldType.dayOfMonth()); [EOL] return ISODateTimeFormat.forFields(fields, true, true).print(this); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=2954560699050434609L; DateTimeFieldType[] FIELD_TYPES=new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() };
public void testNowWithNullZone() { [EOL] try { [EOL] LocalDateTime.now(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException ex) { [EOL] assertEquals("Zone must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testNowWithNonNullZone() { [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] LocalDateTime result = LocalDateTime.now(zone); [EOL] assertNotNull(result); [EOL] assertEquals(zone, result.getZone()); [EOL] }
public void testFromCalendarFieldsWithNullCalendar() { [EOL] try { [EOL] LocalDateTime.fromCalendarFields(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] assertEquals("The calendar must not be null", ex.getMessage()); [EOL] } [EOL] }
public void testFromCalendarFieldsWithGregorianCalendarAD() { [EOL] Calendar calendar = new GregorianCalendar(2023, Calendar.MARCH, 25, 15, 40, 30); [EOL] calendar.set(Calendar.MILLISECOND, 123); [EOL] LocalDateTime dateTime = LocalDateTime.fromCalendarFields(calendar); [EOL] assertEquals(2023, dateTime.getYear()); [EOL] assertEquals(3, dateTime.getMonthOfYear()); [EOL] assertEquals(25, dateTime.getDayOfMonth()); [EOL] assertEquals(15, dateTime.getHourOfDay()); [EOL] assertEquals(40, dateTime.getMinuteOfHour()); [EOL] assertEquals(30, dateTime.getSecondOfMinute()); [EOL] assertEquals(123, dateTime.getMillisOfSecond()); [EOL] }
public void testFromCalendarFieldsWithGregorianCalendarBC() { [EOL] Calendar calendar = new GregorianCalendar(); [EOL] calendar.set(Calendar.ERA, GregorianCalendar.BC); [EOL] calendar.set(Calendar.YEAR, 2023); [EOL] calendar.set(Calendar.MONTH, Calendar.MARCH); [EOL] calendar.set(Calendar.DAY_OF_MONTH, 25); [EOL] calendar.set(Calendar.HOUR_OF_DAY, 15); [EOL] calendar.set(Calendar.MINUTE, 40); [EOL] calendar.set(Calendar.SECOND, 30); [EOL] calendar.set(Calendar.MILLISECOND, 123); [EOL] LocalDateTime dateTime = LocalDateTime.fromCalendarFields(calendar); [EOL] assertEquals(1 - 2023, dateTime.getYear()); [EOL] assertEquals(3, dateTime.getMonthOfYear()); [EOL] assertEquals(25, dateTime.getDayOfMonth()); [EOL] assertEquals(15, dateTime.getHourOfDay()); [EOL] assertEquals(40, dateTime.getMinuteOfHour()); [EOL] assertEquals(30, dateTime.getSecondOfMinute()); [EOL] assertEquals(123, dateTime.getMillisOfSecond()); [EOL] }
public void testLocalDateTimeWithNullZone() { [EOL] LocalDateTime result = new LocalDateTime((DateTimeZone) null); [EOL] assertNotNull(result); [EOL] assertEquals(ISOChronology.getInstanceUTC(), result.getChronology()); [EOL] }
public void testLocalDateTimeWithNonNullZone() { [EOL] DateTimeZone zone = DateTimeZone.forID("Europe/Paris"); [EOL] LocalDateTime result = new LocalDateTime(zone); [EOL] assertNotNull(result); [EOL] assertEquals(ISOChronology.getInstance(zone), result.getChronology()); [EOL] }
public void testLocalDateTimeWithValidInstantAndZone() { [EOL] long instant = System.currentTimeMillis(); [EOL] DateTimeZone zone = DateTimeZone.getDefault(); [EOL] LocalDateTime localDateTime = new LocalDateTime(instant, zone); [EOL] assertNotNull(localDateTime); [EOL] assertEquals(instant, localDateTime.toDateTime(zone).getMillis()); [EOL] }
public void testLocalDateTimeWithNullZone() { [EOL] long instant = System.currentTimeMillis(); [EOL] try { [EOL] new LocalDateTime(instant, null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public int size() { [EOL] return 4; [EOL] }
public void testGetFieldWithYear() { [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] DateTimeField field = getField(YEAR, chrono); [EOL] assertNotNull(field); [EOL] assertEquals(chrono.year(), field); [EOL] }
public void testGetFieldWithMonthOfYear() { [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] DateTimeField field = getField(MONTH_OF_YEAR, chrono); [EOL] assertNotNull(field); [EOL] assertEquals(chrono.monthOfYear(), field); [EOL] }
public void testGetFieldWithDayOfMonth() { [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] DateTimeField field = getField(DAY_OF_MONTH, chrono); [EOL] assertNotNull(field); [EOL] assertEquals(chrono.dayOfMonth(), field); [EOL] }
public void testGetFieldWithMillisOfDay() { [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] DateTimeField field = getField(MILLIS_OF_DAY, chrono); [EOL] assertNotNull(field); [EOL] assertEquals(chrono.millisOfDay(), field); [EOL] }
public void testGetFieldWithInvalidIndex() { [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] try { [EOL] getField(-1, chrono); [EOL] fail("Should have thrown IndexOutOfBoundsException"); [EOL] } catch (IndexOutOfBoundsException ex) { [EOL] } [EOL] }
public void testGetValueYear() { [EOL] int index = YEAR; // Assuming YEAR is a constant defined somewhere [EOL] int expectedValue = 2023; // Assuming this is the expected year value [EOL] int actualValue = getValue(index); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetValueMonthOfYear() { [EOL] int index = MONTH_OF_YEAR; // Assuming MONTH_OF_YEAR is a constant defined somewhere [EOL] int expectedValue = 4; // Assuming this is the expected month value [EOL] int actualValue = getValue(index); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetValueDayOfMonth() { [EOL] int index = DAY_OF_MONTH; // Assuming DAY_OF_MONTH is a constant defined somewhere [EOL] int expectedValue = 15; // Assuming this is the expected day of month value [EOL] int actualValue = getValue(index); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetValueMillisOfDay() { [EOL] int index = MILLIS_OF_DAY; // Assuming MILLIS_OF_DAY is a constant defined somewhere [EOL] int expectedValue = 123456789; // Assuming this is the expected millis of day value [EOL] int actualValue = getValue(index); [EOL] assertEquals(expectedValue, actualValue); [EOL] }
public void testGetValueInvalidIndex() { [EOL] int index = -1; // Assuming this is an invalid index [EOL] try { [EOL] getValue(index); [EOL] fail("Expected an IndexOutOfBoundsException to be thrown"); [EOL] } catch (IndexOutOfBoundsException e) { [EOL] assertEquals("Invalid index: " + index, e.getMessage()); [EOL] } [EOL] }
public void testCompareTo_SameInstance() { [EOL] ReadablePartial partial = createPartial(); // Assume createPartial() creates an instance of the class containing the compareTo method [EOL] int result = partial.compareTo(partial); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testCompareTo_LocalDateTimeSameChronology() { [EOL] LocalDateTime partial1 = new LocalDateTime(0L, iChronology); // Assume iChronology is initialized properly [EOL] LocalDateTime partial2 = new LocalDateTime(0L, iChronology); [EOL] int result = partial1.compareTo(partial2); [EOL] assertEquals(0, result); [EOL] } [EOL] public void testCompareTo_LocalDateTimeDifferentChronology() { [EOL] LocalDateTime partial1 = new LocalDateTime(0L, iChronology); [EOL] Chronology otherChronology = // Initialize a different chronology [EOL] LocalDateTime partial2 = new LocalDateTime(0L, otherChronology); [EOL] int result = partial1.compareTo(partial2); [EOL] assertNotEquals(0, result); // Assuming super.compareTo() does not return 0 for different chronologies [EOL] } [EOL] public void testCompareTo_LocalDateTimeDifferentMillis() { [EOL] LocalDateTime partial1 = new LocalDateTime(0L, iChronology); [EOL] LocalDateTime partial2 = new LocalDateTime(1L, iChronology); // 1 millisecond later [EOL] int result = partial1.compareTo(partial2); [EOL] assertEquals(-1, result); [EOL] } [EOL] public void testCompareTo_LocalDateTimeDifferentMillisInverse() { [EOL] LocalDateTime partial1 = new LocalDateTime(1L, iChronology); [EOL] LocalDateTime partial2 = new LocalDateTime(0L, iChronology); // 1 millisecond earlier [EOL] int result = partial1.compareTo(partial2); [EOL] assertEquals(1, result); [EOL] } [EOL] public void testCompareTo_NonLocalDateTime() { [EOL] ReadablePartial partial1 = createPartial(); [EOL] ReadablePartial partial2 = new ReadablePartial() { [EOL] }; [EOL] int result = partial1.compareTo(partial2); [EOL] assertEquals(super.compareTo(partial2), result); [EOL] }

public void testToLocalTime() { [EOL] DateTime dateTime = new DateTime(2023, 3, 25, 10, 30, 0, 0); [EOL] LocalTime expected = new LocalTime(10, 30, 0, 0); [EOL] LocalTime actual = dateTime.toLocalTime(); [EOL] assertEquals(expected, actual); [EOL] }
public void testCorrectDstTransitionBefore() { [EOL] TimeZone timeZone = TimeZone.getTimeZone("America/New_York"); [EOL] LocalDateTime localDateTime = LocalDateTime.now(); [EOL] Date date = Date.from(localDateTime.minusDays(1).atZone(ZoneId.systemDefault()).toInstant()); [EOL] Date result = correctDstTransition(date, timeZone); [EOL] Calendar calendar = Calendar.getInstance(timeZone); [EOL] calendar.setTime(result); [EOL] LocalDateTime resultCheck = LocalDateTime.fromCalendarFields(calendar); [EOL] assertTrue(resultCheck.isAfter(localDateTime)); [EOL] }
public void testCorrectDstTransitionEquals() { [EOL] TimeZone timeZone = TimeZone.getTimeZone("America/New_York"); [EOL] LocalDateTime localDateTime = LocalDateTime.now(); [EOL] Date date = Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant()); [EOL] Date result = correctDstTransition(date, timeZone); [EOL] Calendar calendar = Calendar.getInstance(timeZone); [EOL] calendar.setTime(result); [EOL] LocalDateTime resultCheck = LocalDateTime.fromCalendarFields(calendar); [EOL] assertTrue(resultCheck.equals(localDateTime) || resultCheck.isAfter(localDateTime)); [EOL] }
public void testCorrectDstTransitionAfter() { [EOL] TimeZone timeZone = TimeZone.getTimeZone("America/New_York"); [EOL] LocalDateTime localDateTime = LocalDateTime.now(); [EOL] Date date = Date.from(localDateTime.plusDays(1).atZone(ZoneId.systemDefault()).toInstant()); [EOL] Date result = correctDstTransition(date, timeZone); [EOL] Calendar calendar = Calendar.getInstance(timeZone); [EOL] calendar.setTime(result); [EOL] LocalDateTime resultCheck = LocalDateTime.fromCalendarFields(calendar); [EOL] assertTrue(resultCheck.isBefore(localDateTime)); [EOL] }
public void testWithField_NullFieldType() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] try { [EOL] dateTime.withField(null, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Field must not be null", e.getMessage()); [EOL] } [EOL] }
public void testWithField_ValidField() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); [EOL] int value = 15; [EOL] LocalDateTime updatedDateTime = dateTime.withField(fieldType, value); [EOL] assertEquals(value, updatedDateTime.getDayOfMonth()); [EOL] }
public void testWithPeriodAdded_NullPeriod() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.withPeriodAdded(null, 1); [EOL] assertEquals(dateTime, result); [EOL] } [EOL] public void testWithPeriodAdded_ZeroScalar() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] ReadablePeriod period = Period.days(1); [EOL] LocalDateTime result = dateTime.withPeriodAdded(period, 0); [EOL] assertEquals(dateTime, result); [EOL] } [EOL] public void testWithPeriodAdded_NonNullPeriodNonZeroScalar() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] ReadablePeriod period = Period.days(1); [EOL] LocalDateTime result = dateTime.withPeriodAdded(period, 1); [EOL] assertNotEquals(dateTime, result); // Assuming that the period does indeed add time [EOL] }
public void testPlusYears_ZeroYears() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime sameDateTime = dateTime.plusYears(0); [EOL] assertEquals(dateTime, sameDateTime); [EOL] }
public void testPlusYears_PositiveYears() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime futureDateTime = dateTime.plusYears(5); [EOL] assertNotEquals(dateTime, futureDateTime); [EOL] assertEquals(dateTime.getYear() + 5, futureDateTime.getYear()); [EOL] }
public void testPlusYears_NegativeYears() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime pastDateTime = dateTime.plusYears(-5); [EOL] assertNotEquals(dateTime, pastDateTime); [EOL] assertEquals(dateTime.getYear() - 5, pastDateTime.getYear()); [EOL] }
public void testPlusMonths_ZeroMonths() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.plusMonths(0); [EOL] assertEquals(dateTime, result); [EOL] }
public void testPlusMonths_PositiveMonths() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.plusMonths(5); [EOL] assertNotSame(dateTime, result); [EOL] assertEquals(dateTime.plusMonths(5), result); [EOL] }
public void testPlusMonths_NegativeMonths() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.plusMonths(-5); [EOL] assertNotSame(dateTime, result); [EOL] assertEquals(dateTime.plusMonths(-5), result); [EOL] }
public void testPlusMinutes_Zero() { [EOL] LocalDateTime time = LocalDateTime.now(); [EOL] LocalDateTime result = time.plusMinutes(0); [EOL] assertEquals(time, result); [EOL] }
public void testPlusMinutes_Positive() { [EOL] LocalDateTime time = LocalDateTime.now(); [EOL] LocalDateTime result = time.plusMinutes(15); [EOL] assertNotEquals(time, result); [EOL] assertEquals(15, Duration.between(time, result).toMinutes()); [EOL] }
public void testPlusMinutes_Negative() { [EOL] LocalDateTime time = LocalDateTime.now(); [EOL] LocalDateTime result = time.plusMinutes(-15); [EOL] assertNotEquals(time, result); [EOL] assertEquals(-15, Duration.between(time, result).toMinutes()); [EOL] }
public void testPlusSeconds_Zero() { [EOL] LocalDateTime time = LocalDateTime.now(); [EOL] LocalDateTime result = time.plusSeconds(0); [EOL] assertSame("Expected same instance when adding zero seconds", time, result); [EOL] }
public void testPlusSeconds_Positive() { [EOL] LocalDateTime time = LocalDateTime.now(); [EOL] LocalDateTime result = time.plusSeconds(3600); [EOL] assertNotSame("Expected different instance when adding seconds", time, result); [EOL] assertEquals("Expected time plus one hour", time.plusHours(1), result); [EOL] }
public void testPlusSeconds_Negative() { [EOL] LocalDateTime time = LocalDateTime.now(); [EOL] LocalDateTime result = time.plusSeconds(-3600); [EOL] assertNotSame("Expected different instance when subtracting seconds", time, result); [EOL] assertEquals("Expected time minus one hour", time.minusHours(1), result); [EOL] }
public void testMinus_withNullPeriod() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.minus(null); [EOL] assertEquals("Minus with null period should return the same LocalDateTime", dateTime, result); [EOL] }
public void testMinus_withValidPeriod() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] Period period = Period.days(1); [EOL] LocalDateTime expected = dateTime.minusDays(1); [EOL] LocalDateTime result = dateTime.minus(period); [EOL] assertEquals("Minus with a valid period should return the correct LocalDateTime", expected, result); [EOL] }
public void testMinusSeconds_Zero() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.minusSeconds(0); [EOL] assertEquals(dateTime, result); [EOL] }
public void testMinusSeconds_Positive() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.minusSeconds(10); [EOL] assertNotEquals(dateTime, result); [EOL] assertEquals(dateTime.minus(Duration.ofSeconds(10)), result); [EOL] }
public void testMinusSeconds_Negative() { [EOL] LocalDateTime dateTime = LocalDateTime.now(); [EOL] LocalDateTime result = dateTime.minusSeconds(-10); [EOL] assertNotEquals(dateTime, result); [EOL] assertEquals(dateTime.plus(Duration.ofSeconds(10)), result); [EOL] }
public void testGetSupportedType() { [EOL] Time time = new Time(); [EOL] Class<?> supportedType = time.getSupportedType(); [EOL] assertEquals(Calendar.class, supportedType); [EOL] }
public void testUTCProviderConstructor() { [EOL] UTCProvider utcProvider = new UTCProvider(); [EOL] assertNotNull(utcProvider); [EOL] }
public void testGetAvailableIDs() { [EOL] Time time = new Time(); [EOL] Set<String> ids = time.getAvailableIDs(); [EOL] assertNotNull(ids); [EOL] assertEquals(1, ids.size()); [EOL] assertTrue(ids.contains("UTC")); [EOL] }
public void testWithLocaleSameLocale() { [EOL] Locale locale = Locale.ENGLISH; [EOL] DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd").withLocale(locale); [EOL] DateTimeFormatter result = formatter.withLocale(locale); [EOL] assertSame(formatter, result); [EOL] } [EOL] public void testWithLocaleDifferentLocale() { [EOL] Locale initialLocale = Locale.ENGLISH; [EOL] Locale newLocale = Locale.FRENCH; [EOL] DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd").withLocale(initialLocale); [EOL] DateTimeFormatter result = formatter.withLocale(newLocale); [EOL] assertNotSame(formatter, result); [EOL] assertEquals(newLocale, result.getLocale()); [EOL] } [EOL] public void testWithLocaleNullLocale() { [EOL] Locale initialLocale = Locale.ENGLISH; [EOL] DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd").withLocale(initialLocale); [EOL] DateTimeFormatter result = formatter.withLocale(null); [EOL] assertNotSame(formatter, result); [EOL] assertNull(result.getLocale()); [EOL] }
public void testWithChronology_SameChronology() { [EOL] Chronology chrono = ISOChronology.getInstance(); [EOL] DateTimeFormatter formatter = new DateTimeFormatter(null, null, Locale.getDefault(), false, chrono, null, null, 2000); [EOL] DateTimeFormatter result = formatter.withChronology(chrono); [EOL] assertSame(formatter, result); [EOL] }
public void testWithChronology_DifferentChronology() { [EOL] Chronology initialChrono = ISOChronology.getInstance(); [EOL] Chronology newChrono = GregorianChronology.getInstance(); [EOL] DateTimeFormatter formatter = new DateTimeFormatter(null, null, Locale.getDefault(), false, initialChrono, null, null, 2000); [EOL] DateTimeFormatter result = formatter.withChronology(newChrono); [EOL] assertNotSame(formatter, result); [EOL] assertSame(newChrono, result.getChronolgy()); [EOL] }
public void testWithPivotYearSameAsCurrent() { [EOL] DateTimeFormatter formatter = new DateTimeFormatter(null, null, null, false, null, null, 2000, 2000); [EOL] DateTimeFormatter result = formatter.withPivotYear(2000); [EOL] assertSame("Should return the same DateTimeFormatter object", formatter, result); [EOL] } [EOL] public void testWithPivotYearDifferentFromCurrent() { [EOL] DateTimeFormatter formatter = new DateTimeFormatter(null, null, null, false, null, null, 2000, 2000); [EOL] DateTimeFormatter result = formatter.withPivotYear(2010); [EOL] assertNotSame("Should return a new DateTimeFormatter object", formatter, result); [EOL] assertEquals("Pivot year should be updated", 2010, result.getPivotYear().intValue()); [EOL] } [EOL] public void testWithPivotYearNullWhenCurrentIsNull() { [EOL] DateTimeFormatter formatter = new DateTimeFormatter(null, null, null, false, null, null, null, 2000); [EOL] DateTimeFormatter result = formatter.withPivotYear(null); [EOL] assertSame("Should return the same DateTimeFormatter object when pivotYear is null", formatter, result); [EOL] } [EOL] public void testWithPivotYearNonNullWhenCurrentIsNull() { [EOL] DateTimeFormatter formatter = new DateTimeFormatter(null, null, null, false, null, null, null, 2000); [EOL] DateTimeFormatter result = formatter.withPivotYear(2010); [EOL] assertNotSame("Should return a new DateTimeFormatter object", formatter, result); [EOL] assertEquals("Pivot year should be updated", 2010, result.getPivotYear().intValue()); [EOL] } [EOL] public void testWithPivotYearNullWhenCurrentIsNonNull() { [EOL] DateTimeFormatter formatter = new DateTimeFormatter(null, null, null, false, null, null, 2000, 2000); [EOL] DateTimeFormatter result = formatter.withPivotYear(null); [EOL] assertNotSame("Should return a new DateTimeFormatter object", formatter, result); [EOL] assertNull("Pivot year should be null", result.getPivotYear()); [EOL] }
public void testWithDefaultYear_ValidYear() { [EOL] DateTimeFormatter dtf = new DateTimeFormatter(null, null, null, false, null, null, null, 2000); [EOL] DateTimeFormatter newDtf = dtf.withDefaultYear(2020); [EOL] assertNotNull(newDtf); [EOL] assertEquals(2020, newDtf.getDefaultYear()); [EOL] }
public void testWithDefaultYear_NegativeYear() { [EOL] DateTimeFormatter dtf = new DateTimeFormatter(null, null, null, false, null, null, null, 2000); [EOL] DateTimeFormatter newDtf = dtf.withDefaultYear(-1); [EOL] assertNotNull(newDtf); [EOL] assertEquals(-1, newDtf.getDefaultYear()); [EOL] }
public void testParseInto_NullInstant_ThrowsIllegalArgumentException() { [EOL] try { [EOL] parseInto(null, "2023-04-01T00:00:00Z", 0); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Instant must not be null", e.getMessage()); [EOL] } [EOL] }
public void testParseInto_ValidInstantAndText_ParsesCorrectly() { [EOL] ReadWritableInstant mockInstant = createMockInstant(); [EOL] String text = "2023-04-01T00:00:00Z"; [EOL] int position = 0; [EOL] int result = parseInto(mockInstant, text, position); [EOL] }
public void testParseInto_WithOffsetParsed_UpdatesOffset() { [EOL] ReadWritableInstant mockInstant = createMockInstant(); [EOL] String text = "2023-04-01T00:00:00+02:00"; [EOL] int position = 0; [EOL] int result = parseInto(mockInstant, text, position); [EOL] }
public void testParseInto_WithZone_UpdatesZone() { [EOL] ReadWritableInstant mockInstant = createMockInstant(); [EOL] String text = "2023-04-01T00:00:00Z"; [EOL] int position = 0; [EOL] int result = parseInto(mockInstant, text, position); [EOL] }
public void testParseMillis_Success() { [EOL] String text = "2023-04-01T00:00:00Z"; // Assuming this is a valid date string for the parser [EOL] long expectedMillis = /* some expected millis value, e.g., the result of parsing the above date */; [EOL] long actualMillis = parseMillis(text); [EOL] assertEquals(expectedMillis, actualMillis); [EOL] }
public void testParseMillis_PartialSuccess() { [EOL] String text = "2023-04-01T00"; // Assuming this is a valid partial date string for the parser [EOL] try { [EOL] parseMillis(text); [EOL] fail("Should have thrown IllegalArgumentException due to incomplete parsing"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testParseMillis_Failure() { [EOL] String text = "InvalidDateString"; [EOL] try { [EOL] parseMillis(text); [EOL] fail("Should have thrown IllegalArgumentException due to invalid date string"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public LocalDate parseLocalDate(String text) { [EOL] return parseLocalDateTime(text).toLocalDate(); [EOL] }
public void testParseLocalDateTime_ValidInput() { [EOL] String validInput = "2023-03-20T10:15:30"; // Assuming this is a valid input for the parser [EOL] LocalDateTime result = parseLocalDateTime(validInput); [EOL] assertNotNull(result); [EOL] assertEquals(2023, result.getYear()); [EOL] assertEquals(3, result.getMonthOfYear()); [EOL] assertEquals(20, result.getDayOfMonth()); [EOL] assertEquals(10, result.getHourOfDay()); [EOL] assertEquals(15, result.getMinuteOfHour()); [EOL] assertEquals(30, result.getSecondOfMinute()); [EOL] } [EOL] public void testParseLocalDateTime_InvalidInput() { [EOL] String invalidInput = "invalid-date-time"; // Assuming this is an invalid input for the parser [EOL] try { [EOL] parseLocalDateTime(invalidInput); [EOL] fail("Expected IllegalArgumentException to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Cannot parse \"invalid-date-time\": not a valid representation (error at index 0)", e.getMessage()); [EOL] } [EOL] }
public void testParseLocalDateTime_ValidInputWithOffset() { [EOL] String validInputWithOffset = "2023-03-20T10:15:30+02:00"; // Assuming this is a valid input with offset [EOL] LocalDateTime result = parseLocalDateTime(validInputWithOffset); [EOL] assertNotNull(result); [EOL] assertEquals(2023, result.getYear()); [EOL] assertEquals(3, result.getMonthOfYear()); [EOL] assertEquals(20, result.getDayOfMonth()); [EOL] assertEquals(8, result.getHourOfDay()); // Adjusted for the offset [EOL] assertEquals(15, result.getMinuteOfHour()); [EOL] assertEquals(30, result.getSecondOfMinute()); [EOL] }
public void testParseLocalDateTime_ValidInputWithZone() { [EOL] String validInputWithZone = "2023-03-20T10:15:30Z"; // Assuming this is a valid input with UTC zone [EOL] LocalDateTime result = parseLocalDateTime(validInputWithZone); [EOL] assertNotNull(result); [EOL] assertEquals(2023, result.getYear()); [EOL] assertEquals(3, result.getMonthOfYear()); [EOL] assertEquals(20, result.getDayOfMonth()); [EOL] assertEquals(10, result.getHourOfDay()); [EOL] assertEquals(15, result.getMinuteOfHour()); [EOL] assertEquals(30, result.getSecondOfMinute()); [EOL] }
public void testSelectChronologyWithNullChronoAndNullZone() { [EOL] Chronology result = selectChronology(null); [EOL] assertNotNull(result); [EOL] assertEquals(DateTimeUtils.getChronology(null), result); [EOL] }
public void testSelectChronologyWithNonNullChronoAndNullZone() { [EOL] Chronology inputChrono = ISOChronology.getInstance(); [EOL] Chronology result = selectChronology(inputChrono); [EOL] assertNotNull(result); [EOL] assertEquals(inputChrono, result); [EOL] }
public void testSelectChronologyWithNullChronoAndNonNullZone() { [EOL] iZone = DateTimeZone.forID("Europe/Paris"); [EOL] Chronology result = selectChronology(null); [EOL] assertNotNull(result); [EOL] assertEquals(DateTimeUtils.getChronology(null).withZone(iZone), result); [EOL] }
public void testSelectChronologyWithNonNullChronoAndNonNullZone() { [EOL] iZone = DateTimeZone.forID("Europe/Paris"); [EOL] Chronology inputChrono = ISOChronology.getInstance(); [EOL] Chronology result = selectChronology(inputChrono); [EOL] assertNotNull(result); [EOL] assertEquals(inputChrono.withZone(iZone), result); [EOL] }
public void testSelectChronologyWithNonNullChronoAndNonNullFixedChrono() { [EOL] iChrono = BuddhistChronology.getInstance(); [EOL] Chronology inputChrono = ISOChronology.getInstance(); [EOL] Chronology result = selectChronology(inputChrono); [EOL] assertNotNull(result); [EOL] assertEquals(iChrono, result); [EOL] }
public void testSelectChronologyWithNullChronoAndNonNullFixedChrono() { [EOL] iChrono = BuddhistChronology.getInstance(); [EOL] Chronology result = selectChronology(null); [EOL] assertNotNull(result); [EOL] assertEquals(iChrono, result); [EOL] }
public void testSelectChronologyWithNonNullChronoNonNullFixedChronoAndNonNullZone() { [EOL] iChrono = BuddhistChronology.getInstance(); [EOL] iZone = DateTimeZone.forID("Europe/Paris"); [EOL] Chronology inputChrono = ISOChronology.getInstance(); [EOL] Chronology result = selectChronology(inputChrono); [EOL] assertNotNull(result); [EOL] assertEquals(iChrono.withZone(iZone), result); [EOL] }
public void testAdd_ZeroDuration() { [EOL] long instant = 1000L; [EOL] long duration = 0L; [EOL] int scalar = 1; [EOL] long result = add(instant, duration, scalar); [EOL] assertEquals(instant, result); [EOL] }
public void testAdd_ZeroScalar() { [EOL] long instant = 1000L; [EOL] long duration = 500L; [EOL] int scalar = 0; [EOL] long result = add(instant, duration, scalar); [EOL] assertEquals(instant, result); [EOL] }
public void testAdd_PositiveDurationPositiveScalar() { [EOL] long instant = 1000L; [EOL] long duration = 500L; [EOL] int scalar = 2; [EOL] long result = add(instant, duration, scalar); [EOL] assertEquals(2000L, result); [EOL] }
public void testAdd_NegativeDurationNegativeScalar() { [EOL] long instant = 1000L; [EOL] long duration = -500L; [EOL] int scalar = -2; [EOL] long result = add(instant, duration, scalar); [EOL] assertEquals(2000L, result); [EOL] }
public long getMillisTestWithValueAndInstant() { [EOL] long value = 12345L; [EOL] long instant = 67890L; [EOL] long result = getMillis(value, instant); [EOL] assertEquals(value, result); [EOL] }
public String toString() { [EOL] return "DurationField[millis]"; [EOL] }
public void testDateTimeFieldTypeConstructor() { [EOL] String name = "testName"; [EOL] DateTimeFieldType fieldType = new DateTimeFieldType(name); [EOL] assertNotNull(fieldType); [EOL] assertEquals("testName", fieldType.getName()); [EOL] }
public void testCenturyOfEra() { [EOL] DateTimeFieldType type = DateTimeFieldType.centuryOfEra(); [EOL] assertNotNull("CenturyOfEra should not be null", type); [EOL] assertEquals("Type should be centuryOfEra", DateTimeFieldType.centuryOfEra(), type); [EOL] }
public String getName() { [EOL] return iName; [EOL] }
public void testIsSupportedWithSupportedChronology() { [EOL] Chronology supportedChronology = Mockito.mock(Chronology.class); [EOL] Mockito.when(supportedChronology.isSupported()).thenReturn(true); [EOL] boolean result = isSupported(supportedChronology); [EOL] assertTrue(result); [EOL] }
public void testIsSupportedWithUnsupportedChronology() { [EOL] Chronology unsupportedChronology = Mockito.mock(Chronology.class); [EOL] Mockito.when(unsupportedChronology.isSupported()).thenReturn(false); [EOL] boolean result = isSupported(unsupportedChronology); [EOL] assertFalse(result); [EOL] }
public void testGetDurationType() { [EOL] DurationFieldType type = DurationFieldType.hours(); [EOL] DurationField field = type.getField(ISOChronology.getInstanceUTC()); [EOL] assertEquals(type, field.getDurationType()); [EOL] }
public void testGetRangeDurationType() { [EOL] DurationFieldType expected = DurationFieldType.hours(); [EOL] MyClass myClassInstance = new MyClass(expected); [EOL] DurationFieldType actual = myClassInstance.getRangeDurationType(); [EOL] assertEquals("The range duration type should be the expected one", expected, actual); [EOL] }
public void testEquals_Reflexive() { [EOL] StandardDateTimeFieldType fieldType = StandardDateTimeFieldType.year(); [EOL] assertTrue(fieldType.equals(fieldType)); [EOL] }
public void testEquals_SameOrdinal() { [EOL] StandardDateTimeFieldType fieldType1 = StandardDateTimeFieldType.year(); [EOL] StandardDateTimeFieldType fieldType2 = StandardDateTimeFieldType.year(); [EOL] assertTrue(fieldType1.equals(fieldType2)); [EOL] }
public void testEquals_DifferentOrdinal() { [EOL] StandardDateTimeFieldType fieldType1 = StandardDateTimeFieldType.year(); [EOL] StandardDateTimeFieldType fieldType2 = StandardDateTimeFieldType.monthOfYear(); [EOL] assertFalse(fieldType1.equals(fieldType2)); [EOL] }
public void testEquals_Null() { [EOL] StandardDateTimeFieldType fieldType = StandardDateTimeFieldType.year(); [EOL] assertFalse(fieldType.equals(null)); [EOL] }
public void testEquals_DifferentClass() { [EOL] StandardDateTimeFieldType fieldType = StandardDateTimeFieldType.year(); [EOL] Object obj = new Object(); [EOL] assertFalse(fieldType.equals(obj)); [EOL] }
public void testGetFieldWithEra() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = ERA; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.era(), field); [EOL] }
public void testGetFieldWithYearOfEra() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = YEAR_OF_ERA; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.yearOfEra(), field); [EOL] }
public void testGetFieldWithCenturyOfEra() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = CENTURY_OF_ERA; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.centuryOfEra(), field); [EOL] }
public void testGetFieldWithYearOfCentury() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = YEAR_OF_CENTURY; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.yearOfCentury(), field); [EOL] }
public void testGetFieldWithYear() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = YEAR; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.year(), field); [EOL] }
public void testGetFieldWithDayOfYear() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = DAY_OF_YEAR; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.dayOfYear(), field); [EOL] }
public void testGetFieldWithMonthOfYear() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = MONTH_OF_YEAR; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.monthOfYear(), field); [EOL] }
public void testGetFieldWithDayOfMonth() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = DAY_OF_MONTH; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.dayOfMonth(), field); [EOL] }
public void testGetFieldWithWeekyearOfCentury() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = WEEKYEAR_OF_CENTURY; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.weekyearOfCentury(), field); [EOL] }
public void testGetFieldWithWeekyear() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = WEEKYEAR; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.weekyear(), field); [EOL] }
public void testGetFieldWithWeekOfWeekyear() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = WEEK_OF_WEEKYEAR; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.weekOfWeekyear(), field); [EOL] }
public void testGetFieldWithDayOfWeek() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = DAY_OF_WEEK; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.dayOfWeek(), field); [EOL] }
public void testGetFieldWithHalfdayOfDay() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = HALFDAY_OF_DAY; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.halfdayOfDay(), field); [EOL] }
public void testGetFieldWithHourOfHalfday() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = HOUR_OF_HALFDAY; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.hourOfHalfday(), field); [EOL] }
public void testGetFieldWithClockhourOfHalfday() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = CLOCKHOUR_OF_HALFDAY; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.clockhourOfHalfday(), field); [EOL] }
public void testGetFieldWithClockhourOfDay() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = CLOCKHOUR_OF_DAY; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.clockhourOfDay(), field); [EOL] }
public void testGetFieldWithHourOfDay() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = HOUR_OF_DAY; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.hourOfDay(), field); [EOL] }
public void testGetFieldWithMinuteOfDay() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = MINUTE_OF_DAY; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.minuteOfDay(), field); [EOL] }
public void testGetFieldWithMinuteOfHour() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = MINUTE_OF_HOUR; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.minuteOfHour(), field); [EOL] }
public void testGetFieldWithSecondOfDay() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = SECOND_OF_DAY; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.secondOfDay(), field); [EOL] }
public void testGetFieldWithSecondOfMinute() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = SECOND_OF_MINUTE; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.secondOfMinute(), field); [EOL] }
public void testGetFieldWithMillisOfDay() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = MILLIS_OF_DAY; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.millisOfDay(), field); [EOL] }
public void testGetFieldWithMillisOfSecond() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = MILLIS_OF_SECOND; [EOL] DateTimeField field = getField(chronology, iOrdinal); [EOL] assertEquals(chronology.millisOfSecond(), field); [EOL] }
public void testGetFieldWithInvalidOrdinal() { [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] int iOrdinal = INVALID_ORDINAL; // This should be a constant representing an invalid ordinal value [EOL] try { [EOL] getField(chronology, iOrdinal); [EOL] fail("Should have thrown InternalError"); [EOL] } catch (InternalError e) { [EOL] } [EOL] }
public void testReadResolveWithERA() { [EOL] TimeType timeType = new TimeType(TimeType.ERA); // Replace TimeType with the actual type name [EOL] Object resolved = timeType.readResolve(); [EOL] assertEquals(TimeType.ERA_TYPE, resolved); [EOL] }
public void testReadResolveWithYEAR_OF_ERA() { [EOL] TimeType timeType = new TimeType(TimeType.YEAR_OF_ERA); [EOL] Object resolved = timeType.readResolve(); [EOL] assertEquals(TimeType.YEAR_OF_ERA_TYPE, resolved); [EOL] }
public void testReadResolveWithCENTURY_OF_ERA() { [EOL] TimeType timeType = new TimeType(TimeType.CENTURY_OF_ERA); [EOL] Object resolved = timeType.readResolve(); [EOL] assertEquals(TimeType.CENTURY_OF_ERA_TYPE, resolved); [EOL] }
public void testReadResolveWithYEAR_OF_CENTURY() { [EOL] TimeType timeType = new TimeType(TimeType.YEAR_OF_CENTURY); [EOL] Object resolved = timeType.readResolve(); [EOL] assertEquals(TimeType.YEAR_OF_CENTURY_TYPE, resolved); [EOL] }
public void testReadResolveWithYEAR() { [EOL] TimeType timeType = new TimeType(TimeType.YEAR); [EOL] Object resolved = timeType.readResolve(); [EOL] assertEquals(TimeType.YEAR_TYPE, resolved); [EOL] }
public void testReadResolveWithDAY_OF_YEAR() { [EOL] TimeType timeType = new TimeType(TimeType.DAY_OF_YEAR); [EOL] Object resolved = timeType.readResolve(); [EOL] assertEquals(TimeType.DAY_OF_YEAR_TYPE, resolved); [EOL] }
public void testReadResolveWithMONTH_OF_YEAR() { [EOL] TimeType timeType = new TimeType(TimeType.MONTH_OF_YEAR); [EOL] Object resolved = timeType.readResolve(); [EOL] assertEquals(TimeType.MONTH_OF_YEAR_TYPE, resolved); [EOL] }
public void testReadResolveWithDAY_OF_MONTH() { [EOL] TimeType timeType = new TimeType(TimeType.DAY_OF_MONTH); [EOL] Object resolved = timeType.readResolve(); [EOL] assertEquals(TimeType.DAY_OF_MONTH_TYPE, resolved); [EOL] }
public void testReadResolveWithWEEKYEAR_OF_CENTURY() { [EOL] TimeType timeType = new TimeType(TimeType.WEEKYEAR_OF_CENTURY); [EOL] Object resolved = timeType.readResolve(); [EOL] assertEquals(TimeType.WEEKYEAR_OF_CENTURY_TYPE, resolved); [EOL] }
public void testReadResolveWithWEEKYEAR() { [EOL] TimeType timeType = new TimeType(TimeType.WEEKYEAR); [EOL] Object resolved = timeType.readResolve(); [EOL] assertEquals(TimeType.WEEKYEAR_TYPE, resolved); [EOL] }
public void testReadResolveWithWEEK_OF_WEEKYEAR() { [EOL] TimeType timeType = new TimeType(TimeType.WEEK_OF_WEEKYEAR); [EOL] Object resolved = timeType.readResolve(); [EOL] assertEquals(TimeType.WEEK_OF_WEEKYEAR_TYPE, resolved); [EOL] }
public void testReadResolveWithDAY_OF_WEEK() { [EOL] TimeType timeType = new TimeType(TimeType.DAY_OF_WEEK); [EOL] Object resolved = timeType.readResolve(); [EOL] assertEquals(TimeType.DAY_OF_WEEK_TYPE, resolved); [EOL] }
public void testReadResolveWithHALFDAY_OF_DAY() { [EOL] TimeType timeType = new TimeType(TimeType.HALFDAY_OF_DAY); [EOL] Object resolved = timeType.readResolve(); [EOL] assertEquals(TimeType.HALFDAY_OF_DAY_TYPE, resolved); [EOL] }
public void testReadResolveWithHOUR_OF_HALFDAY() { [EOL] TimeType timeType = new TimeType(TimeType.HOUR_OF_HALFDAY); [EOL] Object resolved = timeType.readResolve(); [EOL] assertEquals(TimeType.HOUR_OF_HALFDAY_TYPE, resolved); [EOL] }
public void testReadResolveWithCLOCKHOUR_OF_HALFDAY() { [EOL] TimeType timeType = new TimeType(TimeType.CLOCKHOUR_OF_HALFDAY); [EOL] Object resolved = timeType.readResolve(); [EOL] assertEquals(TimeType.CLOCKHOUR_OF_HALFDAY_TYPE, resolved); [EOL] }
public void testReadResolveWithCLOCKHOUR_OF_DAY() { [EOL] TimeType timeType = new TimeType(TimeType.CLOCKHOUR_OF_DAY); [EOL] Object resolved = timeType.readResolve(); [EOL] assertEquals(TimeType.CLOCKHOUR_OF_DAY_TYPE, resolved); [EOL] }
public void testReadResolveWithHOUR_OF_DAY() { [EOL] TimeType timeType = new TimeType(TimeType.HOUR_OF_DAY); [EOL] Object resolved = timeType.readResolve(); [EOL] assertEquals(TimeType.HOUR_OF_DAY_TYPE, resolved); [EOL] }
public void testReadResolveWithMINUTE_OF_DAY() { [EOL] TimeType timeType = new TimeType(TimeType.MINUTE_OF_DAY); [EOL] Object resolved = timeType.readResolve(); [EOL] assertEquals(TimeType.MINUTE_OF_DAY_TYPE, resolved); [EOL] }
public void testReadResolveWithMINUTE_OF_HOUR() { [EOL] TimeType timeType = new TimeType(TimeType.MINUTE_OF_HOUR); [EOL] Object resolved = timeType.readResolve(); [EOL] assertEquals(TimeType.MINUTE_OF_HOUR_TYPE, resolved); [EOL] }
public void testReadResolveWithSECOND_OF_DAY() { [EOL] TimeType timeType = new TimeType(TimeType.SECOND_OF_DAY); [EOL] Object resolved = timeType.readResolve(); [EOL] assertEquals(TimeType.SECOND_OF_DAY_TYPE, resolved); [EOL] }
public void testReadResolveWithSECOND_OF_MINUTE() { [EOL] TimeType timeType = new TimeType(TimeType.SECOND_OF_MINUTE); [EOL] Object resolved = timeType.readResolve(); [EOL] assertEquals(TimeType.SECOND_OF_MINUTE_TYPE, resolved); [EOL] }
public void testReadResolveWithMILLIS_OF_DAY() { [EOL] TimeType timeType = new TimeType(TimeType.MILLIS_OF_DAY); [EOL] Object resolved = timeType.readResolve(); [EOL] assertEquals(TimeType.MILLIS_OF_DAY_TYPE, resolved); [EOL] }
public void testReadResolveWithMILLIS_OF_SECOND() { [EOL] TimeType timeType = new TimeType(TimeType.MILLIS_OF_SECOND); [EOL] Object resolved = timeType.readResolve(); [EOL] assertEquals(TimeType.MILLIS_OF_SECOND_TYPE, resolved); [EOL] }
public void testReadResolveWithDefault() { [EOL] TimeType timeType = new TimeType(-1); // Assuming -1 is not a valid ordinal [EOL] Object resolved = timeType.readResolve(); [EOL] assertSame(timeType, resolved); [EOL] }
public void testIsLongerThanWithNullDuration() { [EOL] Duration testDuration = Duration.ofHours(1); [EOL] boolean result = testDuration.isLongerThan(null); [EOL] assertTrue(result); [EOL] }
public void testIsLongerThanWithShorterDuration() { [EOL] Duration testDuration = Duration.ofHours(1); [EOL] Duration shortDuration = Duration.ofMinutes(30); [EOL] boolean result = testDuration.isLongerThan(shortDuration); [EOL] assertTrue(result); [EOL] }
public void testIsLongerThanWithLongerDuration() { [EOL] Duration testDuration = Duration.ofHours(1); [EOL] Duration longDuration = Duration.ofHours(2); [EOL] boolean result = testDuration.isLongerThan(longDuration); [EOL] assertFalse(result); [EOL] }
public void testIsLongerThanWithEqualDuration() { [EOL] Duration testDuration = Duration.ofHours(1); [EOL] Duration equalDuration = Duration.ofHours(1); [EOL] boolean result = testDuration.isLongerThan(equalDuration); [EOL] assertFalse(result); [EOL] }
public void testEquals_SameObject() { [EOL] ReadableDuration duration = new MockDuration(); [EOL] assertTrue(duration.equals(duration)); [EOL] } [EOL] public void testEquals_Null() { [EOL] ReadableDuration duration = new MockDuration(); [EOL] assertFalse(duration.equals(null)); [EOL] } [EOL] public void testEquals_DifferentType() { [EOL] ReadableDuration duration = new MockDuration(); [EOL] assertFalse(duration.equals(new Object())); [EOL] } [EOL] public void testEquals_DifferentDuration() { [EOL] ReadableDuration duration1 = new MockDuration(123L); [EOL] ReadableDuration duration2 = new MockDuration(456L); [EOL] assertFalse(duration1.equals(duration2)); [EOL] } [EOL] public void testEquals_SameDuration() { [EOL] ReadableDuration duration1 = new MockDuration(123L); [EOL] ReadableDuration duration2 = new MockDuration(123L); [EOL] assertTrue(duration1.equals(duration2)); [EOL] }

public void testHashCode() { [EOL] Time time = new Time(); [EOL] time.setMillis(123456789L); [EOL] int expectedHashCode = (int) (123456789L ^ (123456789L >>> 32)); [EOL] assertEquals(expectedHashCode, time.hashCode()); [EOL] }
public void testForLocaleWithNullLocale() { [EOL] GJLocaleSymbols result = GJLocaleSymbols.forLocale(null); [EOL] assertNotNull(result); [EOL] assertEquals(Locale.getDefault(), result.getLocale()); [EOL] }
public void testForLocaleWithNonNullLocale() { [EOL] Locale locale = new Locale("en", "US"); [EOL] GJLocaleSymbols result = GJLocaleSymbols.forLocale(locale); [EOL] assertNotNull(result); [EOL] assertEquals(locale, result.getLocale()); [EOL] }
public void testForLocaleWithCachedLocale() { [EOL] Locale locale = new Locale("en", "US"); [EOL] GJLocaleSymbols cachedSymbols = prepopulateCache(locale); [EOL] GJLocaleSymbols result = GJLocaleSymbols.forLocale(locale); [EOL] assertSame(cachedSymbols, result); [EOL] }
public void testRealignMonths_ValidInput() { [EOL] String[] inputMonths = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}; [EOL] String[] expectedMonths = {null, "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"}; [EOL] String[] resultMonths = realignMonths(inputMonths); [EOL] assertArrayEquals(expectedMonths, resultMonths); [EOL] }
public void testRealignDaysOfWeek_ValidInput() { [EOL] String[] input = {"", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"}; [EOL] String[] expected = {"", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday", "Monday"}; [EOL] String[] result = realignDaysOfWeek(input); [EOL] for (int i = 0; i < expected.length; i++) { [EOL] assertEquals(expected[i], result[i]); [EOL] } [EOL] }
public void testAddSymbolsAllNonNull() { [EOL] TreeMap<String, Integer> map = new TreeMap<>(); [EOL] String[] symbols = {"A", "B", "C"}; [EOL] Integer[] integers = {1, 2, 3}; [EOL] addSymbols(map, symbols, integers); [EOL] assertEquals(3, map.size()); [EOL] assertEquals(Integer.valueOf(1), map.get("A")); [EOL] assertEquals(Integer.valueOf(2), map.get("B")); [EOL] assertEquals(Integer.valueOf(3), map.get("C")); [EOL] } [EOL] public void testAddSymbolsWithNullSymbols() { [EOL] TreeMap<String, Integer> map = new TreeMap<>(); [EOL] String[] symbols = {null, "B", null}; [EOL] Integer[] integers = {1, 2, 3}; [EOL] addSymbols(map, symbols, integers); [EOL] assertEquals(1, map.size()); [EOL] assertEquals(Integer.valueOf(2), map.get("B")); [EOL] } [EOL] public void testAddSymbolsWithEmptyArrays() { [EOL] TreeMap<String, Integer> map = new TreeMap<>(); [EOL] String[] symbols = {}; [EOL] Integer[] integers = {}; [EOL] addSymbols(map, symbols, integers); [EOL] assertTrue(map.isEmpty()); [EOL] }
public void testAddNumeralsWithEmptyMap() { [EOL] TreeMap<String, Integer> map = new TreeMap<>(); [EOL] Integer[] integers = new Integer[]{0, 1, 2, 3, 4, 5}; [EOL] addNumerals(map, 0, 5, integers); [EOL] assertEquals(6, map.size()); [EOL] for (int i = 0; i <= 5; i++) { [EOL] assertEquals(Integer.valueOf(i), map.get(String.valueOf(i))); [EOL] } [EOL] } [EOL] public void testAddNumeralsWithNonEmptyMap() { [EOL] TreeMap<String, Integer> map = new TreeMap<>(); [EOL] map.put("existing", 10); [EOL] Integer[] integers = new Integer[]{0, 1, 2, 3, 4, 5, 6}; [EOL] addNumerals(map, 1, 5, integers); [EOL] assertEquals(6, map.size()); [EOL] assertEquals(Integer.valueOf(10), map.get("existing")); [EOL] for (int i = 1; i <= 5; i++) { [EOL] assertEquals(Integer.valueOf(i), map.get(String.valueOf(i))); [EOL] } [EOL] } [EOL] public void testAddNumeralsWithPartialRange() { [EOL] TreeMap<String, Integer> map = new TreeMap<>(); [EOL] Integer[] integers = new Integer[]{0, 1, 2, 3}; [EOL] addNumerals(map, 1, 2, integers); [EOL] assertEquals(2, map.size()); [EOL] assertEquals(Integer.valueOf(1), map.get("1")); [EOL] assertEquals(Integer.valueOf(2), map.get("2")); [EOL] }
public void testMaxLengthWithEmptyArray() { [EOL] String[] array = {}; [EOL] int result = maxLength(array); [EOL] assertEquals(0, result); [EOL] }
public void testMaxLengthWithAllNullElements() { [EOL] String[] array = {null, null, null}; [EOL] int result = maxLength(array); [EOL] assertEquals(0, result); [EOL] }
public void testMaxLengthWithSomeNullElements() { [EOL] String[] array = {null, "test", null}; [EOL] int result = maxLength(array); [EOL] assertEquals(4, result); [EOL] }
public void testMaxLengthWithAllNonNullElements() { [EOL] String[] array = {"test", "longestString", "short"}; [EOL] int result = maxLength(array); [EOL] assertEquals(13, result); [EOL] }
public void testMaxLengthWithSingleElement() { [EOL] String[] array = {"single"}; [EOL] int result = maxLength(array); [EOL] assertEquals(6, result); [EOL] }
public void testGJLocaleSymbolsWithNonEnglishLocale() { [EOL] Locale nonEnglishLocale = new Locale("fr", "FR"); [EOL] GJLocaleSymbols symbols = new GJLocaleSymbols(nonEnglishLocale); [EOL] assertNotNull(symbols.iLocale.get()); [EOL] assertNotEquals("en", symbols.iLocale.get().getLanguage()); [EOL] assertEquals(13, symbols.iParseEras.size()); [EOL] assertEquals(7, symbols.iParseDaysOfWeek.size()); [EOL] assertEquals(12, symbols.iParseMonths.size()); [EOL] assertTrue(symbols.iMaxEraLength > 0); [EOL] assertTrue(symbols.iMaxDayOfWeekLength > 0); [EOL] assertTrue(symbols.iMaxShortDayOfWeekLength > 0); [EOL] assertTrue(symbols.iMaxMonthLength > 0); [EOL] assertTrue(symbols.iMaxShortMonthLength > 0); [EOL] assertTrue(symbols.iMaxHalfdayLength > 0); [EOL] }
public void testGJLocaleSymbolsWithEnglishLocale() { [EOL] Locale englishLocale = new Locale("en", "US"); [EOL] GJLocaleSymbols symbols = new GJLocaleSymbols(englishLocale); [EOL] assertNotNull(symbols.iLocale.get()); [EOL] assertEquals("en", symbols.iLocale.get().getLanguage()); [EOL] assertEquals(15, symbols.iParseEras.size()); // BCE and CE added [EOL] assertEquals(7, symbols.iParseDaysOfWeek.size()); [EOL] assertEquals(12, symbols.iParseMonths.size()); [EOL] assertTrue(symbols.iMaxEraLength > 0); [EOL] assertTrue(symbols.iMaxDayOfWeekLength > 0); [EOL] assertTrue(symbols.iMaxShortDayOfWeekLength > 0); [EOL] assertTrue(symbols.iMaxMonthLength > 0); [EOL] assertTrue(symbols.iMaxShortMonthLength > 0); [EOL] assertTrue(symbols.iMaxHalfdayLength > 0); [EOL] }
public void testEraTextToValueWithValidEra() { [EOL] String validEraText = "ValidEra"; // Assume this is a valid era text in iParseEras [EOL] int expectedValue = 1; // Assume this is the mapped value for the valid era [EOL] int actualValue = eraTextToValue(validEraText); [EOL] assertEquals(expectedValue, actualValue); [EOL] } [EOL] public void testEraTextToValueWithInvalidEra() { [EOL] String invalidEraText = "InvalidEra"; [EOL] try { [EOL] eraTextToValue(invalidEraText); [EOL] fail("Should have thrown IllegalFieldValueException"); [EOL] } catch (IllegalFieldValueException ex) { [EOL] assertEquals(DateTimeFieldType.era(), ex.getFieldType()); [EOL] assertEquals(invalidEraText, ex.getIllegalValue()); [EOL] } [EOL] }
public void testMonthOfYearValueToText_ValidValue() { [EOL] String[] iMonths = {"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"}; [EOL] Time time = new Time(iMonths); [EOL] assertEquals("January", time.monthOfYearValueToText(0)); [EOL] assertEquals("December", time.monthOfYearValueToText(11)); [EOL] }
public void testMonthOfYearValueToText_InvalidValue() { [EOL] String[] iMonths = {"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"}; [EOL] Time time = new Time(iMonths); [EOL] try { [EOL] time.monthOfYearValueToText(-1); [EOL] fail("Should have thrown an exception for invalid month value"); [EOL] } catch (ArrayIndexOutOfBoundsException e) { [EOL] } [EOL] try { [EOL] time.monthOfYearValueToText(12); [EOL] fail("Should have thrown an exception for invalid month value"); [EOL] } catch (ArrayIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testMonthOfYearTextToValue_ValidMonth() { [EOL] String validMonthText = "January"; [EOL] int expectedMonthValue = 1; // Assuming January is represented by 1 [EOL] int actualMonthValue = monthOfYearTextToValue(validMonthText); [EOL] assertEquals(expectedMonthValue, actualMonthValue); [EOL] }
public void testMonthOfYearTextToValue_InvalidMonth() { [EOL] String invalidMonthText = "NotAMonth"; [EOL] try { [EOL] monthOfYearTextToValue(invalidMonthText); [EOL] fail("Expected an IllegalFieldValueException to be thrown"); [EOL] } catch (IllegalFieldValueException ex) { [EOL] assertEquals(DateTimeFieldType.monthOfYear(), ex.getFieldType()); [EOL] assertEquals(invalidMonthText, ex.getIllegalValue()); [EOL] } [EOL] }
public int getMonthMaxTextLength() { [EOL] return iMaxMonthLength; [EOL] }
public void testDayOfWeekValueToText_ValidValue() { [EOL] String[] iDaysOfWeek = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}; [EOL] Time time = new Time(iDaysOfWeek); [EOL] assertEquals("Sunday", time.dayOfWeekValueToText(0)); [EOL] assertEquals("Monday", time.dayOfWeekValueToText(1)); [EOL] assertEquals("Tuesday", time.dayOfWeekValueToText(2)); [EOL] assertEquals("Wednesday", time.dayOfWeekValueToText(3)); [EOL] assertEquals("Thursday", time.dayOfWeekValueToText(4)); [EOL] assertEquals("Friday", time.dayOfWeekValueToText(5)); [EOL] assertEquals("Saturday", time.dayOfWeekValueToText(6)); [EOL] }
public void testDayOfWeekValueToText_InvalidValue() { [EOL] String[] iDaysOfWeek = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}; [EOL] Time time = new Time(iDaysOfWeek); [EOL] try { [EOL] time.dayOfWeekValueToText(-1); [EOL] fail("Should have thrown ArrayIndexOutOfBoundsException"); [EOL] } catch (ArrayIndexOutOfBoundsException e) { [EOL] } [EOL] try { [EOL] time.dayOfWeekValueToText(7); [EOL] fail("Should have thrown ArrayIndexOutOfBoundsException"); [EOL] } catch (ArrayIndexOutOfBoundsException e) { [EOL] } [EOL] }
public void testDayOfWeekTextToValue_ValidDay() { [EOL] Map<String, Integer> iParseDaysOfWeek = new HashMap<>(); [EOL] iParseDaysOfWeek.put("Monday", 1); [EOL] iParseDaysOfWeek.put("Tuesday", 2); [EOL] iParseDaysOfWeek.put("Wednesday", 3); [EOL] iParseDaysOfWeek.put("Thursday", 4); [EOL] iParseDaysOfWeek.put("Friday", 5); [EOL] iParseDaysOfWeek.put("Saturday", 6); [EOL] iParseDaysOfWeek.put("Sunday", 7); [EOL] Time time = new Time(iParseDaysOfWeek); [EOL] assertEquals(1, time.dayOfWeekTextToValue("Monday")); [EOL] assertEquals(2, time.dayOfWeekTextToValue("Tuesday")); [EOL] assertEquals(3, time.dayOfWeekTextToValue("Wednesday")); [EOL] assertEquals(4, time.dayOfWeekTextToValue("Thursday")); [EOL] assertEquals(5, time.dayOfWeekTextToValue("Friday")); [EOL] assertEquals(6, time.dayOfWeekTextToValue("Saturday")); [EOL] assertEquals(7, time.dayOfWeekTextToValue("Sunday")); [EOL] }
public void testDayOfWeekTextToValue_InvalidDay() { [EOL] Map<String, Integer> iParseDaysOfWeek = new HashMap<>(); [EOL] iParseDaysOfWeek.put("Monday", 1); [EOL] iParseDaysOfWeek.put("Tuesday", 2); [EOL] iParseDaysOfWeek.put("Wednesday", 3); [EOL] iParseDaysOfWeek.put("Thursday", 4); [EOL] iParseDaysOfWeek.put("Friday", 5); [EOL] iParseDaysOfWeek.put("Saturday", 6); [EOL] iParseDaysOfWeek.put("Sunday", 7); [EOL] Time time = new Time(iParseDaysOfWeek); [EOL] try { [EOL] time.dayOfWeekTextToValue("NotADay"); [EOL] fail("Expected IllegalFieldValueException"); [EOL] } catch (IllegalFieldValueException e) { [EOL] } [EOL] }
public void testGetDayOfWeekMaxTextLength() { [EOL] Time time = new Time(); [EOL] int expectedLength = 9; // Assuming 9 is the maximum length of the day of the week text [EOL] time.iMaxDayOfWeekLength = expectedLength; [EOL] int actualLength = time.getDayOfWeekMaxTextLength(); [EOL] assertEquals(expectedLength, actualLength); [EOL] }
public int halfdayTextToValue(String text) { [EOL] String[] halfday = iHalfday; [EOL] for (int i = halfday.length; --i >= 0; ) { [EOL] if (halfday[i].equalsIgnoreCase(text)) { [EOL] return i; [EOL] } [EOL] } [EOL] throw new IllegalFieldValueException(DateTimeFieldType.halfdayOfDay(), text); [EOL] }
public void testToInstant() { [EOL] DateTime dateTime = new DateTime(); [EOL] Instant instant = dateTime.toInstant(); [EOL] assertEquals(dateTime.getMillis(), instant.getMillis()); [EOL] }
public void testToDateTimeISO_WithDefaultZone() { [EOL] DateTimeZone defaultZone = DateTimeZone.getDefault(); [EOL] Instant instant = new Instant(); [EOL] DateTime result = instant.toDateTimeISO(); [EOL] assertEquals(defaultZone, result.getZone()); [EOL] assertEquals(instant.getMillis(), result.getMillis()); [EOL] assertTrue(result.getChronology() instanceof ISOChronology); [EOL] }
public void testToDateTimeISO_WithSpecificZone() { [EOL] DateTimeZone specificZone = DateTimeZone.forID("Europe/Paris"); [EOL] Instant instant = new Instant(new DateTime(specificZone).getMillis()); [EOL] DateTime result = instant.toDateTimeISO(); [EOL] assertEquals(specificZone, result.getZone()); [EOL] assertEquals(instant.getMillis(), result.getMillis()); [EOL] assertTrue(result.getChronology() instanceof ISOChronology); [EOL] }
public void testToDateTimeWithNullChronology() { [EOL] Instant instant = new Instant(); [EOL] DateTime result = instant.toDateTime(null); [EOL] assertNotNull(result); [EOL] assertEquals(instant.getMillis(), result.getMillis()); [EOL] assertNull(result.getChronology()); [EOL] }
public void testToDateTimeWithNonNullChronology() { [EOL] Instant instant = new Instant(); [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] DateTime result = instant.toDateTime(chronology); [EOL] assertNotNull(result); [EOL] assertEquals(instant.getMillis(), result.getMillis()); [EOL] assertEquals(chronology, result.getChronology()); [EOL] }
public void testCompareTo_SameInstance() { [EOL] ReadableInstant instant = new ReadableInstant() { [EOL] public long getMillis() { [EOL] return 0; [EOL] } [EOL] }; [EOL] int result = instant.compareTo(instant); [EOL] assertEquals(0, result); [EOL] }
public void testCompareTo_EqualMillis() { [EOL] ReadableInstant instant1 = new ReadableInstant() { [EOL] public long getMillis() { [EOL] return 1000; [EOL] } [EOL] }; [EOL] ReadableInstant instant2 = new ReadableInstant() { [EOL] public long getMillis() { [EOL] return 1000; [EOL] } [EOL] }; [EOL] int result = instant1.compareTo(instant2); [EOL] assertEquals(0, result); [EOL] }
public void testCompareTo_LessMillis() { [EOL] ReadableInstant instant1 = new ReadableInstant() { [EOL] public long getMillis() { [EOL] return 500; [EOL] } [EOL] }; [EOL] ReadableInstant instant2 = new ReadableInstant() { [EOL] public long getMillis() { [EOL] return 1000; [EOL] } [EOL] }; [EOL] int result = instant1.compareTo(instant2); [EOL] assertEquals(-1, result); [EOL] }
public void testCompareTo_MoreMillis() { [EOL] ReadableInstant instant1 = new ReadableInstant() { [EOL] public long getMillis() { [EOL] return 1500; [EOL] } [EOL] }; [EOL] ReadableInstant instant2 = new ReadableInstant() { [EOL] public long getMillis() { [EOL] return 1000; [EOL] } [EOL] }; [EOL] int result = instant1.compareTo(instant2); [EOL] assertEquals(1, result); [EOL] }
public boolean isBeforeNow() { [EOL] return isBefore(DateTimeUtils.currentTimeMillis()); [EOL] }
public void testIsEqual_SameInstant() { [EOL] long instant = System.currentTimeMillis(); [EOL] Time time = new Time(instant); [EOL] assertTrue(time.isEqual(instant)); [EOL] }
public void testIsEqual_DifferentInstant() { [EOL] long instant = System.currentTimeMillis(); [EOL] Time time = new Time(instant); [EOL] assertFalse(time.isEqual(instant + 1)); [EOL] }
public boolean isEqualNow() { [EOL] return isEqual(DateTimeUtils.currentTimeMillis()); [EOL] }
public void testToStringWithNullFormatter() { [EOL] DateTime testDateTime = new DateTime(); [EOL] String result = testDateTime.toString(null); [EOL] assertNotNull(result); [EOL] assertEquals(testDateTime.toString(), result); [EOL] }
public void testToStringWithNonNullFormatter() { [EOL] DateTime testDateTime = new DateTime(); [EOL] DateTimeFormatter formatter = DateTimeFormat.forPattern("yyyy-MM-dd"); [EOL] String result = testDateTime.toString(formatter); [EOL] assertNotNull(result); [EOL] assertEquals(formatter.print(testDateTime), result); [EOL] }
public void testDividedDateTimeFieldWithValidInput() { [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] DateTimeFieldType mockType = Mockito.mock(DateTimeFieldType.class); [EOL] int divisor = 10; [EOL] DividedDateTimeField dividedDateTimeField = new DividedDateTimeField(mockField, mockType, divisor); [EOL] assertNotNull(dividedDateTimeField); [EOL] }
public void testDividedDateTimeFieldWithZeroDivisor() { [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] DateTimeFieldType mockType = Mockito.mock(DateTimeFieldType.class); [EOL] int divisor = 0; [EOL] try { [EOL] new DividedDateTimeField(mockField, mockType, divisor); [EOL] fail("Should have thrown IllegalArgumentException for zero divisor"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testDividedDateTimeFieldWithNegativeDivisor() { [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] DateTimeFieldType mockType = Mockito.mock(DateTimeFieldType.class); [EOL] int divisor = -1; [EOL] try { [EOL] new DividedDateTimeField(mockField, mockType, divisor); [EOL] fail("Should have thrown IllegalArgumentException for negative divisor"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testDividedDateTimeField_ValidDivisor() { [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] DurationField mockRangeField = Mockito.mock(DurationField.class); [EOL] DateTimeFieldType mockType = Mockito.mock(DateTimeFieldType.class); [EOL] DurationField mockUnitField = Mockito.mock(DurationField.class); [EOL] DurationType mockDurationType = Mockito.mock(DurationType.class); [EOL] Mockito.when(mockField.getDurationField()).thenReturn(mockUnitField); [EOL] Mockito.when(mockType.getDurationType()).thenReturn(mockDurationType); [EOL] Mockito.when(mockField.getMinimumValue()).thenReturn(0); [EOL] Mockito.when(mockField.getMaximumValue()).thenReturn(10); [EOL] DividedDateTimeField dividedDateTimeField = new DividedDateTimeField(mockField, mockRangeField, mockType, 2); [EOL] assertNotNull(dividedDateTimeField); [EOL] assertEquals(2, dividedDateTimeField.getDivisor()); [EOL] assertEquals(0, dividedDateTimeField.getMinimumValue()); [EOL] assertEquals(5, dividedDateTimeField.getMaximumValue()); [EOL] }
public void testDividedDateTimeField_InvalidDivisor() { [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] DurationField mockRangeField = Mockito.mock(DurationField.class); [EOL] DateTimeFieldType mockType = Mockito.mock(DateTimeFieldType.class); [EOL] try { [EOL] new DividedDateTimeField(mockField, mockRangeField, mockType, 1); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("The divisor must be at least 2", e.getMessage()); [EOL] } [EOL] }
public void testDividedDateTimeField_NullUnitField() { [EOL] DateTimeField mockField = Mockito.mock(DateTimeField.class); [EOL] DurationField mockRangeField = Mockito.mock(DurationField.class); [EOL] DateTimeFieldType mockType = Mockito.mock(DateTimeFieldType.class); [EOL] Mockito.when(mockField.getDurationField()).thenReturn(null); [EOL] Mockito.when(mockField.getMinimumValue()).thenReturn(-1); [EOL] Mockito.when(mockField.getMaximumValue()).thenReturn(-10); [EOL] DividedDateTimeField dividedDateTimeField = new DividedDateTimeField(mockField, mockRangeField, mockType, 2); [EOL] assertNull(dividedDateTimeField.getDurationField()); [EOL] assertEquals(-1, dividedDateTimeField.getMinimumValue()); [EOL] assertEquals(-5, dividedDateTimeField.getMaximumValue()); [EOL] }
public void testGetRangeDurationField_WithNonNullField() { [EOL] DurationField mockField = new MockDurationField(); [EOL] MyClass testClass = new MyClass(mockField); [EOL] DurationField result = testClass.getRangeDurationField(); [EOL] assertSame("Expected the non-null range duration field to be returned", mockField, result); [EOL] }
public void testGetRangeDurationField_WithNullField() { [EOL] MyClass testClass = new MyClass(null); [EOL] DurationField result = testClass.getRangeDurationField(); [EOL] DurationField expected = testClass.super.getRangeDurationField(); [EOL] assertSame("Expected the superclass's range duration field to be returned", expected, result); [EOL] }
public void testGetWithPositiveValue() { [EOL] long instant = /* some positive instant value */; [EOL] int expected = /* expected result for positive value */; [EOL] int actual = get(instant); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testGetWithNegativeValue() { [EOL] long instant = /* some negative instant value */; [EOL] int expected = /* expected result for negative value */; [EOL] int actual = get(instant); [EOL] assertEquals(expected, actual); [EOL] } [EOL] public void testGetWithZeroValue() { [EOL] long instant = 0; [EOL] int expected = 0; [EOL] int actual = get(instant); [EOL] assertEquals(expected, actual); [EOL] }
public void testSetWithMinimumValue() { [EOL] long instant = System.currentTimeMillis(); [EOL] int value = iMin; // Assuming iMin is the minimum value allowed for the field [EOL] long expected = getWrappedField().set(instant, value * iDivisor); // Assuming this is the expected result [EOL] long result = set(instant, value); [EOL] assertEquals(expected, result); [EOL] }
public void testSetWithMaximumValue() { [EOL] long instant = System.currentTimeMillis(); [EOL] int value = iMax; // Assuming iMax is the maximum value allowed for the field [EOL] long expected = getWrappedField().set(instant, value * iDivisor); // Assuming this is the expected result [EOL] long result = set(instant, value); [EOL] assertEquals(expected, result); [EOL] }
public void testSetWithOutOfBoundsValue() { [EOL] long instant = System.currentTimeMillis(); [EOL] int value = iMax + 1; // Value out of bounds [EOL] try { [EOL] set(instant, value); [EOL] fail("Should have thrown an IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetDurationField() { [EOL] MyClass myClassInstance = new MyClass(durationFieldInstance); [EOL] DurationField result = myClassInstance.getDurationField(); [EOL] assertNotNull("DurationField should not be null", result); [EOL] assertSame("Expected the same DurationField instance", durationFieldInstance, result); [EOL] }
public int getMinimumValueTest() { [EOL] Time time = new Time(10); [EOL] int minValue = time.getMinimumValue(); [EOL] assertEquals(10, minValue); [EOL] }
public void testGetMaximumValue() { [EOL] Time time = new Time(); [EOL] int expected = // set the expected value based on the context or preconditions [EOL] int actual = time.getMaximumValue(); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetRemainderWithPositiveValue() { [EOL] int value = 10; // Assume iDivisor is initialized to a positive value, e.g., 3 [EOL] int expected = value % iDivisor; [EOL] int actual = getRemainder(value); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetRemainderWithNegativeValue() { [EOL] int value = -10; // Assume iDivisor is initialized to a positive value, e.g., 3 [EOL] int expected = (iDivisor - 1) + ((value + 1) % iDivisor); [EOL] int actual = getRemainder(value); [EOL] assertEquals(expected, actual); [EOL] }
public void testGetRemainderWithZero() { [EOL] int value = 0; // This will cover the edge case where value is zero [EOL] int expected = value % iDivisor; [EOL] int actual = getRemainder(value); [EOL] assertEquals(expected, actual); [EOL] }
public void testMutableIntervalWithValidIntervals() { [EOL] long startInstant = 1000L; [EOL] long endInstant = 2000L; [EOL] MutableInterval interval = new MutableInterval(startInstant, endInstant); [EOL] assertEquals(startInstant, interval.getStartMillis()); [EOL] assertEquals(endInstant, interval.getEndMillis()); [EOL] }
public void testMutableIntervalWithEqualStartAndEnd() { [EOL] long instant = 1000L; [EOL] MutableInterval interval = new MutableInterval(instant, instant); [EOL] assertEquals(instant, interval.getStartMillis()); [EOL] assertEquals(instant, interval.getEndMillis()); [EOL] }
public void testMutableIntervalWithEndBeforeStart() { [EOL] long startInstant = 2000L; [EOL] long endInstant = 1000L; [EOL] try { [EOL] new MutableInterval(startInstant, endInstant); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testMutableIntervalWithValidArguments() { [EOL] long startInstant = 1000L; [EOL] long endInstant = 2000L; [EOL] Chronology chronology = ISOChronology.getInstance(); [EOL] MutableInterval interval = new MutableInterval(startInstant, endInstant, chronology); [EOL] assertEquals(startInstant, interval.getStartMillis()); [EOL] assertEquals(endInstant, interval.getEndMillis()); [EOL] assertEquals(chronology, interval.getChronology()); [EOL] }
public void testMutableIntervalWithNullChronology() { [EOL] long startInstant = 1000L; [EOL] long endInstant = 2000L; [EOL] MutableInterval interval = new MutableInterval(startInstant, endInstant, null); [EOL] assertEquals(startInstant, interval.getStartMillis()); [EOL] assertEquals(endInstant, interval.getEndMillis()); [EOL] assertNotNull(interval.getChronology()); [EOL] assertEquals(ISOChronology.getInstanceUTC(), interval.getChronology()); [EOL] }
public void testMutableInterval_WithInstantAndDuration() { [EOL] DateTime start = new DateTime(2021, 3, 25, 10, 0, 0, 0); [EOL] Duration duration = new Duration(7200000); // 2 hours [EOL] MutableInterval interval = new MutableInterval(start, duration); [EOL] assertEquals(start.getMillis(), interval.getStartMillis()); [EOL] assertEquals(start.getMillis() + duration.getMillis(), interval.getEndMillis()); [EOL] }
public void testMutableInterval_WithInstantAndNullDuration() { [EOL] DateTime start = new DateTime(2021, 3, 25, 10, 0, 0, 0); [EOL] try { [EOL] new MutableInterval(start, null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException ex) { [EOL] } [EOL] }
public void testMutableInterval_WithNullDurationAndNonNullEnd() { [EOL] ReadableInstant end = new Instant(); [EOL] MutableInterval interval = new MutableInterval(null, end); [EOL] assertNull(interval.getStart()); [EOL] assertEquals(end, interval.getEnd()); [EOL] }
public void testMutableInterval_WithNonNullDurationAndNonNullEnd() { [EOL] ReadableDuration duration = new Duration(12345); [EOL] ReadableInstant end = new Instant(); [EOL] MutableInterval interval = new MutableInterval(duration, end); [EOL] assertNotNull(interval.getStart()); [EOL] assertEquals(end, interval.getEnd()); [EOL] assertEquals(duration.getMillis(), interval.toDurationMillis()); [EOL] }
public void testMutableIntervalWithValidIntervalAndChronology() { [EOL] Object interval = /* some valid interval object */; [EOL] Chronology chronology = /* some valid chronology object */; [EOL] MutableInterval mutableInterval = new MutableInterval(interval, chronology); [EOL] assertNotNull(mutableInterval); [EOL] }
public void testMutableIntervalWithNullInterval() { [EOL] Object interval = null; [EOL] Chronology chronology = /* some valid chronology object */; [EOL] try { [EOL] MutableInterval mutableInterval = new MutableInterval(interval, chronology); [EOL] fail("Expected an exception to be thrown"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testMutableIntervalWithNullChronology() { [EOL] Object interval = /* some valid interval object */; [EOL] Chronology chronology = null; [EOL] MutableInterval mutableInterval = new MutableInterval(interval, chronology); [EOL] assertNotNull(mutableInterval); [EOL] }
public void testSetIntervalWithNullInterval() { [EOL] try { [EOL] setInterval(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] assertEquals("Interval must not be null", e.getMessage()); [EOL] } [EOL] } [EOL] public void testSetIntervalWithValidInterval() { [EOL] ReadableInterval interval = new MockReadableInterval(); [EOL] setInterval(interval); [EOL] assertEquals(interval.getStartMillis(), getStartMillis()); [EOL] assertEquals(interval.getEndMillis(), getEndMillis()); [EOL] assertEquals(interval.getChronology(), getChronology()); [EOL] }
public void testSetIntervalWithBothNull() { [EOL] setInterval(null, null); [EOL] }
public void testSetIntervalWithNonNullStartAndEnd() { [EOL] ReadableInstant start = new DateTime(2020, 1, 1, 0, 0); [EOL] ReadableInstant end = new DateTime(2020, 12, 31, 23, 59); [EOL] setInterval(start, end); [EOL] }
public void testSetStartMillis_ValidStartInstant() { [EOL] long startInstant = 1000L; [EOL] long endInstant = 2000L; [EOL] Interval interval = new Interval(startInstant, endInstant, ISOChronology.getInstanceUTC()); [EOL] interval.setStartMillis(500L); [EOL] assertEquals(500L, interval.getStartMillis()); [EOL] assertEquals(endInstant, interval.getEndMillis()); [EOL] }
public void testSetStartMillis_SameStartInstant() { [EOL] long startInstant = 1000L; [EOL] long endInstant = 2000L; [EOL] Interval interval = new Interval(startInstant, endInstant, ISOChronology.getInstanceUTC()); [EOL] interval.setStartMillis(startInstant); [EOL] assertEquals(startInstant, interval.getStartMillis()); [EOL] assertEquals(endInstant, interval.getEndMillis()); [EOL] }
public void testSetEndWithNull() { [EOL] Interval interval = new Interval(0, 100); [EOL] try { [EOL] interval.setEnd(null); [EOL] fail("Should have thrown IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] } [EOL] public void testSetEndWithValidInstant() { [EOL] Interval interval = new Interval(0, 100); [EOL] ReadableInstant newEnd = new Instant(200); [EOL] interval.setEnd(newEnd); [EOL] assertEquals("End time should be updated to 200", 200, interval.getEndMillis()); [EOL] }
public void testSetDurationAfterStart_PositiveDuration() { [EOL] long startMillis = 1000L; [EOL] long duration = 5000L; [EOL] MyTimeClass instance = new MyTimeClass(startMillis); [EOL] instance.setDurationAfterStart(duration); [EOL] assertEquals(startMillis + duration, instance.getEndMillis()); [EOL] }
public void testSetDurationAfterStart_NegativeDuration() { [EOL] long startMillis = 1000L; [EOL] long duration = -500L; [EOL] MyTimeClass instance = new MyTimeClass(startMillis); [EOL] instance.setDurationAfterStart(duration); [EOL] assertEquals(startMillis + duration, instance.getEndMillis()); [EOL] }
public void testSetDurationAfterStart_ZeroDuration() { [EOL] long startMillis = 1000L; [EOL] long duration = 0L; [EOL] MyTimeClass instance = new MyTimeClass(startMillis); [EOL] instance.setDurationAfterStart(duration); [EOL] assertEquals(startMillis, instance.getEndMillis()); [EOL] }
public void setDurationBeforeEnd_NullDuration() { [EOL] MyTimeClass instance = new MyTimeClass(); [EOL] instance.setEndMillis(1000); // Set end millis to a sample value [EOL] instance.setDurationBeforeEnd(null); [EOL] long expectedStartMillis = 1000; // As duration is null, start should be same as end [EOL] long actualStartMillis = instance.getStartMillis(); [EOL] assertEquals(expectedStartMillis, actualStartMillis); [EOL] }
public void setDurationBeforeEnd_NegativeDuration() { [EOL] MyTimeClass instance = new MyTimeClass(); [EOL] instance.setEndMillis(1000); [EOL] ReadableDuration duration = new ReadableDuration() { [EOL] @Override [EOL] public long getMillis() { [EOL] return -500; [EOL] } [EOL] }; [EOL] instance.setDurationBeforeEnd(duration); [EOL] long expectedStartMillis = 1500; // 1000 - (-500) [EOL] long actualStartMillis = instance.getStartMillis(); [EOL] assertEquals(expectedStartMillis, actualStartMillis); [EOL] }
public void setDurationBeforeEnd_PositiveDuration() { [EOL] MyTimeClass instance = new MyTimeClass(); [EOL] instance.setEndMillis(1000); [EOL] ReadableDuration duration = new ReadableDuration() { [EOL] @Override [EOL] public long getMillis() { [EOL] return 500; [EOL] } [EOL] }; [EOL] instance.setDurationBeforeEnd(duration); [EOL] long expectedStartMillis = 500; // 1000 - 500 [EOL] long actualStartMillis = instance.getStartMillis(); [EOL] assertEquals(expectedStartMillis, actualStartMillis); [EOL] }
public void setPeriodAfterStart_WithNullPeriod_SetsEndToStart() { [EOL] TimePeriod testPeriod = new TimePeriod(); [EOL] testPeriod.setStartMillis(1000); // Assuming setStartMillis is a valid method on TimePeriod [EOL] testPeriod.setPeriodAfterStart(null); [EOL] assertEquals(1000, testPeriod.getEndMillis()); [EOL] }
public void setPeriodAfterStart_WithNonNullPeriod_SetsEndCorrectly() { [EOL] TimePeriod testPeriod = new TimePeriod(); [EOL] testPeriod.setStartMillis(1000); // Assuming setStartMillis is a valid method on TimePeriod [EOL] ReadablePeriod oneDayPeriod = new Period().withDays(1); // Assuming Period implements ReadablePeriod and can be used here [EOL] Chronology chronology = testPeriod.getChronology(); // Assuming getChronology is a valid method on TimePeriod [EOL] when(chronology.add(oneDayPeriod, 1000, 1)).thenReturn(1000 + 24 * 60 * 60 * 1000); // Assuming a mock framework like Mockito [EOL] testPeriod.setPeriodAfterStart(oneDayPeriod); [EOL] assertEquals(1000 + 24 * 60 * 60 * 1000, testPeriod.getEndMillis()); [EOL] }
public void setPeriodBeforeEnd_NullPeriod_SetsStartToEndTime() { [EOL] TimePeriod testPeriod = new TimePeriod(); [EOL] ReadablePeriod nullPeriod = null; [EOL] long expectedStartMillis = testPeriod.getEndMillis(); [EOL] testPeriod.setPeriodBeforeEnd(nullPeriod); [EOL] assertEquals(expectedStartMillis, testPeriod.getStartMillis()); [EOL] }
public void setPeriodBeforeEnd_NonNullPeriod_SetsStartCorrectly() { [EOL] TimePeriod testPeriod = new TimePeriod(); [EOL] ReadablePeriod nonNullPeriod = new MockReadablePeriod(); [EOL] long expectedStartMillis = testPeriod.getChronology().add(nonNullPeriod, testPeriod.getEndMillis(), -1); [EOL] testPeriod.setPeriodBeforeEnd(nonNullPeriod); [EOL] assertEquals(expectedStartMillis, testPeriod.getStartMillis()); [EOL] }
public void testNowWithNonNullZone() { [EOL] DateTimeZone zone = DateTimeZone.UTC; [EOL] DateMidnight result = Time.now(zone); [EOL] assertNotNull(result); [EOL] assertEquals(zone, result.getZone()); [EOL] }
public void testNowWithNullZone() { [EOL] try { [EOL] Time.now(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException e) { [EOL] assertEquals("Zone must not be null", e.getMessage()); [EOL] } [EOL] }
public void testDateMidnightWithNullInstant() { [EOL] try { [EOL] new DateMidnight((Object) null); [EOL] fail("Should have thrown IllegalArgumentException for null instant"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testDateMidnightWithDate() { [EOL] Date date = new Date(); [EOL] DateMidnight dateMidnight = new DateMidnight(date); [EOL] assertEquals(date.getTime(), dateMidnight.getMillis()); [EOL] }
public void testDateMidnightWithCalendar() { [EOL] Calendar calendar = Calendar.getInstance(); [EOL] DateMidnight dateMidnight = new DateMidnight(calendar); [EOL] assertEquals(calendar.getTimeInMillis(), dateMidnight.getMillis()); [EOL] }
public void testDateMidnightWithDateTime() { [EOL] DateTime dateTime = new DateTime(); [EOL] DateMidnight dateMidnight = new DateMidnight(dateTime); [EOL] assertEquals(dateTime.getMillis(), dateMidnight.getMillis()); [EOL] }
public void testDateMidnightWithLong() { [EOL] long currentTimeMillis = System.currentTimeMillis(); [EOL] DateMidnight dateMidnight = new DateMidnight(currentTimeMillis); [EOL] assertEquals(currentTimeMillis, dateMidnight.getMillis()); [EOL] }
public void testWithPeriodAdded_NullPeriod() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] DateMidnight result = dateMidnight.withPeriodAdded(null, 1); [EOL] assertEquals(dateMidnight, result); [EOL] }
public void testWithPeriodAdded_ZeroScalar() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] ReadablePeriod period = new Period().withDays(1); [EOL] DateMidnight result = dateMidnight.withPeriodAdded(period, 0); [EOL] assertEquals(dateMidnight, result); [EOL] }
public void testWithPeriodAdded_NonNullPeriodAndNonZeroScalar() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] ReadablePeriod period = new Period().withDays(1); [EOL] DateMidnight result = dateMidnight.withPeriodAdded(period, 1); [EOL] assertNotEquals(dateMidnight, result); [EOL] }
public void testPlus_withNullPeriod() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] DateMidnight result = dateMidnight.plus(null); [EOL] assertEquals(dateMidnight, result); [EOL] }
public void testPlus_withValidPeriod() { [EOL] DateMidnight dateMidnight = new DateMidnight(); [EOL] ReadablePeriod period = new Period().withDays(1); [EOL] DateMidnight result = dateMidnight.plus(period); [EOL] assertEquals(dateMidnight.plusDays(1), result); [EOL] }
public void testMinusDays_ZeroDays() { [EOL] DateMidnight original = new DateMidnight(2023, 3, 15); [EOL] DateMidnight result = original.minusDays(0); [EOL] assertEquals("Minus zero days should return the same date", original, result); [EOL] }
public void testMinusDays_NegativeDays() { [EOL] DateMidnight original = new DateMidnight(2023, 3, 15); [EOL] DateMidnight result = original.minusDays(-1); [EOL] DateMidnight expected = new DateMidnight(2023, 3, 16); [EOL] assertEquals("Minus negative days should return a future date", expected, result); [EOL] }
public void testMinusDays_PositiveDays() { [EOL] DateMidnight original = new DateMidnight(2023, 3, 15); [EOL] DateMidnight result = original.minusDays(1); [EOL] DateMidnight expected = new DateMidnight(2023, 3, 14); [EOL] assertEquals("Minus positive days should return a past date", expected, result); [EOL] }
public void testWriteObject() throws IOException { [EOL] ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL] ObjectOutputStream oos = new ObjectOutputStream(baos); [EOL] MyTimeClass instance = new MyTimeClass(); [EOL] instance.writeObject(oos); [EOL] oos.close(); [EOL] byte[] bytes = baos.toByteArray(); [EOL] assertTrue(bytes.length > 0); [EOL] }
public void testReadObjectWithValidInput() throws IOException, ClassNotFoundException { [EOL] ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL] ObjectOutputStream oos = new ObjectOutputStream(baos); [EOL] DateMidnight expectedInstant = new DateMidnight(); [EOL] DateTimeFieldType expectedType = DateTimeFieldType.dayOfMonth(); [EOL] oos.writeObject(expectedInstant); [EOL] oos.writeObject(expectedType); [EOL] oos.close(); [EOL] ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())); [EOL] readObject(ois); // Assuming this method can be accessed or is made package-private for the sake of testing [EOL] assertEquals(expectedInstant, iInstant); [EOL] assertEquals(expectedType.getField(expectedInstant.getChronology()), iField); [EOL] }
public void testReadObjectWithInvalidType() { [EOL] ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL] ObjectOutputStream oos = new ObjectOutputStream(baos); [EOL] DateMidnight expectedInstant = new DateMidnight(); [EOL] String invalidType = "Not a DateTimeFieldType"; [EOL] oos.writeObject(expectedInstant); [EOL] oos.writeObject(invalidType); [EOL] oos.close(); [EOL] ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())); [EOL] try { [EOL] readObject(ois); [EOL] fail("Should have thrown ClassCastException"); [EOL] } catch (ClassCastException e) { [EOL] } [EOL] }
public void testReadObjectWithInvalidInstant() { [EOL] ByteArrayOutputStream baos = new ByteArrayOutputStream(); [EOL] ObjectOutputStream oos = new ObjectOutputStream(baos); [EOL] String invalidInstant = "Not a DateMidnight"; [EOL] DateTimeFieldType expectedType = DateTimeFieldType.dayOfMonth(); [EOL] oos.writeObject(invalidInstant); [EOL] oos.writeObject(expectedType); [EOL] oos.close(); [EOL] ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray())); [EOL] try { [EOL] readObject(ois); [EOL] fail("Should have thrown ClassCastException"); [EOL] } catch (ClassCastException e) { [EOL] } [EOL] }
public void testAddToCopy_PositiveValue() { [EOL] long valueToAdd = 1000L; // 1 second [EOL] DateMidnight initialDateMidnight = new DateMidnight(); [EOL] DateMidnight resultDateMidnight = initialDateMidnight.addToCopy(valueToAdd); [EOL] long expectedMillis = initialDateMidnight.getMillis() + valueToAdd; [EOL] assertEquals(expectedMillis, resultDateMidnight.getMillis()); [EOL] }
public void testAddToCopy_NegativeValue() { [EOL] long valueToSubtract = -1000L; // -1 second [EOL] DateMidnight initialDateMidnight = new DateMidnight(); [EOL] DateMidnight resultDateMidnight = initialDateMidnight.addToCopy(valueToSubtract); [EOL] long expectedMillis = initialDateMidnight.getMillis() + valueToSubtract; [EOL] assertEquals(expectedMillis, resultDateMidnight.getMillis()); [EOL] }
public void testAddToCopy_ZeroValue() { [EOL] long valueToAdd = 0L; [EOL] DateMidnight initialDateMidnight = new DateMidnight(); [EOL] DateMidnight resultDateMidnight = initialDateMidnight.addToCopy(valueToAdd); [EOL] long expectedMillis = initialDateMidnight.getMillis(); [EOL] assertEquals(expectedMillis, resultDateMidnight.getMillis()); [EOL] }
public void testRoundHalfFloorCopy() { [EOL] DateTimeFieldType fieldType = DateTimeFieldType.dayOfMonth(); [EOL] DateTimeField field = fieldType.getField(DateTimeZone.UTC); [EOL] long currentTimeMillis = System.currentTimeMillis(); [EOL] DateMidnight dateMidnight = new DateMidnight(currentTimeMillis, DateTimeZone.UTC); [EOL] DateMidnight roundedDateMidnight = dateMidnight.roundHalfFloorCopy(); [EOL] long expectedMillis = field.roundHalfFloor(currentTimeMillis); [EOL] assertEquals(expectedMillis, roundedDateMidnight.getMillis()); [EOL] }
public void testBasePartialWithNullInstantAndChronology() { [EOL] Chronology nullChronology = null; [EOL] BasePartial basePartial = new BasePartial((Object) null, nullChronology, null); [EOL] assertNotNull(basePartial); [EOL] assertNotNull(basePartial.getChronology()); [EOL] assertTrue(basePartial.getChronology() instanceof ISOChronology); [EOL] }
public void testBasePartialWithNonNullInstantAndNullChronology() { [EOL] Instant instant = new Instant(); [EOL] Chronology nullChronology = null; [EOL] BasePartial basePartial = new BasePartial(instant, nullChronology, null); [EOL] assertNotNull(basePartial); [EOL] assertNotNull(basePartial.getChronology()); [EOL] assertTrue(basePartial.getChronology() instanceof ISOChronology); [EOL] }
public void testBasePartialWithNonNullInstantAndNonNullChronology() { [EOL] Instant instant = new Instant(); [EOL] Chronology chronology = GregorianChronology.getInstance(); [EOL] BasePartial basePartial = new BasePartial(instant, chronology, null); [EOL] assertNotNull(basePartial); [EOL] assertNotNull(basePartial.getChronology()); [EOL] assertTrue(basePartial.getChronology() instanceof GregorianChronology); [EOL] }
public void testBasePartialWithNonNullInstantAndNonNullParser() { [EOL] Instant instant = new Instant(); [EOL] Chronology chronology = GregorianChronology.getInstance(); [EOL] DateTimeFormatter parser = ISODateTimeFormat.dateTime(); [EOL] BasePartial basePartial = new BasePartial(instant, chronology, parser); [EOL] assertNotNull(basePartial); [EOL] assertNotNull(basePartial.getChronology()); [EOL] assertTrue(basePartial.getChronology() instanceof GregorianChronology); [EOL] assertNotNull(basePartial.getValues()); [EOL] }
