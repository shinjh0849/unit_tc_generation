public void testJsonSerializationVisitorWithSerializeNullsTrue() { [EOL] ObjectNavigatorFactory factory = mock(ObjectNavigatorFactory.class); [EOL] boolean serializeNulls = true; [EOL] ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers = new ParameterizedTypeHandlerMap<>(); [EOL] JsonSerializationContext context = mock(JsonSerializationContext.class); [EOL] MemoryRefStack ancestors = new MemoryRefStack(); [EOL] JsonSerializationVisitor visitor = new JsonSerializationVisitor(factory, serializeNulls, serializers, context, ancestors); [EOL] assertEquals(factory, visitor.factory); [EOL] assertTrue(visitor.serializeNulls); [EOL] assertEquals(serializers, visitor.serializers); [EOL] assertEquals(context, visitor.context); [EOL] assertEquals(ancestors, visitor.ancestors); [EOL] }
public void testJsonSerializationVisitorWithSerializeNullsFalse() { [EOL] ObjectNavigatorFactory factory = mock(ObjectNavigatorFactory.class); [EOL] boolean serializeNulls = false; [EOL] ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers = new ParameterizedTypeHandlerMap<>(); [EOL] JsonSerializationContext context = mock(JsonSerializationContext.class); [EOL] MemoryRefStack ancestors = new MemoryRefStack(); [EOL] JsonSerializationVisitor visitor = new JsonSerializationVisitor(factory, serializeNulls, serializers, context, ancestors); [EOL] assertEquals(factory, visitor.factory); [EOL] assertFalse(visitor.serializeNulls); [EOL] assertEquals(serializers, visitor.serializers); [EOL] assertEquals(context, visitor.context); [EOL] assertEquals(ancestors, visitor.ancestors); [EOL] }
public void start_withNullNode_doesNotThrow() { [EOL] ObjectTypePair node = null; [EOL] RecursiveTreeTypeAdapter<Object> adapter = new RecursiveTreeTypeAdapter<>(null, null, null, null); [EOL] adapter.start(node); [EOL] }
public void start_withNonCircularReference_doesNotThrow() { [EOL] ObjectTypePair node = new ObjectTypePair(new Object(), Object.class); [EOL] RecursiveTreeTypeAdapter<Object> adapter = new RecursiveTreeTypeAdapter<>(null, null, null, null); [EOL] adapter.start(node); [EOL] }
public void start_withCircularReference_throwsException() { [EOL] ObjectTypePair node = new ObjectTypePair(new Object(), Object.class); [EOL] RecursiveTreeTypeAdapter<Object> adapter = new RecursiveTreeTypeAdapter<>(null, null, null, null); [EOL] adapter.start(node); // First call to add to ancestors [EOL] try { [EOL] adapter.start(node); // Second call should throw exception [EOL] fail("Expected CircularReferenceException"); [EOL] } catch (CircularReferenceException e) { [EOL] } [EOL] }
public void end_withNonNullNode() { [EOL] ObjectTypePair node = new ObjectTypePair(new Object(), Object.class, false); [EOL] JsonTreeWriter writer = new JsonTreeWriter(); [EOL] writer.ancestors.push(node); [EOL] writer.end(node); [EOL] assertTrue(writer.ancestors.isEmpty()); [EOL] } [EOL] public void end_withNullNode() { [EOL] ObjectTypePair node = null; [EOL] JsonTreeWriter writer = new JsonTreeWriter(); [EOL] int initialSize = writer.ancestors.size(); [EOL] writer.end(node); [EOL] assertEquals(initialSize, writer.ancestors.size()); [EOL] }
public void testVisitArrayWithEmptyArray() { [EOL] Object emptyArray = new int[0]; [EOL] Type arrayType = emptyArray.getClass(); [EOL] JsonArrayVisitor visitor = new JsonArrayVisitor(); [EOL] visitor.visitArray(emptyArray, arrayType); [EOL] assertTrue(visitor.getRoot().isJsonArray()); [EOL] assertEquals(0, visitor.getRoot().getAsJsonArray().size()); [EOL] }
public void testVisitArrayWithNonEmptyArray() { [EOL] Object nonEmptyArray = new int[]{1, 2, 3}; [EOL] Type arrayType = nonEmptyArray.getClass(); [EOL] JsonArrayVisitor visitor = new JsonArrayVisitor(); [EOL] visitor.visitArray(nonEmptyArray, arrayType); [EOL] assertTrue(visitor.getRoot().isJsonArray()); [EOL] assertEquals(3, visitor.getRoot().getAsJsonArray().size()); [EOL] assertEquals(1, visitor.getRoot().getAsJsonArray().get(0).getAsInt()); [EOL] assertEquals(2, visitor.getRoot().getAsJsonArray().get(1).getAsInt()); [EOL] assertEquals(3, visitor.getRoot().getAsJsonArray().get(2).getAsInt()); [EOL] }
public void testAddAsArrayElementWithNullObject() { [EOL] ObjectTypePair elementTypePair = new ObjectTypePair(null, null); [EOL] JsonArray root = new JsonArray(); [EOL] addAsArrayElement(elementTypePair); // Assuming this method can be accessed or is made accessible for testing [EOL] assertTrue(root.size() == 1); [EOL] assertTrue(root.get(0).isJsonNull()); [EOL] }
public void testAddAsArrayElementWithNonNullObject() { [EOL] JsonElement nonNullElement = new JsonPrimitive("test"); [EOL] ObjectTypePair elementTypePair = new ObjectTypePair(nonNullElement, nonNullElement.getClass()); [EOL] JsonArray root = new JsonArray(); [EOL] addAsArrayElement(elementTypePair); // Assuming this method can be accessed or is made accessible for testing [EOL] assertTrue(root.size() == 1); [EOL] assertEquals(nonNullElement, root.get(0)); [EOL] }
public void testGetJsonElementForChildWithNonNullValue() { [EOL] ObjectTypePair fieldValueTypePair = new ObjectTypePair(someNonNullValue, someType, false); [EOL] JsonElement result = getJsonElementForChild(fieldValueTypePair); [EOL] assertNotNull(result); [EOL] }
public void testGetJsonElementForChildWithNullValue() { [EOL] ObjectTypePair fieldValueTypePair = new ObjectTypePair(null, someType, false); [EOL] JsonElement result = getJsonElementForChild(fieldValueTypePair); [EOL] if (serializeNulls) { [EOL] assertNotNull(result); [EOL] } else { [EOL] assertNull(result); [EOL] } [EOL] }
public void testVisitUsingCustomHandlerWithNullObjectAndSerializeNullsTrue() { [EOL] ObjectTypePair objTypePair = new ObjectTypePair(null, null, true); [EOL] YourClass instance = new YourClass(true); // Assuming 'serializeNulls' is a field in YourClass [EOL] boolean result = instance.visitUsingCustomHandler(objTypePair); [EOL] assertTrue(result); [EOL] assertEquals(JsonNull.createJsonNull(), instance.getAssignedToRoot()); [EOL] }
public void testVisitUsingCustomHandlerWithNonNullObjectAndCustomSerializerReturnsElement() { [EOL] ObjectTypePair objTypePair = new ObjectTypePair(new Object(), Object.class, false); [EOL] YourClass instance = new YourClass(false); [EOL] JsonElement mockElement = new JsonObject(); [EOL] instance.mockFindAndInvokeCustomSerializer(objTypePair, mockElement); [EOL] boolean result = instance.visitUsingCustomHandler(objTypePair); [EOL] assertTrue(result); [EOL] assertEquals(mockElement, instance.getAssignedToRoot()); [EOL] }
public void testVisitUsingCustomHandlerWithNonNullObjectAndCustomSerializerReturnsNull() { [EOL] ObjectTypePair objTypePair = new ObjectTypePair(new Object(), Object.class, false); [EOL] YourClass instance = new YourClass(false); [EOL] instance.mockFindAndInvokeCustomSerializer(objTypePair, null); [EOL] boolean result = instance.visitUsingCustomHandler(objTypePair); [EOL] assertFalse(result); [EOL] }
public void testVisitUsingCustomHandlerThrowsCircularReferenceException() { [EOL] ObjectTypePair objTypePair = new ObjectTypePair(new Object(), Object.class, false); [EOL] YourClass instance = new YourClass(false); [EOL] instance.mockFindAndInvokeCustomSerializerToThrowCircularReferenceException(objTypePair); [EOL] try { [EOL] instance.visitUsingCustomHandler(objTypePair); [EOL] fail("Expected CircularReferenceException to be thrown"); [EOL] } catch (CircularReferenceException e) { [EOL] } [EOL] }
public void testFindAndInvokeCustomSerializerWithNoMatchingHandler() { [EOL] ObjectTypePair objTypePair = mock(ObjectTypePair.class); [EOL] when(objTypePair.getMatchingHandler(anyMap())).thenReturn(null); [EOL] JsonElement result = findAndInvokeCustomSerializer(objTypePair); [EOL] assertNull(result); [EOL] }
public void testFindAndInvokeCustomSerializerWithMatchingHandlerAndNonNullElement() { [EOL] ObjectTypePair objTypePair = mock(ObjectTypePair.class); [EOL] JsonSerializer jsonSerializer = mock(JsonSerializer.class); [EOL] JsonElement jsonElement = new JsonObject(); [EOL] Pair<JsonSerializer<?>, ObjectTypePair> pair = new Pair<>(jsonSerializer, objTypePair); [EOL] when(objTypePair.getMatchingHandler(anyMap())).thenReturn(pair); [EOL] when(jsonSerializer.serialize(any(), any(), any())).thenReturn(jsonElement); [EOL] JsonElement result = findAndInvokeCustomSerializer(objTypePair); [EOL] assertSame(jsonElement, result); [EOL] }
public void testFindAndInvokeCustomSerializerWithMatchingHandlerAndNullElement() { [EOL] ObjectTypePair objTypePair = mock(ObjectTypePair.class); [EOL] JsonSerializer jsonSerializer = mock(JsonSerializer.class); [EOL] Pair<JsonSerializer<?>, ObjectTypePair> pair = new Pair<>(jsonSerializer, objTypePair); [EOL] when(objTypePair.getMatchingHandler(anyMap())).thenReturn(pair); [EOL] when(jsonSerializer.serialize(any(), any(), any())).thenReturn(null); [EOL] JsonElement result = findAndInvokeCustomSerializer(objTypePair); [EOL] assertTrue(result.isJsonNull()); [EOL] }
public void testAssignToRootWithNonNullElement() { [EOL] JsonElement newRoot = new JsonPrimitive("test"); [EOL] assignToRoot(newRoot); [EOL] assertEquals(newRoot, root); [EOL] }
public void testAssignToRootWithNullElement() { [EOL] try { [EOL] assignToRoot(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public JsonElement getJsonElement() { [EOL] return root; [EOL] }
public void testSetIndentWithEmptyString() { [EOL] Gson gson = new GsonBuilder().create(); [EOL] gson.setIndent(""); [EOL] assertNull(gson.indent); [EOL] assertEquals(":", gson.separator); [EOL] }
public void testSetIndentWithNonEmptyString() { [EOL] Gson gson = new GsonBuilder().create(); [EOL] gson.setIndent("  "); [EOL] assertEquals("  ", gson.indent); [EOL] assertEquals(": ", gson.separator); [EOL] }
public void testCloseWithEmptyContext() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.setLenient(true); [EOL] writer.beginArray(); [EOL] writer.endArray(); [EOL] try { [EOL] writer.close(JsonScope.EMPTY_ARRAY, JsonScope.NONEMPTY_ARRAY, "]"); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException expected) { [EOL] } [EOL] } [EOL] public void testCloseWithNonemptyContext() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.setLenient(true); [EOL] writer.beginArray(); [EOL] writer.value(1); [EOL] writer.close(JsonScope.EMPTY_ARRAY, JsonScope.NONEMPTY_ARRAY, "]"); [EOL] } [EOL] public void testCloseWithInvalidContext() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.setLenient(true); [EOL] writer.beginArray(); [EOL] writer.beginObject(); [EOL] try { [EOL] writer.close(JsonScope.EMPTY_ARRAY, JsonScope.NONEMPTY_ARRAY, "]"); [EOL] fail("Expected IllegalStateException due to invalid context"); [EOL] } catch (IllegalStateException expected) { [EOL] } [EOL] }

public void testNameWithNullNameThrowsException() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] try { [EOL] writer.name(null); [EOL] fail("JsonWriter.name(null) should throw NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testNameWithNonNullName() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.beginObject(); [EOL] JsonWriter returnedWriter = writer.name("name"); [EOL] assertNotNull(returnedWriter); [EOL] assertSame(writer, returnedWriter); [EOL] }
public void testValueWithNull() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.setLenient(true); [EOL] JsonWriter result = writer.value((String) null); [EOL] assertNull(result); [EOL] }
public void testValueWithNonNull() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.setLenient(true); [EOL] JsonWriter result = writer.value("stringValue"); [EOL] assertNotNull(result); [EOL] assertEquals(writer, result); [EOL] }
public void testValueWithNaN() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] try { [EOL] writer.value(Double.NaN); [EOL] fail("JsonWriter.value should not accept NaN"); [EOL] } catch (IllegalArgumentException expected) { [EOL] } [EOL] }
public void testValueWithPositiveInfinity() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] try { [EOL] writer.value(Double.POSITIVE_INFINITY); [EOL] fail("JsonWriter.value should not accept positive infinity"); [EOL] } catch (IllegalArgumentException expected) { [EOL] } [EOL] }
public void testValueWithNegativeInfinity() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] try { [EOL] writer.value(Double.NEGATIVE_INFINITY); [EOL] fail("JsonWriter.value should not accept negative infinity"); [EOL] } catch (IllegalArgumentException expected) { [EOL] } [EOL] }
public void testValueWithFinite() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] double finiteValue = 123.456; [EOL] writer.value(finiteValue); [EOL] assertEquals("123.456", writer.getBuffer().toString()); [EOL] }
public void testCloseWithNonemptyDocument() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.beginArray(); [EOL] writer.endArray(); [EOL] writer.close(); [EOL] }
public void testCloseWithIncompleteDocumentThrowsIOException() { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] try { [EOL] writer.beginArray(); [EOL] writer.close(); [EOL] fail("Should have thrown IOException due to incomplete document"); [EOL] } catch (IOException expected) { [EOL] } [EOL] }
public void testNewlineWithNoIndent() throws IOException { [EOL] JsonWriter jsonWriter = new JsonWriter(new StringWriter()); [EOL] jsonWriter.setIndent(null); [EOL] jsonWriter.newline(); // This should not write anything as indent is null [EOL] assertEquals("", jsonWriter.getBuffer().toString()); [EOL] }
public void testNewlineWithIndent() throws IOException { [EOL] JsonWriter jsonWriter = new JsonWriter(new StringWriter()); [EOL] jsonWriter.setIndent("  "); // Set indent to two spaces [EOL] jsonWriter.beginArray(); // Add a new element to the stack to increase its size [EOL] jsonWriter.newline(); [EOL] assertEquals("\n  ", jsonWriter.getBuffer().toString()); [EOL] }
public void testNewlineWithMultipleStackElements() throws IOException { [EOL] JsonWriter jsonWriter = new JsonWriter(new StringWriter()); [EOL] jsonWriter.setIndent("  "); // Set indent to two spaces [EOL] jsonWriter.beginArray(); // Add a new element to the stack [EOL] jsonWriter.beginArray(); // Add another new element to the stack to increase its size [EOL] jsonWriter.newline(); [EOL] assertEquals("\n    ", jsonWriter.getBuffer().toString()); // Expect two indents [EOL] }
public void testBeforeValueWithEmptyDocumentAndLenient() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.setLenient(true); [EOL] writer.beforeValue(true); [EOL] } [EOL] public void testBeforeValueWithEmptyDocumentAndNotLenientAndNotRoot() { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.setLenient(false); [EOL] try { [EOL] writer.beforeValue(false); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("JSON must start with an array or an object.", e.getMessage()); [EOL] } [EOL] } [EOL] public void testBeforeValueWithEmptyDocumentAndNotLenientAndRoot() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.setLenient(false); [EOL] writer.beforeValue(true); [EOL] } [EOL] public void testBeforeValueWithEmptyArray() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.beginArray(); [EOL] writer.beforeValue(false); [EOL] } [EOL] public void testBeforeValueWithNonemptyArray() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.beginArray(); [EOL] writer.value(true); [EOL] writer.beforeValue(false); [EOL] } [EOL] public void testBeforeValueWithDanglingName() throws IOException { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.beginObject(); [EOL] writer.name("name"); [EOL] writer.beforeValue(false); [EOL] } [EOL] public void testBeforeValueWithNonemptyDocument() { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] writer.beginArray(); [EOL] writer.endArray(); [EOL] try { [EOL] writer.beforeValue(false); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("JSON must have only one top-level value.", e.getMessage()); [EOL] } [EOL] } [EOL] public void testBeforeValueWithInvalidState() { [EOL] JsonWriter writer = new JsonWriter(new StringWriter()); [EOL] try { [EOL] writer.beforeValue(false); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertTrue(e.getMessage().contains("Nesting problem:")); [EOL] } [EOL] }

public boolean shouldSkipClass(Class<?> clazz) { [EOL] return false; [EOL] }
public void testUpperCamelCaseSeparatorNamingPolicyWithEmptySeparator() { [EOL] UpperCamelCaseSeparatorNamingPolicy policy = new UpperCamelCaseSeparatorNamingPolicy(""); [EOL] String result = policy.translateName("someFieldName"); [EOL] assertEquals("SomeFieldName", result); [EOL] }
public void testUpperCamelCaseSeparatorNamingPolicyWithNonEmptySeparator() { [EOL] UpperCamelCaseSeparatorNamingPolicy policy = new UpperCamelCaseSeparatorNamingPolicy("_"); [EOL] String result = policy.translateName("some_field_name"); [EOL] assertEquals("Some_Field_Name", result); [EOL] }
public void testGetComponentRawType() { [EOL] TypeToken<?> typeToken = new TypeToken<List<String>>() {} ; [EOL] Class<?> componentRawType = typeToken.getComponentRawType(); [EOL] assertEquals(String.class, componentRawType); [EOL] }
public void testEscaperConstructor() { [EOL] Escaper escaperWithHtmlEscape = new Escaper(true); [EOL] Escaper escaperWithoutHtmlEscape = new Escaper(false); [EOL] } [EOL] public void testEscapeJsonStringWithHtmlEscape() throws IOException { [EOL] Escaper escaper = new Escaper(true); [EOL] String result = escaper.escapeJsonString("String with <html> tags & special \"characters\""); [EOL] } [EOL] public void testEscapeJsonStringWithoutHtmlEscape() throws IOException { [EOL] Escaper escaper = new Escaper(false); [EOL] String result = escaper.escapeJsonString("String without escaping html characters"); [EOL] } [EOL] public void testEscapeJsonStringWithControlCharacters() throws IOException { [EOL] Escaper escaper = new Escaper(false); [EOL] String result = escaper.escapeJsonString("String with control characters like \n and \r"); [EOL] } [EOL] public void testEscapeJsonStringWithSpecialCharacters() throws IOException { [EOL] Escaper escaper = new Escaper(false); [EOL] String result = escaper.escapeJsonString("String with special characters like \" and \\"); [EOL] } [EOL] public void testMustEscapeCharInJsString() { [EOL] Escaper escaper = new Escaper(false); [EOL] boolean result = escaper.mustEscapeCharInJsString('\"'); [EOL] } [EOL] public void testIsControlCharacter() { [EOL] boolean result = Escaper.isControlCharacter('\n'); [EOL] } [EOL] public void testAppendHexJavaScriptRepresentation() throws IOException { [EOL] StringBuilder out = new StringBuilder(); [EOL] Escaper.appendHexJavaScriptRepresentation('A', out); [EOL] }
public void testPairWithNonNullValues() { [EOL] String first = "firstValue"; [EOL] String second = "secondValue"; [EOL] Pair<String, String> pair = new Pair<>(first, second); [EOL] assertEquals(first, pair.first); [EOL] assertEquals(second, pair.second); [EOL] }
public void testPairWithNullValues() { [EOL] Pair<String, String> pair = new Pair<>(null, null); [EOL] assertNull(pair.first); [EOL] assertNull(pair.second); [EOL] }
public void testPeekWithNoTokenAndDecodeLiteral() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("true")); [EOL] jsonReader.setLenient(true); [EOL] JsonToken result = jsonReader.peek(); [EOL] assertEquals(JsonToken.BOOLEAN, result); [EOL] } [EOL] public void testPeekWithExistingToken() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("true")); [EOL] jsonReader.setLenient(true); [EOL] jsonReader.advance(); // This should set the token [EOL] JsonToken result = jsonReader.peek(); [EOL] assertEquals(JsonToken.BOOLEAN, result); [EOL] }
private void testConsumeNonExecutePrefixWithNonMatchingPrefix() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader(")NonMatching")); [EOL] jsonReader.setLenient(true); [EOL] jsonReader.consumeNonExecutePrefix(); [EOL] assertEquals(')', jsonReader.peek()); [EOL] } [EOL] private void testConsumeNonExecutePrefixWithMatchingPrefix() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader(")]}'")); [EOL] jsonReader.setLenient(true); [EOL] jsonReader.consumeNonExecutePrefix(); [EOL] assertEquals(JsonToken.BEGIN_ARRAY, jsonReader.peek()); [EOL] } [EOL] private void testConsumeNonExecutePrefixWithPartialPrefix() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader(")]}'SomeExtra")); [EOL] jsonReader.setLenient(true); [EOL] jsonReader.consumeNonExecutePrefix(); [EOL] assertEquals(JsonToken.BEGIN_ARRAY, jsonReader.peek()); [EOL] } [EOL] private void testConsumeNonExecutePrefixWithInsufficientBuffer() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("")); [EOL] jsonReader.setLenient(true); [EOL] jsonReader.consumeNonExecutePrefix(); [EOL] assertEquals(JsonToken.END_DOCUMENT, jsonReader.peek()); [EOL] }
public String nextName() throws IOException { [EOL] quickPeek(); [EOL] if (token != JsonToken.NAME) { [EOL] throw new IllegalStateException("Expected a name but was " + peek()); [EOL] } [EOL] String result = name; [EOL] advance(); [EOL] return result; [EOL] }
public void testNextStringWithValidStringToken() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("\"testString\"")); [EOL] jsonReader.beginArray(); [EOL] String result = jsonReader.nextString(); [EOL] assertEquals("testString", result); [EOL] }
public void testNextStringWithValidNumberToken() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("12345")); [EOL] jsonReader.beginArray(); [EOL] String result = jsonReader.nextString(); [EOL] assertEquals("12345", result); [EOL] }
public void testNextStringWithInvalidToken() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[true]")); [EOL] jsonReader.beginArray(); [EOL] assertThrows(IllegalStateException.class, jsonReader::nextString); [EOL] }
public void testNextStringAtEndOfDocument() { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("\"testString\"")); [EOL] jsonReader.beginArray(); [EOL] jsonReader.endArray(); [EOL] assertThrows(IllegalStateException.class, jsonReader::nextString); [EOL] }
public void skipValue() throws IOException { [EOL] skipping = true; [EOL] try { [EOL] int count = 0; [EOL] do { [EOL] JsonToken token = advance(); [EOL] if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) { [EOL] count++; [EOL] } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) { [EOL] count--; [EOL] } [EOL] } while (count != 0); [EOL] } finally { [EOL] skipping = false; [EOL] } [EOL] }
public void testNextInArray_FirstElementEmptyArray() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("[]")); [EOL] reader.beginArray(); [EOL] assertEquals(JsonToken.END_ARRAY, reader.nextInArray(true)); [EOL] }
public void testNextInArray_FirstElementNonEmptyArray() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("[null]")); [EOL] reader.beginArray(); [EOL] assertEquals(JsonToken.NULL, reader.nextInArray(true)); [EOL] }
public void testNextInArray_NonFirstElementEndArray() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("[null,]")); [EOL] reader.beginArray(); [EOL] reader.nextNull(); // Move to the next element [EOL] assertEquals(JsonToken.END_ARRAY, reader.nextInArray(false)); [EOL] }
public void testNextInArray_NonFirstElementWithComma() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("[null,,null]")); [EOL] reader.beginArray(); [EOL] reader.nextNull(); // Move to the next element [EOL] assertEquals(JsonToken.NULL, reader.nextInArray(false)); [EOL] }
public void testNextInArray_NonFirstElementWithSemicolonLenient() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("[null;null]")); [EOL] reader.setLenient(true); [EOL] reader.beginArray(); [EOL] reader.nextNull(); // Move to the next element [EOL] assertEquals(JsonToken.NULL, reader.nextInArray(false)); [EOL] }
public void testNextInArray_NonFirstElementWithSemicolonStrict() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("[null;null]")); [EOL] reader.beginArray(); [EOL] try { [EOL] reader.nextInArray(false); [EOL] fail("Should throw syntax error for non-lenient semicolon."); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testNextInArray_UnterminatedArray() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("[null")); [EOL] reader.beginArray(); [EOL] try { [EOL] reader.nextInArray(false); [EOL] fail("Should throw syntax error for unterminated array."); [EOL] } catch (IOException e) { [EOL] } [EOL] }
private JsonToken nextInObject(boolean firstElement) throws IOException { [EOL] if (firstElement) { [EOL] switch(nextNonWhitespace()) { [EOL] case '}': [EOL] pop(); [EOL] hasToken = true; [EOL] return token = JsonToken.END_OBJECT; [EOL] default: [EOL] pos--; [EOL] } [EOL] } else { [EOL] switch(nextNonWhitespace()) { [EOL] case '}': [EOL] pop(); [EOL] hasToken = true; [EOL] return token = JsonToken.END_OBJECT; [EOL] case ';': [EOL] case ',': [EOL] break; [EOL] default: [EOL] throw syntaxError("Unterminated object"); [EOL] } [EOL] } [EOL] int quote = nextNonWhitespace(); [EOL] switch(quote) { [EOL] case '\'': [EOL] checkLenient(); [EOL] case '"': [EOL] name = nextString((char) quote); [EOL] break; [EOL] default: [EOL] checkLenient(); [EOL] pos--; [EOL] name = nextLiteral(); [EOL] if (name.length() == 0) { [EOL] throw syntaxError("Expected name"); [EOL] } [EOL] } [EOL] replaceTop(JsonScope.DANGLING_NAME); [EOL] hasToken = true; [EOL] return token = JsonToken.NAME; [EOL] } [EOL] public JsonReader(Reader in); [EOL] public void setLenient(boolean lenient); [EOL] public boolean isLenient(); [EOL] public void beginArray() throws IOException; [EOL] public void endArray() throws IOException; [EOL] public void beginObject() throws IOException; [EOL] public void endObject() throws IOException; [EOL] private void expect(JsonToken expected) throws IOException; [EOL] public boolean hasNext() throws IOException; [EOL] public JsonToken peek() throws IOException; [EOL] private JsonToken quickPeek() throws IOException; [EOL] private void consumeNonExecutePrefix() throws IOException; [EOL] private JsonToken advance() throws IOException; [EOL] public String nextName() throws IOException; [EOL] public String nextString() throws IOException; [EOL] public boolean nextBoolean() throws IOException; [EOL] public void nextNull() throws IOException; [EOL] public double nextDouble() throws IOException; [EOL] public long nextLong() throws IOException; [EOL] public int nextInt() throws IOException; [EOL] public void close() throws IOException; [EOL] public void skipValue() throws IOException; [EOL] private JsonScope peekStack(); [EOL] private JsonScope pop(); [EOL] private void push(JsonScope newTop); [EOL] private void replaceTop(JsonScope newTop); [EOL] private JsonToken nextInArray(boolean firstElement) throws IOException; [EOL] private JsonToken nextInObject(boolean firstElement) throws IOException; [EOL] private JsonToken objectValue() throws IOException; [EOL] private JsonToken nextValue() throws IOException; [EOL] private boolean fillBuffer(int minimum) throws IOException; [EOL] private int nextNonWhitespace() throws IOException; [EOL] private void checkLenient() throws IOException; [EOL] private void skipToEndOfLine() throws IOException; [EOL] private boolean skipTo(String toFind) throws IOException; [EOL] private String nextString(char quote) throws IOException; [EOL] private String nextLiteral() throws IOException; [EOL] public String toString(); [EOL] private char readEscapeCharacter() throws IOException; [EOL] private JsonToken readLiteral() throws IOException; [EOL] private void decodeLiteral() throws IOException; [EOL] private IOException syntaxError(String message) throws IOException; [EOL] private CharSequence getSnippet(); [EOL] char[] NON_EXECUTE_PREFIX=Optional[")]}???
public void testObjectValueWithColon() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("{}")); [EOL] jsonReader.beginObject(); [EOL] assertEquals(JsonToken.NAME, jsonReader.peek()); [EOL] jsonReader.setLenient(true); [EOL] jsonReader.nextName(); [EOL] jsonReader.setLenient(false); [EOL] try { [EOL] jsonReader.objectValue(); [EOL] fail("Expected syntax error"); [EOL] } catch (IOException e) { [EOL] assertEquals("Expected ':'", e.getMessage()); [EOL] } [EOL] }
public void testObjectValueWithEquals() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("{key=value}")); [EOL] jsonReader.beginObject(); [EOL] assertEquals(JsonToken.NAME, jsonReader.peek()); [EOL] jsonReader.nextName(); [EOL] jsonReader.setLenient(true); [EOL] assertEquals(JsonToken.STRING, jsonReader.objectValue()); [EOL] }
public void testObjectValueWithEqualsAndArrow() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("{key=>value}")); [EOL] jsonReader.beginObject(); [EOL] assertEquals(JsonToken.NAME, jsonReader.peek()); [EOL] jsonReader.nextName(); [EOL] jsonReader.setLenient(true); [EOL] assertEquals(JsonToken.STRING, jsonReader.objectValue()); [EOL] }
public void testObjectValueWithSyntaxError() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("{key value}")); [EOL] jsonReader.beginObject(); [EOL] assertEquals(JsonToken.NAME, jsonReader.peek()); [EOL] jsonReader.nextName(); [EOL] try { [EOL] jsonReader.objectValue(); [EOL] fail("Expected syntax error"); [EOL] } catch (IOException e) { [EOL] assertEquals("Expected ':'", e.getMessage()); [EOL] } [EOL] }
public void testNextValueBeginObject() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("{")); [EOL] JsonToken token = jsonReader.nextValue(); [EOL] assertEquals(JsonToken.BEGIN_OBJECT, token); [EOL] }
public void testNextValueBeginArray() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("[")); [EOL] JsonToken token = jsonReader.nextValue(); [EOL] assertEquals(JsonToken.BEGIN_ARRAY, token); [EOL] }
public void testNextValueStringWithSingleQuote() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("'string'")); [EOL] jsonReader.setLenient(true); [EOL] JsonToken token = jsonReader.nextValue(); [EOL] assertEquals(JsonToken.STRING, token); [EOL] }
public void testNextValueStringWithDoubleQuote() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("\"string\"")); [EOL] JsonToken token = jsonReader.nextValue(); [EOL] assertEquals(JsonToken.STRING, token); [EOL] }
public void testNextValueLiteral() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("true")); [EOL] JsonToken token = jsonReader.nextValue(); [EOL] assertEquals(JsonToken.BOOLEAN, token); // Assuming readLiteral() correctly identifies the boolean literal [EOL] }
public void testNextNonWhitespaceWithWhitespaceCharacters() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader(" \r\n\t")); [EOL] assertEquals(' ', reader.nextNonWhitespace()); [EOL] assertEquals('\r', reader.nextNonWhitespace()); [EOL] assertEquals('\n', reader.nextNonWhitespace()); [EOL] assertEquals('\t', reader.nextNonWhitespace()); [EOL] }
public void testNextNonWhitespaceWithSlash() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("/")); [EOL] reader.setLenient(true); [EOL] assertEquals('/', reader.nextNonWhitespace()); [EOL] }
public void testNextNonWhitespaceWithAsteriskComment() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("/* comment */")); [EOL] reader.setLenient(true); [EOL] try { [EOL] reader.nextNonWhitespace(); [EOL] fail("Should have thrown syntax error for unterminated comment"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testNextNonWhitespaceWithSlashComment() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("// comment\n")); [EOL] reader.setLenient(true); [EOL] assertEquals('\n', reader.nextNonWhitespace()); [EOL] }
public void testNextNonWhitespaceWithSharp() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("# comment\n")); [EOL] reader.setLenient(true); [EOL] assertEquals('\n', reader.nextNonWhitespace()); [EOL] }
public void testNextNonWhitespaceWithEOF() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("")); [EOL] try { [EOL] reader.nextNonWhitespace(); [EOL] fail("Should have thrown EOFException"); [EOL] } catch (EOFException e) { [EOL] } [EOL] }
private String nextString(char quote) throws IOException { [EOL] StringBuilder builder = null; [EOL] do { [EOL] int start = pos; [EOL] while (pos < limit) { [EOL] int c = buffer[pos++]; [EOL] if (c == quote) { [EOL] if (skipping) { [EOL] return "skipped!"; [EOL] } else if (builder == null) { [EOL] return new String(buffer, start, pos - start - 1); [EOL] } else { [EOL] builder.append(buffer, start, pos - start - 1); [EOL] return builder.toString(); [EOL] } [EOL] } else if (c == '\\') { [EOL] if (builder == null) { [EOL] builder = new StringBuilder(); [EOL] } [EOL] builder.append(buffer, start, pos - start - 1); [EOL] builder.append(readEscapeCharacter()); [EOL] start = pos; [EOL] } [EOL] } [EOL] if (builder == null) { [EOL] builder = new StringBuilder(); [EOL] } [EOL] builder.append(buffer, start, pos - start); [EOL] } while (fillBuffer(1)); [EOL] throw syntaxError("Unterminated string"); [EOL] }
private String nextLiteral() throws IOException { [EOL] StringBuilder builder = null; [EOL] do { [EOL] int start = pos; [EOL] while (pos < limit) { [EOL] int c = buffer[pos++]; [EOL] switch(c) { [EOL] case '/': [EOL] case '\\': [EOL] case ';': [EOL] case '#': [EOL] case '=': [EOL] checkLenient(); [EOL] case '{': [EOL] case '}': [EOL] case '[': [EOL] case ']': [EOL] case ':': [EOL] case ',': [EOL] case ' ': [EOL] case '\t': [EOL] case '\f': [EOL] case '\r': [EOL] case '\n': [EOL] pos--; [EOL] if (skipping) { [EOL] return "skipped!"; [EOL] } else if (builder == null) { [EOL] return new String(buffer, start, pos - start); [EOL] } else { [EOL] builder.append(buffer, start, pos - start); [EOL] return builder.toString(); [EOL] } [EOL] } [EOL] } [EOL] if (builder == null) { [EOL] builder = new StringBuilder(); [EOL] } [EOL] builder.append(buffer, start, pos - start); [EOL] } while (fillBuffer(1)); [EOL] return builder.toString(); [EOL] }
private char readEscapeCharacter() throws IOException { [EOL] if (pos == limit && !fillBuffer(1)) { [EOL] throw syntaxError("Unterminated escape sequence"); [EOL] } [EOL] char escaped = buffer[pos++]; [EOL] switch(escaped) { [EOL] case 'u': [EOL] if (pos + 4 > limit && !fillBuffer(4)) { [EOL] throw syntaxError("Unterminated escape sequence"); [EOL] } [EOL] String hex = new String(buffer, pos, 4); [EOL] pos += 4; [EOL] return (char) Integer.parseInt(hex, 16); [EOL] case 't': [EOL] return '\t'; [EOL] case 'b': [EOL] return '\b'; [EOL] case 'n': [EOL] return '\n'; [EOL] case 'r': [EOL] return '\r'; [EOL] case 'f': [EOL] return '\f'; [EOL] case '\'': [EOL] case '"': [EOL] case '\\': [EOL] default: [EOL] return escaped; [EOL] } [EOL] }
private void testDecodeLiteralWithNullValue() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("null")); [EOL] jsonReader.decodeLiteral(); [EOL] assertEquals(JsonToken.NULL, jsonReader.peek()); [EOL] } [EOL] private void testDecodeLiteralWithBooleanTrueValue() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("true")); [EOL] jsonReader.decodeLiteral(); [EOL] assertEquals(JsonToken.BOOLEAN, jsonReader.peek()); [EOL] } [EOL] private void testDecodeLiteralWithBooleanFalseValue() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("false")); [EOL] jsonReader.decodeLiteral(); [EOL] assertEquals(JsonToken.BOOLEAN, jsonReader.peek()); [EOL] } [EOL] private void testDecodeLiteralWithNumberValue() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("123.45")); [EOL] jsonReader.decodeLiteral(); [EOL] assertEquals(JsonToken.NUMBER, jsonReader.peek()); [EOL] } [EOL] private void testDecodeLiteralWithStringValue() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("notANumber")); [EOL] jsonReader.setLenient(true); [EOL] jsonReader.decodeLiteral(); [EOL] assertEquals(JsonToken.STRING, jsonReader.peek()); [EOL] } [EOL] private void testDecodeLiteralWithNumberFormatException() throws IOException { [EOL] JsonReader jsonReader = new JsonReader(new StringReader("notANumber")); [EOL] try { [EOL] jsonReader.decodeLiteral(); [EOL] fail("Should have thrown NumberFormatException"); [EOL] } catch (NumberFormatException ignored) { [EOL] } [EOL] }
public boolean isAnonymousOrLocal(Class<?> clazz) { [EOL] return clazz.isAnonymousClass() || clazz.isLocalClass(); [EOL] } [EOL] public void testShouldSkipClassWithAnonymousClass() { [EOL] boolean result = shouldSkipClass(new Object(){}.getClass()); [EOL] assert result == true; [EOL] } [EOL] public void testShouldSkipClassWithLocalClass() { [EOL] class LocalClass {} [EOL] boolean result = shouldSkipClass(LocalClass.class); [EOL] assert result == true; [EOL] } [EOL] public void testShouldSkipClassWithRegularClass() { [EOL] boolean result = shouldSkipClass(String.class); [EOL] assert result == false; [EOL] }
public void testIsAnonymousOrLocal_WithEnum() { [EOL] Gson gson = new Gson(); [EOL] boolean result = gson.isAnonymousOrLocal(Enum.class); [EOL] assertFalse(result); [EOL] }
public void testIsAnonymousOrLocal_WithAnonymousClass() { [EOL] Gson gson = new Gson(); [EOL] Object anonymousClassInstance = new Object() {}; [EOL] boolean result = gson.isAnonymousOrLocal(anonymousClassInstance.getClass()); [EOL] assertTrue(result); [EOL] }
public void testIsAnonymousOrLocal_WithLocalClass() { [EOL] Gson gson = new Gson(); [EOL] class LocalClass {} [EOL] boolean result = gson.isAnonymousOrLocal(LocalClass.class); [EOL] assertTrue(result); [EOL] }
public void testIsAnonymousOrLocal_WithRegularClass() { [EOL] Gson gson = new Gson(); [EOL] boolean result = gson.isAnonymousOrLocal(String.class); [EOL] assertFalse(result); [EOL] }
public void testVisitArrayFieldWithJsonObject() throws JsonParseException, IllegalAccessException { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type typeOfF = mock(Type.class); [EOL] Object obj = new Object(); [EOL] JsonElement json = new JsonObject(); [EOL] when(f.getName()).thenReturn("fieldName"); [EOL] ((JsonObject) json).add("fieldName", new JsonArray()); [EOL] visitArrayField(f, typeOfF, obj); [EOL] verify(f).set(eq(obj), any()); [EOL] }
public void testVisitArrayFieldWithNonJsonObject() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type typeOfF = mock(Type.class); [EOL] Object obj = new Object(); [EOL] JsonElement json = new JsonPrimitive("not a json object"); [EOL] try { [EOL] visitArrayField(f, typeOfF, obj); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testVisitArrayFieldWithNullJsonChild() throws IllegalAccessException { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type typeOfF = mock(Type.class); [EOL] Object obj = new Object(); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] when(f.getName()).thenReturn("fieldName"); [EOL] json = jsonObject; [EOL] visitArrayField(f, typeOfF, obj); [EOL] verify(f).set(obj, null); [EOL] }
public void testVisitArrayFieldWithIllegalAccessException() throws IllegalAccessException { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type typeOfF = mock(Type.class); [EOL] Object obj = new Object(); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.add("fieldName", new JsonArray()); [EOL] when(f.getName()).thenReturn("fieldName"); [EOL] json = jsonObject; [EOL] doThrow(new IllegalAccessException()).when(f).set(any(), any()); [EOL] try { [EOL] visitArrayField(f, typeOfF, obj); [EOL] fail("Expected RuntimeException"); [EOL] } catch (RuntimeException e) { [EOL] } [EOL] }
public void testVisitFieldUsingCustomHandler_JsonParseException() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonElement json = new JsonPrimitive("not a JsonObject"); [EOL] ExclusionStrategyAdapter adapter = new ExclusionStrategyAdapter(json); [EOL] try { [EOL] adapter.visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] fail("Should have thrown JsonParseException"); [EOL] } catch (JsonParseException expected) { [EOL] } [EOL] }
public void testVisitFieldUsingCustomHandler_NullChild() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.add("fieldName", JsonNull.INSTANCE); [EOL] when(f.getName()).thenReturn("fieldName"); [EOL] ExclusionStrategyAdapter adapter = new ExclusionStrategyAdapter(jsonObject); [EOL] boolean result = adapter.visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] assertTrue(result); [EOL] }
public void testVisitFieldUsingCustomHandler_NoMatchingHandler() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.add("fieldName", new JsonPrimitive("value")); [EOL] when(f.getName()).thenReturn("fieldName"); [EOL] ExclusionStrategyAdapter adapter = new ExclusionStrategyAdapter(jsonObject); [EOL] adapter.setDeserializers(new HashMap<TypeToken<?>, JsonDeserializer<?>>()); [EOL] boolean result = adapter.visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] assertFalse(result); [EOL] }
public void testVisitFieldUsingCustomHandler_SuccessfulDeserialization() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.add("fieldName", new JsonPrimitive("value")); [EOL] when(f.getName()).thenReturn("fieldName"); [EOL] Map<TypeToken<?>, JsonDeserializer<?>> deserializers = new HashMap<>(); [EOL] TypeToken<?> typeToken = TypeToken.get(declaredTypeOfField); [EOL] JsonDeserializer<?> deserializer = mock(JsonDeserializer.class); [EOL] deserializers.put(typeToken, deserializer); [EOL] ExclusionStrategyAdapter adapter = new ExclusionStrategyAdapter(jsonObject); [EOL] adapter.setDeserializers(deserializers); [EOL] when(deserializer.deserialize(any(JsonElement.class), eq(declaredTypeOfField), any(JsonDeserializationContext.class))) [EOL] .thenReturn("deserializedValue"); [EOL] boolean result = adapter.visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] assertTrue(result); [EOL] }
public void testVisitFieldUsingCustomHandler_IllegalAccessException() { [EOL] FieldAttributes f = mock(FieldAttributes.class); [EOL] Type declaredTypeOfField = mock(Type.class); [EOL] Object parent = new Object(); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.add("fieldName", new JsonPrimitive("value")); [EOL] when(f.getName()).thenReturn("fieldName"); [EOL] ExclusionStrategyAdapter adapter = new ExclusionStrategyAdapter(jsonObject) { [EOL] @Override [EOL] protected String getFieldName(FieldAttributes f) { [EOL] return super.getFieldName(f); [EOL] } [EOL] @Override [EOL] protected Object invokeCustomDeserializer(JsonElement json, Pair<JsonDeserializer<?>, ObjectTypePair> pair) { [EOL] return new Object(); [EOL] } [EOL] @Override [EOL] public void setField(FieldAttributes f, Object parent, Object value) throws IllegalAccessException { [EOL] throw new IllegalAccessException(); [EOL] } [EOL] }; [EOL] try { [EOL] adapter.visitFieldUsingCustomHandler(f, declaredTypeOfField, parent); [EOL] fail("Should have thrown RuntimeException"); [EOL] } catch (RuntimeException expected) { [EOL] } [EOL] }
public void testObjectNavigatorFactoryWithNonNullStrategyAndFieldNamingPolicy() { [EOL] ExclusionStrategy strategy = mock(ExclusionStrategy.class); [EOL] FieldNamingStrategy2 fieldNamingPolicy = mock(FieldNamingStrategy2.class); [EOL] ObjectNavigatorFactory factory = new ObjectNavigatorFactory(strategy, fieldNamingPolicy); [EOL] assertNotNull(factory); [EOL] }
public void testObjectNavigatorFactoryWithNullStrategy() { [EOL] FieldNamingStrategy2 fieldNamingPolicy = mock(FieldNamingStrategy2.class); [EOL] ObjectNavigatorFactory factory = new ObjectNavigatorFactory(null, fieldNamingPolicy); [EOL] assertNotNull(factory); [EOL] }
public void testObjectNavigatorFactoryWithNullFieldNamingPolicy() { [EOL] ExclusionStrategy strategy = mock(ExclusionStrategy.class); [EOL] try { [EOL] new ObjectNavigatorFactory(strategy, null); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testCreateWithNonNullObjTypePair() { [EOL] ObjectTypePair objTypePair = new ObjectTypePair(new Object(), Object.class); [EOL] ExclusionStrategy strategy = mock(ExclusionStrategy.class); [EOL] ObjectNavigatorFactory factory = new ObjectNavigatorFactory(strategy); [EOL] ObjectNavigator navigator = factory.create(objTypePair); [EOL] assertNotNull(navigator); [EOL] }
public void testCreateWithNullObjTypePair() { [EOL] ObjectTypePair objTypePair = null; [EOL] ExclusionStrategy strategy = mock(ExclusionStrategy.class); [EOL] ObjectNavigatorFactory factory = new ObjectNavigatorFactory(strategy); [EOL] try { [EOL] factory.create(objTypePair); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testDeserializeWithNonJsonPrimitive() { [EOL] JsonDeserializationContext context = mock(JsonDeserializationContext.class); [EOL] JsonElement jsonElement = mock(JsonElement.class); [EOL] when(jsonElement instanceof JsonPrimitive).thenReturn(false); [EOL] DateDeserializer deserializer = new DateDeserializer(); [EOL] try { [EOL] deserializer.deserialize(jsonElement, Date.class, context); [EOL] fail("JsonParseException expected"); [EOL] } catch (JsonParseException e) { [EOL] assertEquals("The date should be a string value", e.getMessage()); [EOL] } [EOL] }
public void testDeserializeWithValidJsonPrimitive() { [EOL] JsonDeserializationContext context = mock(JsonDeserializationContext.class); [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("2023-01-01"); [EOL] SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd"); [EOL] DateDeserializer deserializer = new DateDeserializer(); [EOL] deserializer.format = format; [EOL] try { [EOL] Date result = deserializer.deserialize(jsonPrimitive, Date.class, context); [EOL] assertNotNull(result); [EOL] assertEquals("Sun Jan 01 00:00:00 UTC 2023", result.toString()); [EOL] } catch (JsonParseException e) { [EOL] fail("No exception expected"); [EOL] } [EOL] }
public void testDeserializeWithInvalidJsonPrimitive() { [EOL] JsonDeserializationContext context = mock(JsonDeserializationContext.class); [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("invalid-date"); [EOL] SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd"); [EOL] DateDeserializer deserializer = new DateDeserializer(); [EOL] deserializer.format = format; [EOL] try { [EOL] deserializer.deserialize(jsonPrimitive, Date.class, context); [EOL] fail("JsonSyntaxException expected"); [EOL] } catch (JsonSyntaxException e) { [EOL] assertNotNull(e.getCause()); [EOL] assertTrue(e.getCause() instanceof ParseException); [EOL] } [EOL] }
public void testDeserializeWithValidDateJson() { [EOL] JsonDeserializationContext context = mock(JsonDeserializationContext.class); [EOL] JsonElement json = new JsonPrimitive("2023-04-01T12:34:56.789Z"); [EOL] Date expectedDate = new Date(); [EOL] when(context.deserialize(json, Date.class)).thenReturn(expectedDate); [EOL] Timestamp result = deserialize(json, Timestamp.class, context); [EOL] assertEquals(expectedDate.getTime(), result.getTime()); [EOL] }
public void testDeserializeWithInvalidDateJson() { [EOL] JsonDeserializationContext context = mock(JsonDeserializationContext.class); [EOL] JsonElement json = new JsonPrimitive("invalid-date"); [EOL] when(context.deserialize(json, Date.class)).thenThrow(new JsonParseException("Invalid date format")); [EOL] try { [EOL] deserialize(json, Timestamp.class, context); [EOL] fail("JsonParseException expected"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testSerializeGregorianCalendar() { [EOL] GregorianCalendar calendar = new GregorianCalendar(2021, Calendar.DECEMBER, 25, 15, 30, 55); [EOL] Type typeOfSrc = GregorianCalendar.class; [EOL] JsonSerializationContext context = new MockJsonSerializationContext(); [EOL] JsonElement result = serialize(calendar, typeOfSrc, context); [EOL] JsonObject resultObj = result.getAsJsonObject(); [EOL] assertEquals(2021, resultObj.get("year").getAsInt()); [EOL] assertEquals(Calendar.DECEMBER, resultObj.get("month").getAsInt()); [EOL] assertEquals(25, resultObj.get("dayOfMonth").getAsInt()); [EOL] assertEquals(15, resultObj.get("hourOfDay").getAsInt()); [EOL] assertEquals(30, resultObj.get("minute").getAsInt()); [EOL] assertEquals(55, resultObj.get("second").getAsInt()); [EOL] }
public void testSerializeWithValidInput() { [EOL] EnumType src = EnumType.VALUE; [EOL] Type typeOfSrc = src.getClass(); [EOL] JsonSerializationContext context = new MockJsonSerializationContext(); [EOL] JsonElement result = serialize(src, typeOfSrc, context); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertEquals(src.name(), result.getAsString()); [EOL] }
public void testSerializeWithNullInput() { [EOL] EnumType src = null; [EOL] Type typeOfSrc = EnumType.class; [EOL] JsonSerializationContext context = new MockJsonSerializationContext(); [EOL] JsonElement result = serialize(src, typeOfSrc, context); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithValidEnum() { [EOL] JsonElement json = new JsonPrimitive("MONDAY"); [EOL] Type classOfT = DayOfWeek.class; [EOL] Gson gson = new Gson(); [EOL] DayOfWeek result = gson.fromJson(json, classOfT); [EOL] assertEquals(DayOfWeek.MONDAY, result); [EOL] }
public void testDeserializeWithInvalidEnum() { [EOL] JsonElement json = new JsonPrimitive("NODAY"); [EOL] Type classOfT = DayOfWeek.class; [EOL] Gson gson = new Gson(); [EOL] try { [EOL] gson.fromJson(json, classOfT); [EOL] fail("JsonParseException expected"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testDeserializeWithNullJsonElement() { [EOL] Type classOfT = DayOfWeek.class; [EOL] Gson gson = new Gson(); [EOL] try { [EOL] gson.fromJson((JsonElement) null, classOfT); [EOL] fail("JsonParseException expected"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testDeserializeWithNullType() { [EOL] JsonElement json = new JsonPrimitive("MONDAY"); [EOL] Gson gson = new Gson(); [EOL] try { [EOL] gson.fromJson(json, null); [EOL] fail("NullPointerException expected"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void testDeserializeValidUrl() { [EOL] JsonElement json = new JsonPrimitive("http://www.google.com"); [EOL] Type typeOfT = URL.class; [EOL] JsonDeserializationContext context = new JsonDeserializationContext() { [EOL] }; [EOL] URL result = deserialize(json, typeOfT, context); [EOL] assertEquals("http://www.google.com", result.toString()); [EOL] }
public void testDeserializeInvalidUrl() { [EOL] JsonElement json = new JsonPrimitive("invalidurl"); [EOL] Type typeOfT = URL.class; [EOL] JsonDeserializationContext context = new JsonDeserializationContext() { [EOL] }; [EOL] try { [EOL] URL result = deserialize(json, typeOfT, context); [EOL] fail("JsonSyntaxException expected"); [EOL] } catch (JsonSyntaxException e) { [EOL] } [EOL] }
public void testSerializeWithValidUUID() { [EOL] UUID uuid = UUID.randomUUID(); [EOL] JsonElement result = serialize(uuid, UUID.class, null); [EOL] assertEquals(uuid.toString(), result.getAsString()); [EOL] }
public void testSerializeWithNullUUID() { [EOL] UUID uuid = null; [EOL] JsonElement result = serialize(uuid, UUID.class, null); [EOL] assertNull(result); [EOL] }
public void testDeserializeSimpleLocale() { [EOL] JsonElement json = new JsonPrimitive("en"); [EOL] Type typeOfT = Locale.class; [EOL] JsonDeserializationContext context = new MockJsonDeserializationContext(); [EOL] Locale result = deserialize(json, typeOfT, context); [EOL] assertEquals(new Locale("en"), result); [EOL] }
public void testDeserializeLocaleWithCountry() { [EOL] JsonElement json = new JsonPrimitive("en_US"); [EOL] Type typeOfT = Locale.class; [EOL] JsonDeserializationContext context = new MockJsonDeserializationContext(); [EOL] Locale result = deserialize(json, typeOfT, context); [EOL] assertEquals(new Locale("en", "US"), result); [EOL] }
public void testDeserializeLocaleWithCountryAndVariant() { [EOL] JsonElement json = new JsonPrimitive("en_US_POSIX"); [EOL] Type typeOfT = Locale.class; [EOL] JsonDeserializationContext context = new MockJsonDeserializationContext(); [EOL] Locale result = deserialize(json, typeOfT, context); [EOL] assertEquals(new Locale("en", "US", "POSIX"), result); [EOL] }
public void testSerializeWithNullCollection() { [EOL] Collection src = null; [EOL] Type typeOfSrc = null; // Assuming Type is a generic type for the purpose of this test [EOL] JsonSerializationContext context = mock(JsonSerializationContext.class); [EOL] JsonElement result = serialize(src, typeOfSrc, context); [EOL] assertTrue(result.isJsonNull()); [EOL] }
public void testSerializeWithEmptyCollection() { [EOL] Collection src = new ArrayList(); [EOL] Type typeOfSrc = null; // Assuming Type is a generic type for the purpose of this test [EOL] JsonSerializationContext context = mock(JsonSerializationContext.class); [EOL] JsonElement result = serialize(src, typeOfSrc, context); [EOL] assertTrue(result.isJsonArray()); [EOL] assertEquals(0, result.getAsJsonArray().size()); [EOL] }
public void testSerializeWithNonParameterizedType() { [EOL] Collection src = Arrays.asList("string1", "string2"); [EOL] Type typeOfSrc = String.class; // Non-parameterized type [EOL] JsonSerializationContext context = mock(JsonSerializationContext.class); [EOL] when(context.serialize(any(), any())).thenReturn(new JsonPrimitive("mockedValue")); [EOL] JsonElement result = serialize(src, typeOfSrc, context); [EOL] assertTrue(result.isJsonArray()); [EOL] assertEquals(2, result.getAsJsonArray().size()); [EOL] for (JsonElement element : result.getAsJsonArray()) { [EOL] assertEquals("mockedValue", element.getAsString()); [EOL] } [EOL] }
public void testSerializeWithParameterizedType() { [EOL] Collection src = Arrays.asList("string1", "string2"); [EOL] Type typeOfSrc = new TypeToken<ArrayList<String>>() {}.getType(); [EOL] JsonSerializationContext context = mock(JsonSerializationContext.class); [EOL] when(context.serialize(any(), any())).thenReturn(new JsonPrimitive("mockedValue")); [EOL] JsonElement result = serialize(src, typeOfSrc, context); [EOL] assertTrue(result.isJsonArray()); [EOL] assertEquals(2, result.getAsJsonArray().size()); [EOL] for (JsonElement element : result.getAsJsonArray()) { [EOL] assertEquals("mockedValue", element.getAsString()); [EOL] } [EOL] }
public void testSerializeWithCollectionContainingNull() { [EOL] Collection src = Arrays.asList("string1", null, "string2"); [EOL] Type typeOfSrc = new TypeToken<ArrayList<String>>() {}.getType(); [EOL] JsonSerializationContext context = mock(JsonSerializationContext.class); [EOL] when(context.serialize(any(), any())).thenReturn(new JsonPrimitive("mockedValue")); [EOL] JsonElement result = serialize(src, typeOfSrc, context); [EOL] assertTrue(result.isJsonArray()); [EOL] JsonArray array = result.getAsJsonArray(); [EOL] assertEquals(3, array.size()); [EOL] assertEquals("mockedValue", array.get(0).getAsString()); [EOL] assertTrue(array.get(1).isJsonNull()); [EOL] assertEquals("mockedValue", array.get(2).getAsString()); [EOL] }
public void testDeserializeWithJsonNull() { [EOL] JsonElement json = JsonNull.INSTANCE; [EOL] Type typeOfT = new TypeToken<Collection<String>>() {}.getType(); [EOL] JsonDeserializationContext context = new MockJsonDeserializationContext(); [EOL] Collection result = deserialize(json, typeOfT, context); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithEmptyJsonArray() { [EOL] JsonElement json = new JsonArray(); [EOL] Type typeOfT = new TypeToken<Collection<String>>() {}.getType(); [EOL] JsonDeserializationContext context = new MockJsonDeserializationContext(); [EOL] Collection result = deserialize(json, typeOfT, context); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testDeserializeWithNonEmptyJsonArray() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(new JsonPrimitive("element1")); [EOL] jsonArray.add(JsonNull.INSTANCE); [EOL] jsonArray.add(new JsonPrimitive("element2")); [EOL] Type typeOfT = new TypeToken<Collection<String>>() {}.getType(); [EOL] JsonDeserializationContext context = new MockJsonDeserializationContext(); [EOL] Collection result = deserialize(jsonArray, typeOfT, context); [EOL] assertEquals(3, result.size()); [EOL] Iterator it = result.iterator(); [EOL] assertEquals("element1", it.next()); [EOL] assertNull(it.next()); [EOL] assertEquals("element2", it.next()); [EOL] }
public void testConstructCollectionTypeWithValidContext() { [EOL] Type collectionType = new TypeToken<ArrayList<String>>(){}.getType(); [EOL] JsonDeserializationContext context = new JsonDeserializationContextDefault(new Gson()); [EOL] Collection result = constructCollectionType(collectionType, context); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof Collection); [EOL] }
public void testConstructCollectionTypeWithInvalidContext() { [EOL] Type collectionType = new TypeToken<ArrayList<String>>(){}.getType(); [EOL] JsonDeserializationContext context = mock(JsonDeserializationContext.class); [EOL] try { [EOL] Collection result = constructCollectionType(collectionType, context); [EOL] fail("Expected ClassCastException to be thrown"); [EOL] } catch (ClassCastException e) { [EOL] } [EOL] }
public void testSerializeWithNonParameterizedMap() { [EOL] Map src = new HashMap(); [EOL] src.put("key1", "value1"); [EOL] src.put("key2", "value2"); [EOL] Type typeOfSrc = src.getClass(); [EOL] JsonSerializationContext context = mock(JsonSerializationContext.class); [EOL] when(context.serialize("value1", String.class)).thenReturn(new JsonPrimitive("value1")); [EOL] when(context.serialize("value2", String.class)).thenReturn(new JsonPrimitive("value2")); [EOL] JsonElement result = serialize(src, typeOfSrc, context); [EOL] JsonObject expected = new JsonObject(); [EOL] expected.add("key1", new JsonPrimitive("value1")); [EOL] expected.add("key2", new JsonPrimitive("value2")); [EOL] assertEquals(expected, result); [EOL] }
public void testSerializeWithParameterizedMap() { [EOL] Map<String, Integer> src = new HashMap<>(); [EOL] src.put("one", 1); [EOL] src.put("two", 2); [EOL] Type typeOfSrc = new TypeToken<Map<String, Integer>>() {}.getType(); [EOL] JsonSerializationContext context = mock(JsonSerializationContext.class); [EOL] when(context.serialize(1, Integer.class)).thenReturn(new JsonPrimitive(1)); [EOL] when(context.serialize(2, Integer.class)).thenReturn(new JsonPrimitive(2)); [EOL] JsonElement result = serialize(src, typeOfSrc, context); [EOL] JsonObject expected = new JsonObject(); [EOL] expected.add("one", new JsonPrimitive(1)); [EOL] expected.add("two", new JsonPrimitive(2)); [EOL] assertEquals(expected, result); [EOL] }
public void testSerializeWithNullValues() { [EOL] Map src = new HashMap(); [EOL] src.put("key1", null); [EOL] src.put("key2", null); [EOL] Type typeOfSrc = src.getClass(); [EOL] JsonSerializationContext context = mock(JsonSerializationContext.class); [EOL] JsonElement result = serialize(src, typeOfSrc, context); [EOL] JsonObject expected = new JsonObject(); [EOL] expected.add("key1", JsonNull.createJsonNull()); [EOL] expected.add("key2", JsonNull.createJsonNull()); [EOL] assertEquals(expected, result); [EOL] }
public void testCreateInstanceWithValidType() { [EOL] Type type = new TypeToken<Map<String, String>>() {}.getType(); [EOL] Object instance = new MapInstanceCreator().createInstance(type); [EOL] assertTrue(instance instanceof LinkedHashMap); [EOL] }
public void testSerializeWithNullInteger() { [EOL] JsonElement result = serialize(null, Integer.class, new JsonSerializationContext() { [EOL] }); [EOL] assertNull(result); [EOL] }
public void testSerializeWithNonNullInteger() { [EOL] JsonElement result = serialize(123, Integer.class, new JsonSerializationContext() { [EOL] }); [EOL] assertNotNull(result); [EOL] assertEquals("123", result.getAsString()); [EOL] }
public void testDeserializeWithIntJsonElement() { [EOL] JsonElement jsonElement = new JsonPrimitive(123); [EOL] Integer result = deserialize(jsonElement, Integer.class, null); [EOL] assertEquals(Integer.valueOf(123), result); [EOL] }
public void testDeserializeWithNonIntJsonElement() { [EOL] JsonElement jsonElement = new JsonPrimitive("NotAnInt"); [EOL] try { [EOL] deserialize(jsonElement, Integer.class, null); [EOL] fail("Expected JsonParseException"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testDeserializeWithDoubleValue() { [EOL] JsonElement json = new JsonPrimitive(10.5); [EOL] Double result = deserialize(json, double.class, null); [EOL] assertEquals(10.5, result, 0.0); [EOL] }
public void testDeserializeWithNumberFormatException() { [EOL] JsonElement json = new JsonPrimitive("not a number"); [EOL] try { [EOL] deserialize(json, double.class, null); [EOL] fail("JsonParseException expected"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testCreateInstanceWithValidType() { [EOL] Type type = new TypeToken<TreeSet<String>>() {}.getType(); [EOL] TreeSet<?> result = createInstance(type); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof TreeSet); [EOL] }
public void testCreateInstanceWithNullType() { [EOL] Type type = null; [EOL] try { [EOL] TreeSet<?> result = createInstance(type); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public HashSet<?> createInstance(Type type) { [EOL] return new HashSet<Object>(); [EOL] }
public void testTypeInfoMapWithPropertiesSubclass() { [EOL] Type mapType = Properties.class; [EOL] TypeInfoMap typeInfoMap = new TypeInfoMap(mapType); [EOL] assertEquals(String.class, typeInfoMap.keyType); [EOL] assertEquals(String.class, typeInfoMap.valueType); [EOL] }
public void testTypeInfoMapWithParameterizedType() { [EOL] Type mapType = new TypeToken<Map<String, Integer>>(){}.getType(); [EOL] TypeInfoMap typeInfoMap = new TypeInfoMap(mapType); [EOL] assertEquals(String.class, typeInfoMap.keyType); [EOL] assertEquals(Integer.class, typeInfoMap.valueType); [EOL] }
public void testTypeInfoMapWithInvalidType() { [EOL] Type mapType = String.class; [EOL] try { [EOL] new TypeInfoMap(mapType); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testGetKeyType() { [EOL] MapType mapType = new MapType(String.class, Integer.class); [EOL] Type keyType = mapType.getKeyType(); [EOL] assertEquals(String.class, keyType); [EOL] }
public void testGetValueType() { [EOL] Type expectedType = Type.STRING; // Replace Type.STRING with the actual Type object you expect [EOL] MyClass myClassInstance = new MyClass(expectedType); [EOL] Type result = myClassInstance.getValueType(); [EOL] assertEquals(expectedType, result); [EOL] }
public void testParseString() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("\"testString\"")); [EOL] JsonElement result = parse(reader); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertEquals("testString", result.getAsString()); [EOL] }
public void testParseNumber() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("12345")); [EOL] JsonElement result = parse(reader); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertEquals(12345, result.getAsInt()); [EOL] }
public void testParseBoolean() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("true")); [EOL] JsonElement result = parse(reader); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertTrue(result.getAsBoolean()); [EOL] }
public void testParseNull() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("null")); [EOL] JsonElement result = parse(reader); [EOL] assertTrue(result.isJsonNull()); [EOL] }
public void testParseArray() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("[\"item1\", 2, true, null]")); [EOL] JsonElement result = parse(reader); [EOL] assertTrue(result.isJsonArray()); [EOL] JsonArray array = result.getAsJsonArray(); [EOL] assertEquals(4, array.size()); [EOL] assertEquals("item1", array.get(0).getAsString()); [EOL] assertEquals(2, array.get(1).getAsInt()); [EOL] assertTrue(array.get(2).getAsBoolean()); [EOL] assertTrue(array.get(3).isJsonNull()); [EOL] }
public void testParseObject() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("{\"key1\":\"value1\",\"key2\":2,\"key3\":true,\"key4\":null}")); [EOL] JsonElement result = parse(reader); [EOL] assertTrue(result.isJsonObject()); [EOL] JsonObject object = result.getAsJsonObject(); [EOL] assertEquals("value1", object.get("key1").getAsString()); [EOL] assertEquals(2, object.get("key2").getAsInt()); [EOL] assertTrue(object.get("key3").getAsBoolean()); [EOL] assertTrue(object.get("key4").isJsonNull()); [EOL] }
public void testParseEmptyArray() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("[]")); [EOL] JsonElement result = parse(reader); [EOL] assertTrue(result.isJsonArray()); [EOL] assertEquals(0, result.getAsJsonArray().size()); [EOL] }
public void testParseEmptyObject() throws IOException { [EOL] JsonReader reader = new JsonReader(new StringReader("{}")); [EOL] JsonElement result = parse(reader); [EOL] assertTrue(result.isJsonObject()); [EOL] assertEquals(0, result.getAsJsonObject().entrySet().size()); [EOL] }
public void testParseEndOfDocument() { [EOL] JsonReader reader = new JsonReader(new StringReader("")); [EOL] try { [EOL] parse(reader); [EOL] fail("Expected IllegalArgumentException"); [EOL] } catch (IOException e) { [EOL] } [EOL] }
public void testParseInvalidToken() { [EOL] JsonReader reader = new JsonReader(new StringReader("invalid")); [EOL] try { [EOL] parse(reader); [EOL] fail("Expected JsonSyntaxException"); [EOL] } catch (JsonSyntaxException e) { [EOL] } catch (IOException e) { [EOL] fail("Expected JsonSyntaxException, but got IOException"); [EOL] } [EOL] }
public void testWriteNullElementWithSerializeNulls() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] write(null, true, writer); [EOL] verify(writer).nullValue(); [EOL] }
public void testWriteNullElementWithoutSerializeNulls() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] write(null, false, writer); [EOL] verify(writer, never()).nullValue(); [EOL] }
public void testWriteJsonPrimitiveNumber() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonElement element = new JsonPrimitive(10); [EOL] write(element, true, writer); [EOL] verify(writer).value(10); [EOL] }
public void testWriteJsonPrimitiveBoolean() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonElement element = new JsonPrimitive(true); [EOL] write(element, true, writer); [EOL] verify(writer).value(true); [EOL] }
public void testWriteJsonPrimitiveString() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonElement element = new JsonPrimitive("test"); [EOL] write(element, true, writer); [EOL] verify(writer).value("test"); [EOL] }
public void testWriteJsonArray() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(1); [EOL] jsonArray.add("string"); [EOL] JsonElement element = jsonArray; [EOL] write(element, true, writer); [EOL] verify(writer).beginArray(); [EOL] verify(writer).value(1); [EOL] verify(writer).value("string"); [EOL] verify(writer).endArray(); [EOL] }
public void testWriteJsonObject() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.add("key1", new JsonPrimitive(1)); [EOL] jsonObject.add("key2", new JsonPrimitive("value")); [EOL] JsonElement element = jsonObject; [EOL] write(element, true, writer); [EOL] verify(writer).beginObject(); [EOL] verify(writer).name("key1"); [EOL] verify(writer).value(1); [EOL] verify(writer).name("key2"); [EOL] verify(writer).value("value"); [EOL] verify(writer).endObject(); [EOL] }
public void testWriteJsonObjectWithNullValueAndSerializeNulls() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.add("key1", JsonNull.INSTANCE); [EOL] JsonElement element = jsonObject; [EOL] write(element, true, writer); [EOL] verify(writer).beginObject(); [EOL] verify(writer).name("key1"); [EOL] verify(writer).nullValue(); [EOL] verify(writer).endObject(); [EOL] }
public void testWriteJsonObjectWithNullValueWithoutSerializeNulls() throws IOException { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.add("key1", JsonNull.INSTANCE); [EOL] JsonElement element = jsonObject; [EOL] write(element, false, writer); [EOL] verify(writer).beginObject(); [EOL] verify(writer, never()).name("key1"); [EOL] verify(writer, never()).nullValue(); [EOL] verify(writer).endObject(); [EOL] }
public void testWriteIllegalArgument() { [EOL] JsonWriter writer = mock(JsonWriter.class); [EOL] JsonElement element = mock(JsonElement.class); [EOL] when(element.isJsonNull()).thenReturn(false); [EOL] when(element.isJsonPrimitive()).thenReturn(false); [EOL] when(element.isJsonArray()).thenReturn(false); [EOL] when(element.isJsonObject()).thenReturn(false); [EOL] Exception exception = assertThrows(IllegalArgumentException.class, () -> { [EOL] write(element, true, writer); [EOL] }); [EOL] assertEquals("Couldn't write " + element.getClass(), exception.getMessage()); [EOL] }
public void testWriterForAppendableWithWriter() { [EOL] Writer writer = new StringWriter(); [EOL] Writer result = GsonInternalAccess.writerForAppendable(writer); [EOL] assertSame(writer, result); [EOL] }
public void testWriterForAppendableWithNonWriter() { [EOL] StringBuilder stringBuilder = new StringBuilder(); [EOL] Writer result = GsonInternalAccess.writerForAppendable(stringBuilder); [EOL] assertNotNull(result); [EOL] assertTrue(result instanceof AppendableWriter); [EOL] }
public void testCheckNotNullWithNonNull() { [EOL] Object obj = new Object(); [EOL] Gson.checkNotNull(obj); [EOL] }
public void testCheckNotNullWithNull() { [EOL] Object obj = null; [EOL] try { [EOL] Gson.checkNotNull(obj); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testGetAsBigDecimal_SingleElement() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(new BigDecimal("10")); [EOL] BigDecimal result = jsonArray.getAsBigDecimal(); [EOL] assertEquals(new BigDecimal("10"), result); [EOL] }
public void testGetAsBigDecimal_MultipleElements_ThrowsException() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(new BigDecimal("10")); [EOL] jsonArray.add(new BigDecimal("20")); [EOL] try { [EOL] jsonArray.getAsBigDecimal(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] } [EOL] }
private FieldNamingPolicy(FieldNamingStrategy2 namingPolicy) { [EOL] this.namingPolicy = namingPolicy; [EOL] }
public void testGetFieldNamingPolicy() { [EOL] Gson gson = new GsonBuilder().create(); [EOL] FieldNamingStrategy2 actualNamingPolicy = gson.getFieldNamingPolicy(); [EOL] assertNotNull(actualNamingPolicy); [EOL] }
public void testGetRawType() { [EOL] Type expectedType = String.class; [EOL] TypeToken<String> typeToken = TypeToken.get(expectedType); [EOL] Type resultType = typeToken.getRawType(); [EOL] assertEquals(expectedType, resultType); [EOL] }
public void testGetActualTypeArguments_Null() { [EOL] ParameterizedTypeImpl pt = new ParameterizedTypeImpl(null, null, null); [EOL] Type[] result = pt.getActualTypeArguments(); [EOL] assertNull(result); [EOL] }
public void testGetActualTypeArguments_Empty() { [EOL] Type[] expectedTypes = new Type[0]; [EOL] ParameterizedTypeImpl pt = new ParameterizedTypeImpl(null, null, expectedTypes); [EOL] Type[] result = pt.getActualTypeArguments(); [EOL] assertArrayEquals(expectedTypes, result); [EOL] }
public void testGetActualTypeArguments_NonEmpty() { [EOL] Type[] expectedTypes = new Type[] {String.class, Integer.class}; [EOL] ParameterizedTypeImpl pt = new ParameterizedTypeImpl(null, null, expectedTypes); [EOL] Type[] result = pt.getActualTypeArguments(); [EOL] assertArrayEquals(expectedTypes, result); [EOL] }
public void testGetOwnerType_WithNonNullOwner() { [EOL] Type expectedOwner = new Type() {}; // Assuming Type is an interface or abstract class [EOL] ParameterizedTypeImpl typeImpl = new ParameterizedTypeImpl(expectedOwner, null, null); [EOL] Type result = typeImpl.getOwnerType(); [EOL] assertEquals(expectedOwner, result); [EOL] }
public void testGetOwnerType_WithNullOwner() { [EOL] ParameterizedTypeImpl typeImpl = new ParameterizedTypeImpl(null, null, null); [EOL] Type result = typeImpl.getOwnerType(); [EOL] assertNull(result); [EOL] }
public void testHashCode_nullOwnerAndRawType() { [EOL] Type[] actualTypeArguments = new Type[] { String.class, Integer.class }; [EOL] ParameterizedTypeImpl testType = new ParameterizedTypeImpl(null, null, actualTypeArguments); [EOL] int expectedHashCode = Arrays.hashCode(actualTypeArguments); [EOL] assertEquals(expectedHashCode, testType.hashCode()); [EOL] }
public void testHashCode_nonNullOwnerAndRawType() { [EOL] Type[] actualTypeArguments = new Type[] { String.class, Integer.class }; [EOL] Type owner = String.class; [EOL] Type rawType = List.class; [EOL] ParameterizedTypeImpl testType = new ParameterizedTypeImpl(owner, rawType, actualTypeArguments); [EOL] int expectedHashCode = Arrays.hashCode(actualTypeArguments) ^ owner.hashCode() ^ rawType.hashCode(); [EOL] assertEquals(expectedHashCode, testType.hashCode()); [EOL] }
public void testHashCode_nullOwnerNonNullRawType() { [EOL] Type[] actualTypeArguments = new Type[] { String.class, Integer.class }; [EOL] Type rawType = List.class; [EOL] ParameterizedTypeImpl testType = new ParameterizedTypeImpl(null, rawType, actualTypeArguments); [EOL] int expectedHashCode = Arrays.hashCode(actualTypeArguments) ^ rawType.hashCode(); [EOL] assertEquals(expectedHashCode, testType.hashCode()); [EOL] }
public void testHashCode_nonNullOwnerNullRawType() { [EOL] Type[] actualTypeArguments = new Type[] { String.class, Integer.class }; [EOL] Type owner = String.class; [EOL] ParameterizedTypeImpl testType = new ParameterizedTypeImpl(owner, null, actualTypeArguments); [EOL] int expectedHashCode = Arrays.hashCode(actualTypeArguments) ^ owner.hashCode(); [EOL] assertEquals(expectedHashCode, testType.hashCode()); [EOL] }
public void testGetActualTypeForFirstTypeVariableWithClass() { [EOL] Type result = YourClass.getActualTypeForFirstTypeVariable(String.class); [EOL] assertEquals(Object.class, result); [EOL] }
public void testGetActualTypeForFirstTypeVariableWithParameterizedType() { [EOL] Type type = new ParameterizedType() { [EOL] public Type[] getActualTypeArguments() { [EOL] return new Type[] {String.class}; [EOL] } [EOL] public Type getRawType() { return null; } [EOL] public Type getOwnerType() { return null; } [EOL] }; [EOL] Type result = YourClass.getActualTypeForFirstTypeVariable(type); [EOL] assertEquals(String.class, result); [EOL] }
public void testGetActualTypeForFirstTypeVariableWithGenericArrayType() { [EOL] Type type = new GenericArrayType() { [EOL] public Type getGenericComponentType() { [EOL] return String.class; [EOL] } [EOL] }; [EOL] Type result = YourClass.getActualTypeForFirstTypeVariable(type); [EOL] assertEquals(Object.class, result); [EOL] }
public void testGetActualTypeForFirstTypeVariableWithUnsupportedType() { [EOL] Type type = new Type() {}; [EOL] try { [EOL] YourClass.getActualTypeForFirstTypeVariable(type); [EOL] fail("IllegalArgumentException expected"); [EOL] } catch (IllegalArgumentException e) { [EOL] } [EOL] }
public void testIsArrayWithClassType() { [EOL] assertTrue($CLASS$.isArray(int[].class)); [EOL] assertFalse($CLASS$.isArray(int.class)); [EOL] }
public void testIsArrayWithGenericArrayType() throws NoSuchFieldException { [EOL] Type genericArrayType = ((ParameterizedType) getClass().getDeclaredField("listOfArrays").getGenericType()).getActualTypeArguments()[0]; [EOL] assertTrue($CLASS$.isArray(genericArrayType)); [EOL] }
public void testIsArrayWithNonArrayType() { [EOL] assertFalse($CLASS$.isArray(String.class)); [EOL] }
public void testSerializedNameAnnotationInterceptingNamingPolicyWithNonNullDelegate() { [EOL] FieldNamingStrategy2 delegate = mock(FieldNamingStrategy2.class); [EOL] SerializedNameAnnotationInterceptingNamingPolicy policy = new SerializedNameAnnotationInterceptingNamingPolicy(delegate); [EOL] assertNotNull(policy); [EOL] }
public void testSerializedNameAnnotationInterceptingNamingPolicyWithNullDelegate() { [EOL] try { [EOL] new SerializedNameAnnotationInterceptingNamingPolicy(null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void toJson_withNonNullObjectAndAppendable_callsToJsonWithClassAndWriter() throws IOException { [EOL] Gson gson = new Gson(); [EOL] Object src = new Object(); [EOL] Appendable writer = new StringBuilder(); [EOL] gson.toJson(src, writer); [EOL] verifyResult(writer); [EOL] }
public void toJson_withNullObjectAndSerializeNullsTrue_writesOutNullString() throws IOException { [EOL] Gson gson = new GsonBuilder().serializeNulls().create(); [EOL] Object src = null; [EOL] Appendable writer = new StringBuilder(); [EOL] gson.toJson(src, writer); [EOL] assertEquals("null", writer.toString()); [EOL] }
public void toJson_withNullObjectAndSerializeNullsFalse_doesNotWrite() throws IOException { [EOL] Gson gson = new Gson(); // serializeNulls defaults to false [EOL] Object src = null; [EOL] Appendable writer = new StringBuilder(); [EOL] gson.toJson(src, writer); [EOL] assertEquals("", writer.toString()); [EOL] }
public void toJson_withIOExceptionOnWrite_throwsRuntimeException() { [EOL] Gson gson = new Gson(); [EOL] Object src = new Object(); [EOL] Appendable writer = new FailingAppendable(); [EOL] assertThrows(RuntimeException.class, () -> gson.toJson(src, writer)); [EOL] } [EOL] class FailingAppendable implements Appendable { [EOL] @Override [EOL] public Appendable append(CharSequence csq) throws IOException { [EOL] throw new IOException("Failed to write"); [EOL] } [EOL] @Override [EOL] public Appendable append(CharSequence csq, int start, int end) throws IOException { [EOL] throw new IOException("Failed to write"); [EOL] } [EOL] @Override [EOL] public Appendable append(char c) throws IOException { [EOL] throw new IOException("Failed to write"); [EOL] } [EOL] } [EOL] private void verifyResult(Appendable writer) { [EOL] }
public void testToJsonWithObjectAndTypeAndWriter() throws IOException { [EOL] Gson gson = new Gson(); [EOL] StringWriter writer = new StringWriter(); [EOL] TestObject src = new TestObject(1, "test"); [EOL] Type typeOfSrc = new TypeToken<TestObject>() {}.getType(); [EOL] gson.toJson(src, typeOfSrc, writer); [EOL] String jsonResult = writer.toString(); [EOL] assertNotNull(jsonResult); [EOL] assertFalse(jsonResult.isEmpty()); [EOL] }
public void testToJsonWithNullObjectAndTypeAndWriter() throws IOException { [EOL] Gson gson = new Gson(); [EOL] StringWriter writer = new StringWriter(); [EOL] gson.toJson(null, TestObject.class, writer); [EOL] String jsonResult = writer.toString(); [EOL] assertEquals("null", jsonResult); [EOL] }
public void testToJsonWithObjectAndTypeAndWriterForNullAppendable() { [EOL] Gson gson = new Gson(); [EOL] TestObject src = new TestObject(1, "test"); [EOL] Type typeOfSrc = new TypeToken<TestObject>() {}.getType(); [EOL] try { [EOL] gson.toJson(src, typeOfSrc, null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testToJsonWithJsonElement() { [EOL] Gson gson = new Gson(); [EOL] JsonElement jsonElement = new JsonPrimitive("test"); [EOL] String json = gson.toJson(jsonElement); [EOL] assertEquals("\"test\"", json); [EOL] }

public void testFromJsonWithReaderAndClass() throws JsonParseException { [EOL] Gson gson = new Gson(); [EOL] String json = "{\"key\":\"value\"}"; [EOL] Reader reader = new StringReader(json); [EOL] TestObject result = gson.fromJson(reader, TestObject.class); [EOL] assertNotNull(result); [EOL] assertEquals("value", result.getKey()); [EOL] }
public void testFromJsonWithReaderAndClassThrowsException() { [EOL] Gson gson = new Gson(); [EOL] String json = "invalid json"; [EOL] Reader reader = new StringReader(json); [EOL] try { [EOL] gson.fromJson(reader, TestObject.class); [EOL] fail("JsonParseException was expected"); [EOL] } catch (JsonParseException e) { [EOL] assertNotNull(e); [EOL] } [EOL] }
public void testJsonSerializationContextDefaultWithSerializeNullsTrue() { [EOL] ObjectNavigatorFactory factory = new ObjectNavigatorFactory(); [EOL] boolean serializeNulls = true; [EOL] ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers = new ParameterizedTypeHandlerMap<>(); [EOL] JsonSerializationContextDefault context = new JsonSerializationContextDefault(factory, serializeNulls, serializers); [EOL] assertNotNull(context); [EOL] assertEquals(serializeNulls, context.serializeNulls); [EOL] assertEquals(factory, context.factory); [EOL] assertEquals(serializers, context.serializers); [EOL] assertNotNull(context.ancestors); [EOL] }
public void testJsonSerializationContextDefaultWithSerializeNullsFalse() { [EOL] ObjectNavigatorFactory factory = new ObjectNavigatorFactory(); [EOL] boolean serializeNulls = false; [EOL] ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers = new ParameterizedTypeHandlerMap<>(); [EOL] JsonSerializationContextDefault context = new JsonSerializationContextDefault(factory, serializeNulls, serializers); [EOL] assertNotNull(context); [EOL] assertEquals(serializeNulls, context.serializeNulls); [EOL] assertEquals(factory, context.factory); [EOL] assertEquals(serializers, context.serializers); [EOL] assertNotNull(context.ancestors); [EOL] }
public void testSerializeWithNullInput() { [EOL] Gson gson = new Gson(); [EOL] JsonElement result = gson.serialize(null); [EOL] assertTrue(result.isJsonNull()); [EOL] }
public void testSerializeWithNonNullInput() { [EOL] Gson gson = new Gson(); [EOL] Object src = new Object(); [EOL] JsonElement result = gson.serialize(src); [EOL] assertNotNull(result); [EOL] assertFalse(result.isJsonNull()); [EOL] }
public JsonElement serialize(Object src, Type typeOfSrc) { [EOL] return serialize(src, typeOfSrc, true); [EOL] }
public void testSerializeWithNonNullObjectAndType() { [EOL] Gson gson = new Gson(); [EOL] MyClass obj = new MyClass("value"); [EOL] Type typeOfSrc = MyClass.class; [EOL] JsonElement result = gson.serialize(obj, typeOfSrc, false); [EOL] assertNotNull(result); [EOL] assertTrue(result.isJsonObject()); [EOL] }
public void testSerializeWithNullObject() { [EOL] Gson gson = new Gson(); [EOL] Object obj = null; [EOL] Type typeOfSrc = Object.class; [EOL] JsonElement result = gson.serialize(obj, typeOfSrc, false); [EOL] assertNotNull(result); [EOL] assertTrue(result.isJsonNull()); [EOL] }
public void testSerializePreservingType() { [EOL] Gson gson = new Gson(); [EOL] MyClass obj = new MyClass("value"); [EOL] Type typeOfSrc = MyClass.class; [EOL] JsonElement result = gson.serialize(obj, typeOfSrc, true); [EOL] assertNotNull(result); [EOL] assertTrue(result.isJsonObject()); [EOL] }
public void testJsonNullConstructor() { [EOL] JsonNull jsonNullInstance = new JsonNull(); [EOL] assertNotNull(jsonNullInstance); [EOL] }
public void testDeserializeWithNullJson() { [EOL] JsonElement json = null; [EOL] Type typeOfT = String.class; [EOL] Object result = deserialize(json, typeOfT); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithJsonNull() { [EOL] JsonElement json = JsonNull.INSTANCE; [EOL] Type typeOfT = String.class; [EOL] Object result = deserialize(json, typeOfT); [EOL] assertNull(result); [EOL] }
public void testDeserializeWithJsonArray() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add("element1"); [EOL] jsonArray.add("element2"); [EOL] Type typeOfT = new TypeToken<List<String>>() {}.getType(); [EOL] List<String> result = deserialize(jsonArray, typeOfT); [EOL] assertNotNull(result); [EOL] assertEquals(Arrays.asList("element1", "element2"), result); [EOL] }
public void testDeserializeWithJsonObject() { [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.addProperty("key1", "value1"); [EOL] jsonObject.addProperty("key2", "value2"); [EOL] Type typeOfT = new TypeToken<Map<String, String>>() {}.getType(); [EOL] Map<String, String> result = deserialize(jsonObject, typeOfT); [EOL] assertNotNull(result); [EOL] assertEquals("value1", result.get("key1")); [EOL] assertEquals("value2", result.get("key2")); [EOL] }
public void testDeserializeWithJsonPrimitive() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("stringValue"); [EOL] Type typeOfT = String.class; [EOL] String result = deserialize(jsonPrimitive, typeOfT); [EOL] assertNotNull(result); [EOL] assertEquals("stringValue", result); [EOL] }
public void testDeserializeWithUnsupportedJsonElement() { [EOL] JsonElement json = new JsonElement() { [EOL] }; [EOL] Type typeOfT = String.class; [EOL] try { [EOL] deserialize(json, typeOfT); [EOL] fail("JsonParseException expected"); [EOL] } catch (JsonParseException e) { [EOL] } [EOL] }
public void testFromJsonArrayWithEmptyArray() { [EOL] Type arrayType = new TypeToken<List<String>>() {}.getType(); [EOL] JsonArray jsonArray = new JsonArray(); [EOL] JsonDeserializationContext context = new JsonDeserializationContextDefault(new Gson()); [EOL] List<String> result = fromJsonArray(arrayType, jsonArray, context); [EOL] assertTrue(result.isEmpty()); [EOL] }
public void testFromJsonArrayWithNonEmptyArray() { [EOL] Type arrayType = new TypeToken<List<String>>() {}.getType(); [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(new JsonPrimitive("test")); [EOL] JsonDeserializationContext context = new JsonDeserializationContextDefault(new Gson()); [EOL] List<String> result = fromJsonArray(arrayType, jsonArray, context); [EOL] assertEquals(1, result.size()); [EOL] assertEquals("test", result.get(0)); [EOL] }
public void testFromJsonArrayWithNullArray() { [EOL] Type arrayType = new TypeToken<List<String>>() {}.getType(); [EOL] JsonDeserializationContext context = new JsonDeserializationContextDefault(new Gson()); [EOL] try { [EOL] List<String> result = fromJsonArray(arrayType, null, context); [EOL] fail("fromJsonArray should throw JsonParseException when jsonArray is null"); [EOL] } catch (JsonParseException expected) { [EOL] } [EOL] }
public void testGetGenericComponentType() { [EOL] Type expectedType = String.class; [EOL] GenericArrayTypeImpl genericArrayType = new GenericArrayTypeImpl(expectedType); [EOL] Type result = genericArrayType.getGenericComponentType(); [EOL] assertEquals(expectedType, result); [EOL] }
public void testEquals_withNonGenericArrayType() { [EOL] GenericArrayTypeImpl genericArrayType = new GenericArrayTypeImpl(String.class); [EOL] Object nonGenericArrayType = new Object(); [EOL] boolean result = genericArrayType.equals(nonGenericArrayType); [EOL] assertFalse(result); [EOL] }
public void testEquals_withGenericArrayTypeDifferentComponentType() { [EOL] GenericArrayTypeImpl genericArrayType1 = new GenericArrayTypeImpl(String.class); [EOL] GenericArrayTypeImpl genericArrayType2 = new GenericArrayTypeImpl(Integer.class); [EOL] boolean result = genericArrayType1.equals(genericArrayType2); [EOL] assertFalse(result); [EOL] }
public void testEquals_withGenericArrayTypeSameComponentType() { [EOL] GenericArrayTypeImpl genericArrayType1 = new GenericArrayTypeImpl(String.class); [EOL] GenericArrayTypeImpl genericArrayType2 = new GenericArrayTypeImpl(String.class); [EOL] boolean result = genericArrayType1.equals(genericArrayType2); [EOL] assertTrue(result); [EOL] }
public void testEquals_withGenericArrayTypeNullComponentType() { [EOL] GenericArrayTypeImpl genericArrayType1 = new GenericArrayTypeImpl(null); [EOL] GenericArrayTypeImpl genericArrayType2 = new GenericArrayTypeImpl(null); [EOL] boolean result = genericArrayType1.equals(genericArrayType2); [EOL] assertTrue(result); [EOL] }
public void testLruCacheWithValidCapacity() { [EOL] int maxCapacity = 10; [EOL] LruCache lruCache = new LruCache(maxCapacity); [EOL] assertEquals(maxCapacity, lruCache.maxCapacity); [EOL] }
public void testLruCacheWithZeroCapacity() { [EOL] int maxCapacity = 0; [EOL] LruCache lruCache = new LruCache(maxCapacity); [EOL] assertEquals(maxCapacity, lruCache.maxCapacity); [EOL] }
public void testLruCacheWithNegativeCapacity() { [EOL] int maxCapacity = -1; [EOL] try { [EOL] LruCache lruCache = new LruCache(maxCapacity); [EOL] fail("Should have thrown IllegalArgumentException for negative capacity"); [EOL] } catch (IllegalArgumentException expected) { [EOL] } [EOL] }
public void addElementTestWithNonNullKeyAndValue() { [EOL] MyMap<K, V> map = new MyMap<>(); [EOL] K key = ...; // Initialize key with a non-null value [EOL] V value = ...; // Initialize value with a non-null value [EOL] map.addElement(key, value); [EOL] V result = map.get(key); [EOL] assertEquals(value, result); [EOL] }
public void addElementTestWithNullKey() { [EOL] MyMap<K, V> map = new MyMap<>(); [EOL] K key = null; [EOL] V value = ...; // Initialize value with a non-null value [EOL] map.addElement(key, value); [EOL] V result = map.get(key); [EOL] assertEquals(value, result); [EOL] }
public void addElementTestWithNullValue() { [EOL] MyMap<K, V> map = new MyMap<>(); [EOL] K key = ...; // Initialize key with a non-null value [EOL] V value = null; [EOL] map.addElement(key, value); [EOL] V result = map.get(key); [EOL] assertNull(result); [EOL] }
public V getElement(K key) { [EOL] return get(key); [EOL] }
public void testSize_Empty() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] int size = jsonArray.size(); [EOL] assertEquals(0, size); [EOL] }
public void testSize_NonEmpty() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] jsonArray.add(new JsonPrimitive(1)); [EOL] jsonArray.add(new JsonPrimitive(2)); [EOL] jsonArray.add(new JsonPrimitive(3)); [EOL] int size = jsonArray.size(); [EOL] assertEquals(3, size); [EOL] }
public void testRemoveEldestEntry_ShouldReturnFalse_WhenSizeNotExceedingMaxCapacity() { [EOL] int maxCapacity = 5; [EOL] LinkedHashMap<Integer, Integer> map = new LinkedHashMap<Integer, Integer>() { [EOL] protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) { [EOL] return size() > maxCapacity; [EOL] } [EOL] }; [EOL] for (int i = 0; i < maxCapacity; i++) { [EOL] map.put(i, i); [EOL] } [EOL] boolean result = map.removeEldestEntry(new AbstractMap.SimpleEntry<>(0, 0)); [EOL] assertFalse(result); [EOL] }
public void testRemoveEldestEntry_ShouldReturnTrue_WhenSizeExceedingMaxCapacity() { [EOL] int maxCapacity = 5; [EOL] LinkedHashMap<Integer, Integer> map = new LinkedHashMap<Integer, Integer>() { [EOL] protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) { [EOL] return size() > maxCapacity; [EOL] } [EOL] }; [EOL] for (int i = 0; i <= maxCapacity; i++) { [EOL] map.put(i, i); [EOL] } [EOL] boolean result = map.removeEldestEntry(new AbstractMap.SimpleEntry<>(0, 0)); [EOL] assertTrue(result); [EOL] }
public void testObjectNavigatorWithNonNullParameters() { [EOL] ObjectTypePair objTypePair = new ObjectTypePair(new Object(), Object.class, false); [EOL] ExclusionStrategy exclusionStrategy = mock(ExclusionStrategy.class); [EOL] ObjectNavigator navigator = new ObjectNavigator(objTypePair, exclusionStrategy); [EOL] assertNotNull(navigator); [EOL] }
public void testObjectNavigatorWithNullExclusionStrategy() { [EOL] ObjectTypePair objTypePair = new ObjectTypePair(new Object(), Object.class, false); [EOL] try { [EOL] new ObjectNavigator(objTypePair, null); [EOL] fail("Should have thrown NullPointerException"); [EOL] } catch (NullPointerException expected) { [EOL] } [EOL] }
public void testAcceptWithExclusionStrategySkippingClass() { [EOL] Visitor visitor = mock(Visitor.class); [EOL] ExclusionStrategy exclusionStrategy = mock(ExclusionStrategy.class); [EOL] TypeInfo objTypeInfo = mock(TypeInfo.class); [EOL] ObjectTypePair objTypePair = new ObjectTypePair(null, Object.class, false); [EOL] when(objTypeInfo.getRawClass()).thenReturn(Object.class); [EOL] when(exclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(true); [EOL] JsonElementVisitor target = new JsonElementVisitor(objTypePair, exclusionStrategy); [EOL] target.accept(visitor); [EOL] verify(exclusionStrategy).shouldSkipClass(Object.class); [EOL] verify(visitor, never()).visitUsingCustomHandler(any(ObjectTypePair.class)); [EOL] }
public void testAcceptWithCustomHandler() { [EOL] Visitor visitor = mock(Visitor.class); [EOL] ExclusionStrategy exclusionStrategy = mock(ExclusionStrategy.class); [EOL] TypeInfo objTypeInfo = mock(TypeInfo.class); [EOL] ObjectTypePair objTypePair = new ObjectTypePair(null, Object.class, false); [EOL] when(objTypeInfo.getRawClass()).thenReturn(Object.class); [EOL] when(exclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(false); [EOL] when(visitor.visitUsingCustomHandler(objTypePair)).thenReturn(true); [EOL] JsonElementVisitor target = new JsonElementVisitor(objTypePair, exclusionStrategy); [EOL] target.accept(visitor); [EOL] verify(visitor).visitUsingCustomHandler(objTypePair); [EOL] verify(visitor, never()).start(any(ObjectTypePair.class)); [EOL] }
public void testAcceptWithNullObjectToVisit() { [EOL] Visitor visitor = mock(Visitor.class); [EOL] ExclusionStrategy exclusionStrategy = mock(ExclusionStrategy.class); [EOL] TypeInfo objTypeInfo = mock(TypeInfo.class); [EOL] ObjectTypePair objTypePair = new ObjectTypePair(null, Object.class, false); [EOL] when(objTypeInfo.getRawClass()).thenReturn(Object.class); [EOL] when(exclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(false); [EOL] when(visitor.visitUsingCustomHandler(objTypePair)).thenReturn(false); [EOL] when(visitor.getTarget()).thenReturn(null); [EOL] JsonElementVisitor target = new JsonElementVisitor(objTypePair, exclusionStrategy); [EOL] target.accept(visitor); [EOL] verify(visitor).getTarget(); [EOL] verify(visitor, never()).start(any(ObjectTypePair.class)); [EOL] }
public void testAcceptWithArray() { [EOL] Visitor visitor = mock(Visitor.class); [EOL] ExclusionStrategy exclusionStrategy = mock(ExclusionStrategy.class); [EOL] TypeInfo objTypeInfo = mock(TypeInfo.class); [EOL] ObjectTypePair objTypePair = new ObjectTypePair(new Object[0], Object[].class, false); [EOL] when(objTypeInfo.getRawClass()).thenReturn(Object[].class); [EOL] when(objTypeInfo.isArray()).thenReturn(true); [EOL] when(exclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(false); [EOL] when(visitor.visitUsingCustomHandler(objTypePair)).thenReturn(false); [EOL] JsonElementVisitor target = new JsonElementVisitor(objTypePair, exclusionStrategy); [EOL] target.accept(visitor); [EOL] verify(visitor).visitArray(any(), any(Class.class)); [EOL] }
public void testAcceptWithPrimitiveOrString() { [EOL] Visitor visitor = mock(Visitor.class); [EOL] ExclusionStrategy exclusionStrategy = mock(ExclusionStrategy.class); [EOL] TypeInfo objTypeInfo = mock(TypeInfo.class); [EOL] ObjectTypePair objTypePair = new ObjectTypePair("test", String.class, false); [EOL] when(objTypeInfo.getRawClass()).thenReturn(String.class); [EOL] when(objTypeInfo.getActualType()).thenReturn(Object.class); [EOL] when(exclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(false); [EOL] when(visitor.visitUsingCustomHandler(objTypePair)).thenReturn(false); [EOL] JsonElementVisitor target = new JsonElementVisitor(objTypePair, exclusionStrategy); [EOL] target.accept(visitor); [EOL] verify(visitor).visitPrimitive(any()); [EOL] }
public void testAcceptWithVisitingObject() { [EOL] Visitor visitor = mock(Visitor.class); [EOL] ExclusionStrategy exclusionStrategy = mock(ExclusionStrategy.class); [EOL] TypeInfo objTypeInfo = mock(TypeInfo.class); [EOL] ObjectTypePair objTypePair = new ObjectTypePair(new Object(), Object.class, false); [EOL] when(objTypeInfo.getRawClass()).thenReturn(Object.class); [EOL] when(objTypeInfo.getActualType()).thenReturn(Object.class); [EOL] when(exclusionStrategy.shouldSkipClass(any(Class.class))).thenReturn(false); [EOL] when(visitor.visitUsingCustomHandler(objTypePair)).thenReturn(false); [EOL] JsonElementVisitor target = new JsonElementVisitor(objTypePair, exclusionStrategy); [EOL] target.accept(visitor); [EOL] verify(visitor).startVisitingObject(any()); [EOL] verify(visitor, atLeastOnce()).end(any(ObjectTypePair.class)); [EOL] }
public void testGenerateNonExecutableJson() { [EOL] GsonBuilder gsonBuilder = new GsonBuilder(); [EOL] GsonBuilder result = gsonBuilder.generateNonExecutableJson(); [EOL] assertNotNull(result); [EOL] assertTrue(result.generateNonExecutableJson); [EOL] }
public void testSetLongSerializationPolicyWithDefault() { [EOL] GsonBuilder gsonBuilder = new GsonBuilder(); [EOL] gsonBuilder.setLongSerializationPolicy(LongSerializationPolicy.DEFAULT); [EOL] assertEquals(LongSerializationPolicy.DEFAULT, gsonBuilder.longSerializationPolicy); [EOL] }
public void testSetLongSerializationPolicyWithString() { [EOL] GsonBuilder gsonBuilder = new GsonBuilder(); [EOL] gsonBuilder.setLongSerializationPolicy(LongSerializationPolicy.STRING); [EOL] assertEquals(LongSerializationPolicy.STRING, gsonBuilder.longSerializationPolicy); [EOL] }
public void testSetFieldNamingPolicy_identity() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] GsonBuilder returnedBuilder = builder.setFieldNamingPolicy(FieldNamingPolicy.IDENTITY); [EOL] assertNotNull(returnedBuilder); [EOL] assertSame(builder, returnedBuilder); [EOL] }
public void testSetFieldNamingPolicy_upperCamelCase() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] GsonBuilder returnedBuilder = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE); [EOL] assertNotNull(returnedBuilder); [EOL] assertSame(builder, returnedBuilder); [EOL] }
public void testSetFieldNamingPolicy_upperCamelCaseSpaces() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] GsonBuilder returnedBuilder = builder.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE_WITH_SPACES); [EOL] assertNotNull(returnedBuilder); [EOL] assertSame(builder, returnedBuilder); [EOL] }
public void testSetFieldNamingPolicy_lowerCaseWithUnderscores() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] GsonBuilder returnedBuilder = builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES); [EOL] assertNotNull(returnedBuilder); [EOL] assertSame(builder, returnedBuilder); [EOL] }
public void testSetFieldNamingPolicy_lowerCaseWithDashes() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] GsonBuilder returnedBuilder = builder.setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_DASHES); [EOL] assertNotNull(returnedBuilder); [EOL] assertSame(builder, returnedBuilder); [EOL] }
public void testSetFieldNamingStrategyWithNull() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] builder.setFieldNamingStrategy(null); [EOL] assertNull(builder.create().fieldNamingStrategy()); [EOL] }
public void testSetFieldNamingStrategyWithNonNull() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] FieldNamingStrategy strategy = new FieldNamingStrategy() { [EOL] @Override [EOL] public String translateName(Field f) { [EOL] return f.getName().toUpperCase(); [EOL] } [EOL] }; [EOL] builder.setFieldNamingStrategy(strategy); [EOL] assertNotNull(builder.create().fieldNamingStrategy()); [EOL] }
public void testSetFieldNamingStrategyWithNull() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] builder.setFieldNamingStrategy(null); [EOL] assertNull(builder.fieldNamingPolicy); [EOL] }
public void testSetFieldNamingStrategyWithNonNull() { [EOL] GsonBuilder builder = new GsonBuilder(); [EOL] FieldNamingStrategy2 strategy = new SomeFieldNamingStrategy2Implementation(); [EOL] builder.setFieldNamingStrategy(strategy); [EOL] assertNotNull(builder.fieldNamingPolicy); [EOL] assertTrue(builder.fieldNamingPolicy instanceof SerializedNameAnnotationInterceptingNamingPolicy); [EOL] }
public void testIsValidSinceWithNullAnnotation() { [EOL] double version = 1.0; // Example version, adjust as necessary [EOL] MyClass myClass = new MyClass(version); [EOL] boolean result = myClass.isValidSince(null); [EOL] assert result == true; [EOL] }
public void testIsValidSinceWithAnnotationGreaterThanVersion() { [EOL] double version = 1.0; [EOL] MyClass myClass = new MyClass(version); [EOL] Since annotation = new Since(1.1); // Assuming Since is a class with a constructor that takes a double [EOL] boolean result = myClass.isValidSince(annotation); [EOL] assert result == false; [EOL] }
public void testIsValidSinceWithAnnotationEqualToVersion() { [EOL] double version = 1.0; [EOL] MyClass myClass = new MyClass(version); [EOL] Since annotation = new Since(1.0); [EOL] boolean result = myClass.isValidSince(annotation); [EOL] assert result == true; [EOL] }
public void testIsValidSinceWithAnnotationLessThanVersion() { [EOL] double version = 1.0; [EOL] MyClass myClass = new MyClass(version); [EOL] Since annotation = new Since(0.9); [EOL] boolean result = myClass.isValidSince(annotation); [EOL] assert result == true; [EOL] }
public void testHasModifierWithNoModifiers() { [EOL] int noModifiers = 0; [EOL] int testModifier = 1; [EOL] ModifierClass instance = new ModifierClass(noModifiers); [EOL] boolean result = instance.hasModifier(testModifier); [EOL] assertFalse(result); [EOL] }
public void testHasModifierWithMatchingModifier() { [EOL] int modifiers = 1; [EOL] int testModifier = 1; [EOL] ModifierClass instance = new ModifierClass(modifiers); [EOL] boolean result = instance.hasModifier(testModifier); [EOL] assertTrue(result); [EOL] }
public void testHasModifierWithNonMatchingModifier() { [EOL] int modifiers = 1; [EOL] int testModifier = 2; [EOL] ModifierClass instance = new ModifierClass(modifiers); [EOL] boolean result = instance.hasModifier(testModifier); [EOL] assertFalse(result); [EOL] }
public void testHasModifierWithMultipleModifiers() { [EOL] int modifiers = 1 | 4; // Assuming 4 is another valid modifier [EOL] int testModifier = 4; [EOL] ModifierClass instance = new ModifierClass(modifiers); [EOL] boolean result = instance.hasModifier(testModifier); [EOL] assertTrue(result); [EOL] }
public void testJsonPrimitiveWithString() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("testString"); [EOL] assertTrue(jsonPrimitive.isString()); [EOL] assertEquals("testString", jsonPrimitive.getAsString()); [EOL] }
public void testJsonPrimitiveWithBoolean() { [EOL] JsonPrimitive jsonPrimitiveTrue = new JsonPrimitive(true); [EOL] assertTrue(jsonPrimitiveTrue.isBoolean()); [EOL] assertTrue(jsonPrimitiveTrue.getAsBoolean()); [EOL] JsonPrimitive jsonPrimitiveFalse = new JsonPrimitive(false); [EOL] assertTrue(jsonPrimitiveFalse.isBoolean()); [EOL] assertFalse(jsonPrimitiveFalse.getAsBoolean()); [EOL] }
public void testJsonPrimitiveWithNumber() { [EOL] JsonPrimitive jsonPrimitiveInt = new JsonPrimitive(10); [EOL] assertTrue(jsonPrimitiveInt.isNumber()); [EOL] assertEquals(10, jsonPrimitiveInt.getAsInt()); [EOL] JsonPrimitive jsonPrimitiveDouble = new JsonPrimitive(10.5d); [EOL] assertTrue(jsonPrimitiveDouble.isNumber()); [EOL] assertEquals(10.5d, jsonPrimitiveDouble.getAsDouble(), 0.0); [EOL] }
public void testJsonPrimitiveWithCharacter() { [EOL] JsonPrimitive jsonPrimitiveChar = new JsonPrimitive('a'); [EOL] assertTrue(jsonPrimitiveChar.isString()); [EOL] assertEquals('a', jsonPrimitiveChar.getAsCharacter()); [EOL] }
public void testJsonPrimitiveHashCode() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("testString"); [EOL] int hashCode = jsonPrimitive.hashCode(); [EOL] assertNotNull(hashCode); [EOL] }
public void testJsonPrimitiveEquals() { [EOL] JsonPrimitive jsonPrimitive1 = new JsonPrimitive("testString"); [EOL] JsonPrimitive jsonPrimitive2 = new JsonPrimitive("testString"); [EOL] JsonPrimitive jsonPrimitive3 = new JsonPrimitive("differentString"); [EOL] assertTrue(jsonPrimitive1.equals(jsonPrimitive2)); [EOL] assertFalse(jsonPrimitive1.equals(jsonPrimitive3)); [EOL] assertFalse(jsonPrimitive1.equals(null)); [EOL] assertFalse(jsonPrimitive1.equals(new Object())); [EOL] }
public void testJsonPrimitiveIsIntegral() { [EOL] JsonPrimitive jsonPrimitiveInt = new JsonPrimitive(10); [EOL] assertTrue(JsonPrimitive.isIntegral(jsonPrimitiveInt)); [EOL] JsonPrimitive jsonPrimitiveDouble = new JsonPrimitive(10.5d); [EOL] assertFalse(JsonPrimitive.isIntegral(jsonPrimitiveDouble)); [EOL] }
public void testJsonPrimitiveIsFloatingPoint() { [EOL] JsonPrimitive jsonPrimitiveDouble = new JsonPrimitive(10.5d); [EOL] assertTrue(JsonPrimitive.isFloatingPoint(jsonPrimitiveDouble)); [EOL] JsonPrimitive jsonPrimitiveInt = new JsonPrimitive(10); [EOL] assertFalse(JsonPrimitive.isFloatingPoint(jsonPrimitiveInt)); [EOL] }
public void testIsNumber_withNumber() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10); [EOL] assertTrue(jsonPrimitive.isNumber()); [EOL] }
public void testIsNumber_withNonNumber() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("not a number"); [EOL] assertFalse(jsonPrimitive.isNumber()); [EOL] }
public void testIsNumber_withBoolean() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(true); [EOL] assertFalse(jsonPrimitive.isNumber()); [EOL] }
public void testIsNumber_withCharacter() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive('a'); [EOL] assertFalse(jsonPrimitive.isNumber()); [EOL] }
public void testStringToNumberWithIntRangeValue() { [EOL] Number result = JsonPrimitive.stringToNumber("12345"); [EOL] assertTrue(result instanceof Integer); [EOL] assertEquals(12345, result.intValue()); [EOL] }
public void testStringToNumberWithLongValue() { [EOL] Number result = JsonPrimitive.stringToNumber(String.valueOf(Long.MAX_VALUE)); [EOL] assertTrue(result instanceof Long); [EOL] assertEquals(Long.MAX_VALUE, result.longValue()); [EOL] }
public void testStringToNumberWithBigDecimal() { [EOL] Number result = JsonPrimitive.stringToNumber("12345.6789"); [EOL] assertTrue(result instanceof BigDecimal); [EOL] assertEquals(new BigDecimal("12345.6789"), result); [EOL] }
public void testStringToNumberWithDouble() { [EOL] Number result = JsonPrimitive.stringToNumber("1.7976931348623157E308"); [EOL] assertTrue(result instanceof Double); [EOL] assertEquals(Double.parseDouble("1.7976931348623157E308"), result.doubleValue()); [EOL] }
public void testGetAsStringWithNumber() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10); [EOL] String result = jsonPrimitive.getAsString(); [EOL] assertEquals("10", result); [EOL] }
public void testGetAsStringWithBoolean() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(true); [EOL] String result = jsonPrimitive.getAsString(); [EOL] assertEquals("true", result); [EOL] }
public void testGetAsStringWithString() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("testString"); [EOL] String result = jsonPrimitive.getAsString(); [EOL] assertEquals("testString", result); [EOL] }
public void testGetAsStringWithCharacter() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive('a'); [EOL] String result = jsonPrimitive.getAsString(); [EOL] assertEquals("a", result); [EOL] }
public void testGetAsDoubleWithNumber() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10.5); [EOL] assertEquals(10.5, jsonPrimitive.getAsDouble(), 0.0); [EOL] }
public void testGetAsDoubleWithStringRepresentingNumber() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("10.5"); [EOL] assertEquals(10.5, jsonPrimitive.getAsDouble(), 0.0); [EOL] }
public void testGetAsDoubleWithBoolean() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(true); [EOL] try { [EOL] jsonPrimitive.getAsDouble(); [EOL] fail("getAsDouble should fail for boolean values"); [EOL] } catch (NumberFormatException expected) { [EOL] } [EOL] }
public void testGetAsDoubleWithCharacter() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive('a'); [EOL] try { [EOL] jsonPrimitive.getAsDouble(); [EOL] fail("getAsDouble should fail for character values"); [EOL] } catch (NumberFormatException expected) { [EOL] } [EOL] }
public void testGetAsBigDecimal_withBigDecimal() { [EOL] BigDecimal bigDecimalValue = new BigDecimal("123.456"); [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(bigDecimalValue); [EOL] BigDecimal result = jsonPrimitive.getAsBigDecimal(); [EOL] assertEquals(bigDecimalValue, result); [EOL] }
public void testGetAsBigDecimal_withNonBigDecimalNumber() { [EOL] Double doubleValue = 123.456; [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(doubleValue); [EOL] BigDecimal result = jsonPrimitive.getAsBigDecimal(); [EOL] assertEquals(new BigDecimal(doubleValue.toString()), result); [EOL] }
public void testGetAsBigDecimal_withStringRepresentingNumber() { [EOL] String stringValue = "123.456"; [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(stringValue); [EOL] BigDecimal result = jsonPrimitive.getAsBigDecimal(); [EOL] assertEquals(new BigDecimal(stringValue), result); [EOL] }
public void testGetAsBigDecimal_withBoolean() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(true); [EOL] try { [EOL] jsonPrimitive.getAsBigDecimal(); [EOL] fail("getAsBigDecimal should fail for boolean values"); [EOL] } catch (UnsupportedOperationException expected) { [EOL] } [EOL] }
public void testGetAsBigDecimal_withCharacter() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive('a'); [EOL] try { [EOL] jsonPrimitive.getAsBigDecimal(); [EOL] fail("getAsBigDecimal should fail for character values"); [EOL] } catch (UnsupportedOperationException expected) { [EOL] } [EOL] }
public void testGetAsIntWithNumber() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(10); [EOL] int result = jsonPrimitive.getAsInt(); [EOL] assertEquals(10, result); [EOL] }
public void testGetAsIntWithStringRepresentingNumber() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("10"); [EOL] int result = jsonPrimitive.getAsInt(); [EOL] assertEquals(10, result); [EOL] }
public void testGetAsIntWithBooleanShouldThrowException() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(true); [EOL] try { [EOL] jsonPrimitive.getAsInt(); [EOL] fail("Expected NumberFormatException to be thrown"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testGetAsIntWithCharacterShouldThrowException() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive('a'); [EOL] try { [EOL] jsonPrimitive.getAsInt(); [EOL] fail("Expected NumberFormatException to be thrown"); [EOL] } catch (NumberFormatException e) { [EOL] } [EOL] }
public void testGetAsObject_withBigIntegerLessThanIntegerMax() { [EOL] BigInteger bigInteger = BigInteger.valueOf(Integer.MAX_VALUE - 1); [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(bigInteger); [EOL] Object result = jsonPrimitive.getAsObject(); [EOL] assertTrue(result instanceof Integer); [EOL] assertEquals(bigInteger.intValue(), result); [EOL] }
public void testGetAsObject_withBigIntegerEqualToIntegerMax() { [EOL] BigInteger bigInteger = BigInteger.valueOf(Integer.MAX_VALUE); [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(bigInteger); [EOL] Object result = jsonPrimitive.getAsObject(); [EOL] assertTrue(result instanceof Integer); [EOL] assertEquals(bigInteger.intValue(), result); [EOL] }
public void testGetAsObject_withBigIntegerGreaterThanIntegerMaxAndLessThanLongMax() { [EOL] BigInteger bigInteger = BigInteger.valueOf(Long.MAX_VALUE - 1); [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(bigInteger); [EOL] Object result = jsonPrimitive.getAsObject(); [EOL] assertTrue(result instanceof Long); [EOL] assertEquals(bigInteger.longValue(), result); [EOL] }
public void testGetAsObject_withBigIntegerEqualToLongMax() { [EOL] BigInteger bigInteger = BigInteger.valueOf(Long.MAX_VALUE); [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(bigInteger); [EOL] Object result = jsonPrimitive.getAsObject(); [EOL] assertTrue(result instanceof Long); [EOL] assertEquals(bigInteger.longValue(), result); [EOL] }
public void testGetAsObject_withBigIntegerGreaterThanLongMax() { [EOL] BigInteger bigInteger = BigInteger.valueOf(Long.MAX_VALUE).add(BigInteger.ONE); [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(bigInteger); [EOL] Object result = jsonPrimitive.getAsObject(); [EOL] assertTrue(result instanceof BigInteger); [EOL] assertEquals(bigInteger, result); [EOL] }
public void testGetAsObject_withNonBigIntegerValue() { [EOL] String stringValue = "test"; [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive(stringValue); [EOL] Object result = jsonPrimitive.getAsObject(); [EOL] assertTrue(result instanceof String); [EOL] assertEquals(stringValue, result); [EOL] }
private static boolean isPrimitiveOrString(Object target) { [EOL] if (target instanceof String) { [EOL] return true; [EOL] } [EOL] Class<?> classOfPrimitive = target.getClass(); [EOL] for (Class<?> standardPrimitive : PRIMITIVE_TYPES) { [EOL] if (standardPrimitive.isAssignableFrom(classOfPrimitive)) { [EOL] return true; [EOL] } [EOL] } [EOL] return false; [EOL] }
private LongSerializationPolicy(Strategy strategy) { [EOL] this.strategy = strategy; [EOL] }
public void testSerializeWithNullValue() { [EOL] Long value = null; [EOL] JsonElement result = serialize(value); [EOL] assertNull(result); [EOL] }
public void testSerializeWithNonNullValue() { [EOL] Long value = 123L; [EOL] JsonElement result = serialize(value); [EOL] assertNotNull(result); [EOL] assertTrue(result.isJsonPrimitive()); [EOL] assertEquals("123", result.getAsString()); [EOL] }
public void testIsJsonArray_WithJsonArrayInstance() { [EOL] JsonElement element = new JsonArray(); [EOL] assertTrue(element.isJsonArray()); [EOL] }
public void testIsJsonArray_WithNonJsonArrayInstance() { [EOL] JsonElement element = new JsonObject(); [EOL] assertFalse(element.isJsonArray()); [EOL] }
public void testIsJsonObject_WithJsonObjectInstance_ShouldReturnTrue() { [EOL] JsonElement jsonElement = new JsonObject(); [EOL] boolean result = jsonElement.isJsonObject(); [EOL] assert result; [EOL] }
public void testIsJsonObject_WithNonJsonObjectInstance_ShouldReturnFalse() { [EOL] JsonElement jsonElement = new JsonPrimitive("test"); [EOL] boolean result = jsonElement.isJsonObject(); [EOL] assert !result; [EOL] }
public void testIsJsonPrimitive_WithJsonPrimitive() { [EOL] JsonElement element = new JsonPrimitive("Test String"); [EOL] assertTrue(element.isJsonPrimitive()); [EOL] }
public void testIsJsonPrimitive_WithJsonObject() { [EOL] JsonElement element = new JsonObject(); [EOL] assertFalse(element.isJsonPrimitive()); [EOL] }
public void testIsJsonPrimitive_WithJsonArray() { [EOL] JsonElement element = new JsonArray(); [EOL] assertFalse(element.isJsonPrimitive()); [EOL] }
public void testIsJsonPrimitive_WithJsonNull() { [EOL] JsonElement element = JsonNull.INSTANCE; [EOL] assertFalse(element.isJsonPrimitive()); [EOL] }
public void testIsJsonNull_WithJsonNullInstance() { [EOL] JsonElement jsonNull = JsonNull.INSTANCE; [EOL] assertTrue(jsonNull.isJsonNull()); [EOL] }
public void testIsJsonNull_WithNonJsonNullInstance() { [EOL] JsonElement jsonObject = new JsonObject(); [EOL] assertFalse(jsonObject.isJsonNull()); [EOL] }
public void testGetAsJsonArray_WhenIsJsonArray() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] JsonArray result = jsonArray.getAsJsonArray(); [EOL] assertNotNull(result); [EOL] assertSame(jsonArray, result); [EOL] }
public void testGetAsJsonArray_WhenIsNotJsonArray() { [EOL] JsonElement jsonElement = new JsonPrimitive("test"); [EOL] try { [EOL] jsonElement.getAsJsonArray(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("This is not a JSON Array.", e.getMessage()); [EOL] } [EOL] }
public void testGetAsJsonPrimitive_WhenIsJsonPrimitive() { [EOL] JsonPrimitive jsonPrimitive = new JsonPrimitive("test"); [EOL] JsonPrimitive result = jsonPrimitive.getAsJsonPrimitive(); [EOL] assertEquals(jsonPrimitive, result); [EOL] } [EOL] public void testGetAsJsonPrimitive_WhenNotJsonPrimitive() { [EOL] JsonArray jsonArray = new JsonArray(); [EOL] try { [EOL] jsonArray.getAsJsonPrimitive(); [EOL] fail("Expected IllegalStateException"); [EOL] } catch (IllegalStateException e) { [EOL] assertEquals("This is not a JSON Primitive.", e.getMessage()); [EOL] } [EOL] }
public void testObjectTypePairWithNonNullValues() { [EOL] Object obj = new Object(); [EOL] Type type = Object.class; [EOL] boolean preserveType = true; [EOL] ObjectTypePair objectTypePair = new ObjectTypePair(obj, type, preserveType); [EOL] assertNotNull(objectTypePair.obj); [EOL] assertEquals(type, objectTypePair.type); [EOL] assertTrue(objectTypePair.preserveType); [EOL] }
public void testObjectTypePairWithNullValues() { [EOL] Object obj = null; [EOL] Type type = null; [EOL] boolean preserveType = false; [EOL] ObjectTypePair objectTypePair = new ObjectTypePair(obj, type, preserveType); [EOL] assertNull(objectTypePair.obj); [EOL] assertNull(objectTypePair.type); [EOL] assertFalse(objectTypePair.preserveType); [EOL] }
public void testGetObjectWhenObjIsNull() { [EOL] MyClass myClass = new MyClass(); [EOL] assertNull("Object should be null", myClass.getObject()); [EOL] }
public void testGetObjectWhenObjIsNotNull() { [EOL] MyClass myClass = new MyClass(); [EOL] Object expectedObj = new Object(); [EOL] myClass.setObject(expectedObj); [EOL] assertSame("Object should be the same as the one set", expectedObj, myClass.getObject()); [EOL] }
public void testGetType() { [EOL] MyClass instance = new MyClass(); [EOL] Type expected = /* some type */; [EOL] instance.setType(expected); [EOL] Type result = instance.getType(); [EOL] assertEquals(expected, result); [EOL] }
public void testToString() { [EOL] MyClass instance = new MyClass(true, "MyType", new Object()); [EOL] String expected = "preserveType: true, type: MyType, obj: java.lang.Object@"; [EOL] String result = instance.toString(); [EOL] assertTrue(result.startsWith(expected)); [EOL] }
public void testToStringWithNullType() { [EOL] MyClass instance = new MyClass(true, null, new Object()); [EOL] String expected = "preserveType: true, type: null, obj: java.lang.Object@"; [EOL] String result = instance.toString(); [EOL] assertTrue(result.startsWith(expected)); [EOL] }
public void testToStringWithNullObject() { [EOL] MyClass instance = new MyClass(true, "MyType", null); [EOL] String expected = "preserveType: true, type: MyType, obj: null"; [EOL] assertEquals(expected, instance.toString()); [EOL] }
public void testToStringWithFalsePreserveType() { [EOL] MyClass instance = new MyClass(false, "MyType", new Object()); [EOL] String expected = "preserveType: false, type: MyType, obj: java.lang.Object@"; [EOL] String result = instance.toString(); [EOL] assertTrue(result.startsWith(expected)); [EOL] }
public void testGetMatchingHandlerWithNonNullObjectAndPreserveTypeFalse() { [EOL] ParameterizedTypeHandlerMap<SomeHandler> handlers = new ParameterizedTypeHandlerMap<>(); [EOL] SomeHandler expectedHandler = new SomeHandler(); [EOL] handlers.register(SomeType.class, expectedHandler); [EOL] ObjectTypePair<SomeType> objectTypePair = new ObjectTypePair<>(new SomeType(), SomeType.class, false); [EOL] Pair<SomeHandler, ObjectTypePair> result = objectTypePair.getMatchingHandler(handlers); [EOL] assertNotNull(result); [EOL] assertSame(expectedHandler, result.first); [EOL] assertNotNull(result.second); [EOL] }
public void testGetMatchingHandlerWithNonNullObjectAndPreserveTypeTrue() { [EOL] ParameterizedTypeHandlerMap<SomeHandler> handlers = new ParameterizedTypeHandlerMap<>(); [EOL] SomeHandler expectedHandler = new SomeHandler(); [EOL] handlers.register(SomeType.class, expectedHandler); [EOL] ObjectTypePair<SomeType> objectTypePair = new ObjectTypePair<>(new SomeType(), SomeType.class, true); [EOL] Pair<SomeHandler, ObjectTypePair> result = objectTypePair.getMatchingHandler(handlers); [EOL] assertNotNull(result); [EOL] assertSame(expectedHandler, result.first); [EOL] assertSame(objectTypePair, result.second); [EOL] }
public void testGetMatchingHandlerWithNullObject() { [EOL] ParameterizedTypeHandlerMap<SomeHandler> handlers = new ParameterizedTypeHandlerMap<>(); [EOL] SomeHandler expectedHandler = new SomeHandler(); [EOL] handlers.register(SomeType.class, expectedHandler); [EOL] ObjectTypePair<SomeType> objectTypePair = new ObjectTypePair<>(null, SomeType.class, false); [EOL] Pair<SomeHandler, ObjectTypePair> result = objectTypePair.getMatchingHandler(handlers); [EOL] assertNotNull(result); [EOL] assertSame(expectedHandler, result.first); [EOL] assertSame(objectTypePair, result.second); [EOL] }
public void testGetMatchingHandlerWithNoHandlerRegistered() { [EOL] ParameterizedTypeHandlerMap<SomeHandler> handlers = new ParameterizedTypeHandlerMap<>(); [EOL] ObjectTypePair<SomeType> objectTypePair = new ObjectTypePair<>(new SomeType(), SomeType.class, false); [EOL] Pair<SomeHandler, ObjectTypePair> result = objectTypePair.getMatchingHandler(handlers); [EOL] assertNull(result); [EOL] }
public void testAddPropertyWithNullValue() { [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.addProperty("testProperty", (String) null); [EOL] assertTrue(jsonObject.has("testProperty")); [EOL] JsonElement element = jsonObject.get("testProperty"); [EOL] assertTrue(element.isJsonNull()); [EOL] }
public void testAddPropertyWithNonNullValue() { [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.addProperty("testProperty", "testValue"); [EOL] assertTrue(jsonObject.has("testProperty")); [EOL] JsonElement element = jsonObject.get("testProperty"); [EOL] assertTrue(element.isJsonPrimitive()); [EOL] assertEquals("testValue", element.getAsString()); [EOL] }
public void addProperty_withNullKey_shouldThrowNullPointerException() { [EOL] JsonElement jsonElement = new JsonElement(); [EOL] try { [EOL] jsonElement.addProperty(null, 'a'); [EOL] fail("Expected NullPointerException to be thrown"); [EOL] } catch (NullPointerException e) { [EOL] } [EOL] }
public void addProperty_withNonNullKeyAndNullValue_shouldAddNullProperty() { [EOL] JsonElement jsonElement = new JsonElement(); [EOL] jsonElement.addProperty("testKey", null); [EOL] assertTrue(jsonElement.has("testKey")); [EOL] assertTrue(jsonElement.get("testKey").isJsonNull()); [EOL] }
public void addProperty_withNonNullKeyAndNonNullValue_shouldAddProperty() { [EOL] JsonElement jsonElement = new JsonElement(); [EOL] jsonElement.addProperty("testKey", 'a'); [EOL] assertTrue(jsonElement.has("testKey")); [EOL] assertEquals('a', jsonElement.get("testKey").getAsCharacter()); [EOL] }
public void testToStringWithEmptyObject() throws IOException { [EOL] Appendable sb = new StringBuilder(); [EOL] Escaper escaper = new Escaper(true); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.toString(sb, escaper); [EOL] assertEquals("{}", sb.toString()); [EOL] }
public void testToStringWithSingleElement() throws IOException { [EOL] Appendable sb = new StringBuilder(); [EOL] Escaper escaper = new Escaper(true); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.add("key", new JsonPrimitive("value")); [EOL] jsonObject.toString(sb, escaper); [EOL] assertEquals("{\"key\":\"value\"}", sb.toString()); [EOL] }
public void testToStringWithMultipleElements() throws IOException { [EOL] Appendable sb = new StringBuilder(); [EOL] Escaper escaper = new Escaper(true); [EOL] JsonObject jsonObject = new JsonObject(); [EOL] jsonObject.add("key1", new JsonPrimitive("value1")); [EOL] jsonObject.add("key2", new JsonPrimitive("value2")); [EOL] jsonObject.toString(sb, escaper); [EOL] assertEquals("{\"key1\":\"value1\",\"key2\":\"value2\"}", sb.toString()); [EOL] }
