protected int indexOf(DurationFieldType type) { [EOL]     for (int i = 0, isize = size(); i < isize; i++) { [EOL]         if (getFieldType(i).getDurationType() == type) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public int compareTo(ReadablePartial other) { [EOL]     if (this == other) { [EOL]         return 0; [EOL]     } [EOL]     if (size() != other.size()) { [EOL]         throw new ClassCastException("ReadablePartial objects must have matching field types"); [EOL]     } [EOL]     for (int i = 0, isize = size(); i < isize; i++) { [EOL]         if (getFieldType(i) != other.getFieldType(i)) { [EOL]             throw new ClassCastException("ReadablePartial objects must have matching field types"); [EOL]         } [EOL]     } [EOL]     for (int i = 0, isize = size(); i < isize; i++) { [EOL]         if (getValue(i) > other.getValue(i)) { [EOL]             return 1; [EOL]         } [EOL]         if (getValue(i) < other.getValue(i)) { [EOL]             return -1; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
public int compareTo(ReadablePartial other) { [EOL]     if (this == other) { [EOL]         return 0; [EOL]     } [EOL]     if (size() != other.size()) { [EOL]         throw new ClassCastException("ReadablePartial objects must have matching field types"); [EOL]     } [EOL]     for (int i = 0, isize = size(); i < isize; i++) { [EOL]         if (getFieldType(i) != other.getFieldType(i)) { [EOL]             throw new ClassCastException("ReadablePartial objects must have matching field types"); [EOL]         } [EOL]     } [EOL]     for (int i = 0, isize = size(); i < isize; i++) { [EOL]         if (getValue(i) > other.getValue(i)) { [EOL]             return 1; [EOL]         } [EOL]         if (getValue(i) < other.getValue(i)) { [EOL]             return -1; [EOL]         } [EOL]     } [EOL]     return 0; [EOL] }
public boolean isAfter(ReadablePartial partial) { [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("Partial cannot be null"); [EOL]     } [EOL]     return compareTo(partial) > 0; [EOL] }
public boolean isAfter(ReadablePartial partial) { [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("Partial cannot be null"); [EOL]     } [EOL]     return compareTo(partial) > 0; [EOL] }
public boolean isAfter(ReadablePartial partial) { [EOL]     if (partial == null) { [EOL]         throw new IllegalArgumentException("Partial cannot be null"); [EOL]     } [EOL]     return compareTo(partial) > 0; [EOL] }
public YearMonthDay(int year, int monthOfYear, int dayOfMonth) { [EOL]     this(year, monthOfYear, dayOfMonth, null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(int year, int monthOfYear, int dayOfMonth) { [EOL]     this(year, monthOfYear, dayOfMonth, null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(int year, int monthOfYear, int dayOfMonth) { [EOL]     this(year, monthOfYear, dayOfMonth, null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(int year, int monthOfYear, int dayOfMonth) { [EOL]     this(year, monthOfYear, dayOfMonth, null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(int year, int monthOfYear, int dayOfMonth) { [EOL]     this(year, monthOfYear, dayOfMonth, null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology) { [EOL]     super(new int[] { year, monthOfYear, dayOfMonth }, chronology); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology) { [EOL]     super(new int[] { year, monthOfYear, dayOfMonth }, chronology); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology) { [EOL]     super(new int[] { year, monthOfYear, dayOfMonth }, chronology); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology) { [EOL]     super(new int[] { year, monthOfYear, dayOfMonth }, chronology); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology) { [EOL]     super(new int[] { year, monthOfYear, dayOfMonth }, chronology); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology) { [EOL]     super(new int[] { year, monthOfYear, dayOfMonth }, chronology); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology) { [EOL]     super(new int[] { year, monthOfYear, dayOfMonth }, chronology); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology) { [EOL]     super(new int[] { year, monthOfYear, dayOfMonth }, chronology); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology) { [EOL]     super(new int[] { year, monthOfYear, dayOfMonth }, chronology); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay withField(DateTimeFieldType fieldType, int value) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new YearMonthDay(this, newValues); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay withField(DateTimeFieldType fieldType, int value) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new YearMonthDay(this, newValues); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay withField(DateTimeFieldType fieldType, int value) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new YearMonthDay(this, newValues); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay plusDays(int days) { [EOL]     return withFieldAdded(DurationFieldType.days(), days); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay plusDays(int days) { [EOL]     return withFieldAdded(DurationFieldType.days(), days); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay plusDays(int days) { [EOL]     return withFieldAdded(DurationFieldType.days(), days); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay plusDays(int days) { [EOL]     return withFieldAdded(DurationFieldType.days(), days); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay plusDays(int days) { [EOL]     return withFieldAdded(DurationFieldType.days(), days); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTime toDateTimeAtMidnight() { [EOL]     return toDateTimeAtMidnight(null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTime toDateTimeAtMidnight() { [EOL]     return toDateTimeAtMidnight(null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTime toDateTimeAtMidnight() { [EOL]     return toDateTimeAtMidnight(null); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public Property dayOfMonth() { [EOL]     return new Property(this, DAY_OF_MONTH); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public Property dayOfMonth() { [EOL]     return new Property(this, DAY_OF_MONTH); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public Property dayOfMonth() { [EOL]     return new Property(this, DAY_OF_MONTH); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
protected ReadablePartial getReadablePartial() { [EOL]     return iYearMonthDay; [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay getYearMonthDay() { [EOL]     return iYearMonthDay; [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay getYearMonthDay() { [EOL]     return iYearMonthDay; [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay getYearMonthDay() { [EOL]     return iYearMonthDay; [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay getYearMonthDay() { [EOL]     return iYearMonthDay; [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay getYearMonthDay() { [EOL]     return iYearMonthDay; [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay getYearMonthDay() { [EOL]     return iYearMonthDay; [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay getYearMonthDay() { [EOL]     return iYearMonthDay; [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay getYearMonthDay() { [EOL]     return iYearMonthDay; [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay getYearMonthDay() { [EOL]     return iYearMonthDay; [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay getYearMonthDay() { [EOL]     return iYearMonthDay; [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay getYearMonthDay() { [EOL]     return iYearMonthDay; [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay getYearMonthDay() { [EOL]     return iYearMonthDay; [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay getYearMonthDay() { [EOL]     return iYearMonthDay; [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public YearMonthDay addWrapFieldToCopy(int valueToAdd) { [EOL]     int[] newValues = iYearMonthDay.getValues(); [EOL]     newValues = getField().addWrapField(iYearMonthDay, iFieldIndex, newValues, valueToAdd); [EOL]     return new YearMonthDay(iYearMonthDay, newValues); [EOL] } public YearMonthDay(); public YearMonthDay(DateTimeZone zone); public YearMonthDay(Chronology chronology); public YearMonthDay(long instant); public YearMonthDay(long instant, Chronology chronology); public YearMonthDay(Object instant); public YearMonthDay(Object instant, Chronology chronology); public YearMonthDay(int year, int monthOfYear, int dayOfMonth); public YearMonthDay(int year, int monthOfYear, int dayOfMonth, Chronology chronology);  YearMonthDay(YearMonthDay partial, int[] values);  YearMonthDay(YearMonthDay partial, Chronology chrono);  Property(YearMonthDay partial, int fieldIndex); public static YearMonthDay fromCalendarFields(Calendar calendar); public static YearMonthDay fromDateFields(Date date); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonthDay withChronologyRetainFields(Chronology newChronology); public YearMonthDay withField(DateTimeFieldType fieldType, int value); public YearMonthDay withFieldAdded(DurationFieldType fieldType, int amount); public YearMonthDay withPeriodAdded(ReadablePeriod period, int scalar); public YearMonthDay plus(ReadablePeriod period); public YearMonthDay plusYears(int years); public YearMonthDay plusMonths(int months); public YearMonthDay plusDays(int days); public YearMonthDay minus(ReadablePeriod period); public YearMonthDay minusYears(int years); public YearMonthDay minusMonths(int months); public YearMonthDay minusDays(int days); public Property property(DateTimeFieldType type); public LocalDate toLocalDate(); public DateTime toDateTimeAtMidnight(); public DateTime toDateTimeAtMidnight(DateTimeZone zone); public DateTime toDateTimeAtCurrentTime(); public DateTime toDateTimeAtCurrentTime(DateTimeZone zone); public DateMidnight toDateMidnight(); public DateMidnight toDateMidnight(DateTimeZone zone); public DateTime toDateTime(TimeOfDay time); public DateTime toDateTime(TimeOfDay time, DateTimeZone zone); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public int getDayOfMonth(); public YearMonthDay withYear(int year); public YearMonthDay withMonthOfYear(int monthOfYear); public YearMonthDay withDayOfMonth(int dayOfMonth); public Property year(); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonthDay getYearMonthDay(); public int get(); public YearMonthDay addToCopy(int valueToAdd); public YearMonthDay addWrapFieldToCopy(int valueToAdd); public YearMonthDay setCopy(int value); public YearMonthDay setCopy(String text, Locale locale); public YearMonthDay setCopy(String text); public YearMonthDay withMaximumValue(); public YearMonthDay withMinimumValue(); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public Period(long duration, Chronology chronology) { [EOL]     super(duration, null, chronology); [EOL] }
public Period(long duration, Chronology chronology) { [EOL]     super(duration, null, chronology); [EOL] }
public Period(long startInstant, long endInstant) { [EOL]     super(startInstant, endInstant, null, null); [EOL] }
public Period(long startInstant, long endInstant) { [EOL]     super(startInstant, endInstant, null, null); [EOL] }
public Period(long startInstant, long endInstant, PeriodType type) { [EOL]     super(startInstant, endInstant, type, null); [EOL] }
public Period(long startInstant, long endInstant, PeriodType type, Chronology chrono) { [EOL]     super(startInstant, endInstant, type, chrono); [EOL] }
public Period(long startInstant, long endInstant, PeriodType type, Chronology chrono) { [EOL]     super(startInstant, endInstant, type, chrono); [EOL] }
public Period(long startInstant, long endInstant, PeriodType type, Chronology chrono) { [EOL]     super(startInstant, endInstant, type, chrono); [EOL] }
public Period withPeriodType(PeriodType type) { [EOL]     type = DateTimeUtils.getPeriodType(type); [EOL]     if (type.equals(getPeriodType())) { [EOL]         return this; [EOL]     } [EOL]     return new Period(this, type); [EOL] }
public Period withPeriodType(PeriodType type) { [EOL]     type = DateTimeUtils.getPeriodType(type); [EOL]     if (type.equals(getPeriodType())) { [EOL]         return this; [EOL]     } [EOL]     return new Period(this, type); [EOL] }
public Period withFields(ReadablePeriod period) { [EOL]     if (period == null) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = super.mergePeriodInto(newValues, period); [EOL]     return new Period(newValues, getPeriodType()); [EOL] }
public Period withFields(ReadablePeriod period) { [EOL]     if (period == null) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = super.mergePeriodInto(newValues, period); [EOL]     return new Period(newValues, getPeriodType()); [EOL] }
public Period withFieldAdded(DurationFieldType field, int value) { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (value == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     super.addFieldInto(newValues, field, value); [EOL]     return new Period(newValues, getPeriodType()); [EOL] }
public Period withFieldAdded(DurationFieldType field, int value) { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (value == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     super.addFieldInto(newValues, field, value); [EOL]     return new Period(newValues, getPeriodType()); [EOL] }
public Period withFieldAdded(DurationFieldType field, int value) { [EOL]     if (field == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (value == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     super.addFieldInto(newValues, field, value); [EOL]     return new Period(newValues, getPeriodType()); [EOL] }
public Period plusYears(int years) { [EOL]     if (years == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] values = getValues(); [EOL]     getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, years); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period plusYears(int years) { [EOL]     if (years == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] values = getValues(); [EOL]     getPeriodType().addIndexedField(this, PeriodType.YEAR_INDEX, values, years); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period plusMonths(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] values = getValues(); [EOL]     getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, months); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period plusMonths(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] values = getValues(); [EOL]     getPeriodType().addIndexedField(this, PeriodType.MONTH_INDEX, values, months); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period plusWeeks(int weeks) { [EOL]     if (weeks == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] values = getValues(); [EOL]     getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, weeks); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period plusWeeks(int weeks) { [EOL]     if (weeks == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] values = getValues(); [EOL]     getPeriodType().addIndexedField(this, PeriodType.WEEK_INDEX, values, weeks); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period plusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] values = getValues(); [EOL]     getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, days); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period plusDays(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] values = getValues(); [EOL]     getPeriodType().addIndexedField(this, PeriodType.DAY_INDEX, values, days); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period plusHours(int hours) { [EOL]     if (hours == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] values = getValues(); [EOL]     getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, hours); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period plusHours(int hours) { [EOL]     if (hours == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] values = getValues(); [EOL]     getPeriodType().addIndexedField(this, PeriodType.HOUR_INDEX, values, hours); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period plusMinutes(int minutes) { [EOL]     if (minutes == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] values = getValues(); [EOL]     getPeriodType().addIndexedField(this, PeriodType.MINUTE_INDEX, values, minutes); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period plusSeconds(int seconds) { [EOL]     if (seconds == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] values = getValues(); [EOL]     getPeriodType().addIndexedField(this, PeriodType.SECOND_INDEX, values, seconds); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Period plusMillis(int millis) { [EOL]     if (millis == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] values = getValues(); [EOL]     getPeriodType().addIndexedField(this, PeriodType.MILLI_INDEX, values, millis); [EOL]     return new Period(values, getPeriodType()); [EOL] }
public Days toStandardDays() { [EOL]     checkYearsAndMonths("Days"); [EOL]     long millis = getMillis(); [EOL]     millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     long days = millis / DateTimeConstants.MILLIS_PER_DAY; [EOL]     days = FieldUtils.safeAdd(days, getDays()); [EOL]     days = FieldUtils.safeAdd(days, ((long) getWeeks()) * ((long) DateTimeConstants.DAYS_PER_WEEK)); [EOL]     return Days.days(FieldUtils.safeToInt(days)); [EOL] }
public Days toStandardDays() { [EOL]     checkYearsAndMonths("Days"); [EOL]     long millis = getMillis(); [EOL]     millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     long days = millis / DateTimeConstants.MILLIS_PER_DAY; [EOL]     days = FieldUtils.safeAdd(days, getDays()); [EOL]     days = FieldUtils.safeAdd(days, ((long) getWeeks()) * ((long) DateTimeConstants.DAYS_PER_WEEK)); [EOL]     return Days.days(FieldUtils.safeToInt(days)); [EOL] }
public Days toStandardDays() { [EOL]     checkYearsAndMonths("Days"); [EOL]     long millis = getMillis(); [EOL]     millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     long days = millis / DateTimeConstants.MILLIS_PER_DAY; [EOL]     days = FieldUtils.safeAdd(days, getDays()); [EOL]     days = FieldUtils.safeAdd(days, ((long) getWeeks()) * ((long) DateTimeConstants.DAYS_PER_WEEK)); [EOL]     return Days.days(FieldUtils.safeToInt(days)); [EOL] }
public Days toStandardDays() { [EOL]     checkYearsAndMonths("Days"); [EOL]     long millis = getMillis(); [EOL]     millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     long days = millis / DateTimeConstants.MILLIS_PER_DAY; [EOL]     days = FieldUtils.safeAdd(days, getDays()); [EOL]     days = FieldUtils.safeAdd(days, ((long) getWeeks()) * ((long) DateTimeConstants.DAYS_PER_WEEK)); [EOL]     return Days.days(FieldUtils.safeToInt(days)); [EOL] }
public Days toStandardDays() { [EOL]     checkYearsAndMonths("Days"); [EOL]     long millis = getMillis(); [EOL]     millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     long days = millis / DateTimeConstants.MILLIS_PER_DAY; [EOL]     days = FieldUtils.safeAdd(days, getDays()); [EOL]     days = FieldUtils.safeAdd(days, ((long) getWeeks()) * ((long) DateTimeConstants.DAYS_PER_WEEK)); [EOL]     return Days.days(FieldUtils.safeToInt(days)); [EOL] }
public Days toStandardDays() { [EOL]     checkYearsAndMonths("Days"); [EOL]     long millis = getMillis(); [EOL]     millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     long days = millis / DateTimeConstants.MILLIS_PER_DAY; [EOL]     days = FieldUtils.safeAdd(days, getDays()); [EOL]     days = FieldUtils.safeAdd(days, ((long) getWeeks()) * ((long) DateTimeConstants.DAYS_PER_WEEK)); [EOL]     return Days.days(FieldUtils.safeToInt(days)); [EOL] }
public Days toStandardDays() { [EOL]     checkYearsAndMonths("Days"); [EOL]     long millis = getMillis(); [EOL]     millis += ((long) getSeconds()) * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     millis += ((long) getMinutes()) * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     millis += ((long) getHours()) * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     long days = millis / DateTimeConstants.MILLIS_PER_DAY; [EOL]     days = FieldUtils.safeAdd(days, getDays()); [EOL]     days = FieldUtils.safeAdd(days, ((long) getWeeks()) * ((long) DateTimeConstants.DAYS_PER_WEEK)); [EOL]     return Days.days(FieldUtils.safeToInt(days)); [EOL] }
public static IslamicChronology getInstance(DateTimeZone zone) { [EOL]     return getInstance(zone, LEAP_YEAR_16_BASED); [EOL] }
public static IslamicChronology getInstance(DateTimeZone zone) { [EOL]     return getInstance(zone, LEAP_YEAR_16_BASED); [EOL] }
public static IslamicChronology getInstance(DateTimeZone zone, LeapYearPatternType leapYears) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     IslamicChronology chrono; [EOL]     synchronized (cCache) { [EOL]         IslamicChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new IslamicChronology[4]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         chrono = chronos[leapYears.index]; [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new IslamicChronology(null, null, leapYears); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new IslamicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, leapYears); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, leapYears); [EOL]                 chrono = new IslamicChronology(ZonedChronology.getInstance(chrono, zone), null, leapYears); [EOL]             } [EOL]             chronos[leapYears.index] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static IslamicChronology getInstance(DateTimeZone zone, LeapYearPatternType leapYears) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     IslamicChronology chrono; [EOL]     synchronized (cCache) { [EOL]         IslamicChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new IslamicChronology[4]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         chrono = chronos[leapYears.index]; [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new IslamicChronology(null, null, leapYears); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new IslamicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, leapYears); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, leapYears); [EOL]                 chrono = new IslamicChronology(ZonedChronology.getInstance(chrono, zone), null, leapYears); [EOL]             } [EOL]             chronos[leapYears.index] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static IslamicChronology getInstance(DateTimeZone zone, LeapYearPatternType leapYears) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     IslamicChronology chrono; [EOL]     synchronized (cCache) { [EOL]         IslamicChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new IslamicChronology[4]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         chrono = chronos[leapYears.index]; [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new IslamicChronology(null, null, leapYears); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new IslamicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, leapYears); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, leapYears); [EOL]                 chrono = new IslamicChronology(ZonedChronology.getInstance(chrono, zone), null, leapYears); [EOL]             } [EOL]             chronos[leapYears.index] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
IslamicChronology(Chronology base, Object param, LeapYearPatternType leapYears) { [EOL]     super(base, param, 4); [EOL]     this.iLeapYears = leapYears; [EOL] }
IslamicChronology(Chronology base, Object param, LeapYearPatternType leapYears) { [EOL]     super(base, param, 4); [EOL]     this.iLeapYears = leapYears; [EOL] }
IslamicChronology(Chronology base, Object param, LeapYearPatternType leapYears) { [EOL]     super(base, param, 4); [EOL]     this.iLeapYears = leapYears; [EOL] }
public Chronology withUTC() { [EOL]     return INSTANCE_UTC; [EOL] }
public Chronology withZone(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     if (zone == getZone()) { [EOL]         return this; [EOL]     } [EOL]     return getInstance(zone); [EOL] }
public Chronology withZone(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     if (zone == getZone()) { [EOL]         return this; [EOL]     } [EOL]     return getInstance(zone); [EOL] }
public Chronology withZone(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     if (zone == getZone()) { [EOL]         return this; [EOL]     } [EOL]     return getInstance(zone); [EOL] }
protected void assemble(Fields fields) { [EOL]     if (getBase() == null) { [EOL]         super.assemble(fields); [EOL]         fields.era = ERA_FIELD; [EOL]         fields.monthOfYear = new BasicMonthOfYearDateTimeField(this, 12); [EOL]         fields.months = fields.monthOfYear.getDurationField(); [EOL]     } [EOL] }
public static GJChronology getInstance(DateTimeZone zone, ReadableInstant gregorianCutover) { [EOL]     return getInstance(zone, gregorianCutover, 4); [EOL] }
public static GJChronology getInstance(DateTimeZone zone, ReadableInstant gregorianCutover) { [EOL]     return getInstance(zone, gregorianCutover, 4); [EOL] }
public static GJChronology getInstance(DateTimeZone zone, ReadableInstant gregorianCutover) { [EOL]     return getInstance(zone, gregorianCutover, 4); [EOL] }
public static GJChronology getInstance(DateTimeZone zone, ReadableInstant gregorianCutover) { [EOL]     return getInstance(zone, gregorianCutover, 4); [EOL] }
public static synchronized GJChronology getInstance(DateTimeZone zone, ReadableInstant gregorianCutover, int minDaysInFirstWeek) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     Instant cutoverInstant; [EOL]     if (gregorianCutover == null) { [EOL]         cutoverInstant = DEFAULT_CUTOVER; [EOL]     } else { [EOL]         cutoverInstant = gregorianCutover.toInstant(); [EOL]         LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone)); [EOL]         if (cutoverDate.getYear() <= 0) { [EOL]             throw new IllegalArgumentException("Cutover too early. Must be on or after 0001-01-01."); [EOL]         } [EOL]     } [EOL]     GJChronology chrono; [EOL]     synchronized (cCache) { [EOL]         ArrayList<GJChronology> chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new ArrayList<GJChronology>(2); [EOL]             cCache.put(zone, chronos); [EOL]         } else { [EOL]             for (int i = chronos.size(); --i >= 0; ) { [EOL]                 chrono = chronos.get(i); [EOL]                 if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() && cutoverInstant.equals(chrono.getGregorianCutover())) { [EOL]                     return chrono; [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (zone == DateTimeZone.UTC) { [EOL]             chrono = new GJChronology(JulianChronology.getInstance(zone, minDaysInFirstWeek), GregorianChronology.getInstance(zone, minDaysInFirstWeek), cutoverInstant); [EOL]         } else { [EOL]             chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek); [EOL]             chrono = new GJChronology(ZonedChronology.getInstance(chrono, zone), chrono.iJulianChronology, chrono.iGregorianChronology, chrono.iCutoverInstant); [EOL]         } [EOL]         chronos.add(chrono); [EOL]     } [EOL]     return chrono; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     long instant; [EOL]     try { [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } catch (IllegalFieldValueException ex) { [EOL]         if (monthOfYear != 2 || dayOfMonth != 29) { [EOL]             throw ex; [EOL]         } [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw ex; [EOL]         } [EOL]     } [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     long instant; [EOL]     try { [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } catch (IllegalFieldValueException ex) { [EOL]         if (monthOfYear != 2 || dayOfMonth != 29) { [EOL]             throw ex; [EOL]         } [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw ex; [EOL]         } [EOL]     } [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     long instant; [EOL]     try { [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } catch (IllegalFieldValueException ex) { [EOL]         if (monthOfYear != 2 || dayOfMonth != 29) { [EOL]             throw ex; [EOL]         } [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw ex; [EOL]         } [EOL]     } [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     long instant; [EOL]     try { [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } catch (IllegalFieldValueException ex) { [EOL]         if (monthOfYear != 2 || dayOfMonth != 29) { [EOL]             throw ex; [EOL]         } [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw ex; [EOL]         } [EOL]     } [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     long instant; [EOL]     try { [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } catch (IllegalFieldValueException ex) { [EOL]         if (monthOfYear != 2 || dayOfMonth != 29) { [EOL]             throw ex; [EOL]         } [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw ex; [EOL]         } [EOL]     } [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     Chronology base; [EOL]     if ((base = getBase()) != null) { [EOL]         return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } [EOL]     long instant; [EOL]     try { [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     } catch (IllegalFieldValueException ex) { [EOL]         if (monthOfYear != 2 || dayOfMonth != 29) { [EOL]             throw ex; [EOL]         } [EOL]         instant = iGregorianChronology.getDateTimeMillis(year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw ex; [EOL]         } [EOL]     } [EOL]     if (instant < iCutoverMillis) { [EOL]         instant = iJulianChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]         if (instant >= iCutoverMillis) { [EOL]             throw new IllegalArgumentException("Specified date does not exist"); [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof GJChronology) { [EOL]         GJChronology chrono = (GJChronology) obj; [EOL]         return iCutoverMillis == chrono.iCutoverMillis && getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof GJChronology) { [EOL]         GJChronology chrono = (GJChronology) obj; [EOL]         return iCutoverMillis == chrono.iCutoverMillis && getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof GJChronology) { [EOL]         GJChronology chrono = (GJChronology) obj; [EOL]         return iCutoverMillis == chrono.iCutoverMillis && getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof GJChronology) { [EOL]         GJChronology chrono = (GJChronology) obj; [EOL]         return iCutoverMillis == chrono.iCutoverMillis && getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof GJChronology) { [EOL]         GJChronology chrono = (GJChronology) obj; [EOL]         return iCutoverMillis == chrono.iCutoverMillis && getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof GJChronology) { [EOL]         GJChronology chrono = (GJChronology) obj; [EOL]         return iCutoverMillis == chrono.iCutoverMillis && getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof GJChronology) { [EOL]         GJChronology chrono = (GJChronology) obj; [EOL]         return iCutoverMillis == chrono.iCutoverMillis && getMinimumDaysInFirstWeek() == chrono.getMinimumDaysInFirstWeek() && getZone().equals(chrono.getZone()); [EOL]     } [EOL]     return false; [EOL] }
public int hashCode() { [EOL]     return "GJ".hashCode() * 11 + getZone().hashCode() + getMinimumDaysInFirstWeek() + iCutoverInstant.hashCode(); [EOL] }
public int getMinimumValue() { [EOL]     return iJulianField.getMinimumValue(); [EOL] }
public int getMinimumValue(ReadablePartial partial, int[] values) { [EOL]     return iJulianField.getMinimumValue(partial, values); [EOL] }
public int getMaximumValue() { [EOL]     return iGregorianField.getMaximumValue(); [EOL] }
public int getMaximumValue(long instant) { [EOL]     if (instant >= iCutover) { [EOL]         return iGregorianField.getMaximumValue(instant); [EOL]     } [EOL]     int max = iJulianField.getMaximumValue(instant); [EOL]     instant = iJulianField.set(instant, max); [EOL]     if (instant >= iCutover) { [EOL]         max = iJulianField.get(iJulianField.add(iCutover, -1)); [EOL]     } [EOL]     return max; [EOL] }
public int getMaximumValue(long instant) { [EOL]     if (instant >= iCutover) { [EOL]         return iGregorianField.getMaximumValue(instant); [EOL]     } [EOL]     int max = iJulianField.getMaximumValue(instant); [EOL]     instant = iJulianField.set(instant, max); [EOL]     if (instant >= iCutover) { [EOL]         max = iJulianField.get(iJulianField.add(iCutover, -1)); [EOL]     } [EOL]     return max; [EOL] }
public int getMaximumValue(long instant) { [EOL]     if (instant >= iCutover) { [EOL]         return iGregorianField.getMaximumValue(instant); [EOL]     } [EOL]     int max = iJulianField.getMaximumValue(instant); [EOL]     instant = iJulianField.set(instant, max); [EOL]     if (instant >= iCutover) { [EOL]         max = iJulianField.get(iJulianField.add(iCutover, -1)); [EOL]     } [EOL]     return max; [EOL] }
public int getMaximumValue(ReadablePartial partial, int[] values) { [EOL]     Chronology chrono = GJChronology.getInstanceUTC(); [EOL]     long instant = 0L; [EOL]     for (int i = 0, isize = partial.size(); i < isize; i++) { [EOL]         DateTimeField field = partial.getFieldType(i).getField(chrono); [EOL]         if (values[i] <= field.getMaximumValue(instant)) { [EOL]             instant = field.set(instant, values[i]); [EOL]         } [EOL]     } [EOL]     return getMaximumValue(instant); [EOL] }
public long add(long instant, int value) { [EOL]     if (instant >= iCutover) { [EOL]         instant = iGregorianField.add(instant, value); [EOL]         if (instant < iCutover) { [EOL]             if (instant + iGapDuration < iCutover) { [EOL]                 if (iConvertByWeekyear) { [EOL]                     int wyear = iGregorianChronology.weekyear().get(instant); [EOL]                     if (wyear <= 0) { [EOL]                         instant = iGregorianChronology.weekyear().add(instant, -1); [EOL]                     } [EOL]                 } else { [EOL]                     int year = iGregorianChronology.year().get(instant); [EOL]                     if (year <= 0) { [EOL]                         instant = iGregorianChronology.year().add(instant, -1); [EOL]                     } [EOL]                 } [EOL]                 instant = gregorianToJulian(instant); [EOL]             } [EOL]         } [EOL]     } else { [EOL]         instant = iJulianField.add(instant, value); [EOL]         if (instant >= iCutover) { [EOL]             if (instant - iGapDuration >= iCutover) { [EOL]                 instant = julianToGregorian(instant); [EOL]             } [EOL]         } [EOL]     } [EOL]     return instant; [EOL] }
public int getMaximumValue(long instant) { [EOL]     if (instant >= iCutover) { [EOL]         return iGregorianField.getMaximumValue(instant); [EOL]     } else { [EOL]         return iJulianField.getMaximumValue(instant); [EOL]     } [EOL] }
public int getMaximumValue(long instant) { [EOL]     if (instant >= iCutover) { [EOL]         return iGregorianField.getMaximumValue(instant); [EOL]     } else { [EOL]         return iJulianField.getMaximumValue(instant); [EOL]     } [EOL] }
public int getMaximumValue(long instant) { [EOL]     if (instant >= iCutover) { [EOL]         return iGregorianField.getMaximumValue(instant); [EOL]     } else { [EOL]         return iJulianField.getMaximumValue(instant); [EOL]     } [EOL] }
public long getInstantMillis(Object object, Chronology chrono) { [EOL]     String str = (String) object; [EOL]     DateTimeFormatter p = ISODateTimeFormat.dateTimeParser(); [EOL]     return p.withChronology(chrono).parseMillis(str); [EOL] }
public long getInstantMillis(Object object, Chronology chrono) { [EOL]     String str = (String) object; [EOL]     DateTimeFormatter p = ISODateTimeFormat.dateTimeParser(); [EOL]     return p.withChronology(chrono).parseMillis(str); [EOL] }
public long getInstantMillis(Object object, Chronology chrono) { [EOL]     String str = (String) object; [EOL]     DateTimeFormatter p = ISODateTimeFormat.dateTimeParser(); [EOL]     return p.withChronology(chrono).parseMillis(str); [EOL] }
public long getDurationMillis(Object object) { [EOL]     String original = (String) object; [EOL]     String str = original; [EOL]     int len = str.length(); [EOL]     if (len >= 4 && (str.charAt(0) == 'P' || str.charAt(0) == 'p') && (str.charAt(1) == 'T' || str.charAt(1) == 't') && (str.charAt(len - 1) == 'S' || str.charAt(len - 1) == 's')) { [EOL]     } else { [EOL]         throw new IllegalArgumentException("Invalid format: \"" + original + '"'); [EOL]     } [EOL]     str = str.substring(2, len - 1); [EOL]     int dot = -1; [EOL]     boolean negative = false; [EOL]     for (int i = 0; i < str.length(); i++) { [EOL]         if (str.charAt(i) >= '0' && str.charAt(i) <= '9') { [EOL]         } else if (i == 0 && str.charAt(0) == '-') { [EOL]             negative = true; [EOL]         } else if (i > (negative ? 1 : 0) && str.charAt(i) == '.' && dot == -1) { [EOL]             dot = i; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Invalid format: \"" + original + '"'); [EOL]         } [EOL]     } [EOL]     long millis = 0, seconds = 0; [EOL]     int firstDigit = negative ? 1 : 0; [EOL]     if (dot > 0) { [EOL]         seconds = Long.parseLong(str.substring(firstDigit, dot)); [EOL]         str = str.substring(dot + 1); [EOL]         if (str.length() != 3) { [EOL]             str = (str + "000").substring(0, 3); [EOL]         } [EOL]         millis = Integer.parseInt(str); [EOL]     } else if (negative) { [EOL]         seconds = Long.parseLong(str.substring(firstDigit, str.length())); [EOL]     } else { [EOL]         seconds = Long.parseLong(str); [EOL]     } [EOL]     if (negative) { [EOL]         return FieldUtils.safeAdd(FieldUtils.safeMultiply(-seconds, 1000), -millis); [EOL]     } else { [EOL]         return FieldUtils.safeAdd(FieldUtils.safeMultiply(seconds, 1000), millis); [EOL]     } [EOL] }
public long getDurationMillis(Object object) { [EOL]     String original = (String) object; [EOL]     String str = original; [EOL]     int len = str.length(); [EOL]     if (len >= 4 && (str.charAt(0) == 'P' || str.charAt(0) == 'p') && (str.charAt(1) == 'T' || str.charAt(1) == 't') && (str.charAt(len - 1) == 'S' || str.charAt(len - 1) == 's')) { [EOL]     } else { [EOL]         throw new IllegalArgumentException("Invalid format: \"" + original + '"'); [EOL]     } [EOL]     str = str.substring(2, len - 1); [EOL]     int dot = -1; [EOL]     boolean negative = false; [EOL]     for (int i = 0; i < str.length(); i++) { [EOL]         if (str.charAt(i) >= '0' && str.charAt(i) <= '9') { [EOL]         } else if (i == 0 && str.charAt(0) == '-') { [EOL]             negative = true; [EOL]         } else if (i > (negative ? 1 : 0) && str.charAt(i) == '.' && dot == -1) { [EOL]             dot = i; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Invalid format: \"" + original + '"'); [EOL]         } [EOL]     } [EOL]     long millis = 0, seconds = 0; [EOL]     int firstDigit = negative ? 1 : 0; [EOL]     if (dot > 0) { [EOL]         seconds = Long.parseLong(str.substring(firstDigit, dot)); [EOL]         str = str.substring(dot + 1); [EOL]         if (str.length() != 3) { [EOL]             str = (str + "000").substring(0, 3); [EOL]         } [EOL]         millis = Integer.parseInt(str); [EOL]     } else if (negative) { [EOL]         seconds = Long.parseLong(str.substring(firstDigit, str.length())); [EOL]     } else { [EOL]         seconds = Long.parseLong(str); [EOL]     } [EOL]     if (negative) { [EOL]         return FieldUtils.safeAdd(FieldUtils.safeMultiply(-seconds, 1000), -millis); [EOL]     } else { [EOL]         return FieldUtils.safeAdd(FieldUtils.safeMultiply(seconds, 1000), millis); [EOL]     } [EOL] }
public long getDurationMillis(Object object) { [EOL]     String original = (String) object; [EOL]     String str = original; [EOL]     int len = str.length(); [EOL]     if (len >= 4 && (str.charAt(0) == 'P' || str.charAt(0) == 'p') && (str.charAt(1) == 'T' || str.charAt(1) == 't') && (str.charAt(len - 1) == 'S' || str.charAt(len - 1) == 's')) { [EOL]     } else { [EOL]         throw new IllegalArgumentException("Invalid format: \"" + original + '"'); [EOL]     } [EOL]     str = str.substring(2, len - 1); [EOL]     int dot = -1; [EOL]     boolean negative = false; [EOL]     for (int i = 0; i < str.length(); i++) { [EOL]         if (str.charAt(i) >= '0' && str.charAt(i) <= '9') { [EOL]         } else if (i == 0 && str.charAt(0) == '-') { [EOL]             negative = true; [EOL]         } else if (i > (negative ? 1 : 0) && str.charAt(i) == '.' && dot == -1) { [EOL]             dot = i; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Invalid format: \"" + original + '"'); [EOL]         } [EOL]     } [EOL]     long millis = 0, seconds = 0; [EOL]     int firstDigit = negative ? 1 : 0; [EOL]     if (dot > 0) { [EOL]         seconds = Long.parseLong(str.substring(firstDigit, dot)); [EOL]         str = str.substring(dot + 1); [EOL]         if (str.length() != 3) { [EOL]             str = (str + "000").substring(0, 3); [EOL]         } [EOL]         millis = Integer.parseInt(str); [EOL]     } else if (negative) { [EOL]         seconds = Long.parseLong(str.substring(firstDigit, str.length())); [EOL]     } else { [EOL]         seconds = Long.parseLong(str); [EOL]     } [EOL]     if (negative) { [EOL]         return FieldUtils.safeAdd(FieldUtils.safeMultiply(-seconds, 1000), -millis); [EOL]     } else { [EOL]         return FieldUtils.safeAdd(FieldUtils.safeMultiply(seconds, 1000), millis); [EOL]     } [EOL] }
public long getDurationMillis(Object object) { [EOL]     String original = (String) object; [EOL]     String str = original; [EOL]     int len = str.length(); [EOL]     if (len >= 4 && (str.charAt(0) == 'P' || str.charAt(0) == 'p') && (str.charAt(1) == 'T' || str.charAt(1) == 't') && (str.charAt(len - 1) == 'S' || str.charAt(len - 1) == 's')) { [EOL]     } else { [EOL]         throw new IllegalArgumentException("Invalid format: \"" + original + '"'); [EOL]     } [EOL]     str = str.substring(2, len - 1); [EOL]     int dot = -1; [EOL]     boolean negative = false; [EOL]     for (int i = 0; i < str.length(); i++) { [EOL]         if (str.charAt(i) >= '0' && str.charAt(i) <= '9') { [EOL]         } else if (i == 0 && str.charAt(0) == '-') { [EOL]             negative = true; [EOL]         } else if (i > (negative ? 1 : 0) && str.charAt(i) == '.' && dot == -1) { [EOL]             dot = i; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Invalid format: \"" + original + '"'); [EOL]         } [EOL]     } [EOL]     long millis = 0, seconds = 0; [EOL]     int firstDigit = negative ? 1 : 0; [EOL]     if (dot > 0) { [EOL]         seconds = Long.parseLong(str.substring(firstDigit, dot)); [EOL]         str = str.substring(dot + 1); [EOL]         if (str.length() != 3) { [EOL]             str = (str + "000").substring(0, 3); [EOL]         } [EOL]         millis = Integer.parseInt(str); [EOL]     } else if (negative) { [EOL]         seconds = Long.parseLong(str.substring(firstDigit, str.length())); [EOL]     } else { [EOL]         seconds = Long.parseLong(str); [EOL]     } [EOL]     if (negative) { [EOL]         return FieldUtils.safeAdd(FieldUtils.safeMultiply(-seconds, 1000), -millis); [EOL]     } else { [EOL]         return FieldUtils.safeAdd(FieldUtils.safeMultiply(seconds, 1000), millis); [EOL]     } [EOL] }
public long getDurationMillis(Object object) { [EOL]     String original = (String) object; [EOL]     String str = original; [EOL]     int len = str.length(); [EOL]     if (len >= 4 && (str.charAt(0) == 'P' || str.charAt(0) == 'p') && (str.charAt(1) == 'T' || str.charAt(1) == 't') && (str.charAt(len - 1) == 'S' || str.charAt(len - 1) == 's')) { [EOL]     } else { [EOL]         throw new IllegalArgumentException("Invalid format: \"" + original + '"'); [EOL]     } [EOL]     str = str.substring(2, len - 1); [EOL]     int dot = -1; [EOL]     boolean negative = false; [EOL]     for (int i = 0; i < str.length(); i++) { [EOL]         if (str.charAt(i) >= '0' && str.charAt(i) <= '9') { [EOL]         } else if (i == 0 && str.charAt(0) == '-') { [EOL]             negative = true; [EOL]         } else if (i > (negative ? 1 : 0) && str.charAt(i) == '.' && dot == -1) { [EOL]             dot = i; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Invalid format: \"" + original + '"'); [EOL]         } [EOL]     } [EOL]     long millis = 0, seconds = 0; [EOL]     int firstDigit = negative ? 1 : 0; [EOL]     if (dot > 0) { [EOL]         seconds = Long.parseLong(str.substring(firstDigit, dot)); [EOL]         str = str.substring(dot + 1); [EOL]         if (str.length() != 3) { [EOL]             str = (str + "000").substring(0, 3); [EOL]         } [EOL]         millis = Integer.parseInt(str); [EOL]     } else if (negative) { [EOL]         seconds = Long.parseLong(str.substring(firstDigit, str.length())); [EOL]     } else { [EOL]         seconds = Long.parseLong(str); [EOL]     } [EOL]     if (negative) { [EOL]         return FieldUtils.safeAdd(FieldUtils.safeMultiply(-seconds, 1000), -millis); [EOL]     } else { [EOL]         return FieldUtils.safeAdd(FieldUtils.safeMultiply(seconds, 1000), millis); [EOL]     } [EOL] }
public long getDurationMillis(Object object) { [EOL]     String original = (String) object; [EOL]     String str = original; [EOL]     int len = str.length(); [EOL]     if (len >= 4 && (str.charAt(0) == 'P' || str.charAt(0) == 'p') && (str.charAt(1) == 'T' || str.charAt(1) == 't') && (str.charAt(len - 1) == 'S' || str.charAt(len - 1) == 's')) { [EOL]     } else { [EOL]         throw new IllegalArgumentException("Invalid format: \"" + original + '"'); [EOL]     } [EOL]     str = str.substring(2, len - 1); [EOL]     int dot = -1; [EOL]     boolean negative = false; [EOL]     for (int i = 0; i < str.length(); i++) { [EOL]         if (str.charAt(i) >= '0' && str.charAt(i) <= '9') { [EOL]         } else if (i == 0 && str.charAt(0) == '-') { [EOL]             negative = true; [EOL]         } else if (i > (negative ? 1 : 0) && str.charAt(i) == '.' && dot == -1) { [EOL]             dot = i; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Invalid format: \"" + original + '"'); [EOL]         } [EOL]     } [EOL]     long millis = 0, seconds = 0; [EOL]     int firstDigit = negative ? 1 : 0; [EOL]     if (dot > 0) { [EOL]         seconds = Long.parseLong(str.substring(firstDigit, dot)); [EOL]         str = str.substring(dot + 1); [EOL]         if (str.length() != 3) { [EOL]             str = (str + "000").substring(0, 3); [EOL]         } [EOL]         millis = Integer.parseInt(str); [EOL]     } else if (negative) { [EOL]         seconds = Long.parseLong(str.substring(firstDigit, str.length())); [EOL]     } else { [EOL]         seconds = Long.parseLong(str); [EOL]     } [EOL]     if (negative) { [EOL]         return FieldUtils.safeAdd(FieldUtils.safeMultiply(-seconds, 1000), -millis); [EOL]     } else { [EOL]         return FieldUtils.safeAdd(FieldUtils.safeMultiply(seconds, 1000), millis); [EOL]     } [EOL] }
public long getDurationMillis(Object object) { [EOL]     String original = (String) object; [EOL]     String str = original; [EOL]     int len = str.length(); [EOL]     if (len >= 4 && (str.charAt(0) == 'P' || str.charAt(0) == 'p') && (str.charAt(1) == 'T' || str.charAt(1) == 't') && (str.charAt(len - 1) == 'S' || str.charAt(len - 1) == 's')) { [EOL]     } else { [EOL]         throw new IllegalArgumentException("Invalid format: \"" + original + '"'); [EOL]     } [EOL]     str = str.substring(2, len - 1); [EOL]     int dot = -1; [EOL]     boolean negative = false; [EOL]     for (int i = 0; i < str.length(); i++) { [EOL]         if (str.charAt(i) >= '0' && str.charAt(i) <= '9') { [EOL]         } else if (i == 0 && str.charAt(0) == '-') { [EOL]             negative = true; [EOL]         } else if (i > (negative ? 1 : 0) && str.charAt(i) == '.' && dot == -1) { [EOL]             dot = i; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Invalid format: \"" + original + '"'); [EOL]         } [EOL]     } [EOL]     long millis = 0, seconds = 0; [EOL]     int firstDigit = negative ? 1 : 0; [EOL]     if (dot > 0) { [EOL]         seconds = Long.parseLong(str.substring(firstDigit, dot)); [EOL]         str = str.substring(dot + 1); [EOL]         if (str.length() != 3) { [EOL]             str = (str + "000").substring(0, 3); [EOL]         } [EOL]         millis = Integer.parseInt(str); [EOL]     } else if (negative) { [EOL]         seconds = Long.parseLong(str.substring(firstDigit, str.length())); [EOL]     } else { [EOL]         seconds = Long.parseLong(str); [EOL]     } [EOL]     if (negative) { [EOL]         return FieldUtils.safeAdd(FieldUtils.safeMultiply(-seconds, 1000), -millis); [EOL]     } else { [EOL]         return FieldUtils.safeAdd(FieldUtils.safeMultiply(seconds, 1000), millis); [EOL]     } [EOL] }
public long getDurationMillis(Object object) { [EOL]     String original = (String) object; [EOL]     String str = original; [EOL]     int len = str.length(); [EOL]     if (len >= 4 && (str.charAt(0) == 'P' || str.charAt(0) == 'p') && (str.charAt(1) == 'T' || str.charAt(1) == 't') && (str.charAt(len - 1) == 'S' || str.charAt(len - 1) == 's')) { [EOL]     } else { [EOL]         throw new IllegalArgumentException("Invalid format: \"" + original + '"'); [EOL]     } [EOL]     str = str.substring(2, len - 1); [EOL]     int dot = -1; [EOL]     boolean negative = false; [EOL]     for (int i = 0; i < str.length(); i++) { [EOL]         if (str.charAt(i) >= '0' && str.charAt(i) <= '9') { [EOL]         } else if (i == 0 && str.charAt(0) == '-') { [EOL]             negative = true; [EOL]         } else if (i > (negative ? 1 : 0) && str.charAt(i) == '.' && dot == -1) { [EOL]             dot = i; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Invalid format: \"" + original + '"'); [EOL]         } [EOL]     } [EOL]     long millis = 0, seconds = 0; [EOL]     int firstDigit = negative ? 1 : 0; [EOL]     if (dot > 0) { [EOL]         seconds = Long.parseLong(str.substring(firstDigit, dot)); [EOL]         str = str.substring(dot + 1); [EOL]         if (str.length() != 3) { [EOL]             str = (str + "000").substring(0, 3); [EOL]         } [EOL]         millis = Integer.parseInt(str); [EOL]     } else if (negative) { [EOL]         seconds = Long.parseLong(str.substring(firstDigit, str.length())); [EOL]     } else { [EOL]         seconds = Long.parseLong(str); [EOL]     } [EOL]     if (negative) { [EOL]         return FieldUtils.safeAdd(FieldUtils.safeMultiply(-seconds, 1000), -millis); [EOL]     } else { [EOL]         return FieldUtils.safeAdd(FieldUtils.safeMultiply(seconds, 1000), millis); [EOL]     } [EOL] }
public long getDurationMillis(Object object) { [EOL]     String original = (String) object; [EOL]     String str = original; [EOL]     int len = str.length(); [EOL]     if (len >= 4 && (str.charAt(0) == 'P' || str.charAt(0) == 'p') && (str.charAt(1) == 'T' || str.charAt(1) == 't') && (str.charAt(len - 1) == 'S' || str.charAt(len - 1) == 's')) { [EOL]     } else { [EOL]         throw new IllegalArgumentException("Invalid format: \"" + original + '"'); [EOL]     } [EOL]     str = str.substring(2, len - 1); [EOL]     int dot = -1; [EOL]     boolean negative = false; [EOL]     for (int i = 0; i < str.length(); i++) { [EOL]         if (str.charAt(i) >= '0' && str.charAt(i) <= '9') { [EOL]         } else if (i == 0 && str.charAt(0) == '-') { [EOL]             negative = true; [EOL]         } else if (i > (negative ? 1 : 0) && str.charAt(i) == '.' && dot == -1) { [EOL]             dot = i; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Invalid format: \"" + original + '"'); [EOL]         } [EOL]     } [EOL]     long millis = 0, seconds = 0; [EOL]     int firstDigit = negative ? 1 : 0; [EOL]     if (dot > 0) { [EOL]         seconds = Long.parseLong(str.substring(firstDigit, dot)); [EOL]         str = str.substring(dot + 1); [EOL]         if (str.length() != 3) { [EOL]             str = (str + "000").substring(0, 3); [EOL]         } [EOL]         millis = Integer.parseInt(str); [EOL]     } else if (negative) { [EOL]         seconds = Long.parseLong(str.substring(firstDigit, str.length())); [EOL]     } else { [EOL]         seconds = Long.parseLong(str); [EOL]     } [EOL]     if (negative) { [EOL]         return FieldUtils.safeAdd(FieldUtils.safeMultiply(-seconds, 1000), -millis); [EOL]     } else { [EOL]         return FieldUtils.safeAdd(FieldUtils.safeMultiply(seconds, 1000), millis); [EOL]     } [EOL] }
public long getDurationMillis(Object object) { [EOL]     String original = (String) object; [EOL]     String str = original; [EOL]     int len = str.length(); [EOL]     if (len >= 4 && (str.charAt(0) == 'P' || str.charAt(0) == 'p') && (str.charAt(1) == 'T' || str.charAt(1) == 't') && (str.charAt(len - 1) == 'S' || str.charAt(len - 1) == 's')) { [EOL]     } else { [EOL]         throw new IllegalArgumentException("Invalid format: \"" + original + '"'); [EOL]     } [EOL]     str = str.substring(2, len - 1); [EOL]     int dot = -1; [EOL]     boolean negative = false; [EOL]     for (int i = 0; i < str.length(); i++) { [EOL]         if (str.charAt(i) >= '0' && str.charAt(i) <= '9') { [EOL]         } else if (i == 0 && str.charAt(0) == '-') { [EOL]             negative = true; [EOL]         } else if (i > (negative ? 1 : 0) && str.charAt(i) == '.' && dot == -1) { [EOL]             dot = i; [EOL]         } else { [EOL]             throw new IllegalArgumentException("Invalid format: \"" + original + '"'); [EOL]         } [EOL]     } [EOL]     long millis = 0, seconds = 0; [EOL]     int firstDigit = negative ? 1 : 0; [EOL]     if (dot > 0) { [EOL]         seconds = Long.parseLong(str.substring(firstDigit, dot)); [EOL]         str = str.substring(dot + 1); [EOL]         if (str.length() != 3) { [EOL]             str = (str + "000").substring(0, 3); [EOL]         } [EOL]         millis = Integer.parseInt(str); [EOL]     } else if (negative) { [EOL]         seconds = Long.parseLong(str.substring(firstDigit, str.length())); [EOL]     } else { [EOL]         seconds = Long.parseLong(str); [EOL]     } [EOL]     if (negative) { [EOL]         return FieldUtils.safeAdd(FieldUtils.safeMultiply(-seconds, 1000), -millis); [EOL]     } else { [EOL]         return FieldUtils.safeAdd(FieldUtils.safeMultiply(seconds, 1000), millis); [EOL]     } [EOL] }
public void setInto(ReadWritablePeriod period, Object object, Chronology chrono) { [EOL]     String str = (String) object; [EOL]     PeriodFormatter parser = ISOPeriodFormat.standard(); [EOL]     period.clear(); [EOL]     int pos = parser.parseInto(period, str, 0); [EOL]     if (pos < str.length()) { [EOL]         if (pos < 0) { [EOL]             parser.withParseType(period.getPeriodType()).parseMutablePeriod(str); [EOL]         } [EOL]         throw new IllegalArgumentException("Invalid format: \"" + str + '"'); [EOL]     } [EOL] }
public void setInto(ReadWritablePeriod period, Object object, Chronology chrono) { [EOL]     String str = (String) object; [EOL]     PeriodFormatter parser = ISOPeriodFormat.standard(); [EOL]     period.clear(); [EOL]     int pos = parser.parseInto(period, str, 0); [EOL]     if (pos < str.length()) { [EOL]         if (pos < 0) { [EOL]             parser.withParseType(period.getPeriodType()).parseMutablePeriod(str); [EOL]         } [EOL]         throw new IllegalArgumentException("Invalid format: \"" + str + '"'); [EOL]     } [EOL] }
public void setInto(ReadWritablePeriod period, Object object, Chronology chrono) { [EOL]     String str = (String) object; [EOL]     PeriodFormatter parser = ISOPeriodFormat.standard(); [EOL]     period.clear(); [EOL]     int pos = parser.parseInto(period, str, 0); [EOL]     if (pos < str.length()) { [EOL]         if (pos < 0) { [EOL]             parser.withParseType(period.getPeriodType()).parseMutablePeriod(str); [EOL]         } [EOL]         throw new IllegalArgumentException("Invalid format: \"" + str + '"'); [EOL]     } [EOL] }
public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) { [EOL]     String str = (String) object; [EOL]     int separator = str.indexOf('/'); [EOL]     if (separator < 0) { [EOL]         throw new IllegalArgumentException("Format requires a '/' separator: " + str); [EOL]     } [EOL]     String leftStr = str.substring(0, separator); [EOL]     if (leftStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     String rightStr = str.substring(separator + 1); [EOL]     if (rightStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     DateTimeFormatter dateTimeParser = ISODateTimeFormat.dateTimeParser(); [EOL]     dateTimeParser = dateTimeParser.withChronology(chrono); [EOL]     PeriodFormatter periodParser = ISOPeriodFormat.standard(); [EOL]     long startInstant = 0, endInstant = 0; [EOL]     Period period = null; [EOL]     Chronology parsedChrono = null; [EOL]     char c = leftStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         period = periodParser.withParseType(getPeriodType(leftStr)).parsePeriod(leftStr); [EOL]     } else { [EOL]         DateTime start = dateTimeParser.parseDateTime(leftStr); [EOL]         startInstant = start.getMillis(); [EOL]         parsedChrono = start.getChronology(); [EOL]     } [EOL]     c = rightStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         if (period != null) { [EOL]             throw new IllegalArgumentException("Interval composed of two durations: " + str); [EOL]         } [EOL]         period = periodParser.withParseType(getPeriodType(rightStr)).parsePeriod(rightStr); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         endInstant = chrono.add(period, startInstant, 1); [EOL]     } else { [EOL]         DateTime end = dateTimeParser.parseDateTime(rightStr); [EOL]         endInstant = end.getMillis(); [EOL]         parsedChrono = (parsedChrono != null ? parsedChrono : end.getChronology()); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         if (period != null) { [EOL]             startInstant = chrono.add(period, endInstant, -1); [EOL]         } [EOL]     } [EOL]     writableInterval.setInterval(startInstant, endInstant); [EOL]     writableInterval.setChronology(chrono); [EOL] }
public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) { [EOL]     String str = (String) object; [EOL]     int separator = str.indexOf('/'); [EOL]     if (separator < 0) { [EOL]         throw new IllegalArgumentException("Format requires a '/' separator: " + str); [EOL]     } [EOL]     String leftStr = str.substring(0, separator); [EOL]     if (leftStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     String rightStr = str.substring(separator + 1); [EOL]     if (rightStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     DateTimeFormatter dateTimeParser = ISODateTimeFormat.dateTimeParser(); [EOL]     dateTimeParser = dateTimeParser.withChronology(chrono); [EOL]     PeriodFormatter periodParser = ISOPeriodFormat.standard(); [EOL]     long startInstant = 0, endInstant = 0; [EOL]     Period period = null; [EOL]     Chronology parsedChrono = null; [EOL]     char c = leftStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         period = periodParser.withParseType(getPeriodType(leftStr)).parsePeriod(leftStr); [EOL]     } else { [EOL]         DateTime start = dateTimeParser.parseDateTime(leftStr); [EOL]         startInstant = start.getMillis(); [EOL]         parsedChrono = start.getChronology(); [EOL]     } [EOL]     c = rightStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         if (period != null) { [EOL]             throw new IllegalArgumentException("Interval composed of two durations: " + str); [EOL]         } [EOL]         period = periodParser.withParseType(getPeriodType(rightStr)).parsePeriod(rightStr); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         endInstant = chrono.add(period, startInstant, 1); [EOL]     } else { [EOL]         DateTime end = dateTimeParser.parseDateTime(rightStr); [EOL]         endInstant = end.getMillis(); [EOL]         parsedChrono = (parsedChrono != null ? parsedChrono : end.getChronology()); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         if (period != null) { [EOL]             startInstant = chrono.add(period, endInstant, -1); [EOL]         } [EOL]     } [EOL]     writableInterval.setInterval(startInstant, endInstant); [EOL]     writableInterval.setChronology(chrono); [EOL] }
public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) { [EOL]     String str = (String) object; [EOL]     int separator = str.indexOf('/'); [EOL]     if (separator < 0) { [EOL]         throw new IllegalArgumentException("Format requires a '/' separator: " + str); [EOL]     } [EOL]     String leftStr = str.substring(0, separator); [EOL]     if (leftStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     String rightStr = str.substring(separator + 1); [EOL]     if (rightStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     DateTimeFormatter dateTimeParser = ISODateTimeFormat.dateTimeParser(); [EOL]     dateTimeParser = dateTimeParser.withChronology(chrono); [EOL]     PeriodFormatter periodParser = ISOPeriodFormat.standard(); [EOL]     long startInstant = 0, endInstant = 0; [EOL]     Period period = null; [EOL]     Chronology parsedChrono = null; [EOL]     char c = leftStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         period = periodParser.withParseType(getPeriodType(leftStr)).parsePeriod(leftStr); [EOL]     } else { [EOL]         DateTime start = dateTimeParser.parseDateTime(leftStr); [EOL]         startInstant = start.getMillis(); [EOL]         parsedChrono = start.getChronology(); [EOL]     } [EOL]     c = rightStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         if (period != null) { [EOL]             throw new IllegalArgumentException("Interval composed of two durations: " + str); [EOL]         } [EOL]         period = periodParser.withParseType(getPeriodType(rightStr)).parsePeriod(rightStr); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         endInstant = chrono.add(period, startInstant, 1); [EOL]     } else { [EOL]         DateTime end = dateTimeParser.parseDateTime(rightStr); [EOL]         endInstant = end.getMillis(); [EOL]         parsedChrono = (parsedChrono != null ? parsedChrono : end.getChronology()); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         if (period != null) { [EOL]             startInstant = chrono.add(period, endInstant, -1); [EOL]         } [EOL]     } [EOL]     writableInterval.setInterval(startInstant, endInstant); [EOL]     writableInterval.setChronology(chrono); [EOL] }
public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) { [EOL]     String str = (String) object; [EOL]     int separator = str.indexOf('/'); [EOL]     if (separator < 0) { [EOL]         throw new IllegalArgumentException("Format requires a '/' separator: " + str); [EOL]     } [EOL]     String leftStr = str.substring(0, separator); [EOL]     if (leftStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     String rightStr = str.substring(separator + 1); [EOL]     if (rightStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     DateTimeFormatter dateTimeParser = ISODateTimeFormat.dateTimeParser(); [EOL]     dateTimeParser = dateTimeParser.withChronology(chrono); [EOL]     PeriodFormatter periodParser = ISOPeriodFormat.standard(); [EOL]     long startInstant = 0, endInstant = 0; [EOL]     Period period = null; [EOL]     Chronology parsedChrono = null; [EOL]     char c = leftStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         period = periodParser.withParseType(getPeriodType(leftStr)).parsePeriod(leftStr); [EOL]     } else { [EOL]         DateTime start = dateTimeParser.parseDateTime(leftStr); [EOL]         startInstant = start.getMillis(); [EOL]         parsedChrono = start.getChronology(); [EOL]     } [EOL]     c = rightStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         if (period != null) { [EOL]             throw new IllegalArgumentException("Interval composed of two durations: " + str); [EOL]         } [EOL]         period = periodParser.withParseType(getPeriodType(rightStr)).parsePeriod(rightStr); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         endInstant = chrono.add(period, startInstant, 1); [EOL]     } else { [EOL]         DateTime end = dateTimeParser.parseDateTime(rightStr); [EOL]         endInstant = end.getMillis(); [EOL]         parsedChrono = (parsedChrono != null ? parsedChrono : end.getChronology()); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         if (period != null) { [EOL]             startInstant = chrono.add(period, endInstant, -1); [EOL]         } [EOL]     } [EOL]     writableInterval.setInterval(startInstant, endInstant); [EOL]     writableInterval.setChronology(chrono); [EOL] }
public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) { [EOL]     String str = (String) object; [EOL]     int separator = str.indexOf('/'); [EOL]     if (separator < 0) { [EOL]         throw new IllegalArgumentException("Format requires a '/' separator: " + str); [EOL]     } [EOL]     String leftStr = str.substring(0, separator); [EOL]     if (leftStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     String rightStr = str.substring(separator + 1); [EOL]     if (rightStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     DateTimeFormatter dateTimeParser = ISODateTimeFormat.dateTimeParser(); [EOL]     dateTimeParser = dateTimeParser.withChronology(chrono); [EOL]     PeriodFormatter periodParser = ISOPeriodFormat.standard(); [EOL]     long startInstant = 0, endInstant = 0; [EOL]     Period period = null; [EOL]     Chronology parsedChrono = null; [EOL]     char c = leftStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         period = periodParser.withParseType(getPeriodType(leftStr)).parsePeriod(leftStr); [EOL]     } else { [EOL]         DateTime start = dateTimeParser.parseDateTime(leftStr); [EOL]         startInstant = start.getMillis(); [EOL]         parsedChrono = start.getChronology(); [EOL]     } [EOL]     c = rightStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         if (period != null) { [EOL]             throw new IllegalArgumentException("Interval composed of two durations: " + str); [EOL]         } [EOL]         period = periodParser.withParseType(getPeriodType(rightStr)).parsePeriod(rightStr); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         endInstant = chrono.add(period, startInstant, 1); [EOL]     } else { [EOL]         DateTime end = dateTimeParser.parseDateTime(rightStr); [EOL]         endInstant = end.getMillis(); [EOL]         parsedChrono = (parsedChrono != null ? parsedChrono : end.getChronology()); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         if (period != null) { [EOL]             startInstant = chrono.add(period, endInstant, -1); [EOL]         } [EOL]     } [EOL]     writableInterval.setInterval(startInstant, endInstant); [EOL]     writableInterval.setChronology(chrono); [EOL] }
public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) { [EOL]     String str = (String) object; [EOL]     int separator = str.indexOf('/'); [EOL]     if (separator < 0) { [EOL]         throw new IllegalArgumentException("Format requires a '/' separator: " + str); [EOL]     } [EOL]     String leftStr = str.substring(0, separator); [EOL]     if (leftStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     String rightStr = str.substring(separator + 1); [EOL]     if (rightStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     DateTimeFormatter dateTimeParser = ISODateTimeFormat.dateTimeParser(); [EOL]     dateTimeParser = dateTimeParser.withChronology(chrono); [EOL]     PeriodFormatter periodParser = ISOPeriodFormat.standard(); [EOL]     long startInstant = 0, endInstant = 0; [EOL]     Period period = null; [EOL]     Chronology parsedChrono = null; [EOL]     char c = leftStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         period = periodParser.withParseType(getPeriodType(leftStr)).parsePeriod(leftStr); [EOL]     } else { [EOL]         DateTime start = dateTimeParser.parseDateTime(leftStr); [EOL]         startInstant = start.getMillis(); [EOL]         parsedChrono = start.getChronology(); [EOL]     } [EOL]     c = rightStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         if (period != null) { [EOL]             throw new IllegalArgumentException("Interval composed of two durations: " + str); [EOL]         } [EOL]         period = periodParser.withParseType(getPeriodType(rightStr)).parsePeriod(rightStr); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         endInstant = chrono.add(period, startInstant, 1); [EOL]     } else { [EOL]         DateTime end = dateTimeParser.parseDateTime(rightStr); [EOL]         endInstant = end.getMillis(); [EOL]         parsedChrono = (parsedChrono != null ? parsedChrono : end.getChronology()); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         if (period != null) { [EOL]             startInstant = chrono.add(period, endInstant, -1); [EOL]         } [EOL]     } [EOL]     writableInterval.setInterval(startInstant, endInstant); [EOL]     writableInterval.setChronology(chrono); [EOL] }
public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) { [EOL]     String str = (String) object; [EOL]     int separator = str.indexOf('/'); [EOL]     if (separator < 0) { [EOL]         throw new IllegalArgumentException("Format requires a '/' separator: " + str); [EOL]     } [EOL]     String leftStr = str.substring(0, separator); [EOL]     if (leftStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     String rightStr = str.substring(separator + 1); [EOL]     if (rightStr.length() <= 0) { [EOL]         throw new IllegalArgumentException("Format invalid: " + str); [EOL]     } [EOL]     DateTimeFormatter dateTimeParser = ISODateTimeFormat.dateTimeParser(); [EOL]     dateTimeParser = dateTimeParser.withChronology(chrono); [EOL]     PeriodFormatter periodParser = ISOPeriodFormat.standard(); [EOL]     long startInstant = 0, endInstant = 0; [EOL]     Period period = null; [EOL]     Chronology parsedChrono = null; [EOL]     char c = leftStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         period = periodParser.withParseType(getPeriodType(leftStr)).parsePeriod(leftStr); [EOL]     } else { [EOL]         DateTime start = dateTimeParser.parseDateTime(leftStr); [EOL]         startInstant = start.getMillis(); [EOL]         parsedChrono = start.getChronology(); [EOL]     } [EOL]     c = rightStr.charAt(0); [EOL]     if (c == 'P' || c == 'p') { [EOL]         if (period != null) { [EOL]             throw new IllegalArgumentException("Interval composed of two durations: " + str); [EOL]         } [EOL]         period = periodParser.withParseType(getPeriodType(rightStr)).parsePeriod(rightStr); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         endInstant = chrono.add(period, startInstant, 1); [EOL]     } else { [EOL]         DateTime end = dateTimeParser.parseDateTime(rightStr); [EOL]         endInstant = end.getMillis(); [EOL]         parsedChrono = (parsedChrono != null ? parsedChrono : end.getChronology()); [EOL]         chrono = (chrono != null ? chrono : parsedChrono); [EOL]         if (period != null) { [EOL]             startInstant = chrono.add(period, endInstant, -1); [EOL]         } [EOL]     } [EOL]     writableInterval.setInterval(startInstant, endInstant); [EOL]     writableInterval.setChronology(chrono); [EOL] }
public PeriodFormatterBuilder printZeroAlways() { [EOL]     iPrintZeroSetting = PRINT_ZERO_ALWAYS; [EOL]     return this; [EOL] }
public PeriodFormatterBuilder printZeroNever() { [EOL]     iPrintZeroSetting = PRINT_ZERO_NEVER; [EOL]     return this; [EOL] }
public PeriodFormatterBuilder appendMonths() { [EOL]     appendField(MONTHS); [EOL]     return this; [EOL] }
public PeriodFormatterBuilder appendDays() { [EOL]     appendField(DAYS); [EOL]     return this; [EOL] }
public PeriodFormatterBuilder appendSuffix(String text) { [EOL]     if (text == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     return appendSuffix(new SimpleAffix(text)); [EOL] }
public PeriodFormatterBuilder appendSuffix(String text) { [EOL]     if (text == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     return appendSuffix(new SimpleAffix(text)); [EOL] }
private PeriodFormatterBuilder appendSuffix(PeriodFieldAffix suffix) { [EOL]     final Object originalPrinter; [EOL]     final Object originalParser; [EOL]     if (iElementPairs.size() > 0) { [EOL]         originalPrinter = iElementPairs.get(iElementPairs.size() - 2); [EOL]         originalParser = iElementPairs.get(iElementPairs.size() - 1); [EOL]     } else { [EOL]         originalPrinter = null; [EOL]         originalParser = null; [EOL]     } [EOL]     if (originalPrinter == null || originalParser == null || originalPrinter != originalParser || !(originalPrinter instanceof FieldFormatter)) { [EOL]         throw new IllegalStateException("No field to apply suffix to"); [EOL]     } [EOL]     clearPrefix(); [EOL]     FieldFormatter newField = new FieldFormatter((FieldFormatter) originalPrinter, suffix); [EOL]     iElementPairs.set(iElementPairs.size() - 2, newField); [EOL]     iElementPairs.set(iElementPairs.size() - 1, newField); [EOL]     iFieldFormatters[newField.getFieldType()] = newField; [EOL]     return this; [EOL] }
private PeriodFormatterBuilder appendSuffix(PeriodFieldAffix suffix) { [EOL]     final Object originalPrinter; [EOL]     final Object originalParser; [EOL]     if (iElementPairs.size() > 0) { [EOL]         originalPrinter = iElementPairs.get(iElementPairs.size() - 2); [EOL]         originalParser = iElementPairs.get(iElementPairs.size() - 1); [EOL]     } else { [EOL]         originalPrinter = null; [EOL]         originalParser = null; [EOL]     } [EOL]     if (originalPrinter == null || originalParser == null || originalPrinter != originalParser || !(originalPrinter instanceof FieldFormatter)) { [EOL]         throw new IllegalStateException("No field to apply suffix to"); [EOL]     } [EOL]     clearPrefix(); [EOL]     FieldFormatter newField = new FieldFormatter((FieldFormatter) originalPrinter, suffix); [EOL]     iElementPairs.set(iElementPairs.size() - 2, newField); [EOL]     iElementPairs.set(iElementPairs.size() - 1, newField); [EOL]     iFieldFormatters[newField.getFieldType()] = newField; [EOL]     return this; [EOL] }
private PeriodFormatterBuilder appendSuffix(PeriodFieldAffix suffix) { [EOL]     final Object originalPrinter; [EOL]     final Object originalParser; [EOL]     if (iElementPairs.size() > 0) { [EOL]         originalPrinter = iElementPairs.get(iElementPairs.size() - 2); [EOL]         originalParser = iElementPairs.get(iElementPairs.size() - 1); [EOL]     } else { [EOL]         originalPrinter = null; [EOL]         originalParser = null; [EOL]     } [EOL]     if (originalPrinter == null || originalParser == null || originalPrinter != originalParser || !(originalPrinter instanceof FieldFormatter)) { [EOL]         throw new IllegalStateException("No field to apply suffix to"); [EOL]     } [EOL]     clearPrefix(); [EOL]     FieldFormatter newField = new FieldFormatter((FieldFormatter) originalPrinter, suffix); [EOL]     iElementPairs.set(iElementPairs.size() - 2, newField); [EOL]     iElementPairs.set(iElementPairs.size() - 1, newField); [EOL]     iFieldFormatters[newField.getFieldType()] = newField; [EOL]     return this; [EOL] }
public PeriodFormatterBuilder appendSeparatorIfFieldsBefore(String text) { [EOL]     return appendSeparator(text, text, null, true, false); [EOL] }
private void clearPrefix() throws IllegalStateException { [EOL]     if (iPrefix != null) { [EOL]         throw new IllegalStateException("Prefix not followed by field"); [EOL]     } [EOL]     iPrefix = null; [EOL] }
private void clearPrefix() throws IllegalStateException { [EOL]     if (iPrefix != null) { [EOL]         throw new IllegalStateException("Prefix not followed by field"); [EOL]     } [EOL]     iPrefix = null; [EOL] }
public int parse(String periodStr, int position) { [EOL]     String text1 = iPluralText; [EOL]     String text2 = iSingularText; [EOL]     if (text1.length() < text2.length()) { [EOL]         String temp = text1; [EOL]         text1 = text2; [EOL]         text2 = temp; [EOL]     } [EOL]     if (periodStr.regionMatches(true, position, text1, 0, text1.length())) { [EOL]         return position + text1.length(); [EOL]     } [EOL]     if (periodStr.regionMatches(true, position, text2, 0, text2.length())) { [EOL]         return position + text2.length(); [EOL]     } [EOL]     return ~position; [EOL] }
public int parse(String periodStr, int position) { [EOL]     String text1 = iPluralText; [EOL]     String text2 = iSingularText; [EOL]     if (text1.length() < text2.length()) { [EOL]         String temp = text1; [EOL]         text1 = text2; [EOL]         text2 = temp; [EOL]     } [EOL]     if (periodStr.regionMatches(true, position, text1, 0, text1.length())) { [EOL]         return position + text1.length(); [EOL]     } [EOL]     if (periodStr.regionMatches(true, position, text2, 0, text2.length())) { [EOL]         return position + text2.length(); [EOL]     } [EOL]     return ~position; [EOL] }
public int parse(String periodStr, int position) { [EOL]     String text1 = iPluralText; [EOL]     String text2 = iSingularText; [EOL]     if (text1.length() < text2.length()) { [EOL]         String temp = text1; [EOL]         text1 = text2; [EOL]         text2 = temp; [EOL]     } [EOL]     if (periodStr.regionMatches(true, position, text1, 0, text1.length())) { [EOL]         return position + text1.length(); [EOL]     } [EOL]     if (periodStr.regionMatches(true, position, text2, 0, text2.length())) { [EOL]         return position + text2.length(); [EOL]     } [EOL]     return ~position; [EOL] }
public int scan(String periodStr, final int position) { [EOL]     String text1 = iPluralText; [EOL]     String text2 = iSingularText; [EOL]     if (text1.length() < text2.length()) { [EOL]         String temp = text1; [EOL]         text1 = text2; [EOL]         text2 = temp; [EOL]     } [EOL]     int textLength1 = text1.length(); [EOL]     int textLength2 = text2.length(); [EOL]     int sourceLength = periodStr.length(); [EOL]     for (int pos = position; pos < sourceLength; pos++) { [EOL]         if (periodStr.regionMatches(true, pos, text1, 0, textLength1)) { [EOL]             return pos; [EOL]         } [EOL]         if (periodStr.regionMatches(true, pos, text2, 0, textLength2)) { [EOL]             return pos; [EOL]         } [EOL]     } [EOL]     return ~position; [EOL] }
public int scan(String periodStr, final int position) { [EOL]     String text1 = iPluralText; [EOL]     String text2 = iSingularText; [EOL]     if (text1.length() < text2.length()) { [EOL]         String temp = text1; [EOL]         text1 = text2; [EOL]         text2 = temp; [EOL]     } [EOL]     int textLength1 = text1.length(); [EOL]     int textLength2 = text2.length(); [EOL]     int sourceLength = periodStr.length(); [EOL]     for (int pos = position; pos < sourceLength; pos++) { [EOL]         if (periodStr.regionMatches(true, pos, text1, 0, textLength1)) { [EOL]             return pos; [EOL]         } [EOL]         if (periodStr.regionMatches(true, pos, text2, 0, textLength2)) { [EOL]             return pos; [EOL]         } [EOL]     } [EOL]     return ~position; [EOL] }
public int scan(String periodStr, final int position) { [EOL]     String text1 = iPluralText; [EOL]     String text2 = iSingularText; [EOL]     if (text1.length() < text2.length()) { [EOL]         String temp = text1; [EOL]         text1 = text2; [EOL]         text2 = temp; [EOL]     } [EOL]     int textLength1 = text1.length(); [EOL]     int textLength2 = text2.length(); [EOL]     int sourceLength = periodStr.length(); [EOL]     for (int pos = position; pos < sourceLength; pos++) { [EOL]         if (periodStr.regionMatches(true, pos, text1, 0, textLength1)) { [EOL]             return pos; [EOL]         } [EOL]         if (periodStr.regionMatches(true, pos, text2, 0, textLength2)) { [EOL]             return pos; [EOL]         } [EOL]     } [EOL]     return ~position; [EOL] }
FieldFormatter(FieldFormatter field, PeriodFieldAffix suffix) { [EOL]     iMinPrintedDigits = field.iMinPrintedDigits; [EOL]     iPrintZeroSetting = field.iPrintZeroSetting; [EOL]     iMaxParsedDigits = field.iMaxParsedDigits; [EOL]     iRejectSignedValues = field.iRejectSignedValues; [EOL]     iFieldType = field.iFieldType; [EOL]     iFieldFormatters = field.iFieldFormatters; [EOL]     iPrefix = field.iPrefix; [EOL]     if (field.iSuffix != null) { [EOL]         suffix = new CompositeAffix(field.iSuffix, suffix); [EOL]     } [EOL]     iSuffix = suffix; [EOL] }
FieldFormatter(FieldFormatter field, PeriodFieldAffix suffix) { [EOL]     iMinPrintedDigits = field.iMinPrintedDigits; [EOL]     iPrintZeroSetting = field.iPrintZeroSetting; [EOL]     iMaxParsedDigits = field.iMaxParsedDigits; [EOL]     iRejectSignedValues = field.iRejectSignedValues; [EOL]     iFieldType = field.iFieldType; [EOL]     iFieldFormatters = field.iFieldFormatters; [EOL]     iPrefix = field.iPrefix; [EOL]     if (field.iSuffix != null) { [EOL]         suffix = new CompositeAffix(field.iSuffix, suffix); [EOL]     } [EOL]     iSuffix = suffix; [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return 0; [EOL]     } [EOL]     int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits); [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4)); [EOL]         sum++; [EOL]         if (iFieldType == SECONDS_OPTIONAL_MILLIS && (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) { [EOL]             sum -= 4; [EOL]         } [EOL]         valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iPrefix != null) { [EOL]         sum += iPrefix.calculatePrintedLength(value); [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         sum += iSuffix.calculatePrintedLength(value); [EOL]     } [EOL]     return sum; [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return 0; [EOL]     } [EOL]     int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits); [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4)); [EOL]         sum++; [EOL]         if (iFieldType == SECONDS_OPTIONAL_MILLIS && (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) { [EOL]             sum -= 4; [EOL]         } [EOL]         valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iPrefix != null) { [EOL]         sum += iPrefix.calculatePrintedLength(value); [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         sum += iSuffix.calculatePrintedLength(value); [EOL]     } [EOL]     return sum; [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return 0; [EOL]     } [EOL]     int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits); [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4)); [EOL]         sum++; [EOL]         if (iFieldType == SECONDS_OPTIONAL_MILLIS && (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) { [EOL]             sum -= 4; [EOL]         } [EOL]         valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iPrefix != null) { [EOL]         sum += iPrefix.calculatePrintedLength(value); [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         sum += iSuffix.calculatePrintedLength(value); [EOL]     } [EOL]     return sum; [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return 0; [EOL]     } [EOL]     int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits); [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4)); [EOL]         sum++; [EOL]         if (iFieldType == SECONDS_OPTIONAL_MILLIS && (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) { [EOL]             sum -= 4; [EOL]         } [EOL]         valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iPrefix != null) { [EOL]         sum += iPrefix.calculatePrintedLength(value); [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         sum += iSuffix.calculatePrintedLength(value); [EOL]     } [EOL]     return sum; [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return 0; [EOL]     } [EOL]     int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits); [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4)); [EOL]         sum++; [EOL]         if (iFieldType == SECONDS_OPTIONAL_MILLIS && (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) { [EOL]             sum -= 4; [EOL]         } [EOL]         valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iPrefix != null) { [EOL]         sum += iPrefix.calculatePrintedLength(value); [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         sum += iSuffix.calculatePrintedLength(value); [EOL]     } [EOL]     return sum; [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return 0; [EOL]     } [EOL]     int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits); [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         sum = (valueLong < 0 ? Math.max(sum, 5) : Math.max(sum, 4)); [EOL]         sum++; [EOL]         if (iFieldType == SECONDS_OPTIONAL_MILLIS && (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) { [EOL]             sum -= 4; [EOL]         } [EOL]         valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iPrefix != null) { [EOL]         sum += iPrefix.calculatePrintedLength(value); [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         sum += iSuffix.calculatePrintedLength(value); [EOL]     } [EOL]     return sum; [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         iPrefix.printTo(buf, value); [EOL]     } [EOL]     int bufLen = buf.length(); [EOL]     int minDigits = iMinPrintedDigits; [EOL]     if (minDigits <= 1) { [EOL]         FormatUtils.appendUnpaddedInteger(buf, value); [EOL]     } else { [EOL]         FormatUtils.appendPaddedInteger(buf, value, minDigits); [EOL]     } [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); [EOL]         if (iFieldType == SECONDS_MILLIS || dp > 0) { [EOL]             if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) { [EOL]                 buf.insert(bufLen, '-'); [EOL]             } [EOL]             buf.append('.'); [EOL]             FormatUtils.appendPaddedInteger(buf, dp, 3); [EOL]         } [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         iSuffix.printTo(buf, value); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         iPrefix.printTo(buf, value); [EOL]     } [EOL]     int bufLen = buf.length(); [EOL]     int minDigits = iMinPrintedDigits; [EOL]     if (minDigits <= 1) { [EOL]         FormatUtils.appendUnpaddedInteger(buf, value); [EOL]     } else { [EOL]         FormatUtils.appendPaddedInteger(buf, value, minDigits); [EOL]     } [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); [EOL]         if (iFieldType == SECONDS_MILLIS || dp > 0) { [EOL]             if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) { [EOL]                 buf.insert(bufLen, '-'); [EOL]             } [EOL]             buf.append('.'); [EOL]             FormatUtils.appendPaddedInteger(buf, dp, 3); [EOL]         } [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         iSuffix.printTo(buf, value); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         iPrefix.printTo(buf, value); [EOL]     } [EOL]     int bufLen = buf.length(); [EOL]     int minDigits = iMinPrintedDigits; [EOL]     if (minDigits <= 1) { [EOL]         FormatUtils.appendUnpaddedInteger(buf, value); [EOL]     } else { [EOL]         FormatUtils.appendPaddedInteger(buf, value, minDigits); [EOL]     } [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); [EOL]         if (iFieldType == SECONDS_MILLIS || dp > 0) { [EOL]             if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) { [EOL]                 buf.insert(bufLen, '-'); [EOL]             } [EOL]             buf.append('.'); [EOL]             FormatUtils.appendPaddedInteger(buf, dp, 3); [EOL]         } [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         iSuffix.printTo(buf, value); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         iPrefix.printTo(buf, value); [EOL]     } [EOL]     int bufLen = buf.length(); [EOL]     int minDigits = iMinPrintedDigits; [EOL]     if (minDigits <= 1) { [EOL]         FormatUtils.appendUnpaddedInteger(buf, value); [EOL]     } else { [EOL]         FormatUtils.appendPaddedInteger(buf, value, minDigits); [EOL]     } [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); [EOL]         if (iFieldType == SECONDS_MILLIS || dp > 0) { [EOL]             if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) { [EOL]                 buf.insert(bufLen, '-'); [EOL]             } [EOL]             buf.append('.'); [EOL]             FormatUtils.appendPaddedInteger(buf, dp, 3); [EOL]         } [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         iSuffix.printTo(buf, value); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         iPrefix.printTo(buf, value); [EOL]     } [EOL]     int bufLen = buf.length(); [EOL]     int minDigits = iMinPrintedDigits; [EOL]     if (minDigits <= 1) { [EOL]         FormatUtils.appendUnpaddedInteger(buf, value); [EOL]     } else { [EOL]         FormatUtils.appendPaddedInteger(buf, value, minDigits); [EOL]     } [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); [EOL]         if (iFieldType == SECONDS_MILLIS || dp > 0) { [EOL]             if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) { [EOL]                 buf.insert(bufLen, '-'); [EOL]             } [EOL]             buf.append('.'); [EOL]             FormatUtils.appendPaddedInteger(buf, dp, 3); [EOL]         } [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         iSuffix.printTo(buf, value); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     long valueLong = getFieldValue(period); [EOL]     if (valueLong == Long.MAX_VALUE) { [EOL]         return; [EOL]     } [EOL]     int value = (int) valueLong; [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND); [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         iPrefix.printTo(buf, value); [EOL]     } [EOL]     int bufLen = buf.length(); [EOL]     int minDigits = iMinPrintedDigits; [EOL]     if (minDigits <= 1) { [EOL]         FormatUtils.appendUnpaddedInteger(buf, value); [EOL]     } else { [EOL]         FormatUtils.appendPaddedInteger(buf, value, minDigits); [EOL]     } [EOL]     if (iFieldType >= SECONDS_MILLIS) { [EOL]         int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND); [EOL]         if (iFieldType == SECONDS_MILLIS || dp > 0) { [EOL]             if (valueLong < 0 && valueLong > -DateTimeConstants.MILLIS_PER_SECOND) { [EOL]                 buf.insert(bufLen, '-'); [EOL]             } [EOL]             buf.append('.'); [EOL]             FormatUtils.appendPaddedInteger(buf, dp, 3); [EOL]         } [EOL]     } [EOL]     if (iSuffix != null) { [EOL]         iSuffix.printTo(buf, value); [EOL]     } [EOL] }
public int parseInto(ReadWritablePeriod period, String text, int position, Locale locale) { [EOL]     boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS); [EOL]     if (position >= text.length()) { [EOL]         return mustParse ? ~position : position; [EOL]     } [EOL]     if (iPrefix != null) { [EOL]         position = iPrefix.parse(text, position); [EOL]         if (position >= 0) { [EOL]             mustParse = true; [EOL]         } else { [EOL]             if (!mustParse) { [EOL]                 return ~position; [EOL]             } [EOL]             return position; [EOL]         } [EOL]     } [EOL]     int suffixPos = -1; [EOL]     if (iSuffix != null && !mustParse) { [EOL]         suffixPos = iSuffix.scan(text, position); [EOL]         if (suffixPos >= 0) { [EOL]             mustParse = true; [EOL]         } else { [EOL]             if (!mustParse) { [EOL]                 return ~suffixPos; [EOL]             } [EOL]             return suffixPos; [EOL]         } [EOL]     } [EOL]     if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) { [EOL]         return position; [EOL]     } [EOL]     int limit; [EOL]     if (suffixPos > 0) { [EOL]         limit = Math.min(iMaxParsedDigits, suffixPos - position); [EOL]     } else { [EOL]         limit = Math.min(iMaxParsedDigits, text.length() - position); [EOL]     } [EOL]     int length = 0; [EOL]     int fractPos = -1; [EOL]     boolean hasDigits = false; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) { [EOL]             boolean negative = c == '-'; [EOL]             if (length + 1 >= limit || (c = text.charAt(position + length + 1)) < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             if (negative) { [EOL]                 length++; [EOL]             } else { [EOL]                 position++; [EOL]             } [EOL]             limit = Math.min(limit + 1, text.length() - position); [EOL]             continue; [EOL]         } [EOL]         if (c >= '0' && c <= '9') { [EOL]             hasDigits = true; [EOL]         } else { [EOL]             if ((c == '.' || c == ',') && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) { [EOL]                 if (fractPos >= 0) { [EOL]                     break; [EOL]                 } [EOL]                 fractPos = position + length + 1; [EOL]                 limit = Math.min(limit + 1, text.length() - position); [EOL]             } else { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         length++; [EOL]     } [EOL]     if (!hasDigits) { [EOL]         return ~position; [EOL]     } [EOL]     if (suffixPos >= 0 && position + length != suffixPos) { [EOL]         return position; [EOL]     } [EOL]     if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) { [EOL]         setFieldValue(period, iFieldType, parseInt(text, position, length)); [EOL]     } else if (fractPos < 0) { [EOL]         setFieldValue(period, SECONDS, parseInt(text, position, length)); [EOL]         setFieldValue(period, MILLIS, 0); [EOL]     } else { [EOL]         int wholeValue = parseInt(text, position, fractPos - position - 1); [EOL]         setFieldValue(period, SECONDS, wholeValue); [EOL]         int fractLen = position + length - fractPos; [EOL]         int fractValue; [EOL]         if (fractLen <= 0) { [EOL]             fractValue = 0; [EOL]         } else { [EOL]             if (fractLen >= 3) { [EOL]                 fractValue = parseInt(text, fractPos, 3); [EOL]             } else { [EOL]                 fractValue = parseInt(text, fractPos, fractLen); [EOL]                 if (fractLen == 1) { [EOL]                     fractValue *= 100; [EOL]                 } else { [EOL]                     fractValue *= 10; [EOL]                 } [EOL]             } [EOL]             if (wholeValue < 0) { [EOL]                 fractValue = -fractValue; [EOL]             } [EOL]         } [EOL]         setFieldValue(period, MILLIS, fractValue); [EOL]     } [EOL]     position += length; [EOL]     if (position >= 0 && iSuffix != null) { [EOL]         position = iSuffix.parse(text, position); [EOL]     } [EOL]     return position; [EOL] }
long getFieldValue(ReadablePeriod period) { [EOL]     PeriodType type; [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { [EOL]         type = null; [EOL]     } else { [EOL]         type = period.getPeriodType(); [EOL]     } [EOL]     if (type != null && isSupported(type, iFieldType) == false) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     long value; [EOL]     switch(iFieldType) { [EOL]         default: [EOL]             return Long.MAX_VALUE; [EOL]         case YEARS: [EOL]             value = period.get(DurationFieldType.years()); [EOL]             break; [EOL]         case MONTHS: [EOL]             value = period.get(DurationFieldType.months()); [EOL]             break; [EOL]         case WEEKS: [EOL]             value = period.get(DurationFieldType.weeks()); [EOL]             break; [EOL]         case DAYS: [EOL]             value = period.get(DurationFieldType.days()); [EOL]             break; [EOL]         case HOURS: [EOL]             value = period.get(DurationFieldType.hours()); [EOL]             break; [EOL]         case MINUTES: [EOL]             value = period.get(DurationFieldType.minutes()); [EOL]             break; [EOL]         case SECONDS: [EOL]             value = period.get(DurationFieldType.seconds()); [EOL]             break; [EOL]         case MILLIS: [EOL]             value = period.get(DurationFieldType.millis()); [EOL]             break; [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             int seconds = period.get(DurationFieldType.seconds()); [EOL]             int millis = period.get(DurationFieldType.millis()); [EOL]             value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis; [EOL]             break; [EOL]     } [EOL]     if (value == 0) { [EOL]         switch(iPrintZeroSetting) { [EOL]             case PRINT_ZERO_NEVER: [EOL]                 return Long.MAX_VALUE; [EOL]             case PRINT_ZERO_RARELY_LAST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     for (int i = iFieldType + 1; i <= MAX_FIELD; i++) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]             case PRINT_ZERO_RARELY_FIRST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     int i = Math.min(iFieldType, 8); [EOL]                     i--; [EOL]                     for (; i >= 0 && i <= MAX_FIELD; i--) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
long getFieldValue(ReadablePeriod period) { [EOL]     PeriodType type; [EOL]     if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) { [EOL]         type = null; [EOL]     } else { [EOL]         type = period.getPeriodType(); [EOL]     } [EOL]     if (type != null && isSupported(type, iFieldType) == false) { [EOL]         return Long.MAX_VALUE; [EOL]     } [EOL]     long value; [EOL]     switch(iFieldType) { [EOL]         default: [EOL]             return Long.MAX_VALUE; [EOL]         case YEARS: [EOL]             value = period.get(DurationFieldType.years()); [EOL]             break; [EOL]         case MONTHS: [EOL]             value = period.get(DurationFieldType.months()); [EOL]             break; [EOL]         case WEEKS: [EOL]             value = period.get(DurationFieldType.weeks()); [EOL]             break; [EOL]         case DAYS: [EOL]             value = period.get(DurationFieldType.days()); [EOL]             break; [EOL]         case HOURS: [EOL]             value = period.get(DurationFieldType.hours()); [EOL]             break; [EOL]         case MINUTES: [EOL]             value = period.get(DurationFieldType.minutes()); [EOL]             break; [EOL]         case SECONDS: [EOL]             value = period.get(DurationFieldType.seconds()); [EOL]             break; [EOL]         case MILLIS: [EOL]             value = period.get(DurationFieldType.millis()); [EOL]             break; [EOL]         case SECONDS_MILLIS: [EOL]         case SECONDS_OPTIONAL_MILLIS: [EOL]             int seconds = period.get(DurationFieldType.seconds()); [EOL]             int millis = period.get(DurationFieldType.millis()); [EOL]             value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis; [EOL]             break; [EOL]     } [EOL]     if (value == 0) { [EOL]         switch(iPrintZeroSetting) { [EOL]             case PRINT_ZERO_NEVER: [EOL]                 return Long.MAX_VALUE; [EOL]             case PRINT_ZERO_RARELY_LAST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     for (int i = iFieldType + 1; i <= MAX_FIELD; i++) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]             case PRINT_ZERO_RARELY_FIRST: [EOL]                 if (isZero(period) && iFieldFormatters[iFieldType] == this) { [EOL]                     int i = Math.min(iFieldType, 8); [EOL]                     i--; [EOL]                     for (; i >= 0 && i <= MAX_FIELD; i--) { [EOL]                         if (isSupported(type, i) && iFieldFormatters[i] != null) { [EOL]                             return Long.MAX_VALUE; [EOL]                         } [EOL]                     } [EOL]                 } else { [EOL]                     return Long.MAX_VALUE; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
int getFieldType() { [EOL]     return iFieldType; [EOL] }
public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) { [EOL]     return 0; [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     return iText.length(); [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     buf.append(iText); [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     PeriodPrinter before = iBeforePrinter; [EOL]     PeriodPrinter after = iAfterPrinter; [EOL]     int sum = before.calculatePrintedLength(period, locale) + after.calculatePrintedLength(period, locale); [EOL]     if (iUseBefore) { [EOL]         if (before.countFieldsToPrint(period, 1, locale) > 0) { [EOL]             if (iUseAfter) { [EOL]                 int afterCount = after.countFieldsToPrint(period, 2, locale); [EOL]                 if (afterCount > 0) { [EOL]                     sum += (afterCount > 1 ? iText : iFinalText).length(); [EOL]                 } [EOL]             } else { [EOL]                 sum += iText.length(); [EOL]             } [EOL]         } [EOL]     } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { [EOL]         sum += iText.length(); [EOL]     } [EOL]     return sum; [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     PeriodPrinter before = iBeforePrinter; [EOL]     PeriodPrinter after = iAfterPrinter; [EOL]     int sum = before.calculatePrintedLength(period, locale) + after.calculatePrintedLength(period, locale); [EOL]     if (iUseBefore) { [EOL]         if (before.countFieldsToPrint(period, 1, locale) > 0) { [EOL]             if (iUseAfter) { [EOL]                 int afterCount = after.countFieldsToPrint(period, 2, locale); [EOL]                 if (afterCount > 0) { [EOL]                     sum += (afterCount > 1 ? iText : iFinalText).length(); [EOL]                 } [EOL]             } else { [EOL]                 sum += iText.length(); [EOL]             } [EOL]         } [EOL]     } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { [EOL]         sum += iText.length(); [EOL]     } [EOL]     return sum; [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     PeriodPrinter before = iBeforePrinter; [EOL]     PeriodPrinter after = iAfterPrinter; [EOL]     int sum = before.calculatePrintedLength(period, locale) + after.calculatePrintedLength(period, locale); [EOL]     if (iUseBefore) { [EOL]         if (before.countFieldsToPrint(period, 1, locale) > 0) { [EOL]             if (iUseAfter) { [EOL]                 int afterCount = after.countFieldsToPrint(period, 2, locale); [EOL]                 if (afterCount > 0) { [EOL]                     sum += (afterCount > 1 ? iText : iFinalText).length(); [EOL]                 } [EOL]             } else { [EOL]                 sum += iText.length(); [EOL]             } [EOL]         } [EOL]     } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { [EOL]         sum += iText.length(); [EOL]     } [EOL]     return sum; [EOL] }
public int calculatePrintedLength(ReadablePeriod period, Locale locale) { [EOL]     PeriodPrinter before = iBeforePrinter; [EOL]     PeriodPrinter after = iAfterPrinter; [EOL]     int sum = before.calculatePrintedLength(period, locale) + after.calculatePrintedLength(period, locale); [EOL]     if (iUseBefore) { [EOL]         if (before.countFieldsToPrint(period, 1, locale) > 0) { [EOL]             if (iUseAfter) { [EOL]                 int afterCount = after.countFieldsToPrint(period, 2, locale); [EOL]                 if (afterCount > 0) { [EOL]                     sum += (afterCount > 1 ? iText : iFinalText).length(); [EOL]                 } [EOL]             } else { [EOL]                 sum += iText.length(); [EOL]             } [EOL]         } [EOL]     } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { [EOL]         sum += iText.length(); [EOL]     } [EOL]     return sum; [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     PeriodPrinter before = iBeforePrinter; [EOL]     PeriodPrinter after = iAfterPrinter; [EOL]     before.printTo(buf, period, locale); [EOL]     if (iUseBefore) { [EOL]         if (before.countFieldsToPrint(period, 1, locale) > 0) { [EOL]             if (iUseAfter) { [EOL]                 int afterCount = after.countFieldsToPrint(period, 2, locale); [EOL]                 if (afterCount > 0) { [EOL]                     buf.append(afterCount > 1 ? iText : iFinalText); [EOL]                 } [EOL]             } else { [EOL]                 buf.append(iText); [EOL]             } [EOL]         } [EOL]     } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { [EOL]         buf.append(iText); [EOL]     } [EOL]     after.printTo(buf, period, locale); [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     PeriodPrinter before = iBeforePrinter; [EOL]     PeriodPrinter after = iAfterPrinter; [EOL]     before.printTo(buf, period, locale); [EOL]     if (iUseBefore) { [EOL]         if (before.countFieldsToPrint(period, 1, locale) > 0) { [EOL]             if (iUseAfter) { [EOL]                 int afterCount = after.countFieldsToPrint(period, 2, locale); [EOL]                 if (afterCount > 0) { [EOL]                     buf.append(afterCount > 1 ? iText : iFinalText); [EOL]                 } [EOL]             } else { [EOL]                 buf.append(iText); [EOL]             } [EOL]         } [EOL]     } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { [EOL]         buf.append(iText); [EOL]     } [EOL]     after.printTo(buf, period, locale); [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     PeriodPrinter before = iBeforePrinter; [EOL]     PeriodPrinter after = iAfterPrinter; [EOL]     before.printTo(buf, period, locale); [EOL]     if (iUseBefore) { [EOL]         if (before.countFieldsToPrint(period, 1, locale) > 0) { [EOL]             if (iUseAfter) { [EOL]                 int afterCount = after.countFieldsToPrint(period, 2, locale); [EOL]                 if (afterCount > 0) { [EOL]                     buf.append(afterCount > 1 ? iText : iFinalText); [EOL]                 } [EOL]             } else { [EOL]                 buf.append(iText); [EOL]             } [EOL]         } [EOL]     } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { [EOL]         buf.append(iText); [EOL]     } [EOL]     after.printTo(buf, period, locale); [EOL] }
public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) { [EOL]     PeriodPrinter before = iBeforePrinter; [EOL]     PeriodPrinter after = iAfterPrinter; [EOL]     before.printTo(buf, period, locale); [EOL]     if (iUseBefore) { [EOL]         if (before.countFieldsToPrint(period, 1, locale) > 0) { [EOL]             if (iUseAfter) { [EOL]                 int afterCount = after.countFieldsToPrint(period, 2, locale); [EOL]                 if (afterCount > 0) { [EOL]                     buf.append(afterCount > 1 ? iText : iFinalText); [EOL]                 } [EOL]             } else { [EOL]                 buf.append(iText); [EOL]             } [EOL]         } [EOL]     } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) { [EOL]         buf.append(iText); [EOL]     } [EOL]     after.printTo(buf, period, locale); [EOL] }
public int parseInto(ReadWritablePeriod period, String periodStr, int position, Locale locale) { [EOL]     int oldPos = position; [EOL]     position = iBeforeParser.parseInto(period, periodStr, position, locale); [EOL]     if (position < 0) { [EOL]         return position; [EOL]     } [EOL]     boolean found = false; [EOL]     int parsedFormLength = -1; [EOL]     if (position > oldPos) { [EOL]         String[] parsedForms = iParsedForms; [EOL]         int length = parsedForms.length; [EOL]         for (int i = 0; i < length; i++) { [EOL]             String parsedForm = parsedForms[i]; [EOL]             if ((parsedForm == null || parsedForm.length() == 0) || periodStr.regionMatches(true, position, parsedForm, 0, parsedForm.length())) { [EOL]                 parsedFormLength = (parsedForm == null ? 0 : parsedForm.length()); [EOL]                 position += parsedFormLength; [EOL]                 found = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     oldPos = position; [EOL]     position = iAfterParser.parseInto(period, periodStr, position, locale); [EOL]     if (position < 0) { [EOL]         return position; [EOL]     } [EOL]     if (found && position == oldPos && parsedFormLength > 0) { [EOL]         return ~oldPos; [EOL]     } [EOL]     if (position > oldPos && !found && !iUseBefore) { [EOL]         return ~oldPos; [EOL]     } [EOL]     return position; [EOL] }
public int parseInto(ReadWritablePeriod period, String periodStr, int position, Locale locale) { [EOL]     int oldPos = position; [EOL]     position = iBeforeParser.parseInto(period, periodStr, position, locale); [EOL]     if (position < 0) { [EOL]         return position; [EOL]     } [EOL]     boolean found = false; [EOL]     int parsedFormLength = -1; [EOL]     if (position > oldPos) { [EOL]         String[] parsedForms = iParsedForms; [EOL]         int length = parsedForms.length; [EOL]         for (int i = 0; i < length; i++) { [EOL]             String parsedForm = parsedForms[i]; [EOL]             if ((parsedForm == null || parsedForm.length() == 0) || periodStr.regionMatches(true, position, parsedForm, 0, parsedForm.length())) { [EOL]                 parsedFormLength = (parsedForm == null ? 0 : parsedForm.length()); [EOL]                 position += parsedFormLength; [EOL]                 found = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     oldPos = position; [EOL]     position = iAfterParser.parseInto(period, periodStr, position, locale); [EOL]     if (position < 0) { [EOL]         return position; [EOL]     } [EOL]     if (found && position == oldPos && parsedFormLength > 0) { [EOL]         return ~oldPos; [EOL]     } [EOL]     if (position > oldPos && !found && !iUseBefore) { [EOL]         return ~oldPos; [EOL]     } [EOL]     return position; [EOL] }
public int parseInto(ReadWritablePeriod period, String periodStr, int position, Locale locale) { [EOL]     int oldPos = position; [EOL]     position = iBeforeParser.parseInto(period, periodStr, position, locale); [EOL]     if (position < 0) { [EOL]         return position; [EOL]     } [EOL]     boolean found = false; [EOL]     int parsedFormLength = -1; [EOL]     if (position > oldPos) { [EOL]         String[] parsedForms = iParsedForms; [EOL]         int length = parsedForms.length; [EOL]         for (int i = 0; i < length; i++) { [EOL]             String parsedForm = parsedForms[i]; [EOL]             if ((parsedForm == null || parsedForm.length() == 0) || periodStr.regionMatches(true, position, parsedForm, 0, parsedForm.length())) { [EOL]                 parsedFormLength = (parsedForm == null ? 0 : parsedForm.length()); [EOL]                 position += parsedFormLength; [EOL]                 found = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     oldPos = position; [EOL]     position = iAfterParser.parseInto(period, periodStr, position, locale); [EOL]     if (position < 0) { [EOL]         return position; [EOL]     } [EOL]     if (found && position == oldPos && parsedFormLength > 0) { [EOL]         return ~oldPos; [EOL]     } [EOL]     if (position > oldPos && !found && !iUseBefore) { [EOL]         return ~oldPos; [EOL]     } [EOL]     return position; [EOL] }
public int parseInto(ReadWritablePeriod period, String periodStr, int position, Locale locale) { [EOL]     int oldPos = position; [EOL]     position = iBeforeParser.parseInto(period, periodStr, position, locale); [EOL]     if (position < 0) { [EOL]         return position; [EOL]     } [EOL]     boolean found = false; [EOL]     int parsedFormLength = -1; [EOL]     if (position > oldPos) { [EOL]         String[] parsedForms = iParsedForms; [EOL]         int length = parsedForms.length; [EOL]         for (int i = 0; i < length; i++) { [EOL]             String parsedForm = parsedForms[i]; [EOL]             if ((parsedForm == null || parsedForm.length() == 0) || periodStr.regionMatches(true, position, parsedForm, 0, parsedForm.length())) { [EOL]                 parsedFormLength = (parsedForm == null ? 0 : parsedForm.length()); [EOL]                 position += parsedFormLength; [EOL]                 found = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     oldPos = position; [EOL]     position = iAfterParser.parseInto(period, periodStr, position, locale); [EOL]     if (position < 0) { [EOL]         return position; [EOL]     } [EOL]     if (found && position == oldPos && parsedFormLength > 0) { [EOL]         return ~oldPos; [EOL]     } [EOL]     if (position > oldPos && !found && !iUseBefore) { [EOL]         return ~oldPos; [EOL]     } [EOL]     return position; [EOL] }
public int parseInto(ReadWritablePeriod period, String periodStr, int position, Locale locale) { [EOL]     int oldPos = position; [EOL]     position = iBeforeParser.parseInto(period, periodStr, position, locale); [EOL]     if (position < 0) { [EOL]         return position; [EOL]     } [EOL]     boolean found = false; [EOL]     int parsedFormLength = -1; [EOL]     if (position > oldPos) { [EOL]         String[] parsedForms = iParsedForms; [EOL]         int length = parsedForms.length; [EOL]         for (int i = 0; i < length; i++) { [EOL]             String parsedForm = parsedForms[i]; [EOL]             if ((parsedForm == null || parsedForm.length() == 0) || periodStr.regionMatches(true, position, parsedForm, 0, parsedForm.length())) { [EOL]                 parsedFormLength = (parsedForm == null ? 0 : parsedForm.length()); [EOL]                 position += parsedFormLength; [EOL]                 found = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     oldPos = position; [EOL]     position = iAfterParser.parseInto(period, periodStr, position, locale); [EOL]     if (position < 0) { [EOL]         return position; [EOL]     } [EOL]     if (found && position == oldPos && parsedFormLength > 0) { [EOL]         return ~oldPos; [EOL]     } [EOL]     if (position > oldPos && !found && !iUseBefore) { [EOL]         return ~oldPos; [EOL]     } [EOL]     return position; [EOL] }
public int parseInto(ReadWritablePeriod period, String periodStr, int position, Locale locale) { [EOL]     int oldPos = position; [EOL]     position = iBeforeParser.parseInto(period, periodStr, position, locale); [EOL]     if (position < 0) { [EOL]         return position; [EOL]     } [EOL]     boolean found = false; [EOL]     int parsedFormLength = -1; [EOL]     if (position > oldPos) { [EOL]         String[] parsedForms = iParsedForms; [EOL]         int length = parsedForms.length; [EOL]         for (int i = 0; i < length; i++) { [EOL]             String parsedForm = parsedForms[i]; [EOL]             if ((parsedForm == null || parsedForm.length() == 0) || periodStr.regionMatches(true, position, parsedForm, 0, parsedForm.length())) { [EOL]                 parsedFormLength = (parsedForm == null ? 0 : parsedForm.length()); [EOL]                 position += parsedFormLength; [EOL]                 found = true; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     oldPos = position; [EOL]     position = iAfterParser.parseInto(period, periodStr, position, locale); [EOL]     if (position < 0) { [EOL]         return position; [EOL]     } [EOL]     if (found && position == oldPos && parsedFormLength > 0) { [EOL]         return ~oldPos; [EOL]     } [EOL]     if (position > oldPos && !found && !iUseBefore) { [EOL]         return ~oldPos; [EOL]     } [EOL]     return position; [EOL] }
public long add(long instant, int years) { [EOL]     if (years == 0) { [EOL]         return instant; [EOL]     } [EOL]     return set(instant, get(instant) + years); [EOL] }
public long add(long instant, int years) { [EOL]     if (years == 0) { [EOL]         return instant; [EOL]     } [EOL]     return set(instant, get(instant) + years); [EOL] }
public long add(long instant, int years) { [EOL]     if (years == 0) { [EOL]         return instant; [EOL]     } [EOL]     return set(instant, get(instant) + years); [EOL] }
public long addWrapField(long instant, int years) { [EOL]     return add(instant, years); [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     if (minuendInstant < subtrahendInstant) { [EOL]         return -getDifference(subtrahendInstant, minuendInstant); [EOL]     } [EOL]     int minuendWeekyear = get(minuendInstant); [EOL]     int subtrahendWeekyear = get(subtrahendInstant); [EOL]     long minuendRem = remainder(minuendInstant); [EOL]     long subtrahendRem = remainder(subtrahendInstant); [EOL]     if (subtrahendRem >= WEEK_53 && iChronology.getWeeksInYear(minuendWeekyear) <= 52) { [EOL]         subtrahendRem -= DateTimeConstants.MILLIS_PER_WEEK; [EOL]     } [EOL]     int difference = minuendWeekyear - subtrahendWeekyear; [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     if (minuendInstant < subtrahendInstant) { [EOL]         return -getDifference(subtrahendInstant, minuendInstant); [EOL]     } [EOL]     int minuendWeekyear = get(minuendInstant); [EOL]     int subtrahendWeekyear = get(subtrahendInstant); [EOL]     long minuendRem = remainder(minuendInstant); [EOL]     long subtrahendRem = remainder(subtrahendInstant); [EOL]     if (subtrahendRem >= WEEK_53 && iChronology.getWeeksInYear(minuendWeekyear) <= 52) { [EOL]         subtrahendRem -= DateTimeConstants.MILLIS_PER_WEEK; [EOL]     } [EOL]     int difference = minuendWeekyear - subtrahendWeekyear; [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     if (minuendInstant < subtrahendInstant) { [EOL]         return -getDifference(subtrahendInstant, minuendInstant); [EOL]     } [EOL]     int minuendWeekyear = get(minuendInstant); [EOL]     int subtrahendWeekyear = get(subtrahendInstant); [EOL]     long minuendRem = remainder(minuendInstant); [EOL]     long subtrahendRem = remainder(subtrahendInstant); [EOL]     if (subtrahendRem >= WEEK_53 && iChronology.getWeeksInYear(minuendWeekyear) <= 52) { [EOL]         subtrahendRem -= DateTimeConstants.MILLIS_PER_WEEK; [EOL]     } [EOL]     int difference = minuendWeekyear - subtrahendWeekyear; [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     if (minuendInstant < subtrahendInstant) { [EOL]         return -getDifference(subtrahendInstant, minuendInstant); [EOL]     } [EOL]     int minuendWeekyear = get(minuendInstant); [EOL]     int subtrahendWeekyear = get(subtrahendInstant); [EOL]     long minuendRem = remainder(minuendInstant); [EOL]     long subtrahendRem = remainder(subtrahendInstant); [EOL]     if (subtrahendRem >= WEEK_53 && iChronology.getWeeksInYear(minuendWeekyear) <= 52) { [EOL]         subtrahendRem -= DateTimeConstants.MILLIS_PER_WEEK; [EOL]     } [EOL]     int difference = minuendWeekyear - subtrahendWeekyear; [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }
public long set(long instant, int year) { [EOL]     FieldUtils.verifyValueBounds(this, Math.abs(year), iChronology.getMinYear(), iChronology.getMaxYear()); [EOL]     int thisWeekyear = get(instant); [EOL]     if (thisWeekyear == year) { [EOL]         return instant; [EOL]     } [EOL]     int thisDow = iChronology.getDayOfWeek(instant); [EOL]     int weeksInFromYear = iChronology.getWeeksInYear(thisWeekyear); [EOL]     int weeksInToYear = iChronology.getWeeksInYear(year); [EOL]     int maxOutWeeks = (weeksInToYear < weeksInFromYear) ? weeksInToYear : weeksInFromYear; [EOL]     int setToWeek = iChronology.getWeekOfWeekyear(instant); [EOL]     if (setToWeek > maxOutWeeks) { [EOL]         setToWeek = maxOutWeeks; [EOL]     } [EOL]     long workInstant = instant; [EOL]     workInstant = iChronology.setYear(workInstant, year); [EOL]     int workWoyYear = get(workInstant); [EOL]     if (workWoyYear < year) { [EOL]         workInstant += DateTimeConstants.MILLIS_PER_WEEK; [EOL]     } else if (workWoyYear > year) { [EOL]         workInstant -= DateTimeConstants.MILLIS_PER_WEEK; [EOL]     } [EOL]     int currentWoyWeek = iChronology.getWeekOfWeekyear(workInstant); [EOL]     workInstant = workInstant + (setToWeek - currentWoyWeek) * (long) DateTimeConstants.MILLIS_PER_WEEK; [EOL]     workInstant = iChronology.dayOfWeek().set(workInstant, thisDow); [EOL]     return workInstant; [EOL] }
public boolean isLeap(long instant) { [EOL]     return iChronology.getWeeksInYear(iChronology.getWeekyear(instant)) > 52; [EOL] }
public boolean isLeap(long instant) { [EOL]     return iChronology.getWeeksInYear(iChronology.getWeekyear(instant)) > 52; [EOL] }
public int getLeapAmount(long instant) { [EOL]     return iChronology.getWeeksInYear(iChronology.getWeekyear(instant)) - 52; [EOL] }
public long remainder(long instant) { [EOL]     return instant - roundFloor(instant); [EOL] }
public long remainder(long instant) { [EOL]     return instant - roundFloor(instant); [EOL] }
public long remainder(long instant) { [EOL]     return instant - roundFloor(instant); [EOL] }
public static DateTimeFormatter shortTime() { [EOL]     return createFormatterForStyleIndex(NONE, SHORT); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
protected DateTimeFormat() { [EOL]     super(); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) { [EOL]     int length = pattern.length(); [EOL]     int[] indexRef = new int[1]; [EOL]     for (int i = 0; i < length; i++) { [EOL]         indexRef[0] = i; [EOL]         String token = parseToken(pattern, indexRef); [EOL]         i = indexRef[0]; [EOL]         int tokenLen = token.length(); [EOL]         if (tokenLen == 0) { [EOL]             break; [EOL]         } [EOL]         char c = token.charAt(0); [EOL]         switch(c) { [EOL]             case 'G': [EOL]                 builder.appendEraText(); [EOL]                 break; [EOL]             case 'C': [EOL]                 builder.appendCenturyOfEra(tokenLen, tokenLen); [EOL]                 break; [EOL]             case 'x': [EOL]             case 'y': [EOL]             case 'Y': [EOL]                 if (tokenLen == 2) { [EOL]                     boolean lenientParse = true; [EOL]                     if (i + 1 < length) { [EOL]                         indexRef[0]++; [EOL]                         if (isNumericToken(parseToken(pattern, indexRef))) { [EOL]                             lenientParse = false; [EOL]                         } [EOL]                         indexRef[0]--; [EOL]                     } [EOL]                     switch(c) { [EOL]                         case 'x': [EOL]                             builder.appendTwoDigitWeekyear(new DateTime().getWeekyear() - 30, lenientParse); [EOL]                             break; [EOL]                         case 'y': [EOL]                         case 'Y': [EOL]                         default: [EOL]                             builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse); [EOL]                             break; [EOL]                     } [EOL]                 } else { [EOL]                     int maxDigits = 9; [EOL]                     if (i + 1 < length) { [EOL]                         indexRef[0]++; [EOL]                         if (isNumericToken(parseToken(pattern, indexRef))) { [EOL]                             maxDigits = tokenLen; [EOL]                         } [EOL]                         indexRef[0]--; [EOL]                     } [EOL]                     switch(c) { [EOL]                         case 'x': [EOL]                             builder.appendWeekyear(tokenLen, maxDigits); [EOL]                             break; [EOL]                         case 'y': [EOL]                             builder.appendYear(tokenLen, maxDigits); [EOL]                             break; [EOL]                         case 'Y': [EOL]                             builder.appendYearOfEra(tokenLen, maxDigits); [EOL]                             break; [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case 'M': [EOL]                 if (tokenLen >= 3) { [EOL]                     if (tokenLen >= 4) { [EOL]                         builder.appendMonthOfYearText(); [EOL]                     } else { [EOL]                         builder.appendMonthOfYearShortText(); [EOL]                     } [EOL]                 } else { [EOL]                     builder.appendMonthOfYear(tokenLen); [EOL]                 } [EOL]                 break; [EOL]             case 'd': [EOL]                 builder.appendDayOfMonth(tokenLen); [EOL]                 break; [EOL]             case 'a': [EOL]                 builder.appendHalfdayOfDayText(); [EOL]                 break; [EOL]             case 'h': [EOL]                 builder.appendClockhourOfHalfday(tokenLen); [EOL]                 break; [EOL]             case 'H': [EOL]                 builder.appendHourOfDay(tokenLen); [EOL]                 break; [EOL]             case 'k': [EOL]                 builder.appendClockhourOfDay(tokenLen); [EOL]                 break; [EOL]             case 'K': [EOL]                 builder.appendHourOfHalfday(tokenLen); [EOL]                 break; [EOL]             case 'm': [EOL]                 builder.appendMinuteOfHour(tokenLen); [EOL]                 break; [EOL]             case 's': [EOL]                 builder.appendSecondOfMinute(tokenLen); [EOL]                 break; [EOL]             case 'S': [EOL]                 builder.appendFractionOfSecond(tokenLen, tokenLen); [EOL]                 break; [EOL]             case 'e': [EOL]                 builder.appendDayOfWeek(tokenLen); [EOL]                 break; [EOL]             case 'E': [EOL]                 if (tokenLen >= 4) { [EOL]                     builder.appendDayOfWeekText(); [EOL]                 } else { [EOL]                     builder.appendDayOfWeekShortText(); [EOL]                 } [EOL]                 break; [EOL]             case 'D': [EOL]                 builder.appendDayOfYear(tokenLen); [EOL]                 break; [EOL]             case 'w': [EOL]                 builder.appendWeekOfWeekyear(tokenLen); [EOL]                 break; [EOL]             case 'z': [EOL]                 if (tokenLen >= 4) { [EOL]                     builder.appendTimeZoneName(); [EOL]                 } else { [EOL]                     builder.appendTimeZoneShortName(null); [EOL]                 } [EOL]                 break; [EOL]             case 'Z': [EOL]                 if (tokenLen == 1) { [EOL]                     builder.appendTimeZoneOffset(null, "Z", false, 2, 2); [EOL]                 } else if (tokenLen == 2) { [EOL]                     builder.appendTimeZoneOffset(null, "Z", true, 2, 2); [EOL]                 } else { [EOL]                     builder.appendTimeZoneId(); [EOL]                 } [EOL]                 break; [EOL]             case '\'': [EOL]                 String sub = token.substring(1); [EOL]                 if (sub.length() == 1) { [EOL]                     builder.appendLiteral(sub.charAt(0)); [EOL]                 } else { [EOL]                     builder.appendLiteral(new String(sub)); [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 throw new IllegalArgumentException("Illegal pattern component: " + token); [EOL]         } [EOL]     } [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static DateTimeFormatter createFormatterForStyle(String style) { [EOL]     if (style == null || style.length() != 2) { [EOL]         throw new IllegalArgumentException("Invalid style specification: " + style); [EOL]     } [EOL]     int dateStyle = selectStyle(style.charAt(0)); [EOL]     int timeStyle = selectStyle(style.charAt(1)); [EOL]     if (dateStyle == NONE && timeStyle == NONE) { [EOL]         throw new IllegalArgumentException("Style '--' is invalid"); [EOL]     } [EOL]     return createFormatterForStyleIndex(dateStyle, timeStyle); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static DateTimeFormatter createFormatterForStyle(String style) { [EOL]     if (style == null || style.length() != 2) { [EOL]         throw new IllegalArgumentException("Invalid style specification: " + style); [EOL]     } [EOL]     int dateStyle = selectStyle(style.charAt(0)); [EOL]     int timeStyle = selectStyle(style.charAt(1)); [EOL]     if (dateStyle == NONE && timeStyle == NONE) { [EOL]         throw new IllegalArgumentException("Style '--' is invalid"); [EOL]     } [EOL]     return createFormatterForStyleIndex(dateStyle, timeStyle); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static DateTimeFormatter createFormatterForStyle(String style) { [EOL]     if (style == null || style.length() != 2) { [EOL]         throw new IllegalArgumentException("Invalid style specification: " + style); [EOL]     } [EOL]     int dateStyle = selectStyle(style.charAt(0)); [EOL]     int timeStyle = selectStyle(style.charAt(1)); [EOL]     if (dateStyle == NONE && timeStyle == NONE) { [EOL]         throw new IllegalArgumentException("Style '--' is invalid"); [EOL]     } [EOL]     return createFormatterForStyleIndex(dateStyle, timeStyle); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
private static DateTimeFormatter createFormatterForStyle(String style) { [EOL]     if (style == null || style.length() != 2) { [EOL]         throw new IllegalArgumentException("Invalid style specification: " + style); [EOL]     } [EOL]     int dateStyle = selectStyle(style.charAt(0)); [EOL]     int timeStyle = selectStyle(style.charAt(1)); [EOL]     if (dateStyle == NONE && timeStyle == NONE) { [EOL]         throw new IllegalArgumentException("Style '--' is invalid"); [EOL]     } [EOL]     return createFormatterForStyleIndex(dateStyle, timeStyle); [EOL] } protected DateTimeFormat();  StyleFormatter(int dateStyle, int timeStyle, int type); protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest); public static DateTimeFormatter forPattern(String pattern); public static DateTimeFormatter forStyle(String style); public static String patternForStyle(String style, Locale locale); public static DateTimeFormatter shortDate(); public static DateTimeFormatter shortTime(); public static DateTimeFormatter shortDateTime(); public static DateTimeFormatter mediumDate(); public static DateTimeFormatter mediumTime(); public static DateTimeFormatter mediumDateTime(); public static DateTimeFormatter longDate(); public static DateTimeFormatter longTime(); public static DateTimeFormatter longDateTime(); public static DateTimeFormatter fullDate(); public static DateTimeFormatter fullTime(); public static DateTimeFormatter fullDateTime();  static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern); private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern); private static String parseToken(String pattern, int[] indexRef); private static boolean isNumericToken(String token); private static DateTimeFormatter createFormatterForPattern(String pattern); private static DateTimeFormatter createFormatterForStyle(String style); private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle); private static DateTimeFormatter createDateTimeFormatter(int dateStyle, int timeStyle); private static int selectStyle(char ch); public int estimatePrintedLength(); public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale); public void printTo(Writer out, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException; public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale); public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException; public int estimateParsedLength(); public int parseInto(DateTimeParserBucket bucket, String text, int position); private DateTimeFormatter getFormatter(Locale locale);  String getPattern(Locale locale); int FULL=Optional[0]; int LONG=Optional[1]; int MEDIUM=Optional[2]; int SHORT=Optional[3]; int NONE=Optional[4]; int DATE=Optional[0]; int TIME=Optional[1]; int DATETIME=Optional[2]; int PATTERN_CACHE_SIZE=Optional[500]; Map<String, DateTimeFormatter> PATTERN_CACHE=Optional[new LinkedHashMap<String, DateTimeFormatter>(7) {; ;     private static final long serialVersionUID = 23L;; ;     @Override;     protected boolean removeEldestEntry(final Map.Entry<String, DateTimeFormatter> eldest) {;         return size() > PATTERN_CACHE_SIZE;;     }; }
public static Duration standardDays(long days) { [EOL]     if (days == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     return new Duration(FieldUtils.safeMultiply(days, DateTimeConstants.MILLIS_PER_DAY)); [EOL] }
public static Duration standardDays(long days) { [EOL]     if (days == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     return new Duration(FieldUtils.safeMultiply(days, DateTimeConstants.MILLIS_PER_DAY)); [EOL] }
public static Duration standardDays(long days) { [EOL]     if (days == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     return new Duration(FieldUtils.safeMultiply(days, DateTimeConstants.MILLIS_PER_DAY)); [EOL] }
public static Duration standardDays(long days) { [EOL]     if (days == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     return new Duration(FieldUtils.safeMultiply(days, DateTimeConstants.MILLIS_PER_DAY)); [EOL] }
public static Duration standardDays(long days) { [EOL]     if (days == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     return new Duration(FieldUtils.safeMultiply(days, DateTimeConstants.MILLIS_PER_DAY)); [EOL] }
public static Duration millis(long millis) { [EOL]     if (millis == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     return new Duration(millis); [EOL] }
public static Duration millis(long millis) { [EOL]     if (millis == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     return new Duration(millis); [EOL] }
public static Duration millis(long millis) { [EOL]     if (millis == 0) { [EOL]         return ZERO; [EOL]     } [EOL]     return new Duration(millis); [EOL] }
public Duration(ReadableInstant start, ReadableInstant end) { [EOL]     super(start, end); [EOL] }
public Duration(ReadableInstant start, ReadableInstant end) { [EOL]     super(start, end); [EOL] }
public Duration(ReadableInstant start, ReadableInstant end) { [EOL]     super(start, end); [EOL] }
public Duration(Object duration) { [EOL]     super(duration); [EOL] }
public long getStandardDays() { [EOL]     return getMillis() / DateTimeConstants.MILLIS_PER_DAY; [EOL] }
public Days toStandardDays() { [EOL]     long days = getStandardDays(); [EOL]     return Days.days(FieldUtils.safeToInt(days)); [EOL] }
public Days toStandardDays() { [EOL]     long days = getStandardDays(); [EOL]     return Days.days(FieldUtils.safeToInt(days)); [EOL] }
public Days toStandardDays() { [EOL]     long days = getStandardDays(); [EOL]     return Days.days(FieldUtils.safeToInt(days)); [EOL] }
public Duration withMillis(long duration) { [EOL]     if (duration == getMillis()) { [EOL]         return this; [EOL]     } [EOL]     return new Duration(duration); [EOL] }
public Duration withMillis(long duration) { [EOL]     if (duration == getMillis()) { [EOL]         return this; [EOL]     } [EOL]     return new Duration(duration); [EOL] }
public Duration withDurationAdded(ReadableDuration durationToAdd, int scalar) { [EOL]     if (durationToAdd == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     return withDurationAdded(durationToAdd.getMillis(), scalar); [EOL] }
public Duration withDurationAdded(ReadableDuration durationToAdd, int scalar) { [EOL]     if (durationToAdd == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     return withDurationAdded(durationToAdd.getMillis(), scalar); [EOL] }
public Duration withDurationAdded(ReadableDuration durationToAdd, int scalar) { [EOL]     if (durationToAdd == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     return withDurationAdded(durationToAdd.getMillis(), scalar); [EOL] }
public Duration minus(ReadableDuration amount) { [EOL]     if (amount == null) { [EOL]         return this; [EOL]     } [EOL]     return withDurationAdded(amount.getMillis(), -1); [EOL] }
public Duration minus(ReadableDuration amount) { [EOL]     if (amount == null) { [EOL]         return this; [EOL]     } [EOL]     return withDurationAdded(amount.getMillis(), -1); [EOL] }
protected ISOPeriodFormat() { [EOL]     super(); [EOL] }
public static PeriodFormatter standard() { [EOL]     if (cStandard == null) { [EOL]         cStandard = new PeriodFormatterBuilder().appendLiteral("P").appendYears().appendSuffix("Y").appendMonths().appendSuffix("M").appendWeeks().appendSuffix("W").appendDays().appendSuffix("D").appendSeparatorIfFieldsAfter("T").appendHours().appendSuffix("H").appendMinutes().appendSuffix("M").appendSecondsWithOptionalMillis().appendSuffix("S").toFormatter(); [EOL]     } [EOL]     return cStandard; [EOL] }
public static PeriodFormatter alternate() { [EOL]     if (cAlternate == null) { [EOL]         cAlternate = new PeriodFormatterBuilder().appendLiteral("P").printZeroAlways().minimumPrintedDigits(4).appendYears().minimumPrintedDigits(2).appendMonths().appendDays().appendSeparatorIfFieldsAfter("T").appendHours().appendMinutes().appendSecondsWithOptionalMillis().toFormatter(); [EOL]     } [EOL]     return cAlternate; [EOL] }
public static PeriodFormatter alternate() { [EOL]     if (cAlternate == null) { [EOL]         cAlternate = new PeriodFormatterBuilder().appendLiteral("P").printZeroAlways().minimumPrintedDigits(4).appendYears().minimumPrintedDigits(2).appendMonths().appendDays().appendSeparatorIfFieldsAfter("T").appendHours().appendMinutes().appendSecondsWithOptionalMillis().toFormatter(); [EOL]     } [EOL]     return cAlternate; [EOL] }
public static PeriodFormatter alternateWithWeeks() { [EOL]     if (cAlternateWithWeeks == null) { [EOL]         cAlternateWithWeeks = new PeriodFormatterBuilder().appendLiteral("P").printZeroAlways().minimumPrintedDigits(4).appendYears().minimumPrintedDigits(2).appendPrefix("W").appendWeeks().appendDays().appendSeparatorIfFieldsAfter("T").appendHours().appendMinutes().appendSecondsWithOptionalMillis().toFormatter(); [EOL]     } [EOL]     return cAlternateWithWeeks; [EOL] }
public long next(long instant, int standardOffset, int saveMillis) { [EOL]     int offset; [EOL]     if (iMode == 'w') { [EOL]         offset = standardOffset + saveMillis; [EOL]     } else if (iMode == 's') { [EOL]         offset = standardOffset; [EOL]     } else { [EOL]         offset = 0; [EOL]     } [EOL]     instant += offset; [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     long next = chrono.monthOfYear().set(instant, iMonthOfYear); [EOL]     next = chrono.millisOfDay().set(next, 0); [EOL]     next = chrono.millisOfDay().add(next, iMillisOfDay); [EOL]     next = setDayOfMonthNext(chrono, next); [EOL]     if (iDayOfWeek == 0) { [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]         } [EOL]     } else { [EOL]         next = setDayOfWeek(chrono, next); [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = chrono.monthOfYear().set(next, iMonthOfYear); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]             next = setDayOfWeek(chrono, next); [EOL]         } [EOL]     } [EOL]     return next - offset; [EOL] }
public long next(long instant, int standardOffset, int saveMillis) { [EOL]     int offset; [EOL]     if (iMode == 'w') { [EOL]         offset = standardOffset + saveMillis; [EOL]     } else if (iMode == 's') { [EOL]         offset = standardOffset; [EOL]     } else { [EOL]         offset = 0; [EOL]     } [EOL]     instant += offset; [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     long next = chrono.monthOfYear().set(instant, iMonthOfYear); [EOL]     next = chrono.millisOfDay().set(next, 0); [EOL]     next = chrono.millisOfDay().add(next, iMillisOfDay); [EOL]     next = setDayOfMonthNext(chrono, next); [EOL]     if (iDayOfWeek == 0) { [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]         } [EOL]     } else { [EOL]         next = setDayOfWeek(chrono, next); [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = chrono.monthOfYear().set(next, iMonthOfYear); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]             next = setDayOfWeek(chrono, next); [EOL]         } [EOL]     } [EOL]     return next - offset; [EOL] }
public long next(long instant, int standardOffset, int saveMillis) { [EOL]     int offset; [EOL]     if (iMode == 'w') { [EOL]         offset = standardOffset + saveMillis; [EOL]     } else if (iMode == 's') { [EOL]         offset = standardOffset; [EOL]     } else { [EOL]         offset = 0; [EOL]     } [EOL]     instant += offset; [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     long next = chrono.monthOfYear().set(instant, iMonthOfYear); [EOL]     next = chrono.millisOfDay().set(next, 0); [EOL]     next = chrono.millisOfDay().add(next, iMillisOfDay); [EOL]     next = setDayOfMonthNext(chrono, next); [EOL]     if (iDayOfWeek == 0) { [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]         } [EOL]     } else { [EOL]         next = setDayOfWeek(chrono, next); [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = chrono.monthOfYear().set(next, iMonthOfYear); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]             next = setDayOfWeek(chrono, next); [EOL]         } [EOL]     } [EOL]     return next - offset; [EOL] }
public long next(long instant, int standardOffset, int saveMillis) { [EOL]     int offset; [EOL]     if (iMode == 'w') { [EOL]         offset = standardOffset + saveMillis; [EOL]     } else if (iMode == 's') { [EOL]         offset = standardOffset; [EOL]     } else { [EOL]         offset = 0; [EOL]     } [EOL]     instant += offset; [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     long next = chrono.monthOfYear().set(instant, iMonthOfYear); [EOL]     next = chrono.millisOfDay().set(next, 0); [EOL]     next = chrono.millisOfDay().add(next, iMillisOfDay); [EOL]     next = setDayOfMonthNext(chrono, next); [EOL]     if (iDayOfWeek == 0) { [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]         } [EOL]     } else { [EOL]         next = setDayOfWeek(chrono, next); [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = chrono.monthOfYear().set(next, iMonthOfYear); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]             next = setDayOfWeek(chrono, next); [EOL]         } [EOL]     } [EOL]     return next - offset; [EOL] }
public long next(long instant, int standardOffset, int saveMillis) { [EOL]     int offset; [EOL]     if (iMode == 'w') { [EOL]         offset = standardOffset + saveMillis; [EOL]     } else if (iMode == 's') { [EOL]         offset = standardOffset; [EOL]     } else { [EOL]         offset = 0; [EOL]     } [EOL]     instant += offset; [EOL]     Chronology chrono = ISOChronology.getInstanceUTC(); [EOL]     long next = chrono.monthOfYear().set(instant, iMonthOfYear); [EOL]     next = chrono.millisOfDay().set(next, 0); [EOL]     next = chrono.millisOfDay().add(next, iMillisOfDay); [EOL]     next = setDayOfMonthNext(chrono, next); [EOL]     if (iDayOfWeek == 0) { [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]         } [EOL]     } else { [EOL]         next = setDayOfWeek(chrono, next); [EOL]         if (next <= instant) { [EOL]             next = chrono.year().add(next, 1); [EOL]             next = chrono.monthOfYear().set(next, iMonthOfYear); [EOL]             next = setDayOfMonthNext(chrono, next); [EOL]             next = setDayOfWeek(chrono, next); [EOL]         } [EOL]     } [EOL]     return next - offset; [EOL] }
public String getNameKey(long instant) { [EOL]     return findMatchingRecurrence(instant).getNameKey(); [EOL] }
public int getOffset(long instant) { [EOL]     return iStandardOffset + findMatchingRecurrence(instant).getSaveMillis(); [EOL] }
public int getOffset(long instant) { [EOL]     return iStandardOffset + findMatchingRecurrence(instant).getSaveMillis(); [EOL] }
public long nextTransition(long instant) { [EOL]     int standardOffset = iStandardOffset; [EOL]     Recurrence startRecurrence = iStartRecurrence; [EOL]     Recurrence endRecurrence = iEndRecurrence; [EOL]     long start, end; [EOL]     try { [EOL]         start = startRecurrence.next(instant, standardOffset, endRecurrence.getSaveMillis()); [EOL]         if (instant > 0 && start < 0) { [EOL]             start = instant; [EOL]         } [EOL]     } catch (IllegalArgumentException e) { [EOL]         start = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         start = instant; [EOL]     } [EOL]     try { [EOL]         end = endRecurrence.next(instant, standardOffset, startRecurrence.getSaveMillis()); [EOL]         if (instant > 0 && end < 0) { [EOL]             end = instant; [EOL]         } [EOL]     } catch (IllegalArgumentException e) { [EOL]         end = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         end = instant; [EOL]     } [EOL]     return (start > end) ? end : start; [EOL] }
public long nextTransition(long instant) { [EOL]     int standardOffset = iStandardOffset; [EOL]     Recurrence startRecurrence = iStartRecurrence; [EOL]     Recurrence endRecurrence = iEndRecurrence; [EOL]     long start, end; [EOL]     try { [EOL]         start = startRecurrence.next(instant, standardOffset, endRecurrence.getSaveMillis()); [EOL]         if (instant > 0 && start < 0) { [EOL]             start = instant; [EOL]         } [EOL]     } catch (IllegalArgumentException e) { [EOL]         start = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         start = instant; [EOL]     } [EOL]     try { [EOL]         end = endRecurrence.next(instant, standardOffset, startRecurrence.getSaveMillis()); [EOL]         if (instant > 0 && end < 0) { [EOL]             end = instant; [EOL]         } [EOL]     } catch (IllegalArgumentException e) { [EOL]         end = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         end = instant; [EOL]     } [EOL]     return (start > end) ? end : start; [EOL] }
public long nextTransition(long instant) { [EOL]     int standardOffset = iStandardOffset; [EOL]     Recurrence startRecurrence = iStartRecurrence; [EOL]     Recurrence endRecurrence = iEndRecurrence; [EOL]     long start, end; [EOL]     try { [EOL]         start = startRecurrence.next(instant, standardOffset, endRecurrence.getSaveMillis()); [EOL]         if (instant > 0 && start < 0) { [EOL]             start = instant; [EOL]         } [EOL]     } catch (IllegalArgumentException e) { [EOL]         start = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         start = instant; [EOL]     } [EOL]     try { [EOL]         end = endRecurrence.next(instant, standardOffset, startRecurrence.getSaveMillis()); [EOL]         if (instant > 0 && end < 0) { [EOL]             end = instant; [EOL]         } [EOL]     } catch (IllegalArgumentException e) { [EOL]         end = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         end = instant; [EOL]     } [EOL]     return (start > end) ? end : start; [EOL] }
public long nextTransition(long instant) { [EOL]     int standardOffset = iStandardOffset; [EOL]     Recurrence startRecurrence = iStartRecurrence; [EOL]     Recurrence endRecurrence = iEndRecurrence; [EOL]     long start, end; [EOL]     try { [EOL]         start = startRecurrence.next(instant, standardOffset, endRecurrence.getSaveMillis()); [EOL]         if (instant > 0 && start < 0) { [EOL]             start = instant; [EOL]         } [EOL]     } catch (IllegalArgumentException e) { [EOL]         start = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         start = instant; [EOL]     } [EOL]     try { [EOL]         end = endRecurrence.next(instant, standardOffset, startRecurrence.getSaveMillis()); [EOL]         if (instant > 0 && end < 0) { [EOL]             end = instant; [EOL]         } [EOL]     } catch (IllegalArgumentException e) { [EOL]         end = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         end = instant; [EOL]     } [EOL]     return (start > end) ? end : start; [EOL] }
public long nextTransition(long instant) { [EOL]     int standardOffset = iStandardOffset; [EOL]     Recurrence startRecurrence = iStartRecurrence; [EOL]     Recurrence endRecurrence = iEndRecurrence; [EOL]     long start, end; [EOL]     try { [EOL]         start = startRecurrence.next(instant, standardOffset, endRecurrence.getSaveMillis()); [EOL]         if (instant > 0 && start < 0) { [EOL]             start = instant; [EOL]         } [EOL]     } catch (IllegalArgumentException e) { [EOL]         start = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         start = instant; [EOL]     } [EOL]     try { [EOL]         end = endRecurrence.next(instant, standardOffset, startRecurrence.getSaveMillis()); [EOL]         if (instant > 0 && end < 0) { [EOL]             end = instant; [EOL]         } [EOL]     } catch (IllegalArgumentException e) { [EOL]         end = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         end = instant; [EOL]     } [EOL]     return (start > end) ? end : start; [EOL] }
public long nextTransition(long instant) { [EOL]     int standardOffset = iStandardOffset; [EOL]     Recurrence startRecurrence = iStartRecurrence; [EOL]     Recurrence endRecurrence = iEndRecurrence; [EOL]     long start, end; [EOL]     try { [EOL]         start = startRecurrence.next(instant, standardOffset, endRecurrence.getSaveMillis()); [EOL]         if (instant > 0 && start < 0) { [EOL]             start = instant; [EOL]         } [EOL]     } catch (IllegalArgumentException e) { [EOL]         start = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         start = instant; [EOL]     } [EOL]     try { [EOL]         end = endRecurrence.next(instant, standardOffset, startRecurrence.getSaveMillis()); [EOL]         if (instant > 0 && end < 0) { [EOL]             end = instant; [EOL]         } [EOL]     } catch (IllegalArgumentException e) { [EOL]         end = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         end = instant; [EOL]     } [EOL]     return (start > end) ? end : start; [EOL] }
public long nextTransition(long instant) { [EOL]     int standardOffset = iStandardOffset; [EOL]     Recurrence startRecurrence = iStartRecurrence; [EOL]     Recurrence endRecurrence = iEndRecurrence; [EOL]     long start, end; [EOL]     try { [EOL]         start = startRecurrence.next(instant, standardOffset, endRecurrence.getSaveMillis()); [EOL]         if (instant > 0 && start < 0) { [EOL]             start = instant; [EOL]         } [EOL]     } catch (IllegalArgumentException e) { [EOL]         start = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         start = instant; [EOL]     } [EOL]     try { [EOL]         end = endRecurrence.next(instant, standardOffset, startRecurrence.getSaveMillis()); [EOL]         if (instant > 0 && end < 0) { [EOL]             end = instant; [EOL]         } [EOL]     } catch (IllegalArgumentException e) { [EOL]         end = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         end = instant; [EOL]     } [EOL]     return (start > end) ? end : start; [EOL] }
public long nextTransition(long instant) { [EOL]     int standardOffset = iStandardOffset; [EOL]     Recurrence startRecurrence = iStartRecurrence; [EOL]     Recurrence endRecurrence = iEndRecurrence; [EOL]     long start, end; [EOL]     try { [EOL]         start = startRecurrence.next(instant, standardOffset, endRecurrence.getSaveMillis()); [EOL]         if (instant > 0 && start < 0) { [EOL]             start = instant; [EOL]         } [EOL]     } catch (IllegalArgumentException e) { [EOL]         start = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         start = instant; [EOL]     } [EOL]     try { [EOL]         end = endRecurrence.next(instant, standardOffset, startRecurrence.getSaveMillis()); [EOL]         if (instant > 0 && end < 0) { [EOL]             end = instant; [EOL]         } [EOL]     } catch (IllegalArgumentException e) { [EOL]         end = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         end = instant; [EOL]     } [EOL]     return (start > end) ? end : start; [EOL] }
private Recurrence findMatchingRecurrence(long instant) { [EOL]     int standardOffset = iStandardOffset; [EOL]     Recurrence startRecurrence = iStartRecurrence; [EOL]     Recurrence endRecurrence = iEndRecurrence; [EOL]     long start, end; [EOL]     try { [EOL]         start = startRecurrence.next(instant, standardOffset, endRecurrence.getSaveMillis()); [EOL]     } catch (IllegalArgumentException e) { [EOL]         start = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         start = instant; [EOL]     } [EOL]     try { [EOL]         end = endRecurrence.next(instant, standardOffset, startRecurrence.getSaveMillis()); [EOL]     } catch (IllegalArgumentException e) { [EOL]         end = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         end = instant; [EOL]     } [EOL]     return (start > end) ? startRecurrence : endRecurrence; [EOL] }
private Recurrence findMatchingRecurrence(long instant) { [EOL]     int standardOffset = iStandardOffset; [EOL]     Recurrence startRecurrence = iStartRecurrence; [EOL]     Recurrence endRecurrence = iEndRecurrence; [EOL]     long start, end; [EOL]     try { [EOL]         start = startRecurrence.next(instant, standardOffset, endRecurrence.getSaveMillis()); [EOL]     } catch (IllegalArgumentException e) { [EOL]         start = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         start = instant; [EOL]     } [EOL]     try { [EOL]         end = endRecurrence.next(instant, standardOffset, startRecurrence.getSaveMillis()); [EOL]     } catch (IllegalArgumentException e) { [EOL]         end = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         end = instant; [EOL]     } [EOL]     return (start > end) ? startRecurrence : endRecurrence; [EOL] }
private Recurrence findMatchingRecurrence(long instant) { [EOL]     int standardOffset = iStandardOffset; [EOL]     Recurrence startRecurrence = iStartRecurrence; [EOL]     Recurrence endRecurrence = iEndRecurrence; [EOL]     long start, end; [EOL]     try { [EOL]         start = startRecurrence.next(instant, standardOffset, endRecurrence.getSaveMillis()); [EOL]     } catch (IllegalArgumentException e) { [EOL]         start = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         start = instant; [EOL]     } [EOL]     try { [EOL]         end = endRecurrence.next(instant, standardOffset, startRecurrence.getSaveMillis()); [EOL]     } catch (IllegalArgumentException e) { [EOL]         end = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         end = instant; [EOL]     } [EOL]     return (start > end) ? startRecurrence : endRecurrence; [EOL] }
private Recurrence findMatchingRecurrence(long instant) { [EOL]     int standardOffset = iStandardOffset; [EOL]     Recurrence startRecurrence = iStartRecurrence; [EOL]     Recurrence endRecurrence = iEndRecurrence; [EOL]     long start, end; [EOL]     try { [EOL]         start = startRecurrence.next(instant, standardOffset, endRecurrence.getSaveMillis()); [EOL]     } catch (IllegalArgumentException e) { [EOL]         start = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         start = instant; [EOL]     } [EOL]     try { [EOL]         end = endRecurrence.next(instant, standardOffset, startRecurrence.getSaveMillis()); [EOL]     } catch (IllegalArgumentException e) { [EOL]         end = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         end = instant; [EOL]     } [EOL]     return (start > end) ? startRecurrence : endRecurrence; [EOL] }
private Recurrence findMatchingRecurrence(long instant) { [EOL]     int standardOffset = iStandardOffset; [EOL]     Recurrence startRecurrence = iStartRecurrence; [EOL]     Recurrence endRecurrence = iEndRecurrence; [EOL]     long start, end; [EOL]     try { [EOL]         start = startRecurrence.next(instant, standardOffset, endRecurrence.getSaveMillis()); [EOL]     } catch (IllegalArgumentException e) { [EOL]         start = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         start = instant; [EOL]     } [EOL]     try { [EOL]         end = endRecurrence.next(instant, standardOffset, startRecurrence.getSaveMillis()); [EOL]     } catch (IllegalArgumentException e) { [EOL]         end = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         end = instant; [EOL]     } [EOL]     return (start > end) ? startRecurrence : endRecurrence; [EOL] }
private Recurrence findMatchingRecurrence(long instant) { [EOL]     int standardOffset = iStandardOffset; [EOL]     Recurrence startRecurrence = iStartRecurrence; [EOL]     Recurrence endRecurrence = iEndRecurrence; [EOL]     long start, end; [EOL]     try { [EOL]         start = startRecurrence.next(instant, standardOffset, endRecurrence.getSaveMillis()); [EOL]     } catch (IllegalArgumentException e) { [EOL]         start = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         start = instant; [EOL]     } [EOL]     try { [EOL]         end = endRecurrence.next(instant, standardOffset, startRecurrence.getSaveMillis()); [EOL]     } catch (IllegalArgumentException e) { [EOL]         end = instant; [EOL]     } catch (ArithmeticException e) { [EOL]         end = instant; [EOL]     } [EOL]     return (start > end) ? startRecurrence : endRecurrence; [EOL] }
public String getNameKey(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         return iNameKeys[i]; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             return iNameKeys[i - 1]; [EOL]         } [EOL]         return "UTC"; [EOL]     } [EOL]     if (iTailZone == null) { [EOL]         return iNameKeys[i - 1]; [EOL]     } [EOL]     return iTailZone.getNameKey(instant); [EOL] }
public String getNameKey(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         return iNameKeys[i]; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             return iNameKeys[i - 1]; [EOL]         } [EOL]         return "UTC"; [EOL]     } [EOL]     if (iTailZone == null) { [EOL]         return iNameKeys[i - 1]; [EOL]     } [EOL]     return iTailZone.getNameKey(instant); [EOL] }
public String getNameKey(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         return iNameKeys[i]; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             return iNameKeys[i - 1]; [EOL]         } [EOL]         return "UTC"; [EOL]     } [EOL]     if (iTailZone == null) { [EOL]         return iNameKeys[i - 1]; [EOL]     } [EOL]     return iTailZone.getNameKey(instant); [EOL] }
public String getNameKey(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         return iNameKeys[i]; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             return iNameKeys[i - 1]; [EOL]         } [EOL]         return "UTC"; [EOL]     } [EOL]     if (iTailZone == null) { [EOL]         return iNameKeys[i - 1]; [EOL]     } [EOL]     return iTailZone.getNameKey(instant); [EOL] }
public String getNameKey(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         return iNameKeys[i]; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             return iNameKeys[i - 1]; [EOL]         } [EOL]         return "UTC"; [EOL]     } [EOL]     if (iTailZone == null) { [EOL]         return iNameKeys[i - 1]; [EOL]     } [EOL]     return iTailZone.getNameKey(instant); [EOL] }
public int getOffset(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         return iWallOffsets[i]; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             return iWallOffsets[i - 1]; [EOL]         } [EOL]         return 0; [EOL]     } [EOL]     if (iTailZone == null) { [EOL]         return iWallOffsets[i - 1]; [EOL]     } [EOL]     return iTailZone.getOffset(instant); [EOL] }
public int getOffset(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         return iWallOffsets[i]; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             return iWallOffsets[i - 1]; [EOL]         } [EOL]         return 0; [EOL]     } [EOL]     if (iTailZone == null) { [EOL]         return iWallOffsets[i - 1]; [EOL]     } [EOL]     return iTailZone.getOffset(instant); [EOL] }
public int getOffset(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         return iWallOffsets[i]; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             return iWallOffsets[i - 1]; [EOL]         } [EOL]         return 0; [EOL]     } [EOL]     if (iTailZone == null) { [EOL]         return iWallOffsets[i - 1]; [EOL]     } [EOL]     return iTailZone.getOffset(instant); [EOL] }
public int getOffset(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         return iWallOffsets[i]; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             return iWallOffsets[i - 1]; [EOL]         } [EOL]         return 0; [EOL]     } [EOL]     if (iTailZone == null) { [EOL]         return iWallOffsets[i - 1]; [EOL]     } [EOL]     return iTailZone.getOffset(instant); [EOL] }
public int getOffset(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         return iWallOffsets[i]; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             return iWallOffsets[i - 1]; [EOL]         } [EOL]         return 0; [EOL]     } [EOL]     if (iTailZone == null) { [EOL]         return iWallOffsets[i - 1]; [EOL]     } [EOL]     return iTailZone.getOffset(instant); [EOL] }
public long nextTransition(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     i = (i >= 0) ? (i + 1) : ~i; [EOL]     if (i < transitions.length) { [EOL]         return transitions[i]; [EOL]     } [EOL]     if (iTailZone == null) { [EOL]         return instant; [EOL]     } [EOL]     long end = transitions[transitions.length - 1]; [EOL]     if (instant < end) { [EOL]         instant = end; [EOL]     } [EOL]     return iTailZone.nextTransition(instant); [EOL] }
public long nextTransition(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     i = (i >= 0) ? (i + 1) : ~i; [EOL]     if (i < transitions.length) { [EOL]         return transitions[i]; [EOL]     } [EOL]     if (iTailZone == null) { [EOL]         return instant; [EOL]     } [EOL]     long end = transitions[transitions.length - 1]; [EOL]     if (instant < end) { [EOL]         instant = end; [EOL]     } [EOL]     return iTailZone.nextTransition(instant); [EOL] }
public long nextTransition(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     i = (i >= 0) ? (i + 1) : ~i; [EOL]     if (i < transitions.length) { [EOL]         return transitions[i]; [EOL]     } [EOL]     if (iTailZone == null) { [EOL]         return instant; [EOL]     } [EOL]     long end = transitions[transitions.length - 1]; [EOL]     if (instant < end) { [EOL]         instant = end; [EOL]     } [EOL]     return iTailZone.nextTransition(instant); [EOL] }
public long nextTransition(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     i = (i >= 0) ? (i + 1) : ~i; [EOL]     if (i < transitions.length) { [EOL]         return transitions[i]; [EOL]     } [EOL]     if (iTailZone == null) { [EOL]         return instant; [EOL]     } [EOL]     long end = transitions[transitions.length - 1]; [EOL]     if (instant < end) { [EOL]         instant = end; [EOL]     } [EOL]     return iTailZone.nextTransition(instant); [EOL] }
public long previousTransition(long instant) { [EOL]     long[] transitions = iTransitions; [EOL]     int i = Arrays.binarySearch(transitions, instant); [EOL]     if (i >= 0) { [EOL]         if (instant > Long.MIN_VALUE) { [EOL]             return instant - 1; [EOL]         } [EOL]         return instant; [EOL]     } [EOL]     i = ~i; [EOL]     if (i < transitions.length) { [EOL]         if (i > 0) { [EOL]             long prev = transitions[i - 1]; [EOL]             if (prev > Long.MIN_VALUE) { [EOL]                 return prev - 1; [EOL]             } [EOL]         } [EOL]         return instant; [EOL]     } [EOL]     if (iTailZone != null) { [EOL]         long prev = iTailZone.previousTransition(instant); [EOL]         if (prev < instant) { [EOL]             return prev; [EOL]         } [EOL]     } [EOL]     long prev = transitions[i - 1]; [EOL]     if (prev > Long.MIN_VALUE) { [EOL]         return prev - 1; [EOL]     } [EOL]     return instant; [EOL] }
public static CachedDateTimeZone forZone(DateTimeZone zone) { [EOL]     if (zone instanceof CachedDateTimeZone) { [EOL]         return (CachedDateTimeZone) zone; [EOL]     } [EOL]     return new CachedDateTimeZone(zone); [EOL] }
public static CachedDateTimeZone forZone(DateTimeZone zone) { [EOL]     if (zone instanceof CachedDateTimeZone) { [EOL]         return (CachedDateTimeZone) zone; [EOL]     } [EOL]     return new CachedDateTimeZone(zone); [EOL] }
public String getNameKey(long instant) { [EOL]     return getInfo(instant).getNameKey(instant); [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof CachedDateTimeZone) { [EOL]         return iZone.equals(((CachedDateTimeZone) obj).iZone); [EOL]     } [EOL]     return false; [EOL] }
private Info getInfo(long millis) { [EOL]     int period = (int) (millis >> 32); [EOL]     Info[] cache = iInfoCache; [EOL]     int index = period & cInfoCacheMask; [EOL]     Info info = cache[index]; [EOL]     if (info == null || (int) ((info.iPeriodStart >> 32)) != period) { [EOL]         info = createInfo(millis); [EOL]         cache[index] = info; [EOL]     } [EOL]     return info; [EOL] }
private Info getInfo(long millis) { [EOL]     int period = (int) (millis >> 32); [EOL]     Info[] cache = iInfoCache; [EOL]     int index = period & cInfoCacheMask; [EOL]     Info info = cache[index]; [EOL]     if (info == null || (int) ((info.iPeriodStart >> 32)) != period) { [EOL]         info = createInfo(millis); [EOL]         cache[index] = info; [EOL]     } [EOL]     return info; [EOL] }
private Info getInfo(long millis) { [EOL]     int period = (int) (millis >> 32); [EOL]     Info[] cache = iInfoCache; [EOL]     int index = period & cInfoCacheMask; [EOL]     Info info = cache[index]; [EOL]     if (info == null || (int) ((info.iPeriodStart >> 32)) != period) { [EOL]         info = createInfo(millis); [EOL]         cache[index] = info; [EOL]     } [EOL]     return info; [EOL] }
private Info createInfo(long millis) { [EOL]     long periodStart = millis & (0xffffffffL << 32); [EOL]     Info info = new Info(iZone, periodStart); [EOL]     long end = periodStart | 0xffffffffL; [EOL]     Info chain = info; [EOL]     while (true) { [EOL]         long next = iZone.nextTransition(periodStart); [EOL]         if (next == periodStart || next > end) { [EOL]             break; [EOL]         } [EOL]         periodStart = next; [EOL]         chain = (chain.iNextInfo = new Info(iZone, periodStart)); [EOL]     } [EOL]     return info; [EOL] }
private Info createInfo(long millis) { [EOL]     long periodStart = millis & (0xffffffffL << 32); [EOL]     Info info = new Info(iZone, periodStart); [EOL]     long end = periodStart | 0xffffffffL; [EOL]     Info chain = info; [EOL]     while (true) { [EOL]         long next = iZone.nextTransition(periodStart); [EOL]         if (next == periodStart || next > end) { [EOL]             break; [EOL]         } [EOL]         periodStart = next; [EOL]         chain = (chain.iNextInfo = new Info(iZone, periodStart)); [EOL]     } [EOL]     return info; [EOL] }
private Info createInfo(long millis) { [EOL]     long periodStart = millis & (0xffffffffL << 32); [EOL]     Info info = new Info(iZone, periodStart); [EOL]     long end = periodStart | 0xffffffffL; [EOL]     Info chain = info; [EOL]     while (true) { [EOL]         long next = iZone.nextTransition(periodStart); [EOL]         if (next == periodStart || next > end) { [EOL]             break; [EOL]         } [EOL]         periodStart = next; [EOL]         chain = (chain.iNextInfo = new Info(iZone, periodStart)); [EOL]     } [EOL]     return info; [EOL] }
Info(DateTimeZone zone, long periodStart) { [EOL]     iPeriodStart = periodStart; [EOL]     iZoneRef = zone; [EOL] }
Info(DateTimeZone zone, long periodStart) { [EOL]     iPeriodStart = periodStart; [EOL]     iZoneRef = zone; [EOL] }
public String getNameKey(long millis) { [EOL]     if (iNextInfo == null || millis < iNextInfo.iPeriodStart) { [EOL]         if (iNameKey == null) { [EOL]             iNameKey = iZoneRef.getNameKey(iPeriodStart); [EOL]         } [EOL]         return iNameKey; [EOL]     } [EOL]     return iNextInfo.getNameKey(millis); [EOL] }
public String getNameKey(long millis) { [EOL]     if (iNextInfo == null || millis < iNextInfo.iPeriodStart) { [EOL]         if (iNameKey == null) { [EOL]             iNameKey = iZoneRef.getNameKey(iPeriodStart); [EOL]         } [EOL]         return iNameKey; [EOL]     } [EOL]     return iNextInfo.getNameKey(millis); [EOL] }
public String getNameKey(long millis) { [EOL]     if (iNextInfo == null || millis < iNextInfo.iPeriodStart) { [EOL]         if (iNameKey == null) { [EOL]             iNameKey = iZoneRef.getNameKey(iPeriodStart); [EOL]         } [EOL]         return iNameKey; [EOL]     } [EOL]     return iNextInfo.getNameKey(millis); [EOL] }
public String getNameKey(long millis) { [EOL]     if (iNextInfo == null || millis < iNextInfo.iPeriodStart) { [EOL]         if (iNameKey == null) { [EOL]             iNameKey = iZoneRef.getNameKey(iPeriodStart); [EOL]         } [EOL]         return iNameKey; [EOL]     } [EOL]     return iNextInfo.getNameKey(millis); [EOL] }
public int getOffset(long millis) { [EOL]     if (iNextInfo == null || millis < iNextInfo.iPeriodStart) { [EOL]         if (iOffset == Integer.MIN_VALUE) { [EOL]             iOffset = iZoneRef.getOffset(iPeriodStart); [EOL]         } [EOL]         return iOffset; [EOL]     } [EOL]     return iNextInfo.getOffset(millis); [EOL] }
public int getValue(long duration, long instant) { [EOL]     return getWrappedField().getValue(duration, instant) / iScalar; [EOL] }
public int getValue(long duration, long instant) { [EOL]     return getWrappedField().getValue(duration, instant) / iScalar; [EOL] }
public long getMillis(long value, long instant) { [EOL]     long scaled = FieldUtils.safeMultiply(value, iScalar); [EOL]     return getWrappedField().getMillis(scaled, instant); [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof ScaledDurationField) { [EOL]         ScaledDurationField other = (ScaledDurationField) obj; [EOL]         return (getWrappedField().equals(other.getWrappedField())) && (getType() == other.getType()) && (iScalar == other.iScalar); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof ScaledDurationField) { [EOL]         ScaledDurationField other = (ScaledDurationField) obj; [EOL]         return (getWrappedField().equals(other.getWrappedField())) && (getType() == other.getType()) && (iScalar == other.iScalar); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof ScaledDurationField) { [EOL]         ScaledDurationField other = (ScaledDurationField) obj; [EOL]         return (getWrappedField().equals(other.getWrappedField())) && (getType() == other.getType()) && (iScalar == other.iScalar); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof ScaledDurationField) { [EOL]         ScaledDurationField other = (ScaledDurationField) obj; [EOL]         return (getWrappedField().equals(other.getWrappedField())) && (getType() == other.getType()) && (iScalar == other.iScalar); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof ScaledDurationField) { [EOL]         ScaledDurationField other = (ScaledDurationField) obj; [EOL]         return (getWrappedField().equals(other.getWrappedField())) && (getType() == other.getType()) && (iScalar == other.iScalar); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof ScaledDurationField) { [EOL]         ScaledDurationField other = (ScaledDurationField) obj; [EOL]         return (getWrappedField().equals(other.getWrappedField())) && (getType() == other.getType()) && (iScalar == other.iScalar); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof ScaledDurationField) { [EOL]         ScaledDurationField other = (ScaledDurationField) obj; [EOL]         return (getWrappedField().equals(other.getWrappedField())) && (getType() == other.getType()) && (iScalar == other.iScalar); [EOL]     } [EOL]     return false; [EOL] }
public static ISOChronology getInstance() { [EOL]     return getInstance(DateTimeZone.getDefault()); [EOL] }
public static ISOChronology getInstance(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     int index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1); [EOL]     ISOChronology chrono = cFastCache[index]; [EOL]     if (chrono != null && chrono.getZone() == zone) { [EOL]         return chrono; [EOL]     } [EOL]     synchronized (cCache) { [EOL]         chrono = cCache.get(zone); [EOL]         if (chrono == null) { [EOL]             chrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone)); [EOL]             cCache.put(zone, chrono); [EOL]         } [EOL]     } [EOL]     cFastCache[index] = chrono; [EOL]     return chrono; [EOL] }
public static ISOChronology getInstance(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     int index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1); [EOL]     ISOChronology chrono = cFastCache[index]; [EOL]     if (chrono != null && chrono.getZone() == zone) { [EOL]         return chrono; [EOL]     } [EOL]     synchronized (cCache) { [EOL]         chrono = cCache.get(zone); [EOL]         if (chrono == null) { [EOL]             chrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone)); [EOL]             cCache.put(zone, chrono); [EOL]         } [EOL]     } [EOL]     cFastCache[index] = chrono; [EOL]     return chrono; [EOL] }
public static ISOChronology getInstance(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     int index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1); [EOL]     ISOChronology chrono = cFastCache[index]; [EOL]     if (chrono != null && chrono.getZone() == zone) { [EOL]         return chrono; [EOL]     } [EOL]     synchronized (cCache) { [EOL]         chrono = cCache.get(zone); [EOL]         if (chrono == null) { [EOL]             chrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone)); [EOL]             cCache.put(zone, chrono); [EOL]         } [EOL]     } [EOL]     cFastCache[index] = chrono; [EOL]     return chrono; [EOL] }
private ISOChronology(Chronology base) { [EOL]     super(base, null); [EOL] }
public String toString() { [EOL]     String str = "ISOChronology"; [EOL]     DateTimeZone zone = getZone(); [EOL]     if (zone != null) { [EOL]         str = str + '[' + zone.getID() + ']'; [EOL]     } [EOL]     return str; [EOL] }
public String toString() { [EOL]     String str = "ISOChronology"; [EOL]     DateTimeZone zone = getZone(); [EOL]     if (zone != null) { [EOL]         str = str + '[' + zone.getID() + ']'; [EOL]     } [EOL]     return str; [EOL] }
protected void assemble(Fields fields) { [EOL]     if (getBase().getZone() == DateTimeZone.UTC) { [EOL]         fields.centuryOfEra = new DividedDateTimeField(ISOYearOfEraDateTimeField.INSTANCE, DateTimeFieldType.centuryOfEra(), 100); [EOL]         fields.centuries = fields.centuryOfEra.getDurationField(); [EOL]         fields.yearOfCentury = new RemainderDateTimeField((DividedDateTimeField) fields.centuryOfEra, DateTimeFieldType.yearOfCentury()); [EOL]         fields.weekyearOfCentury = new RemainderDateTimeField((DividedDateTimeField) fields.centuryOfEra, fields.weekyears, DateTimeFieldType.weekyearOfCentury()); [EOL]     } [EOL] }
protected void assemble(Fields fields) { [EOL]     if (getBase().getZone() == DateTimeZone.UTC) { [EOL]         fields.centuryOfEra = new DividedDateTimeField(ISOYearOfEraDateTimeField.INSTANCE, DateTimeFieldType.centuryOfEra(), 100); [EOL]         fields.centuries = fields.centuryOfEra.getDurationField(); [EOL]         fields.yearOfCentury = new RemainderDateTimeField((DividedDateTimeField) fields.centuryOfEra, DateTimeFieldType.yearOfCentury()); [EOL]         fields.weekyearOfCentury = new RemainderDateTimeField((DividedDateTimeField) fields.centuryOfEra, fields.weekyears, DateTimeFieldType.weekyearOfCentury()); [EOL]     } [EOL] }
public final String getName() { [EOL]     return iType.getName(); [EOL] }
public static CopticChronology getInstanceUTC() { [EOL]     return INSTANCE_UTC; [EOL] }
public static CopticChronology getInstance() { [EOL]     return getInstance(DateTimeZone.getDefault(), 4); [EOL] }
public static CopticChronology getInstance(DateTimeZone zone) { [EOL]     return getInstance(zone, 4); [EOL] }
public static CopticChronology getInstance(DateTimeZone zone) { [EOL]     return getInstance(zone, 4); [EOL] }
public static CopticChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     CopticChronology chrono; [EOL]     synchronized (cCache) { [EOL]         CopticChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new CopticChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new CopticChronology(null, null, minDaysInFirstWeek); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new CopticChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new CopticChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static CopticChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     CopticChronology chrono; [EOL]     synchronized (cCache) { [EOL]         CopticChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new CopticChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new CopticChronology(null, null, minDaysInFirstWeek); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new CopticChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new CopticChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static CopticChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     CopticChronology chrono; [EOL]     synchronized (cCache) { [EOL]         CopticChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new CopticChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new CopticChronology(null, null, minDaysInFirstWeek); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new CopticChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new CopticChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static CopticChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     CopticChronology chrono; [EOL]     synchronized (cCache) { [EOL]         CopticChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new CopticChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new CopticChronology(null, null, minDaysInFirstWeek); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new CopticChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new CopticChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     int relativeYear = year - 1687; [EOL]     int leapYears; [EOL]     if (relativeYear <= 0) { [EOL]         leapYears = (relativeYear + 3) >> 2; [EOL]     } else { [EOL]         leapYears = relativeYear >> 2; [EOL]         if (!isLeapYear(year)) { [EOL]             leapYears++; [EOL]         } [EOL]     } [EOL]     long millis = (relativeYear * 365L + leapYears) * (long) DateTimeConstants.MILLIS_PER_DAY; [EOL]     return millis + (365L - 112) * DateTimeConstants.MILLIS_PER_DAY; [EOL] }
long getApproxMillisAtEpochDividedByTwo() { [EOL]     return (1686L * MILLIS_PER_YEAR + 112L * DateTimeConstants.MILLIS_PER_DAY) / 2; [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
public static Months months(int months) { [EOL]     switch(months) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case 9: [EOL]             return NINE; [EOL]         case 10: [EOL]             return TEN; [EOL]         case 11: [EOL]             return ELEVEN; [EOL]         case 12: [EOL]             return TWELVE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Months(months); [EOL]     } [EOL] }
private Months(int months) { [EOL]     super(months); [EOL] }
public PeriodType getPeriodType() { [EOL]     return PeriodType.months(); [EOL] }
public Interval(Object interval, Chronology chronology) { [EOL]     super(interval, chronology); [EOL] }
public Interval(Object interval, Chronology chronology) { [EOL]     super(interval, chronology); [EOL] }
public Interval(Object interval, Chronology chronology) { [EOL]     super(interval, chronology); [EOL] }
public Interval(Object interval, Chronology chronology) { [EOL]     super(interval, chronology); [EOL] }
public Interval withDurationBeforeEnd(ReadableDuration duration) { [EOL]     long durationMillis = DateTimeUtils.getDurationMillis(duration); [EOL]     if (durationMillis == toDurationMillis()) { [EOL]         return this; [EOL]     } [EOL]     Chronology chrono = getChronology(); [EOL]     long endMillis = getEndMillis(); [EOL]     long startMillis = chrono.add(endMillis, durationMillis, -1); [EOL]     return new Interval(startMillis, endMillis, chrono); [EOL] }
public Interval withDurationBeforeEnd(ReadableDuration duration) { [EOL]     long durationMillis = DateTimeUtils.getDurationMillis(duration); [EOL]     if (durationMillis == toDurationMillis()) { [EOL]         return this; [EOL]     } [EOL]     Chronology chrono = getChronology(); [EOL]     long endMillis = getEndMillis(); [EOL]     long startMillis = chrono.add(endMillis, durationMillis, -1); [EOL]     return new Interval(startMillis, endMillis, chrono); [EOL] }
public Interval withPeriodAfterStart(ReadablePeriod period) { [EOL]     if (period == null) { [EOL]         return withDurationAfterStart(null); [EOL]     } [EOL]     Chronology chrono = getChronology(); [EOL]     long startMillis = getStartMillis(); [EOL]     long endMillis = chrono.add(period, startMillis, 1); [EOL]     return new Interval(startMillis, endMillis, chrono); [EOL] }
public static YearMonth now() { [EOL]     return new YearMonth(); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public static YearMonth now(Chronology chronology) { [EOL]     if (chronology == null) { [EOL]         throw new NullPointerException("Chronology must not be null"); [EOL]     } [EOL]     return new YearMonth(chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public static YearMonth now(Chronology chronology) { [EOL]     if (chronology == null) { [EOL]         throw new NullPointerException("Chronology must not be null"); [EOL]     } [EOL]     return new YearMonth(chronology); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public static YearMonth fromCalendarFields(Calendar calendar) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The calendar must not be null"); [EOL]     } [EOL]     return new YearMonth(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH) + 1); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public static YearMonth fromCalendarFields(Calendar calendar) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The calendar must not be null"); [EOL]     } [EOL]     return new YearMonth(calendar.get(Calendar.YEAR), calendar.get(Calendar.MONTH) + 1); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth() { [EOL]     super(); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth() { [EOL]     super(); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth() { [EOL]     super(); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth() { [EOL]     super(); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth() { [EOL]     super(); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth() { [EOL]     super(); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth() { [EOL]     super(); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth() { [EOL]     super(); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth() { [EOL]     super(); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.localDateParser()); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth withYear(int year) { [EOL]     int[] newValues = getValues(); [EOL]     newValues = getChronology().year().set(this, YEAR, newValues, year); [EOL]     return new YearMonth(this, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth withYear(int year) { [EOL]     int[] newValues = getValues(); [EOL]     newValues = getChronology().year().set(this, YEAR, newValues, year); [EOL]     return new YearMonth(this, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth withYear(int year) { [EOL]     int[] newValues = getValues(); [EOL]     newValues = getChronology().year().set(this, YEAR, newValues, year); [EOL]     return new YearMonth(this, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth withMonthOfYear(int monthOfYear) { [EOL]     int[] newValues = getValues(); [EOL]     newValues = getChronology().monthOfYear().set(this, MONTH_OF_YEAR, newValues, monthOfYear); [EOL]     return new YearMonth(this, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
public YearMonth withMonthOfYear(int monthOfYear) { [EOL]     int[] newValues = getValues(); [EOL]     newValues = getChronology().monthOfYear().set(this, MONTH_OF_YEAR, newValues, monthOfYear); [EOL]     return new YearMonth(this, newValues); [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
protected ReadablePartial getReadablePartial() { [EOL]     return iBase; [EOL] } public YearMonth(); public YearMonth(DateTimeZone zone); public YearMonth(Chronology chronology); public YearMonth(long instant); public YearMonth(long instant, Chronology chronology); public YearMonth(Object instant); public YearMonth(Object instant, Chronology chronology); public YearMonth(int year, int monthOfYear); public YearMonth(int year, int monthOfYear, Chronology chronology);  YearMonth(YearMonth partial, int[] values);  YearMonth(YearMonth partial, Chronology chrono);  Property(YearMonth partial, int fieldIndex); public static YearMonth now(); public static YearMonth now(DateTimeZone zone); public static YearMonth now(Chronology chronology); public static YearMonth parse(String str); public static YearMonth parse(String str, DateTimeFormatter formatter); public static YearMonth fromCalendarFields(Calendar calendar); public static YearMonth fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public YearMonth withChronologyRetainFields(Chronology newChronology); public YearMonth withField(DateTimeFieldType fieldType, int value); public YearMonth withFieldAdded(DurationFieldType fieldType, int amount); public YearMonth withPeriodAdded(ReadablePeriod period, int scalar); public YearMonth plus(ReadablePeriod period); public YearMonth plusYears(int years); public YearMonth plusMonths(int months); public YearMonth minus(ReadablePeriod period); public YearMonth minusYears(int years); public YearMonth minusMonths(int months); public LocalDate toLocalDate(int dayOfMonth); public Interval toInterval(); public Interval toInterval(DateTimeZone zone); public int getYear(); public int getMonthOfYear(); public YearMonth withYear(int year); public YearMonth withMonthOfYear(int monthOfYear); public Property property(DateTimeFieldType type); public Property year(); public Property monthOfYear(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public YearMonth getYearMonth(); public int get(); public YearMonth addToCopy(int valueToAdd); public YearMonth addWrapFieldToCopy(int valueToAdd); public YearMonth setCopy(int value); public YearMonth setCopy(String text, Locale locale); public YearMonth setCopy(String text); long serialVersionUID=Optional[797544782896179L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() }
protected BaseDateTimeField(DateTimeFieldType type) { [EOL]     super(); [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("The type must not be null"); [EOL]     } [EOL]     iType = type; [EOL] }
protected BaseDateTimeField(DateTimeFieldType type) { [EOL]     super(); [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("The type must not be null"); [EOL]     } [EOL]     iType = type; [EOL] }
public final String getAsText(ReadablePartial partial, Locale locale) { [EOL]     return getAsText(partial, partial.get(getType()), locale); [EOL] }
public int[] addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     DateTimeField nextField = null; [EOL]     while (valueToAdd > 0) { [EOL]         int max = getMaximumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed <= max) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]                 values[fieldIndex] = getMinimumValue(instant, values); [EOL]                 continue; [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]         values = nextField.addWrapPartial(instant, fieldIndex - 1, values, 1); [EOL]         values[fieldIndex] = getMinimumValue(instant, values); [EOL]     } [EOL]     while (valueToAdd < 0) { [EOL]         int min = getMinimumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed >= min) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]                 values[fieldIndex] = getMaximumValue(instant, values); [EOL]                 continue; [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]         values = nextField.addWrapPartial(instant, fieldIndex - 1, values, -1); [EOL]         values[fieldIndex] = getMaximumValue(instant, values); [EOL]     } [EOL]     return set(instant, fieldIndex, values, values[fieldIndex]); [EOL] }
public int[] addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     DateTimeField nextField = null; [EOL]     while (valueToAdd > 0) { [EOL]         int max = getMaximumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed <= max) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]                 values[fieldIndex] = getMinimumValue(instant, values); [EOL]                 continue; [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]         values = nextField.addWrapPartial(instant, fieldIndex - 1, values, 1); [EOL]         values[fieldIndex] = getMinimumValue(instant, values); [EOL]     } [EOL]     while (valueToAdd < 0) { [EOL]         int min = getMinimumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed >= min) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]                 values[fieldIndex] = getMaximumValue(instant, values); [EOL]                 continue; [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]         values = nextField.addWrapPartial(instant, fieldIndex - 1, values, -1); [EOL]         values[fieldIndex] = getMaximumValue(instant, values); [EOL]     } [EOL]     return set(instant, fieldIndex, values, values[fieldIndex]); [EOL] }
public int[] addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     DateTimeField nextField = null; [EOL]     while (valueToAdd > 0) { [EOL]         int max = getMaximumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed <= max) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]                 values[fieldIndex] = getMinimumValue(instant, values); [EOL]                 continue; [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]         values = nextField.addWrapPartial(instant, fieldIndex - 1, values, 1); [EOL]         values[fieldIndex] = getMinimumValue(instant, values); [EOL]     } [EOL]     while (valueToAdd < 0) { [EOL]         int min = getMinimumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed >= min) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]                 values[fieldIndex] = getMaximumValue(instant, values); [EOL]                 continue; [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]         values = nextField.addWrapPartial(instant, fieldIndex - 1, values, -1); [EOL]         values[fieldIndex] = getMaximumValue(instant, values); [EOL]     } [EOL]     return set(instant, fieldIndex, values, values[fieldIndex]); [EOL] }
public int[] addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     DateTimeField nextField = null; [EOL]     while (valueToAdd > 0) { [EOL]         int max = getMaximumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed <= max) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]                 values[fieldIndex] = getMinimumValue(instant, values); [EOL]                 continue; [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]         values = nextField.addWrapPartial(instant, fieldIndex - 1, values, 1); [EOL]         values[fieldIndex] = getMinimumValue(instant, values); [EOL]     } [EOL]     while (valueToAdd < 0) { [EOL]         int min = getMinimumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed >= min) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]                 values[fieldIndex] = getMaximumValue(instant, values); [EOL]                 continue; [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]         values = nextField.addWrapPartial(instant, fieldIndex - 1, values, -1); [EOL]         values[fieldIndex] = getMaximumValue(instant, values); [EOL]     } [EOL]     return set(instant, fieldIndex, values, values[fieldIndex]); [EOL] }
public int[] addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     DateTimeField nextField = null; [EOL]     while (valueToAdd > 0) { [EOL]         int max = getMaximumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed <= max) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]                 values[fieldIndex] = getMinimumValue(instant, values); [EOL]                 continue; [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]         values = nextField.addWrapPartial(instant, fieldIndex - 1, values, 1); [EOL]         values[fieldIndex] = getMinimumValue(instant, values); [EOL]     } [EOL]     while (valueToAdd < 0) { [EOL]         int min = getMinimumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed >= min) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]                 values[fieldIndex] = getMaximumValue(instant, values); [EOL]                 continue; [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]         values = nextField.addWrapPartial(instant, fieldIndex - 1, values, -1); [EOL]         values[fieldIndex] = getMaximumValue(instant, values); [EOL]     } [EOL]     return set(instant, fieldIndex, values, values[fieldIndex]); [EOL] }
public int[] addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     DateTimeField nextField = null; [EOL]     while (valueToAdd > 0) { [EOL]         int max = getMaximumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed <= max) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]                 values[fieldIndex] = getMinimumValue(instant, values); [EOL]                 continue; [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]         values = nextField.addWrapPartial(instant, fieldIndex - 1, values, 1); [EOL]         values[fieldIndex] = getMinimumValue(instant, values); [EOL]     } [EOL]     while (valueToAdd < 0) { [EOL]         int min = getMinimumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed >= min) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]                 values[fieldIndex] = getMaximumValue(instant, values); [EOL]                 continue; [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]         values = nextField.addWrapPartial(instant, fieldIndex - 1, values, -1); [EOL]         values[fieldIndex] = getMaximumValue(instant, values); [EOL]     } [EOL]     return set(instant, fieldIndex, values, values[fieldIndex]); [EOL] }
public int[] addWrapPartial(ReadablePartial instant, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     DateTimeField nextField = null; [EOL]     while (valueToAdd > 0) { [EOL]         int max = getMaximumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed <= max) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]                 values[fieldIndex] = getMinimumValue(instant, values); [EOL]                 continue; [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (max + 1) - values[fieldIndex]; [EOL]         values = nextField.addWrapPartial(instant, fieldIndex - 1, values, 1); [EOL]         values[fieldIndex] = getMinimumValue(instant, values); [EOL]     } [EOL]     while (valueToAdd < 0) { [EOL]         int min = getMinimumValue(instant, values); [EOL]         long proposed = values[fieldIndex] + valueToAdd; [EOL]         if (proposed >= min) { [EOL]             values[fieldIndex] = (int) proposed; [EOL]             break; [EOL]         } [EOL]         if (nextField == null) { [EOL]             if (fieldIndex == 0) { [EOL]                 valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]                 values[fieldIndex] = getMaximumValue(instant, values); [EOL]                 continue; [EOL]             } [EOL]             nextField = instant.getField(fieldIndex - 1); [EOL]             if (getRangeDurationField().getType() != nextField.getDurationField().getType()) { [EOL]                 throw new IllegalArgumentException("Fields invalid for add"); [EOL]             } [EOL]         } [EOL]         valueToAdd -= (min - 1) - values[fieldIndex]; [EOL]         values = nextField.addWrapPartial(instant, fieldIndex - 1, values, -1); [EOL]         values[fieldIndex] = getMaximumValue(instant, values); [EOL]     } [EOL]     return set(instant, fieldIndex, values, values[fieldIndex]); [EOL] }
public int getDifference(long minuendInstant, long subtrahendInstant) { [EOL]     return getDurationField().getDifference(minuendInstant, subtrahendInstant); [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     return getDurationField().getDifferenceAsLong(minuendInstant, subtrahendInstant); [EOL] }
public int[] set(ReadablePartial partial, int fieldIndex, int[] values, int newValue) { [EOL]     FieldUtils.verifyValueBounds(this, newValue, getMinimumValue(partial, values), getMaximumValue(partial, values)); [EOL]     values[fieldIndex] = newValue; [EOL]     for (int i = fieldIndex + 1; i < partial.size(); i++) { [EOL]         DateTimeField field = partial.getField(i); [EOL]         if (values[i] > field.getMaximumValue(partial, values)) { [EOL]             values[i] = field.getMaximumValue(partial, values); [EOL]         } [EOL]         if (values[i] < field.getMinimumValue(partial, values)) { [EOL]             values[i] = field.getMinimumValue(partial, values); [EOL]         } [EOL]     } [EOL]     return values; [EOL] }
public int[] set(ReadablePartial partial, int fieldIndex, int[] values, int newValue) { [EOL]     FieldUtils.verifyValueBounds(this, newValue, getMinimumValue(partial, values), getMaximumValue(partial, values)); [EOL]     values[fieldIndex] = newValue; [EOL]     for (int i = fieldIndex + 1; i < partial.size(); i++) { [EOL]         DateTimeField field = partial.getField(i); [EOL]         if (values[i] > field.getMaximumValue(partial, values)) { [EOL]             values[i] = field.getMaximumValue(partial, values); [EOL]         } [EOL]         if (values[i] < field.getMinimumValue(partial, values)) { [EOL]             values[i] = field.getMinimumValue(partial, values); [EOL]         } [EOL]     } [EOL]     return values; [EOL] }
public int[] set(ReadablePartial partial, int fieldIndex, int[] values, int newValue) { [EOL]     FieldUtils.verifyValueBounds(this, newValue, getMinimumValue(partial, values), getMaximumValue(partial, values)); [EOL]     values[fieldIndex] = newValue; [EOL]     for (int i = fieldIndex + 1; i < partial.size(); i++) { [EOL]         DateTimeField field = partial.getField(i); [EOL]         if (values[i] > field.getMaximumValue(partial, values)) { [EOL]             values[i] = field.getMaximumValue(partial, values); [EOL]         } [EOL]         if (values[i] < field.getMinimumValue(partial, values)) { [EOL]             values[i] = field.getMinimumValue(partial, values); [EOL]         } [EOL]     } [EOL]     return values; [EOL] }
public int[] set(ReadablePartial partial, int fieldIndex, int[] values, int newValue) { [EOL]     FieldUtils.verifyValueBounds(this, newValue, getMinimumValue(partial, values), getMaximumValue(partial, values)); [EOL]     values[fieldIndex] = newValue; [EOL]     for (int i = fieldIndex + 1; i < partial.size(); i++) { [EOL]         DateTimeField field = partial.getField(i); [EOL]         if (values[i] > field.getMaximumValue(partial, values)) { [EOL]             values[i] = field.getMaximumValue(partial, values); [EOL]         } [EOL]         if (values[i] < field.getMinimumValue(partial, values)) { [EOL]             values[i] = field.getMinimumValue(partial, values); [EOL]         } [EOL]     } [EOL]     return values; [EOL] }
public int[] set(ReadablePartial partial, int fieldIndex, int[] values, int newValue) { [EOL]     FieldUtils.verifyValueBounds(this, newValue, getMinimumValue(partial, values), getMaximumValue(partial, values)); [EOL]     values[fieldIndex] = newValue; [EOL]     for (int i = fieldIndex + 1; i < partial.size(); i++) { [EOL]         DateTimeField field = partial.getField(i); [EOL]         if (values[i] > field.getMaximumValue(partial, values)) { [EOL]             values[i] = field.getMaximumValue(partial, values); [EOL]         } [EOL]         if (values[i] < field.getMinimumValue(partial, values)) { [EOL]             values[i] = field.getMinimumValue(partial, values); [EOL]         } [EOL]     } [EOL]     return values; [EOL] }
public int[] set(ReadablePartial instant, int fieldIndex, int[] values, String text, Locale locale) { [EOL]     int value = convertText(text, locale); [EOL]     return set(instant, fieldIndex, values, value); [EOL] }
public int getLeapAmount(long instant) { [EOL]     return 0; [EOL] }
public int getMinimumValue(ReadablePartial instant) { [EOL]     return getMinimumValue(); [EOL] }
public int getMinimumValue(ReadablePartial instant, int[] values) { [EOL]     return getMinimumValue(instant); [EOL] }
public int getMinimumValue(ReadablePartial instant, int[] values) { [EOL]     return getMinimumValue(instant); [EOL] }
public int getMaximumValue(long instant) { [EOL]     return getMaximumValue(); [EOL] }
public int getMaximumValue(ReadablePartial instant) { [EOL]     return getMaximumValue(); [EOL] }
public int getMaximumValue(ReadablePartial instant, int[] values) { [EOL]     return getMaximumValue(instant); [EOL] }
public int getMaximumValue(ReadablePartial instant, int[] values) { [EOL]     return getMaximumValue(instant); [EOL] }
public int getMaximumShortTextLength(Locale locale) { [EOL]     return getMaximumTextLength(locale); [EOL] }
public long roundHalfEven(long instant) { [EOL]     long floor = roundFloor(instant); [EOL]     long ceiling = roundCeiling(instant); [EOL]     long diffFromFloor = instant - floor; [EOL]     long diffToCeiling = ceiling - instant; [EOL]     if (diffFromFloor < diffToCeiling) { [EOL]         return floor; [EOL]     } else if (diffToCeiling < diffFromFloor) { [EOL]         return ceiling; [EOL]     } else { [EOL]         if ((get(ceiling) & 1) == 0) { [EOL]             return ceiling; [EOL]         } [EOL]         return floor; [EOL]     } [EOL] }
public long roundHalfEven(long instant) { [EOL]     long floor = roundFloor(instant); [EOL]     long ceiling = roundCeiling(instant); [EOL]     long diffFromFloor = instant - floor; [EOL]     long diffToCeiling = ceiling - instant; [EOL]     if (diffFromFloor < diffToCeiling) { [EOL]         return floor; [EOL]     } else if (diffToCeiling < diffFromFloor) { [EOL]         return ceiling; [EOL]     } else { [EOL]         if ((get(ceiling) & 1) == 0) { [EOL]             return ceiling; [EOL]         } [EOL]         return floor; [EOL]     } [EOL] }
public long roundHalfEven(long instant) { [EOL]     long floor = roundFloor(instant); [EOL]     long ceiling = roundCeiling(instant); [EOL]     long diffFromFloor = instant - floor; [EOL]     long diffToCeiling = ceiling - instant; [EOL]     if (diffFromFloor < diffToCeiling) { [EOL]         return floor; [EOL]     } else if (diffToCeiling < diffFromFloor) { [EOL]         return ceiling; [EOL]     } else { [EOL]         if ((get(ceiling) & 1) == 0) { [EOL]             return ceiling; [EOL]         } [EOL]         return floor; [EOL]     } [EOL] }
public long roundHalfEven(long instant) { [EOL]     long floor = roundFloor(instant); [EOL]     long ceiling = roundCeiling(instant); [EOL]     long diffFromFloor = instant - floor; [EOL]     long diffToCeiling = ceiling - instant; [EOL]     if (diffFromFloor < diffToCeiling) { [EOL]         return floor; [EOL]     } else if (diffToCeiling < diffFromFloor) { [EOL]         return ceiling; [EOL]     } else { [EOL]         if ((get(ceiling) & 1) == 0) { [EOL]             return ceiling; [EOL]         } [EOL]         return floor; [EOL]     } [EOL] }
public String toString() { [EOL]     return "DateTimeField[" + getName() + ']'; [EOL] }
public int getMaximumValue() { [EOL]     return iChronology.getDaysInMonthMax(); [EOL] }
public int getMaximumValue(long instant) { [EOL]     return iChronology.getDaysInMonthMax(instant); [EOL] }
public int getMaximumValue(ReadablePartial partial) { [EOL]     if (partial.isSupported(DateTimeFieldType.monthOfYear())) { [EOL]         int month = partial.get(DateTimeFieldType.monthOfYear()); [EOL]         if (partial.isSupported(DateTimeFieldType.year())) { [EOL]             int year = partial.get(DateTimeFieldType.year()); [EOL]             return iChronology.getDaysInYearMonth(year, month); [EOL]         } [EOL]         return iChronology.getDaysInMonthMax(month); [EOL]     } [EOL]     return getMaximumValue(); [EOL] }
public int getMaximumValue(ReadablePartial partial) { [EOL]     if (partial.isSupported(DateTimeFieldType.monthOfYear())) { [EOL]         int month = partial.get(DateTimeFieldType.monthOfYear()); [EOL]         if (partial.isSupported(DateTimeFieldType.year())) { [EOL]             int year = partial.get(DateTimeFieldType.year()); [EOL]             return iChronology.getDaysInYearMonth(year, month); [EOL]         } [EOL]         return iChronology.getDaysInMonthMax(month); [EOL]     } [EOL]     return getMaximumValue(); [EOL] }
public int getMaximumValue(ReadablePartial partial) { [EOL]     if (partial.isSupported(DateTimeFieldType.monthOfYear())) { [EOL]         int month = partial.get(DateTimeFieldType.monthOfYear()); [EOL]         if (partial.isSupported(DateTimeFieldType.year())) { [EOL]             int year = partial.get(DateTimeFieldType.year()); [EOL]             return iChronology.getDaysInYearMonth(year, month); [EOL]         } [EOL]         return iChronology.getDaysInMonthMax(month); [EOL]     } [EOL]     return getMaximumValue(); [EOL] }
public int getMaximumValue(ReadablePartial partial, int[] values) { [EOL]     int size = partial.size(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (partial.getFieldType(i) == DateTimeFieldType.monthOfYear()) { [EOL]             int month = values[i]; [EOL]             for (int j = 0; j < size; j++) { [EOL]                 if (partial.getFieldType(j) == DateTimeFieldType.year()) { [EOL]                     int year = values[j]; [EOL]                     return iChronology.getDaysInYearMonth(year, month); [EOL]                 } [EOL]             } [EOL]             return iChronology.getDaysInMonthMax(month); [EOL]         } [EOL]     } [EOL]     return getMaximumValue(); [EOL] }
public int getMaximumValue(ReadablePartial partial, int[] values) { [EOL]     int size = partial.size(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (partial.getFieldType(i) == DateTimeFieldType.monthOfYear()) { [EOL]             int month = values[i]; [EOL]             for (int j = 0; j < size; j++) { [EOL]                 if (partial.getFieldType(j) == DateTimeFieldType.year()) { [EOL]                     int year = values[j]; [EOL]                     return iChronology.getDaysInYearMonth(year, month); [EOL]                 } [EOL]             } [EOL]             return iChronology.getDaysInMonthMax(month); [EOL]         } [EOL]     } [EOL]     return getMaximumValue(); [EOL] }
public int getMaximumValue(ReadablePartial partial, int[] values) { [EOL]     int size = partial.size(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (partial.getFieldType(i) == DateTimeFieldType.monthOfYear()) { [EOL]             int month = values[i]; [EOL]             for (int j = 0; j < size; j++) { [EOL]                 if (partial.getFieldType(j) == DateTimeFieldType.year()) { [EOL]                     int year = values[j]; [EOL]                     return iChronology.getDaysInYearMonth(year, month); [EOL]                 } [EOL]             } [EOL]             return iChronology.getDaysInMonthMax(month); [EOL]         } [EOL]     } [EOL]     return getMaximumValue(); [EOL] }
public static void appendPaddedInteger(StringBuffer buf, int value, int size) { [EOL]     if (value < 0) { [EOL]         buf.append('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             for (; size > 10; size--) { [EOL]                 buf.append('0'); [EOL]             } [EOL]             buf.append("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         for (; size > 1; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append((char) (value + '0')); [EOL]     } else if (value < 100) { [EOL]         for (; size > 2; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         buf.append((char) (d + '0')); [EOL]         buf.append((char) (value - (d << 3) - (d << 1) + '0')); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else if (value < 10000) { [EOL]             digits = 4; [EOL]         } else { [EOL]             digits = (int) (Math.log(value) / LOG_10) + 1; [EOL]         } [EOL]         for (; size > digits; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append(Integer.toString(value)); [EOL]     } [EOL] }
public static void appendPaddedInteger(StringBuffer buf, int value, int size) { [EOL]     if (value < 0) { [EOL]         buf.append('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             for (; size > 10; size--) { [EOL]                 buf.append('0'); [EOL]             } [EOL]             buf.append("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         for (; size > 1; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append((char) (value + '0')); [EOL]     } else if (value < 100) { [EOL]         for (; size > 2; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         buf.append((char) (d + '0')); [EOL]         buf.append((char) (value - (d << 3) - (d << 1) + '0')); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else if (value < 10000) { [EOL]             digits = 4; [EOL]         } else { [EOL]             digits = (int) (Math.log(value) / LOG_10) + 1; [EOL]         } [EOL]         for (; size > digits; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append(Integer.toString(value)); [EOL]     } [EOL] }
public static void appendPaddedInteger(StringBuffer buf, int value, int size) { [EOL]     if (value < 0) { [EOL]         buf.append('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             for (; size > 10; size--) { [EOL]                 buf.append('0'); [EOL]             } [EOL]             buf.append("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         for (; size > 1; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append((char) (value + '0')); [EOL]     } else if (value < 100) { [EOL]         for (; size > 2; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         buf.append((char) (d + '0')); [EOL]         buf.append((char) (value - (d << 3) - (d << 1) + '0')); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else if (value < 10000) { [EOL]             digits = 4; [EOL]         } else { [EOL]             digits = (int) (Math.log(value) / LOG_10) + 1; [EOL]         } [EOL]         for (; size > digits; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append(Integer.toString(value)); [EOL]     } [EOL] }
public static void appendPaddedInteger(StringBuffer buf, int value, int size) { [EOL]     if (value < 0) { [EOL]         buf.append('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             for (; size > 10; size--) { [EOL]                 buf.append('0'); [EOL]             } [EOL]             buf.append("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         for (; size > 1; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append((char) (value + '0')); [EOL]     } else if (value < 100) { [EOL]         for (; size > 2; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         buf.append((char) (d + '0')); [EOL]         buf.append((char) (value - (d << 3) - (d << 1) + '0')); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else if (value < 10000) { [EOL]             digits = 4; [EOL]         } else { [EOL]             digits = (int) (Math.log(value) / LOG_10) + 1; [EOL]         } [EOL]         for (; size > digits; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append(Integer.toString(value)); [EOL]     } [EOL] }
public static void appendPaddedInteger(StringBuffer buf, int value, int size) { [EOL]     if (value < 0) { [EOL]         buf.append('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             for (; size > 10; size--) { [EOL]                 buf.append('0'); [EOL]             } [EOL]             buf.append("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         for (; size > 1; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append((char) (value + '0')); [EOL]     } else if (value < 100) { [EOL]         for (; size > 2; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         buf.append((char) (d + '0')); [EOL]         buf.append((char) (value - (d << 3) - (d << 1) + '0')); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else if (value < 10000) { [EOL]             digits = 4; [EOL]         } else { [EOL]             digits = (int) (Math.log(value) / LOG_10) + 1; [EOL]         } [EOL]         for (; size > digits; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append(Integer.toString(value)); [EOL]     } [EOL] }
public static void appendPaddedInteger(StringBuffer buf, int value, int size) { [EOL]     if (value < 0) { [EOL]         buf.append('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             for (; size > 10; size--) { [EOL]                 buf.append('0'); [EOL]             } [EOL]             buf.append("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         for (; size > 1; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append((char) (value + '0')); [EOL]     } else if (value < 100) { [EOL]         for (; size > 2; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         buf.append((char) (d + '0')); [EOL]         buf.append((char) (value - (d << 3) - (d << 1) + '0')); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else if (value < 10000) { [EOL]             digits = 4; [EOL]         } else { [EOL]             digits = (int) (Math.log(value) / LOG_10) + 1; [EOL]         } [EOL]         for (; size > digits; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append(Integer.toString(value)); [EOL]     } [EOL] }
public static void appendPaddedInteger(StringBuffer buf, int value, int size) { [EOL]     if (value < 0) { [EOL]         buf.append('-'); [EOL]         if (value != Integer.MIN_VALUE) { [EOL]             value = -value; [EOL]         } else { [EOL]             for (; size > 10; size--) { [EOL]                 buf.append('0'); [EOL]             } [EOL]             buf.append("" + -(long) Integer.MIN_VALUE); [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value < 10) { [EOL]         for (; size > 1; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append((char) (value + '0')); [EOL]     } else if (value < 100) { [EOL]         for (; size > 2; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         int d = ((value + 1) * 13421772) >> 27; [EOL]         buf.append((char) (d + '0')); [EOL]         buf.append((char) (value - (d << 3) - (d << 1) + '0')); [EOL]     } else { [EOL]         int digits; [EOL]         if (value < 1000) { [EOL]             digits = 3; [EOL]         } else if (value < 10000) { [EOL]             digits = 4; [EOL]         } else { [EOL]             digits = (int) (Math.log(value) / LOG_10) + 1; [EOL]         } [EOL]         for (; size > digits; size--) { [EOL]             buf.append('0'); [EOL]         } [EOL]         buf.append(Integer.toString(value)); [EOL]     } [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     int relativeYear = year - 1968; [EOL]     int leapYears; [EOL]     if (relativeYear <= 0) { [EOL]         leapYears = (relativeYear + 3) >> 2; [EOL]     } else { [EOL]         leapYears = relativeYear >> 2; [EOL]         if (!isLeapYear(year)) { [EOL]             leapYears++; [EOL]         } [EOL]     } [EOL]     long millis = (relativeYear * 365L + leapYears) * (long) DateTimeConstants.MILLIS_PER_DAY; [EOL]     return millis - (366L + 352) * DateTimeConstants.MILLIS_PER_DAY; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     int relativeYear = year - 1968; [EOL]     int leapYears; [EOL]     if (relativeYear <= 0) { [EOL]         leapYears = (relativeYear + 3) >> 2; [EOL]     } else { [EOL]         leapYears = relativeYear >> 2; [EOL]         if (!isLeapYear(year)) { [EOL]             leapYears++; [EOL]         } [EOL]     } [EOL]     long millis = (relativeYear * 365L + leapYears) * (long) DateTimeConstants.MILLIS_PER_DAY; [EOL]     return millis - (366L + 352) * DateTimeConstants.MILLIS_PER_DAY; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     int relativeYear = year - 1968; [EOL]     int leapYears; [EOL]     if (relativeYear <= 0) { [EOL]         leapYears = (relativeYear + 3) >> 2; [EOL]     } else { [EOL]         leapYears = relativeYear >> 2; [EOL]         if (!isLeapYear(year)) { [EOL]             leapYears++; [EOL]         } [EOL]     } [EOL]     long millis = (relativeYear * 365L + leapYears) * (long) DateTimeConstants.MILLIS_PER_DAY; [EOL]     return millis - (366L + 352) * DateTimeConstants.MILLIS_PER_DAY; [EOL] }
public Chronology getChronology(Object object, Chronology chrono) { [EOL]     if (chrono == null) { [EOL]         chrono = ((ReadableInstant) object).getChronology(); [EOL]         chrono = DateTimeUtils.getChronology(chrono); [EOL]     } [EOL]     return chrono; [EOL] }
public Chronology getChronology(Object object, Chronology chrono) { [EOL]     if (chrono == null) { [EOL]         chrono = ((ReadableInstant) object).getChronology(); [EOL]         chrono = DateTimeUtils.getChronology(chrono); [EOL]     } [EOL]     return chrono; [EOL] }
public static BuddhistChronology getInstance() { [EOL]     return getInstance(DateTimeZone.getDefault()); [EOL] }
public static synchronized BuddhistChronology getInstance(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     BuddhistChronology chrono; [EOL]     synchronized (cCache) { [EOL]         chrono = cCache.get(zone); [EOL]         if (chrono == null) { [EOL]             chrono = new BuddhistChronology(GJChronology.getInstance(zone, null), null); [EOL]             DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]             chrono = new BuddhistChronology(LimitChronology.getInstance(chrono, lowerLimit, null), ""); [EOL]             cCache.put(zone, chrono); [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static synchronized BuddhistChronology getInstance(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     BuddhistChronology chrono; [EOL]     synchronized (cCache) { [EOL]         chrono = cCache.get(zone); [EOL]         if (chrono == null) { [EOL]             chrono = new BuddhistChronology(GJChronology.getInstance(zone, null), null); [EOL]             DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]             chrono = new BuddhistChronology(LimitChronology.getInstance(chrono, lowerLimit, null), ""); [EOL]             cCache.put(zone, chrono); [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public int getMinimumValueOverall() { [EOL]     return getField().getMinimumValue(); [EOL] }
public int getMaximumValueOverall() { [EOL]     return getField().getMaximumValue(); [EOL] }
public int getMaximumValue() { [EOL]     return getField().getMaximumValue(getReadablePartial()); [EOL] }
public int getMaximumValue() { [EOL]     return getField().getMaximumValue(getReadablePartial()); [EOL] }
public boolean equals(Object object) { [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof AbstractPartialFieldProperty == false) { [EOL]         return false; [EOL]     } [EOL]     AbstractPartialFieldProperty other = (AbstractPartialFieldProperty) object; [EOL]     return get() == other.get() && getFieldType() == other.getFieldType() && FieldUtils.equals(getReadablePartial().getChronology(), other.getReadablePartial().getChronology()); [EOL] }
public boolean equals(Object object) { [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof AbstractPartialFieldProperty == false) { [EOL]         return false; [EOL]     } [EOL]     AbstractPartialFieldProperty other = (AbstractPartialFieldProperty) object; [EOL]     return get() == other.get() && getFieldType() == other.getFieldType() && FieldUtils.equals(getReadablePartial().getChronology(), other.getReadablePartial().getChronology()); [EOL] }
public boolean equals(Object object) { [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof AbstractPartialFieldProperty == false) { [EOL]         return false; [EOL]     } [EOL]     AbstractPartialFieldProperty other = (AbstractPartialFieldProperty) object; [EOL]     return get() == other.get() && getFieldType() == other.getFieldType() && FieldUtils.equals(getReadablePartial().getChronology(), other.getReadablePartial().getChronology()); [EOL] }
public boolean equals(Object object) { [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof AbstractPartialFieldProperty == false) { [EOL]         return false; [EOL]     } [EOL]     AbstractPartialFieldProperty other = (AbstractPartialFieldProperty) object; [EOL]     return get() == other.get() && getFieldType() == other.getFieldType() && FieldUtils.equals(getReadablePartial().getChronology(), other.getReadablePartial().getChronology()); [EOL] }
public boolean equals(Object object) { [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof AbstractPartialFieldProperty == false) { [EOL]         return false; [EOL]     } [EOL]     AbstractPartialFieldProperty other = (AbstractPartialFieldProperty) object; [EOL]     return get() == other.get() && getFieldType() == other.getFieldType() && FieldUtils.equals(getReadablePartial().getChronology(), other.getReadablePartial().getChronology()); [EOL] }
public boolean equals(Object object) { [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof AbstractPartialFieldProperty == false) { [EOL]         return false; [EOL]     } [EOL]     AbstractPartialFieldProperty other = (AbstractPartialFieldProperty) object; [EOL]     return get() == other.get() && getFieldType() == other.getFieldType() && FieldUtils.equals(getReadablePartial().getChronology(), other.getReadablePartial().getChronology()); [EOL] }
public boolean equals(Object object) { [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof AbstractPartialFieldProperty == false) { [EOL]         return false; [EOL]     } [EOL]     AbstractPartialFieldProperty other = (AbstractPartialFieldProperty) object; [EOL]     return get() == other.get() && getFieldType() == other.getFieldType() && FieldUtils.equals(getReadablePartial().getChronology(), other.getReadablePartial().getChronology()); [EOL] }
public int hashCode() { [EOL]     int hash = 19; [EOL]     hash = 13 * hash + get(); [EOL]     hash = 13 * hash + getFieldType().hashCode(); [EOL]     hash = 13 * hash + getReadablePartial().getChronology().hashCode(); [EOL]     return hash; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof PreciseDurationField) { [EOL]         PreciseDurationField other = (PreciseDurationField) obj; [EOL]         return (getType() == other.getType()) && (iUnitMillis == other.iUnitMillis); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof PreciseDurationField) { [EOL]         PreciseDurationField other = (PreciseDurationField) obj; [EOL]         return (getType() == other.getType()) && (iUnitMillis == other.iUnitMillis); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof PreciseDurationField) { [EOL]         PreciseDurationField other = (PreciseDurationField) obj; [EOL]         return (getType() == other.getType()) && (iUnitMillis == other.iUnitMillis); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof PreciseDurationField) { [EOL]         PreciseDurationField other = (PreciseDurationField) obj; [EOL]         return (getType() == other.getType()) && (iUnitMillis == other.iUnitMillis); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof PreciseDurationField) { [EOL]         PreciseDurationField other = (PreciseDurationField) obj; [EOL]         return (getType() == other.getType()) && (iUnitMillis == other.iUnitMillis); [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } else if (obj instanceof PreciseDurationField) { [EOL]         PreciseDurationField other = (PreciseDurationField) obj; [EOL]         return (getType() == other.getType()) && (iUnitMillis == other.iUnitMillis); [EOL]     } [EOL]     return false; [EOL] }
public long add(long instant, int months) { [EOL]     if (months == 0) { [EOL]         return instant; [EOL]     } [EOL]     long timePart = iChronology.getMillisOfDay(instant); [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int thisMonth = iChronology.getMonthOfYear(instant, thisYear); [EOL]     int yearToUse; [EOL]     int monthToUse = thisMonth - 1 + months; [EOL]     if (monthToUse >= 0) { [EOL]         yearToUse = thisYear + (monthToUse / iMax); [EOL]         monthToUse = (monthToUse % iMax) + 1; [EOL]     } else { [EOL]         yearToUse = thisYear + (monthToUse / iMax) - 1; [EOL]         monthToUse = Math.abs(monthToUse); [EOL]         int remMonthToUse = monthToUse % iMax; [EOL]         if (remMonthToUse == 0) { [EOL]             remMonthToUse = iMax; [EOL]         } [EOL]         monthToUse = iMax - remMonthToUse + 1; [EOL]         if (monthToUse == 1) { [EOL]             yearToUse += 1; [EOL]         } [EOL]     } [EOL]     int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth); [EOL]     int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse); [EOL]     if (dayToUse > maxDay) { [EOL]         dayToUse = maxDay; [EOL]     } [EOL]     long datePart = iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse); [EOL]     return datePart + timePart; [EOL] }
public long add(long instant, int months) { [EOL]     if (months == 0) { [EOL]         return instant; [EOL]     } [EOL]     long timePart = iChronology.getMillisOfDay(instant); [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int thisMonth = iChronology.getMonthOfYear(instant, thisYear); [EOL]     int yearToUse; [EOL]     int monthToUse = thisMonth - 1 + months; [EOL]     if (monthToUse >= 0) { [EOL]         yearToUse = thisYear + (monthToUse / iMax); [EOL]         monthToUse = (monthToUse % iMax) + 1; [EOL]     } else { [EOL]         yearToUse = thisYear + (monthToUse / iMax) - 1; [EOL]         monthToUse = Math.abs(monthToUse); [EOL]         int remMonthToUse = monthToUse % iMax; [EOL]         if (remMonthToUse == 0) { [EOL]             remMonthToUse = iMax; [EOL]         } [EOL]         monthToUse = iMax - remMonthToUse + 1; [EOL]         if (monthToUse == 1) { [EOL]             yearToUse += 1; [EOL]         } [EOL]     } [EOL]     int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth); [EOL]     int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse); [EOL]     if (dayToUse > maxDay) { [EOL]         dayToUse = maxDay; [EOL]     } [EOL]     long datePart = iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse); [EOL]     return datePart + timePart; [EOL] }
public long add(long instant, int months) { [EOL]     if (months == 0) { [EOL]         return instant; [EOL]     } [EOL]     long timePart = iChronology.getMillisOfDay(instant); [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int thisMonth = iChronology.getMonthOfYear(instant, thisYear); [EOL]     int yearToUse; [EOL]     int monthToUse = thisMonth - 1 + months; [EOL]     if (monthToUse >= 0) { [EOL]         yearToUse = thisYear + (monthToUse / iMax); [EOL]         monthToUse = (monthToUse % iMax) + 1; [EOL]     } else { [EOL]         yearToUse = thisYear + (monthToUse / iMax) - 1; [EOL]         monthToUse = Math.abs(monthToUse); [EOL]         int remMonthToUse = monthToUse % iMax; [EOL]         if (remMonthToUse == 0) { [EOL]             remMonthToUse = iMax; [EOL]         } [EOL]         monthToUse = iMax - remMonthToUse + 1; [EOL]         if (monthToUse == 1) { [EOL]             yearToUse += 1; [EOL]         } [EOL]     } [EOL]     int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth); [EOL]     int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse); [EOL]     if (dayToUse > maxDay) { [EOL]         dayToUse = maxDay; [EOL]     } [EOL]     long datePart = iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse); [EOL]     return datePart + timePart; [EOL] }
public long add(long instant, int months) { [EOL]     if (months == 0) { [EOL]         return instant; [EOL]     } [EOL]     long timePart = iChronology.getMillisOfDay(instant); [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int thisMonth = iChronology.getMonthOfYear(instant, thisYear); [EOL]     int yearToUse; [EOL]     int monthToUse = thisMonth - 1 + months; [EOL]     if (monthToUse >= 0) { [EOL]         yearToUse = thisYear + (monthToUse / iMax); [EOL]         monthToUse = (monthToUse % iMax) + 1; [EOL]     } else { [EOL]         yearToUse = thisYear + (monthToUse / iMax) - 1; [EOL]         monthToUse = Math.abs(monthToUse); [EOL]         int remMonthToUse = monthToUse % iMax; [EOL]         if (remMonthToUse == 0) { [EOL]             remMonthToUse = iMax; [EOL]         } [EOL]         monthToUse = iMax - remMonthToUse + 1; [EOL]         if (monthToUse == 1) { [EOL]             yearToUse += 1; [EOL]         } [EOL]     } [EOL]     int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth); [EOL]     int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse); [EOL]     if (dayToUse > maxDay) { [EOL]         dayToUse = maxDay; [EOL]     } [EOL]     long datePart = iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse); [EOL]     return datePart + timePart; [EOL] }
public long add(long instant, int months) { [EOL]     if (months == 0) { [EOL]         return instant; [EOL]     } [EOL]     long timePart = iChronology.getMillisOfDay(instant); [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int thisMonth = iChronology.getMonthOfYear(instant, thisYear); [EOL]     int yearToUse; [EOL]     int monthToUse = thisMonth - 1 + months; [EOL]     if (monthToUse >= 0) { [EOL]         yearToUse = thisYear + (monthToUse / iMax); [EOL]         monthToUse = (monthToUse % iMax) + 1; [EOL]     } else { [EOL]         yearToUse = thisYear + (monthToUse / iMax) - 1; [EOL]         monthToUse = Math.abs(monthToUse); [EOL]         int remMonthToUse = monthToUse % iMax; [EOL]         if (remMonthToUse == 0) { [EOL]             remMonthToUse = iMax; [EOL]         } [EOL]         monthToUse = iMax - remMonthToUse + 1; [EOL]         if (monthToUse == 1) { [EOL]             yearToUse += 1; [EOL]         } [EOL]     } [EOL]     int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth); [EOL]     int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse); [EOL]     if (dayToUse > maxDay) { [EOL]         dayToUse = maxDay; [EOL]     } [EOL]     long datePart = iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse); [EOL]     return datePart + timePart; [EOL] }
public long add(long instant, int months) { [EOL]     if (months == 0) { [EOL]         return instant; [EOL]     } [EOL]     long timePart = iChronology.getMillisOfDay(instant); [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int thisMonth = iChronology.getMonthOfYear(instant, thisYear); [EOL]     int yearToUse; [EOL]     int monthToUse = thisMonth - 1 + months; [EOL]     if (monthToUse >= 0) { [EOL]         yearToUse = thisYear + (monthToUse / iMax); [EOL]         monthToUse = (monthToUse % iMax) + 1; [EOL]     } else { [EOL]         yearToUse = thisYear + (monthToUse / iMax) - 1; [EOL]         monthToUse = Math.abs(monthToUse); [EOL]         int remMonthToUse = monthToUse % iMax; [EOL]         if (remMonthToUse == 0) { [EOL]             remMonthToUse = iMax; [EOL]         } [EOL]         monthToUse = iMax - remMonthToUse + 1; [EOL]         if (monthToUse == 1) { [EOL]             yearToUse += 1; [EOL]         } [EOL]     } [EOL]     int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth); [EOL]     int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse); [EOL]     if (dayToUse > maxDay) { [EOL]         dayToUse = maxDay; [EOL]     } [EOL]     long datePart = iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse); [EOL]     return datePart + timePart; [EOL] }
public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) { [EOL]         int curMonth0 = partial.getValue(0) - 1; [EOL]         int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1; [EOL]         return set(partial, 0, values, newMonth); [EOL]     } [EOL]     if (DateTimeUtils.isContiguous(partial)) { [EOL]         long instant = 0L; [EOL]         for (int i = 0, isize = partial.size(); i < isize; i++) { [EOL]             instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); [EOL]         } [EOL]         instant = add(instant, valueToAdd); [EOL]         return iChronology.get(partial, instant); [EOL]     } else { [EOL]         return super.add(partial, fieldIndex, values, valueToAdd); [EOL]     } [EOL] }
public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) { [EOL]         int curMonth0 = partial.getValue(0) - 1; [EOL]         int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1; [EOL]         return set(partial, 0, values, newMonth); [EOL]     } [EOL]     if (DateTimeUtils.isContiguous(partial)) { [EOL]         long instant = 0L; [EOL]         for (int i = 0, isize = partial.size(); i < isize; i++) { [EOL]             instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); [EOL]         } [EOL]         instant = add(instant, valueToAdd); [EOL]         return iChronology.get(partial, instant); [EOL]     } else { [EOL]         return super.add(partial, fieldIndex, values, valueToAdd); [EOL]     } [EOL] }
public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) { [EOL]         int curMonth0 = partial.getValue(0) - 1; [EOL]         int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1; [EOL]         return set(partial, 0, values, newMonth); [EOL]     } [EOL]     if (DateTimeUtils.isContiguous(partial)) { [EOL]         long instant = 0L; [EOL]         for (int i = 0, isize = partial.size(); i < isize; i++) { [EOL]             instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); [EOL]         } [EOL]         instant = add(instant, valueToAdd); [EOL]         return iChronology.get(partial, instant); [EOL]     } else { [EOL]         return super.add(partial, fieldIndex, values, valueToAdd); [EOL]     } [EOL] }
public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) { [EOL]     if (valueToAdd == 0) { [EOL]         return values; [EOL]     } [EOL]     if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) { [EOL]         int curMonth0 = partial.getValue(0) - 1; [EOL]         int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1; [EOL]         return set(partial, 0, values, newMonth); [EOL]     } [EOL]     if (DateTimeUtils.isContiguous(partial)) { [EOL]         long instant = 0L; [EOL]         for (int i = 0, isize = partial.size(); i < isize; i++) { [EOL]             instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]); [EOL]         } [EOL]         instant = add(instant, valueToAdd); [EOL]         return iChronology.get(partial, instant); [EOL]     } else { [EOL]         return super.add(partial, fieldIndex, values, valueToAdd); [EOL]     } [EOL] }
public long set(long instant, int month) { [EOL]     FieldUtils.verifyValueBounds(this, month, MIN, iMax); [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int thisDom = iChronology.getDayOfMonth(instant, thisYear); [EOL]     int maxDom = iChronology.getDaysInYearMonth(thisYear, month); [EOL]     if (thisDom > maxDom) { [EOL]         thisDom = maxDom; [EOL]     } [EOL]     return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) + iChronology.getMillisOfDay(instant); [EOL] }
public boolean isLeap(long instant) { [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     if (iChronology.isLeapYear(thisYear)) { [EOL]         return (iChronology.getMonthOfYear(instant, thisYear) == iLeapMonth); [EOL]     } [EOL]     return false; [EOL] }
public int getLeapAmount(long instant) { [EOL]     return isLeap(instant) ? 1 : 0; [EOL] }
public int getMinimumValue() { [EOL]     return MIN; [EOL] }
public int getMaximumValue() { [EOL]     return iMax; [EOL] }
public int getMaximumValue(ReadablePartial partial, int[] values) { [EOL]     int size = partial.size(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (partial.getFieldType(i) == DateTimeFieldType.year()) { [EOL]             int year = values[i]; [EOL]             return iChronology.getDaysInYear(year); [EOL]         } [EOL]     } [EOL]     return iChronology.getDaysInYearMax(); [EOL] }
public int getMaximumValue(ReadablePartial partial, int[] values) { [EOL]     int size = partial.size(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (partial.getFieldType(i) == DateTimeFieldType.year()) { [EOL]             int year = values[i]; [EOL]             return iChronology.getDaysInYear(year); [EOL]         } [EOL]     } [EOL]     return iChronology.getDaysInYearMax(); [EOL] }
public int getMaximumValue(ReadablePartial partial, int[] values) { [EOL]     int size = partial.size(); [EOL]     for (int i = 0; i < size; i++) { [EOL]         if (partial.getFieldType(i) == DateTimeFieldType.year()) { [EOL]             int year = values[i]; [EOL]             return iChronology.getDaysInYear(year); [EOL]         } [EOL]     } [EOL]     return iChronology.getDaysInYearMax(); [EOL] }
public static long safeSubtract(long val1, long val2) { [EOL]     long diff = val1 - val2; [EOL]     if ((val1 ^ diff) < 0 && (val1 ^ val2) < 0) { [EOL]         throw new ArithmeticException("The calculation caused an overflow: " + val1 + " - " + val2); [EOL]     } [EOL]     return diff; [EOL] }
public static long safeSubtract(long val1, long val2) { [EOL]     long diff = val1 - val2; [EOL]     if ((val1 ^ diff) < 0 && (val1 ^ val2) < 0) { [EOL]         throw new ArithmeticException("The calculation caused an overflow: " + val1 + " - " + val2); [EOL]     } [EOL]     return diff; [EOL] }
public static long safeSubtract(long val1, long val2) { [EOL]     long diff = val1 - val2; [EOL]     if ((val1 ^ diff) < 0 && (val1 ^ val2) < 0) { [EOL]         throw new ArithmeticException("The calculation caused an overflow: " + val1 + " - " + val2); [EOL]     } [EOL]     return diff; [EOL] }
public static void verifyValueBounds(DateTimeField field, int value, int lowerBound, int upperBound) { [EOL]     if ((value < lowerBound) || (value > upperBound)) { [EOL]         throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), Integer.valueOf(lowerBound), Integer.valueOf(upperBound)); [EOL]     } [EOL] }
public static void verifyValueBounds(DateTimeField field, int value, int lowerBound, int upperBound) { [EOL]     if ((value < lowerBound) || (value > upperBound)) { [EOL]         throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), Integer.valueOf(lowerBound), Integer.valueOf(upperBound)); [EOL]     } [EOL] }
public static void verifyValueBounds(DateTimeField field, int value, int lowerBound, int upperBound) { [EOL]     if ((value < lowerBound) || (value > upperBound)) { [EOL]         throw new IllegalFieldValueException(field.getType(), Integer.valueOf(value), Integer.valueOf(lowerBound), Integer.valueOf(upperBound)); [EOL]     } [EOL] }
public static void verifyValueBounds(DateTimeFieldType fieldType, int value, int lowerBound, int upperBound) { [EOL]     if ((value < lowerBound) || (value > upperBound)) { [EOL]         throw new IllegalFieldValueException(fieldType, Integer.valueOf(value), Integer.valueOf(lowerBound), Integer.valueOf(upperBound)); [EOL]     } [EOL] }
public static void verifyValueBounds(DateTimeFieldType fieldType, int value, int lowerBound, int upperBound) { [EOL]     if ((value < lowerBound) || (value > upperBound)) { [EOL]         throw new IllegalFieldValueException(fieldType, Integer.valueOf(value), Integer.valueOf(lowerBound), Integer.valueOf(upperBound)); [EOL]     } [EOL] }
public static void verifyValueBounds(DateTimeFieldType fieldType, int value, int lowerBound, int upperBound) { [EOL]     if ((value < lowerBound) || (value > upperBound)) { [EOL]         throw new IllegalFieldValueException(fieldType, Integer.valueOf(value), Integer.valueOf(lowerBound), Integer.valueOf(upperBound)); [EOL]     } [EOL] }
public static void verifyValueBounds(String fieldName, int value, int lowerBound, int upperBound) { [EOL]     if ((value < lowerBound) || (value > upperBound)) { [EOL]         throw new IllegalFieldValueException(fieldName, Integer.valueOf(value), Integer.valueOf(lowerBound), Integer.valueOf(upperBound)); [EOL]     } [EOL] }
public static void verifyValueBounds(String fieldName, int value, int lowerBound, int upperBound) { [EOL]     if ((value < lowerBound) || (value > upperBound)) { [EOL]         throw new IllegalFieldValueException(fieldName, Integer.valueOf(value), Integer.valueOf(lowerBound), Integer.valueOf(upperBound)); [EOL]     } [EOL] }
public static void verifyValueBounds(String fieldName, int value, int lowerBound, int upperBound) { [EOL]     if ((value < lowerBound) || (value > upperBound)) { [EOL]         throw new IllegalFieldValueException(fieldName, Integer.valueOf(value), Integer.valueOf(lowerBound), Integer.valueOf(upperBound)); [EOL]     } [EOL] }
public static int getWrappedValue(int value, int minValue, int maxValue) { [EOL]     if (minValue >= maxValue) { [EOL]         throw new IllegalArgumentException("MIN > MAX"); [EOL]     } [EOL]     int wrapRange = maxValue - minValue + 1; [EOL]     value -= minValue; [EOL]     if (value >= 0) { [EOL]         return (value % wrapRange) + minValue; [EOL]     } [EOL]     int remByRange = (-value) % wrapRange; [EOL]     if (remByRange == 0) { [EOL]         return 0 + minValue; [EOL]     } [EOL]     return (wrapRange - remByRange) + minValue; [EOL] }
public static int getWrappedValue(int value, int minValue, int maxValue) { [EOL]     if (minValue >= maxValue) { [EOL]         throw new IllegalArgumentException("MIN > MAX"); [EOL]     } [EOL]     int wrapRange = maxValue - minValue + 1; [EOL]     value -= minValue; [EOL]     if (value >= 0) { [EOL]         return (value % wrapRange) + minValue; [EOL]     } [EOL]     int remByRange = (-value) % wrapRange; [EOL]     if (remByRange == 0) { [EOL]         return 0 + minValue; [EOL]     } [EOL]     return (wrapRange - remByRange) + minValue; [EOL] }
public static int getWrappedValue(int value, int minValue, int maxValue) { [EOL]     if (minValue >= maxValue) { [EOL]         throw new IllegalArgumentException("MIN > MAX"); [EOL]     } [EOL]     int wrapRange = maxValue - minValue + 1; [EOL]     value -= minValue; [EOL]     if (value >= 0) { [EOL]         return (value % wrapRange) + minValue; [EOL]     } [EOL]     int remByRange = (-value) % wrapRange; [EOL]     if (remByRange == 0) { [EOL]         return 0 + minValue; [EOL]     } [EOL]     return (wrapRange - remByRange) + minValue; [EOL] }
public static int getWrappedValue(int value, int minValue, int maxValue) { [EOL]     if (minValue >= maxValue) { [EOL]         throw new IllegalArgumentException("MIN > MAX"); [EOL]     } [EOL]     int wrapRange = maxValue - minValue + 1; [EOL]     value -= minValue; [EOL]     if (value >= 0) { [EOL]         return (value % wrapRange) + minValue; [EOL]     } [EOL]     int remByRange = (-value) % wrapRange; [EOL]     if (remByRange == 0) { [EOL]         return 0 + minValue; [EOL]     } [EOL]     return (wrapRange - remByRange) + minValue; [EOL] }
public static int getWrappedValue(int value, int minValue, int maxValue) { [EOL]     if (minValue >= maxValue) { [EOL]         throw new IllegalArgumentException("MIN > MAX"); [EOL]     } [EOL]     int wrapRange = maxValue - minValue + 1; [EOL]     value -= minValue; [EOL]     if (value >= 0) { [EOL]         return (value % wrapRange) + minValue; [EOL]     } [EOL]     int remByRange = (-value) % wrapRange; [EOL]     if (remByRange == 0) { [EOL]         return 0 + minValue; [EOL]     } [EOL]     return (wrapRange - remByRange) + minValue; [EOL] }
public static int getWrappedValue(int value, int minValue, int maxValue) { [EOL]     if (minValue >= maxValue) { [EOL]         throw new IllegalArgumentException("MIN > MAX"); [EOL]     } [EOL]     int wrapRange = maxValue - minValue + 1; [EOL]     value -= minValue; [EOL]     if (value >= 0) { [EOL]         return (value % wrapRange) + minValue; [EOL]     } [EOL]     int remByRange = (-value) % wrapRange; [EOL]     if (remByRange == 0) { [EOL]         return 0 + minValue; [EOL]     } [EOL]     return (wrapRange - remByRange) + minValue; [EOL] }
public final DateTimeField getWrappedField() { [EOL]     return iField; [EOL] }
public int get(long instant) { [EOL]     return iField.get(instant); [EOL] }
public InstantConverter removeInstantConverter(InstantConverter converter) throws SecurityException { [EOL]     checkAlterInstantConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     InstantConverter[] removed = new InstantConverter[1]; [EOL]     iInstantConverters = iInstantConverters.remove(converter, removed); [EOL]     return removed[0]; [EOL] }
public InstantConverter removeInstantConverter(InstantConverter converter) throws SecurityException { [EOL]     checkAlterInstantConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     InstantConverter[] removed = new InstantConverter[1]; [EOL]     iInstantConverters = iInstantConverters.remove(converter, removed); [EOL]     return removed[0]; [EOL] }
public InstantConverter removeInstantConverter(InstantConverter converter) throws SecurityException { [EOL]     checkAlterInstantConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     InstantConverter[] removed = new InstantConverter[1]; [EOL]     iInstantConverters = iInstantConverters.remove(converter, removed); [EOL]     return removed[0]; [EOL] }
public InstantConverter removeInstantConverter(InstantConverter converter) throws SecurityException { [EOL]     checkAlterInstantConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     InstantConverter[] removed = new InstantConverter[1]; [EOL]     iInstantConverters = iInstantConverters.remove(converter, removed); [EOL]     return removed[0]; [EOL] }
public PartialConverter getPartialConverter(Object object) { [EOL]     PartialConverter converter = (PartialConverter) iPartialConverters.select(object == null ? null : object.getClass()); [EOL]     if (converter != null) { [EOL]         return converter; [EOL]     } [EOL]     throw new IllegalArgumentException("No partial converter found for type: " + (object == null ? "null" : object.getClass().getName())); [EOL] }
public PartialConverter getPartialConverter(Object object) { [EOL]     PartialConverter converter = (PartialConverter) iPartialConverters.select(object == null ? null : object.getClass()); [EOL]     if (converter != null) { [EOL]         return converter; [EOL]     } [EOL]     throw new IllegalArgumentException("No partial converter found for type: " + (object == null ? "null" : object.getClass().getName())); [EOL] }
public PartialConverter getPartialConverter(Object object) { [EOL]     PartialConverter converter = (PartialConverter) iPartialConverters.select(object == null ? null : object.getClass()); [EOL]     if (converter != null) { [EOL]         return converter; [EOL]     } [EOL]     throw new IllegalArgumentException("No partial converter found for type: " + (object == null ? "null" : object.getClass().getName())); [EOL] }
public PartialConverter addPartialConverter(PartialConverter converter) throws SecurityException { [EOL]     checkAlterPartialConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     PartialConverter[] removed = new PartialConverter[1]; [EOL]     iPartialConverters = iPartialConverters.add(converter, removed); [EOL]     return removed[0]; [EOL] }
public DurationConverter[] getDurationConverters() { [EOL]     ConverterSet set = iDurationConverters; [EOL]     DurationConverter[] converters = new DurationConverter[set.size()]; [EOL]     set.copyInto(converters); [EOL]     return converters; [EOL] }
public DurationConverter[] getDurationConverters() { [EOL]     ConverterSet set = iDurationConverters; [EOL]     DurationConverter[] converters = new DurationConverter[set.size()]; [EOL]     set.copyInto(converters); [EOL]     return converters; [EOL] }
public DurationConverter addDurationConverter(DurationConverter converter) throws SecurityException { [EOL]     checkAlterDurationConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     DurationConverter[] removed = new DurationConverter[1]; [EOL]     iDurationConverters = iDurationConverters.add(converter, removed); [EOL]     return removed[0]; [EOL] }
public DurationConverter addDurationConverter(DurationConverter converter) throws SecurityException { [EOL]     checkAlterDurationConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     DurationConverter[] removed = new DurationConverter[1]; [EOL]     iDurationConverters = iDurationConverters.add(converter, removed); [EOL]     return removed[0]; [EOL] }
public DurationConverter addDurationConverter(DurationConverter converter) throws SecurityException { [EOL]     checkAlterDurationConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     DurationConverter[] removed = new DurationConverter[1]; [EOL]     iDurationConverters = iDurationConverters.add(converter, removed); [EOL]     return removed[0]; [EOL] }
private void checkAlterDurationConverters() throws SecurityException { [EOL]     SecurityManager sm = System.getSecurityManager(); [EOL]     if (sm != null) { [EOL]         sm.checkPermission(new JodaTimePermission("ConverterManager.alterDurationConverters")); [EOL]     } [EOL] }
private void checkAlterDurationConverters() throws SecurityException { [EOL]     SecurityManager sm = System.getSecurityManager(); [EOL]     if (sm != null) { [EOL]         sm.checkPermission(new JodaTimePermission("ConverterManager.alterDurationConverters")); [EOL]     } [EOL] }
public PeriodConverter removePeriodConverter(PeriodConverter converter) throws SecurityException { [EOL]     checkAlterPeriodConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     PeriodConverter[] removed = new PeriodConverter[1]; [EOL]     iPeriodConverters = iPeriodConverters.remove(converter, removed); [EOL]     return removed[0]; [EOL] }
public PeriodConverter removePeriodConverter(PeriodConverter converter) throws SecurityException { [EOL]     checkAlterPeriodConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     PeriodConverter[] removed = new PeriodConverter[1]; [EOL]     iPeriodConverters = iPeriodConverters.remove(converter, removed); [EOL]     return removed[0]; [EOL] }
public PeriodConverter removePeriodConverter(PeriodConverter converter) throws SecurityException { [EOL]     checkAlterPeriodConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     PeriodConverter[] removed = new PeriodConverter[1]; [EOL]     iPeriodConverters = iPeriodConverters.remove(converter, removed); [EOL]     return removed[0]; [EOL] }
public IntervalConverter[] getIntervalConverters() { [EOL]     ConverterSet set = iIntervalConverters; [EOL]     IntervalConverter[] converters = new IntervalConverter[set.size()]; [EOL]     set.copyInto(converters); [EOL]     return converters; [EOL] }
public IntervalConverter[] getIntervalConverters() { [EOL]     ConverterSet set = iIntervalConverters; [EOL]     IntervalConverter[] converters = new IntervalConverter[set.size()]; [EOL]     set.copyInto(converters); [EOL]     return converters; [EOL] }
public IntervalConverter removeIntervalConverter(IntervalConverter converter) throws SecurityException { [EOL]     checkAlterIntervalConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     IntervalConverter[] removed = new IntervalConverter[1]; [EOL]     iIntervalConverters = iIntervalConverters.remove(converter, removed); [EOL]     return removed[0]; [EOL] }
public IntervalConverter removeIntervalConverter(IntervalConverter converter) throws SecurityException { [EOL]     checkAlterIntervalConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     IntervalConverter[] removed = new IntervalConverter[1]; [EOL]     iIntervalConverters = iIntervalConverters.remove(converter, removed); [EOL]     return removed[0]; [EOL] }
public IntervalConverter removeIntervalConverter(IntervalConverter converter) throws SecurityException { [EOL]     checkAlterIntervalConverters(); [EOL]     if (converter == null) { [EOL]         return null; [EOL]     } [EOL]     IntervalConverter[] removed = new IntervalConverter[1]; [EOL]     iIntervalConverters = iIntervalConverters.remove(converter, removed); [EOL]     return removed[0]; [EOL] }
private void checkAlterIntervalConverters() throws SecurityException { [EOL]     SecurityManager sm = System.getSecurityManager(); [EOL]     if (sm != null) { [EOL]         sm.checkPermission(new JodaTimePermission("ConverterManager.alterIntervalConverters")); [EOL]     } [EOL] }
private void checkAlterIntervalConverters() throws SecurityException { [EOL]     SecurityManager sm = System.getSecurityManager(); [EOL]     if (sm != null) { [EOL]         sm.checkPermission(new JodaTimePermission("ConverterManager.alterIntervalConverters")); [EOL]     } [EOL] }
public String toString() { [EOL]     return "ConverterManager[" + iInstantConverters.size() + " instant," + iPartialConverters.size() + " partial," + iDurationConverters.size() + " duration," + iPeriodConverters.size() + " period," + iIntervalConverters.size() + " interval]"; [EOL] }
public long addWrapField(long instant, int value) { [EOL]     return iField.addWrapField(instant, value); [EOL] }
public boolean isLeap(long instant) { [EOL]     return iField.isLeap(instant); [EOL] }
public int getLeapAmount(long instant) { [EOL]     return iField.getLeapAmount(instant); [EOL] }
public int getMinimumValue(long instant) { [EOL]     return iField.getMinimumValue(instant); [EOL] }
public int getMinimumValue(ReadablePartial instant, int[] values) { [EOL]     return iField.getMinimumValue(instant, values); [EOL] }
public int getMaximumValue(ReadablePartial instant, int[] values) { [EOL]     return iField.getMaximumValue(instant, values); [EOL] }
public long roundCeiling(long instant) { [EOL]     return iField.roundCeiling(instant); [EOL] }
public long roundHalfFloor(long instant) { [EOL]     return iField.roundHalfFloor(instant); [EOL] }
public long roundHalfFloor(long instant) { [EOL]     return iField.roundHalfFloor(instant); [EOL] }
public long roundHalfFloor(long instant) { [EOL]     return iField.roundHalfFloor(instant); [EOL] }
public long roundHalfEven(long instant) { [EOL]     return iField.roundHalfEven(instant); [EOL] }
public static DateTimeComparator getInstance() { [EOL]     return ALL_INSTANCE; [EOL] }
public static DateTimeComparator getInstance(DateTimeFieldType lowerLimit) { [EOL]     return getInstance(lowerLimit, null); [EOL] }
public static DateTimeComparator getInstance(DateTimeFieldType lowerLimit) { [EOL]     return getInstance(lowerLimit, null); [EOL] }
public DateTimeFieldType getLowerLimit() { [EOL]     return iLowerLimit; [EOL] }
public DateTimeFieldType getUpperLimit() { [EOL]     return iUpperLimit; [EOL] }
public int compare(Object lhsObj, Object rhsObj) { [EOL]     InstantConverter conv = ConverterManager.getInstance().getInstantConverter(lhsObj); [EOL]     Chronology lhsChrono = conv.getChronology(lhsObj, (Chronology) null); [EOL]     long lhsMillis = conv.getInstantMillis(lhsObj, lhsChrono); [EOL]     conv = ConverterManager.getInstance().getInstantConverter(rhsObj); [EOL]     Chronology rhsChrono = conv.getChronology(rhsObj, (Chronology) null); [EOL]     long rhsMillis = conv.getInstantMillis(rhsObj, rhsChrono); [EOL]     if (iLowerLimit != null) { [EOL]         lhsMillis = iLowerLimit.getField(lhsChrono).roundFloor(lhsMillis); [EOL]         rhsMillis = iLowerLimit.getField(rhsChrono).roundFloor(rhsMillis); [EOL]     } [EOL]     if (iUpperLimit != null) { [EOL]         lhsMillis = iUpperLimit.getField(lhsChrono).remainder(lhsMillis); [EOL]         rhsMillis = iUpperLimit.getField(rhsChrono).remainder(rhsMillis); [EOL]     } [EOL]     if (lhsMillis < rhsMillis) { [EOL]         return -1; [EOL]     } else if (lhsMillis > rhsMillis) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] }
public int compare(Object lhsObj, Object rhsObj) { [EOL]     InstantConverter conv = ConverterManager.getInstance().getInstantConverter(lhsObj); [EOL]     Chronology lhsChrono = conv.getChronology(lhsObj, (Chronology) null); [EOL]     long lhsMillis = conv.getInstantMillis(lhsObj, lhsChrono); [EOL]     conv = ConverterManager.getInstance().getInstantConverter(rhsObj); [EOL]     Chronology rhsChrono = conv.getChronology(rhsObj, (Chronology) null); [EOL]     long rhsMillis = conv.getInstantMillis(rhsObj, rhsChrono); [EOL]     if (iLowerLimit != null) { [EOL]         lhsMillis = iLowerLimit.getField(lhsChrono).roundFloor(lhsMillis); [EOL]         rhsMillis = iLowerLimit.getField(rhsChrono).roundFloor(rhsMillis); [EOL]     } [EOL]     if (iUpperLimit != null) { [EOL]         lhsMillis = iUpperLimit.getField(lhsChrono).remainder(lhsMillis); [EOL]         rhsMillis = iUpperLimit.getField(rhsChrono).remainder(rhsMillis); [EOL]     } [EOL]     if (lhsMillis < rhsMillis) { [EOL]         return -1; [EOL]     } else if (lhsMillis > rhsMillis) { [EOL]         return 1; [EOL]     } else { [EOL]         return 0; [EOL]     } [EOL] }
public String toString() { [EOL]     if (iLowerLimit == iUpperLimit) { [EOL]         return "DateTimeComparator[" + (iLowerLimit == null ? "" : iLowerLimit.getName()) + "]"; [EOL]     } else { [EOL]         return "DateTimeComparator[" + (iLowerLimit == null ? "" : iLowerLimit.getName()) + "-" + (iUpperLimit == null ? "" : iUpperLimit.getName()) + "]"; [EOL]     } [EOL] }
public String toString() { [EOL]     if (iLowerLimit == iUpperLimit) { [EOL]         return "DateTimeComparator[" + (iLowerLimit == null ? "" : iLowerLimit.getName()) + "]"; [EOL]     } else { [EOL]         return "DateTimeComparator[" + (iLowerLimit == null ? "" : iLowerLimit.getName()) + "-" + (iUpperLimit == null ? "" : iUpperLimit.getName()) + "]"; [EOL]     } [EOL] }
public String toString() { [EOL]     if (iLowerLimit == iUpperLimit) { [EOL]         return "DateTimeComparator[" + (iLowerLimit == null ? "" : iLowerLimit.getName()) + "]"; [EOL]     } else { [EOL]         return "DateTimeComparator[" + (iLowerLimit == null ? "" : iLowerLimit.getName()) + "-" + (iUpperLimit == null ? "" : iUpperLimit.getName()) + "]"; [EOL]     } [EOL] }
public String toString() { [EOL]     if (iLowerLimit == iUpperLimit) { [EOL]         return "DateTimeComparator[" + (iLowerLimit == null ? "" : iLowerLimit.getName()) + "]"; [EOL]     } else { [EOL]         return "DateTimeComparator[" + (iLowerLimit == null ? "" : iLowerLimit.getName()) + "-" + (iUpperLimit == null ? "" : iUpperLimit.getName()) + "]"; [EOL]     } [EOL] }
public String toString() { [EOL]     if (iLowerLimit == iUpperLimit) { [EOL]         return "DateTimeComparator[" + (iLowerLimit == null ? "" : iLowerLimit.getName()) + "]"; [EOL]     } else { [EOL]         return "DateTimeComparator[" + (iLowerLimit == null ? "" : iLowerLimit.getName()) + "-" + (iUpperLimit == null ? "" : iUpperLimit.getName()) + "]"; [EOL]     } [EOL] }
public int getValue(int index) { [EOL]     if (index != 0) { [EOL]         throw new IndexOutOfBoundsException(String.valueOf(index)); [EOL]     } [EOL]     return getValue(); [EOL] }
public int getValue(int index) { [EOL]     if (index != 0) { [EOL]         throw new IndexOutOfBoundsException(String.valueOf(index)); [EOL]     } [EOL]     return getValue(); [EOL] }
public int compareTo(BaseSingleFieldPeriod other) { [EOL]     if (other.getClass() != getClass()) { [EOL]         throw new ClassCastException(getClass() + " cannot be compared to " + other.getClass()); [EOL]     } [EOL]     int otherValue = other.getValue(); [EOL]     int thisValue = getValue(); [EOL]     if (thisValue > otherValue) { [EOL]         return 1; [EOL]     } [EOL]     if (thisValue < otherValue) { [EOL]         return -1; [EOL]     } [EOL]     return 0; [EOL] }
public int compareTo(BaseSingleFieldPeriod other) { [EOL]     if (other.getClass() != getClass()) { [EOL]         throw new ClassCastException(getClass() + " cannot be compared to " + other.getClass()); [EOL]     } [EOL]     int otherValue = other.getValue(); [EOL]     int thisValue = getValue(); [EOL]     if (thisValue > otherValue) { [EOL]         return 1; [EOL]     } [EOL]     if (thisValue < otherValue) { [EOL]         return -1; [EOL]     } [EOL]     return 0; [EOL] }
public int compareTo(BaseSingleFieldPeriod other) { [EOL]     if (other.getClass() != getClass()) { [EOL]         throw new ClassCastException(getClass() + " cannot be compared to " + other.getClass()); [EOL]     } [EOL]     int otherValue = other.getValue(); [EOL]     int thisValue = getValue(); [EOL]     if (thisValue > otherValue) { [EOL]         return 1; [EOL]     } [EOL]     if (thisValue < otherValue) { [EOL]         return -1; [EOL]     } [EOL]     return 0; [EOL] }
public int compareTo(BaseSingleFieldPeriod other) { [EOL]     if (other.getClass() != getClass()) { [EOL]         throw new ClassCastException(getClass() + " cannot be compared to " + other.getClass()); [EOL]     } [EOL]     int otherValue = other.getValue(); [EOL]     int thisValue = getValue(); [EOL]     if (thisValue > otherValue) { [EOL]         return 1; [EOL]     } [EOL]     if (thisValue < otherValue) { [EOL]         return -1; [EOL]     } [EOL]     return 0; [EOL] }
int getMonthOfYear(long millis, int year) { [EOL]     int i = (int) ((millis - getYearMillis(year)) >> 10); [EOL]     return (isLeapYear(year)) ? ((i < 182 * 84375) ? ((i < 91 * 84375) ? ((i < 31 * 84375) ? 1 : (i < 60 * 84375) ? 2 : 3) : ((i < 121 * 84375) ? 4 : (i < 152 * 84375) ? 5 : 6)) : ((i < 274 * 84375) ? ((i < 213 * 84375) ? 7 : (i < 244 * 84375) ? 8 : 9) : ((i < 305 * 84375) ? 10 : (i < 335 * 84375) ? 11 : 12))) : ((i < 181 * 84375) ? ((i < 90 * 84375) ? ((i < 31 * 84375) ? 1 : (i < 59 * 84375) ? 2 : 3) : ((i < 120 * 84375) ? 4 : (i < 151 * 84375) ? 5 : 6)) : ((i < 273 * 84375) ? ((i < 212 * 84375) ? 7 : (i < 243 * 84375) ? 8 : 9) : ((i < 304 * 84375) ? 10 : (i < 334 * 84375) ? 11 : 12))); [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
int getDaysInMonthMax(int month) { [EOL]     return MAX_DAYS_PER_MONTH_ARRAY[month - 1]; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
int getDaysInMonthMax(int month) { [EOL]     return MAX_DAYS_PER_MONTH_ARRAY[month - 1]; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
int getDaysInMonthMax(int month) { [EOL]     return MAX_DAYS_PER_MONTH_ARRAY[month - 1]; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long getYearDifference(long minuendInstant, long subtrahendInstant) { [EOL]     int minuendYear = getYear(minuendInstant); [EOL]     int subtrahendYear = getYear(subtrahendInstant); [EOL]     long minuendRem = minuendInstant - getYearMillis(minuendYear); [EOL]     long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear); [EOL]     if (subtrahendRem >= FEB_29) { [EOL]         if (isLeapYear(subtrahendYear)) { [EOL]             if (!isLeapYear(minuendYear)) { [EOL]                 subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]             } [EOL]         } else if (minuendRem >= FEB_29 && isLeapYear(minuendYear)) { [EOL]             minuendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]         } [EOL]     } [EOL]     int difference = minuendYear - subtrahendYear; [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long getYearDifference(long minuendInstant, long subtrahendInstant) { [EOL]     int minuendYear = getYear(minuendInstant); [EOL]     int subtrahendYear = getYear(subtrahendInstant); [EOL]     long minuendRem = minuendInstant - getYearMillis(minuendYear); [EOL]     long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear); [EOL]     if (subtrahendRem >= FEB_29) { [EOL]         if (isLeapYear(subtrahendYear)) { [EOL]             if (!isLeapYear(minuendYear)) { [EOL]                 subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]             } [EOL]         } else if (minuendRem >= FEB_29 && isLeapYear(minuendYear)) { [EOL]             minuendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]         } [EOL]     } [EOL]     int difference = minuendYear - subtrahendYear; [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long getYearDifference(long minuendInstant, long subtrahendInstant) { [EOL]     int minuendYear = getYear(minuendInstant); [EOL]     int subtrahendYear = getYear(subtrahendInstant); [EOL]     long minuendRem = minuendInstant - getYearMillis(minuendYear); [EOL]     long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear); [EOL]     if (subtrahendRem >= FEB_29) { [EOL]         if (isLeapYear(subtrahendYear)) { [EOL]             if (!isLeapYear(minuendYear)) { [EOL]                 subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]             } [EOL]         } else if (minuendRem >= FEB_29 && isLeapYear(minuendYear)) { [EOL]             minuendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]         } [EOL]     } [EOL]     int difference = minuendYear - subtrahendYear; [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long getYearDifference(long minuendInstant, long subtrahendInstant) { [EOL]     int minuendYear = getYear(minuendInstant); [EOL]     int subtrahendYear = getYear(subtrahendInstant); [EOL]     long minuendRem = minuendInstant - getYearMillis(minuendYear); [EOL]     long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear); [EOL]     if (subtrahendRem >= FEB_29) { [EOL]         if (isLeapYear(subtrahendYear)) { [EOL]             if (!isLeapYear(minuendYear)) { [EOL]                 subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]             } [EOL]         } else if (minuendRem >= FEB_29 && isLeapYear(minuendYear)) { [EOL]             minuendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]         } [EOL]     } [EOL]     int difference = minuendYear - subtrahendYear; [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long getYearDifference(long minuendInstant, long subtrahendInstant) { [EOL]     int minuendYear = getYear(minuendInstant); [EOL]     int subtrahendYear = getYear(subtrahendInstant); [EOL]     long minuendRem = minuendInstant - getYearMillis(minuendYear); [EOL]     long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear); [EOL]     if (subtrahendRem >= FEB_29) { [EOL]         if (isLeapYear(subtrahendYear)) { [EOL]             if (!isLeapYear(minuendYear)) { [EOL]                 subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]             } [EOL]         } else if (minuendRem >= FEB_29 && isLeapYear(minuendYear)) { [EOL]             minuendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]         } [EOL]     } [EOL]     int difference = minuendYear - subtrahendYear; [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long getYearDifference(long minuendInstant, long subtrahendInstant) { [EOL]     int minuendYear = getYear(minuendInstant); [EOL]     int subtrahendYear = getYear(subtrahendInstant); [EOL]     long minuendRem = minuendInstant - getYearMillis(minuendYear); [EOL]     long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear); [EOL]     if (subtrahendRem >= FEB_29) { [EOL]         if (isLeapYear(subtrahendYear)) { [EOL]             if (!isLeapYear(minuendYear)) { [EOL]                 subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]             } [EOL]         } else if (minuendRem >= FEB_29 && isLeapYear(minuendYear)) { [EOL]             minuendRem -= DateTimeConstants.MILLIS_PER_DAY; [EOL]         } [EOL]     } [EOL]     int difference = minuendYear - subtrahendYear; [EOL]     if (minuendRem < subtrahendRem) { [EOL]         difference--; [EOL]     } [EOL]     return difference; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long setYear(long instant, int year) { [EOL]     int thisYear = getYear(instant); [EOL]     int dayOfYear = getDayOfYear(instant, thisYear); [EOL]     int millisOfDay = getMillisOfDay(instant); [EOL]     if (dayOfYear > (31 + 28)) { [EOL]         if (isLeapYear(thisYear)) { [EOL]             if (!isLeapYear(year)) { [EOL]                 dayOfYear--; [EOL]             } [EOL]         } else { [EOL]             if (isLeapYear(year)) { [EOL]                 dayOfYear++; [EOL]             } [EOL]         } [EOL]     } [EOL]     instant = getYearMonthDayMillis(year, 1, dayOfYear); [EOL]     instant += millisOfDay; [EOL]     return instant; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long setYear(long instant, int year) { [EOL]     int thisYear = getYear(instant); [EOL]     int dayOfYear = getDayOfYear(instant, thisYear); [EOL]     int millisOfDay = getMillisOfDay(instant); [EOL]     if (dayOfYear > (31 + 28)) { [EOL]         if (isLeapYear(thisYear)) { [EOL]             if (!isLeapYear(year)) { [EOL]                 dayOfYear--; [EOL]             } [EOL]         } else { [EOL]             if (isLeapYear(year)) { [EOL]                 dayOfYear++; [EOL]             } [EOL]         } [EOL]     } [EOL]     instant = getYearMonthDayMillis(year, 1, dayOfYear); [EOL]     instant += millisOfDay; [EOL]     return instant; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long setYear(long instant, int year) { [EOL]     int thisYear = getYear(instant); [EOL]     int dayOfYear = getDayOfYear(instant, thisYear); [EOL]     int millisOfDay = getMillisOfDay(instant); [EOL]     if (dayOfYear > (31 + 28)) { [EOL]         if (isLeapYear(thisYear)) { [EOL]             if (!isLeapYear(year)) { [EOL]                 dayOfYear--; [EOL]             } [EOL]         } else { [EOL]             if (isLeapYear(year)) { [EOL]                 dayOfYear++; [EOL]             } [EOL]         } [EOL]     } [EOL]     instant = getYearMonthDayMillis(year, 1, dayOfYear); [EOL]     instant += millisOfDay; [EOL]     return instant; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long setYear(long instant, int year) { [EOL]     int thisYear = getYear(instant); [EOL]     int dayOfYear = getDayOfYear(instant, thisYear); [EOL]     int millisOfDay = getMillisOfDay(instant); [EOL]     if (dayOfYear > (31 + 28)) { [EOL]         if (isLeapYear(thisYear)) { [EOL]             if (!isLeapYear(year)) { [EOL]                 dayOfYear--; [EOL]             } [EOL]         } else { [EOL]             if (isLeapYear(year)) { [EOL]                 dayOfYear++; [EOL]             } [EOL]         } [EOL]     } [EOL]     instant = getYearMonthDayMillis(year, 1, dayOfYear); [EOL]     instant += millisOfDay; [EOL]     return instant; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
long setYear(long instant, int year) { [EOL]     int thisYear = getYear(instant); [EOL]     int dayOfYear = getDayOfYear(instant, thisYear); [EOL]     int millisOfDay = getMillisOfDay(instant); [EOL]     if (dayOfYear > (31 + 28)) { [EOL]         if (isLeapYear(thisYear)) { [EOL]             if (!isLeapYear(year)) { [EOL]                 dayOfYear--; [EOL]             } [EOL]         } else { [EOL]             if (isLeapYear(year)) { [EOL]                 dayOfYear++; [EOL]             } [EOL]         } [EOL]     } [EOL]     instant = getYearMonthDayMillis(year, 1, dayOfYear); [EOL]     instant += millisOfDay; [EOL]     return instant; [EOL] }  BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek);  int getMonthOfYear(long millis, int year);  int getDaysInYearMonth(int year, int month);  int getDaysInMonthMax(int month);  int getDaysInMonthMaxForSet(long instant, int value);  long getTotalMillisByYearMonth(int year, int month);  long getYearDifference(long minuendInstant, long subtrahendInstant);  long setYear(long instant, int year); long serialVersionUID=Optional[538276888268L]; int[] MIN_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }]; int[] MAX_DAYS_PER_MONTH_ARRAY=Optional[{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
public static Seconds seconds(int seconds) { [EOL]     switch(seconds) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Seconds(seconds); [EOL]     } [EOL] }
public static Seconds seconds(int seconds) { [EOL]     switch(seconds) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Seconds(seconds); [EOL]     } [EOL] }
public static Seconds seconds(int seconds) { [EOL]     switch(seconds) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Seconds(seconds); [EOL]     } [EOL] }
public static Seconds seconds(int seconds) { [EOL]     switch(seconds) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Seconds(seconds); [EOL]     } [EOL] }
public static Seconds seconds(int seconds) { [EOL]     switch(seconds) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Seconds(seconds); [EOL]     } [EOL] }
public static Seconds seconds(int seconds) { [EOL]     switch(seconds) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Seconds(seconds); [EOL]     } [EOL] }
public static Seconds seconds(int seconds) { [EOL]     switch(seconds) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Seconds(seconds); [EOL]     } [EOL] }
public static Seconds secondsBetween(ReadableInstant start, ReadableInstant end) { [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.seconds()); [EOL]     return Seconds.seconds(amount); [EOL] }
public static Seconds secondsBetween(ReadableInstant start, ReadableInstant end) { [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, DurationFieldType.seconds()); [EOL]     return Seconds.seconds(amount); [EOL] }
public static Seconds secondsIn(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         return Seconds.ZERO; [EOL]     } [EOL]     int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.seconds()); [EOL]     return Seconds.seconds(amount); [EOL] }
public static Seconds secondsIn(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         return Seconds.ZERO; [EOL]     } [EOL]     int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.seconds()); [EOL]     return Seconds.seconds(amount); [EOL] }
public static Seconds standardSecondsIn(ReadablePeriod period) { [EOL]     int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_SECOND); [EOL]     return Seconds.seconds(amount); [EOL] }
public static Seconds standardSecondsIn(ReadablePeriod period) { [EOL]     int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_SECOND); [EOL]     return Seconds.seconds(amount); [EOL] }
public static Seconds standardSecondsIn(ReadablePeriod period) { [EOL]     int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_SECOND); [EOL]     return Seconds.seconds(amount); [EOL] }
public PeriodType getPeriodType() { [EOL]     return PeriodType.seconds(); [EOL] }
public int getSeconds() { [EOL]     return getValue(); [EOL] }
public Seconds minus(int seconds) { [EOL]     return plus(FieldUtils.safeNegate(seconds)); [EOL] }
public Seconds minus(int seconds) { [EOL]     return plus(FieldUtils.safeNegate(seconds)); [EOL] }
public Seconds minus(int seconds) { [EOL]     return plus(FieldUtils.safeNegate(seconds)); [EOL] }
public static LimitChronology getInstance(Chronology base, ReadableDateTime lowerLimit, ReadableDateTime upperLimit) { [EOL]     if (base == null) { [EOL]         throw new IllegalArgumentException("Must supply a chronology"); [EOL]     } [EOL]     lowerLimit = lowerLimit == null ? null : lowerLimit.toDateTime(); [EOL]     upperLimit = upperLimit == null ? null : upperLimit.toDateTime(); [EOL]     if (lowerLimit != null && upperLimit != null) { [EOL]         if (!lowerLimit.isBefore(upperLimit)) { [EOL]             throw new IllegalArgumentException("The lower limit must be come before than the upper limit"); [EOL]         } [EOL]     } [EOL]     return new LimitChronology(base, (DateTime) lowerLimit, (DateTime) upperLimit); [EOL] }
public static LimitChronology getInstance(Chronology base, ReadableDateTime lowerLimit, ReadableDateTime upperLimit) { [EOL]     if (base == null) { [EOL]         throw new IllegalArgumentException("Must supply a chronology"); [EOL]     } [EOL]     lowerLimit = lowerLimit == null ? null : lowerLimit.toDateTime(); [EOL]     upperLimit = upperLimit == null ? null : upperLimit.toDateTime(); [EOL]     if (lowerLimit != null && upperLimit != null) { [EOL]         if (!lowerLimit.isBefore(upperLimit)) { [EOL]             throw new IllegalArgumentException("The lower limit must be come before than the upper limit"); [EOL]         } [EOL]     } [EOL]     return new LimitChronology(base, (DateTime) lowerLimit, (DateTime) upperLimit); [EOL] }
public static LimitChronology getInstance(Chronology base, ReadableDateTime lowerLimit, ReadableDateTime upperLimit) { [EOL]     if (base == null) { [EOL]         throw new IllegalArgumentException("Must supply a chronology"); [EOL]     } [EOL]     lowerLimit = lowerLimit == null ? null : lowerLimit.toDateTime(); [EOL]     upperLimit = upperLimit == null ? null : upperLimit.toDateTime(); [EOL]     if (lowerLimit != null && upperLimit != null) { [EOL]         if (!lowerLimit.isBefore(upperLimit)) { [EOL]             throw new IllegalArgumentException("The lower limit must be come before than the upper limit"); [EOL]         } [EOL]     } [EOL]     return new LimitChronology(base, (DateTime) lowerLimit, (DateTime) upperLimit); [EOL] }
public static LimitChronology getInstance(Chronology base, ReadableDateTime lowerLimit, ReadableDateTime upperLimit) { [EOL]     if (base == null) { [EOL]         throw new IllegalArgumentException("Must supply a chronology"); [EOL]     } [EOL]     lowerLimit = lowerLimit == null ? null : lowerLimit.toDateTime(); [EOL]     upperLimit = upperLimit == null ? null : upperLimit.toDateTime(); [EOL]     if (lowerLimit != null && upperLimit != null) { [EOL]         if (!lowerLimit.isBefore(upperLimit)) { [EOL]             throw new IllegalArgumentException("The lower limit must be come before than the upper limit"); [EOL]         } [EOL]     } [EOL]     return new LimitChronology(base, (DateTime) lowerLimit, (DateTime) upperLimit); [EOL] }
public static LimitChronology getInstance(Chronology base, ReadableDateTime lowerLimit, ReadableDateTime upperLimit) { [EOL]     if (base == null) { [EOL]         throw new IllegalArgumentException("Must supply a chronology"); [EOL]     } [EOL]     lowerLimit = lowerLimit == null ? null : lowerLimit.toDateTime(); [EOL]     upperLimit = upperLimit == null ? null : upperLimit.toDateTime(); [EOL]     if (lowerLimit != null && upperLimit != null) { [EOL]         if (!lowerLimit.isBefore(upperLimit)) { [EOL]             throw new IllegalArgumentException("The lower limit must be come before than the upper limit"); [EOL]         } [EOL]     } [EOL]     return new LimitChronology(base, (DateTime) lowerLimit, (DateTime) upperLimit); [EOL] }
public static LimitChronology getInstance(Chronology base, ReadableDateTime lowerLimit, ReadableDateTime upperLimit) { [EOL]     if (base == null) { [EOL]         throw new IllegalArgumentException("Must supply a chronology"); [EOL]     } [EOL]     lowerLimit = lowerLimit == null ? null : lowerLimit.toDateTime(); [EOL]     upperLimit = upperLimit == null ? null : upperLimit.toDateTime(); [EOL]     if (lowerLimit != null && upperLimit != null) { [EOL]         if (!lowerLimit.isBefore(upperLimit)) { [EOL]             throw new IllegalArgumentException("The lower limit must be come before than the upper limit"); [EOL]         } [EOL]     } [EOL]     return new LimitChronology(base, (DateTime) lowerLimit, (DateTime) upperLimit); [EOL] }
public DateTime getLowerLimit() { [EOL]     return iLowerLimit; [EOL] }
public DateTime getUpperLimit() { [EOL]     return iUpperLimit; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { [EOL]     long instant = getBase().getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]     checkLimits(instant, "resulting"); [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { [EOL]     long instant = getBase().getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]     checkLimits(instant, "resulting"); [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int millisOfDay) throws IllegalArgumentException { [EOL]     long instant = getBase().getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay); [EOL]     checkLimits(instant, "resulting"); [EOL]     return instant; [EOL] }
public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) throws IllegalArgumentException { [EOL]     long instant = getBase().getDateTimeMillis(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL]     checkLimits(instant, "resulting"); [EOL]     return instant; [EOL] }
void checkLimits(long instant, String desc) { [EOL]     DateTime limit; [EOL]     if ((limit = iLowerLimit) != null && instant < limit.getMillis()) { [EOL]         throw new LimitException(desc, true); [EOL]     } [EOL]     if ((limit = iUpperLimit) != null && instant >= limit.getMillis()) { [EOL]         throw new LimitException(desc, false); [EOL]     } [EOL] }
void checkLimits(long instant, String desc) { [EOL]     DateTime limit; [EOL]     if ((limit = iLowerLimit) != null && instant < limit.getMillis()) { [EOL]         throw new LimitException(desc, true); [EOL]     } [EOL]     if ((limit = iUpperLimit) != null && instant >= limit.getMillis()) { [EOL]         throw new LimitException(desc, false); [EOL]     } [EOL] }
void checkLimits(long instant, String desc) { [EOL]     DateTime limit; [EOL]     if ((limit = iLowerLimit) != null && instant < limit.getMillis()) { [EOL]         throw new LimitException(desc, true); [EOL]     } [EOL]     if ((limit = iUpperLimit) != null && instant >= limit.getMillis()) { [EOL]         throw new LimitException(desc, false); [EOL]     } [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof LimitChronology == false) { [EOL]         return false; [EOL]     } [EOL]     LimitChronology chrono = (LimitChronology) obj; [EOL]     return getBase().equals(chrono.getBase()) && FieldUtils.equals(getLowerLimit(), chrono.getLowerLimit()) && FieldUtils.equals(getUpperLimit(), chrono.getUpperLimit()); [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof LimitChronology == false) { [EOL]         return false; [EOL]     } [EOL]     LimitChronology chrono = (LimitChronology) obj; [EOL]     return getBase().equals(chrono.getBase()) && FieldUtils.equals(getLowerLimit(), chrono.getLowerLimit()) && FieldUtils.equals(getUpperLimit(), chrono.getUpperLimit()); [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof LimitChronology == false) { [EOL]         return false; [EOL]     } [EOL]     LimitChronology chrono = (LimitChronology) obj; [EOL]     return getBase().equals(chrono.getBase()) && FieldUtils.equals(getLowerLimit(), chrono.getLowerLimit()) && FieldUtils.equals(getUpperLimit(), chrono.getUpperLimit()); [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof LimitChronology == false) { [EOL]         return false; [EOL]     } [EOL]     LimitChronology chrono = (LimitChronology) obj; [EOL]     return getBase().equals(chrono.getBase()) && FieldUtils.equals(getLowerLimit(), chrono.getLowerLimit()) && FieldUtils.equals(getUpperLimit(), chrono.getUpperLimit()); [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof LimitChronology == false) { [EOL]         return false; [EOL]     } [EOL]     LimitChronology chrono = (LimitChronology) obj; [EOL]     return getBase().equals(chrono.getBase()) && FieldUtils.equals(getLowerLimit(), chrono.getLowerLimit()) && FieldUtils.equals(getUpperLimit(), chrono.getUpperLimit()); [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof LimitChronology == false) { [EOL]         return false; [EOL]     } [EOL]     LimitChronology chrono = (LimitChronology) obj; [EOL]     return getBase().equals(chrono.getBase()) && FieldUtils.equals(getLowerLimit(), chrono.getLowerLimit()) && FieldUtils.equals(getUpperLimit(), chrono.getUpperLimit()); [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof LimitChronology == false) { [EOL]         return false; [EOL]     } [EOL]     LimitChronology chrono = (LimitChronology) obj; [EOL]     return getBase().equals(chrono.getBase()) && FieldUtils.equals(getLowerLimit(), chrono.getLowerLimit()) && FieldUtils.equals(getUpperLimit(), chrono.getUpperLimit()); [EOL] }
public int hashCode() { [EOL]     int hash = 317351877; [EOL]     hash += (getLowerLimit() != null ? getLowerLimit().hashCode() : 0); [EOL]     hash += (getUpperLimit() != null ? getUpperLimit().hashCode() : 0); [EOL]     hash += getBase().hashCode() * 7; [EOL]     return hash; [EOL] }
public int hashCode() { [EOL]     int hash = 317351877; [EOL]     hash += (getLowerLimit() != null ? getLowerLimit().hashCode() : 0); [EOL]     hash += (getUpperLimit() != null ? getUpperLimit().hashCode() : 0); [EOL]     hash += getBase().hashCode() * 7; [EOL]     return hash; [EOL] }
public int hashCode() { [EOL]     int hash = 317351877; [EOL]     hash += (getLowerLimit() != null ? getLowerLimit().hashCode() : 0); [EOL]     hash += (getUpperLimit() != null ? getUpperLimit().hashCode() : 0); [EOL]     hash += getBase().hashCode() * 7; [EOL]     return hash; [EOL] }
public int hashCode() { [EOL]     int hash = 317351877; [EOL]     hash += (getLowerLimit() != null ? getLowerLimit().hashCode() : 0); [EOL]     hash += (getUpperLimit() != null ? getUpperLimit().hashCode() : 0); [EOL]     hash += getBase().hashCode() * 7; [EOL]     return hash; [EOL] }
public int get(long instant) { [EOL]     checkLimits(instant, null); [EOL]     return getWrappedField().get(instant); [EOL] }
public int get(long instant) { [EOL]     checkLimits(instant, null); [EOL]     return getWrappedField().get(instant); [EOL] }
public long add(long instant, int amount) { [EOL]     checkLimits(instant, null); [EOL]     long result = getWrappedField().add(instant, amount); [EOL]     checkLimits(result, "resulting"); [EOL]     return result; [EOL] }
public long addWrapField(long instant, int amount) { [EOL]     checkLimits(instant, null); [EOL]     long result = getWrappedField().addWrapField(instant, amount); [EOL]     checkLimits(result, "resulting"); [EOL]     return result; [EOL] }
public long addWrapField(long instant, int amount) { [EOL]     checkLimits(instant, null); [EOL]     long result = getWrappedField().addWrapField(instant, amount); [EOL]     checkLimits(result, "resulting"); [EOL]     return result; [EOL] }
public long addWrapField(long instant, int amount) { [EOL]     checkLimits(instant, null); [EOL]     long result = getWrappedField().addWrapField(instant, amount); [EOL]     checkLimits(result, "resulting"); [EOL]     return result; [EOL] }
public long set(long instant, int value) { [EOL]     checkLimits(instant, null); [EOL]     long result = getWrappedField().set(instant, value); [EOL]     checkLimits(result, "resulting"); [EOL]     return result; [EOL] }
public long roundFloor(long instant) { [EOL]     checkLimits(instant, null); [EOL]     long result = getWrappedField().roundFloor(instant); [EOL]     checkLimits(result, "resulting"); [EOL]     return result; [EOL] }
public long roundFloor(long instant) { [EOL]     checkLimits(instant, null); [EOL]     long result = getWrappedField().roundFloor(instant); [EOL]     checkLimits(result, "resulting"); [EOL]     return result; [EOL] }
public long roundFloor(long instant) { [EOL]     checkLimits(instant, null); [EOL]     long result = getWrappedField().roundFloor(instant); [EOL]     checkLimits(result, "resulting"); [EOL]     return result; [EOL] }
public int getMonthOfYear() { [EOL]     return getChronology().monthOfYear().get(getMillis()); [EOL] }
public int getDayOfMonth() { [EOL]     return getChronology().dayOfMonth().get(getMillis()); [EOL] }
public String toString(String pattern, Locale locale) throws IllegalArgumentException { [EOL]     if (pattern == null) { [EOL]         return toString(); [EOL]     } [EOL]     return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this); [EOL] }
public String toString(String pattern, Locale locale) throws IllegalArgumentException { [EOL]     if (pattern == null) { [EOL]         return toString(); [EOL]     } [EOL]     return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this); [EOL] }
public String toString(String pattern, Locale locale) throws IllegalArgumentException { [EOL]     if (pattern == null) { [EOL]         return toString(); [EOL]     } [EOL]     return DateTimeFormat.forPattern(pattern).withLocale(locale).print(this); [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     if (minuendInstant < subtrahendInstant) { [EOL]         return -getDifferenceAsLong(subtrahendInstant, minuendInstant); [EOL]     } [EOL]     long difference = (minuendInstant - subtrahendInstant) / iUnitMillis; [EOL]     if (add(subtrahendInstant, difference) < minuendInstant) { [EOL]         do { [EOL]             difference++; [EOL]         } while (add(subtrahendInstant, difference) <= minuendInstant); [EOL]         difference--; [EOL]     } else if (add(subtrahendInstant, difference) > minuendInstant) { [EOL]         do { [EOL]             difference--; [EOL]         } while (add(subtrahendInstant, difference) > minuendInstant); [EOL]     } [EOL]     return difference; [EOL] }
public PeriodType getPeriodType() { [EOL]     return PeriodType.weeks(); [EOL] }
public Seconds toStandardSeconds() { [EOL]     return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_WEEK)); [EOL] }
public Seconds toStandardSeconds() { [EOL]     return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_WEEK)); [EOL] }
public Seconds toStandardSeconds() { [EOL]     return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_WEEK)); [EOL] }
public Duration toStandardDuration() { [EOL]     long weeks = getValue(); [EOL]     return new Duration(weeks * DateTimeConstants.MILLIS_PER_WEEK); [EOL] }
public Duration toStandardDuration() { [EOL]     long weeks = getValue(); [EOL]     return new Duration(weeks * DateTimeConstants.MILLIS_PER_WEEK); [EOL] }
public Duration toStandardDuration() { [EOL]     long weeks = getValue(); [EOL]     return new Duration(weeks * DateTimeConstants.MILLIS_PER_WEEK); [EOL] }
public Weeks multipliedBy(int scalar) { [EOL]     return Weeks.weeks(FieldUtils.safeMultiply(getValue(), scalar)); [EOL] }
public Weeks multipliedBy(int scalar) { [EOL]     return Weeks.weeks(FieldUtils.safeMultiply(getValue(), scalar)); [EOL] }
public Weeks multipliedBy(int scalar) { [EOL]     return Weeks.weeks(FieldUtils.safeMultiply(getValue(), scalar)); [EOL] }
public Weeks multipliedBy(int scalar) { [EOL]     return Weeks.weeks(FieldUtils.safeMultiply(getValue(), scalar)); [EOL] }
@ToString [EOL] public String toString() { [EOL]     return "P" + String.valueOf(getValue()) + "W"; [EOL] }
@ToString [EOL] public String toString() { [EOL]     return "P" + String.valueOf(getValue()) + "W"; [EOL] }
@ToString [EOL] public String toString() { [EOL]     return "P" + String.valueOf(getValue()) + "W"; [EOL] }
public static DateTime parse(String str, DateTimeFormatter formatter) { [EOL]     return formatter.parseDateTime(str); [EOL] }
public static DateTime parse(String str, DateTimeFormatter formatter) { [EOL]     return formatter.parseDateTime(str); [EOL] }
public static DateTime parse(String str, DateTimeFormatter formatter) { [EOL]     return formatter.parseDateTime(str); [EOL] }
public DateTime(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] }
public DateTime(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] }
public DateTime(Object instant, DateTimeZone zone) { [EOL]     super(instant, zone); [EOL] }
public DateTime(Object instant, DateTimeZone zone) { [EOL]     super(instant, zone); [EOL] }
public DateTime(Object instant, DateTimeZone zone) { [EOL]     super(instant, zone); [EOL] }
public DateTime(Object instant, DateTimeZone zone) { [EOL]     super(instant, zone); [EOL] }
public DateTime(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute) { [EOL]     super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, 0); [EOL] }
public DateTime(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, DateTimeZone zone) { [EOL]     super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, 0, zone); [EOL] }
public DateTime(int year, int monthOfYear, int dayOfMonth, int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { [EOL]     super(year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); [EOL] }
public DateTime withMillis(long newMillis) { [EOL]     return (newMillis == getMillis() ? this : new DateTime(newMillis, getChronology())); [EOL] }
public DateTime withMillis(long newMillis) { [EOL]     return (newMillis == getMillis() ? this : new DateTime(newMillis, getChronology())); [EOL] }
public DateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { [EOL]     Chronology chrono = getChronology(); [EOL]     long instant = getMillis(); [EOL]     instant = chrono.hourOfDay().set(instant, hourOfDay); [EOL]     instant = chrono.minuteOfHour().set(instant, minuteOfHour); [EOL]     instant = chrono.secondOfMinute().set(instant, secondOfMinute); [EOL]     instant = chrono.millisOfSecond().set(instant, millisOfSecond); [EOL]     return withMillis(instant); [EOL] }
public DateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { [EOL]     Chronology chrono = getChronology(); [EOL]     long instant = getMillis(); [EOL]     instant = chrono.hourOfDay().set(instant, hourOfDay); [EOL]     instant = chrono.minuteOfHour().set(instant, minuteOfHour); [EOL]     instant = chrono.secondOfMinute().set(instant, secondOfMinute); [EOL]     instant = chrono.millisOfSecond().set(instant, millisOfSecond); [EOL]     return withMillis(instant); [EOL] }
public DateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { [EOL]     Chronology chrono = getChronology(); [EOL]     long instant = getMillis(); [EOL]     instant = chrono.hourOfDay().set(instant, hourOfDay); [EOL]     instant = chrono.minuteOfHour().set(instant, minuteOfHour); [EOL]     instant = chrono.secondOfMinute().set(instant, secondOfMinute); [EOL]     instant = chrono.millisOfSecond().set(instant, millisOfSecond); [EOL]     return withMillis(instant); [EOL] }
public DateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { [EOL]     Chronology chrono = getChronology(); [EOL]     long instant = getMillis(); [EOL]     instant = chrono.hourOfDay().set(instant, hourOfDay); [EOL]     instant = chrono.minuteOfHour().set(instant, minuteOfHour); [EOL]     instant = chrono.secondOfMinute().set(instant, secondOfMinute); [EOL]     instant = chrono.millisOfSecond().set(instant, millisOfSecond); [EOL]     return withMillis(instant); [EOL] }
public DateTime withTime(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond) { [EOL]     Chronology chrono = getChronology(); [EOL]     long instant = getMillis(); [EOL]     instant = chrono.hourOfDay().set(instant, hourOfDay); [EOL]     instant = chrono.minuteOfHour().set(instant, minuteOfHour); [EOL]     instant = chrono.secondOfMinute().set(instant, secondOfMinute); [EOL]     instant = chrono.millisOfSecond().set(instant, millisOfSecond); [EOL]     return withMillis(instant); [EOL] }
public DateTime withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getMillis(), amount); [EOL]     return withMillis(instant); [EOL] }
public DateTime withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getMillis(), amount); [EOL]     return withMillis(instant); [EOL] }
public DateTime withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getMillis(), amount); [EOL]     return withMillis(instant); [EOL] }
public DateTime withDurationAdded(long durationToAdd, int scalar) { [EOL]     if (durationToAdd == 0 || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().add(getMillis(), durationToAdd, scalar); [EOL]     return withMillis(instant); [EOL] }
public DateTime withDurationAdded(long durationToAdd, int scalar) { [EOL]     if (durationToAdd == 0 || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().add(getMillis(), durationToAdd, scalar); [EOL]     return withMillis(instant); [EOL] }
public DateTime withDurationAdded(long durationToAdd, int scalar) { [EOL]     if (durationToAdd == 0 || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().add(getMillis(), durationToAdd, scalar); [EOL]     return withMillis(instant); [EOL] }
public DateTime withDurationAdded(ReadableDuration durationToAdd, int scalar) { [EOL]     if (durationToAdd == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     return withDurationAdded(durationToAdd.getMillis(), scalar); [EOL] }
public DateTime withDurationAdded(ReadableDuration durationToAdd, int scalar) { [EOL]     if (durationToAdd == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     return withDurationAdded(durationToAdd.getMillis(), scalar); [EOL] }
public DateTime plusMonths(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().months().add(getMillis(), months); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusMonths(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().months().add(getMillis(), months); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusMonths(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().months().add(getMillis(), months); [EOL]     return withMillis(instant); [EOL] }
public DateTime plusSeconds(int seconds) { [EOL]     if (seconds == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().seconds().add(getMillis(), seconds); [EOL]     return withMillis(instant); [EOL] }
public DateTime minusMonths(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().months().subtract(getMillis(), months); [EOL]     return withMillis(instant); [EOL] }
public DateTime minusMonths(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().months().subtract(getMillis(), months); [EOL]     return withMillis(instant); [EOL] }
public DateTime minusMonths(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().months().subtract(getMillis(), months); [EOL]     return withMillis(instant); [EOL] }
public DateTime minusHours(int hours) { [EOL]     if (hours == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().hours().subtract(getMillis(), hours); [EOL]     return withMillis(instant); [EOL] }
public DateTime minusHours(int hours) { [EOL]     if (hours == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().hours().subtract(getMillis(), hours); [EOL]     return withMillis(instant); [EOL] }
public DateTime minusHours(int hours) { [EOL]     if (hours == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().hours().subtract(getMillis(), hours); [EOL]     return withMillis(instant); [EOL] }
public DateTime minusMinutes(int minutes) { [EOL]     if (minutes == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().minutes().subtract(getMillis(), minutes); [EOL]     return withMillis(instant); [EOL] }
public DateTime minusMinutes(int minutes) { [EOL]     if (minutes == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().minutes().subtract(getMillis(), minutes); [EOL]     return withMillis(instant); [EOL] }
public DateTime minusMinutes(int minutes) { [EOL]     if (minutes == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().minutes().subtract(getMillis(), minutes); [EOL]     return withMillis(instant); [EOL] }
public LocalDateTime toLocalDateTime() { [EOL]     return new LocalDateTime(getMillis(), getChronology()); [EOL] }
public LocalTime toLocalTime() { [EOL]     return new LocalTime(getMillis(), getChronology()); [EOL] }
public DateTime withWeekOfWeekyear(int weekOfWeekyear) { [EOL]     return withMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear)); [EOL] }
public DateTime withWeekOfWeekyear(int weekOfWeekyear) { [EOL]     return withMillis(getChronology().weekOfWeekyear().set(getMillis(), weekOfWeekyear)); [EOL] }
public DateTime withDayOfMonth(int dayOfMonth) { [EOL]     return withMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth)); [EOL] }
public DateTime withDayOfMonth(int dayOfMonth) { [EOL]     return withMillis(getChronology().dayOfMonth().set(getMillis(), dayOfMonth)); [EOL] }
public DateTime withDayOfWeek(int dayOfWeek) { [EOL]     return withMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek)); [EOL] }
public DateTime withDayOfWeek(int dayOfWeek) { [EOL]     return withMillis(getChronology().dayOfWeek().set(getMillis(), dayOfWeek)); [EOL] }
public DateTime withMinuteOfHour(int minute) { [EOL]     return withMillis(getChronology().minuteOfHour().set(getMillis(), minute)); [EOL] }
public DateTime withMinuteOfHour(int minute) { [EOL]     return withMillis(getChronology().minuteOfHour().set(getMillis(), minute)); [EOL] }
public DateTime withMinuteOfHour(int minute) { [EOL]     return withMillis(getChronology().minuteOfHour().set(getMillis(), minute)); [EOL] }
public Property yearOfEra() { [EOL]     return new Property(this, getChronology().yearOfEra()); [EOL] }
public Property year() { [EOL]     return new Property(this, getChronology().year()); [EOL] }
public Property hourOfDay() { [EOL]     return new Property(this, getChronology().hourOfDay()); [EOL] }
public Property minuteOfDay() { [EOL]     return new Property(this, getChronology().minuteOfDay()); [EOL] }
public Property minuteOfHour() { [EOL]     return new Property(this, getChronology().minuteOfHour()); [EOL] }
public Property secondOfMinute() { [EOL]     return new Property(this, getChronology().secondOfMinute()); [EOL] }
public Property millisOfSecond() { [EOL]     return new Property(this, getChronology().millisOfSecond()); [EOL] }
Property(DateTime instant, DateTimeField field) { [EOL]     super(); [EOL]     iInstant = instant; [EOL]     iField = field; [EOL] }
private void writeObject(ObjectOutputStream oos) throws IOException { [EOL]     oos.writeObject(iInstant); [EOL]     oos.writeObject(iField.getType()); [EOL] }
private void readObject(ObjectInputStream oos) throws IOException, ClassNotFoundException { [EOL]     iInstant = (DateTime) oos.readObject(); [EOL]     DateTimeFieldType type = (DateTimeFieldType) oos.readObject(); [EOL]     iField = type.getField(iInstant.getChronology()); [EOL] }
public DateTime addWrapFieldToCopy(int value) { [EOL]     return iInstant.withMillis(iField.addWrapField(iInstant.getMillis(), value)); [EOL] }
public DateTime setCopy(int value) { [EOL]     return iInstant.withMillis(iField.set(iInstant.getMillis(), value)); [EOL] }
public DateTime setCopy(int value) { [EOL]     return iInstant.withMillis(iField.set(iInstant.getMillis(), value)); [EOL] }
public DateTime setCopy(String text, Locale locale) { [EOL]     return iInstant.withMillis(iField.set(iInstant.getMillis(), text, locale)); [EOL] }
public DateTime setCopy(String text, Locale locale) { [EOL]     return iInstant.withMillis(iField.set(iInstant.getMillis(), text, locale)); [EOL] }
public DateTime setCopy(String text, Locale locale) { [EOL]     return iInstant.withMillis(iField.set(iInstant.getMillis(), text, locale)); [EOL] }
public DateTime setCopy(String text, Locale locale) { [EOL]     return iInstant.withMillis(iField.set(iInstant.getMillis(), text, locale)); [EOL] }
public DateTime setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] }
public DateTime setCopy(String text) { [EOL]     return setCopy(text, null); [EOL] }
public DateTime roundHalfFloorCopy() { [EOL]     return iInstant.withMillis(iField.roundHalfFloor(iInstant.getMillis())); [EOL] }
public DateTime roundHalfFloorCopy() { [EOL]     return iInstant.withMillis(iField.roundHalfFloor(iInstant.getMillis())); [EOL] }
public DateTime roundHalfCeilingCopy() { [EOL]     return iInstant.withMillis(iField.roundHalfCeiling(iInstant.getMillis())); [EOL] }
private PeriodFormatter(PeriodPrinter printer, PeriodParser parser, Locale locale, PeriodType type) { [EOL]     super(); [EOL]     iPrinter = printer; [EOL]     iParser = parser; [EOL]     iLocale = locale; [EOL]     iParseType = type; [EOL] }
private PeriodFormatter(PeriodPrinter printer, PeriodParser parser, Locale locale, PeriodType type) { [EOL]     super(); [EOL]     iPrinter = printer; [EOL]     iParser = parser; [EOL]     iLocale = locale; [EOL]     iParseType = type; [EOL] }
private PeriodFormatter(PeriodPrinter printer, PeriodParser parser, Locale locale, PeriodType type) { [EOL]     super(); [EOL]     iPrinter = printer; [EOL]     iParser = parser; [EOL]     iLocale = locale; [EOL]     iParseType = type; [EOL] }
private PeriodFormatter(PeriodPrinter printer, PeriodParser parser, Locale locale, PeriodType type) { [EOL]     super(); [EOL]     iPrinter = printer; [EOL]     iParser = parser; [EOL]     iLocale = locale; [EOL]     iParseType = type; [EOL] }
private PeriodFormatter(PeriodPrinter printer, PeriodParser parser, Locale locale, PeriodType type) { [EOL]     super(); [EOL]     iPrinter = printer; [EOL]     iParser = parser; [EOL]     iLocale = locale; [EOL]     iParseType = type; [EOL] }
public PeriodFormatter withLocale(Locale locale) { [EOL]     if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) { [EOL]         return this; [EOL]     } [EOL]     return new PeriodFormatter(iPrinter, iParser, locale, iParseType); [EOL] }
public PeriodFormatter withLocale(Locale locale) { [EOL]     if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) { [EOL]         return this; [EOL]     } [EOL]     return new PeriodFormatter(iPrinter, iParser, locale, iParseType); [EOL] }
public PeriodFormatter withLocale(Locale locale) { [EOL]     if (locale == getLocale() || (locale != null && locale.equals(getLocale()))) { [EOL]         return this; [EOL]     } [EOL]     return new PeriodFormatter(iPrinter, iParser, locale, iParseType); [EOL] }
public Locale getLocale() { [EOL]     return iLocale; [EOL] }
public Partial() { [EOL]     this((Chronology) null); [EOL] }
public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology).withUTC(); [EOL]     iChronology = chronology; [EOL]     if (types == null) { [EOL]         throw new IllegalArgumentException("Types array must not be null"); [EOL]     } [EOL]     if (values == null) { [EOL]         throw new IllegalArgumentException("Values array must not be null"); [EOL]     } [EOL]     if (values.length != types.length) { [EOL]         throw new IllegalArgumentException("Values array must be the same length as the types array"); [EOL]     } [EOL]     if (types.length == 0) { [EOL]         iTypes = types; [EOL]         iValues = values; [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null: index " + i); [EOL]         } [EOL]     } [EOL]     DurationField lastUnitField = null; [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         DateTimeFieldType loopType = types[i]; [EOL]         DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]         if (i > 0) { [EOL]             if (loopUnitField.isSupported() == false) { [EOL]                 if (lastUnitField.isSupported()) { [EOL]                     throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                 } else { [EOL]                     throw new IllegalArgumentException("Types array must not contain duplicate unsupported: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                 } [EOL]             } [EOL]             int compare = lastUnitField.compareTo(loopUnitField); [EOL]             if (compare < 0) { [EOL]                 throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]             } else if (compare == 0 && lastUnitField.equals(loopUnitField)) { [EOL]                 if (types[i - 1].getRangeDurationType() == null) { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } else { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); [EOL]                     DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                     if (lastRangeField.compareTo(loopRangeField) < 0) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     if (lastRangeField.compareTo(loopRangeField) == 0) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         lastUnitField = loopUnitField; [EOL]     } [EOL]     iTypes = (DateTimeFieldType[]) types.clone(); [EOL]     chronology.validate(this, values); [EOL]     iValues = (int[]) values.clone(); [EOL] }
public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology).withUTC(); [EOL]     iChronology = chronology; [EOL]     if (types == null) { [EOL]         throw new IllegalArgumentException("Types array must not be null"); [EOL]     } [EOL]     if (values == null) { [EOL]         throw new IllegalArgumentException("Values array must not be null"); [EOL]     } [EOL]     if (values.length != types.length) { [EOL]         throw new IllegalArgumentException("Values array must be the same length as the types array"); [EOL]     } [EOL]     if (types.length == 0) { [EOL]         iTypes = types; [EOL]         iValues = values; [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null: index " + i); [EOL]         } [EOL]     } [EOL]     DurationField lastUnitField = null; [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         DateTimeFieldType loopType = types[i]; [EOL]         DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]         if (i > 0) { [EOL]             if (loopUnitField.isSupported() == false) { [EOL]                 if (lastUnitField.isSupported()) { [EOL]                     throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                 } else { [EOL]                     throw new IllegalArgumentException("Types array must not contain duplicate unsupported: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                 } [EOL]             } [EOL]             int compare = lastUnitField.compareTo(loopUnitField); [EOL]             if (compare < 0) { [EOL]                 throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]             } else if (compare == 0 && lastUnitField.equals(loopUnitField)) { [EOL]                 if (types[i - 1].getRangeDurationType() == null) { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } else { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); [EOL]                     DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                     if (lastRangeField.compareTo(loopRangeField) < 0) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     if (lastRangeField.compareTo(loopRangeField) == 0) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         lastUnitField = loopUnitField; [EOL]     } [EOL]     iTypes = (DateTimeFieldType[]) types.clone(); [EOL]     chronology.validate(this, values); [EOL]     iValues = (int[]) values.clone(); [EOL] }
public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology).withUTC(); [EOL]     iChronology = chronology; [EOL]     if (types == null) { [EOL]         throw new IllegalArgumentException("Types array must not be null"); [EOL]     } [EOL]     if (values == null) { [EOL]         throw new IllegalArgumentException("Values array must not be null"); [EOL]     } [EOL]     if (values.length != types.length) { [EOL]         throw new IllegalArgumentException("Values array must be the same length as the types array"); [EOL]     } [EOL]     if (types.length == 0) { [EOL]         iTypes = types; [EOL]         iValues = values; [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null: index " + i); [EOL]         } [EOL]     } [EOL]     DurationField lastUnitField = null; [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         DateTimeFieldType loopType = types[i]; [EOL]         DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]         if (i > 0) { [EOL]             if (loopUnitField.isSupported() == false) { [EOL]                 if (lastUnitField.isSupported()) { [EOL]                     throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                 } else { [EOL]                     throw new IllegalArgumentException("Types array must not contain duplicate unsupported: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                 } [EOL]             } [EOL]             int compare = lastUnitField.compareTo(loopUnitField); [EOL]             if (compare < 0) { [EOL]                 throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]             } else if (compare == 0 && lastUnitField.equals(loopUnitField)) { [EOL]                 if (types[i - 1].getRangeDurationType() == null) { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } else { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); [EOL]                     DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                     if (lastRangeField.compareTo(loopRangeField) < 0) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     if (lastRangeField.compareTo(loopRangeField) == 0) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         lastUnitField = loopUnitField; [EOL]     } [EOL]     iTypes = (DateTimeFieldType[]) types.clone(); [EOL]     chronology.validate(this, values); [EOL]     iValues = (int[]) values.clone(); [EOL] }
public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology).withUTC(); [EOL]     iChronology = chronology; [EOL]     if (types == null) { [EOL]         throw new IllegalArgumentException("Types array must not be null"); [EOL]     } [EOL]     if (values == null) { [EOL]         throw new IllegalArgumentException("Values array must not be null"); [EOL]     } [EOL]     if (values.length != types.length) { [EOL]         throw new IllegalArgumentException("Values array must be the same length as the types array"); [EOL]     } [EOL]     if (types.length == 0) { [EOL]         iTypes = types; [EOL]         iValues = values; [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null: index " + i); [EOL]         } [EOL]     } [EOL]     DurationField lastUnitField = null; [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         DateTimeFieldType loopType = types[i]; [EOL]         DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]         if (i > 0) { [EOL]             if (loopUnitField.isSupported() == false) { [EOL]                 if (lastUnitField.isSupported()) { [EOL]                     throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                 } else { [EOL]                     throw new IllegalArgumentException("Types array must not contain duplicate unsupported: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                 } [EOL]             } [EOL]             int compare = lastUnitField.compareTo(loopUnitField); [EOL]             if (compare < 0) { [EOL]                 throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]             } else if (compare == 0 && lastUnitField.equals(loopUnitField)) { [EOL]                 if (types[i - 1].getRangeDurationType() == null) { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } else { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); [EOL]                     DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                     if (lastRangeField.compareTo(loopRangeField) < 0) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     if (lastRangeField.compareTo(loopRangeField) == 0) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         lastUnitField = loopUnitField; [EOL]     } [EOL]     iTypes = (DateTimeFieldType[]) types.clone(); [EOL]     chronology.validate(this, values); [EOL]     iValues = (int[]) values.clone(); [EOL] }
public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology).withUTC(); [EOL]     iChronology = chronology; [EOL]     if (types == null) { [EOL]         throw new IllegalArgumentException("Types array must not be null"); [EOL]     } [EOL]     if (values == null) { [EOL]         throw new IllegalArgumentException("Values array must not be null"); [EOL]     } [EOL]     if (values.length != types.length) { [EOL]         throw new IllegalArgumentException("Values array must be the same length as the types array"); [EOL]     } [EOL]     if (types.length == 0) { [EOL]         iTypes = types; [EOL]         iValues = values; [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null: index " + i); [EOL]         } [EOL]     } [EOL]     DurationField lastUnitField = null; [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         DateTimeFieldType loopType = types[i]; [EOL]         DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]         if (i > 0) { [EOL]             if (loopUnitField.isSupported() == false) { [EOL]                 if (lastUnitField.isSupported()) { [EOL]                     throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                 } else { [EOL]                     throw new IllegalArgumentException("Types array must not contain duplicate unsupported: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                 } [EOL]             } [EOL]             int compare = lastUnitField.compareTo(loopUnitField); [EOL]             if (compare < 0) { [EOL]                 throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]             } else if (compare == 0 && lastUnitField.equals(loopUnitField)) { [EOL]                 if (types[i - 1].getRangeDurationType() == null) { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } else { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); [EOL]                     DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                     if (lastRangeField.compareTo(loopRangeField) < 0) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     if (lastRangeField.compareTo(loopRangeField) == 0) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         lastUnitField = loopUnitField; [EOL]     } [EOL]     iTypes = (DateTimeFieldType[]) types.clone(); [EOL]     chronology.validate(this, values); [EOL]     iValues = (int[]) values.clone(); [EOL] }
public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology).withUTC(); [EOL]     iChronology = chronology; [EOL]     if (types == null) { [EOL]         throw new IllegalArgumentException("Types array must not be null"); [EOL]     } [EOL]     if (values == null) { [EOL]         throw new IllegalArgumentException("Values array must not be null"); [EOL]     } [EOL]     if (values.length != types.length) { [EOL]         throw new IllegalArgumentException("Values array must be the same length as the types array"); [EOL]     } [EOL]     if (types.length == 0) { [EOL]         iTypes = types; [EOL]         iValues = values; [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null: index " + i); [EOL]         } [EOL]     } [EOL]     DurationField lastUnitField = null; [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         DateTimeFieldType loopType = types[i]; [EOL]         DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]         if (i > 0) { [EOL]             if (loopUnitField.isSupported() == false) { [EOL]                 if (lastUnitField.isSupported()) { [EOL]                     throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                 } else { [EOL]                     throw new IllegalArgumentException("Types array must not contain duplicate unsupported: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                 } [EOL]             } [EOL]             int compare = lastUnitField.compareTo(loopUnitField); [EOL]             if (compare < 0) { [EOL]                 throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]             } else if (compare == 0 && lastUnitField.equals(loopUnitField)) { [EOL]                 if (types[i - 1].getRangeDurationType() == null) { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } else { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); [EOL]                     DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                     if (lastRangeField.compareTo(loopRangeField) < 0) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     if (lastRangeField.compareTo(loopRangeField) == 0) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         lastUnitField = loopUnitField; [EOL]     } [EOL]     iTypes = (DateTimeFieldType[]) types.clone(); [EOL]     chronology.validate(this, values); [EOL]     iValues = (int[]) values.clone(); [EOL] }
public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology).withUTC(); [EOL]     iChronology = chronology; [EOL]     if (types == null) { [EOL]         throw new IllegalArgumentException("Types array must not be null"); [EOL]     } [EOL]     if (values == null) { [EOL]         throw new IllegalArgumentException("Values array must not be null"); [EOL]     } [EOL]     if (values.length != types.length) { [EOL]         throw new IllegalArgumentException("Values array must be the same length as the types array"); [EOL]     } [EOL]     if (types.length == 0) { [EOL]         iTypes = types; [EOL]         iValues = values; [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null: index " + i); [EOL]         } [EOL]     } [EOL]     DurationField lastUnitField = null; [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         DateTimeFieldType loopType = types[i]; [EOL]         DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]         if (i > 0) { [EOL]             if (loopUnitField.isSupported() == false) { [EOL]                 if (lastUnitField.isSupported()) { [EOL]                     throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                 } else { [EOL]                     throw new IllegalArgumentException("Types array must not contain duplicate unsupported: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                 } [EOL]             } [EOL]             int compare = lastUnitField.compareTo(loopUnitField); [EOL]             if (compare < 0) { [EOL]                 throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]             } else if (compare == 0 && lastUnitField.equals(loopUnitField)) { [EOL]                 if (types[i - 1].getRangeDurationType() == null) { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } else { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); [EOL]                     DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                     if (lastRangeField.compareTo(loopRangeField) < 0) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     if (lastRangeField.compareTo(loopRangeField) == 0) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         lastUnitField = loopUnitField; [EOL]     } [EOL]     iTypes = (DateTimeFieldType[]) types.clone(); [EOL]     chronology.validate(this, values); [EOL]     iValues = (int[]) values.clone(); [EOL] }
public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology).withUTC(); [EOL]     iChronology = chronology; [EOL]     if (types == null) { [EOL]         throw new IllegalArgumentException("Types array must not be null"); [EOL]     } [EOL]     if (values == null) { [EOL]         throw new IllegalArgumentException("Values array must not be null"); [EOL]     } [EOL]     if (values.length != types.length) { [EOL]         throw new IllegalArgumentException("Values array must be the same length as the types array"); [EOL]     } [EOL]     if (types.length == 0) { [EOL]         iTypes = types; [EOL]         iValues = values; [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         if (types[i] == null) { [EOL]             throw new IllegalArgumentException("Types array must not contain null: index " + i); [EOL]         } [EOL]     } [EOL]     DurationField lastUnitField = null; [EOL]     for (int i = 0; i < types.length; i++) { [EOL]         DateTimeFieldType loopType = types[i]; [EOL]         DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]         if (i > 0) { [EOL]             if (loopUnitField.isSupported() == false) { [EOL]                 if (lastUnitField.isSupported()) { [EOL]                     throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                 } else { [EOL]                     throw new IllegalArgumentException("Types array must not contain duplicate unsupported: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                 } [EOL]             } [EOL]             int compare = lastUnitField.compareTo(loopUnitField); [EOL]             if (compare < 0) { [EOL]                 throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]             } else if (compare == 0 && lastUnitField.equals(loopUnitField)) { [EOL]                 if (types[i - 1].getRangeDurationType() == null) { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } else { [EOL]                     if (loopType.getRangeDurationType() == null) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology); [EOL]                     DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                     if (lastRangeField.compareTo(loopRangeField) < 0) { [EOL]                         throw new IllegalArgumentException("Types array must be in order largest-smallest: " + types[i - 1].getName() + " < " + loopType.getName()); [EOL]                     } [EOL]                     if (lastRangeField.compareTo(loopRangeField) == 0) { [EOL]                         throw new IllegalArgumentException("Types array must not contain duplicate: " + types[i - 1].getName() + " and " + loopType.getName()); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         lastUnitField = loopUnitField; [EOL]     } [EOL]     iTypes = (DateTimeFieldType[]) types.clone(); [EOL]     chronology.validate(this, values); [EOL]     iValues = (int[]) values.clone(); [EOL] }
public Partial withChronologyRetainFields(Chronology newChronology) { [EOL]     newChronology = DateTimeUtils.getChronology(newChronology); [EOL]     newChronology = newChronology.withUTC(); [EOL]     if (newChronology == getChronology()) { [EOL]         return this; [EOL]     } else { [EOL]         Partial newPartial = new Partial(newChronology, iTypes, iValues); [EOL]         newChronology.validate(newPartial, iValues); [EOL]         return newPartial; [EOL]     } [EOL] }
public Partial withChronologyRetainFields(Chronology newChronology) { [EOL]     newChronology = DateTimeUtils.getChronology(newChronology); [EOL]     newChronology = newChronology.withUTC(); [EOL]     if (newChronology == getChronology()) { [EOL]         return this; [EOL]     } else { [EOL]         Partial newPartial = new Partial(newChronology, iTypes, iValues); [EOL]         newChronology.validate(newPartial, iValues); [EOL]         return newPartial; [EOL]     } [EOL] }
public Partial with(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The field type must not be null"); [EOL]     } [EOL]     int index = indexOf(fieldType); [EOL]     if (index == -1) { [EOL]         DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; [EOL]         int[] newValues = new int[newTypes.length]; [EOL]         int i = 0; [EOL]         DurationField unitField = fieldType.getDurationType().getField(iChronology); [EOL]         if (unitField.isSupported()) { [EOL]             for (; i < iTypes.length; i++) { [EOL]                 DateTimeFieldType loopType = iTypes[i]; [EOL]                 DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]                 if (loopUnitField.isSupported()) { [EOL]                     int compare = unitField.compareTo(loopUnitField); [EOL]                     if (compare > 0) { [EOL]                         break; [EOL]                     } else if (compare == 0) { [EOL]                         if (fieldType.getRangeDurationType() == null) { [EOL]                             break; [EOL]                         } [EOL]                         DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); [EOL]                         DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                         if (rangeField.compareTo(loopRangeField) > 0) { [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         System.arraycopy(iTypes, 0, newTypes, 0, i); [EOL]         System.arraycopy(iValues, 0, newValues, 0, i); [EOL]         newTypes[i] = fieldType; [EOL]         newValues[i] = value; [EOL]         System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); [EOL]         System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); [EOL]         Partial newPartial = new Partial(newTypes, newValues, iChronology); [EOL]         iChronology.validate(newPartial, newValues); [EOL]         return newPartial; [EOL]     } [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial with(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The field type must not be null"); [EOL]     } [EOL]     int index = indexOf(fieldType); [EOL]     if (index == -1) { [EOL]         DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; [EOL]         int[] newValues = new int[newTypes.length]; [EOL]         int i = 0; [EOL]         DurationField unitField = fieldType.getDurationType().getField(iChronology); [EOL]         if (unitField.isSupported()) { [EOL]             for (; i < iTypes.length; i++) { [EOL]                 DateTimeFieldType loopType = iTypes[i]; [EOL]                 DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]                 if (loopUnitField.isSupported()) { [EOL]                     int compare = unitField.compareTo(loopUnitField); [EOL]                     if (compare > 0) { [EOL]                         break; [EOL]                     } else if (compare == 0) { [EOL]                         if (fieldType.getRangeDurationType() == null) { [EOL]                             break; [EOL]                         } [EOL]                         DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); [EOL]                         DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                         if (rangeField.compareTo(loopRangeField) > 0) { [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         System.arraycopy(iTypes, 0, newTypes, 0, i); [EOL]         System.arraycopy(iValues, 0, newValues, 0, i); [EOL]         newTypes[i] = fieldType; [EOL]         newValues[i] = value; [EOL]         System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); [EOL]         System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); [EOL]         Partial newPartial = new Partial(newTypes, newValues, iChronology); [EOL]         iChronology.validate(newPartial, newValues); [EOL]         return newPartial; [EOL]     } [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial with(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The field type must not be null"); [EOL]     } [EOL]     int index = indexOf(fieldType); [EOL]     if (index == -1) { [EOL]         DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; [EOL]         int[] newValues = new int[newTypes.length]; [EOL]         int i = 0; [EOL]         DurationField unitField = fieldType.getDurationType().getField(iChronology); [EOL]         if (unitField.isSupported()) { [EOL]             for (; i < iTypes.length; i++) { [EOL]                 DateTimeFieldType loopType = iTypes[i]; [EOL]                 DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]                 if (loopUnitField.isSupported()) { [EOL]                     int compare = unitField.compareTo(loopUnitField); [EOL]                     if (compare > 0) { [EOL]                         break; [EOL]                     } else if (compare == 0) { [EOL]                         if (fieldType.getRangeDurationType() == null) { [EOL]                             break; [EOL]                         } [EOL]                         DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); [EOL]                         DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                         if (rangeField.compareTo(loopRangeField) > 0) { [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         System.arraycopy(iTypes, 0, newTypes, 0, i); [EOL]         System.arraycopy(iValues, 0, newValues, 0, i); [EOL]         newTypes[i] = fieldType; [EOL]         newValues[i] = value; [EOL]         System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); [EOL]         System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); [EOL]         Partial newPartial = new Partial(newTypes, newValues, iChronology); [EOL]         iChronology.validate(newPartial, newValues); [EOL]         return newPartial; [EOL]     } [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial with(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The field type must not be null"); [EOL]     } [EOL]     int index = indexOf(fieldType); [EOL]     if (index == -1) { [EOL]         DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; [EOL]         int[] newValues = new int[newTypes.length]; [EOL]         int i = 0; [EOL]         DurationField unitField = fieldType.getDurationType().getField(iChronology); [EOL]         if (unitField.isSupported()) { [EOL]             for (; i < iTypes.length; i++) { [EOL]                 DateTimeFieldType loopType = iTypes[i]; [EOL]                 DurationField loopUnitField = loopType.getDurationType().getField(iChronology); [EOL]                 if (loopUnitField.isSupported()) { [EOL]                     int compare = unitField.compareTo(loopUnitField); [EOL]                     if (compare > 0) { [EOL]                         break; [EOL]                     } else if (compare == 0) { [EOL]                         if (fieldType.getRangeDurationType() == null) { [EOL]                             break; [EOL]                         } [EOL]                         DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); [EOL]                         DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); [EOL]                         if (rangeField.compareTo(loopRangeField) > 0) { [EOL]                             break; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]         System.arraycopy(iTypes, 0, newTypes, 0, i); [EOL]         System.arraycopy(iValues, 0, newValues, 0, i); [EOL]         newTypes[i] = fieldType; [EOL]         newValues[i] = value; [EOL]         System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); [EOL]         System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); [EOL]         Partial newPartial = new Partial(newTypes, newValues, iChronology); [EOL]         iChronology.validate(newPartial, newValues); [EOL]         return newPartial; [EOL]     } [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).add(this, index, newValues, amount); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).add(this, index, newValues, amount); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).add(this, index, newValues, amount); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).addWrapPartial(this, index, newValues, amount); [EOL]     return new Partial(this, newValues); [EOL] }
public Partial withFieldAddWrapped(DurationFieldType fieldType, int amount) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).addWrapPartial(this, index, newValues, amount); [EOL]     return new Partial(this, newValues); [EOL] }
public boolean isMatch(ReadableInstant instant) { [EOL]     long millis = DateTimeUtils.getInstantMillis(instant); [EOL]     Chronology chrono = DateTimeUtils.getInstantChronology(instant); [EOL]     for (int i = 0; i < iTypes.length; i++) { [EOL]         int value = iTypes[i].getField(chrono).get(millis); [EOL]         if (value != iValues[i]) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean isMatch(ReadableInstant instant) { [EOL]     long millis = DateTimeUtils.getInstantMillis(instant); [EOL]     Chronology chrono = DateTimeUtils.getInstantChronology(instant); [EOL]     for (int i = 0; i < iTypes.length; i++) { [EOL]         int value = iTypes[i].getField(chrono).get(millis); [EOL]         if (value != iValues[i]) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public DateTimeFormatter getFormatter() { [EOL]     DateTimeFormatter[] f = iFormatter; [EOL]     if (f == null) { [EOL]         if (size() == 0) { [EOL]             return null; [EOL]         } [EOL]         f = new DateTimeFormatter[2]; [EOL]         try { [EOL]             List<DateTimeFieldType> list = new ArrayList<DateTimeFieldType>(Arrays.asList(iTypes)); [EOL]             f[0] = ISODateTimeFormat.forFields(list, true, false); [EOL]             if (list.size() == 0) { [EOL]                 f[1] = f[0]; [EOL]             } [EOL]         } catch (IllegalArgumentException ex) { [EOL]         } [EOL]         iFormatter = f; [EOL]     } [EOL]     return f[0]; [EOL] }
public DateTimeFormatter getFormatter() { [EOL]     DateTimeFormatter[] f = iFormatter; [EOL]     if (f == null) { [EOL]         if (size() == 0) { [EOL]             return null; [EOL]         } [EOL]         f = new DateTimeFormatter[2]; [EOL]         try { [EOL]             List<DateTimeFieldType> list = new ArrayList<DateTimeFieldType>(Arrays.asList(iTypes)); [EOL]             f[0] = ISODateTimeFormat.forFields(list, true, false); [EOL]             if (list.size() == 0) { [EOL]                 f[1] = f[0]; [EOL]             } [EOL]         } catch (IllegalArgumentException ex) { [EOL]         } [EOL]         iFormatter = f; [EOL]     } [EOL]     return f[0]; [EOL] }
public DateTimeFormatter getFormatter() { [EOL]     DateTimeFormatter[] f = iFormatter; [EOL]     if (f == null) { [EOL]         if (size() == 0) { [EOL]             return null; [EOL]         } [EOL]         f = new DateTimeFormatter[2]; [EOL]         try { [EOL]             List<DateTimeFieldType> list = new ArrayList<DateTimeFieldType>(Arrays.asList(iTypes)); [EOL]             f[0] = ISODateTimeFormat.forFields(list, true, false); [EOL]             if (list.size() == 0) { [EOL]                 f[1] = f[0]; [EOL]             } [EOL]         } catch (IllegalArgumentException ex) { [EOL]         } [EOL]         iFormatter = f; [EOL]     } [EOL]     return f[0]; [EOL] }
public String toString() { [EOL]     DateTimeFormatter[] f = iFormatter; [EOL]     if (f == null) { [EOL]         getFormatter(); [EOL]         f = iFormatter; [EOL]         if (f == null) { [EOL]             return toStringList(); [EOL]         } [EOL]     } [EOL]     DateTimeFormatter f1 = f[1]; [EOL]     if (f1 == null) { [EOL]         return toStringList(); [EOL]     } [EOL]     return f1.print(this); [EOL] }
public String toString() { [EOL]     DateTimeFormatter[] f = iFormatter; [EOL]     if (f == null) { [EOL]         getFormatter(); [EOL]         f = iFormatter; [EOL]         if (f == null) { [EOL]             return toStringList(); [EOL]         } [EOL]     } [EOL]     DateTimeFormatter f1 = f[1]; [EOL]     if (f1 == null) { [EOL]         return toStringList(); [EOL]     } [EOL]     return f1.print(this); [EOL] }
public String toString() { [EOL]     DateTimeFormatter[] f = iFormatter; [EOL]     if (f == null) { [EOL]         getFormatter(); [EOL]         f = iFormatter; [EOL]         if (f == null) { [EOL]             return toStringList(); [EOL]         } [EOL]     } [EOL]     DateTimeFormatter f1 = f[1]; [EOL]     if (f1 == null) { [EOL]         return toStringList(); [EOL]     } [EOL]     return f1.print(this); [EOL] }
protected BaseDuration(long duration) { [EOL]     super(); [EOL]     iMillis = duration; [EOL] }
protected BaseDuration(long duration) { [EOL]     super(); [EOL]     iMillis = duration; [EOL] }
protected BaseDuration(long duration) { [EOL]     super(); [EOL]     iMillis = duration; [EOL] }
protected BaseDuration(ReadableInstant start, ReadableInstant end) { [EOL]     super(); [EOL]     if (start == end) { [EOL]         iMillis = 0L; [EOL]     } else { [EOL]         long startMillis = DateTimeUtils.getInstantMillis(start); [EOL]         long endMillis = DateTimeUtils.getInstantMillis(end); [EOL]         iMillis = FieldUtils.safeAdd(endMillis, -startMillis); [EOL]     } [EOL] }
protected BaseDuration(ReadableInstant start, ReadableInstant end) { [EOL]     super(); [EOL]     if (start == end) { [EOL]         iMillis = 0L; [EOL]     } else { [EOL]         long startMillis = DateTimeUtils.getInstantMillis(start); [EOL]         long endMillis = DateTimeUtils.getInstantMillis(end); [EOL]         iMillis = FieldUtils.safeAdd(endMillis, -startMillis); [EOL]     } [EOL] }
protected BaseDuration(Object duration) { [EOL]     super(); [EOL]     DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration); [EOL]     iMillis = converter.getDurationMillis(duration); [EOL] }
protected BaseDuration(Object duration) { [EOL]     super(); [EOL]     DurationConverter converter = ConverterManager.getInstance().getDurationConverter(duration); [EOL]     iMillis = converter.getDurationMillis(duration); [EOL] }
public long getMillis() { [EOL]     return iMillis; [EOL] }
public Period toPeriodTo(ReadableInstant endInstant) { [EOL]     return new Period(this, endInstant); [EOL] }
public Period toPeriodTo(ReadableInstant endInstant) { [EOL]     return new Period(this, endInstant); [EOL] }
public Interval toIntervalTo(ReadableInstant endInstant) { [EOL]     return new Interval(this, endInstant); [EOL] }
public Interval toIntervalTo(ReadableInstant endInstant) { [EOL]     return new Interval(this, endInstant); [EOL] }
public static Years years(int years) { [EOL]     switch(years) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Years(years); [EOL]     } [EOL] }
public static Years years(int years) { [EOL]     switch(years) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Years(years); [EOL]     } [EOL] }
public static Years years(int years) { [EOL]     switch(years) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Years(years); [EOL]     } [EOL] }
public static Years years(int years) { [EOL]     switch(years) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Years(years); [EOL]     } [EOL] }
public static Years years(int years) { [EOL]     switch(years) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Years(years); [EOL]     } [EOL] }
public static Years years(int years) { [EOL]     switch(years) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Years(years); [EOL]     } [EOL] }
public static Years years(int years) { [EOL]     switch(years) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Years(years); [EOL]     } [EOL] }
@FromString [EOL] public static Years parseYears(String periodStr) { [EOL]     if (periodStr == null) { [EOL]         return Years.ZERO; [EOL]     } [EOL]     Period p = PARSER.parsePeriod(periodStr); [EOL]     return Years.years(p.getYears()); [EOL] }
@FromString [EOL] public static Years parseYears(String periodStr) { [EOL]     if (periodStr == null) { [EOL]         return Years.ZERO; [EOL]     } [EOL]     Period p = PARSER.parsePeriod(periodStr); [EOL]     return Years.years(p.getYears()); [EOL] }
@FromString [EOL] public static Years parseYears(String periodStr) { [EOL]     if (periodStr == null) { [EOL]         return Years.ZERO; [EOL]     } [EOL]     Period p = PARSER.parsePeriod(periodStr); [EOL]     return Years.years(p.getYears()); [EOL] }
public Years multipliedBy(int scalar) { [EOL]     return Years.years(FieldUtils.safeMultiply(getValue(), scalar)); [EOL] }
public Years multipliedBy(int scalar) { [EOL]     return Years.years(FieldUtils.safeMultiply(getValue(), scalar)); [EOL] }
public Years multipliedBy(int scalar) { [EOL]     return Years.years(FieldUtils.safeMultiply(getValue(), scalar)); [EOL] }
public Years multipliedBy(int scalar) { [EOL]     return Years.years(FieldUtils.safeMultiply(getValue(), scalar)); [EOL] }
public Instant withDurationAdded(long durationToAdd, int scalar) { [EOL]     if (durationToAdd == 0 || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().add(getMillis(), durationToAdd, scalar); [EOL]     return withMillis(instant); [EOL] }
public Instant withDurationAdded(long durationToAdd, int scalar) { [EOL]     if (durationToAdd == 0 || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().add(getMillis(), durationToAdd, scalar); [EOL]     return withMillis(instant); [EOL] }
public Instant withDurationAdded(long durationToAdd, int scalar) { [EOL]     if (durationToAdd == 0 || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().add(getMillis(), durationToAdd, scalar); [EOL]     return withMillis(instant); [EOL] }
public Instant plus(ReadableDuration duration) { [EOL]     return withDurationAdded(duration, 1); [EOL] }
public Instant plus(ReadableDuration duration) { [EOL]     return withDurationAdded(duration, 1); [EOL] }
public Instant plus(ReadableDuration duration) { [EOL]     return withDurationAdded(duration, 1); [EOL] }
public Instant plus(ReadableDuration duration) { [EOL]     return withDurationAdded(duration, 1); [EOL] }
public MutableDateTime toMutableDateTime() { [EOL]     return new MutableDateTime(getMillis(), ISOChronology.getInstance()); [EOL] }
@Deprecated [EOL] public MutableDateTime toMutableDateTimeISO() { [EOL]     return toMutableDateTime(); [EOL] }
@SuppressWarnings("deprecation") [EOL] public static LocalDate fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date.getTime() < 0) { [EOL]         GregorianCalendar cal = new GregorianCalendar(); [EOL]         cal.setTime(date); [EOL]         return fromCalendarFields(cal); [EOL]     } [EOL]     return new LocalDate(date.getYear() + 1900, date.getMonth() + 1, date.getDate()); [EOL] }
@SuppressWarnings("deprecation") [EOL] public static LocalDate fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date.getTime() < 0) { [EOL]         GregorianCalendar cal = new GregorianCalendar(); [EOL]         cal.setTime(date); [EOL]         return fromCalendarFields(cal); [EOL]     } [EOL]     return new LocalDate(date.getYear() + 1900, date.getMonth() + 1, date.getDate()); [EOL] }
@SuppressWarnings("deprecation") [EOL] public static LocalDate fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date.getTime() < 0) { [EOL]         GregorianCalendar cal = new GregorianCalendar(); [EOL]         cal.setTime(date); [EOL]         return fromCalendarFields(cal); [EOL]     } [EOL]     return new LocalDate(date.getYear() + 1900, date.getMonth() + 1, date.getDate()); [EOL] }
public LocalDate(long instant, Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant); [EOL]     chronology = chronology.withUTC(); [EOL]     iLocalMillis = chronology.dayOfMonth().roundFloor(localMillis); [EOL]     iChronology = chronology; [EOL] }
public LocalDate(long instant, Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant); [EOL]     chronology = chronology.withUTC(); [EOL]     iLocalMillis = chronology.dayOfMonth().roundFloor(localMillis); [EOL]     iChronology = chronology; [EOL] }
public LocalDate(long instant, Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant); [EOL]     chronology = chronology.withUTC(); [EOL]     iLocalMillis = chronology.dayOfMonth().roundFloor(localMillis); [EOL]     iChronology = chronology; [EOL] }
public LocalDate(int year, int monthOfYear, int dayOfMonth, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology).withUTC(); [EOL]     long instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0); [EOL]     iChronology = chronology; [EOL]     iLocalMillis = instant; [EOL] }
public LocalDate(int year, int monthOfYear, int dayOfMonth, Chronology chronology) { [EOL]     super(); [EOL]     chronology = DateTimeUtils.getChronology(chronology).withUTC(); [EOL]     long instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0); [EOL]     iChronology = chronology; [EOL]     iLocalMillis = instant; [EOL] }
protected long getLocalMillis() { [EOL]     return iLocalMillis; [EOL] }
public Chronology getChronology() { [EOL]     return iChronology; [EOL] }
public int compareTo(ReadablePartial partial) { [EOL]     if (this == partial) { [EOL]         return 0; [EOL]     } [EOL]     if (partial instanceof LocalDate) { [EOL]         LocalDate other = (LocalDate) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1)); [EOL]         } [EOL]     } [EOL]     return super.compareTo(partial); [EOL] }
public int compareTo(ReadablePartial partial) { [EOL]     if (this == partial) { [EOL]         return 0; [EOL]     } [EOL]     if (partial instanceof LocalDate) { [EOL]         LocalDate other = (LocalDate) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return (iLocalMillis < other.iLocalMillis ? -1 : (iLocalMillis == other.iLocalMillis ? 0 : 1)); [EOL]         } [EOL]     } [EOL]     return super.compareTo(partial); [EOL] }
public DateTime toDateTimeAtStartOfDay() { [EOL]     return toDateTimeAtStartOfDay(null); [EOL] }
public DateTime toDateTimeAtStartOfDay(DateTimeZone zone) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     Chronology chrono = getChronology().withZone(zone); [EOL]     long localMillis = getLocalMillis() + 6L * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     long instant = zone.convertLocalToUTC(localMillis, false); [EOL]     instant = chrono.dayOfMonth().roundFloor(instant); [EOL]     return new DateTime(instant, chrono); [EOL] }
public DateTime toDateTimeAtStartOfDay(DateTimeZone zone) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     Chronology chrono = getChronology().withZone(zone); [EOL]     long localMillis = getLocalMillis() + 6L * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     long instant = zone.convertLocalToUTC(localMillis, false); [EOL]     instant = chrono.dayOfMonth().roundFloor(instant); [EOL]     return new DateTime(instant, chrono); [EOL] }
public DateTime toDateTimeAtStartOfDay(DateTimeZone zone) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     Chronology chrono = getChronology().withZone(zone); [EOL]     long localMillis = getLocalMillis() + 6L * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     long instant = zone.convertLocalToUTC(localMillis, false); [EOL]     instant = chrono.dayOfMonth().roundFloor(instant); [EOL]     return new DateTime(instant, chrono); [EOL] }
public DateTime toDateTimeAtCurrentTime() { [EOL]     return toDateTimeAtCurrentTime(null); [EOL] }
public DateTime toDateTimeAtCurrentTime(DateTimeZone zone) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     Chronology chrono = getChronology().withZone(zone); [EOL]     long instantMillis = DateTimeUtils.currentTimeMillis(); [EOL]     long resolved = chrono.set(this, instantMillis); [EOL]     return new DateTime(resolved, chrono); [EOL] }
public DateTime toDateTimeAtCurrentTime(DateTimeZone zone) { [EOL]     zone = DateTimeUtils.getZone(zone); [EOL]     Chronology chrono = getChronology().withZone(zone); [EOL]     long instantMillis = DateTimeUtils.currentTimeMillis(); [EOL]     long resolved = chrono.set(this, instantMillis); [EOL]     return new DateTime(resolved, chrono); [EOL] }
@Deprecated [EOL] public DateMidnight toDateMidnight() { [EOL]     return toDateMidnight(null); [EOL] }
public LocalDateTime toLocalDateTime(LocalTime time) { [EOL]     if (time == null) { [EOL]         throw new IllegalArgumentException("The time must not be null"); [EOL]     } [EOL]     if (getChronology() != time.getChronology()) { [EOL]         throw new IllegalArgumentException("The chronology of the time does not match"); [EOL]     } [EOL]     long localMillis = getLocalMillis() + time.getLocalMillis(); [EOL]     return new LocalDateTime(localMillis, getChronology()); [EOL] }
public LocalDateTime toLocalDateTime(LocalTime time) { [EOL]     if (time == null) { [EOL]         throw new IllegalArgumentException("The time must not be null"); [EOL]     } [EOL]     if (getChronology() != time.getChronology()) { [EOL]         throw new IllegalArgumentException("The chronology of the time does not match"); [EOL]     } [EOL]     long localMillis = getLocalMillis() + time.getLocalMillis(); [EOL]     return new LocalDateTime(localMillis, getChronology()); [EOL] }
public LocalDateTime toLocalDateTime(LocalTime time) { [EOL]     if (time == null) { [EOL]         throw new IllegalArgumentException("The time must not be null"); [EOL]     } [EOL]     if (getChronology() != time.getChronology()) { [EOL]         throw new IllegalArgumentException("The chronology of the time does not match"); [EOL]     } [EOL]     long localMillis = getLocalMillis() + time.getLocalMillis(); [EOL]     return new LocalDateTime(localMillis, getChronology()); [EOL] }
public DateTime toDateTime(LocalTime time) { [EOL]     return toDateTime(time, null); [EOL] }
public DateTime toDateTime(LocalTime time) { [EOL]     return toDateTime(time, null); [EOL] }
@SuppressWarnings("deprecation") [EOL] public Date toDate() { [EOL]     int dom = getDayOfMonth(); [EOL]     Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom); [EOL]     LocalDate check = LocalDate.fromDateFields(date); [EOL]     if (check.isBefore(this)) { [EOL]         while (check.equals(this) == false) { [EOL]             date.setTime(date.getTime() + 3600000); [EOL]             check = LocalDate.fromDateFields(date); [EOL]         } [EOL]         while (date.getDate() == dom) { [EOL]             date.setTime(date.getTime() - 1000); [EOL]         } [EOL]         date.setTime(date.getTime() + 1000); [EOL]     } else if (check.equals(this)) { [EOL]         Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings()); [EOL]         if (earlier.getDate() == dom) { [EOL]             date = earlier; [EOL]         } [EOL]     } [EOL]     return date; [EOL] }
@SuppressWarnings("deprecation") [EOL] public Date toDate() { [EOL]     int dom = getDayOfMonth(); [EOL]     Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom); [EOL]     LocalDate check = LocalDate.fromDateFields(date); [EOL]     if (check.isBefore(this)) { [EOL]         while (check.equals(this) == false) { [EOL]             date.setTime(date.getTime() + 3600000); [EOL]             check = LocalDate.fromDateFields(date); [EOL]         } [EOL]         while (date.getDate() == dom) { [EOL]             date.setTime(date.getTime() - 1000); [EOL]         } [EOL]         date.setTime(date.getTime() + 1000); [EOL]     } else if (check.equals(this)) { [EOL]         Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings()); [EOL]         if (earlier.getDate() == dom) { [EOL]             date = earlier; [EOL]         } [EOL]     } [EOL]     return date; [EOL] }
@SuppressWarnings("deprecation") [EOL] public Date toDate() { [EOL]     int dom = getDayOfMonth(); [EOL]     Date date = new Date(getYear() - 1900, getMonthOfYear() - 1, dom); [EOL]     LocalDate check = LocalDate.fromDateFields(date); [EOL]     if (check.isBefore(this)) { [EOL]         while (check.equals(this) == false) { [EOL]             date.setTime(date.getTime() + 3600000); [EOL]             check = LocalDate.fromDateFields(date); [EOL]         } [EOL]         while (date.getDate() == dom) { [EOL]             date.setTime(date.getTime() - 1000); [EOL]         } [EOL]         date.setTime(date.getTime() + 1000); [EOL]     } else if (check.equals(this)) { [EOL]         Date earlier = new Date(date.getTime() - TimeZone.getDefault().getDSTSavings()); [EOL]         if (earlier.getDate() == dom) { [EOL]             date = earlier; [EOL]         } [EOL]     } [EOL]     return date; [EOL] }
public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate plusMonths(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().months().add(getLocalMillis(), months); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate plusMonths(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().months().add(getLocalMillis(), months); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate plusMonths(int months) { [EOL]     if (months == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().months().add(getLocalMillis(), months); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate minusYears(int years) { [EOL]     if (years == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().years().subtract(getLocalMillis(), years); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate minusYears(int years) { [EOL]     if (years == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().years().subtract(getLocalMillis(), years); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDate minusYears(int years) { [EOL]     if (years == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().years().subtract(getLocalMillis(), years); [EOL]     return withLocalMillis(instant); [EOL] }
public int getEra() { [EOL]     return getChronology().era().get(getLocalMillis()); [EOL] }
public int getCenturyOfEra() { [EOL]     return getChronology().centuryOfEra().get(getLocalMillis()); [EOL] }
public int getYearOfEra() { [EOL]     return getChronology().yearOfEra().get(getLocalMillis()); [EOL] }
public int getYearOfCentury() { [EOL]     return getChronology().yearOfCentury().get(getLocalMillis()); [EOL] }
public int getYear() { [EOL]     return getChronology().year().get(getLocalMillis()); [EOL] }
public int getWeekyear() { [EOL]     return getChronology().weekyear().get(getLocalMillis()); [EOL] }
public int getMonthOfYear() { [EOL]     return getChronology().monthOfYear().get(getLocalMillis()); [EOL] }
public int getWeekOfWeekyear() { [EOL]     return getChronology().weekOfWeekyear().get(getLocalMillis()); [EOL] }
public int getDayOfYear() { [EOL]     return getChronology().dayOfYear().get(getLocalMillis()); [EOL] }
public int getDayOfMonth() { [EOL]     return getChronology().dayOfMonth().get(getLocalMillis()); [EOL] }
public int getDayOfWeek() { [EOL]     return getChronology().dayOfWeek().get(getLocalMillis()); [EOL] }
public LocalDate withEra(int era) { [EOL]     return withLocalMillis(getChronology().era().set(getLocalMillis(), era)); [EOL] }
public LocalDate withEra(int era) { [EOL]     return withLocalMillis(getChronology().era().set(getLocalMillis(), era)); [EOL] }
public LocalDate withCenturyOfEra(int centuryOfEra) { [EOL]     return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra)); [EOL] }
public LocalDate withCenturyOfEra(int centuryOfEra) { [EOL]     return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra)); [EOL] }
public LocalDate withCenturyOfEra(int centuryOfEra) { [EOL]     return withLocalMillis(getChronology().centuryOfEra().set(getLocalMillis(), centuryOfEra)); [EOL] }
public LocalDate withYearOfEra(int yearOfEra) { [EOL]     return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra)); [EOL] }
public LocalDate withYearOfEra(int yearOfEra) { [EOL]     return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra)); [EOL] }
public LocalDate withYearOfEra(int yearOfEra) { [EOL]     return withLocalMillis(getChronology().yearOfEra().set(getLocalMillis(), yearOfEra)); [EOL] }
public LocalDate withYearOfCentury(int yearOfCentury) { [EOL]     return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury)); [EOL] }
public LocalDate withYearOfCentury(int yearOfCentury) { [EOL]     return withLocalMillis(getChronology().yearOfCentury().set(getLocalMillis(), yearOfCentury)); [EOL] }
public LocalDate withYear(int year) { [EOL]     return withLocalMillis(getChronology().year().set(getLocalMillis(), year)); [EOL] }
public LocalDate withYear(int year) { [EOL]     return withLocalMillis(getChronology().year().set(getLocalMillis(), year)); [EOL] }
public LocalDate withWeekyear(int weekyear) { [EOL]     return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear)); [EOL] }
public LocalDate withWeekyear(int weekyear) { [EOL]     return withLocalMillis(getChronology().weekyear().set(getLocalMillis(), weekyear)); [EOL] }
public LocalDate withMonthOfYear(int monthOfYear) { [EOL]     return withLocalMillis(getChronology().monthOfYear().set(getLocalMillis(), monthOfYear)); [EOL] }
public LocalDate withWeekOfWeekyear(int weekOfWeekyear) { [EOL]     return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear)); [EOL] }
public LocalDate withWeekOfWeekyear(int weekOfWeekyear) { [EOL]     return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear)); [EOL] }
public LocalDate withWeekOfWeekyear(int weekOfWeekyear) { [EOL]     return withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear)); [EOL] }
public LocalDate withDayOfYear(int dayOfYear) { [EOL]     return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear)); [EOL] }
public LocalDate withDayOfYear(int dayOfYear) { [EOL]     return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear)); [EOL] }
public LocalDate withDayOfYear(int dayOfYear) { [EOL]     return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear)); [EOL] }
public LocalDate withDayOfYear(int dayOfYear) { [EOL]     return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear)); [EOL] }
public LocalDate withDayOfYear(int dayOfYear) { [EOL]     return withLocalMillis(getChronology().dayOfYear().set(getLocalMillis(), dayOfYear)); [EOL] }
public LocalDate withDayOfMonth(int dayOfMonth) { [EOL]     return withLocalMillis(getChronology().dayOfMonth().set(getLocalMillis(), dayOfMonth)); [EOL] }
public LocalDate withDayOfWeek(int dayOfWeek) { [EOL]     return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek)); [EOL] }
public LocalDate withDayOfWeek(int dayOfWeek) { [EOL]     return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek)); [EOL] }
public LocalDate withDayOfWeek(int dayOfWeek) { [EOL]     return withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek)); [EOL] }
protected PeriodFormat() { [EOL]     super(); [EOL] }
public static PeriodFormatter wordBased() { [EOL]     return wordBased(Locale.getDefault()); [EOL] }
public static EthiopicChronology getInstanceUTC() { [EOL]     return INSTANCE_UTC; [EOL] }
public static EthiopicChronology getInstance() { [EOL]     return getInstance(DateTimeZone.getDefault(), 4); [EOL] }
public static EthiopicChronology getInstance(DateTimeZone zone) { [EOL]     return getInstance(zone, 4); [EOL] }
public static EthiopicChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     EthiopicChronology chrono; [EOL]     synchronized (cCache) { [EOL]         EthiopicChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new EthiopicChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new EthiopicChronology(null, null, minDaysInFirstWeek); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new EthiopicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new EthiopicChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static EthiopicChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     EthiopicChronology chrono; [EOL]     synchronized (cCache) { [EOL]         EthiopicChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new EthiopicChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new EthiopicChronology(null, null, minDaysInFirstWeek); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new EthiopicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new EthiopicChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static EthiopicChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     EthiopicChronology chrono; [EOL]     synchronized (cCache) { [EOL]         EthiopicChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new EthiopicChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new EthiopicChronology(null, null, minDaysInFirstWeek); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new EthiopicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new EthiopicChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static EthiopicChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     EthiopicChronology chrono; [EOL]     synchronized (cCache) { [EOL]         EthiopicChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new EthiopicChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new EthiopicChronology(null, null, minDaysInFirstWeek); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new EthiopicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new EthiopicChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static EthiopicChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     EthiopicChronology chrono; [EOL]     synchronized (cCache) { [EOL]         EthiopicChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new EthiopicChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new EthiopicChronology(null, null, minDaysInFirstWeek); [EOL]                 DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono); [EOL]                 chrono = new EthiopicChronology(LimitChronology.getInstance(chrono, lowerLimit, null), null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new EthiopicChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
long getApproxMillisAtEpochDividedByTwo() { [EOL]     return (1962L * MILLIS_PER_YEAR + 112L * DateTimeConstants.MILLIS_PER_DAY) / 2; [EOL] }
public long set(long instant, int era) { [EOL]     FieldUtils.verifyValueBounds(this, era, DateTimeConstants.BCE, DateTimeConstants.CE); [EOL]     int oldEra = get(instant); [EOL]     if (oldEra != era) { [EOL]         int year = iChronology.getYear(instant); [EOL]         return iChronology.setYear(instant, -year); [EOL]     } else { [EOL]         return instant; [EOL]     } [EOL] }
public long set(long instant, int era) { [EOL]     FieldUtils.verifyValueBounds(this, era, DateTimeConstants.BCE, DateTimeConstants.CE); [EOL]     int oldEra = get(instant); [EOL]     if (oldEra != era) { [EOL]         int year = iChronology.getYear(instant); [EOL]         return iChronology.setYear(instant, -year); [EOL]     } else { [EOL]         return instant; [EOL]     } [EOL] }
public long set(long instant, int era) { [EOL]     FieldUtils.verifyValueBounds(this, era, DateTimeConstants.BCE, DateTimeConstants.CE); [EOL]     int oldEra = get(instant); [EOL]     if (oldEra != era) { [EOL]         int year = iChronology.getYear(instant); [EOL]         return iChronology.setYear(instant, -year); [EOL]     } else { [EOL]         return instant; [EOL]     } [EOL] }
public long roundFloor(long instant) { [EOL]     if (get(instant) == DateTimeConstants.CE) { [EOL]         return iChronology.setYear(0, 1); [EOL]     } else { [EOL]         return Long.MIN_VALUE; [EOL]     } [EOL] }
public long roundFloor(long instant) { [EOL]     if (get(instant) == DateTimeConstants.CE) { [EOL]         return iChronology.setYear(0, 1); [EOL]     } else { [EOL]         return Long.MIN_VALUE; [EOL]     } [EOL] }
public static PeriodType months() { [EOL]     PeriodType type = cMonths; [EOL]     if (type == null) { [EOL]         type = new PeriodType("Months", new DurationFieldType[] { DurationFieldType.months() }, new int[] { -1, 0, -1, -1, -1, -1, -1, -1 }); [EOL]         cMonths = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType months() { [EOL]     PeriodType type = cMonths; [EOL]     if (type == null) { [EOL]         type = new PeriodType("Months", new DurationFieldType[] { DurationFieldType.months() }, new int[] { -1, 0, -1, -1, -1, -1, -1, -1 }); [EOL]         cMonths = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType days() { [EOL]     PeriodType type = cDays; [EOL]     if (type == null) { [EOL]         type = new PeriodType("Days", new DurationFieldType[] { DurationFieldType.days() }, new int[] { -1, -1, -1, 0, -1, -1, -1, -1 }); [EOL]         cDays = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType hours() { [EOL]     PeriodType type = cHours; [EOL]     if (type == null) { [EOL]         type = new PeriodType("Hours", new DurationFieldType[] { DurationFieldType.hours() }, new int[] { -1, -1, -1, -1, 0, -1, -1, -1 }); [EOL]         cHours = type; [EOL]     } [EOL]     return type; [EOL] }
public static PeriodType minutes() { [EOL]     PeriodType type = cMinutes; [EOL]     if (type == null) { [EOL]         type = new PeriodType("Minutes", new DurationFieldType[] { DurationFieldType.minutes() }, new int[] { -1, -1, -1, -1, -1, 0, -1, -1 }); [EOL]         cMinutes = type; [EOL]     } [EOL]     return type; [EOL] }
public int indexOf(DurationFieldType type) { [EOL]     for (int i = 0, isize = size(); i < isize; i++) { [EOL]         if (iTypes[i] == type) { [EOL]             return i; [EOL]         } [EOL]     } [EOL]     return -1; [EOL] }
public PeriodType withYearsRemoved() { [EOL]     return withFieldRemoved(0, "NoYears"); [EOL] }
public PeriodType withYearsRemoved() { [EOL]     return withFieldRemoved(0, "NoYears"); [EOL] }
public PeriodType withMillisRemoved() { [EOL]     return withFieldRemoved(7, "NoMillis"); [EOL] }
public PeriodType withMillisRemoved() { [EOL]     return withFieldRemoved(7, "NoMillis"); [EOL] }
protected DateTimeUtils() { [EOL]     super(); [EOL] }
public static final void setCurrentMillisProvider(MillisProvider millisProvider) throws SecurityException { [EOL]     if (millisProvider == null) { [EOL]         throw new IllegalArgumentException("The MillisProvider must not be null"); [EOL]     } [EOL]     checkPermission(); [EOL]     cMillisProvider = millisProvider; [EOL] }
public Class<?> getSupportedType() { [EOL]     return null; [EOL] }
protected BaseInterval(ReadableInstant start, ReadablePeriod period) { [EOL]     super(); [EOL]     Chronology chrono = DateTimeUtils.getInstantChronology(start); [EOL]     iChronology = chrono; [EOL]     iStartMillis = DateTimeUtils.getInstantMillis(start); [EOL]     if (period == null) { [EOL]         iEndMillis = iStartMillis; [EOL]     } else { [EOL]         iEndMillis = chrono.add(period, iStartMillis, 1); [EOL]     } [EOL]     checkInterval(iStartMillis, iEndMillis); [EOL] }
protected BaseInterval(ReadableInstant start, ReadablePeriod period) { [EOL]     super(); [EOL]     Chronology chrono = DateTimeUtils.getInstantChronology(start); [EOL]     iChronology = chrono; [EOL]     iStartMillis = DateTimeUtils.getInstantMillis(start); [EOL]     if (period == null) { [EOL]         iEndMillis = iStartMillis; [EOL]     } else { [EOL]         iEndMillis = chrono.add(period, iStartMillis, 1); [EOL]     } [EOL]     checkInterval(iStartMillis, iEndMillis); [EOL] }
@FromString [EOL] public static DateTimeZone forID(String id) { [EOL]     if (id == null) { [EOL]         return getDefault(); [EOL]     } [EOL]     if (id.equals("UTC")) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     DateTimeZone zone = cProvider.getZone(id); [EOL]     if (zone != null) { [EOL]         return zone; [EOL]     } [EOL]     if (id.startsWith("+") || id.startsWith("-")) { [EOL]         int offset = parseOffset(id); [EOL]         if (offset == 0L) { [EOL]             return DateTimeZone.UTC; [EOL]         } else { [EOL]             id = printOffset(offset); [EOL]             return fixedOffsetZone(id, offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised"); [EOL] }
@FromString [EOL] public static DateTimeZone forID(String id) { [EOL]     if (id == null) { [EOL]         return getDefault(); [EOL]     } [EOL]     if (id.equals("UTC")) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     DateTimeZone zone = cProvider.getZone(id); [EOL]     if (zone != null) { [EOL]         return zone; [EOL]     } [EOL]     if (id.startsWith("+") || id.startsWith("-")) { [EOL]         int offset = parseOffset(id); [EOL]         if (offset == 0L) { [EOL]             return DateTimeZone.UTC; [EOL]         } else { [EOL]             id = printOffset(offset); [EOL]             return fixedOffsetZone(id, offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised"); [EOL] }
@FromString [EOL] public static DateTimeZone forID(String id) { [EOL]     if (id == null) { [EOL]         return getDefault(); [EOL]     } [EOL]     if (id.equals("UTC")) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     DateTimeZone zone = cProvider.getZone(id); [EOL]     if (zone != null) { [EOL]         return zone; [EOL]     } [EOL]     if (id.startsWith("+") || id.startsWith("-")) { [EOL]         int offset = parseOffset(id); [EOL]         if (offset == 0L) { [EOL]             return DateTimeZone.UTC; [EOL]         } else { [EOL]             id = printOffset(offset); [EOL]             return fixedOffsetZone(id, offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised"); [EOL] }
@FromString [EOL] public static DateTimeZone forID(String id) { [EOL]     if (id == null) { [EOL]         return getDefault(); [EOL]     } [EOL]     if (id.equals("UTC")) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     DateTimeZone zone = cProvider.getZone(id); [EOL]     if (zone != null) { [EOL]         return zone; [EOL]     } [EOL]     if (id.startsWith("+") || id.startsWith("-")) { [EOL]         int offset = parseOffset(id); [EOL]         if (offset == 0L) { [EOL]             return DateTimeZone.UTC; [EOL]         } else { [EOL]             id = printOffset(offset); [EOL]             return fixedOffsetZone(id, offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised"); [EOL] }
@FromString [EOL] public static DateTimeZone forID(String id) { [EOL]     if (id == null) { [EOL]         return getDefault(); [EOL]     } [EOL]     if (id.equals("UTC")) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     DateTimeZone zone = cProvider.getZone(id); [EOL]     if (zone != null) { [EOL]         return zone; [EOL]     } [EOL]     if (id.startsWith("+") || id.startsWith("-")) { [EOL]         int offset = parseOffset(id); [EOL]         if (offset == 0L) { [EOL]             return DateTimeZone.UTC; [EOL]         } else { [EOL]             id = printOffset(offset); [EOL]             return fixedOffsetZone(id, offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised"); [EOL] }
@FromString [EOL] public static DateTimeZone forID(String id) { [EOL]     if (id == null) { [EOL]         return getDefault(); [EOL]     } [EOL]     if (id.equals("UTC")) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     DateTimeZone zone = cProvider.getZone(id); [EOL]     if (zone != null) { [EOL]         return zone; [EOL]     } [EOL]     if (id.startsWith("+") || id.startsWith("-")) { [EOL]         int offset = parseOffset(id); [EOL]         if (offset == 0L) { [EOL]             return DateTimeZone.UTC; [EOL]         } else { [EOL]             id = printOffset(offset); [EOL]             return fixedOffsetZone(id, offset); [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised"); [EOL] }
public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { [EOL]     if (hoursOffset == 0 && minutesOffset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     if (hoursOffset < -23 || hoursOffset > 23) { [EOL]         throw new IllegalArgumentException("Hours out of range: " + hoursOffset); [EOL]     } [EOL]     if (minutesOffset < -59 || minutesOffset > 59) { [EOL]         throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); [EOL]     } [EOL]     if (hoursOffset > 0 && minutesOffset < 0) { [EOL]         throw new IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset); [EOL]     } [EOL]     int offset = 0; [EOL]     try { [EOL]         int hoursInMinutes = hoursOffset * 60; [EOL]         if (hoursInMinutes < 0) { [EOL]             minutesOffset = hoursInMinutes - Math.abs(minutesOffset); [EOL]         } else { [EOL]             minutesOffset = hoursInMinutes + minutesOffset; [EOL]         } [EOL]         offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); [EOL]     } catch (ArithmeticException ex) { [EOL]         throw new IllegalArgumentException("Offset is too large"); [EOL]     } [EOL]     return forOffsetMillis(offset); [EOL] }
public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { [EOL]     if (hoursOffset == 0 && minutesOffset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     if (hoursOffset < -23 || hoursOffset > 23) { [EOL]         throw new IllegalArgumentException("Hours out of range: " + hoursOffset); [EOL]     } [EOL]     if (minutesOffset < -59 || minutesOffset > 59) { [EOL]         throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); [EOL]     } [EOL]     if (hoursOffset > 0 && minutesOffset < 0) { [EOL]         throw new IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset); [EOL]     } [EOL]     int offset = 0; [EOL]     try { [EOL]         int hoursInMinutes = hoursOffset * 60; [EOL]         if (hoursInMinutes < 0) { [EOL]             minutesOffset = hoursInMinutes - Math.abs(minutesOffset); [EOL]         } else { [EOL]             minutesOffset = hoursInMinutes + minutesOffset; [EOL]         } [EOL]         offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); [EOL]     } catch (ArithmeticException ex) { [EOL]         throw new IllegalArgumentException("Offset is too large"); [EOL]     } [EOL]     return forOffsetMillis(offset); [EOL] }
public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { [EOL]     if (hoursOffset == 0 && minutesOffset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     if (hoursOffset < -23 || hoursOffset > 23) { [EOL]         throw new IllegalArgumentException("Hours out of range: " + hoursOffset); [EOL]     } [EOL]     if (minutesOffset < -59 || minutesOffset > 59) { [EOL]         throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); [EOL]     } [EOL]     if (hoursOffset > 0 && minutesOffset < 0) { [EOL]         throw new IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset); [EOL]     } [EOL]     int offset = 0; [EOL]     try { [EOL]         int hoursInMinutes = hoursOffset * 60; [EOL]         if (hoursInMinutes < 0) { [EOL]             minutesOffset = hoursInMinutes - Math.abs(minutesOffset); [EOL]         } else { [EOL]             minutesOffset = hoursInMinutes + minutesOffset; [EOL]         } [EOL]         offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); [EOL]     } catch (ArithmeticException ex) { [EOL]         throw new IllegalArgumentException("Offset is too large"); [EOL]     } [EOL]     return forOffsetMillis(offset); [EOL] }
public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { [EOL]     if (hoursOffset == 0 && minutesOffset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     if (hoursOffset < -23 || hoursOffset > 23) { [EOL]         throw new IllegalArgumentException("Hours out of range: " + hoursOffset); [EOL]     } [EOL]     if (minutesOffset < -59 || minutesOffset > 59) { [EOL]         throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); [EOL]     } [EOL]     if (hoursOffset > 0 && minutesOffset < 0) { [EOL]         throw new IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset); [EOL]     } [EOL]     int offset = 0; [EOL]     try { [EOL]         int hoursInMinutes = hoursOffset * 60; [EOL]         if (hoursInMinutes < 0) { [EOL]             minutesOffset = hoursInMinutes - Math.abs(minutesOffset); [EOL]         } else { [EOL]             minutesOffset = hoursInMinutes + minutesOffset; [EOL]         } [EOL]         offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); [EOL]     } catch (ArithmeticException ex) { [EOL]         throw new IllegalArgumentException("Offset is too large"); [EOL]     } [EOL]     return forOffsetMillis(offset); [EOL] }
public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { [EOL]     if (hoursOffset == 0 && minutesOffset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     if (hoursOffset < -23 || hoursOffset > 23) { [EOL]         throw new IllegalArgumentException("Hours out of range: " + hoursOffset); [EOL]     } [EOL]     if (minutesOffset < -59 || minutesOffset > 59) { [EOL]         throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); [EOL]     } [EOL]     if (hoursOffset > 0 && minutesOffset < 0) { [EOL]         throw new IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset); [EOL]     } [EOL]     int offset = 0; [EOL]     try { [EOL]         int hoursInMinutes = hoursOffset * 60; [EOL]         if (hoursInMinutes < 0) { [EOL]             minutesOffset = hoursInMinutes - Math.abs(minutesOffset); [EOL]         } else { [EOL]             minutesOffset = hoursInMinutes + minutesOffset; [EOL]         } [EOL]         offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); [EOL]     } catch (ArithmeticException ex) { [EOL]         throw new IllegalArgumentException("Offset is too large"); [EOL]     } [EOL]     return forOffsetMillis(offset); [EOL] }
public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException { [EOL]     if (hoursOffset == 0 && minutesOffset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     if (hoursOffset < -23 || hoursOffset > 23) { [EOL]         throw new IllegalArgumentException("Hours out of range: " + hoursOffset); [EOL]     } [EOL]     if (minutesOffset < -59 || minutesOffset > 59) { [EOL]         throw new IllegalArgumentException("Minutes out of range: " + minutesOffset); [EOL]     } [EOL]     if (hoursOffset > 0 && minutesOffset < 0) { [EOL]         throw new IllegalArgumentException("Positive hours must not have negative minutes: " + minutesOffset); [EOL]     } [EOL]     int offset = 0; [EOL]     try { [EOL]         int hoursInMinutes = hoursOffset * 60; [EOL]         if (hoursInMinutes < 0) { [EOL]             minutesOffset = hoursInMinutes - Math.abs(minutesOffset); [EOL]         } else { [EOL]             minutesOffset = hoursInMinutes + minutesOffset; [EOL]         } [EOL]         offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE); [EOL]     } catch (ArithmeticException ex) { [EOL]         throw new IllegalArgumentException("Offset is too large"); [EOL]     } [EOL]     return forOffsetMillis(offset); [EOL] }
public static DateTimeZone forOffsetMillis(int millisOffset) { [EOL]     if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) { [EOL]         throw new IllegalArgumentException("Millis out of range: " + millisOffset); [EOL]     } [EOL]     String id = printOffset(millisOffset); [EOL]     return fixedOffsetZone(id, millisOffset); [EOL] }
public static DateTimeZone forOffsetMillis(int millisOffset) { [EOL]     if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) { [EOL]         throw new IllegalArgumentException("Millis out of range: " + millisOffset); [EOL]     } [EOL]     String id = printOffset(millisOffset); [EOL]     return fixedOffsetZone(id, millisOffset); [EOL] }
public static DateTimeZone forOffsetMillis(int millisOffset) { [EOL]     if (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) { [EOL]         throw new IllegalArgumentException("Millis out of range: " + millisOffset); [EOL]     } [EOL]     String id = printOffset(millisOffset); [EOL]     return fixedOffsetZone(id, millisOffset); [EOL] }
public static DateTimeZone forTimeZone(TimeZone zone) { [EOL]     if (zone == null) { [EOL]         return getDefault(); [EOL]     } [EOL]     final String id = zone.getID(); [EOL]     if (id.equals("UTC")) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     DateTimeZone dtz = null; [EOL]     String convId = getConvertedId(id); [EOL]     if (convId != null) { [EOL]         dtz = cProvider.getZone(convId); [EOL]     } [EOL]     if (dtz == null) { [EOL]         dtz = cProvider.getZone(id); [EOL]     } [EOL]     if (dtz != null) { [EOL]         return dtz; [EOL]     } [EOL]     if (convId == null) { [EOL]         convId = zone.getID(); [EOL]         if (convId.startsWith("GMT+") || convId.startsWith("GMT-")) { [EOL]             convId = convId.substring(3); [EOL]             int offset = parseOffset(convId); [EOL]             if (offset == 0L) { [EOL]                 return DateTimeZone.UTC; [EOL]             } else { [EOL]                 convId = printOffset(offset); [EOL]                 return fixedOffsetZone(convId, offset); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised"); [EOL] }
public static DateTimeZone forTimeZone(TimeZone zone) { [EOL]     if (zone == null) { [EOL]         return getDefault(); [EOL]     } [EOL]     final String id = zone.getID(); [EOL]     if (id.equals("UTC")) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     DateTimeZone dtz = null; [EOL]     String convId = getConvertedId(id); [EOL]     if (convId != null) { [EOL]         dtz = cProvider.getZone(convId); [EOL]     } [EOL]     if (dtz == null) { [EOL]         dtz = cProvider.getZone(id); [EOL]     } [EOL]     if (dtz != null) { [EOL]         return dtz; [EOL]     } [EOL]     if (convId == null) { [EOL]         convId = zone.getID(); [EOL]         if (convId.startsWith("GMT+") || convId.startsWith("GMT-")) { [EOL]             convId = convId.substring(3); [EOL]             int offset = parseOffset(convId); [EOL]             if (offset == 0L) { [EOL]                 return DateTimeZone.UTC; [EOL]             } else { [EOL]                 convId = printOffset(offset); [EOL]                 return fixedOffsetZone(convId, offset); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised"); [EOL] }
public static DateTimeZone forTimeZone(TimeZone zone) { [EOL]     if (zone == null) { [EOL]         return getDefault(); [EOL]     } [EOL]     final String id = zone.getID(); [EOL]     if (id.equals("UTC")) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     DateTimeZone dtz = null; [EOL]     String convId = getConvertedId(id); [EOL]     if (convId != null) { [EOL]         dtz = cProvider.getZone(convId); [EOL]     } [EOL]     if (dtz == null) { [EOL]         dtz = cProvider.getZone(id); [EOL]     } [EOL]     if (dtz != null) { [EOL]         return dtz; [EOL]     } [EOL]     if (convId == null) { [EOL]         convId = zone.getID(); [EOL]         if (convId.startsWith("GMT+") || convId.startsWith("GMT-")) { [EOL]             convId = convId.substring(3); [EOL]             int offset = parseOffset(convId); [EOL]             if (offset == 0L) { [EOL]                 return DateTimeZone.UTC; [EOL]             } else { [EOL]                 convId = printOffset(offset); [EOL]                 return fixedOffsetZone(convId, offset); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised"); [EOL] }
public static DateTimeZone forTimeZone(TimeZone zone) { [EOL]     if (zone == null) { [EOL]         return getDefault(); [EOL]     } [EOL]     final String id = zone.getID(); [EOL]     if (id.equals("UTC")) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     DateTimeZone dtz = null; [EOL]     String convId = getConvertedId(id); [EOL]     if (convId != null) { [EOL]         dtz = cProvider.getZone(convId); [EOL]     } [EOL]     if (dtz == null) { [EOL]         dtz = cProvider.getZone(id); [EOL]     } [EOL]     if (dtz != null) { [EOL]         return dtz; [EOL]     } [EOL]     if (convId == null) { [EOL]         convId = zone.getID(); [EOL]         if (convId.startsWith("GMT+") || convId.startsWith("GMT-")) { [EOL]             convId = convId.substring(3); [EOL]             int offset = parseOffset(convId); [EOL]             if (offset == 0L) { [EOL]                 return DateTimeZone.UTC; [EOL]             } else { [EOL]                 convId = printOffset(offset); [EOL]                 return fixedOffsetZone(convId, offset); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised"); [EOL] }
public static DateTimeZone forTimeZone(TimeZone zone) { [EOL]     if (zone == null) { [EOL]         return getDefault(); [EOL]     } [EOL]     final String id = zone.getID(); [EOL]     if (id.equals("UTC")) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     DateTimeZone dtz = null; [EOL]     String convId = getConvertedId(id); [EOL]     if (convId != null) { [EOL]         dtz = cProvider.getZone(convId); [EOL]     } [EOL]     if (dtz == null) { [EOL]         dtz = cProvider.getZone(id); [EOL]     } [EOL]     if (dtz != null) { [EOL]         return dtz; [EOL]     } [EOL]     if (convId == null) { [EOL]         convId = zone.getID(); [EOL]         if (convId.startsWith("GMT+") || convId.startsWith("GMT-")) { [EOL]             convId = convId.substring(3); [EOL]             int offset = parseOffset(convId); [EOL]             if (offset == 0L) { [EOL]                 return DateTimeZone.UTC; [EOL]             } else { [EOL]                 convId = printOffset(offset); [EOL]                 return fixedOffsetZone(convId, offset); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised"); [EOL] }
public static DateTimeZone forTimeZone(TimeZone zone) { [EOL]     if (zone == null) { [EOL]         return getDefault(); [EOL]     } [EOL]     final String id = zone.getID(); [EOL]     if (id.equals("UTC")) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     DateTimeZone dtz = null; [EOL]     String convId = getConvertedId(id); [EOL]     if (convId != null) { [EOL]         dtz = cProvider.getZone(convId); [EOL]     } [EOL]     if (dtz == null) { [EOL]         dtz = cProvider.getZone(id); [EOL]     } [EOL]     if (dtz != null) { [EOL]         return dtz; [EOL]     } [EOL]     if (convId == null) { [EOL]         convId = zone.getID(); [EOL]         if (convId.startsWith("GMT+") || convId.startsWith("GMT-")) { [EOL]             convId = convId.substring(3); [EOL]             int offset = parseOffset(convId); [EOL]             if (offset == 0L) { [EOL]                 return DateTimeZone.UTC; [EOL]             } else { [EOL]                 convId = printOffset(offset); [EOL]                 return fixedOffsetZone(convId, offset); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw new IllegalArgumentException("The datetime zone id '" + id + "' is not recognised"); [EOL] }
private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) { [EOL]     if (offset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     if (iFixedOffsetCache == null) { [EOL]         iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>(); [EOL]     } [EOL]     DateTimeZone zone; [EOL]     Reference<DateTimeZone> ref = iFixedOffsetCache.get(id); [EOL]     if (ref != null) { [EOL]         zone = ref.get(); [EOL]         if (zone != null) { [EOL]             return zone; [EOL]         } [EOL]     } [EOL]     zone = new FixedDateTimeZone(id, null, offset, offset); [EOL]     iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone)); [EOL]     return zone; [EOL] }
private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) { [EOL]     if (offset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     if (iFixedOffsetCache == null) { [EOL]         iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>(); [EOL]     } [EOL]     DateTimeZone zone; [EOL]     Reference<DateTimeZone> ref = iFixedOffsetCache.get(id); [EOL]     if (ref != null) { [EOL]         zone = ref.get(); [EOL]         if (zone != null) { [EOL]             return zone; [EOL]         } [EOL]     } [EOL]     zone = new FixedDateTimeZone(id, null, offset, offset); [EOL]     iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone)); [EOL]     return zone; [EOL] }
private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) { [EOL]     if (offset == 0) { [EOL]         return DateTimeZone.UTC; [EOL]     } [EOL]     if (iFixedOffsetCache == null) { [EOL]         iFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>(); [EOL]     } [EOL]     DateTimeZone zone; [EOL]     Reference<DateTimeZone> ref = iFixedOffsetCache.get(id); [EOL]     if (ref != null) { [EOL]         zone = ref.get(); [EOL]         if (zone != null) { [EOL]             return zone; [EOL]         } [EOL]     } [EOL]     zone = new FixedDateTimeZone(id, null, offset, offset); [EOL]     iFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone)); [EOL]     return zone; [EOL] }
public static void setProvider(Provider provider) throws SecurityException { [EOL]     SecurityManager sm = System.getSecurityManager(); [EOL]     if (sm != null) { [EOL]         sm.checkPermission(new JodaTimePermission("DateTimeZone.setProvider")); [EOL]     } [EOL]     setProvider0(provider); [EOL] }
public static void setProvider(Provider provider) throws SecurityException { [EOL]     SecurityManager sm = System.getSecurityManager(); [EOL]     if (sm != null) { [EOL]         sm.checkPermission(new JodaTimePermission("DateTimeZone.setProvider")); [EOL]     } [EOL]     setProvider0(provider); [EOL] }
public static void setProvider(Provider provider) throws SecurityException { [EOL]     SecurityManager sm = System.getSecurityManager(); [EOL]     if (sm != null) { [EOL]         sm.checkPermission(new JodaTimePermission("DateTimeZone.setProvider")); [EOL]     } [EOL]     setProvider0(provider); [EOL] }
private static void setProvider0(Provider provider) { [EOL]     if (provider == null) { [EOL]         provider = getDefaultProvider(); [EOL]     } [EOL]     Set<String> ids = provider.getAvailableIDs(); [EOL]     if (ids == null || ids.size() == 0) { [EOL]         throw new IllegalArgumentException("The provider doesn't have any available ids"); [EOL]     } [EOL]     if (!ids.contains("UTC")) { [EOL]         throw new IllegalArgumentException("The provider doesn't support UTC"); [EOL]     } [EOL]     if (!UTC.equals(provider.getZone("UTC"))) { [EOL]         throw new IllegalArgumentException("Invalid UTC zone provided"); [EOL]     } [EOL]     cProvider = provider; [EOL]     cAvailableIDs = ids; [EOL] }
private static Provider getDefaultProvider() { [EOL]     Provider provider = null; [EOL]     try { [EOL]         String providerClass = System.getProperty("org.joda.time.DateTimeZone.Provider"); [EOL]         if (providerClass != null) { [EOL]             try { [EOL]                 provider = (Provider) Class.forName(providerClass).newInstance(); [EOL]             } catch (Exception ex) { [EOL]                 throw new RuntimeException(ex); [EOL]             } [EOL]         } [EOL]     } catch (SecurityException ex) { [EOL]     } [EOL]     if (provider == null) { [EOL]         try { [EOL]             provider = new ZoneInfoProvider("org/joda/time/tz/data"); [EOL]         } catch (Exception ex) { [EOL]             ex.printStackTrace(); [EOL]         } [EOL]     } [EOL]     if (provider == null) { [EOL]         provider = new UTCProvider(); [EOL]     } [EOL]     return provider; [EOL] }
private static Provider getDefaultProvider() { [EOL]     Provider provider = null; [EOL]     try { [EOL]         String providerClass = System.getProperty("org.joda.time.DateTimeZone.Provider"); [EOL]         if (providerClass != null) { [EOL]             try { [EOL]                 provider = (Provider) Class.forName(providerClass).newInstance(); [EOL]             } catch (Exception ex) { [EOL]                 throw new RuntimeException(ex); [EOL]             } [EOL]         } [EOL]     } catch (SecurityException ex) { [EOL]     } [EOL]     if (provider == null) { [EOL]         try { [EOL]             provider = new ZoneInfoProvider("org/joda/time/tz/data"); [EOL]         } catch (Exception ex) { [EOL]             ex.printStackTrace(); [EOL]         } [EOL]     } [EOL]     if (provider == null) { [EOL]         provider = new UTCProvider(); [EOL]     } [EOL]     return provider; [EOL] }
private static Provider getDefaultProvider() { [EOL]     Provider provider = null; [EOL]     try { [EOL]         String providerClass = System.getProperty("org.joda.time.DateTimeZone.Provider"); [EOL]         if (providerClass != null) { [EOL]             try { [EOL]                 provider = (Provider) Class.forName(providerClass).newInstance(); [EOL]             } catch (Exception ex) { [EOL]                 throw new RuntimeException(ex); [EOL]             } [EOL]         } [EOL]     } catch (SecurityException ex) { [EOL]     } [EOL]     if (provider == null) { [EOL]         try { [EOL]             provider = new ZoneInfoProvider("org/joda/time/tz/data"); [EOL]         } catch (Exception ex) { [EOL]             ex.printStackTrace(); [EOL]         } [EOL]     } [EOL]     if (provider == null) { [EOL]         provider = new UTCProvider(); [EOL]     } [EOL]     return provider; [EOL] }
private static String printOffset(int offset) { [EOL]     StringBuffer buf = new StringBuffer(); [EOL]     if (offset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         offset = -offset; [EOL]     } [EOL]     int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     buf.append('.'); [EOL]     FormatUtils.appendPaddedInteger(buf, offset, 3); [EOL]     return buf.toString(); [EOL] }
private static String printOffset(int offset) { [EOL]     StringBuffer buf = new StringBuffer(); [EOL]     if (offset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         offset = -offset; [EOL]     } [EOL]     int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     buf.append('.'); [EOL]     FormatUtils.appendPaddedInteger(buf, offset, 3); [EOL]     return buf.toString(); [EOL] }
private static String printOffset(int offset) { [EOL]     StringBuffer buf = new StringBuffer(); [EOL]     if (offset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         offset = -offset; [EOL]     } [EOL]     int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     buf.append('.'); [EOL]     FormatUtils.appendPaddedInteger(buf, offset, 3); [EOL]     return buf.toString(); [EOL] }
private static String printOffset(int offset) { [EOL]     StringBuffer buf = new StringBuffer(); [EOL]     if (offset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         offset = -offset; [EOL]     } [EOL]     int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     buf.append('.'); [EOL]     FormatUtils.appendPaddedInteger(buf, offset, 3); [EOL]     return buf.toString(); [EOL] }
private static String printOffset(int offset) { [EOL]     StringBuffer buf = new StringBuffer(); [EOL]     if (offset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         offset = -offset; [EOL]     } [EOL]     int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     buf.append('.'); [EOL]     FormatUtils.appendPaddedInteger(buf, offset, 3); [EOL]     return buf.toString(); [EOL] }
private static String printOffset(int offset) { [EOL]     StringBuffer buf = new StringBuffer(); [EOL]     if (offset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         offset = -offset; [EOL]     } [EOL]     int hours = offset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     offset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     int minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     offset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     int seconds = offset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     buf.append(':'); [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     offset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (offset == 0) { [EOL]         return buf.toString(); [EOL]     } [EOL]     buf.append('.'); [EOL]     FormatUtils.appendPaddedInteger(buf, offset, 3); [EOL]     return buf.toString(); [EOL] }
protected DateTimeZone(String id) { [EOL]     if (id == null) { [EOL]         throw new IllegalArgumentException("Id must not be null"); [EOL]     } [EOL]     iID = id; [EOL] }
protected DateTimeZone(String id) { [EOL]     if (id == null) { [EOL]         throw new IllegalArgumentException("Id must not be null"); [EOL]     } [EOL]     iID = id; [EOL] }
public final int getOffset(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return getOffset(DateTimeUtils.currentTimeMillis()); [EOL]     } [EOL]     return getOffset(instant.getMillis()); [EOL] }
public final int getOffset(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return getOffset(DateTimeUtils.currentTimeMillis()); [EOL]     } [EOL]     return getOffset(instant.getMillis()); [EOL] }
public int getOffsetFromLocal(long instantLocal) { [EOL]     final int offsetLocal = getOffset(instantLocal); [EOL]     final long instantAdjusted = instantLocal - offsetLocal; [EOL]     final int offsetAdjusted = getOffset(instantAdjusted); [EOL]     if (offsetLocal != offsetAdjusted) { [EOL]         if ((offsetLocal - offsetAdjusted) < 0) { [EOL]             long nextLocal = nextTransition(instantAdjusted); [EOL]             long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); [EOL]             if (nextLocal != nextAdjusted) { [EOL]                 return offsetLocal; [EOL]             } [EOL]         } [EOL]     } else if (offsetLocal >= 0) { [EOL]         long prev = previousTransition(instantAdjusted); [EOL]         if (prev < instantAdjusted) { [EOL]             int offsetPrev = getOffset(prev); [EOL]             int diff = offsetPrev - offsetLocal; [EOL]             if (instantAdjusted - prev <= diff) { [EOL]                 return offsetPrev; [EOL]             } [EOL]         } [EOL]     } [EOL]     return offsetAdjusted; [EOL] }
public int getOffsetFromLocal(long instantLocal) { [EOL]     final int offsetLocal = getOffset(instantLocal); [EOL]     final long instantAdjusted = instantLocal - offsetLocal; [EOL]     final int offsetAdjusted = getOffset(instantAdjusted); [EOL]     if (offsetLocal != offsetAdjusted) { [EOL]         if ((offsetLocal - offsetAdjusted) < 0) { [EOL]             long nextLocal = nextTransition(instantAdjusted); [EOL]             long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); [EOL]             if (nextLocal != nextAdjusted) { [EOL]                 return offsetLocal; [EOL]             } [EOL]         } [EOL]     } else if (offsetLocal >= 0) { [EOL]         long prev = previousTransition(instantAdjusted); [EOL]         if (prev < instantAdjusted) { [EOL]             int offsetPrev = getOffset(prev); [EOL]             int diff = offsetPrev - offsetLocal; [EOL]             if (instantAdjusted - prev <= diff) { [EOL]                 return offsetPrev; [EOL]             } [EOL]         } [EOL]     } [EOL]     return offsetAdjusted; [EOL] }
public int getOffsetFromLocal(long instantLocal) { [EOL]     final int offsetLocal = getOffset(instantLocal); [EOL]     final long instantAdjusted = instantLocal - offsetLocal; [EOL]     final int offsetAdjusted = getOffset(instantAdjusted); [EOL]     if (offsetLocal != offsetAdjusted) { [EOL]         if ((offsetLocal - offsetAdjusted) < 0) { [EOL]             long nextLocal = nextTransition(instantAdjusted); [EOL]             long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); [EOL]             if (nextLocal != nextAdjusted) { [EOL]                 return offsetLocal; [EOL]             } [EOL]         } [EOL]     } else if (offsetLocal >= 0) { [EOL]         long prev = previousTransition(instantAdjusted); [EOL]         if (prev < instantAdjusted) { [EOL]             int offsetPrev = getOffset(prev); [EOL]             int diff = offsetPrev - offsetLocal; [EOL]             if (instantAdjusted - prev <= diff) { [EOL]                 return offsetPrev; [EOL]             } [EOL]         } [EOL]     } [EOL]     return offsetAdjusted; [EOL] }
public int getOffsetFromLocal(long instantLocal) { [EOL]     final int offsetLocal = getOffset(instantLocal); [EOL]     final long instantAdjusted = instantLocal - offsetLocal; [EOL]     final int offsetAdjusted = getOffset(instantAdjusted); [EOL]     if (offsetLocal != offsetAdjusted) { [EOL]         if ((offsetLocal - offsetAdjusted) < 0) { [EOL]             long nextLocal = nextTransition(instantAdjusted); [EOL]             long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); [EOL]             if (nextLocal != nextAdjusted) { [EOL]                 return offsetLocal; [EOL]             } [EOL]         } [EOL]     } else if (offsetLocal >= 0) { [EOL]         long prev = previousTransition(instantAdjusted); [EOL]         if (prev < instantAdjusted) { [EOL]             int offsetPrev = getOffset(prev); [EOL]             int diff = offsetPrev - offsetLocal; [EOL]             if (instantAdjusted - prev <= diff) { [EOL]                 return offsetPrev; [EOL]             } [EOL]         } [EOL]     } [EOL]     return offsetAdjusted; [EOL] }
public int getOffsetFromLocal(long instantLocal) { [EOL]     final int offsetLocal = getOffset(instantLocal); [EOL]     final long instantAdjusted = instantLocal - offsetLocal; [EOL]     final int offsetAdjusted = getOffset(instantAdjusted); [EOL]     if (offsetLocal != offsetAdjusted) { [EOL]         if ((offsetLocal - offsetAdjusted) < 0) { [EOL]             long nextLocal = nextTransition(instantAdjusted); [EOL]             long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); [EOL]             if (nextLocal != nextAdjusted) { [EOL]                 return offsetLocal; [EOL]             } [EOL]         } [EOL]     } else if (offsetLocal >= 0) { [EOL]         long prev = previousTransition(instantAdjusted); [EOL]         if (prev < instantAdjusted) { [EOL]             int offsetPrev = getOffset(prev); [EOL]             int diff = offsetPrev - offsetLocal; [EOL]             if (instantAdjusted - prev <= diff) { [EOL]                 return offsetPrev; [EOL]             } [EOL]         } [EOL]     } [EOL]     return offsetAdjusted; [EOL] }
public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) { [EOL]     int offsetOriginal = getOffset(originalInstantUTC); [EOL]     long instantUTC = instantLocal - offsetOriginal; [EOL]     int offsetLocalFromOriginal = getOffset(instantUTC); [EOL]     if (offsetLocalFromOriginal == offsetOriginal) { [EOL]         return instantUTC; [EOL]     } [EOL]     return convertLocalToUTC(instantLocal, strict); [EOL] }
public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) { [EOL]     int offsetOriginal = getOffset(originalInstantUTC); [EOL]     long instantUTC = instantLocal - offsetOriginal; [EOL]     int offsetLocalFromOriginal = getOffset(instantUTC); [EOL]     if (offsetLocalFromOriginal == offsetOriginal) { [EOL]         return instantUTC; [EOL]     } [EOL]     return convertLocalToUTC(instantLocal, strict); [EOL] }
public long convertLocalToUTC(long instantLocal, boolean strict) { [EOL]     int offsetLocal = getOffset(instantLocal); [EOL]     int offset = getOffset(instantLocal - offsetLocal); [EOL]     if (offsetLocal != offset) { [EOL]         if (strict || offsetLocal < 0) { [EOL]             long nextLocal = nextTransition(instantLocal - offsetLocal); [EOL]             if (nextLocal == (instantLocal - offsetLocal)) { [EOL]                 nextLocal = Long.MAX_VALUE; [EOL]             } [EOL]             long nextAdjusted = nextTransition(instantLocal - offset); [EOL]             if (nextAdjusted == (instantLocal - offset)) { [EOL]                 nextAdjusted = Long.MAX_VALUE; [EOL]             } [EOL]             if (nextLocal != nextAdjusted) { [EOL]                 if (strict) { [EOL]                     throw new IllegalInstantException(instantLocal, getID()); [EOL]                 } else { [EOL]                     offset = offsetLocal; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     long instantUTC = instantLocal - offset; [EOL]     if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) { [EOL]         throw new ArithmeticException("Subtracting time zone offset caused overflow"); [EOL]     } [EOL]     return instantUTC; [EOL] }
public long convertLocalToUTC(long instantLocal, boolean strict) { [EOL]     int offsetLocal = getOffset(instantLocal); [EOL]     int offset = getOffset(instantLocal - offsetLocal); [EOL]     if (offsetLocal != offset) { [EOL]         if (strict || offsetLocal < 0) { [EOL]             long nextLocal = nextTransition(instantLocal - offsetLocal); [EOL]             if (nextLocal == (instantLocal - offsetLocal)) { [EOL]                 nextLocal = Long.MAX_VALUE; [EOL]             } [EOL]             long nextAdjusted = nextTransition(instantLocal - offset); [EOL]             if (nextAdjusted == (instantLocal - offset)) { [EOL]                 nextAdjusted = Long.MAX_VALUE; [EOL]             } [EOL]             if (nextLocal != nextAdjusted) { [EOL]                 if (strict) { [EOL]                     throw new IllegalInstantException(instantLocal, getID()); [EOL]                 } else { [EOL]                     offset = offsetLocal; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     long instantUTC = instantLocal - offset; [EOL]     if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) { [EOL]         throw new ArithmeticException("Subtracting time zone offset caused overflow"); [EOL]     } [EOL]     return instantUTC; [EOL] }
public long convertLocalToUTC(long instantLocal, boolean strict) { [EOL]     int offsetLocal = getOffset(instantLocal); [EOL]     int offset = getOffset(instantLocal - offsetLocal); [EOL]     if (offsetLocal != offset) { [EOL]         if (strict || offsetLocal < 0) { [EOL]             long nextLocal = nextTransition(instantLocal - offsetLocal); [EOL]             if (nextLocal == (instantLocal - offsetLocal)) { [EOL]                 nextLocal = Long.MAX_VALUE; [EOL]             } [EOL]             long nextAdjusted = nextTransition(instantLocal - offset); [EOL]             if (nextAdjusted == (instantLocal - offset)) { [EOL]                 nextAdjusted = Long.MAX_VALUE; [EOL]             } [EOL]             if (nextLocal != nextAdjusted) { [EOL]                 if (strict) { [EOL]                     throw new IllegalInstantException(instantLocal, getID()); [EOL]                 } else { [EOL]                     offset = offsetLocal; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     long instantUTC = instantLocal - offset; [EOL]     if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) { [EOL]         throw new ArithmeticException("Subtracting time zone offset caused overflow"); [EOL]     } [EOL]     return instantUTC; [EOL] }
public long convertLocalToUTC(long instantLocal, boolean strict) { [EOL]     int offsetLocal = getOffset(instantLocal); [EOL]     int offset = getOffset(instantLocal - offsetLocal); [EOL]     if (offsetLocal != offset) { [EOL]         if (strict || offsetLocal < 0) { [EOL]             long nextLocal = nextTransition(instantLocal - offsetLocal); [EOL]             if (nextLocal == (instantLocal - offsetLocal)) { [EOL]                 nextLocal = Long.MAX_VALUE; [EOL]             } [EOL]             long nextAdjusted = nextTransition(instantLocal - offset); [EOL]             if (nextAdjusted == (instantLocal - offset)) { [EOL]                 nextAdjusted = Long.MAX_VALUE; [EOL]             } [EOL]             if (nextLocal != nextAdjusted) { [EOL]                 if (strict) { [EOL]                     throw new IllegalInstantException(instantLocal, getID()); [EOL]                 } else { [EOL]                     offset = offsetLocal; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     long instantUTC = instantLocal - offset; [EOL]     if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) { [EOL]         throw new ArithmeticException("Subtracting time zone offset caused overflow"); [EOL]     } [EOL]     return instantUTC; [EOL] }
public long convertLocalToUTC(long instantLocal, boolean strict) { [EOL]     int offsetLocal = getOffset(instantLocal); [EOL]     int offset = getOffset(instantLocal - offsetLocal); [EOL]     if (offsetLocal != offset) { [EOL]         if (strict || offsetLocal < 0) { [EOL]             long nextLocal = nextTransition(instantLocal - offsetLocal); [EOL]             if (nextLocal == (instantLocal - offsetLocal)) { [EOL]                 nextLocal = Long.MAX_VALUE; [EOL]             } [EOL]             long nextAdjusted = nextTransition(instantLocal - offset); [EOL]             if (nextAdjusted == (instantLocal - offset)) { [EOL]                 nextAdjusted = Long.MAX_VALUE; [EOL]             } [EOL]             if (nextLocal != nextAdjusted) { [EOL]                 if (strict) { [EOL]                     throw new IllegalInstantException(instantLocal, getID()); [EOL]                 } else { [EOL]                     offset = offsetLocal; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     long instantUTC = instantLocal - offset; [EOL]     if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) { [EOL]         throw new ArithmeticException("Subtracting time zone offset caused overflow"); [EOL]     } [EOL]     return instantUTC; [EOL] }
public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) { [EOL]     if (newZone == null) { [EOL]         newZone = DateTimeZone.getDefault(); [EOL]     } [EOL]     if (newZone == this) { [EOL]         return oldInstant; [EOL]     } [EOL]     long instantLocal = convertUTCToLocal(oldInstant); [EOL]     return newZone.convertLocalToUTC(instantLocal, false, oldInstant); [EOL] }
public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) { [EOL]     if (newZone == null) { [EOL]         newZone = DateTimeZone.getDefault(); [EOL]     } [EOL]     if (newZone == this) { [EOL]         return oldInstant; [EOL]     } [EOL]     long instantLocal = convertUTCToLocal(oldInstant); [EOL]     return newZone.convertLocalToUTC(instantLocal, false, oldInstant); [EOL] }
public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) { [EOL]     if (newZone == null) { [EOL]         newZone = DateTimeZone.getDefault(); [EOL]     } [EOL]     if (newZone == this) { [EOL]         return oldInstant; [EOL]     } [EOL]     long instantLocal = convertUTCToLocal(oldInstant); [EOL]     return newZone.convertLocalToUTC(instantLocal, false, oldInstant); [EOL] }
protected Object writeReplace() throws ObjectStreamException { [EOL]     return new Stub(iID); [EOL] }
Stub(String id) { [EOL]     iID = id; [EOL] }
private void writeObject(ObjectOutputStream out) throws IOException { [EOL]     out.writeUTF(iID); [EOL] }
private void readObject(ObjectInputStream in) throws IOException { [EOL]     iID = in.readUTF(); [EOL] }
private Object readResolve() throws ObjectStreamException { [EOL]     return forID(iID); [EOL] }
public int getMinimumDaysInFirstWeek() { [EOL]     return iMinDaysInFirstWeek; [EOL] }
public String toString() { [EOL]     StringBuilder sb = new StringBuilder(60); [EOL]     String name = getClass().getName(); [EOL]     int index = name.lastIndexOf('.'); [EOL]     if (index >= 0) { [EOL]         name = name.substring(index + 1); [EOL]     } [EOL]     sb.append(name); [EOL]     sb.append('['); [EOL]     DateTimeZone zone = getZone(); [EOL]     if (zone != null) { [EOL]         sb.append(zone.getID()); [EOL]     } [EOL]     if (getMinimumDaysInFirstWeek() != 4) { [EOL]         sb.append(",mdfw="); [EOL]         sb.append(getMinimumDaysInFirstWeek()); [EOL]     } [EOL]     sb.append(']'); [EOL]     return sb.toString(); [EOL] }
public String toString() { [EOL]     StringBuilder sb = new StringBuilder(60); [EOL]     String name = getClass().getName(); [EOL]     int index = name.lastIndexOf('.'); [EOL]     if (index >= 0) { [EOL]         name = name.substring(index + 1); [EOL]     } [EOL]     sb.append(name); [EOL]     sb.append('['); [EOL]     DateTimeZone zone = getZone(); [EOL]     if (zone != null) { [EOL]         sb.append(zone.getID()); [EOL]     } [EOL]     if (getMinimumDaysInFirstWeek() != 4) { [EOL]         sb.append(",mdfw="); [EOL]         sb.append(getMinimumDaysInFirstWeek()); [EOL]     } [EOL]     sb.append(']'); [EOL]     return sb.toString(); [EOL] }
public String toString() { [EOL]     StringBuilder sb = new StringBuilder(60); [EOL]     String name = getClass().getName(); [EOL]     int index = name.lastIndexOf('.'); [EOL]     if (index >= 0) { [EOL]         name = name.substring(index + 1); [EOL]     } [EOL]     sb.append(name); [EOL]     sb.append('['); [EOL]     DateTimeZone zone = getZone(); [EOL]     if (zone != null) { [EOL]         sb.append(zone.getID()); [EOL]     } [EOL]     if (getMinimumDaysInFirstWeek() != 4) { [EOL]         sb.append(",mdfw="); [EOL]         sb.append(getMinimumDaysInFirstWeek()); [EOL]     } [EOL]     sb.append(']'); [EOL]     return sb.toString(); [EOL] }
int getDaysInYearMax() { [EOL]     return 366; [EOL] }
int getDaysInYear(int year) { [EOL]     return isLeapYear(year) ? 366 : 365; [EOL] }
int getDaysInYear(int year) { [EOL]     return isLeapYear(year) ? 366 : 365; [EOL] }
int getYear(long instant) { [EOL]     long unitMillis = getAverageMillisPerYearDividedByTwo(); [EOL]     long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo(); [EOL]     if (i2 < 0) { [EOL]         i2 = i2 - unitMillis + 1; [EOL]     } [EOL]     int year = (int) (i2 / unitMillis); [EOL]     long yearStart = getYearMillis(year); [EOL]     long diff = instant - yearStart; [EOL]     if (diff < 0) { [EOL]         year--; [EOL]     } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) { [EOL]         long oneYear; [EOL]         if (isLeapYear(year)) { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L; [EOL]         } else { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L; [EOL]         } [EOL]         yearStart += oneYear; [EOL]         if (yearStart <= instant) { [EOL]             year++; [EOL]         } [EOL]     } [EOL]     return year; [EOL] }
int getYear(long instant) { [EOL]     long unitMillis = getAverageMillisPerYearDividedByTwo(); [EOL]     long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo(); [EOL]     if (i2 < 0) { [EOL]         i2 = i2 - unitMillis + 1; [EOL]     } [EOL]     int year = (int) (i2 / unitMillis); [EOL]     long yearStart = getYearMillis(year); [EOL]     long diff = instant - yearStart; [EOL]     if (diff < 0) { [EOL]         year--; [EOL]     } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) { [EOL]         long oneYear; [EOL]         if (isLeapYear(year)) { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L; [EOL]         } else { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L; [EOL]         } [EOL]         yearStart += oneYear; [EOL]         if (yearStart <= instant) { [EOL]             year++; [EOL]         } [EOL]     } [EOL]     return year; [EOL] }
int getYear(long instant) { [EOL]     long unitMillis = getAverageMillisPerYearDividedByTwo(); [EOL]     long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo(); [EOL]     if (i2 < 0) { [EOL]         i2 = i2 - unitMillis + 1; [EOL]     } [EOL]     int year = (int) (i2 / unitMillis); [EOL]     long yearStart = getYearMillis(year); [EOL]     long diff = instant - yearStart; [EOL]     if (diff < 0) { [EOL]         year--; [EOL]     } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) { [EOL]         long oneYear; [EOL]         if (isLeapYear(year)) { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L; [EOL]         } else { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L; [EOL]         } [EOL]         yearStart += oneYear; [EOL]         if (yearStart <= instant) { [EOL]             year++; [EOL]         } [EOL]     } [EOL]     return year; [EOL] }
int getYear(long instant) { [EOL]     long unitMillis = getAverageMillisPerYearDividedByTwo(); [EOL]     long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo(); [EOL]     if (i2 < 0) { [EOL]         i2 = i2 - unitMillis + 1; [EOL]     } [EOL]     int year = (int) (i2 / unitMillis); [EOL]     long yearStart = getYearMillis(year); [EOL]     long diff = instant - yearStart; [EOL]     if (diff < 0) { [EOL]         year--; [EOL]     } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) { [EOL]         long oneYear; [EOL]         if (isLeapYear(year)) { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L; [EOL]         } else { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L; [EOL]         } [EOL]         yearStart += oneYear; [EOL]         if (yearStart <= instant) { [EOL]             year++; [EOL]         } [EOL]     } [EOL]     return year; [EOL] }
int getYear(long instant) { [EOL]     long unitMillis = getAverageMillisPerYearDividedByTwo(); [EOL]     long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo(); [EOL]     if (i2 < 0) { [EOL]         i2 = i2 - unitMillis + 1; [EOL]     } [EOL]     int year = (int) (i2 / unitMillis); [EOL]     long yearStart = getYearMillis(year); [EOL]     long diff = instant - yearStart; [EOL]     if (diff < 0) { [EOL]         year--; [EOL]     } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) { [EOL]         long oneYear; [EOL]         if (isLeapYear(year)) { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L; [EOL]         } else { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L; [EOL]         } [EOL]         yearStart += oneYear; [EOL]         if (yearStart <= instant) { [EOL]             year++; [EOL]         } [EOL]     } [EOL]     return year; [EOL] }
int getYear(long instant) { [EOL]     long unitMillis = getAverageMillisPerYearDividedByTwo(); [EOL]     long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo(); [EOL]     if (i2 < 0) { [EOL]         i2 = i2 - unitMillis + 1; [EOL]     } [EOL]     int year = (int) (i2 / unitMillis); [EOL]     long yearStart = getYearMillis(year); [EOL]     long diff = instant - yearStart; [EOL]     if (diff < 0) { [EOL]         year--; [EOL]     } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) { [EOL]         long oneYear; [EOL]         if (isLeapYear(year)) { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L; [EOL]         } else { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L; [EOL]         } [EOL]         yearStart += oneYear; [EOL]         if (yearStart <= instant) { [EOL]             year++; [EOL]         } [EOL]     } [EOL]     return year; [EOL] }
int getYear(long instant) { [EOL]     long unitMillis = getAverageMillisPerYearDividedByTwo(); [EOL]     long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo(); [EOL]     if (i2 < 0) { [EOL]         i2 = i2 - unitMillis + 1; [EOL]     } [EOL]     int year = (int) (i2 / unitMillis); [EOL]     long yearStart = getYearMillis(year); [EOL]     long diff = instant - yearStart; [EOL]     if (diff < 0) { [EOL]         year--; [EOL]     } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) { [EOL]         long oneYear; [EOL]         if (isLeapYear(year)) { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L; [EOL]         } else { [EOL]             oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L; [EOL]         } [EOL]         yearStart += oneYear; [EOL]         if (yearStart <= instant) { [EOL]             year++; [EOL]         } [EOL]     } [EOL]     return year; [EOL] }
int getWeekyear(long instant) { [EOL]     int year = getYear(instant); [EOL]     int week = getWeekOfWeekyear(instant, year); [EOL]     if (week == 1) { [EOL]         return getYear(instant + DateTimeConstants.MILLIS_PER_WEEK); [EOL]     } else if (week > 51) { [EOL]         return getYear(instant - (2 * DateTimeConstants.MILLIS_PER_WEEK)); [EOL]     } else { [EOL]         return year; [EOL]     } [EOL] }
int getWeekyear(long instant) { [EOL]     int year = getYear(instant); [EOL]     int week = getWeekOfWeekyear(instant, year); [EOL]     if (week == 1) { [EOL]         return getYear(instant + DateTimeConstants.MILLIS_PER_WEEK); [EOL]     } else if (week > 51) { [EOL]         return getYear(instant - (2 * DateTimeConstants.MILLIS_PER_WEEK)); [EOL]     } else { [EOL]         return year; [EOL]     } [EOL] }
int getWeekyear(long instant) { [EOL]     int year = getYear(instant); [EOL]     int week = getWeekOfWeekyear(instant, year); [EOL]     if (week == 1) { [EOL]         return getYear(instant + DateTimeConstants.MILLIS_PER_WEEK); [EOL]     } else if (week > 51) { [EOL]         return getYear(instant - (2 * DateTimeConstants.MILLIS_PER_WEEK)); [EOL]     } else { [EOL]         return year; [EOL]     } [EOL] }
int getWeekOfWeekyear(long instant, int year) { [EOL]     long firstWeekMillis1 = getFirstWeekOfYearMillis(year); [EOL]     if (instant < firstWeekMillis1) { [EOL]         return getWeeksInYear(year - 1); [EOL]     } [EOL]     long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1); [EOL]     if (instant >= firstWeekMillis2) { [EOL]         return 1; [EOL]     } [EOL]     return (int) ((instant - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1; [EOL] }
int getWeekOfWeekyear(long instant, int year) { [EOL]     long firstWeekMillis1 = getFirstWeekOfYearMillis(year); [EOL]     if (instant < firstWeekMillis1) { [EOL]         return getWeeksInYear(year - 1); [EOL]     } [EOL]     long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1); [EOL]     if (instant >= firstWeekMillis2) { [EOL]         return 1; [EOL]     } [EOL]     return (int) ((instant - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1; [EOL] }
int getWeekOfWeekyear(long instant, int year) { [EOL]     long firstWeekMillis1 = getFirstWeekOfYearMillis(year); [EOL]     if (instant < firstWeekMillis1) { [EOL]         return getWeeksInYear(year - 1); [EOL]     } [EOL]     long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1); [EOL]     if (instant >= firstWeekMillis2) { [EOL]         return 1; [EOL]     } [EOL]     return (int) ((instant - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1; [EOL] }
int getWeekOfWeekyear(long instant, int year) { [EOL]     long firstWeekMillis1 = getFirstWeekOfYearMillis(year); [EOL]     if (instant < firstWeekMillis1) { [EOL]         return getWeeksInYear(year - 1); [EOL]     } [EOL]     long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1); [EOL]     if (instant >= firstWeekMillis2) { [EOL]         return 1; [EOL]     } [EOL]     return (int) ((instant - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1; [EOL] }
int getDaysInMonthMax() { [EOL]     return 31; [EOL] }
int getDaysInMonthMax(long instant) { [EOL]     int thisYear = getYear(instant); [EOL]     int thisMonth = getMonthOfYear(instant, thisYear); [EOL]     return getDaysInYearMonth(thisYear, thisMonth); [EOL] }
int getDaysInMonthMax(long instant) { [EOL]     int thisYear = getYear(instant); [EOL]     int thisMonth = getMonthOfYear(instant, thisYear); [EOL]     return getDaysInYearMonth(thisYear, thisMonth); [EOL] }
int getDaysInMonthMax(long instant) { [EOL]     int thisYear = getYear(instant); [EOL]     int thisMonth = getMonthOfYear(instant, thisYear); [EOL]     return getDaysInYearMonth(thisYear, thisMonth); [EOL] }
int getDaysInMonthMax(long instant) { [EOL]     int thisYear = getYear(instant); [EOL]     int thisMonth = getMonthOfYear(instant, thisYear); [EOL]     return getDaysInYearMonth(thisYear, thisMonth); [EOL] }
int getDaysInMonthMaxForSet(long instant, int value) { [EOL]     return getDaysInMonthMax(instant); [EOL] }
protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type) { [EOL]     super(); [EOL]     if (start == null || end == null) { [EOL]         throw new IllegalArgumentException("ReadablePartial objects must not be null"); [EOL]     } [EOL]     if (start instanceof BaseLocal && end instanceof BaseLocal && start.getClass() == end.getClass()) { [EOL]         type = checkPeriodType(type); [EOL]         long startMillis = ((BaseLocal) start).getLocalMillis(); [EOL]         long endMillis = ((BaseLocal) end).getLocalMillis(); [EOL]         Chronology chrono = start.getChronology(); [EOL]         chrono = DateTimeUtils.getChronology(chrono); [EOL]         iType = type; [EOL]         iValues = chrono.get(this, startMillis, endMillis); [EOL]     } else { [EOL]         if (start.size() != end.size()) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]         } [EOL]         for (int i = 0, isize = start.size(); i < isize; i++) { [EOL]             if (start.getFieldType(i) != end.getFieldType(i)) { [EOL]                 throw new IllegalArgumentException("ReadablePartial objects must have the same set of fields"); [EOL]             } [EOL]         } [EOL]         if (DateTimeUtils.isContiguous(start) == false) { [EOL]             throw new IllegalArgumentException("ReadablePartial objects must be contiguous"); [EOL]         } [EOL]         iType = checkPeriodType(type); [EOL]         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC(); [EOL]         iValues = chrono.get(this, chrono.set(start, 0L), chrono.set(end, 0L)); [EOL]     } [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
private void checkAndUpdate(DurationFieldType type, int[] values, int newValue) { [EOL]     int index = indexOf(type); [EOL]     if (index == -1) { [EOL]         if (newValue != 0) { [EOL]             throw new IllegalArgumentException("Period does not support field '" + type.getName() + "'"); [EOL]         } [EOL]     } else { [EOL]         values[index] = newValue; [EOL]     } [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected void addFieldInto(int[] values, DurationFieldType field, int value) { [EOL]     int index = indexOf(field); [EOL]     if (index == -1) { [EOL]         if (value != 0 || field == null) { [EOL]             throw new IllegalArgumentException("Period does not support field '" + field + "'"); [EOL]         } [EOL]     } else { [EOL]         values[index] = FieldUtils.safeAdd(values[index], value); [EOL]     } [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected void addPeriod(ReadablePeriod period) { [EOL]     if (period != null) { [EOL]         setValues(addPeriodInto(getValues(), period)); [EOL]     } [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected int[] addPeriodInto(int[] values, ReadablePeriod period) { [EOL]     for (int i = 0, isize = period.size(); i < isize; i++) { [EOL]         DurationFieldType type = period.getFieldType(i); [EOL]         int value = period.getValue(i); [EOL]         if (value != 0) { [EOL]             int index = indexOf(type); [EOL]             if (index == -1) { [EOL]                 throw new IllegalArgumentException("Period does not support field '" + type.getName() + "'"); [EOL]             } else { [EOL]                 values[index] = FieldUtils.safeAdd(getValue(index), value); [EOL]             } [EOL]         } [EOL]     } [EOL]     return values; [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
protected void setValues(int[] values) { [EOL]     System.arraycopy(values, 0, iValues, 0, iValues.length); [EOL] } protected BasePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type); protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono); protected BasePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type); protected BasePeriod(ReadablePartial start, ReadablePartial end, PeriodType type); protected BasePeriod(ReadableInstant startInstant, ReadableDuration duration, PeriodType type); protected BasePeriod(ReadableDuration duration, ReadableInstant endInstant, PeriodType type); protected BasePeriod(long duration); protected BasePeriod(long duration, PeriodType type, Chronology chrono); protected BasePeriod(Object period, PeriodType type, Chronology chrono); protected BasePeriod(int[] values, PeriodType type); public int getValue(int index); public PeriodType getPeriodType(); protected PeriodType checkPeriodType(PeriodType type); public PeriodType getPeriodType(); public int getValue(int index); public Duration toDurationFrom(ReadableInstant startInstant); public Duration toDurationTo(ReadableInstant endInstant); private void checkAndUpdate(DurationFieldType type, int[] values, int newValue); protected void setPeriod(ReadablePeriod period); private void setPeriodInternal(ReadablePeriod period); protected void setPeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); private int[] setPeriodInternal(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis); protected void setField(DurationFieldType field, int value); protected void setFieldInto(int[] values, DurationFieldType field, int value); protected void addField(DurationFieldType field, int value); protected void addFieldInto(int[] values, DurationFieldType field, int value); protected void mergePeriod(ReadablePeriod period); protected int[] mergePeriodInto(int[] values, ReadablePeriod period); protected void addPeriod(ReadablePeriod period); protected int[] addPeriodInto(int[] values, ReadablePeriod period); protected void setValue(int index, int value); protected void setValues(int[] values); long serialVersionUID=Optional[-2110953284060001145L]; ReadablePeriod DUMMY_PERIOD=Optional[new AbstractPeriod() {; ;     public int getValue(int index) {;         return 0;;     }; ;     public PeriodType getPeriodType() {;         return PeriodType.time();;     }; }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
public static DateTimeFormatter forFields(Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     if (fields == null || fields.size() == 0) { [EOL]         throw new IllegalArgumentException("The fields must not be null or empty"); [EOL]     } [EOL]     Set<DateTimeFieldType> workingFields = new HashSet<DateTimeFieldType>(fields); [EOL]     int inputSize = workingFields.size(); [EOL]     boolean reducedPrec = false; [EOL]     DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder(); [EOL]     if (workingFields.contains(DateTimeFieldType.monthOfYear())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfYear())) { [EOL]         reducedPrec = dateByOrdinal(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.weekOfWeekyear())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfMonth())) { [EOL]         reducedPrec = dateByMonth(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.contains(DateTimeFieldType.dayOfWeek())) { [EOL]         reducedPrec = dateByWeek(bld, workingFields, extended, strictISO); [EOL]     } else if (workingFields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         reducedPrec = true; [EOL]     } else if (workingFields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         reducedPrec = true; [EOL]     } [EOL]     boolean datePresent = (workingFields.size() < inputSize); [EOL]     time(bld, workingFields, extended, strictISO, reducedPrec, datePresent); [EOL]     if (bld.canBuildFormatter() == false) { [EOL]         throw new IllegalArgumentException("No valid format for fields: " + fields); [EOL]     } [EOL]     try { [EOL]         fields.retainAll(workingFields); [EOL]     } catch (UnsupportedOperationException ex) { [EOL]     } [EOL]     return bld.toFormatter(); [EOL] }
private static boolean dateByMonth(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendMonthOfYear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfMonth(2); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfMonth(2); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByMonth(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendMonthOfYear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfMonth(2); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfMonth(2); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByMonth(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendMonthOfYear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfMonth(2); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfMonth(2); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByMonth(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendMonthOfYear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfMonth(2); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfMonth(2); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByMonth(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendMonthOfYear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfMonth(2); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfMonth(2); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByMonth(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendMonthOfYear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfMonth(2); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfMonth(2); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByMonth(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendMonthOfYear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfMonth(2); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfMonth(2); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByMonth(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.year())) { [EOL]         bld.append(Constants.ye); [EOL]         if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendMonthOfYear(2); [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfMonth(2); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.monthOfYear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendMonthOfYear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfMonth(2); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfMonth())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfMonth(2); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByWeek(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendLiteral('W'); [EOL]             bld.appendWeekOfWeekyear(2); [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendLiteral('W'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendWeekOfWeekyear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfWeek(1); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfWeek(1); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByWeek(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendLiteral('W'); [EOL]             bld.appendWeekOfWeekyear(2); [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendLiteral('W'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendWeekOfWeekyear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfWeek(1); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfWeek(1); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByWeek(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendLiteral('W'); [EOL]             bld.appendWeekOfWeekyear(2); [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendLiteral('W'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendWeekOfWeekyear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfWeek(1); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfWeek(1); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByWeek(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendLiteral('W'); [EOL]             bld.appendWeekOfWeekyear(2); [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendLiteral('W'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendWeekOfWeekyear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfWeek(1); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfWeek(1); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByWeek(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendLiteral('W'); [EOL]             bld.appendWeekOfWeekyear(2); [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendLiteral('W'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendWeekOfWeekyear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfWeek(1); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfWeek(1); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByWeek(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendLiteral('W'); [EOL]             bld.appendWeekOfWeekyear(2); [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendLiteral('W'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendWeekOfWeekyear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfWeek(1); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfWeek(1); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByWeek(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendLiteral('W'); [EOL]             bld.appendWeekOfWeekyear(2); [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendLiteral('W'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendWeekOfWeekyear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfWeek(1); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfWeek(1); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static boolean dateByWeek(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO) { [EOL]     boolean reducedPrec = false; [EOL]     if (fields.remove(DateTimeFieldType.weekyear())) { [EOL]         bld.append(Constants.we); [EOL]         if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendLiteral('W'); [EOL]             bld.appendWeekOfWeekyear(2); [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } else { [EOL]             if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]                 checkNotStrictISO(fields, strictISO); [EOL]                 appendSeparator(bld, extended); [EOL]                 bld.appendLiteral('W'); [EOL]                 bld.appendLiteral('-'); [EOL]                 bld.appendDayOfWeek(1); [EOL]             } else { [EOL]                 reducedPrec = true; [EOL]             } [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.weekOfWeekyear())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendWeekOfWeekyear(2); [EOL]         if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]             appendSeparator(bld, extended); [EOL]             bld.appendDayOfWeek(1); [EOL]         } else { [EOL]             reducedPrec = true; [EOL]         } [EOL]     } else if (fields.remove(DateTimeFieldType.dayOfWeek())) { [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendLiteral('W'); [EOL]         bld.appendLiteral('-'); [EOL]         bld.appendDayOfWeek(1); [EOL]     } [EOL]     return reducedPrec; [EOL] }
private static void time(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO, boolean reducedPrec, boolean datePresent) { [EOL]     boolean hour = fields.remove(DateTimeFieldType.hourOfDay()); [EOL]     boolean minute = fields.remove(DateTimeFieldType.minuteOfHour()); [EOL]     boolean second = fields.remove(DateTimeFieldType.secondOfMinute()); [EOL]     boolean milli = fields.remove(DateTimeFieldType.millisOfSecond()); [EOL]     if (!hour && !minute && !second && !milli) { [EOL]         return; [EOL]     } [EOL]     if (hour || minute || second || milli) { [EOL]         if (strictISO && reducedPrec) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields); [EOL]         } [EOL]         if (datePresent) { [EOL]             bld.appendLiteral('T'); [EOL]         } [EOL]     } [EOL]     if (hour && minute && second || (hour && !second && !milli)) { [EOL]     } else { [EOL]         if (strictISO && datePresent) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields); [EOL]         } [EOL]         if (!hour && (minute && second || (minute && !milli) || second)) { [EOL]         } else { [EOL]             if (strictISO) { [EOL]                 throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (hour) { [EOL]         bld.appendHourOfDay(2); [EOL]     } else if (minute || second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && hour && minute) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (minute) { [EOL]         bld.appendMinuteOfHour(2); [EOL]     } else if (second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && minute && second) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (second) { [EOL]         bld.appendSecondOfMinute(2); [EOL]     } else if (milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (milli) { [EOL]         bld.appendLiteral('.'); [EOL]         bld.appendMillisOfSecond(3); [EOL]     } [EOL] }
private static void time(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO, boolean reducedPrec, boolean datePresent) { [EOL]     boolean hour = fields.remove(DateTimeFieldType.hourOfDay()); [EOL]     boolean minute = fields.remove(DateTimeFieldType.minuteOfHour()); [EOL]     boolean second = fields.remove(DateTimeFieldType.secondOfMinute()); [EOL]     boolean milli = fields.remove(DateTimeFieldType.millisOfSecond()); [EOL]     if (!hour && !minute && !second && !milli) { [EOL]         return; [EOL]     } [EOL]     if (hour || minute || second || milli) { [EOL]         if (strictISO && reducedPrec) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields); [EOL]         } [EOL]         if (datePresent) { [EOL]             bld.appendLiteral('T'); [EOL]         } [EOL]     } [EOL]     if (hour && minute && second || (hour && !second && !milli)) { [EOL]     } else { [EOL]         if (strictISO && datePresent) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields); [EOL]         } [EOL]         if (!hour && (minute && second || (minute && !milli) || second)) { [EOL]         } else { [EOL]             if (strictISO) { [EOL]                 throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (hour) { [EOL]         bld.appendHourOfDay(2); [EOL]     } else if (minute || second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && hour && minute) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (minute) { [EOL]         bld.appendMinuteOfHour(2); [EOL]     } else if (second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && minute && second) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (second) { [EOL]         bld.appendSecondOfMinute(2); [EOL]     } else if (milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (milli) { [EOL]         bld.appendLiteral('.'); [EOL]         bld.appendMillisOfSecond(3); [EOL]     } [EOL] }
private static void time(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO, boolean reducedPrec, boolean datePresent) { [EOL]     boolean hour = fields.remove(DateTimeFieldType.hourOfDay()); [EOL]     boolean minute = fields.remove(DateTimeFieldType.minuteOfHour()); [EOL]     boolean second = fields.remove(DateTimeFieldType.secondOfMinute()); [EOL]     boolean milli = fields.remove(DateTimeFieldType.millisOfSecond()); [EOL]     if (!hour && !minute && !second && !milli) { [EOL]         return; [EOL]     } [EOL]     if (hour || minute || second || milli) { [EOL]         if (strictISO && reducedPrec) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields); [EOL]         } [EOL]         if (datePresent) { [EOL]             bld.appendLiteral('T'); [EOL]         } [EOL]     } [EOL]     if (hour && minute && second || (hour && !second && !milli)) { [EOL]     } else { [EOL]         if (strictISO && datePresent) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields); [EOL]         } [EOL]         if (!hour && (minute && second || (minute && !milli) || second)) { [EOL]         } else { [EOL]             if (strictISO) { [EOL]                 throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (hour) { [EOL]         bld.appendHourOfDay(2); [EOL]     } else if (minute || second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && hour && minute) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (minute) { [EOL]         bld.appendMinuteOfHour(2); [EOL]     } else if (second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && minute && second) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (second) { [EOL]         bld.appendSecondOfMinute(2); [EOL]     } else if (milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (milli) { [EOL]         bld.appendLiteral('.'); [EOL]         bld.appendMillisOfSecond(3); [EOL]     } [EOL] }
private static void time(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO, boolean reducedPrec, boolean datePresent) { [EOL]     boolean hour = fields.remove(DateTimeFieldType.hourOfDay()); [EOL]     boolean minute = fields.remove(DateTimeFieldType.minuteOfHour()); [EOL]     boolean second = fields.remove(DateTimeFieldType.secondOfMinute()); [EOL]     boolean milli = fields.remove(DateTimeFieldType.millisOfSecond()); [EOL]     if (!hour && !minute && !second && !milli) { [EOL]         return; [EOL]     } [EOL]     if (hour || minute || second || milli) { [EOL]         if (strictISO && reducedPrec) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields); [EOL]         } [EOL]         if (datePresent) { [EOL]             bld.appendLiteral('T'); [EOL]         } [EOL]     } [EOL]     if (hour && minute && second || (hour && !second && !milli)) { [EOL]     } else { [EOL]         if (strictISO && datePresent) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields); [EOL]         } [EOL]         if (!hour && (minute && second || (minute && !milli) || second)) { [EOL]         } else { [EOL]             if (strictISO) { [EOL]                 throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (hour) { [EOL]         bld.appendHourOfDay(2); [EOL]     } else if (minute || second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && hour && minute) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (minute) { [EOL]         bld.appendMinuteOfHour(2); [EOL]     } else if (second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && minute && second) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (second) { [EOL]         bld.appendSecondOfMinute(2); [EOL]     } else if (milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (milli) { [EOL]         bld.appendLiteral('.'); [EOL]         bld.appendMillisOfSecond(3); [EOL]     } [EOL] }
private static void time(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO, boolean reducedPrec, boolean datePresent) { [EOL]     boolean hour = fields.remove(DateTimeFieldType.hourOfDay()); [EOL]     boolean minute = fields.remove(DateTimeFieldType.minuteOfHour()); [EOL]     boolean second = fields.remove(DateTimeFieldType.secondOfMinute()); [EOL]     boolean milli = fields.remove(DateTimeFieldType.millisOfSecond()); [EOL]     if (!hour && !minute && !second && !milli) { [EOL]         return; [EOL]     } [EOL]     if (hour || minute || second || milli) { [EOL]         if (strictISO && reducedPrec) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields); [EOL]         } [EOL]         if (datePresent) { [EOL]             bld.appendLiteral('T'); [EOL]         } [EOL]     } [EOL]     if (hour && minute && second || (hour && !second && !milli)) { [EOL]     } else { [EOL]         if (strictISO && datePresent) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields); [EOL]         } [EOL]         if (!hour && (minute && second || (minute && !milli) || second)) { [EOL]         } else { [EOL]             if (strictISO) { [EOL]                 throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (hour) { [EOL]         bld.appendHourOfDay(2); [EOL]     } else if (minute || second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && hour && minute) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (minute) { [EOL]         bld.appendMinuteOfHour(2); [EOL]     } else if (second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && minute && second) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (second) { [EOL]         bld.appendSecondOfMinute(2); [EOL]     } else if (milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (milli) { [EOL]         bld.appendLiteral('.'); [EOL]         bld.appendMillisOfSecond(3); [EOL]     } [EOL] }
private static void time(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO, boolean reducedPrec, boolean datePresent) { [EOL]     boolean hour = fields.remove(DateTimeFieldType.hourOfDay()); [EOL]     boolean minute = fields.remove(DateTimeFieldType.minuteOfHour()); [EOL]     boolean second = fields.remove(DateTimeFieldType.secondOfMinute()); [EOL]     boolean milli = fields.remove(DateTimeFieldType.millisOfSecond()); [EOL]     if (!hour && !minute && !second && !milli) { [EOL]         return; [EOL]     } [EOL]     if (hour || minute || second || milli) { [EOL]         if (strictISO && reducedPrec) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields); [EOL]         } [EOL]         if (datePresent) { [EOL]             bld.appendLiteral('T'); [EOL]         } [EOL]     } [EOL]     if (hour && minute && second || (hour && !second && !milli)) { [EOL]     } else { [EOL]         if (strictISO && datePresent) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields); [EOL]         } [EOL]         if (!hour && (minute && second || (minute && !milli) || second)) { [EOL]         } else { [EOL]             if (strictISO) { [EOL]                 throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (hour) { [EOL]         bld.appendHourOfDay(2); [EOL]     } else if (minute || second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && hour && minute) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (minute) { [EOL]         bld.appendMinuteOfHour(2); [EOL]     } else if (second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && minute && second) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (second) { [EOL]         bld.appendSecondOfMinute(2); [EOL]     } else if (milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (milli) { [EOL]         bld.appendLiteral('.'); [EOL]         bld.appendMillisOfSecond(3); [EOL]     } [EOL] }
private static void time(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO, boolean reducedPrec, boolean datePresent) { [EOL]     boolean hour = fields.remove(DateTimeFieldType.hourOfDay()); [EOL]     boolean minute = fields.remove(DateTimeFieldType.minuteOfHour()); [EOL]     boolean second = fields.remove(DateTimeFieldType.secondOfMinute()); [EOL]     boolean milli = fields.remove(DateTimeFieldType.millisOfSecond()); [EOL]     if (!hour && !minute && !second && !milli) { [EOL]         return; [EOL]     } [EOL]     if (hour || minute || second || milli) { [EOL]         if (strictISO && reducedPrec) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields); [EOL]         } [EOL]         if (datePresent) { [EOL]             bld.appendLiteral('T'); [EOL]         } [EOL]     } [EOL]     if (hour && minute && second || (hour && !second && !milli)) { [EOL]     } else { [EOL]         if (strictISO && datePresent) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields); [EOL]         } [EOL]         if (!hour && (minute && second || (minute && !milli) || second)) { [EOL]         } else { [EOL]             if (strictISO) { [EOL]                 throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (hour) { [EOL]         bld.appendHourOfDay(2); [EOL]     } else if (minute || second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && hour && minute) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (minute) { [EOL]         bld.appendMinuteOfHour(2); [EOL]     } else if (second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && minute && second) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (second) { [EOL]         bld.appendSecondOfMinute(2); [EOL]     } else if (milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (milli) { [EOL]         bld.appendLiteral('.'); [EOL]         bld.appendMillisOfSecond(3); [EOL]     } [EOL] }
private static void time(DateTimeFormatterBuilder bld, Collection<DateTimeFieldType> fields, boolean extended, boolean strictISO, boolean reducedPrec, boolean datePresent) { [EOL]     boolean hour = fields.remove(DateTimeFieldType.hourOfDay()); [EOL]     boolean minute = fields.remove(DateTimeFieldType.minuteOfHour()); [EOL]     boolean second = fields.remove(DateTimeFieldType.secondOfMinute()); [EOL]     boolean milli = fields.remove(DateTimeFieldType.millisOfSecond()); [EOL]     if (!hour && !minute && !second && !milli) { [EOL]         return; [EOL]     } [EOL]     if (hour || minute || second || milli) { [EOL]         if (strictISO && reducedPrec) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Date was reduced precision: " + fields); [EOL]         } [EOL]         if (datePresent) { [EOL]             bld.appendLiteral('T'); [EOL]         } [EOL]     } [EOL]     if (hour && minute && second || (hour && !second && !milli)) { [EOL]     } else { [EOL]         if (strictISO && datePresent) { [EOL]             throw new IllegalArgumentException("No valid ISO8601 format for fields because Time was truncated: " + fields); [EOL]         } [EOL]         if (!hour && (minute && second || (minute && !milli) || second)) { [EOL]         } else { [EOL]             if (strictISO) { [EOL]                 throw new IllegalArgumentException("No valid ISO8601 format for fields: " + fields); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (hour) { [EOL]         bld.appendHourOfDay(2); [EOL]     } else if (minute || second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && hour && minute) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (minute) { [EOL]         bld.appendMinuteOfHour(2); [EOL]     } else if (second || milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (extended && minute && second) { [EOL]         bld.appendLiteral(':'); [EOL]     } [EOL]     if (second) { [EOL]         bld.appendSecondOfMinute(2); [EOL]     } else if (milli) { [EOL]         bld.appendLiteral('-'); [EOL]     } [EOL]     if (milli) { [EOL]         bld.appendLiteral('.'); [EOL]         bld.appendMillisOfSecond(3); [EOL]     } [EOL] }
public static DateTimeFormatter date() { [EOL]     return yearMonthDay(); [EOL] }
public static DateTimeFormatter time() { [EOL]     return Constants.t; [EOL] }
public static DateTimeFormatter dateTime() { [EOL]     return Constants.dt; [EOL] }
public static DateTimeFormatter dateTimeNoMillis() { [EOL]     return Constants.dtx; [EOL] }
public static DateTimeFormatter ordinalDateTimeNoMillis() { [EOL]     return Constants.odtx; [EOL] }
public static DateTimeFormatter weekDate() { [EOL]     return Constants.wwd; [EOL] }
public static DateTimeFormatter basicTime() { [EOL]     return Constants.bt; [EOL] }
public static DateTimeFormatter hourMinute() { [EOL]     return Constants.hm; [EOL] }
public static DateTimeFormatter hourMinuteSecond() { [EOL]     return Constants.hms; [EOL] }
public static DateTimeFormatter hourMinuteSecondMillis() { [EOL]     return Constants.hmsl; [EOL] }
public static DateTimeFormatter hourMinuteSecondFraction() { [EOL]     return Constants.hmsf; [EOL] }
public static DateTimeFormatter dateHourMinute() { [EOL]     return Constants.dhm; [EOL] }
private static DateTimeFormatter dateParser() { [EOL]     if (dp == null) { [EOL]         DateTimeParser tOffset = new DateTimeFormatterBuilder().appendLiteral('T').append(offsetElement()).toParser(); [EOL]         return new DateTimeFormatterBuilder().append(dateElementParser()).appendOptional(tOffset).toFormatter(); [EOL]     } [EOL]     return dp; [EOL] }
private static DateTimeFormatter dateParser() { [EOL]     if (dp == null) { [EOL]         DateTimeParser tOffset = new DateTimeFormatterBuilder().appendLiteral('T').append(offsetElement()).toParser(); [EOL]         return new DateTimeFormatterBuilder().append(dateElementParser()).appendOptional(tOffset).toFormatter(); [EOL]     } [EOL]     return dp; [EOL] }
private static DateTimeFormatter localDateParser() { [EOL]     if (ldp == null) { [EOL]         return dateElementParser().withZoneUTC(); [EOL]     } [EOL]     return ldp; [EOL] }
private static DateTimeFormatter localDateParser() { [EOL]     if (ldp == null) { [EOL]         return dateElementParser().withZoneUTC(); [EOL]     } [EOL]     return ldp; [EOL] }
private static DateTimeFormatter dateElementParser() { [EOL]     if (dpe == null) { [EOL]         return new DateTimeFormatterBuilder().append(null, new DateTimeParser[] { new DateTimeFormatterBuilder().append(yearElement()).appendOptional(new DateTimeFormatterBuilder().append(monthElement()).appendOptional(dayOfMonthElement().getParser()).toParser()).toParser(), new DateTimeFormatterBuilder().append(weekyearElement()).append(weekElement()).appendOptional(dayOfWeekElement().getParser()).toParser(), new DateTimeFormatterBuilder().append(yearElement()).append(dayOfYearElement()).toParser() }).toFormatter(); [EOL]     } [EOL]     return dpe; [EOL] }
private static DateTimeFormatter dateElementParser() { [EOL]     if (dpe == null) { [EOL]         return new DateTimeFormatterBuilder().append(null, new DateTimeParser[] { new DateTimeFormatterBuilder().append(yearElement()).appendOptional(new DateTimeFormatterBuilder().append(monthElement()).appendOptional(dayOfMonthElement().getParser()).toParser()).toParser(), new DateTimeFormatterBuilder().append(weekyearElement()).append(weekElement()).appendOptional(dayOfWeekElement().getParser()).toParser(), new DateTimeFormatterBuilder().append(yearElement()).append(dayOfYearElement()).toParser() }).toFormatter(); [EOL]     } [EOL]     return dpe; [EOL] }
private static DateTimeFormatter timeParser() { [EOL]     if (tp == null) { [EOL]         return new DateTimeFormatterBuilder().appendOptional(literalTElement().getParser()).append(timeElementParser()).appendOptional(offsetElement().getParser()).toFormatter(); [EOL]     } [EOL]     return tp; [EOL] }
private static DateTimeFormatter localTimeParser() { [EOL]     if (ltp == null) { [EOL]         return new DateTimeFormatterBuilder().appendOptional(literalTElement().getParser()).append(timeElementParser()).toFormatter().withZoneUTC(); [EOL]     } [EOL]     return ltp; [EOL] }
private static DateTimeFormatter localTimeParser() { [EOL]     if (ltp == null) { [EOL]         return new DateTimeFormatterBuilder().appendOptional(literalTElement().getParser()).append(timeElementParser()).toFormatter().withZoneUTC(); [EOL]     } [EOL]     return ltp; [EOL] }
private static DateTimeFormatter timeElementParser() { [EOL]     if (tpe == null) { [EOL]         DateTimeParser decimalPoint = new DateTimeFormatterBuilder().append(null, new DateTimeParser[] { new DateTimeFormatterBuilder().appendLiteral('.').toParser(), new DateTimeFormatterBuilder().appendLiteral(',').toParser() }).toParser(); [EOL]         return new DateTimeFormatterBuilder().append(hourElement()).append(null, new DateTimeParser[] { new DateTimeFormatterBuilder().append(minuteElement()).append(null, new DateTimeParser[] { new DateTimeFormatterBuilder().append(secondElement()).appendOptional(new DateTimeFormatterBuilder().append(decimalPoint).appendFractionOfSecond(1, 9).toParser()).toParser(), new DateTimeFormatterBuilder().append(decimalPoint).appendFractionOfMinute(1, 9).toParser(), null }).toParser(), new DateTimeFormatterBuilder().append(decimalPoint).appendFractionOfHour(1, 9).toParser(), null }).toFormatter(); [EOL]     } [EOL]     return tpe; [EOL] }
private static DateTimeFormatter dateTimeParser() { [EOL]     if (dtp == null) { [EOL]         DateTimeParser time = new DateTimeFormatterBuilder().appendLiteral('T').append(timeElementParser()).appendOptional(offsetElement().getParser()).toParser(); [EOL]         return new DateTimeFormatterBuilder().append(null, new DateTimeParser[] { time, dateOptionalTimeParser().getParser() }).toFormatter(); [EOL]     } [EOL]     return dtp; [EOL] }
private static DateTimeFormatter dateOptionalTimeParser() { [EOL]     if (dotp == null) { [EOL]         DateTimeParser timeOrOffset = new DateTimeFormatterBuilder().appendLiteral('T').appendOptional(timeElementParser().getParser()).appendOptional(offsetElement().getParser()).toParser(); [EOL]         return new DateTimeFormatterBuilder().append(dateElementParser()).appendOptional(timeOrOffset).toFormatter(); [EOL]     } [EOL]     return dotp; [EOL] }
private static DateTimeFormatter localDateOptionalTimeParser() { [EOL]     if (ldotp == null) { [EOL]         DateTimeParser time = new DateTimeFormatterBuilder().appendLiteral('T').append(timeElementParser()).toParser(); [EOL]         return new DateTimeFormatterBuilder().append(dateElementParser()).appendOptional(time).toFormatter().withZoneUTC(); [EOL]     } [EOL]     return ldotp; [EOL] }
private static DateTimeFormatter time() { [EOL]     if (t == null) { [EOL]         return new DateTimeFormatterBuilder().append(hourMinuteSecondFraction()).append(offsetElement()).toFormatter(); [EOL]     } [EOL]     return t; [EOL] }
private static DateTimeFormatter timeNoMillis() { [EOL]     if (tx == null) { [EOL]         return new DateTimeFormatterBuilder().append(hourMinuteSecond()).append(offsetElement()).toFormatter(); [EOL]     } [EOL]     return tx; [EOL] }
private static DateTimeFormatter timeNoMillis() { [EOL]     if (tx == null) { [EOL]         return new DateTimeFormatterBuilder().append(hourMinuteSecond()).append(offsetElement()).toFormatter(); [EOL]     } [EOL]     return tx; [EOL] }
private static DateTimeFormatter tTime() { [EOL]     if (tt == null) { [EOL]         return new DateTimeFormatterBuilder().append(literalTElement()).append(time()).toFormatter(); [EOL]     } [EOL]     return tt; [EOL] }
private static DateTimeFormatter tTimeNoMillis() { [EOL]     if (ttx == null) { [EOL]         return new DateTimeFormatterBuilder().append(literalTElement()).append(timeNoMillis()).toFormatter(); [EOL]     } [EOL]     return ttx; [EOL] }
private static DateTimeFormatter tTimeNoMillis() { [EOL]     if (ttx == null) { [EOL]         return new DateTimeFormatterBuilder().append(literalTElement()).append(timeNoMillis()).toFormatter(); [EOL]     } [EOL]     return ttx; [EOL] }
private static DateTimeFormatter dateTime() { [EOL]     if (dt == null) { [EOL]         return new DateTimeFormatterBuilder().append(date()).append(tTime()).toFormatter(); [EOL]     } [EOL]     return dt; [EOL] }
private static DateTimeFormatter dateTime() { [EOL]     if (dt == null) { [EOL]         return new DateTimeFormatterBuilder().append(date()).append(tTime()).toFormatter(); [EOL]     } [EOL]     return dt; [EOL] }
private static DateTimeFormatter dateTimeNoMillis() { [EOL]     if (dtx == null) { [EOL]         return new DateTimeFormatterBuilder().append(date()).append(tTimeNoMillis()).toFormatter(); [EOL]     } [EOL]     return dtx; [EOL] }
private static DateTimeFormatter dateTimeNoMillis() { [EOL]     if (dtx == null) { [EOL]         return new DateTimeFormatterBuilder().append(date()).append(tTimeNoMillis()).toFormatter(); [EOL]     } [EOL]     return dtx; [EOL] }
private static DateTimeFormatter ordinalDate() { [EOL]     if (od == null) { [EOL]         return new DateTimeFormatterBuilder().append(yearElement()).append(dayOfYearElement()).toFormatter(); [EOL]     } [EOL]     return od; [EOL] }
private static DateTimeFormatter ordinalDateTime() { [EOL]     if (odt == null) { [EOL]         return new DateTimeFormatterBuilder().append(ordinalDate()).append(tTime()).toFormatter(); [EOL]     } [EOL]     return odt; [EOL] }
private static DateTimeFormatter ordinalDateTimeNoMillis() { [EOL]     if (odtx == null) { [EOL]         return new DateTimeFormatterBuilder().append(ordinalDate()).append(tTimeNoMillis()).toFormatter(); [EOL]     } [EOL]     return odtx; [EOL] }
private static DateTimeFormatter ordinalDateTimeNoMillis() { [EOL]     if (odtx == null) { [EOL]         return new DateTimeFormatterBuilder().append(ordinalDate()).append(tTimeNoMillis()).toFormatter(); [EOL]     } [EOL]     return odtx; [EOL] }
private static DateTimeFormatter weekDateTime() { [EOL]     if (wdt == null) { [EOL]         return new DateTimeFormatterBuilder().append(weekDate()).append(tTime()).toFormatter(); [EOL]     } [EOL]     return wdt; [EOL] }
private static DateTimeFormatter weekDateTime() { [EOL]     if (wdt == null) { [EOL]         return new DateTimeFormatterBuilder().append(weekDate()).append(tTime()).toFormatter(); [EOL]     } [EOL]     return wdt; [EOL] }
private static DateTimeFormatter weekDateTimeNoMillis() { [EOL]     if (wdtx == null) { [EOL]         return new DateTimeFormatterBuilder().append(weekDate()).append(tTimeNoMillis()).toFormatter(); [EOL]     } [EOL]     return wdtx; [EOL] }
private static DateTimeFormatter weekDateTimeNoMillis() { [EOL]     if (wdtx == null) { [EOL]         return new DateTimeFormatterBuilder().append(weekDate()).append(tTimeNoMillis()).toFormatter(); [EOL]     } [EOL]     return wdtx; [EOL] }
private static DateTimeFormatter basicDate() { [EOL]     if (bd == null) { [EOL]         return new DateTimeFormatterBuilder().appendYear(4, 4).appendFixedDecimal(DateTimeFieldType.monthOfYear(), 2).appendFixedDecimal(DateTimeFieldType.dayOfMonth(), 2).toFormatter(); [EOL]     } [EOL]     return bd; [EOL] }
private static DateTimeFormatter basicDate() { [EOL]     if (bd == null) { [EOL]         return new DateTimeFormatterBuilder().appendYear(4, 4).appendFixedDecimal(DateTimeFieldType.monthOfYear(), 2).appendFixedDecimal(DateTimeFieldType.dayOfMonth(), 2).toFormatter(); [EOL]     } [EOL]     return bd; [EOL] }
private static DateTimeFormatter basicTime() { [EOL]     if (bt == null) { [EOL]         return new DateTimeFormatterBuilder().appendFixedDecimal(DateTimeFieldType.hourOfDay(), 2).appendFixedDecimal(DateTimeFieldType.minuteOfHour(), 2).appendFixedDecimal(DateTimeFieldType.secondOfMinute(), 2).appendLiteral('.').appendFractionOfSecond(3, 9).appendTimeZoneOffset("Z", false, 2, 2).toFormatter(); [EOL]     } [EOL]     return bt; [EOL] }
private static DateTimeFormatter basicTimeNoMillis() { [EOL]     if (btx == null) { [EOL]         return new DateTimeFormatterBuilder().appendFixedDecimal(DateTimeFieldType.hourOfDay(), 2).appendFixedDecimal(DateTimeFieldType.minuteOfHour(), 2).appendFixedDecimal(DateTimeFieldType.secondOfMinute(), 2).appendTimeZoneOffset("Z", false, 2, 2).toFormatter(); [EOL]     } [EOL]     return btx; [EOL] }
private static DateTimeFormatter basicTTime() { [EOL]     if (btt == null) { [EOL]         return new DateTimeFormatterBuilder().append(literalTElement()).append(basicTime()).toFormatter(); [EOL]     } [EOL]     return btt; [EOL] }
private static DateTimeFormatter basicTTime() { [EOL]     if (btt == null) { [EOL]         return new DateTimeFormatterBuilder().append(literalTElement()).append(basicTime()).toFormatter(); [EOL]     } [EOL]     return btt; [EOL] }
private static DateTimeFormatter basicTTimeNoMillis() { [EOL]     if (bttx == null) { [EOL]         return new DateTimeFormatterBuilder().append(literalTElement()).append(basicTimeNoMillis()).toFormatter(); [EOL]     } [EOL]     return bttx; [EOL] }
private static DateTimeFormatter basicDateTime() { [EOL]     if (bdt == null) { [EOL]         return new DateTimeFormatterBuilder().append(basicDate()).append(basicTTime()).toFormatter(); [EOL]     } [EOL]     return bdt; [EOL] }
private static DateTimeFormatter basicDateTime() { [EOL]     if (bdt == null) { [EOL]         return new DateTimeFormatterBuilder().append(basicDate()).append(basicTTime()).toFormatter(); [EOL]     } [EOL]     return bdt; [EOL] }
private static DateTimeFormatter basicDateTimeNoMillis() { [EOL]     if (bdtx == null) { [EOL]         return new DateTimeFormatterBuilder().append(basicDate()).append(basicTTimeNoMillis()).toFormatter(); [EOL]     } [EOL]     return bdtx; [EOL] }
private static DateTimeFormatter basicOrdinalDate() { [EOL]     if (bod == null) { [EOL]         return new DateTimeFormatterBuilder().appendYear(4, 4).appendFixedDecimal(DateTimeFieldType.dayOfYear(), 3).toFormatter(); [EOL]     } [EOL]     return bod; [EOL] }
private static DateTimeFormatter basicOrdinalDate() { [EOL]     if (bod == null) { [EOL]         return new DateTimeFormatterBuilder().appendYear(4, 4).appendFixedDecimal(DateTimeFieldType.dayOfYear(), 3).toFormatter(); [EOL]     } [EOL]     return bod; [EOL] }
private static DateTimeFormatter basicOrdinalDateTime() { [EOL]     if (bodt == null) { [EOL]         return new DateTimeFormatterBuilder().append(basicOrdinalDate()).append(basicTTime()).toFormatter(); [EOL]     } [EOL]     return bodt; [EOL] }
private static DateTimeFormatter basicOrdinalDateTime() { [EOL]     if (bodt == null) { [EOL]         return new DateTimeFormatterBuilder().append(basicOrdinalDate()).append(basicTTime()).toFormatter(); [EOL]     } [EOL]     return bodt; [EOL] }
private static DateTimeFormatter basicOrdinalDateTimeNoMillis() { [EOL]     if (bodtx == null) { [EOL]         return new DateTimeFormatterBuilder().append(basicOrdinalDate()).append(basicTTimeNoMillis()).toFormatter(); [EOL]     } [EOL]     return bodtx; [EOL] }
private static DateTimeFormatter basicOrdinalDateTimeNoMillis() { [EOL]     if (bodtx == null) { [EOL]         return new DateTimeFormatterBuilder().append(basicOrdinalDate()).append(basicTTimeNoMillis()).toFormatter(); [EOL]     } [EOL]     return bodtx; [EOL] }
private static DateTimeFormatter basicWeekDate() { [EOL]     if (bwd == null) { [EOL]         return new DateTimeFormatterBuilder().appendWeekyear(4, 4).appendLiteral('W').appendFixedDecimal(DateTimeFieldType.weekOfWeekyear(), 2).appendFixedDecimal(DateTimeFieldType.dayOfWeek(), 1).toFormatter(); [EOL]     } [EOL]     return bwd; [EOL] }
private static DateTimeFormatter basicWeekDateTime() { [EOL]     if (bwdt == null) { [EOL]         return new DateTimeFormatterBuilder().append(basicWeekDate()).append(basicTTime()).toFormatter(); [EOL]     } [EOL]     return bwdt; [EOL] }
private static DateTimeFormatter basicWeekDateTime() { [EOL]     if (bwdt == null) { [EOL]         return new DateTimeFormatterBuilder().append(basicWeekDate()).append(basicTTime()).toFormatter(); [EOL]     } [EOL]     return bwdt; [EOL] }
private static DateTimeFormatter basicWeekDateTimeNoMillis() { [EOL]     if (bwdtx == null) { [EOL]         return new DateTimeFormatterBuilder().append(basicWeekDate()).append(basicTTimeNoMillis()).toFormatter(); [EOL]     } [EOL]     return bwdtx; [EOL] }
private static DateTimeFormatter basicWeekDateTimeNoMillis() { [EOL]     if (bwdtx == null) { [EOL]         return new DateTimeFormatterBuilder().append(basicWeekDate()).append(basicTTimeNoMillis()).toFormatter(); [EOL]     } [EOL]     return bwdtx; [EOL] }
private static DateTimeFormatter yearMonth() { [EOL]     if (ym == null) { [EOL]         return new DateTimeFormatterBuilder().append(yearElement()).append(monthElement()).toFormatter(); [EOL]     } [EOL]     return ym; [EOL] }
private static DateTimeFormatter yearMonthDay() { [EOL]     if (ymd == null) { [EOL]         return new DateTimeFormatterBuilder().append(yearElement()).append(monthElement()).append(dayOfMonthElement()).toFormatter(); [EOL]     } [EOL]     return ymd; [EOL] }
private static DateTimeFormatter yearMonthDay() { [EOL]     if (ymd == null) { [EOL]         return new DateTimeFormatterBuilder().append(yearElement()).append(monthElement()).append(dayOfMonthElement()).toFormatter(); [EOL]     } [EOL]     return ymd; [EOL] }
private static DateTimeFormatter weekyearWeek() { [EOL]     if (ww == null) { [EOL]         return new DateTimeFormatterBuilder().append(weekyearElement()).append(weekElement()).toFormatter(); [EOL]     } [EOL]     return ww; [EOL] }
private static DateTimeFormatter weekyearWeekDay() { [EOL]     if (wwd == null) { [EOL]         return new DateTimeFormatterBuilder().append(weekyearElement()).append(weekElement()).append(dayOfWeekElement()).toFormatter(); [EOL]     } [EOL]     return wwd; [EOL] }
private static DateTimeFormatter weekyearWeekDay() { [EOL]     if (wwd == null) { [EOL]         return new DateTimeFormatterBuilder().append(weekyearElement()).append(weekElement()).append(dayOfWeekElement()).toFormatter(); [EOL]     } [EOL]     return wwd; [EOL] }
private static DateTimeFormatter hourMinute() { [EOL]     if (hm == null) { [EOL]         return new DateTimeFormatterBuilder().append(hourElement()).append(minuteElement()).toFormatter(); [EOL]     } [EOL]     return hm; [EOL] }
private static DateTimeFormatter hourMinuteSecond() { [EOL]     if (hms == null) { [EOL]         return new DateTimeFormatterBuilder().append(hourElement()).append(minuteElement()).append(secondElement()).toFormatter(); [EOL]     } [EOL]     return hms; [EOL] }
private static DateTimeFormatter hourMinuteSecondMillis() { [EOL]     if (hmsl == null) { [EOL]         return new DateTimeFormatterBuilder().append(hourElement()).append(minuteElement()).append(secondElement()).appendLiteral('.').appendFractionOfSecond(3, 3).toFormatter(); [EOL]     } [EOL]     return hmsl; [EOL] }
private static DateTimeFormatter hourMinuteSecondFraction() { [EOL]     if (hmsf == null) { [EOL]         return new DateTimeFormatterBuilder().append(hourElement()).append(minuteElement()).append(secondElement()).append(fractionElement()).toFormatter(); [EOL]     } [EOL]     return hmsf; [EOL] }
private static DateTimeFormatter dateHour() { [EOL]     if (dh == null) { [EOL]         return new DateTimeFormatterBuilder().append(date()).append(literalTElement()).append(hour()).toFormatter(); [EOL]     } [EOL]     return dh; [EOL] }
private static DateTimeFormatter dateHour() { [EOL]     if (dh == null) { [EOL]         return new DateTimeFormatterBuilder().append(date()).append(literalTElement()).append(hour()).toFormatter(); [EOL]     } [EOL]     return dh; [EOL] }
private static DateTimeFormatter dateHourMinute() { [EOL]     if (dhm == null) { [EOL]         return new DateTimeFormatterBuilder().append(date()).append(literalTElement()).append(hourMinute()).toFormatter(); [EOL]     } [EOL]     return dhm; [EOL] }
private static DateTimeFormatter dateHourMinuteSecond() { [EOL]     if (dhms == null) { [EOL]         return new DateTimeFormatterBuilder().append(date()).append(literalTElement()).append(hourMinuteSecond()).toFormatter(); [EOL]     } [EOL]     return dhms; [EOL] }
private static DateTimeFormatter dateHourMinuteSecond() { [EOL]     if (dhms == null) { [EOL]         return new DateTimeFormatterBuilder().append(date()).append(literalTElement()).append(hourMinuteSecond()).toFormatter(); [EOL]     } [EOL]     return dhms; [EOL] }
private static DateTimeFormatter dateHourMinuteSecondMillis() { [EOL]     if (dhmsl == null) { [EOL]         return new DateTimeFormatterBuilder().append(date()).append(literalTElement()).append(hourMinuteSecondMillis()).toFormatter(); [EOL]     } [EOL]     return dhmsl; [EOL] }
private static DateTimeFormatter dateHourMinuteSecondFraction() { [EOL]     if (dhmsf == null) { [EOL]         return new DateTimeFormatterBuilder().append(date()).append(literalTElement()).append(hourMinuteSecondFraction()).toFormatter(); [EOL]     } [EOL]     return dhmsf; [EOL] }
private static DateTimeFormatter yearElement() { [EOL]     if (ye == null) { [EOL]         return new DateTimeFormatterBuilder().appendYear(4, 9).toFormatter(); [EOL]     } [EOL]     return ye; [EOL] }
private static DateTimeFormatter monthElement() { [EOL]     if (mye == null) { [EOL]         return new DateTimeFormatterBuilder().appendLiteral('-').appendMonthOfYear(2).toFormatter(); [EOL]     } [EOL]     return mye; [EOL] }
private static DateTimeFormatter dayOfMonthElement() { [EOL]     if (dme == null) { [EOL]         return new DateTimeFormatterBuilder().appendLiteral('-').appendDayOfMonth(2).toFormatter(); [EOL]     } [EOL]     return dme; [EOL] }
private static DateTimeFormatter weekyearElement() { [EOL]     if (we == null) { [EOL]         return new DateTimeFormatterBuilder().appendWeekyear(4, 9).toFormatter(); [EOL]     } [EOL]     return we; [EOL] }
private static DateTimeFormatter weekyearElement() { [EOL]     if (we == null) { [EOL]         return new DateTimeFormatterBuilder().appendWeekyear(4, 9).toFormatter(); [EOL]     } [EOL]     return we; [EOL] }
private static DateTimeFormatter weekElement() { [EOL]     if (wwe == null) { [EOL]         return new DateTimeFormatterBuilder().appendLiteral("-W").appendWeekOfWeekyear(2).toFormatter(); [EOL]     } [EOL]     return wwe; [EOL] }
private static DateTimeFormatter dayOfWeekElement() { [EOL]     if (dwe == null) { [EOL]         return new DateTimeFormatterBuilder().appendLiteral('-').appendDayOfWeek(1).toFormatter(); [EOL]     } [EOL]     return dwe; [EOL] }
private static DateTimeFormatter dayOfWeekElement() { [EOL]     if (dwe == null) { [EOL]         return new DateTimeFormatterBuilder().appendLiteral('-').appendDayOfWeek(1).toFormatter(); [EOL]     } [EOL]     return dwe; [EOL] }
private static DateTimeFormatter dayOfYearElement() { [EOL]     if (dye == null) { [EOL]         return new DateTimeFormatterBuilder().appendLiteral('-').appendDayOfYear(3).toFormatter(); [EOL]     } [EOL]     return dye; [EOL] }
private static DateTimeFormatter literalTElement() { [EOL]     if (lte == null) { [EOL]         return new DateTimeFormatterBuilder().appendLiteral('T').toFormatter(); [EOL]     } [EOL]     return lte; [EOL] }
private static DateTimeFormatter literalTElement() { [EOL]     if (lte == null) { [EOL]         return new DateTimeFormatterBuilder().appendLiteral('T').toFormatter(); [EOL]     } [EOL]     return lte; [EOL] }
private static DateTimeFormatter hourElement() { [EOL]     if (hde == null) { [EOL]         return new DateTimeFormatterBuilder().appendHourOfDay(2).toFormatter(); [EOL]     } [EOL]     return hde; [EOL] }
private static DateTimeFormatter hourElement() { [EOL]     if (hde == null) { [EOL]         return new DateTimeFormatterBuilder().appendHourOfDay(2).toFormatter(); [EOL]     } [EOL]     return hde; [EOL] }
private static DateTimeFormatter minuteElement() { [EOL]     if (mhe == null) { [EOL]         return new DateTimeFormatterBuilder().appendLiteral(':').appendMinuteOfHour(2).toFormatter(); [EOL]     } [EOL]     return mhe; [EOL] }
private static DateTimeFormatter minuteElement() { [EOL]     if (mhe == null) { [EOL]         return new DateTimeFormatterBuilder().appendLiteral(':').appendMinuteOfHour(2).toFormatter(); [EOL]     } [EOL]     return mhe; [EOL] }
private static DateTimeFormatter secondElement() { [EOL]     if (sme == null) { [EOL]         return new DateTimeFormatterBuilder().appendLiteral(':').appendSecondOfMinute(2).toFormatter(); [EOL]     } [EOL]     return sme; [EOL] }
private static DateTimeFormatter secondElement() { [EOL]     if (sme == null) { [EOL]         return new DateTimeFormatterBuilder().appendLiteral(':').appendSecondOfMinute(2).toFormatter(); [EOL]     } [EOL]     return sme; [EOL] }
private static DateTimeFormatter fractionElement() { [EOL]     if (fse == null) { [EOL]         return new DateTimeFormatterBuilder().appendLiteral('.').appendFractionOfSecond(3, 9).toFormatter(); [EOL]     } [EOL]     return fse; [EOL] }
private static DateTimeFormatter fractionElement() { [EOL]     if (fse == null) { [EOL]         return new DateTimeFormatterBuilder().appendLiteral('.').appendFractionOfSecond(3, 9).toFormatter(); [EOL]     } [EOL]     return fse; [EOL] }
private static DateTimeFormatter offsetElement() { [EOL]     if (ze == null) { [EOL]         return new DateTimeFormatterBuilder().appendTimeZoneOffset("Z", true, 2, 4).toFormatter(); [EOL]     } [EOL]     return ze; [EOL] }
public static Minutes minutesIn(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         return Minutes.ZERO; [EOL]     } [EOL]     int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.minutes()); [EOL]     return Minutes.minutes(amount); [EOL] }
public static Minutes minutesIn(ReadableInterval interval) { [EOL]     if (interval == null) { [EOL]         return Minutes.ZERO; [EOL]     } [EOL]     int amount = BaseSingleFieldPeriod.between(interval.getStart(), interval.getEnd(), DurationFieldType.minutes()); [EOL]     return Minutes.minutes(amount); [EOL] }
public PeriodType getPeriodType() { [EOL]     return PeriodType.minutes(); [EOL] }
public Duration toStandardDuration() { [EOL]     long minutes = getValue(); [EOL]     return new Duration(minutes * DateTimeConstants.MILLIS_PER_MINUTE); [EOL] }
public Duration toStandardDuration() { [EOL]     long minutes = getValue(); [EOL]     return new Duration(minutes * DateTimeConstants.MILLIS_PER_MINUTE); [EOL] }
public Duration toStandardDuration() { [EOL]     long minutes = getValue(); [EOL]     return new Duration(minutes * DateTimeConstants.MILLIS_PER_MINUTE); [EOL] }
public Minutes dividedBy(int divisor) { [EOL]     if (divisor == 1) { [EOL]         return this; [EOL]     } [EOL]     return Minutes.minutes(getValue() / divisor); [EOL] }
public Minutes dividedBy(int divisor) { [EOL]     if (divisor == 1) { [EOL]         return this; [EOL]     } [EOL]     return Minutes.minutes(getValue() / divisor); [EOL] }
public Minutes negated() { [EOL]     return Minutes.minutes(FieldUtils.safeNegate(getValue())); [EOL] }
public Minutes negated() { [EOL]     return Minutes.minutes(FieldUtils.safeNegate(getValue())); [EOL] }
public Minutes negated() { [EOL]     return Minutes.minutes(FieldUtils.safeNegate(getValue())); [EOL] }
public static GregorianChronology getInstance() { [EOL]     return getInstance(DateTimeZone.getDefault(), 4); [EOL] }
public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     GregorianChronology chrono; [EOL]     synchronized (cCache) { [EOL]         GregorianChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new GregorianChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new GregorianChronology(null, null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new GregorianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     GregorianChronology chrono; [EOL]     synchronized (cCache) { [EOL]         GregorianChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new GregorianChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new GregorianChronology(null, null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new GregorianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     GregorianChronology chrono; [EOL]     synchronized (cCache) { [EOL]         GregorianChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new GregorianChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new GregorianChronology(null, null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new GregorianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     GregorianChronology chrono; [EOL]     synchronized (cCache) { [EOL]         GregorianChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new GregorianChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new GregorianChronology(null, null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new GregorianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     GregorianChronology chrono; [EOL]     synchronized (cCache) { [EOL]         GregorianChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new GregorianChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new GregorianChronology(null, null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new GregorianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) { [EOL]     if (zone == null) { [EOL]         zone = DateTimeZone.getDefault(); [EOL]     } [EOL]     GregorianChronology chrono; [EOL]     synchronized (cCache) { [EOL]         GregorianChronology[] chronos = cCache.get(zone); [EOL]         if (chronos == null) { [EOL]             chronos = new GregorianChronology[7]; [EOL]             cCache.put(zone, chronos); [EOL]         } [EOL]         try { [EOL]             chrono = chronos[minDaysInFirstWeek - 1]; [EOL]         } catch (ArrayIndexOutOfBoundsException e) { [EOL]             throw new IllegalArgumentException("Invalid min days in first week: " + minDaysInFirstWeek); [EOL]         } [EOL]         if (chrono == null) { [EOL]             if (zone == DateTimeZone.UTC) { [EOL]                 chrono = new GregorianChronology(null, null, minDaysInFirstWeek); [EOL]             } else { [EOL]                 chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek); [EOL]                 chrono = new GregorianChronology(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek); [EOL]             } [EOL]             chronos[minDaysInFirstWeek - 1] = chrono; [EOL]         } [EOL]     } [EOL]     return chrono; [EOL] }
boolean isLeapYear(int year) { [EOL]     return ((year & 3) == 0) && ((year % 100) != 0 || (year % 400) == 0); [EOL] }
boolean isLeapYear(int year) { [EOL]     return ((year & 3) == 0) && ((year % 100) != 0 || (year % 400) == 0); [EOL] }
boolean isLeapYear(int year) { [EOL]     return ((year & 3) == 0) && ((year % 100) != 0 || (year % 400) == 0); [EOL] }
boolean isLeapYear(int year) { [EOL]     return ((year & 3) == 0) && ((year % 100) != 0 || (year % 400) == 0); [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     int leapYears = year / 100; [EOL]     if (year < 0) { [EOL]         leapYears = ((year + 3) >> 2) - leapYears + ((leapYears + 3) >> 2) - 1; [EOL]     } else { [EOL]         leapYears = (year >> 2) - leapYears + (leapYears >> 2); [EOL]         if (isLeapYear(year)) { [EOL]             leapYears--; [EOL]         } [EOL]     } [EOL]     return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     int leapYears = year / 100; [EOL]     if (year < 0) { [EOL]         leapYears = ((year + 3) >> 2) - leapYears + ((leapYears + 3) >> 2) - 1; [EOL]     } else { [EOL]         leapYears = (year >> 2) - leapYears + (leapYears >> 2); [EOL]         if (isLeapYear(year)) { [EOL]             leapYears--; [EOL]         } [EOL]     } [EOL]     return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     int leapYears = year / 100; [EOL]     if (year < 0) { [EOL]         leapYears = ((year + 3) >> 2) - leapYears + ((leapYears + 3) >> 2) - 1; [EOL]     } else { [EOL]         leapYears = (year >> 2) - leapYears + (leapYears >> 2); [EOL]         if (isLeapYear(year)) { [EOL]             leapYears--; [EOL]         } [EOL]     } [EOL]     return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     int leapYears = year / 100; [EOL]     if (year < 0) { [EOL]         leapYears = ((year + 3) >> 2) - leapYears + ((leapYears + 3) >> 2) - 1; [EOL]     } else { [EOL]         leapYears = (year >> 2) - leapYears + (leapYears >> 2); [EOL]         if (isLeapYear(year)) { [EOL]             leapYears--; [EOL]         } [EOL]     } [EOL]     return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     int leapYears = year / 100; [EOL]     if (year < 0) { [EOL]         leapYears = ((year + 3) >> 2) - leapYears + ((leapYears + 3) >> 2) - 1; [EOL]     } else { [EOL]         leapYears = (year >> 2) - leapYears + (leapYears >> 2); [EOL]         if (isLeapYear(year)) { [EOL]             leapYears--; [EOL]         } [EOL]     } [EOL]     return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY; [EOL] }
long calculateFirstDayOfYearMillis(int year) { [EOL]     int leapYears = year / 100; [EOL]     if (year < 0) { [EOL]         leapYears = ((year + 3) >> 2) - leapYears + ((leapYears + 3) >> 2) - 1; [EOL]     } else { [EOL]         leapYears = (year >> 2) - leapYears + (leapYears >> 2); [EOL]         if (isLeapYear(year)) { [EOL]             leapYears--; [EOL]         } [EOL]     } [EOL]     return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY; [EOL] }
int getMinYear() { [EOL]     return MIN_YEAR; [EOL] }
int getMaxYear() { [EOL]     return MAX_YEAR; [EOL] }
long getAverageMillisPerYearDividedByTwo() { [EOL]     return MILLIS_PER_YEAR / 2; [EOL] }
long getApproxMillisAtEpochDividedByTwo() { [EOL]     return (1970L * MILLIS_PER_YEAR) / 2; [EOL] }
public BaseDateTime(Object instant, DateTimeZone zone) { [EOL]     super(); [EOL]     InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant); [EOL]     Chronology chrono = checkChronology(converter.getChronology(instant, zone)); [EOL]     iChronology = chrono; [EOL]     iMillis = checkInstant(converter.getInstantMillis(instant, chrono), chrono); [EOL] }
public BaseDateTime(Object instant, DateTimeZone zone) { [EOL]     super(); [EOL]     InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant); [EOL]     Chronology chrono = checkChronology(converter.getChronology(instant, zone)); [EOL]     iChronology = chrono; [EOL]     iMillis = checkInstant(converter.getInstantMillis(instant, chrono), chrono); [EOL] }
public BaseDateTime(Object instant, DateTimeZone zone) { [EOL]     super(); [EOL]     InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant); [EOL]     Chronology chrono = checkChronology(converter.getChronology(instant, zone)); [EOL]     iChronology = chrono; [EOL]     iMillis = checkInstant(converter.getInstantMillis(instant, chrono), chrono); [EOL] }
public BaseDateTime(Object instant, DateTimeZone zone) { [EOL]     super(); [EOL]     InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant); [EOL]     Chronology chrono = checkChronology(converter.getChronology(instant, zone)); [EOL]     iChronology = chrono; [EOL]     iMillis = checkInstant(converter.getInstantMillis(instant, chrono), chrono); [EOL] }
public BaseDateTime(Object instant, DateTimeZone zone) { [EOL]     super(); [EOL]     InstantConverter converter = ConverterManager.getInstance().getInstantConverter(instant); [EOL]     Chronology chrono = checkChronology(converter.getChronology(instant, zone)); [EOL]     iChronology = chrono; [EOL]     iMillis = checkInstant(converter.getInstantMillis(instant, chrono), chrono); [EOL] }
protected void setChronology(Chronology chronology) { [EOL]     iChronology = checkChronology(chronology); [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof FixedDateTimeZone) { [EOL]         FixedDateTimeZone other = (FixedDateTimeZone) obj; [EOL]         return getID().equals(other.getID()) && iStandardOffset == other.iStandardOffset && iWallOffset == other.iWallOffset; [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof FixedDateTimeZone) { [EOL]         FixedDateTimeZone other = (FixedDateTimeZone) obj; [EOL]         return getID().equals(other.getID()) && iStandardOffset == other.iStandardOffset && iWallOffset == other.iWallOffset; [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof FixedDateTimeZone) { [EOL]         FixedDateTimeZone other = (FixedDateTimeZone) obj; [EOL]         return getID().equals(other.getID()) && iStandardOffset == other.iStandardOffset && iWallOffset == other.iWallOffset; [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof FixedDateTimeZone) { [EOL]         FixedDateTimeZone other = (FixedDateTimeZone) obj; [EOL]         return getID().equals(other.getID()) && iStandardOffset == other.iStandardOffset && iWallOffset == other.iWallOffset; [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof FixedDateTimeZone) { [EOL]         FixedDateTimeZone other = (FixedDateTimeZone) obj; [EOL]         return getID().equals(other.getID()) && iStandardOffset == other.iStandardOffset && iWallOffset == other.iWallOffset; [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof FixedDateTimeZone) { [EOL]         FixedDateTimeZone other = (FixedDateTimeZone) obj; [EOL]         return getID().equals(other.getID()) && iStandardOffset == other.iStandardOffset && iWallOffset == other.iWallOffset; [EOL]     } [EOL]     return false; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof FixedDateTimeZone) { [EOL]         FixedDateTimeZone other = (FixedDateTimeZone) obj; [EOL]         return getID().equals(other.getID()) && iStandardOffset == other.iStandardOffset && iWallOffset == other.iWallOffset; [EOL]     } [EOL]     return false; [EOL] }
public int getDifference(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return getField().getDifference(getMillis(), DateTimeUtils.currentTimeMillis()); [EOL]     } [EOL]     return getField().getDifference(getMillis(), instant.getMillis()); [EOL] }
public int getDifference(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return getField().getDifference(getMillis(), DateTimeUtils.currentTimeMillis()); [EOL]     } [EOL]     return getField().getDifference(getMillis(), instant.getMillis()); [EOL] }
public long getDifferenceAsLong(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return getField().getDifferenceAsLong(getMillis(), DateTimeUtils.currentTimeMillis()); [EOL]     } [EOL]     return getField().getDifferenceAsLong(getMillis(), instant.getMillis()); [EOL] }
public long getDifferenceAsLong(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return getField().getDifferenceAsLong(getMillis(), DateTimeUtils.currentTimeMillis()); [EOL]     } [EOL]     return getField().getDifferenceAsLong(getMillis(), instant.getMillis()); [EOL] }
private UnsupportedDateTimeField(DateTimeFieldType type, DurationField durationField) { [EOL]     if (type == null || durationField == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     iType = type; [EOL]     iDurationField = durationField; [EOL] }
private UnsupportedDateTimeField(DateTimeFieldType type, DurationField durationField) { [EOL]     if (type == null || durationField == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     iType = type; [EOL]     iDurationField = durationField; [EOL] }
private UnsupportedDateTimeField(DateTimeFieldType type, DurationField durationField) { [EOL]     if (type == null || durationField == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     iType = type; [EOL]     iDurationField = durationField; [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof ZonedChronology == false) { [EOL]         return false; [EOL]     } [EOL]     ZonedChronology chrono = (ZonedChronology) obj; [EOL]     return getBase().equals(chrono.getBase()) && getZone().equals(chrono.getZone()); [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof ZonedChronology == false) { [EOL]         return false; [EOL]     } [EOL]     ZonedChronology chrono = (ZonedChronology) obj; [EOL]     return getBase().equals(chrono.getBase()) && getZone().equals(chrono.getZone()); [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof ZonedChronology == false) { [EOL]         return false; [EOL]     } [EOL]     ZonedChronology chrono = (ZonedChronology) obj; [EOL]     return getBase().equals(chrono.getBase()) && getZone().equals(chrono.getZone()); [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof ZonedChronology == false) { [EOL]         return false; [EOL]     } [EOL]     ZonedChronology chrono = (ZonedChronology) obj; [EOL]     return getBase().equals(chrono.getBase()) && getZone().equals(chrono.getZone()); [EOL] }
public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof ZonedChronology == false) { [EOL]         return false; [EOL]     } [EOL]     ZonedChronology chrono = (ZonedChronology) obj; [EOL]     return getBase().equals(chrono.getBase()) && getZone().equals(chrono.getZone()); [EOL] }
public int hashCode() { [EOL]     return 326565 + getZone().hashCode() * 11 + getBase().hashCode() * 7; [EOL] }
public int hashCode() { [EOL]     return 326565 + getZone().hashCode() * 11 + getBase().hashCode() * 7; [EOL] }
public long addWrapField(long instant, int value) { [EOL]     if (iTimeField) { [EOL]         int offset = getOffsetToAdd(instant); [EOL]         long localInstant = iField.addWrapField(instant + offset, value); [EOL]         return localInstant - offset; [EOL]     } else { [EOL]         long localInstant = iZone.convertUTCToLocal(instant); [EOL]         localInstant = iField.addWrapField(localInstant, value); [EOL]         return iZone.convertLocalToUTC(localInstant, false, instant); [EOL]     } [EOL] }
public long addWrapField(long instant, int value) { [EOL]     if (iTimeField) { [EOL]         int offset = getOffsetToAdd(instant); [EOL]         long localInstant = iField.addWrapField(instant + offset, value); [EOL]         return localInstant - offset; [EOL]     } else { [EOL]         long localInstant = iZone.convertUTCToLocal(instant); [EOL]         localInstant = iField.addWrapField(localInstant, value); [EOL]         return iZone.convertLocalToUTC(localInstant, false, instant); [EOL]     } [EOL] }
public int getDifference(long minuendInstant, long subtrahendInstant) { [EOL]     int offset = getOffsetToAdd(subtrahendInstant); [EOL]     return iField.getDifference(minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); [EOL] }
public int getDifference(long minuendInstant, long subtrahendInstant) { [EOL]     int offset = getOffsetToAdd(subtrahendInstant); [EOL]     return iField.getDifference(minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); [EOL] }
public int getDifference(long minuendInstant, long subtrahendInstant) { [EOL]     int offset = getOffsetToAdd(subtrahendInstant); [EOL]     return iField.getDifference(minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     int offset = getOffsetToAdd(subtrahendInstant); [EOL]     return iField.getDifferenceAsLong(minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     int offset = getOffsetToAdd(subtrahendInstant); [EOL]     return iField.getDifferenceAsLong(minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); [EOL] }
public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) { [EOL]     int offset = getOffsetToAdd(subtrahendInstant); [EOL]     return iField.getDifferenceAsLong(minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)), subtrahendInstant + offset); [EOL] }
public long roundCeiling(long instant) { [EOL]     if (iTimeField) { [EOL]         int offset = getOffsetToAdd(instant); [EOL]         instant = iField.roundCeiling(instant + offset); [EOL]         return instant - offset; [EOL]     } else { [EOL]         long localInstant = iZone.convertUTCToLocal(instant); [EOL]         localInstant = iField.roundCeiling(localInstant); [EOL]         return iZone.convertLocalToUTC(localInstant, false, instant); [EOL]     } [EOL] }
public long roundCeiling(long instant) { [EOL]     if (iTimeField) { [EOL]         int offset = getOffsetToAdd(instant); [EOL]         instant = iField.roundCeiling(instant + offset); [EOL]         return instant - offset; [EOL]     } else { [EOL]         long localInstant = iZone.convertUTCToLocal(instant); [EOL]         localInstant = iField.roundCeiling(localInstant); [EOL]         return iZone.convertLocalToUTC(localInstant, false, instant); [EOL]     } [EOL] }
public int getMaximumValue(long instant) { [EOL]     long localInstant = iZone.convertUTCToLocal(instant); [EOL]     return iField.getMaximumValue(localInstant); [EOL] }
public int getMaximumValue(ReadablePartial instant) { [EOL]     return iField.getMaximumValue(instant); [EOL] }
public int get(long instant) { [EOL]     return ERA_VALUE; [EOL] }
public String getAsShortText(int fieldValue, Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToShortText(fieldValue); [EOL] }
public String getAsShortText(int fieldValue, Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToShortText(fieldValue); [EOL] }
public String getAsShortText(int fieldValue, Locale locale) { [EOL]     return GJLocaleSymbols.forLocale(locale).dayOfWeekValueToShortText(fieldValue); [EOL] }
private static String createMessage(String fieldName, Number value, Number lowerBound, Number upperBound, String explain) { [EOL]     StringBuilder buf = new StringBuilder().append("Value ").append(value).append(" for ").append(fieldName).append(' '); [EOL]     if (lowerBound == null) { [EOL]         if (upperBound == null) { [EOL]             buf.append("is not supported"); [EOL]         } else { [EOL]             buf.append("must not be larger than ").append(upperBound); [EOL]         } [EOL]     } else if (upperBound == null) { [EOL]         buf.append("must not be smaller than ").append(lowerBound); [EOL]     } else { [EOL]         buf.append("must be in the range [").append(lowerBound).append(',').append(upperBound).append(']'); [EOL]     } [EOL]     if (explain != null) { [EOL]         buf.append(": ").append(explain); [EOL]     } [EOL]     return buf.toString(); [EOL] }
private static String createMessage(String fieldName, Number value, Number lowerBound, Number upperBound, String explain) { [EOL]     StringBuilder buf = new StringBuilder().append("Value ").append(value).append(" for ").append(fieldName).append(' '); [EOL]     if (lowerBound == null) { [EOL]         if (upperBound == null) { [EOL]             buf.append("is not supported"); [EOL]         } else { [EOL]             buf.append("must not be larger than ").append(upperBound); [EOL]         } [EOL]     } else if (upperBound == null) { [EOL]         buf.append("must not be smaller than ").append(lowerBound); [EOL]     } else { [EOL]         buf.append("must be in the range [").append(lowerBound).append(',').append(upperBound).append(']'); [EOL]     } [EOL]     if (explain != null) { [EOL]         buf.append(": ").append(explain); [EOL]     } [EOL]     return buf.toString(); [EOL] }
private static String createMessage(String fieldName, Number value, Number lowerBound, Number upperBound, String explain) { [EOL]     StringBuilder buf = new StringBuilder().append("Value ").append(value).append(" for ").append(fieldName).append(' '); [EOL]     if (lowerBound == null) { [EOL]         if (upperBound == null) { [EOL]             buf.append("is not supported"); [EOL]         } else { [EOL]             buf.append("must not be larger than ").append(upperBound); [EOL]         } [EOL]     } else if (upperBound == null) { [EOL]         buf.append("must not be smaller than ").append(lowerBound); [EOL]     } else { [EOL]         buf.append("must be in the range [").append(lowerBound).append(',').append(upperBound).append(']'); [EOL]     } [EOL]     if (explain != null) { [EOL]         buf.append(": ").append(explain); [EOL]     } [EOL]     return buf.toString(); [EOL] }
private static String createMessage(String fieldName, Number value, Number lowerBound, Number upperBound, String explain) { [EOL]     StringBuilder buf = new StringBuilder().append("Value ").append(value).append(" for ").append(fieldName).append(' '); [EOL]     if (lowerBound == null) { [EOL]         if (upperBound == null) { [EOL]             buf.append("is not supported"); [EOL]         } else { [EOL]             buf.append("must not be larger than ").append(upperBound); [EOL]         } [EOL]     } else if (upperBound == null) { [EOL]         buf.append("must not be smaller than ").append(lowerBound); [EOL]     } else { [EOL]         buf.append("must be in the range [").append(lowerBound).append(',').append(upperBound).append(']'); [EOL]     } [EOL]     if (explain != null) { [EOL]         buf.append(": ").append(explain); [EOL]     } [EOL]     return buf.toString(); [EOL] }
private static String createMessage(String fieldName, Number value, Number lowerBound, Number upperBound, String explain) { [EOL]     StringBuilder buf = new StringBuilder().append("Value ").append(value).append(" for ").append(fieldName).append(' '); [EOL]     if (lowerBound == null) { [EOL]         if (upperBound == null) { [EOL]             buf.append("is not supported"); [EOL]         } else { [EOL]             buf.append("must not be larger than ").append(upperBound); [EOL]         } [EOL]     } else if (upperBound == null) { [EOL]         buf.append("must not be smaller than ").append(lowerBound); [EOL]     } else { [EOL]         buf.append("must be in the range [").append(lowerBound).append(',').append(upperBound).append(']'); [EOL]     } [EOL]     if (explain != null) { [EOL]         buf.append(": ").append(explain); [EOL]     } [EOL]     return buf.toString(); [EOL] }
public IllegalFieldValueException(String fieldName, Number value, Number lowerBound, Number upperBound) { [EOL]     super(createMessage(fieldName, value, lowerBound, upperBound, null)); [EOL]     iDateTimeFieldType = null; [EOL]     iDurationFieldType = null; [EOL]     iFieldName = fieldName; [EOL]     iNumberValue = value; [EOL]     iStringValue = null; [EOL]     iLowerBound = lowerBound; [EOL]     iUpperBound = upperBound; [EOL]     iMessage = super.getMessage(); [EOL] }
public static LocalTime now(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         throw new NullPointerException("Zone must not be null"); [EOL]     } [EOL]     return new LocalTime(zone); [EOL] }
public static LocalTime now(DateTimeZone zone) { [EOL]     if (zone == null) { [EOL]         throw new NullPointerException("Zone must not be null"); [EOL]     } [EOL]     return new LocalTime(zone); [EOL] }
public static LocalTime fromMillisOfDay(long millisOfDay) { [EOL]     return fromMillisOfDay(millisOfDay, null); [EOL] }
public static LocalTime fromMillisOfDay(long millisOfDay) { [EOL]     return fromMillisOfDay(millisOfDay, null); [EOL] }
public static LocalTime fromMillisOfDay(long millisOfDay) { [EOL]     return fromMillisOfDay(millisOfDay, null); [EOL] }
public static LocalTime fromMillisOfDay(long millisOfDay, Chronology chrono) { [EOL]     chrono = DateTimeUtils.getChronology(chrono).withUTC(); [EOL]     return new LocalTime(millisOfDay, chrono); [EOL] }
public static LocalTime fromMillisOfDay(long millisOfDay, Chronology chrono) { [EOL]     chrono = DateTimeUtils.getChronology(chrono).withUTC(); [EOL]     return new LocalTime(millisOfDay, chrono); [EOL] }
public static LocalTime fromCalendarFields(Calendar calendar) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The calendar must not be null"); [EOL]     } [EOL]     return new LocalTime(calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND)); [EOL] }
public static LocalTime fromCalendarFields(Calendar calendar) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The calendar must not be null"); [EOL]     } [EOL]     return new LocalTime(calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND)); [EOL] }
public LocalTime() { [EOL]     this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance()); [EOL] }
public LocalTime(DateTimeZone zone) { [EOL]     this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone)); [EOL] }
public LocalTime(DateTimeZone zone) { [EOL]     this(DateTimeUtils.currentTimeMillis(), ISOChronology.getInstance(zone)); [EOL] }
public LocalTime(long instant) { [EOL]     this(instant, ISOChronology.getInstance()); [EOL] }
public LocalTime(long instant) { [EOL]     this(instant, ISOChronology.getInstance()); [EOL] }
public LocalTime(long instant, DateTimeZone zone) { [EOL]     this(instant, ISOChronology.getInstance(zone)); [EOL] }
public LocalTime(long instant, DateTimeZone zone) { [EOL]     this(instant, ISOChronology.getInstance(zone)); [EOL] }
public LocalTime(long instant, DateTimeZone zone) { [EOL]     this(instant, ISOChronology.getInstance(zone)); [EOL] }
private Object readResolve() { [EOL]     if (iChronology == null) { [EOL]         return new LocalTime(iLocalMillis, ISOChronology.getInstanceUTC()); [EOL]     } [EOL]     if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) { [EOL]         return new LocalTime(iLocalMillis, iChronology.withUTC()); [EOL]     } [EOL]     return this; [EOL] }
private Object readResolve() { [EOL]     if (iChronology == null) { [EOL]         return new LocalTime(iLocalMillis, ISOChronology.getInstanceUTC()); [EOL]     } [EOL]     if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) { [EOL]         return new LocalTime(iLocalMillis, iChronology.withUTC()); [EOL]     } [EOL]     return this; [EOL] }
private Object readResolve() { [EOL]     if (iChronology == null) { [EOL]         return new LocalTime(iLocalMillis, ISOChronology.getInstanceUTC()); [EOL]     } [EOL]     if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) { [EOL]         return new LocalTime(iLocalMillis, iChronology.withUTC()); [EOL]     } [EOL]     return this; [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case HOUR_OF_DAY: [EOL]             return chrono.hourOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chrono.minuteOfHour(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chrono.secondOfMinute(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chrono.millisOfSecond(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case HOUR_OF_DAY: [EOL]             return chrono.hourOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chrono.minuteOfHour(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chrono.secondOfMinute(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chrono.millisOfSecond(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case HOUR_OF_DAY: [EOL]             return chrono.hourOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chrono.minuteOfHour(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chrono.secondOfMinute(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chrono.millisOfSecond(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case HOUR_OF_DAY: [EOL]             return chrono.hourOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chrono.minuteOfHour(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chrono.secondOfMinute(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chrono.millisOfSecond(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
protected DateTimeField getField(int index, Chronology chrono) { [EOL]     switch(index) { [EOL]         case HOUR_OF_DAY: [EOL]             return chrono.hourOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chrono.minuteOfHour(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chrono.secondOfMinute(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chrono.millisOfSecond(); [EOL]         default: [EOL]             throw new IndexOutOfBoundsException("Invalid index: " + index); [EOL]     } [EOL] }
public int get(DateTimeFieldType fieldType) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     return fieldType.getField(getChronology()).get(getLocalMillis()); [EOL] }
public int get(DateTimeFieldType fieldType) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     return fieldType.getField(getChronology()).get(getLocalMillis()); [EOL] }
public int get(DateTimeFieldType fieldType) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     return fieldType.getField(getChronology()).get(getLocalMillis()); [EOL] }
public boolean isSupported(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     if (isSupported(type.getDurationType()) == false) { [EOL]         return false; [EOL]     } [EOL]     DurationFieldType range = type.getRangeDurationType(); [EOL]     return (isSupported(range) || range == DurationFieldType.days()); [EOL] }
public boolean isSupported(DurationFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     DurationField field = type.getField(getChronology()); [EOL]     if (TIME_DURATION_TYPES.contains(type) || field.getUnitMillis() < getChronology().days().getUnitMillis()) { [EOL]         return field.isSupported(); [EOL]     } [EOL]     return false; [EOL] }
public boolean isSupported(DurationFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     DurationField field = type.getField(getChronology()); [EOL]     if (TIME_DURATION_TYPES.contains(type) || field.getUnitMillis() < getChronology().days().getUnitMillis()) { [EOL]         return field.isSupported(); [EOL]     } [EOL]     return false; [EOL] }
public boolean isSupported(DurationFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     DurationField field = type.getField(getChronology()); [EOL]     if (TIME_DURATION_TYPES.contains(type) || field.getUnitMillis() < getChronology().days().getUnitMillis()) { [EOL]         return field.isSupported(); [EOL]     } [EOL]     return false; [EOL] }
public LocalTime withField(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime withField(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime withField(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).set(getLocalMillis(), value); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getLocalMillis(), amount); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime plusMillis(int millis) { [EOL]     if (millis == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().millis().add(getLocalMillis(), millis); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime plusMillis(int millis) { [EOL]     if (millis == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().millis().add(getLocalMillis(), millis); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime plusMillis(int millis) { [EOL]     if (millis == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().millis().add(getLocalMillis(), millis); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime minusHours(int hours) { [EOL]     if (hours == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().hours().subtract(getLocalMillis(), hours); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime minusHours(int hours) { [EOL]     if (hours == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().hours().subtract(getLocalMillis(), hours); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalTime minusHours(int hours) { [EOL]     if (hours == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().hours().subtract(getLocalMillis(), hours); [EOL]     return withLocalMillis(instant); [EOL] }
public int getMillisOfDay() { [EOL]     return getChronology().millisOfDay().get(getLocalMillis()); [EOL] }
public DateTime toDateTimeToday() { [EOL]     return toDateTimeToday(null); [EOL] }
Property(LocalTime instant, DateTimeField field) { [EOL]     super(); [EOL]     iInstant = instant; [EOL]     iField = field; [EOL] }
public DateTimeField getField() { [EOL]     return iField; [EOL] }
protected long getMillis() { [EOL]     return iInstant.getLocalMillis(); [EOL] }
public LocalTime withMaximumValue() { [EOL]     return setCopy(getMaximumValue()); [EOL] }
public LocalTime withMinimumValue() { [EOL]     return setCopy(getMinimumValue()); [EOL] }
public int get(long millis) { [EOL]     int value = super.get(millis); [EOL]     if (value <= iSkip) { [EOL]         value--; [EOL]     } [EOL]     return value; [EOL] }
public long set(long millis, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue()); [EOL]     if (value <= iSkip) { [EOL]         if (value == iSkip) { [EOL]             throw new IllegalFieldValueException(DateTimeFieldType.year(), Integer.valueOf(value), null, null); [EOL]         } [EOL]         value++; [EOL]     } [EOL]     return super.set(millis, value); [EOL] }
public long set(long millis, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue()); [EOL]     if (value <= iSkip) { [EOL]         if (value == iSkip) { [EOL]             throw new IllegalFieldValueException(DateTimeFieldType.year(), Integer.valueOf(value), null, null); [EOL]         } [EOL]         value++; [EOL]     } [EOL]     return super.set(millis, value); [EOL] }
public long set(long millis, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue()); [EOL]     if (value <= iSkip) { [EOL]         if (value == iSkip) { [EOL]             throw new IllegalFieldValueException(DateTimeFieldType.year(), Integer.valueOf(value), null, null); [EOL]         } [EOL]         value++; [EOL]     } [EOL]     return super.set(millis, value); [EOL] }
public long set(long millis, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue()); [EOL]     if (value <= iSkip) { [EOL]         if (value == iSkip) { [EOL]             throw new IllegalFieldValueException(DateTimeFieldType.year(), Integer.valueOf(value), null, null); [EOL]         } [EOL]         value++; [EOL]     } [EOL]     return super.set(millis, value); [EOL] }
public long set(long millis, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue()); [EOL]     if (value <= iSkip) { [EOL]         if (value == iSkip) { [EOL]             throw new IllegalFieldValueException(DateTimeFieldType.year(), Integer.valueOf(value), null, null); [EOL]         } [EOL]         value++; [EOL]     } [EOL]     return super.set(millis, value); [EOL] }
public long set(long millis, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue()); [EOL]     if (value <= iSkip) { [EOL]         if (value == iSkip) { [EOL]             throw new IllegalFieldValueException(DateTimeFieldType.year(), Integer.valueOf(value), null, null); [EOL]         } [EOL]         value++; [EOL]     } [EOL]     return super.set(millis, value); [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERAS: [EOL]             return ERAS_TYPE; [EOL]         case CENTURIES: [EOL]             return CENTURIES_TYPE; [EOL]         case WEEKYEARS: [EOL]             return WEEKYEARS_TYPE; [EOL]         case YEARS: [EOL]             return YEARS_TYPE; [EOL]         case MONTHS: [EOL]             return MONTHS_TYPE; [EOL]         case WEEKS: [EOL]             return WEEKS_TYPE; [EOL]         case DAYS: [EOL]             return DAYS_TYPE; [EOL]         case HALFDAYS: [EOL]             return HALFDAYS_TYPE; [EOL]         case HOURS: [EOL]             return HOURS_TYPE; [EOL]         case MINUTES: [EOL]             return MINUTES_TYPE; [EOL]         case SECONDS: [EOL]             return SECONDS_TYPE; [EOL]         case MILLIS: [EOL]             return MILLIS_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
public static MutableDateTime now(Chronology chronology) { [EOL]     if (chronology == null) { [EOL]         throw new NullPointerException("Chronology must not be null"); [EOL]     } [EOL]     return new MutableDateTime(chronology); [EOL] }
public static MutableDateTime now(Chronology chronology) { [EOL]     if (chronology == null) { [EOL]         throw new NullPointerException("Chronology must not be null"); [EOL]     } [EOL]     return new MutableDateTime(chronology); [EOL] }
public MutableDateTime(DateTimeZone zone) { [EOL]     super(zone); [EOL] }
public MutableDateTime(DateTimeZone zone) { [EOL]     super(zone); [EOL] }
public MutableDateTime(Chronology chronology) { [EOL]     super(chronology); [EOL] }
public MutableDateTime(Chronology chronology) { [EOL]     super(chronology); [EOL] }
public MutableDateTime(long instant) { [EOL]     super(instant); [EOL] }
public MutableDateTime(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] }
public MutableDateTime(long instant, Chronology chronology) { [EOL]     super(instant, chronology); [EOL] }
public MutableDateTime(Object instant) { [EOL]     super(instant, (Chronology) null); [EOL] }
public MutableDateTime(Object instant) { [EOL]     super(instant, (Chronology) null); [EOL] }
public MutableDateTime(Object instant) { [EOL]     super(instant, (Chronology) null); [EOL] }
public MutableDateTime(Object instant) { [EOL]     super(instant, (Chronology) null); [EOL] }
public MutableDateTime(Object instant) { [EOL]     super(instant, (Chronology) null); [EOL] }
public MutableDateTime(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology)); [EOL] }
public MutableDateTime(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology)); [EOL] }
public MutableDateTime(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology)); [EOL] }
public MutableDateTime(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology)); [EOL] }
public void add(long duration) { [EOL]     setMillis(FieldUtils.safeAdd(getMillis(), duration)); [EOL] }
public void add(long duration) { [EOL]     setMillis(FieldUtils.safeAdd(getMillis(), duration)); [EOL] }
public void add(long duration) { [EOL]     setMillis(FieldUtils.safeAdd(getMillis(), duration)); [EOL] }
public void setZone(DateTimeZone newZone) { [EOL]     newZone = DateTimeUtils.getZone(newZone); [EOL]     Chronology chrono = getChronology(); [EOL]     if (chrono.getZone() != newZone) { [EOL]         setChronology(chrono.withZone(newZone)); [EOL]     } [EOL] }
public void setZone(DateTimeZone newZone) { [EOL]     newZone = DateTimeUtils.getZone(newZone); [EOL]     Chronology chrono = getChronology(); [EOL]     if (chrono.getZone() != newZone) { [EOL]         setChronology(chrono.withZone(newZone)); [EOL]     } [EOL] }
public void set(DateTimeFieldType type, int value) { [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     setMillis(type.getField(getChronology()).set(getMillis(), value)); [EOL] }
public void addYears(final int years) { [EOL]     if (years != 0) { [EOL]         setMillis(getChronology().years().add(getMillis(), years)); [EOL]     } [EOL] }
public void addYears(final int years) { [EOL]     if (years != 0) { [EOL]         setMillis(getChronology().years().add(getMillis(), years)); [EOL]     } [EOL] }
public void addYears(final int years) { [EOL]     if (years != 0) { [EOL]         setMillis(getChronology().years().add(getMillis(), years)); [EOL]     } [EOL] }
public void addDays(final int days) { [EOL]     if (days != 0) { [EOL]         setMillis(getChronology().days().add(getMillis(), days)); [EOL]     } [EOL] }
public void addDays(final int days) { [EOL]     if (days != 0) { [EOL]         setMillis(getChronology().days().add(getMillis(), days)); [EOL]     } [EOL] }
public void addDays(final int days) { [EOL]     if (days != 0) { [EOL]         setMillis(getChronology().days().add(getMillis(), days)); [EOL]     } [EOL] }
public void addMinutes(final int minutes) { [EOL]     if (minutes != 0) { [EOL]         setMillis(getChronology().minutes().add(getMillis(), minutes)); [EOL]     } [EOL] }
public void addMinutes(final int minutes) { [EOL]     if (minutes != 0) { [EOL]         setMillis(getChronology().minutes().add(getMillis(), minutes)); [EOL]     } [EOL] }
public void addMinutes(final int minutes) { [EOL]     if (minutes != 0) { [EOL]         setMillis(getChronology().minutes().add(getMillis(), minutes)); [EOL]     } [EOL] }
public void setSecondOfDay(final int secondOfDay) { [EOL]     setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay)); [EOL] }
public void setSecondOfDay(final int secondOfDay) { [EOL]     setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay)); [EOL] }
public void setSecondOfDay(final int secondOfDay) { [EOL]     setMillis(getChronology().secondOfDay().set(getMillis(), secondOfDay)); [EOL] }
public void addMillis(final int millis) { [EOL]     if (millis != 0) { [EOL]         setMillis(getChronology().millis().add(getMillis(), millis)); [EOL]     } [EOL] }
public void addMillis(final int millis) { [EOL]     if (millis != 0) { [EOL]         setMillis(getChronology().millis().add(getMillis(), millis)); [EOL]     } [EOL] }
public void addMillis(final int millis) { [EOL]     if (millis != 0) { [EOL]         setMillis(getChronology().millis().add(getMillis(), millis)); [EOL]     } [EOL] }
public void setTime(final long millis) { [EOL]     int millisOfDay = ISOChronology.getInstanceUTC().millisOfDay().get(millis); [EOL]     setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); [EOL] }
public void setTime(final long millis) { [EOL]     int millisOfDay = ISOChronology.getInstanceUTC().millisOfDay().get(millis); [EOL]     setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); [EOL] }
public void setTime(final long millis) { [EOL]     int millisOfDay = ISOChronology.getInstanceUTC().millisOfDay().get(millis); [EOL]     setMillis(getChronology().millisOfDay().set(getMillis(), millisOfDay)); [EOL] }
public void setTime(final ReadableInstant instant) { [EOL]     long instantMillis = DateTimeUtils.getInstantMillis(instant); [EOL]     Chronology instantChrono = DateTimeUtils.getInstantChronology(instant); [EOL]     DateTimeZone zone = instantChrono.getZone(); [EOL]     if (zone != null) { [EOL]         instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis); [EOL]     } [EOL]     setTime(instantMillis); [EOL] }
public void setTime(final ReadableInstant instant) { [EOL]     long instantMillis = DateTimeUtils.getInstantMillis(instant); [EOL]     Chronology instantChrono = DateTimeUtils.getInstantChronology(instant); [EOL]     DateTimeZone zone = instantChrono.getZone(); [EOL]     if (zone != null) { [EOL]         instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis); [EOL]     } [EOL]     setTime(instantMillis); [EOL] }
public void setTime(final ReadableInstant instant) { [EOL]     long instantMillis = DateTimeUtils.getInstantMillis(instant); [EOL]     Chronology instantChrono = DateTimeUtils.getInstantChronology(instant); [EOL]     DateTimeZone zone = instantChrono.getZone(); [EOL]     if (zone != null) { [EOL]         instantMillis = zone.getMillisKeepLocal(DateTimeZone.UTC, instantMillis); [EOL]     } [EOL]     setTime(instantMillis); [EOL] }
public Property centuryOfEra() { [EOL]     return new Property(this, getChronology().centuryOfEra()); [EOL] }
public Property weekyear() { [EOL]     return new Property(this, getChronology().weekyear()); [EOL] }
public MutableDateTime add(long value) { [EOL]     iInstant.setMillis(getField().add(iInstant.getMillis(), value)); [EOL]     return iInstant; [EOL] }
public MutableDateTime add(long value) { [EOL]     iInstant.setMillis(getField().add(iInstant.getMillis(), value)); [EOL]     return iInstant; [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours hours(int hours) { [EOL]     switch(hours) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case 8: [EOL]             return EIGHT; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Hours(hours); [EOL]     } [EOL] }
public static Hours standardHoursIn(ReadablePeriod period) { [EOL]     int amount = BaseSingleFieldPeriod.standardPeriodIn(period, DateTimeConstants.MILLIS_PER_HOUR); [EOL]     return Hours.hours(amount); [EOL] }
public DurationFieldType getFieldType() { [EOL]     return DurationFieldType.hours(); [EOL] }
public Weeks toStandardWeeks() { [EOL]     return Weeks.weeks(getValue() / DateTimeConstants.HOURS_PER_WEEK); [EOL] }
public Weeks toStandardWeeks() { [EOL]     return Weeks.weeks(getValue() / DateTimeConstants.HOURS_PER_WEEK); [EOL] }
public Weeks toStandardWeeks() { [EOL]     return Weeks.weeks(getValue() / DateTimeConstants.HOURS_PER_WEEK); [EOL] }
public Weeks toStandardWeeks() { [EOL]     return Weeks.weeks(getValue() / DateTimeConstants.HOURS_PER_WEEK); [EOL] }
public Seconds toStandardSeconds() { [EOL]     return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_HOUR)); [EOL] }
public Seconds toStandardSeconds() { [EOL]     return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_HOUR)); [EOL] }
public Seconds toStandardSeconds() { [EOL]     return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_HOUR)); [EOL] }
public int getHours() { [EOL]     return getValue(); [EOL] }
public Hours dividedBy(int divisor) { [EOL]     if (divisor == 1) { [EOL]         return this; [EOL]     } [EOL]     return Hours.hours(getValue() / divisor); [EOL] }
public Hours dividedBy(int divisor) { [EOL]     if (divisor == 1) { [EOL]         return this; [EOL]     } [EOL]     return Hours.hours(getValue() / divisor); [EOL] }
public Hours dividedBy(int divisor) { [EOL]     if (divisor == 1) { [EOL]         return this; [EOL]     } [EOL]     return Hours.hours(getValue() / divisor); [EOL] }
public Hours dividedBy(int divisor) { [EOL]     if (divisor == 1) { [EOL]         return this; [EOL]     } [EOL]     return Hours.hours(getValue() / divisor); [EOL] }
void copyInto(Converter[] converters) { [EOL]     System.arraycopy(iConverters, 0, converters, 0, iConverters.length); [EOL] }
ConverterSet add(Converter converter, Converter[] removed) { [EOL]     Converter[] converters = iConverters; [EOL]     int length = converters.length; [EOL]     for (int i = 0; i < length; i++) { [EOL]         Converter existing = converters[i]; [EOL]         if (converter.equals(existing)) { [EOL]             if (removed != null) { [EOL]                 removed[0] = null; [EOL]             } [EOL]             return this; [EOL]         } [EOL]         if (converter.getSupportedType() == existing.getSupportedType()) { [EOL]             Converter[] copy = new Converter[length]; [EOL]             for (int j = 0; j < length; j++) { [EOL]                 if (j != i) { [EOL]                     copy[j] = converters[j]; [EOL]                 } else { [EOL]                     copy[j] = converter; [EOL]                 } [EOL]             } [EOL]             if (removed != null) { [EOL]                 removed[0] = existing; [EOL]             } [EOL]             return new ConverterSet(copy); [EOL]         } [EOL]     } [EOL]     Converter[] copy = new Converter[length + 1]; [EOL]     System.arraycopy(converters, 0, copy, 0, length); [EOL]     copy[length] = converter; [EOL]     if (removed != null) { [EOL]         removed[0] = null; [EOL]     } [EOL]     return new ConverterSet(copy); [EOL] }
ConverterSet add(Converter converter, Converter[] removed) { [EOL]     Converter[] converters = iConverters; [EOL]     int length = converters.length; [EOL]     for (int i = 0; i < length; i++) { [EOL]         Converter existing = converters[i]; [EOL]         if (converter.equals(existing)) { [EOL]             if (removed != null) { [EOL]                 removed[0] = null; [EOL]             } [EOL]             return this; [EOL]         } [EOL]         if (converter.getSupportedType() == existing.getSupportedType()) { [EOL]             Converter[] copy = new Converter[length]; [EOL]             for (int j = 0; j < length; j++) { [EOL]                 if (j != i) { [EOL]                     copy[j] = converters[j]; [EOL]                 } else { [EOL]                     copy[j] = converter; [EOL]                 } [EOL]             } [EOL]             if (removed != null) { [EOL]                 removed[0] = existing; [EOL]             } [EOL]             return new ConverterSet(copy); [EOL]         } [EOL]     } [EOL]     Converter[] copy = new Converter[length + 1]; [EOL]     System.arraycopy(converters, 0, copy, 0, length); [EOL]     copy[length] = converter; [EOL]     if (removed != null) { [EOL]         removed[0] = null; [EOL]     } [EOL]     return new ConverterSet(copy); [EOL] }
ConverterSet add(Converter converter, Converter[] removed) { [EOL]     Converter[] converters = iConverters; [EOL]     int length = converters.length; [EOL]     for (int i = 0; i < length; i++) { [EOL]         Converter existing = converters[i]; [EOL]         if (converter.equals(existing)) { [EOL]             if (removed != null) { [EOL]                 removed[0] = null; [EOL]             } [EOL]             return this; [EOL]         } [EOL]         if (converter.getSupportedType() == existing.getSupportedType()) { [EOL]             Converter[] copy = new Converter[length]; [EOL]             for (int j = 0; j < length; j++) { [EOL]                 if (j != i) { [EOL]                     copy[j] = converters[j]; [EOL]                 } else { [EOL]                     copy[j] = converter; [EOL]                 } [EOL]             } [EOL]             if (removed != null) { [EOL]                 removed[0] = existing; [EOL]             } [EOL]             return new ConverterSet(copy); [EOL]         } [EOL]     } [EOL]     Converter[] copy = new Converter[length + 1]; [EOL]     System.arraycopy(converters, 0, copy, 0, length); [EOL]     copy[length] = converter; [EOL]     if (removed != null) { [EOL]         removed[0] = null; [EOL]     } [EOL]     return new ConverterSet(copy); [EOL] }
ConverterSet add(Converter converter, Converter[] removed) { [EOL]     Converter[] converters = iConverters; [EOL]     int length = converters.length; [EOL]     for (int i = 0; i < length; i++) { [EOL]         Converter existing = converters[i]; [EOL]         if (converter.equals(existing)) { [EOL]             if (removed != null) { [EOL]                 removed[0] = null; [EOL]             } [EOL]             return this; [EOL]         } [EOL]         if (converter.getSupportedType() == existing.getSupportedType()) { [EOL]             Converter[] copy = new Converter[length]; [EOL]             for (int j = 0; j < length; j++) { [EOL]                 if (j != i) { [EOL]                     copy[j] = converters[j]; [EOL]                 } else { [EOL]                     copy[j] = converter; [EOL]                 } [EOL]             } [EOL]             if (removed != null) { [EOL]                 removed[0] = existing; [EOL]             } [EOL]             return new ConverterSet(copy); [EOL]         } [EOL]     } [EOL]     Converter[] copy = new Converter[length + 1]; [EOL]     System.arraycopy(converters, 0, copy, 0, length); [EOL]     copy[length] = converter; [EOL]     if (removed != null) { [EOL]         removed[0] = null; [EOL]     } [EOL]     return new ConverterSet(copy); [EOL] }
ConverterSet add(Converter converter, Converter[] removed) { [EOL]     Converter[] converters = iConverters; [EOL]     int length = converters.length; [EOL]     for (int i = 0; i < length; i++) { [EOL]         Converter existing = converters[i]; [EOL]         if (converter.equals(existing)) { [EOL]             if (removed != null) { [EOL]                 removed[0] = null; [EOL]             } [EOL]             return this; [EOL]         } [EOL]         if (converter.getSupportedType() == existing.getSupportedType()) { [EOL]             Converter[] copy = new Converter[length]; [EOL]             for (int j = 0; j < length; j++) { [EOL]                 if (j != i) { [EOL]                     copy[j] = converters[j]; [EOL]                 } else { [EOL]                     copy[j] = converter; [EOL]                 } [EOL]             } [EOL]             if (removed != null) { [EOL]                 removed[0] = existing; [EOL]             } [EOL]             return new ConverterSet(copy); [EOL]         } [EOL]     } [EOL]     Converter[] copy = new Converter[length + 1]; [EOL]     System.arraycopy(converters, 0, copy, 0, length); [EOL]     copy[length] = converter; [EOL]     if (removed != null) { [EOL]         removed[0] = null; [EOL]     } [EOL]     return new ConverterSet(copy); [EOL] }
ConverterSet add(Converter converter, Converter[] removed) { [EOL]     Converter[] converters = iConverters; [EOL]     int length = converters.length; [EOL]     for (int i = 0; i < length; i++) { [EOL]         Converter existing = converters[i]; [EOL]         if (converter.equals(existing)) { [EOL]             if (removed != null) { [EOL]                 removed[0] = null; [EOL]             } [EOL]             return this; [EOL]         } [EOL]         if (converter.getSupportedType() == existing.getSupportedType()) { [EOL]             Converter[] copy = new Converter[length]; [EOL]             for (int j = 0; j < length; j++) { [EOL]                 if (j != i) { [EOL]                     copy[j] = converters[j]; [EOL]                 } else { [EOL]                     copy[j] = converter; [EOL]                 } [EOL]             } [EOL]             if (removed != null) { [EOL]                 removed[0] = existing; [EOL]             } [EOL]             return new ConverterSet(copy); [EOL]         } [EOL]     } [EOL]     Converter[] copy = new Converter[length + 1]; [EOL]     System.arraycopy(converters, 0, copy, 0, length); [EOL]     copy[length] = converter; [EOL]     if (removed != null) { [EOL]         removed[0] = null; [EOL]     } [EOL]     return new ConverterSet(copy); [EOL] }
ConverterSet remove(Converter converter, Converter[] removed) { [EOL]     Converter[] converters = iConverters; [EOL]     int length = converters.length; [EOL]     for (int i = 0; i < length; i++) { [EOL]         if (converter.equals(converters[i])) { [EOL]             return remove(i, removed); [EOL]         } [EOL]     } [EOL]     if (removed != null) { [EOL]         removed[0] = null; [EOL]     } [EOL]     return this; [EOL] }
ConverterSet remove(Converter converter, Converter[] removed) { [EOL]     Converter[] converters = iConverters; [EOL]     int length = converters.length; [EOL]     for (int i = 0; i < length; i++) { [EOL]         if (converter.equals(converters[i])) { [EOL]             return remove(i, removed); [EOL]         } [EOL]     } [EOL]     if (removed != null) { [EOL]         removed[0] = null; [EOL]     } [EOL]     return this; [EOL] }
ConverterSet remove(Converter converter, Converter[] removed) { [EOL]     Converter[] converters = iConverters; [EOL]     int length = converters.length; [EOL]     for (int i = 0; i < length; i++) { [EOL]         if (converter.equals(converters[i])) { [EOL]             return remove(i, removed); [EOL]         } [EOL]     } [EOL]     if (removed != null) { [EOL]         removed[0] = null; [EOL]     } [EOL]     return this; [EOL] }
ConverterSet remove(Converter converter, Converter[] removed) { [EOL]     Converter[] converters = iConverters; [EOL]     int length = converters.length; [EOL]     for (int i = 0; i < length; i++) { [EOL]         if (converter.equals(converters[i])) { [EOL]             return remove(i, removed); [EOL]         } [EOL]     } [EOL]     if (removed != null) { [EOL]         removed[0] = null; [EOL]     } [EOL]     return this; [EOL] }
public DateTimeFormatterBuilder() { [EOL]     super(); [EOL]     iElementPairs = new ArrayList<Object>(); [EOL] }
public DateTimeFormatter toFormatter() { [EOL]     Object f = getFormatter(); [EOL]     DateTimePrinter printer = null; [EOL]     if (isPrinter(f)) { [EOL]         printer = (DateTimePrinter) f; [EOL]     } [EOL]     DateTimeParser parser = null; [EOL]     if (isParser(f)) { [EOL]         parser = (DateTimeParser) f; [EOL]     } [EOL]     if (printer != null || parser != null) { [EOL]         return new DateTimeFormatter(printer, parser); [EOL]     } [EOL]     throw new UnsupportedOperationException("Both printing and parsing not supported"); [EOL] }
public DateTimePrinter toPrinter() { [EOL]     Object f = getFormatter(); [EOL]     if (isPrinter(f)) { [EOL]         return (DateTimePrinter) f; [EOL]     } [EOL]     throw new UnsupportedOperationException("Printing is not supported"); [EOL] }
public DateTimePrinter toPrinter() { [EOL]     Object f = getFormatter(); [EOL]     if (isPrinter(f)) { [EOL]         return (DateTimePrinter) f; [EOL]     } [EOL]     throw new UnsupportedOperationException("Printing is not supported"); [EOL] }
public boolean canBuildPrinter() { [EOL]     return isPrinter(getFormatter()); [EOL] }
public DateTimeFormatterBuilder append(DateTimePrinter printer) { [EOL]     checkPrinter(printer); [EOL]     return append0(printer, null); [EOL] }
public DateTimeFormatterBuilder append(DateTimePrinter printer) { [EOL]     checkPrinter(printer); [EOL]     return append0(printer, null); [EOL] }
public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[] parsers) { [EOL]     if (printer != null) { [EOL]         checkPrinter(printer); [EOL]     } [EOL]     if (parsers == null) { [EOL]         throw new IllegalArgumentException("No parsers supplied"); [EOL]     } [EOL]     int length = parsers.length; [EOL]     if (length == 1) { [EOL]         if (parsers[0] == null) { [EOL]             throw new IllegalArgumentException("No parser supplied"); [EOL]         } [EOL]         return append0(printer, parsers[0]); [EOL]     } [EOL]     DateTimeParser[] copyOfParsers = new DateTimeParser[length]; [EOL]     int i; [EOL]     for (i = 0; i < length - 1; i++) { [EOL]         if ((copyOfParsers[i] = parsers[i]) == null) { [EOL]             throw new IllegalArgumentException("Incomplete parser array"); [EOL]         } [EOL]     } [EOL]     copyOfParsers[i] = parsers[i]; [EOL]     return append0(printer, new MatchingParser(copyOfParsers)); [EOL] }
public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[] parsers) { [EOL]     if (printer != null) { [EOL]         checkPrinter(printer); [EOL]     } [EOL]     if (parsers == null) { [EOL]         throw new IllegalArgumentException("No parsers supplied"); [EOL]     } [EOL]     int length = parsers.length; [EOL]     if (length == 1) { [EOL]         if (parsers[0] == null) { [EOL]             throw new IllegalArgumentException("No parser supplied"); [EOL]         } [EOL]         return append0(printer, parsers[0]); [EOL]     } [EOL]     DateTimeParser[] copyOfParsers = new DateTimeParser[length]; [EOL]     int i; [EOL]     for (i = 0; i < length - 1; i++) { [EOL]         if ((copyOfParsers[i] = parsers[i]) == null) { [EOL]             throw new IllegalArgumentException("Incomplete parser array"); [EOL]         } [EOL]     } [EOL]     copyOfParsers[i] = parsers[i]; [EOL]     return append0(printer, new MatchingParser(copyOfParsers)); [EOL] }
public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[] parsers) { [EOL]     if (printer != null) { [EOL]         checkPrinter(printer); [EOL]     } [EOL]     if (parsers == null) { [EOL]         throw new IllegalArgumentException("No parsers supplied"); [EOL]     } [EOL]     int length = parsers.length; [EOL]     if (length == 1) { [EOL]         if (parsers[0] == null) { [EOL]             throw new IllegalArgumentException("No parser supplied"); [EOL]         } [EOL]         return append0(printer, parsers[0]); [EOL]     } [EOL]     DateTimeParser[] copyOfParsers = new DateTimeParser[length]; [EOL]     int i; [EOL]     for (i = 0; i < length - 1; i++) { [EOL]         if ((copyOfParsers[i] = parsers[i]) == null) { [EOL]             throw new IllegalArgumentException("Incomplete parser array"); [EOL]         } [EOL]     } [EOL]     copyOfParsers[i] = parsers[i]; [EOL]     return append0(printer, new MatchingParser(copyOfParsers)); [EOL] }
public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[] parsers) { [EOL]     if (printer != null) { [EOL]         checkPrinter(printer); [EOL]     } [EOL]     if (parsers == null) { [EOL]         throw new IllegalArgumentException("No parsers supplied"); [EOL]     } [EOL]     int length = parsers.length; [EOL]     if (length == 1) { [EOL]         if (parsers[0] == null) { [EOL]             throw new IllegalArgumentException("No parser supplied"); [EOL]         } [EOL]         return append0(printer, parsers[0]); [EOL]     } [EOL]     DateTimeParser[] copyOfParsers = new DateTimeParser[length]; [EOL]     int i; [EOL]     for (i = 0; i < length - 1; i++) { [EOL]         if ((copyOfParsers[i] = parsers[i]) == null) { [EOL]             throw new IllegalArgumentException("Incomplete parser array"); [EOL]         } [EOL]     } [EOL]     copyOfParsers[i] = parsers[i]; [EOL]     return append0(printer, new MatchingParser(copyOfParsers)); [EOL] }
public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[] parsers) { [EOL]     if (printer != null) { [EOL]         checkPrinter(printer); [EOL]     } [EOL]     if (parsers == null) { [EOL]         throw new IllegalArgumentException("No parsers supplied"); [EOL]     } [EOL]     int length = parsers.length; [EOL]     if (length == 1) { [EOL]         if (parsers[0] == null) { [EOL]             throw new IllegalArgumentException("No parser supplied"); [EOL]         } [EOL]         return append0(printer, parsers[0]); [EOL]     } [EOL]     DateTimeParser[] copyOfParsers = new DateTimeParser[length]; [EOL]     int i; [EOL]     for (i = 0; i < length - 1; i++) { [EOL]         if ((copyOfParsers[i] = parsers[i]) == null) { [EOL]             throw new IllegalArgumentException("Incomplete parser array"); [EOL]         } [EOL]     } [EOL]     copyOfParsers[i] = parsers[i]; [EOL]     return append0(printer, new MatchingParser(copyOfParsers)); [EOL] }
public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[] parsers) { [EOL]     if (printer != null) { [EOL]         checkPrinter(printer); [EOL]     } [EOL]     if (parsers == null) { [EOL]         throw new IllegalArgumentException("No parsers supplied"); [EOL]     } [EOL]     int length = parsers.length; [EOL]     if (length == 1) { [EOL]         if (parsers[0] == null) { [EOL]             throw new IllegalArgumentException("No parser supplied"); [EOL]         } [EOL]         return append0(printer, parsers[0]); [EOL]     } [EOL]     DateTimeParser[] copyOfParsers = new DateTimeParser[length]; [EOL]     int i; [EOL]     for (i = 0; i < length - 1; i++) { [EOL]         if ((copyOfParsers[i] = parsers[i]) == null) { [EOL]             throw new IllegalArgumentException("Incomplete parser array"); [EOL]         } [EOL]     } [EOL]     copyOfParsers[i] = parsers[i]; [EOL]     return append0(printer, new MatchingParser(copyOfParsers)); [EOL] }
public DateTimeFormatterBuilder append(DateTimePrinter printer, DateTimeParser[] parsers) { [EOL]     if (printer != null) { [EOL]         checkPrinter(printer); [EOL]     } [EOL]     if (parsers == null) { [EOL]         throw new IllegalArgumentException("No parsers supplied"); [EOL]     } [EOL]     int length = parsers.length; [EOL]     if (length == 1) { [EOL]         if (parsers[0] == null) { [EOL]             throw new IllegalArgumentException("No parser supplied"); [EOL]         } [EOL]         return append0(printer, parsers[0]); [EOL]     } [EOL]     DateTimeParser[] copyOfParsers = new DateTimeParser[length]; [EOL]     int i; [EOL]     for (i = 0; i < length - 1; i++) { [EOL]         if ((copyOfParsers[i] = parsers[i]) == null) { [EOL]             throw new IllegalArgumentException("Incomplete parser array"); [EOL]         } [EOL]     } [EOL]     copyOfParsers[i] = parsers[i]; [EOL]     return append0(printer, new MatchingParser(copyOfParsers)); [EOL] }
private DateTimeFormatterBuilder append0(Object element) { [EOL]     iFormatter = null; [EOL]     iElementPairs.add(element); [EOL]     iElementPairs.add(element); [EOL]     return this; [EOL] }
public DateTimeFormatterBuilder appendLiteral(char c) { [EOL]     return append0(new CharacterLiteral(c)); [EOL] }
public DateTimeFormatterBuilder appendLiteral(String text) { [EOL]     if (text == null) { [EOL]         throw new IllegalArgumentException("Literal must not be null"); [EOL]     } [EOL]     switch(text.length()) { [EOL]         case 0: [EOL]             return this; [EOL]         case 1: [EOL]             return append0(new CharacterLiteral(text.charAt(0))); [EOL]         default: [EOL]             return append0(new StringLiteral(text)); [EOL]     } [EOL] }
public DateTimeFormatterBuilder appendLiteral(String text) { [EOL]     if (text == null) { [EOL]         throw new IllegalArgumentException("Literal must not be null"); [EOL]     } [EOL]     switch(text.length()) { [EOL]         case 0: [EOL]             return this; [EOL]         case 1: [EOL]             return append0(new CharacterLiteral(text.charAt(0))); [EOL]         default: [EOL]             return append0(new StringLiteral(text)); [EOL]     } [EOL] }
public DateTimeFormatterBuilder appendLiteral(String text) { [EOL]     if (text == null) { [EOL]         throw new IllegalArgumentException("Literal must not be null"); [EOL]     } [EOL]     switch(text.length()) { [EOL]         case 0: [EOL]             return this; [EOL]         case 1: [EOL]             return append0(new CharacterLiteral(text.charAt(0))); [EOL]         default: [EOL]             return append0(new StringLiteral(text)); [EOL]     } [EOL] }
public DateTimeFormatterBuilder appendLiteral(String text) { [EOL]     if (text == null) { [EOL]         throw new IllegalArgumentException("Literal must not be null"); [EOL]     } [EOL]     switch(text.length()) { [EOL]         case 0: [EOL]             return this; [EOL]         case 1: [EOL]             return append0(new CharacterLiteral(text.charAt(0))); [EOL]         default: [EOL]             return append0(new StringLiteral(text)); [EOL]     } [EOL] }
public DateTimeFormatterBuilder appendDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (maxDigits < minDigits) { [EOL]         maxDigits = minDigits; [EOL]     } [EOL]     if (minDigits < 0 || maxDigits <= 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (minDigits <= 1) { [EOL]         return append0(new UnpaddedNumber(fieldType, maxDigits, false)); [EOL]     } else { [EOL]         return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits)); [EOL]     } [EOL] }
public DateTimeFormatterBuilder appendDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (maxDigits < minDigits) { [EOL]         maxDigits = minDigits; [EOL]     } [EOL]     if (minDigits < 0 || maxDigits <= 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (minDigits <= 1) { [EOL]         return append0(new UnpaddedNumber(fieldType, maxDigits, false)); [EOL]     } else { [EOL]         return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits)); [EOL]     } [EOL] }
public DateTimeFormatterBuilder appendDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (maxDigits < minDigits) { [EOL]         maxDigits = minDigits; [EOL]     } [EOL]     if (minDigits < 0 || maxDigits <= 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (minDigits <= 1) { [EOL]         return append0(new UnpaddedNumber(fieldType, maxDigits, false)); [EOL]     } else { [EOL]         return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits)); [EOL]     } [EOL] }
public DateTimeFormatterBuilder appendDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (maxDigits < minDigits) { [EOL]         maxDigits = minDigits; [EOL]     } [EOL]     if (minDigits < 0 || maxDigits <= 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (minDigits <= 1) { [EOL]         return append0(new UnpaddedNumber(fieldType, maxDigits, false)); [EOL]     } else { [EOL]         return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits)); [EOL]     } [EOL] }
public DateTimeFormatterBuilder appendDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (maxDigits < minDigits) { [EOL]         maxDigits = minDigits; [EOL]     } [EOL]     if (minDigits < 0 || maxDigits <= 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (minDigits <= 1) { [EOL]         return append0(new UnpaddedNumber(fieldType, maxDigits, false)); [EOL]     } else { [EOL]         return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits)); [EOL]     } [EOL] }
public DateTimeFormatterBuilder appendDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (maxDigits < minDigits) { [EOL]         maxDigits = minDigits; [EOL]     } [EOL]     if (minDigits < 0 || maxDigits <= 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (minDigits <= 1) { [EOL]         return append0(new UnpaddedNumber(fieldType, maxDigits, false)); [EOL]     } else { [EOL]         return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits)); [EOL]     } [EOL] }
public DateTimeFormatterBuilder appendSignedDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (maxDigits < minDigits) { [EOL]         maxDigits = minDigits; [EOL]     } [EOL]     if (minDigits < 0 || maxDigits <= 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (minDigits <= 1) { [EOL]         return append0(new UnpaddedNumber(fieldType, maxDigits, true)); [EOL]     } else { [EOL]         return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits)); [EOL]     } [EOL] }
public DateTimeFormatterBuilder appendSignedDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (maxDigits < minDigits) { [EOL]         maxDigits = minDigits; [EOL]     } [EOL]     if (minDigits < 0 || maxDigits <= 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (minDigits <= 1) { [EOL]         return append0(new UnpaddedNumber(fieldType, maxDigits, true)); [EOL]     } else { [EOL]         return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits)); [EOL]     } [EOL] }
public DateTimeFormatterBuilder appendSignedDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (maxDigits < minDigits) { [EOL]         maxDigits = minDigits; [EOL]     } [EOL]     if (minDigits < 0 || maxDigits <= 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (minDigits <= 1) { [EOL]         return append0(new UnpaddedNumber(fieldType, maxDigits, true)); [EOL]     } else { [EOL]         return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits)); [EOL]     } [EOL] }
public DateTimeFormatterBuilder appendSignedDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (maxDigits < minDigits) { [EOL]         maxDigits = minDigits; [EOL]     } [EOL]     if (minDigits < 0 || maxDigits <= 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (minDigits <= 1) { [EOL]         return append0(new UnpaddedNumber(fieldType, maxDigits, true)); [EOL]     } else { [EOL]         return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits)); [EOL]     } [EOL] }
public DateTimeFormatterBuilder appendSignedDecimal(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (maxDigits < minDigits) { [EOL]         maxDigits = minDigits; [EOL]     } [EOL]     if (minDigits < 0 || maxDigits <= 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (minDigits <= 1) { [EOL]         return append0(new UnpaddedNumber(fieldType, maxDigits, true)); [EOL]     } else { [EOL]         return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits)); [EOL]     } [EOL] }
public DateTimeFormatterBuilder appendFraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (maxDigits < minDigits) { [EOL]         maxDigits = minDigits; [EOL]     } [EOL]     if (minDigits < 0 || maxDigits <= 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     return append0(new Fraction(fieldType, minDigits, maxDigits)); [EOL] }
public DateTimeFormatterBuilder appendFraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (maxDigits < minDigits) { [EOL]         maxDigits = minDigits; [EOL]     } [EOL]     if (minDigits < 0 || maxDigits <= 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     return append0(new Fraction(fieldType, minDigits, maxDigits)); [EOL] }
public DateTimeFormatterBuilder appendFraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (maxDigits < minDigits) { [EOL]         maxDigits = minDigits; [EOL]     } [EOL]     if (minDigits < 0 || maxDigits <= 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     return append0(new Fraction(fieldType, minDigits, maxDigits)); [EOL] }
public DateTimeFormatterBuilder appendFraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (maxDigits < minDigits) { [EOL]         maxDigits = minDigits; [EOL]     } [EOL]     if (minDigits < 0 || maxDigits <= 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     return append0(new Fraction(fieldType, minDigits, maxDigits)); [EOL] }
public DateTimeFormatterBuilder appendFraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field type must not be null"); [EOL]     } [EOL]     if (maxDigits < minDigits) { [EOL]         maxDigits = minDigits; [EOL]     } [EOL]     if (minDigits < 0 || maxDigits <= 0) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     return append0(new Fraction(fieldType, minDigits, maxDigits)); [EOL] }
public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) { [EOL]     return appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits); [EOL] }
public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) { [EOL]     return appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits); [EOL] }
public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) { [EOL]     return appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits); [EOL] }
public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) { [EOL]     return appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits); [EOL] }
public DateTimeFormatterBuilder appendFractionOfMinute(int minDigits, int maxDigits) { [EOL]     return appendFraction(DateTimeFieldType.minuteOfDay(), minDigits, maxDigits); [EOL] }
public DateTimeFormatterBuilder appendFractionOfMinute(int minDigits, int maxDigits) { [EOL]     return appendFraction(DateTimeFieldType.minuteOfDay(), minDigits, maxDigits); [EOL] }
public DateTimeFormatterBuilder appendFractionOfMinute(int minDigits, int maxDigits) { [EOL]     return appendFraction(DateTimeFieldType.minuteOfDay(), minDigits, maxDigits); [EOL] }
public DateTimeFormatterBuilder appendFractionOfHour(int minDigits, int maxDigits) { [EOL]     return appendFraction(DateTimeFieldType.hourOfDay(), minDigits, maxDigits); [EOL] }
public DateTimeFormatterBuilder appendFractionOfHour(int minDigits, int maxDigits) { [EOL]     return appendFraction(DateTimeFieldType.hourOfDay(), minDigits, maxDigits); [EOL] }
public DateTimeFormatterBuilder appendFractionOfHour(int minDigits, int maxDigits) { [EOL]     return appendFraction(DateTimeFieldType.hourOfDay(), minDigits, maxDigits); [EOL] }
public DateTimeFormatterBuilder appendMillisOfSecond(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.millisOfSecond(), minDigits, 3); [EOL] }
public DateTimeFormatterBuilder appendMillisOfSecond(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.millisOfSecond(), minDigits, 3); [EOL] }
public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2); [EOL] }
public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2); [EOL] }
public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2); [EOL] }
public DateTimeFormatterBuilder appendHourOfDay(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2); [EOL] }
public DateTimeFormatterBuilder appendHourOfDay(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2); [EOL] }
public DateTimeFormatterBuilder appendHourOfDay(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2); [EOL] }
public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2); [EOL] }
public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2); [EOL] }
public DateTimeFormatterBuilder appendDayOfYear(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.dayOfYear(), minDigits, 3); [EOL] }
public DateTimeFormatterBuilder appendDayOfYear(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.dayOfYear(), minDigits, 3); [EOL] }
public DateTimeFormatterBuilder appendDayOfYear(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.dayOfYear(), minDigits, 3); [EOL] }
public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.weekOfWeekyear(), minDigits, 2); [EOL] }
public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.weekOfWeekyear(), minDigits, 2); [EOL] }
public DateTimeFormatterBuilder appendWeekyear(int minDigits, int maxDigits) { [EOL]     return appendSignedDecimal(DateTimeFieldType.weekyear(), minDigits, maxDigits); [EOL] }
public DateTimeFormatterBuilder appendWeekyear(int minDigits, int maxDigits) { [EOL]     return appendSignedDecimal(DateTimeFieldType.weekyear(), minDigits, maxDigits); [EOL] }
public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2); [EOL] }
public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2); [EOL] }
public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) { [EOL]     return appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2); [EOL] }
public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) { [EOL]     return appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits); [EOL] }
public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) { [EOL]     return appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits); [EOL] }
public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) { [EOL]     return appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits); [EOL] }
public DateTimeFormatterBuilder appendDayOfWeekShortText() { [EOL]     return appendShortText(DateTimeFieldType.dayOfWeek()); [EOL] }
public DateTimeFormatterBuilder appendTimeZoneOffset(String zeroOffsetText, boolean showSeparators, int minFields, int maxFields) { [EOL]     return append0(new TimeZoneOffset(zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields)); [EOL] }
public DateTimeFormatterBuilder appendTimeZoneOffset(String zeroOffsetText, boolean showSeparators, int minFields, int maxFields) { [EOL]     return append0(new TimeZoneOffset(zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields)); [EOL] }
public DateTimeFormatterBuilder appendTimeZoneOffset(String zeroOffsetText, boolean showSeparators, int minFields, int maxFields) { [EOL]     return append0(new TimeZoneOffset(zeroOffsetText, zeroOffsetText, showSeparators, minFields, maxFields)); [EOL] }
public DateTimeFormatterBuilder appendPattern(String pattern) { [EOL]     DateTimeFormat.appendPatternTo(this, pattern); [EOL]     return this; [EOL] }
public DateTimeFormatterBuilder appendPattern(String pattern) { [EOL]     DateTimeFormat.appendPatternTo(this, pattern); [EOL]     return this; [EOL] }
private Object getFormatter() { [EOL]     Object f = iFormatter; [EOL]     if (f == null) { [EOL]         if (iElementPairs.size() == 2) { [EOL]             Object printer = iElementPairs.get(0); [EOL]             Object parser = iElementPairs.get(1); [EOL]             if (printer != null) { [EOL]                 if (printer == parser || parser == null) { [EOL]                     f = printer; [EOL]                 } [EOL]             } else { [EOL]                 f = parser; [EOL]             } [EOL]         } [EOL]         if (f == null) { [EOL]             f = new Composite(iElementPairs); [EOL]         } [EOL]         iFormatter = f; [EOL]     } [EOL]     return f; [EOL] }
private Object getFormatter() { [EOL]     Object f = iFormatter; [EOL]     if (f == null) { [EOL]         if (iElementPairs.size() == 2) { [EOL]             Object printer = iElementPairs.get(0); [EOL]             Object parser = iElementPairs.get(1); [EOL]             if (printer != null) { [EOL]                 if (printer == parser || parser == null) { [EOL]                     f = printer; [EOL]                 } [EOL]             } else { [EOL]                 f = parser; [EOL]             } [EOL]         } [EOL]         if (f == null) { [EOL]             f = new Composite(iElementPairs); [EOL]         } [EOL]         iFormatter = f; [EOL]     } [EOL]     return f; [EOL] }
private Object getFormatter() { [EOL]     Object f = iFormatter; [EOL]     if (f == null) { [EOL]         if (iElementPairs.size() == 2) { [EOL]             Object printer = iElementPairs.get(0); [EOL]             Object parser = iElementPairs.get(1); [EOL]             if (printer != null) { [EOL]                 if (printer == parser || parser == null) { [EOL]                     f = printer; [EOL]                 } [EOL]             } else { [EOL]                 f = parser; [EOL]             } [EOL]         } [EOL]         if (f == null) { [EOL]             f = new Composite(iElementPairs); [EOL]         } [EOL]         iFormatter = f; [EOL]     } [EOL]     return f; [EOL] }
private Object getFormatter() { [EOL]     Object f = iFormatter; [EOL]     if (f == null) { [EOL]         if (iElementPairs.size() == 2) { [EOL]             Object printer = iElementPairs.get(0); [EOL]             Object parser = iElementPairs.get(1); [EOL]             if (printer != null) { [EOL]                 if (printer == parser || parser == null) { [EOL]                     f = printer; [EOL]                 } [EOL]             } else { [EOL]                 f = parser; [EOL]             } [EOL]         } [EOL]         if (f == null) { [EOL]             f = new Composite(iElementPairs); [EOL]         } [EOL]         iFormatter = f; [EOL]     } [EOL]     return f; [EOL] }
private Object getFormatter() { [EOL]     Object f = iFormatter; [EOL]     if (f == null) { [EOL]         if (iElementPairs.size() == 2) { [EOL]             Object printer = iElementPairs.get(0); [EOL]             Object parser = iElementPairs.get(1); [EOL]             if (printer != null) { [EOL]                 if (printer == parser || parser == null) { [EOL]                     f = printer; [EOL]                 } [EOL]             } else { [EOL]                 f = parser; [EOL]             } [EOL]         } [EOL]         if (f == null) { [EOL]             f = new Composite(iElementPairs); [EOL]         } [EOL]         iFormatter = f; [EOL]     } [EOL]     return f; [EOL] }
private boolean isPrinter(Object f) { [EOL]     if (f instanceof DateTimePrinter) { [EOL]         if (f instanceof Composite) { [EOL]             return ((Composite) f).isPrinter(); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
private boolean isPrinter(Object f) { [EOL]     if (f instanceof DateTimePrinter) { [EOL]         if (f instanceof Composite) { [EOL]             return ((Composite) f).isPrinter(); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
private boolean isParser(Object f) { [EOL]     if (f instanceof DateTimeParser) { [EOL]         if (f instanceof Composite) { [EOL]             return ((Composite) f).isParser(); [EOL]         } [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
static void appendUnknownString(StringBuffer buf, int len) { [EOL]     for (int i = len; --i >= 0; ) { [EOL]         buf.append('\ufffd'); [EOL]     } [EOL] }
static void appendUnknownString(StringBuffer buf, int len) { [EOL]     for (int i = len; --i >= 0; ) { [EOL]         buf.append('\ufffd'); [EOL]     } [EOL] }
static void appendUnknownString(StringBuffer buf, int len) { [EOL]     for (int i = len; --i >= 0; ) { [EOL]         buf.append('\ufffd'); [EOL]     } [EOL] }
CharacterLiteral(char value) { [EOL]     super(); [EOL]     iValue = value; [EOL] }
CharacterLiteral(char value) { [EOL]     super(); [EOL]     iValue = value; [EOL] }
CharacterLiteral(char value) { [EOL]     super(); [EOL]     iValue = value; [EOL] }
CharacterLiteral(char value) { [EOL]     super(); [EOL]     iValue = value; [EOL] }
public int estimatePrintedLength() { [EOL]     return 1; [EOL] }
public int estimateParsedLength() { [EOL]     return 1; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     if (position >= text.length()) { [EOL]         return ~position; [EOL]     } [EOL]     char a = text.charAt(position); [EOL]     char b = iValue; [EOL]     if (a != b) { [EOL]         a = Character.toUpperCase(a); [EOL]         b = Character.toUpperCase(b); [EOL]         if (a != b) { [EOL]             a = Character.toLowerCase(a); [EOL]             b = Character.toLowerCase(b); [EOL]             if (a != b) { [EOL]                 return ~position; [EOL]             } [EOL]         } [EOL]     } [EOL]     return position + 1; [EOL] }
StringLiteral(String value) { [EOL]     super(); [EOL]     iValue = value; [EOL] }
StringLiteral(String value) { [EOL]     super(); [EOL]     iValue = value; [EOL] }
public int estimatePrintedLength() { [EOL]     return iValue.length(); [EOL] }
public int estimatePrintedLength() { [EOL]     return iValue.length(); [EOL] }
public int estimateParsedLength() { [EOL]     return iValue.length(); [EOL] }
public int estimateParsedLength() { [EOL]     return iValue.length(); [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     if (text.regionMatches(true, position, iValue, 0, iValue.length())) { [EOL]         return position + iValue.length(); [EOL]     } [EOL]     return ~position; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     if (text.regionMatches(true, position, iValue, 0, iValue.length())) { [EOL]         return position + iValue.length(); [EOL]     } [EOL]     return ~position; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     if (text.regionMatches(true, position, iValue, 0, iValue.length())) { [EOL]         return position + iValue.length(); [EOL]     } [EOL]     return ~position; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     if (text.regionMatches(true, position, iValue, 0, iValue.length())) { [EOL]         return position + iValue.length(); [EOL]     } [EOL]     return ~position; [EOL] }
NumberFormatter(DateTimeFieldType fieldType, int maxParsedDigits, boolean signed) { [EOL]     super(); [EOL]     iFieldType = fieldType; [EOL]     iMaxParsedDigits = maxParsedDigits; [EOL]     iSigned = signed; [EOL] }
NumberFormatter(DateTimeFieldType fieldType, int maxParsedDigits, boolean signed) { [EOL]     super(); [EOL]     iFieldType = fieldType; [EOL]     iMaxParsedDigits = maxParsedDigits; [EOL]     iSigned = signed; [EOL] }
NumberFormatter(DateTimeFieldType fieldType, int maxParsedDigits, boolean signed) { [EOL]     super(); [EOL]     iFieldType = fieldType; [EOL]     iMaxParsedDigits = maxParsedDigits; [EOL]     iSigned = signed; [EOL] }
public int estimateParsedLength() { [EOL]     return iMaxParsedDigits; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = Math.min(iMaxParsedDigits, text.length() - position); [EOL]     boolean negative = false; [EOL]     int length = 0; [EOL]     while (length < limit) { [EOL]         char c = text.charAt(position + length); [EOL]         if (length == 0 && (c == '-' || c == '+') && iSigned) { [EOL]             negative = c == '-'; [EOL]             if (length + 1 >= limit || (c = text.charAt(position + length + 1)) < '0' || c > '9') { [EOL]                 break; [EOL]             } [EOL]             if (negative) { [EOL]                 length++; [EOL]             } else { [EOL]                 position++; [EOL]             } [EOL]             limit = Math.min(limit + 1, text.length() - position); [EOL]             continue; [EOL]         } [EOL]         if (c < '0' || c > '9') { [EOL]             break; [EOL]         } [EOL]         length++; [EOL]     } [EOL]     if (length == 0) { [EOL]         return ~position; [EOL]     } [EOL]     int value; [EOL]     if (length >= 9) { [EOL]         value = Integer.parseInt(text.substring(position, position += length)); [EOL]     } else { [EOL]         int i = position; [EOL]         if (negative) { [EOL]             i++; [EOL]         } [EOL]         try { [EOL]             value = text.charAt(i++) - '0'; [EOL]         } catch (StringIndexOutOfBoundsException e) { [EOL]             return ~position; [EOL]         } [EOL]         position += length; [EOL]         while (i < position) { [EOL]             value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0'; [EOL]         } [EOL]         if (negative) { [EOL]             value = -value; [EOL]         } [EOL]     } [EOL]     bucket.saveField(iFieldType, value); [EOL]     return position; [EOL] }
protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits, boolean signed, int minPrintedDigits) { [EOL]     super(fieldType, maxParsedDigits, signed); [EOL]     iMinPrintedDigits = minPrintedDigits; [EOL] }
public int estimatePrintedLength() { [EOL]     return iMaxParsedDigits; [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     try { [EOL]         DateTimeField field = iFieldType.getField(chrono); [EOL]         FormatUtils.appendPaddedInteger(buf, field.get(instant), iMinPrintedDigits); [EOL]     } catch (RuntimeException e) { [EOL]         appendUnknownString(buf, iMinPrintedDigits); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) { [EOL]     if (partial.isSupported(iFieldType)) { [EOL]         try { [EOL]             FormatUtils.appendPaddedInteger(buf, partial.get(iFieldType), iMinPrintedDigits); [EOL]         } catch (RuntimeException e) { [EOL]             appendUnknownString(buf, iMinPrintedDigits); [EOL]         } [EOL]     } else { [EOL]         appendUnknownString(buf, iMinPrintedDigits); [EOL]     } [EOL] }
private String print(long instant, Chronology chrono, Locale locale) { [EOL]     DateTimeField field = iFieldType.getField(chrono); [EOL]     if (iShort) { [EOL]         return field.getAsShortText(instant, locale); [EOL]     } else { [EOL]         return field.getAsText(instant, locale); [EOL]     } [EOL] }
private String print(long instant, Chronology chrono, Locale locale) { [EOL]     DateTimeField field = iFieldType.getField(chrono); [EOL]     if (iShort) { [EOL]         return field.getAsShortText(instant, locale); [EOL]     } else { [EOL]         return field.getAsText(instant, locale); [EOL]     } [EOL] }
private String print(ReadablePartial partial, Locale locale) { [EOL]     if (partial.isSupported(iFieldType)) { [EOL]         DateTimeField field = iFieldType.getField(partial.getChronology()); [EOL]         if (iShort) { [EOL]             return field.getAsShortText(partial, locale); [EOL]         } else { [EOL]             return field.getAsText(partial, locale); [EOL]         } [EOL]     } else { [EOL]         return "\ufffd"; [EOL]     } [EOL] }
private String print(ReadablePartial partial, Locale locale) { [EOL]     if (partial.isSupported(iFieldType)) { [EOL]         DateTimeField field = iFieldType.getField(partial.getChronology()); [EOL]         if (iShort) { [EOL]             return field.getAsShortText(partial, locale); [EOL]         } else { [EOL]             return field.getAsText(partial, locale); [EOL]         } [EOL]     } else { [EOL]         return "\ufffd"; [EOL]     } [EOL] }
private String print(ReadablePartial partial, Locale locale) { [EOL]     if (partial.isSupported(iFieldType)) { [EOL]         DateTimeField field = iFieldType.getField(partial.getChronology()); [EOL]         if (iShort) { [EOL]             return field.getAsShortText(partial, locale); [EOL]         } else { [EOL]             return field.getAsText(partial, locale); [EOL]         } [EOL]     } else { [EOL]         return "\ufffd"; [EOL]     } [EOL] }
protected Fraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     super(); [EOL]     iFieldType = fieldType; [EOL]     if (maxDigits > 18) { [EOL]         maxDigits = 18; [EOL]     } [EOL]     iMinDigits = minDigits; [EOL]     iMaxDigits = maxDigits; [EOL] }
protected Fraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) { [EOL]     super(); [EOL]     iFieldType = fieldType; [EOL]     if (maxDigits > 18) { [EOL]         maxDigits = 18; [EOL]     } [EOL]     iMinDigits = minDigits; [EOL]     iMaxDigits = maxDigits; [EOL] }
public int estimatePrintedLength() { [EOL]     return iMaxDigits; [EOL] }
public int estimateParsedLength() { [EOL]     return iMaxDigits; [EOL] }
TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators, int minFields, int maxFields) { [EOL]     super(); [EOL]     iZeroOffsetPrintText = zeroOffsetPrintText; [EOL]     iZeroOffsetParseText = zeroOffsetParseText; [EOL]     iShowSeparators = showSeparators; [EOL]     if (minFields <= 0 || maxFields < minFields) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (minFields > 4) { [EOL]         minFields = 4; [EOL]         maxFields = 4; [EOL]     } [EOL]     iMinFields = minFields; [EOL]     iMaxFields = maxFields; [EOL] }
TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators, int minFields, int maxFields) { [EOL]     super(); [EOL]     iZeroOffsetPrintText = zeroOffsetPrintText; [EOL]     iZeroOffsetParseText = zeroOffsetParseText; [EOL]     iShowSeparators = showSeparators; [EOL]     if (minFields <= 0 || maxFields < minFields) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (minFields > 4) { [EOL]         minFields = 4; [EOL]         maxFields = 4; [EOL]     } [EOL]     iMinFields = minFields; [EOL]     iMaxFields = maxFields; [EOL] }
TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators, int minFields, int maxFields) { [EOL]     super(); [EOL]     iZeroOffsetPrintText = zeroOffsetPrintText; [EOL]     iZeroOffsetParseText = zeroOffsetParseText; [EOL]     iShowSeparators = showSeparators; [EOL]     if (minFields <= 0 || maxFields < minFields) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (minFields > 4) { [EOL]         minFields = 4; [EOL]         maxFields = 4; [EOL]     } [EOL]     iMinFields = minFields; [EOL]     iMaxFields = maxFields; [EOL] }
TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText, boolean showSeparators, int minFields, int maxFields) { [EOL]     super(); [EOL]     iZeroOffsetPrintText = zeroOffsetPrintText; [EOL]     iZeroOffsetParseText = zeroOffsetParseText; [EOL]     iShowSeparators = showSeparators; [EOL]     if (minFields <= 0 || maxFields < minFields) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     if (minFields > 4) { [EOL]         minFields = 4; [EOL]         maxFields = 4; [EOL]     } [EOL]     iMinFields = minFields; [EOL]     iMaxFields = maxFields; [EOL] }
public int estimatePrintedLength() { [EOL]     int est = 1 + iMinFields << 1; [EOL]     if (iShowSeparators) { [EOL]         est += iMinFields - 1; [EOL]     } [EOL]     if (iZeroOffsetPrintText != null && iZeroOffsetPrintText.length() > est) { [EOL]         est = iZeroOffsetPrintText.length(); [EOL]     } [EOL]     return est; [EOL] }
public int estimatePrintedLength() { [EOL]     int est = 1 + iMinFields << 1; [EOL]     if (iShowSeparators) { [EOL]         est += iMinFields - 1; [EOL]     } [EOL]     if (iZeroOffsetPrintText != null && iZeroOffsetPrintText.length() > est) { [EOL]         est = iZeroOffsetPrintText.length(); [EOL]     } [EOL]     return est; [EOL] }
public int estimatePrintedLength() { [EOL]     int est = 1 + iMinFields << 1; [EOL]     if (iShowSeparators) { [EOL]         est += iMinFields - 1; [EOL]     } [EOL]     if (iZeroOffsetPrintText != null && iZeroOffsetPrintText.length() > est) { [EOL]         est = iZeroOffsetPrintText.length(); [EOL]     } [EOL]     return est; [EOL] }
public int estimatePrintedLength() { [EOL]     int est = 1 + iMinFields << 1; [EOL]     if (iShowSeparators) { [EOL]         est += iMinFields - 1; [EOL]     } [EOL]     if (iZeroOffsetPrintText != null && iZeroOffsetPrintText.length() > est) { [EOL]         est = iZeroOffsetPrintText.length(); [EOL]     } [EOL]     return est; [EOL] }
public int estimatePrintedLength() { [EOL]     int est = 1 + iMinFields << 1; [EOL]     if (iShowSeparators) { [EOL]         est += iMinFields - 1; [EOL]     } [EOL]     if (iZeroOffsetPrintText != null && iZeroOffsetPrintText.length() > est) { [EOL]         est = iZeroOffsetPrintText.length(); [EOL]     } [EOL]     return est; [EOL] }
public int estimatePrintedLength() { [EOL]     int est = 1 + iMinFields << 1; [EOL]     if (iShowSeparators) { [EOL]         est += iMinFields - 1; [EOL]     } [EOL]     if (iZeroOffsetPrintText != null && iZeroOffsetPrintText.length() > est) { [EOL]         est = iZeroOffsetPrintText.length(); [EOL]     } [EOL]     return est; [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         buf.append(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields <= 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields <= 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields <= 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         buf.append('.'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, displayOffset, 3); [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         buf.append(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields <= 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields <= 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields <= 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         buf.append('.'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, displayOffset, 3); [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         buf.append(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields <= 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields <= 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields <= 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         buf.append('.'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, displayOffset, 3); [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         buf.append(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields <= 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields <= 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields <= 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         buf.append('.'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, displayOffset, 3); [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         buf.append(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields <= 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields <= 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields <= 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         buf.append('.'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, displayOffset, 3); [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         buf.append(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields <= 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields <= 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields <= 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         buf.append('.'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, displayOffset, 3); [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     if (displayZone == null) { [EOL]         return; [EOL]     } [EOL]     if (displayOffset == 0 && iZeroOffsetPrintText != null) { [EOL]         buf.append(iZeroOffsetPrintText); [EOL]         return; [EOL]     } [EOL]     if (displayOffset >= 0) { [EOL]         buf.append('+'); [EOL]     } else { [EOL]         buf.append('-'); [EOL]         displayOffset = -displayOffset; [EOL]     } [EOL]     int hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR; [EOL]     FormatUtils.appendPaddedInteger(buf, hours, 2); [EOL]     if (iMaxFields == 1) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR; [EOL]     if (displayOffset == 0 && iMinFields <= 1) { [EOL]         return; [EOL]     } [EOL]     int minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, minutes, 2); [EOL]     if (iMaxFields == 2) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]     if (displayOffset == 0 && iMinFields <= 2) { [EOL]         return; [EOL]     } [EOL]     int seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (iShowSeparators) { [EOL]         buf.append(':'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, seconds, 2); [EOL]     if (iMaxFields == 3) { [EOL]         return; [EOL]     } [EOL]     displayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]     if (displayOffset == 0 && iMinFields <= 3) { [EOL]         return; [EOL]     } [EOL]     if (iShowSeparators) { [EOL]         buf.append('.'); [EOL]     } [EOL]     FormatUtils.appendPaddedInteger(buf, displayOffset, 3); [EOL] }
public int estimateParsedLength() { [EOL]     return estimatePrintedLength(); [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     int limit = text.length() - position; [EOL]     zeroOffset: if (iZeroOffsetParseText != null) { [EOL]         if (iZeroOffsetParseText.length() == 0) { [EOL]             if (limit > 0) { [EOL]                 char c = text.charAt(position); [EOL]                 if (c == '-' || c == '+') { [EOL]                     break zeroOffset; [EOL]                 } [EOL]             } [EOL]             bucket.setOffset(Integer.valueOf(0)); [EOL]             return position; [EOL]         } [EOL]         if (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) { [EOL]             bucket.setOffset(Integer.valueOf(0)); [EOL]             return position + iZeroOffsetParseText.length(); [EOL]         } [EOL]     } [EOL]     if (limit <= 1) { [EOL]         return ~position; [EOL]     } [EOL]     boolean negative; [EOL]     char c = text.charAt(position); [EOL]     if (c == '-') { [EOL]         negative = true; [EOL]     } else if (c == '+') { [EOL]         negative = false; [EOL]     } else { [EOL]         return ~position; [EOL]     } [EOL]     limit--; [EOL]     position++; [EOL]     if (digitCount(text, position, 2) < 2) { [EOL]         return ~position; [EOL]     } [EOL]     int offset; [EOL]     int hours = FormatUtils.parseTwoDigits(text, position); [EOL]     if (hours > 23) { [EOL]         return ~position; [EOL]     } [EOL]     offset = hours * DateTimeConstants.MILLIS_PER_HOUR; [EOL]     limit -= 2; [EOL]     position += 2; [EOL]     parse: { [EOL]         if (limit <= 0) { [EOL]             break parse; [EOL]         } [EOL]         boolean expectSeparators; [EOL]         c = text.charAt(position); [EOL]         if (c == ':') { [EOL]             expectSeparators = true; [EOL]             limit--; [EOL]             position++; [EOL]         } else if (c >= '0' && c <= '9') { [EOL]             expectSeparators = false; [EOL]         } else { [EOL]             break parse; [EOL]         } [EOL]         int count = digitCount(text, position, 2); [EOL]         if (count == 0 && !expectSeparators) { [EOL]             break parse; [EOL]         } else if (count < 2) { [EOL]             return ~position; [EOL]         } [EOL]         int minutes = FormatUtils.parseTwoDigits(text, position); [EOL]         if (minutes > 59) { [EOL]             return ~position; [EOL]         } [EOL]         offset += minutes * DateTimeConstants.MILLIS_PER_MINUTE; [EOL]         limit -= 2; [EOL]         position += 2; [EOL]         if (limit <= 0) { [EOL]             break parse; [EOL]         } [EOL]         if (expectSeparators) { [EOL]             if (text.charAt(position) != ':') { [EOL]                 break parse; [EOL]             } [EOL]             limit--; [EOL]             position++; [EOL]         } [EOL]         count = digitCount(text, position, 2); [EOL]         if (count == 0 && !expectSeparators) { [EOL]             break parse; [EOL]         } else if (count < 2) { [EOL]             return ~position; [EOL]         } [EOL]         int seconds = FormatUtils.parseTwoDigits(text, position); [EOL]         if (seconds > 59) { [EOL]             return ~position; [EOL]         } [EOL]         offset += seconds * DateTimeConstants.MILLIS_PER_SECOND; [EOL]         limit -= 2; [EOL]         position += 2; [EOL]         if (limit <= 0) { [EOL]             break parse; [EOL]         } [EOL]         if (expectSeparators) { [EOL]             if (text.charAt(position) != '.' && text.charAt(position) != ',') { [EOL]                 break parse; [EOL]             } [EOL]             limit--; [EOL]             position++; [EOL]         } [EOL]         count = digitCount(text, position, 3); [EOL]         if (count == 0 && !expectSeparators) { [EOL]             break parse; [EOL]         } else if (count < 1) { [EOL]             return ~position; [EOL]         } [EOL]         offset += (text.charAt(position++) - '0') * 100; [EOL]         if (count > 1) { [EOL]             offset += (text.charAt(position++) - '0') * 10; [EOL]             if (count > 2) { [EOL]                 offset += text.charAt(position++) - '0'; [EOL]             } [EOL]         } [EOL]     } [EOL]     bucket.setOffset(Integer.valueOf(negative ? -offset : offset)); [EOL]     return position; [EOL] }
private int digitCount(String text, int position, int amount) { [EOL]     int limit = Math.min(text.length() - position, amount); [EOL]     amount = 0; [EOL]     for (; limit > 0; limit--) { [EOL]         char c = text.charAt(position + amount); [EOL]         if (c < '0' || c > '9') { [EOL]             break; [EOL]         } [EOL]         amount++; [EOL]     } [EOL]     return amount; [EOL] }
Composite(List<Object> elementPairs) { [EOL]     super(); [EOL]     List<Object> printerList = new ArrayList<Object>(); [EOL]     List<Object> parserList = new ArrayList<Object>(); [EOL]     decompose(elementPairs, printerList, parserList); [EOL]     if (printerList.contains(null) || printerList.isEmpty()) { [EOL]         iPrinters = null; [EOL]         iPrintedLengthEstimate = 0; [EOL]     } else { [EOL]         int size = printerList.size(); [EOL]         iPrinters = new DateTimePrinter[size]; [EOL]         int printEst = 0; [EOL]         for (int i = 0; i < size; i++) { [EOL]             DateTimePrinter printer = (DateTimePrinter) printerList.get(i); [EOL]             printEst += printer.estimatePrintedLength(); [EOL]             iPrinters[i] = printer; [EOL]         } [EOL]         iPrintedLengthEstimate = printEst; [EOL]     } [EOL]     if (parserList.contains(null) || parserList.isEmpty()) { [EOL]         iParsers = null; [EOL]         iParsedLengthEstimate = 0; [EOL]     } else { [EOL]         int size = parserList.size(); [EOL]         iParsers = new DateTimeParser[size]; [EOL]         int parseEst = 0; [EOL]         for (int i = 0; i < size; i++) { [EOL]             DateTimeParser parser = (DateTimeParser) parserList.get(i); [EOL]             parseEst += parser.estimateParsedLength(); [EOL]             iParsers[i] = parser; [EOL]         } [EOL]         iParsedLengthEstimate = parseEst; [EOL]     } [EOL] }
Composite(List<Object> elementPairs) { [EOL]     super(); [EOL]     List<Object> printerList = new ArrayList<Object>(); [EOL]     List<Object> parserList = new ArrayList<Object>(); [EOL]     decompose(elementPairs, printerList, parserList); [EOL]     if (printerList.contains(null) || printerList.isEmpty()) { [EOL]         iPrinters = null; [EOL]         iPrintedLengthEstimate = 0; [EOL]     } else { [EOL]         int size = printerList.size(); [EOL]         iPrinters = new DateTimePrinter[size]; [EOL]         int printEst = 0; [EOL]         for (int i = 0; i < size; i++) { [EOL]             DateTimePrinter printer = (DateTimePrinter) printerList.get(i); [EOL]             printEst += printer.estimatePrintedLength(); [EOL]             iPrinters[i] = printer; [EOL]         } [EOL]         iPrintedLengthEstimate = printEst; [EOL]     } [EOL]     if (parserList.contains(null) || parserList.isEmpty()) { [EOL]         iParsers = null; [EOL]         iParsedLengthEstimate = 0; [EOL]     } else { [EOL]         int size = parserList.size(); [EOL]         iParsers = new DateTimeParser[size]; [EOL]         int parseEst = 0; [EOL]         for (int i = 0; i < size; i++) { [EOL]             DateTimeParser parser = (DateTimeParser) parserList.get(i); [EOL]             parseEst += parser.estimateParsedLength(); [EOL]             iParsers[i] = parser; [EOL]         } [EOL]         iParsedLengthEstimate = parseEst; [EOL]     } [EOL] }
Composite(List<Object> elementPairs) { [EOL]     super(); [EOL]     List<Object> printerList = new ArrayList<Object>(); [EOL]     List<Object> parserList = new ArrayList<Object>(); [EOL]     decompose(elementPairs, printerList, parserList); [EOL]     if (printerList.contains(null) || printerList.isEmpty()) { [EOL]         iPrinters = null; [EOL]         iPrintedLengthEstimate = 0; [EOL]     } else { [EOL]         int size = printerList.size(); [EOL]         iPrinters = new DateTimePrinter[size]; [EOL]         int printEst = 0; [EOL]         for (int i = 0; i < size; i++) { [EOL]             DateTimePrinter printer = (DateTimePrinter) printerList.get(i); [EOL]             printEst += printer.estimatePrintedLength(); [EOL]             iPrinters[i] = printer; [EOL]         } [EOL]         iPrintedLengthEstimate = printEst; [EOL]     } [EOL]     if (parserList.contains(null) || parserList.isEmpty()) { [EOL]         iParsers = null; [EOL]         iParsedLengthEstimate = 0; [EOL]     } else { [EOL]         int size = parserList.size(); [EOL]         iParsers = new DateTimeParser[size]; [EOL]         int parseEst = 0; [EOL]         for (int i = 0; i < size; i++) { [EOL]             DateTimeParser parser = (DateTimeParser) parserList.get(i); [EOL]             parseEst += parser.estimateParsedLength(); [EOL]             iParsers[i] = parser; [EOL]         } [EOL]         iParsedLengthEstimate = parseEst; [EOL]     } [EOL] }
Composite(List<Object> elementPairs) { [EOL]     super(); [EOL]     List<Object> printerList = new ArrayList<Object>(); [EOL]     List<Object> parserList = new ArrayList<Object>(); [EOL]     decompose(elementPairs, printerList, parserList); [EOL]     if (printerList.contains(null) || printerList.isEmpty()) { [EOL]         iPrinters = null; [EOL]         iPrintedLengthEstimate = 0; [EOL]     } else { [EOL]         int size = printerList.size(); [EOL]         iPrinters = new DateTimePrinter[size]; [EOL]         int printEst = 0; [EOL]         for (int i = 0; i < size; i++) { [EOL]             DateTimePrinter printer = (DateTimePrinter) printerList.get(i); [EOL]             printEst += printer.estimatePrintedLength(); [EOL]             iPrinters[i] = printer; [EOL]         } [EOL]         iPrintedLengthEstimate = printEst; [EOL]     } [EOL]     if (parserList.contains(null) || parserList.isEmpty()) { [EOL]         iParsers = null; [EOL]         iParsedLengthEstimate = 0; [EOL]     } else { [EOL]         int size = parserList.size(); [EOL]         iParsers = new DateTimeParser[size]; [EOL]         int parseEst = 0; [EOL]         for (int i = 0; i < size; i++) { [EOL]             DateTimeParser parser = (DateTimeParser) parserList.get(i); [EOL]             parseEst += parser.estimateParsedLength(); [EOL]             iParsers[i] = parser; [EOL]         } [EOL]         iParsedLengthEstimate = parseEst; [EOL]     } [EOL] }
public int estimatePrintedLength() { [EOL]     return iPrintedLengthEstimate; [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     DateTimePrinter[] elements = iPrinters; [EOL]     if (elements == null) { [EOL]         throw new UnsupportedOperationException(); [EOL]     } [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     int len = elements.length; [EOL]     for (int i = 0; i < len; i++) { [EOL]         elements[i].printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     DateTimePrinter[] elements = iPrinters; [EOL]     if (elements == null) { [EOL]         throw new UnsupportedOperationException(); [EOL]     } [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     int len = elements.length; [EOL]     for (int i = 0; i < len; i++) { [EOL]         elements[i].printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL]     } [EOL] }
public void printTo(StringBuffer buf, long instant, Chronology chrono, int displayOffset, DateTimeZone displayZone, Locale locale) { [EOL]     DateTimePrinter[] elements = iPrinters; [EOL]     if (elements == null) { [EOL]         throw new UnsupportedOperationException(); [EOL]     } [EOL]     if (locale == null) { [EOL]         locale = Locale.getDefault(); [EOL]     } [EOL]     int len = elements.length; [EOL]     for (int i = 0; i < len; i++) { [EOL]         elements[i].printTo(buf, instant, chrono, displayOffset, displayZone, locale); [EOL]     } [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     DateTimeParser[] elements = iParsers; [EOL]     if (elements == null) { [EOL]         throw new UnsupportedOperationException(); [EOL]     } [EOL]     int len = elements.length; [EOL]     for (int i = 0; i < len && position >= 0; i++) { [EOL]         position = elements[i].parseInto(bucket, text, position); [EOL]     } [EOL]     return position; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     DateTimeParser[] elements = iParsers; [EOL]     if (elements == null) { [EOL]         throw new UnsupportedOperationException(); [EOL]     } [EOL]     int len = elements.length; [EOL]     for (int i = 0; i < len && position >= 0; i++) { [EOL]         position = elements[i].parseInto(bucket, text, position); [EOL]     } [EOL]     return position; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     DateTimeParser[] elements = iParsers; [EOL]     if (elements == null) { [EOL]         throw new UnsupportedOperationException(); [EOL]     } [EOL]     int len = elements.length; [EOL]     for (int i = 0; i < len && position >= 0; i++) { [EOL]         position = elements[i].parseInto(bucket, text, position); [EOL]     } [EOL]     return position; [EOL] }
public int parseInto(DateTimeParserBucket bucket, String text, int position) { [EOL]     DateTimeParser[] elements = iParsers; [EOL]     if (elements == null) { [EOL]         throw new UnsupportedOperationException(); [EOL]     } [EOL]     int len = elements.length; [EOL]     for (int i = 0; i < len && position >= 0; i++) { [EOL]         position = elements[i].parseInto(bucket, text, position); [EOL]     } [EOL]     return position; [EOL] }
boolean isPrinter() { [EOL]     return iPrinters != null; [EOL] }
boolean isPrinter() { [EOL]     return iPrinters != null; [EOL] }
boolean isParser() { [EOL]     return iParsers != null; [EOL] }
boolean isParser() { [EOL]     return iParsers != null; [EOL] }
private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) { [EOL]     int size = elementPairs.size(); [EOL]     for (int i = 0; i < size; i += 2) { [EOL]         Object element = elementPairs.get(i); [EOL]         if (element instanceof Composite) { [EOL]             addArrayToList(printerList, ((Composite) element).iPrinters); [EOL]         } else { [EOL]             printerList.add(element); [EOL]         } [EOL]         element = elementPairs.get(i + 1); [EOL]         if (element instanceof Composite) { [EOL]             addArrayToList(parserList, ((Composite) element).iParsers); [EOL]         } else { [EOL]             parserList.add(element); [EOL]         } [EOL]     } [EOL] }
private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) { [EOL]     int size = elementPairs.size(); [EOL]     for (int i = 0; i < size; i += 2) { [EOL]         Object element = elementPairs.get(i); [EOL]         if (element instanceof Composite) { [EOL]             addArrayToList(printerList, ((Composite) element).iPrinters); [EOL]         } else { [EOL]             printerList.add(element); [EOL]         } [EOL]         element = elementPairs.get(i + 1); [EOL]         if (element instanceof Composite) { [EOL]             addArrayToList(parserList, ((Composite) element).iParsers); [EOL]         } else { [EOL]             parserList.add(element); [EOL]         } [EOL]     } [EOL] }
private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) { [EOL]     int size = elementPairs.size(); [EOL]     for (int i = 0; i < size; i += 2) { [EOL]         Object element = elementPairs.get(i); [EOL]         if (element instanceof Composite) { [EOL]             addArrayToList(printerList, ((Composite) element).iPrinters); [EOL]         } else { [EOL]             printerList.add(element); [EOL]         } [EOL]         element = elementPairs.get(i + 1); [EOL]         if (element instanceof Composite) { [EOL]             addArrayToList(parserList, ((Composite) element).iParsers); [EOL]         } else { [EOL]             parserList.add(element); [EOL]         } [EOL]     } [EOL] }
private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) { [EOL]     int size = elementPairs.size(); [EOL]     for (int i = 0; i < size; i += 2) { [EOL]         Object element = elementPairs.get(i); [EOL]         if (element instanceof Composite) { [EOL]             addArrayToList(printerList, ((Composite) element).iPrinters); [EOL]         } else { [EOL]             printerList.add(element); [EOL]         } [EOL]         element = elementPairs.get(i + 1); [EOL]         if (element instanceof Composite) { [EOL]             addArrayToList(parserList, ((Composite) element).iParsers); [EOL]         } else { [EOL]             parserList.add(element); [EOL]         } [EOL]     } [EOL] }
private void addArrayToList(List<Object> list, Object[] array) { [EOL]     if (array != null) { [EOL]         for (int i = 0; i < array.length; i++) { [EOL]             list.add(array[i]); [EOL]         } [EOL]     } [EOL] }
private void addArrayToList(List<Object> list, Object[] array) { [EOL]     if (array != null) { [EOL]         for (int i = 0; i < array.length; i++) { [EOL]             list.add(array[i]); [EOL]         } [EOL]     } [EOL] }
public static TimeOfDay fromCalendarFields(Calendar calendar) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The calendar must not be null"); [EOL]     } [EOL]     return new TimeOfDay(calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND)); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public static TimeOfDay fromCalendarFields(Calendar calendar) { [EOL]     if (calendar == null) { [EOL]         throw new IllegalArgumentException("The calendar must not be null"); [EOL]     } [EOL]     return new TimeOfDay(calendar.get(Calendar.HOUR_OF_DAY), calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND), calendar.get(Calendar.MILLISECOND)); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(DateTimeZone zone) { [EOL]     super(ISOChronology.getInstance(zone)); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.timeParser()); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.timeParser()); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.timeParser()); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.timeParser()); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.timeParser()); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.timeParser()); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.timeParser()); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.timeParser()); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.timeParser()); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.timeParser()); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.timeParser()); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.timeParser()); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.timeParser()); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.timeParser()); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.timeParser()); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.timeParser()); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.timeParser()); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.timeParser()); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(Object instant, Chronology chronology) { [EOL]     super(instant, DateTimeUtils.getChronology(chronology), ISODateTimeFormat.timeParser()); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology) { [EOL]     this(hourOfDay, minuteOfHour, 0, 0, chronology); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public DateTimeFieldType getFieldType(int index) { [EOL]     return FIELD_TYPES[index]; [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay withChronologyRetainFields(Chronology newChronology) { [EOL]     newChronology = DateTimeUtils.getChronology(newChronology); [EOL]     newChronology = newChronology.withUTC(); [EOL]     if (newChronology == getChronology()) { [EOL]         return this; [EOL]     } else { [EOL]         TimeOfDay newTimeOfDay = new TimeOfDay(this, newChronology); [EOL]         newChronology.validate(newTimeOfDay, getValues()); [EOL]         return newTimeOfDay; [EOL]     } [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay withChronologyRetainFields(Chronology newChronology) { [EOL]     newChronology = DateTimeUtils.getChronology(newChronology); [EOL]     newChronology = newChronology.withUTC(); [EOL]     if (newChronology == getChronology()) { [EOL]         return this; [EOL]     } else { [EOL]         TimeOfDay newTimeOfDay = new TimeOfDay(this, newChronology); [EOL]         newChronology.validate(newTimeOfDay, getValues()); [EOL]         return newTimeOfDay; [EOL]     } [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay withField(DateTimeFieldType fieldType, int value) { [EOL]     int index = indexOfSupported(fieldType); [EOL]     if (value == getValue(index)) { [EOL]         return this; [EOL]     } [EOL]     int[] newValues = getValues(); [EOL]     newValues = getField(index).set(this, index, newValues, value); [EOL]     return new TimeOfDay(this, newValues); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay plus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, 1); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay plus(ReadablePeriod period) { [EOL]     return withPeriodAdded(period, 1); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay plusHours(int hours) { [EOL]     return withFieldAdded(DurationFieldType.hours(), hours); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay plusHours(int hours) { [EOL]     return withFieldAdded(DurationFieldType.hours(), hours); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay plusMinutes(int minutes) { [EOL]     return withFieldAdded(DurationFieldType.minutes(), minutes); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public TimeOfDay minusHours(int hours) { [EOL]     return withFieldAdded(DurationFieldType.hours(), FieldUtils.safeNegate(hours)); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public DateTime toDateTimeToday(DateTimeZone zone) { [EOL]     Chronology chrono = getChronology().withZone(zone); [EOL]     long instantMillis = DateTimeUtils.currentTimeMillis(); [EOL]     long resolved = chrono.set(this, instantMillis); [EOL]     return new DateTime(resolved, chrono); [EOL] } public TimeOfDay(); public TimeOfDay(DateTimeZone zone); public TimeOfDay(Chronology chronology); public TimeOfDay(long instant); public TimeOfDay(long instant, Chronology chronology); public TimeOfDay(Object instant); public TimeOfDay(Object instant, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour); public TimeOfDay(int hourOfDay, int minuteOfHour, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, Chronology chronology); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond); public TimeOfDay(int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond, Chronology chronology);  TimeOfDay(TimeOfDay partial, int[] values);  TimeOfDay(TimeOfDay partial, Chronology chrono);  Property(TimeOfDay partial, int fieldIndex); public static TimeOfDay fromCalendarFields(Calendar calendar); public static TimeOfDay fromDateFields(Date date); public static TimeOfDay fromMillisOfDay(long millisOfDay); public static TimeOfDay fromMillisOfDay(long millisOfDay, Chronology chrono); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public TimeOfDay withChronologyRetainFields(Chronology newChronology); public TimeOfDay withField(DateTimeFieldType fieldType, int value); public TimeOfDay withFieldAdded(DurationFieldType fieldType, int amount); public TimeOfDay withPeriodAdded(ReadablePeriod period, int scalar); public TimeOfDay plus(ReadablePeriod period); public TimeOfDay plusHours(int hours); public TimeOfDay plusMinutes(int minutes); public TimeOfDay plusSeconds(int seconds); public TimeOfDay plusMillis(int millis); public TimeOfDay minus(ReadablePeriod period); public TimeOfDay minusHours(int hours); public TimeOfDay minusMinutes(int minutes); public TimeOfDay minusSeconds(int seconds); public TimeOfDay minusMillis(int millis); public Property property(DateTimeFieldType type); public LocalTime toLocalTime(); public DateTime toDateTimeToday(); public DateTime toDateTimeToday(DateTimeZone zone); public int getHourOfDay(); public int getMinuteOfHour(); public int getSecondOfMinute(); public int getMillisOfSecond(); public TimeOfDay withHourOfDay(int hour); public TimeOfDay withMinuteOfHour(int minute); public TimeOfDay withSecondOfMinute(int second); public TimeOfDay withMillisOfSecond(int millis); public Property hourOfDay(); public Property minuteOfHour(); public Property secondOfMinute(); public Property millisOfSecond(); public String toString(); public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public TimeOfDay getTimeOfDay(); public int get(); public TimeOfDay addToCopy(int valueToAdd); public TimeOfDay addNoWrapToCopy(int valueToAdd); public TimeOfDay addWrapFieldToCopy(int valueToAdd); public TimeOfDay setCopy(int value); public TimeOfDay setCopy(String text, Locale locale); public TimeOfDay setCopy(String text); public TimeOfDay withMaximumValue(); public TimeOfDay withMinimumValue(); long serialVersionUID=Optional[3633353405803318660L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.hourOfDay(), DateTimeFieldType.minuteOfHour(), DateTimeFieldType.secondOfMinute(), DateTimeFieldType.millisOfSecond() }
public boolean contains(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return containsNow(); [EOL]     } [EOL]     return contains(instant.getMillis()); [EOL] }
public boolean contains(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return containsNow(); [EOL]     } [EOL]     return contains(instant.getMillis()); [EOL] }
public boolean isEqual(ReadableInterval other) { [EOL]     return getStartMillis() == other.getStartMillis() && getEndMillis() == other.getEndMillis(); [EOL] }
public boolean isEqual(ReadableInterval other) { [EOL]     return getStartMillis() == other.getStartMillis() && getEndMillis() == other.getEndMillis(); [EOL] }
public boolean isEqual(ReadableInterval other) { [EOL]     return getStartMillis() == other.getStartMillis() && getEndMillis() == other.getEndMillis(); [EOL] }
public boolean isEqual(ReadableInterval other) { [EOL]     return getStartMillis() == other.getStartMillis() && getEndMillis() == other.getEndMillis(); [EOL] }
public boolean isBefore(long millisInstant) { [EOL]     return (getEndMillis() <= millisInstant); [EOL] }
public boolean isBefore(long millisInstant) { [EOL]     return (getEndMillis() <= millisInstant); [EOL] }
public boolean isBefore(long millisInstant) { [EOL]     return (getEndMillis() <= millisInstant); [EOL] }
public boolean isBeforeNow() { [EOL]     return isBefore(DateTimeUtils.currentTimeMillis()); [EOL] }
public boolean isBefore(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return isBeforeNow(); [EOL]     } [EOL]     return isBefore(instant.getMillis()); [EOL] }
public boolean isBefore(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return isBeforeNow(); [EOL]     } [EOL]     return isBefore(instant.getMillis()); [EOL] }
public boolean isBefore(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return isBeforeNow(); [EOL]     } [EOL]     return isBefore(instant.getMillis()); [EOL] }
public boolean isAfter(long millisInstant) { [EOL]     return (getStartMillis() > millisInstant); [EOL] }
public boolean isAfter(long millisInstant) { [EOL]     return (getStartMillis() > millisInstant); [EOL] }
public boolean isAfter(long millisInstant) { [EOL]     return (getStartMillis() > millisInstant); [EOL] }
public boolean isAfterNow() { [EOL]     return isAfter(DateTimeUtils.currentTimeMillis()); [EOL] }
public boolean isAfterNow() { [EOL]     return isAfter(DateTimeUtils.currentTimeMillis()); [EOL] }
public boolean isAfterNow() { [EOL]     return isAfter(DateTimeUtils.currentTimeMillis()); [EOL] }
public boolean isAfter(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return isAfterNow(); [EOL]     } [EOL]     return isAfter(instant.getMillis()); [EOL] }
public boolean isAfter(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return isAfterNow(); [EOL]     } [EOL]     return isAfter(instant.getMillis()); [EOL] }
public boolean isAfter(ReadableInstant instant) { [EOL]     if (instant == null) { [EOL]         return isAfterNow(); [EOL]     } [EOL]     return isAfter(instant.getMillis()); [EOL] }
public boolean isAfter(ReadableInterval interval) { [EOL]     long endMillis; [EOL]     if (interval == null) { [EOL]         endMillis = DateTimeUtils.currentTimeMillis(); [EOL]     } else { [EOL]         endMillis = interval.getEndMillis(); [EOL]     } [EOL]     return (getStartMillis() >= endMillis); [EOL] }
public boolean isAfter(ReadableInterval interval) { [EOL]     long endMillis; [EOL]     if (interval == null) { [EOL]         endMillis = DateTimeUtils.currentTimeMillis(); [EOL]     } else { [EOL]         endMillis = interval.getEndMillis(); [EOL]     } [EOL]     return (getStartMillis() >= endMillis); [EOL] }
public boolean isAfter(ReadableInterval interval) { [EOL]     long endMillis; [EOL]     if (interval == null) { [EOL]         endMillis = DateTimeUtils.currentTimeMillis(); [EOL]     } else { [EOL]         endMillis = interval.getEndMillis(); [EOL]     } [EOL]     return (getStartMillis() >= endMillis); [EOL] }
public Interval toInterval() { [EOL]     return new Interval(getStartMillis(), getEndMillis(), getChronology()); [EOL] }
public Period toPeriod(PeriodType type) { [EOL]     return new Period(getStartMillis(), getEndMillis(), type, getChronology()); [EOL] }
public Period toPeriod(PeriodType type) { [EOL]     return new Period(getStartMillis(), getEndMillis(), type, getChronology()); [EOL] }
public boolean equals(Object readableInterval) { [EOL]     if (this == readableInterval) { [EOL]         return true; [EOL]     } [EOL]     if (readableInterval instanceof ReadableInterval == false) { [EOL]         return false; [EOL]     } [EOL]     ReadableInterval other = (ReadableInterval) readableInterval; [EOL]     return getStartMillis() == other.getStartMillis() && getEndMillis() == other.getEndMillis() && FieldUtils.equals(getChronology(), other.getChronology()); [EOL] }
public boolean equals(Object readableInterval) { [EOL]     if (this == readableInterval) { [EOL]         return true; [EOL]     } [EOL]     if (readableInterval instanceof ReadableInterval == false) { [EOL]         return false; [EOL]     } [EOL]     ReadableInterval other = (ReadableInterval) readableInterval; [EOL]     return getStartMillis() == other.getStartMillis() && getEndMillis() == other.getEndMillis() && FieldUtils.equals(getChronology(), other.getChronology()); [EOL] }
public boolean equals(Object readableInterval) { [EOL]     if (this == readableInterval) { [EOL]         return true; [EOL]     } [EOL]     if (readableInterval instanceof ReadableInterval == false) { [EOL]         return false; [EOL]     } [EOL]     ReadableInterval other = (ReadableInterval) readableInterval; [EOL]     return getStartMillis() == other.getStartMillis() && getEndMillis() == other.getEndMillis() && FieldUtils.equals(getChronology(), other.getChronology()); [EOL] }
public boolean equals(Object readableInterval) { [EOL]     if (this == readableInterval) { [EOL]         return true; [EOL]     } [EOL]     if (readableInterval instanceof ReadableInterval == false) { [EOL]         return false; [EOL]     } [EOL]     ReadableInterval other = (ReadableInterval) readableInterval; [EOL]     return getStartMillis() == other.getStartMillis() && getEndMillis() == other.getEndMillis() && FieldUtils.equals(getChronology(), other.getChronology()); [EOL] }
public boolean equals(Object readableInterval) { [EOL]     if (this == readableInterval) { [EOL]         return true; [EOL]     } [EOL]     if (readableInterval instanceof ReadableInterval == false) { [EOL]         return false; [EOL]     } [EOL]     ReadableInterval other = (ReadableInterval) readableInterval; [EOL]     return getStartMillis() == other.getStartMillis() && getEndMillis() == other.getEndMillis() && FieldUtils.equals(getChronology(), other.getChronology()); [EOL] }
public boolean equals(Object readableInterval) { [EOL]     if (this == readableInterval) { [EOL]         return true; [EOL]     } [EOL]     if (readableInterval instanceof ReadableInterval == false) { [EOL]         return false; [EOL]     } [EOL]     ReadableInterval other = (ReadableInterval) readableInterval; [EOL]     return getStartMillis() == other.getStartMillis() && getEndMillis() == other.getEndMillis() && FieldUtils.equals(getChronology(), other.getChronology()); [EOL] }
public boolean equals(Object readableInterval) { [EOL]     if (this == readableInterval) { [EOL]         return true; [EOL]     } [EOL]     if (readableInterval instanceof ReadableInterval == false) { [EOL]         return false; [EOL]     } [EOL]     ReadableInterval other = (ReadableInterval) readableInterval; [EOL]     return getStartMillis() == other.getStartMillis() && getEndMillis() == other.getEndMillis() && FieldUtils.equals(getChronology(), other.getChronology()); [EOL] }
public String toString() { [EOL]     DateTimeFormatter printer = ISODateTimeFormat.dateTime(); [EOL]     printer = printer.withChronology(getChronology()); [EOL]     StringBuffer buf = new StringBuffer(48); [EOL]     printer.printTo(buf, getStartMillis()); [EOL]     buf.append('/'); [EOL]     printer.printTo(buf, getEndMillis()); [EOL]     return buf.toString(); [EOL] }
public int[] getValues() { [EOL]     int[] result = new int[size()]; [EOL]     for (int i = 0; i < result.length; i++) { [EOL]         result[i] = getValue(i); [EOL]     } [EOL]     return result; [EOL] }
public int[] getValues() { [EOL]     int[] result = new int[size()]; [EOL]     for (int i = 0; i < result.length; i++) { [EOL]         result[i] = getValue(i); [EOL]     } [EOL]     return result; [EOL] }
public int get(DurationFieldType type) { [EOL]     int index = indexOf(type); [EOL]     if (index == -1) { [EOL]         return 0; [EOL]     } [EOL]     return getValue(index); [EOL] }
public int get(DurationFieldType type) { [EOL]     int index = indexOf(type); [EOL]     if (index == -1) { [EOL]         return 0; [EOL]     } [EOL]     return getValue(index); [EOL] }
@ToString [EOL] public String toString() { [EOL]     return ISOPeriodFormat.standard().print(this); [EOL] }
public String toString(PeriodFormatter formatter) { [EOL]     if (formatter == null) { [EOL]         return toString(); [EOL]     } [EOL]     return formatter.print(this); [EOL] }
public String toString(PeriodFormatter formatter) { [EOL]     if (formatter == null) { [EOL]         return toString(); [EOL]     } [EOL]     return formatter.print(this); [EOL] }
public MutablePeriod(PeriodType type) { [EOL]     super(0L, type, null); [EOL] }
public MutablePeriod(PeriodType type) { [EOL]     super(0L, type, null); [EOL] }
public MutablePeriod(int years, int months, int weeks, int days, int hours, int minutes, int seconds, int millis, PeriodType type) { [EOL]     super(years, months, weeks, days, hours, minutes, seconds, millis, type); [EOL] }
public MutablePeriod(long duration) { [EOL]     super(duration); [EOL] }
public MutablePeriod(long duration) { [EOL]     super(duration); [EOL] }
public MutablePeriod(long duration) { [EOL]     super(duration); [EOL] }
public MutablePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) { [EOL]     super(startInstant, endInstant, type); [EOL] }
public MutablePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) { [EOL]     super(startInstant, endInstant, type); [EOL] }
public MutablePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) { [EOL]     super(startInstant, endInstant, type); [EOL] }
public MutablePeriod(ReadableInstant startInstant, ReadableInstant endInstant, PeriodType type) { [EOL]     super(startInstant, endInstant, type); [EOL] }
public MutablePeriod(ReadableInstant startInstant, ReadableDuration duration) { [EOL]     super(startInstant, duration, null); [EOL] }
public MutablePeriod(ReadableInstant startInstant, ReadableDuration duration) { [EOL]     super(startInstant, duration, null); [EOL] }
public MutablePeriod(ReadableInstant startInstant, ReadableDuration duration) { [EOL]     super(startInstant, duration, null); [EOL] }
public MutablePeriod(Object period, Chronology chrono) { [EOL]     super(period, null, chrono); [EOL] }
public MutablePeriod(Object period, Chronology chrono) { [EOL]     super(period, null, chrono); [EOL] }
public MutablePeriod(Object period, Chronology chrono) { [EOL]     super(period, null, chrono); [EOL] }
public void setValue(int index, int value) { [EOL]     super.setValue(index, value); [EOL] }
public void set(DurationFieldType field, int value) { [EOL]     super.setField(field, value); [EOL] }
public void set(DurationFieldType field, int value) { [EOL]     super.setField(field, value); [EOL] }
public void setPeriod(ReadableInstant start, ReadableInstant end) { [EOL]     if (start == end) { [EOL]         setPeriod(0L); [EOL]     } else { [EOL]         long startMillis = DateTimeUtils.getInstantMillis(start); [EOL]         long endMillis = DateTimeUtils.getInstantMillis(end); [EOL]         Chronology chrono = DateTimeUtils.getIntervalChronology(start, end); [EOL]         setPeriod(startMillis, endMillis, chrono); [EOL]     } [EOL] }
public void setPeriod(ReadableInstant start, ReadableInstant end) { [EOL]     if (start == end) { [EOL]         setPeriod(0L); [EOL]     } else { [EOL]         long startMillis = DateTimeUtils.getInstantMillis(start); [EOL]         long endMillis = DateTimeUtils.getInstantMillis(end); [EOL]         Chronology chrono = DateTimeUtils.getIntervalChronology(start, end); [EOL]         setPeriod(startMillis, endMillis, chrono); [EOL]     } [EOL] }
public void setPeriod(long startInstant, long endInstant) { [EOL]     setPeriod(startInstant, endInstant, null); [EOL] }
public void add(ReadablePeriod period) { [EOL]     super.addPeriod(period); [EOL] }
public void add(ReadablePeriod period) { [EOL]     super.addPeriod(period); [EOL] }
public void add(ReadableInterval interval) { [EOL]     if (interval != null) { [EOL]         add(interval.toPeriod(getPeriodType())); [EOL]     } [EOL] }
public void add(ReadableInterval interval) { [EOL]     if (interval != null) { [EOL]         add(interval.toPeriod(getPeriodType())); [EOL]     } [EOL] }
public void add(ReadableDuration duration) { [EOL]     if (duration != null) { [EOL]         add(new Period(duration.getMillis(), getPeriodType())); [EOL]     } [EOL] }
public void add(ReadableDuration duration) { [EOL]     if (duration != null) { [EOL]         add(new Period(duration.getMillis(), getPeriodType())); [EOL]     } [EOL] }
public void setYears(int years) { [EOL]     super.setField(DurationFieldType.years(), years); [EOL] }
public void setYears(int years) { [EOL]     super.setField(DurationFieldType.years(), years); [EOL] }
public void setYears(int years) { [EOL]     super.setField(DurationFieldType.years(), years); [EOL] }
public void addMonths(int months) { [EOL]     super.addField(DurationFieldType.months(), months); [EOL] }
public void addMonths(int months) { [EOL]     super.addField(DurationFieldType.months(), months); [EOL] }
public void addMonths(int months) { [EOL]     super.addField(DurationFieldType.months(), months); [EOL] }
public void addWeeks(int weeks) { [EOL]     super.addField(DurationFieldType.weeks(), weeks); [EOL] }
public void addWeeks(int weeks) { [EOL]     super.addField(DurationFieldType.weeks(), weeks); [EOL] }
public void addWeeks(int weeks) { [EOL]     super.addField(DurationFieldType.weeks(), weeks); [EOL] }
public void addMillis(int millis) { [EOL]     super.addField(DurationFieldType.millis(), millis); [EOL] }
public long set(long instant, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, getMinimumValue(), getMaximumValueForSet(instant, value)); [EOL]     return instant + (value - get(instant)) * iUnitMillis; [EOL] }
public long set(long instant, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, getMinimumValue(), getMaximumValueForSet(instant, value)); [EOL]     return instant + (value - get(instant)) * iUnitMillis; [EOL] }
public long set(long instant, int value) { [EOL]     FieldUtils.verifyValueBounds(this, value, getMinimumValue(), getMaximumValueForSet(instant, value)); [EOL]     return instant + (value - get(instant)) * iUnitMillis; [EOL] }
public DurationField getDurationField() { [EOL]     return iUnitField; [EOL] }
public int getMinimumValue() { [EOL]     return 0; [EOL] }
public final long getUnitMillis() { [EOL]     return iUnitMillis; [EOL] }
protected int getMaximumValueForSet(long instant, int value) { [EOL]     return getMaximumValue(instant); [EOL] }
public long addWrapField(long instant, int years) { [EOL]     if (years == 0) { [EOL]         return instant; [EOL]     } [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int wrappedYear = FieldUtils.getWrappedValue(thisYear, years, iChronology.getMinYear(), iChronology.getMaxYear()); [EOL]     return set(instant, wrappedYear); [EOL] }
public long addWrapField(long instant, int years) { [EOL]     if (years == 0) { [EOL]         return instant; [EOL]     } [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int wrappedYear = FieldUtils.getWrappedValue(thisYear, years, iChronology.getMinYear(), iChronology.getMaxYear()); [EOL]     return set(instant, wrappedYear); [EOL] }
public long addWrapField(long instant, int years) { [EOL]     if (years == 0) { [EOL]         return instant; [EOL]     } [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int wrappedYear = FieldUtils.getWrappedValue(thisYear, years, iChronology.getMinYear(), iChronology.getMaxYear()); [EOL]     return set(instant, wrappedYear); [EOL] }
public long addWrapField(long instant, int years) { [EOL]     if (years == 0) { [EOL]         return instant; [EOL]     } [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int wrappedYear = FieldUtils.getWrappedValue(thisYear, years, iChronology.getMinYear(), iChronology.getMaxYear()); [EOL]     return set(instant, wrappedYear); [EOL] }
public long addWrapField(long instant, int years) { [EOL]     if (years == 0) { [EOL]         return instant; [EOL]     } [EOL]     int thisYear = iChronology.getYear(instant); [EOL]     int wrappedYear = FieldUtils.getWrappedValue(thisYear, years, iChronology.getMinYear(), iChronology.getMaxYear()); [EOL]     return set(instant, wrappedYear); [EOL] }
public int getMinimumValue() { [EOL]     return iChronology.getMinYear(); [EOL] }
public int getMaximumValue() { [EOL]     return iChronology.getMaxYear(); [EOL] }
static int compareReverse(DurationField a, DurationField b) { [EOL]     if (a == null || !a.isSupported()) { [EOL]         if (b == null || !b.isSupported()) { [EOL]             return 0; [EOL]         } [EOL]         return -1; [EOL]     } [EOL]     if (b == null || !b.isSupported()) { [EOL]         return 1; [EOL]     } [EOL]     return -a.compareTo(b); [EOL] }
public long roundCeiling(long instant) { [EOL]     return super.roundCeiling(instant + 3 * DateTimeConstants.MILLIS_PER_DAY) - 3 * DateTimeConstants.MILLIS_PER_DAY; [EOL] }
public long roundCeiling(long instant) { [EOL]     return super.roundCeiling(instant + 3 * DateTimeConstants.MILLIS_PER_DAY) - 3 * DateTimeConstants.MILLIS_PER_DAY; [EOL] }
public long remainder(long instant) { [EOL]     return super.remainder(instant + 3 * DateTimeConstants.MILLIS_PER_DAY); [EOL] }
public long remainder(long instant) { [EOL]     return super.remainder(instant + 3 * DateTimeConstants.MILLIS_PER_DAY); [EOL] }
public static Days days(int days) { [EOL]     switch(days) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Days(days); [EOL]     } [EOL] }
public static Days days(int days) { [EOL]     switch(days) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Days(days); [EOL]     } [EOL] }
public static Days days(int days) { [EOL]     switch(days) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Days(days); [EOL]     } [EOL] }
public static Days days(int days) { [EOL]     switch(days) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Days(days); [EOL]     } [EOL] }
public static Days days(int days) { [EOL]     switch(days) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Days(days); [EOL]     } [EOL] }
public static Days days(int days) { [EOL]     switch(days) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Days(days); [EOL]     } [EOL] }
public static Days days(int days) { [EOL]     switch(days) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Days(days); [EOL]     } [EOL] }
public static Days days(int days) { [EOL]     switch(days) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Days(days); [EOL]     } [EOL] }
public static Days days(int days) { [EOL]     switch(days) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Days(days); [EOL]     } [EOL] }
public static Days days(int days) { [EOL]     switch(days) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Days(days); [EOL]     } [EOL] }
public static Days days(int days) { [EOL]     switch(days) { [EOL]         case 0: [EOL]             return ZERO; [EOL]         case 1: [EOL]             return ONE; [EOL]         case 2: [EOL]             return TWO; [EOL]         case 3: [EOL]             return THREE; [EOL]         case 4: [EOL]             return FOUR; [EOL]         case 5: [EOL]             return FIVE; [EOL]         case 6: [EOL]             return SIX; [EOL]         case 7: [EOL]             return SEVEN; [EOL]         case Integer.MAX_VALUE: [EOL]             return MAX_VALUE; [EOL]         case Integer.MIN_VALUE: [EOL]             return MIN_VALUE; [EOL]         default: [EOL]             return new Days(days); [EOL]     } [EOL] }
public static Days daysBetween(ReadablePartial start, ReadablePartial end) { [EOL]     if (start instanceof LocalDate && end instanceof LocalDate) { [EOL]         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()); [EOL]         int days = chrono.days().getDifference(((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis()); [EOL]         return Days.days(days); [EOL]     } [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, ZERO); [EOL]     return Days.days(amount); [EOL] }
public static Days daysBetween(ReadablePartial start, ReadablePartial end) { [EOL]     if (start instanceof LocalDate && end instanceof LocalDate) { [EOL]         Chronology chrono = DateTimeUtils.getChronology(start.getChronology()); [EOL]         int days = chrono.days().getDifference(((LocalDate) end).getLocalMillis(), ((LocalDate) start).getLocalMillis()); [EOL]         return Days.days(days); [EOL]     } [EOL]     int amount = BaseSingleFieldPeriod.between(start, end, ZERO); [EOL]     return Days.days(amount); [EOL] }
public DurationFieldType getFieldType() { [EOL]     return DurationFieldType.days(); [EOL] }
public Seconds toStandardSeconds() { [EOL]     return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_DAY)); [EOL] }
public Seconds toStandardSeconds() { [EOL]     return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_DAY)); [EOL] }
public Seconds toStandardSeconds() { [EOL]     return Seconds.seconds(FieldUtils.safeMultiply(getValue(), DateTimeConstants.SECONDS_PER_DAY)); [EOL] }
public Days plus(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     return Days.days(FieldUtils.safeAdd(getValue(), days)); [EOL] }
public Days plus(int days) { [EOL]     if (days == 0) { [EOL]         return this; [EOL]     } [EOL]     return Days.days(FieldUtils.safeAdd(getValue(), days)); [EOL] }
public Days dividedBy(int divisor) { [EOL]     if (divisor == 1) { [EOL]         return this; [EOL]     } [EOL]     return Days.days(getValue() / divisor); [EOL] }
public Days dividedBy(int divisor) { [EOL]     if (divisor == 1) { [EOL]         return this; [EOL]     } [EOL]     return Days.days(getValue() / divisor); [EOL] }
public Days dividedBy(int divisor) { [EOL]     if (divisor == 1) { [EOL]         return this; [EOL]     } [EOL]     return Days.days(getValue() / divisor); [EOL] }
@ToString [EOL] public String toString() { [EOL]     return "P" + String.valueOf(getValue()) + "D"; [EOL] }
@ToString [EOL] public String toString() { [EOL]     return "P" + String.valueOf(getValue()) + "D"; [EOL] }
@ToString [EOL] public String toString() { [EOL]     return "P" + String.valueOf(getValue()) + "D"; [EOL] }
public long add(long instant, int years) { [EOL]     return getWrappedField().add(instant, years); [EOL] }
public long roundFloor(long instant) { [EOL]     return getWrappedField().roundFloor(instant); [EOL] }
public static MonthDay now(Chronology chronology) { [EOL]     if (chronology == null) { [EOL]         throw new NullPointerException("Chronology must not be null"); [EOL]     } [EOL]     return new MonthDay(chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public static MonthDay now(Chronology chronology) { [EOL]     if (chronology == null) { [EOL]         throw new NullPointerException("Chronology must not be null"); [EOL]     } [EOL]     return new MonthDay(chronology); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
MonthDay(MonthDay partial, int[] values) { [EOL]     super(partial, values); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
MonthDay(MonthDay partial, int[] values) { [EOL]     super(partial, values); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
MonthDay(MonthDay partial, int[] values) { [EOL]     super(partial, values); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
MonthDay(MonthDay partial, int[] values) { [EOL]     super(partial, values); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
MonthDay(MonthDay partial, int[] values) { [EOL]     super(partial, values); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
MonthDay(MonthDay partial, int[] values) { [EOL]     super(partial, values); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
MonthDay(MonthDay partial, int[] values) { [EOL]     super(partial, values); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
MonthDay(MonthDay partial, int[] values) { [EOL]     super(partial, values); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
MonthDay(MonthDay partial, int[] values) { [EOL]     super(partial, values); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
MonthDay(MonthDay partial, int[] values) { [EOL]     super(partial, values); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
MonthDay(MonthDay partial, int[] values) { [EOL]     super(partial, values); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay plusMonths(int months) { [EOL]     return withFieldAdded(DurationFieldType.months(), months); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay plusMonths(int months) { [EOL]     return withFieldAdded(DurationFieldType.months(), months); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay plusMonths(int months) { [EOL]     return withFieldAdded(DurationFieldType.months(), months); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay plusMonths(int months) { [EOL]     return withFieldAdded(DurationFieldType.months(), months); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public LocalDate toLocalDate(int year) { [EOL]     return new LocalDate(year, getMonthOfYear(), getDayOfMonth(), getChronology()); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int getMonthOfYear() { [EOL]     return getValue(MONTH_OF_YEAR); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int getDayOfMonth() { [EOL]     return getValue(DAY_OF_MONTH); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay withMonthOfYear(int monthOfYear) { [EOL]     int[] newValues = getValues(); [EOL]     newValues = getChronology().monthOfYear().set(this, MONTH_OF_YEAR, newValues, monthOfYear); [EOL]     return new MonthDay(this, newValues); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay withMonthOfYear(int monthOfYear) { [EOL]     int[] newValues = getValues(); [EOL]     newValues = getChronology().monthOfYear().set(this, MONTH_OF_YEAR, newValues, monthOfYear); [EOL]     return new MonthDay(this, newValues); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay withMonthOfYear(int monthOfYear) { [EOL]     int[] newValues = getValues(); [EOL]     newValues = getChronology().monthOfYear().set(this, MONTH_OF_YEAR, newValues, monthOfYear); [EOL]     return new MonthDay(this, newValues); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay withDayOfMonth(int dayOfMonth) { [EOL]     int[] newValues = getValues(); [EOL]     newValues = getChronology().dayOfMonth().set(this, DAY_OF_MONTH, newValues, dayOfMonth); [EOL]     return new MonthDay(this, newValues); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay withDayOfMonth(int dayOfMonth) { [EOL]     int[] newValues = getValues(); [EOL]     newValues = getChronology().dayOfMonth().set(this, DAY_OF_MONTH, newValues, dayOfMonth); [EOL]     return new MonthDay(this, newValues); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay withDayOfMonth(int dayOfMonth) { [EOL]     int[] newValues = getValues(); [EOL]     newValues = getChronology().dayOfMonth().set(this, DAY_OF_MONTH, newValues, dayOfMonth); [EOL]     return new MonthDay(this, newValues); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public MonthDay withDayOfMonth(int dayOfMonth) { [EOL]     int[] newValues = getValues(); [EOL]     newValues = getChronology().dayOfMonth().set(this, DAY_OF_MONTH, newValues, dayOfMonth); [EOL]     return new MonthDay(this, newValues); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public Property property(DateTimeFieldType type) { [EOL]     return new Property(this, indexOfSupported(type)); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public Property monthOfYear() { [EOL]     return new Property(this, MONTH_OF_YEAR); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public Property dayOfMonth() { [EOL]     return new Property(this, DAY_OF_MONTH); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public String toString(String pattern) { [EOL]     if (pattern == null) { [EOL]         return toString(); [EOL]     } [EOL]     return DateTimeFormat.forPattern(pattern).print(this); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public String toString(String pattern) { [EOL]     if (pattern == null) { [EOL]         return toString(); [EOL]     } [EOL]     return DateTimeFormat.forPattern(pattern).print(this); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public String toString(String pattern) { [EOL]     if (pattern == null) { [EOL]         return toString(); [EOL]     } [EOL]     return DateTimeFormat.forPattern(pattern).print(this); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
Property(MonthDay partial, int fieldIndex) { [EOL]     super(); [EOL]     iBase = partial; [EOL]     iFieldIndex = fieldIndex; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public DateTimeField getField() { [EOL]     return iBase.getField(iFieldIndex); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
protected ReadablePartial getReadablePartial() { [EOL]     return iBase; [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public int get() { [EOL]     return iBase.getValue(iFieldIndex); [EOL] } public MonthDay(); public MonthDay(DateTimeZone zone); public MonthDay(Chronology chronology); public MonthDay(long instant); public MonthDay(long instant, Chronology chronology); public MonthDay(Object instant); public MonthDay(Object instant, Chronology chronology); public MonthDay(int monthOfYear, int dayOfMonth); public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology);  MonthDay(MonthDay partial, int[] values);  MonthDay(MonthDay partial, Chronology chrono);  Property(MonthDay partial, int fieldIndex); public static MonthDay now(); public static MonthDay now(DateTimeZone zone); public static MonthDay now(Chronology chronology); public static MonthDay parse(String str); public static MonthDay parse(String str, DateTimeFormatter formatter); public static MonthDay fromCalendarFields(Calendar calendar); public static MonthDay fromDateFields(Date date); private Object readResolve(); public int size(); protected DateTimeField getField(int index, Chronology chrono); public DateTimeFieldType getFieldType(int index); public DateTimeFieldType[] getFieldTypes(); public MonthDay withChronologyRetainFields(Chronology newChronology); public MonthDay withField(DateTimeFieldType fieldType, int value); public MonthDay withFieldAdded(DurationFieldType fieldType, int amount); public MonthDay withPeriodAdded(ReadablePeriod period, int scalar); public MonthDay plus(ReadablePeriod period); public MonthDay plusMonths(int months); public MonthDay plusDays(int days); public MonthDay minus(ReadablePeriod period); public MonthDay minusMonths(int months); public MonthDay minusDays(int days); public LocalDate toLocalDate(int year); public int getMonthOfYear(); public int getDayOfMonth(); public MonthDay withMonthOfYear(int monthOfYear); public MonthDay withDayOfMonth(int dayOfMonth); public Property property(DateTimeFieldType type); public Property monthOfYear(); public Property dayOfMonth(); public String toString(); public String toString(String pattern); public String toString(String pattern, Locale locale) throws IllegalArgumentException; public DateTimeField getField(); protected ReadablePartial getReadablePartial(); public MonthDay getMonthDay(); public int get(); public MonthDay addToCopy(int valueToAdd); public MonthDay addWrapFieldToCopy(int valueToAdd); public MonthDay setCopy(int value); public MonthDay setCopy(String text, Locale locale); public MonthDay setCopy(String text); long serialVersionUID=Optional[2954560699050434609L]; DateTimeFieldType[] FIELD_TYPES=Optional[new DateTimeFieldType[] { DateTimeFieldType.monthOfYear(), DateTimeFieldType.dayOfMonth() }
public static LocalDateTime now(Chronology chronology) { [EOL]     if (chronology == null) { [EOL]         throw new NullPointerException("Chronology must not be null"); [EOL]     } [EOL]     return new LocalDateTime(chronology); [EOL] }
public static LocalDateTime now(Chronology chronology) { [EOL]     if (chronology == null) { [EOL]         throw new NullPointerException("Chronology must not be null"); [EOL]     } [EOL]     return new LocalDateTime(chronology); [EOL] }
@FromString [EOL] public static LocalDateTime parse(String str) { [EOL]     return parse(str, ISODateTimeFormat.localDateOptionalTimeParser()); [EOL] }
@FromString [EOL] public static LocalDateTime parse(String str) { [EOL]     return parse(str, ISODateTimeFormat.localDateOptionalTimeParser()); [EOL] }
@FromString [EOL] public static LocalDateTime parse(String str) { [EOL]     return parse(str, ISODateTimeFormat.localDateOptionalTimeParser()); [EOL] }
public static LocalDateTime parse(String str, DateTimeFormatter formatter) { [EOL]     return formatter.parseLocalDateTime(str); [EOL] }
public static LocalDateTime parse(String str, DateTimeFormatter formatter) { [EOL]     return formatter.parseLocalDateTime(str); [EOL] }
public static LocalDateTime parse(String str, DateTimeFormatter formatter) { [EOL]     return formatter.parseLocalDateTime(str); [EOL] }
@SuppressWarnings("deprecation") [EOL] public static LocalDateTime fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date.getTime() < 0) { [EOL]         GregorianCalendar cal = new GregorianCalendar(); [EOL]         cal.setTime(date); [EOL]         return fromCalendarFields(cal); [EOL]     } [EOL]     return new LocalDateTime(date.getYear() + 1900, date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000); [EOL] }
@SuppressWarnings("deprecation") [EOL] public static LocalDateTime fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date.getTime() < 0) { [EOL]         GregorianCalendar cal = new GregorianCalendar(); [EOL]         cal.setTime(date); [EOL]         return fromCalendarFields(cal); [EOL]     } [EOL]     return new LocalDateTime(date.getYear() + 1900, date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000); [EOL] }
@SuppressWarnings("deprecation") [EOL] public static LocalDateTime fromDateFields(Date date) { [EOL]     if (date == null) { [EOL]         throw new IllegalArgumentException("The date must not be null"); [EOL]     } [EOL]     if (date.getTime() < 0) { [EOL]         GregorianCalendar cal = new GregorianCalendar(); [EOL]         cal.setTime(date); [EOL]         return fromCalendarFields(cal); [EOL]     } [EOL]     return new LocalDateTime(date.getYear() + 1900, date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), (((int) (date.getTime() % 1000)) + 1000) % 1000); [EOL] }
private Object readResolve() { [EOL]     if (iChronology == null) { [EOL]         return new LocalDateTime(iLocalMillis, ISOChronology.getInstanceUTC()); [EOL]     } [EOL]     if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) { [EOL]         return new LocalDateTime(iLocalMillis, iChronology.withUTC()); [EOL]     } [EOL]     return this; [EOL] }
private Object readResolve() { [EOL]     if (iChronology == null) { [EOL]         return new LocalDateTime(iLocalMillis, ISOChronology.getInstanceUTC()); [EOL]     } [EOL]     if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) { [EOL]         return new LocalDateTime(iLocalMillis, iChronology.withUTC()); [EOL]     } [EOL]     return this; [EOL] }
private Object readResolve() { [EOL]     if (iChronology == null) { [EOL]         return new LocalDateTime(iLocalMillis, ISOChronology.getInstanceUTC()); [EOL]     } [EOL]     if (DateTimeZone.UTC.equals(iChronology.getZone()) == false) { [EOL]         return new LocalDateTime(iLocalMillis, iChronology.withUTC()); [EOL]     } [EOL]     return this; [EOL] }
public int get(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     return type.getField(getChronology()).get(getLocalMillis()); [EOL] }
public int get(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     return type.getField(getChronology()).get(getLocalMillis()); [EOL] }
public boolean isSupported(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     return type.getField(getChronology()).isSupported(); [EOL] }
public boolean isSupported(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     return type.getField(getChronology()).isSupported(); [EOL] }
public boolean isSupported(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         return false; [EOL]     } [EOL]     return type.getField(getChronology()).isSupported(); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalDateTime) { [EOL]         LocalDateTime other = (LocalDateTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalDateTime) { [EOL]         LocalDateTime other = (LocalDateTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalDateTime) { [EOL]         LocalDateTime other = (LocalDateTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalDateTime) { [EOL]         LocalDateTime other = (LocalDateTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalDateTime) { [EOL]         LocalDateTime other = (LocalDateTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public boolean equals(Object partial) { [EOL]     if (this == partial) { [EOL]         return true; [EOL]     } [EOL]     if (partial instanceof LocalDateTime) { [EOL]         LocalDateTime other = (LocalDateTime) partial; [EOL]         if (iChronology.equals(other.iChronology)) { [EOL]             return iLocalMillis == other.iLocalMillis; [EOL]         } [EOL]     } [EOL]     return super.equals(partial); [EOL] }
public DateTime toDateTime() { [EOL]     return toDateTime((DateTimeZone) null); [EOL] }
public LocalDateTime withDate(int year, int monthOfYear, int dayOfMonth) { [EOL]     Chronology chrono = getChronology(); [EOL]     long instant = getLocalMillis(); [EOL]     instant = chrono.year().set(instant, year); [EOL]     instant = chrono.monthOfYear().set(instant, monthOfYear); [EOL]     instant = chrono.dayOfMonth().set(instant, dayOfMonth); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime withDate(int year, int monthOfYear, int dayOfMonth) { [EOL]     Chronology chrono = getChronology(); [EOL]     long instant = getLocalMillis(); [EOL]     instant = chrono.year().set(instant, year); [EOL]     instant = chrono.monthOfYear().set(instant, monthOfYear); [EOL]     instant = chrono.dayOfMonth().set(instant, dayOfMonth); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime withDate(int year, int monthOfYear, int dayOfMonth) { [EOL]     Chronology chrono = getChronology(); [EOL]     long instant = getLocalMillis(); [EOL]     instant = chrono.year().set(instant, year); [EOL]     instant = chrono.monthOfYear().set(instant, monthOfYear); [EOL]     instant = chrono.dayOfMonth().set(instant, dayOfMonth); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime withDate(int year, int monthOfYear, int dayOfMonth) { [EOL]     Chronology chrono = getChronology(); [EOL]     long instant = getLocalMillis(); [EOL]     instant = chrono.year().set(instant, year); [EOL]     instant = chrono.monthOfYear().set(instant, monthOfYear); [EOL]     instant = chrono.dayOfMonth().set(instant, dayOfMonth); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime plusWeeks(int weeks) { [EOL]     if (weeks == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().weeks().add(getLocalMillis(), weeks); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime plusWeeks(int weeks) { [EOL]     if (weeks == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().weeks().add(getLocalMillis(), weeks); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime plusWeeks(int weeks) { [EOL]     if (weeks == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().weeks().add(getLocalMillis(), weeks); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime minusMillis(int millis) { [EOL]     if (millis == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().millis().subtract(getLocalMillis(), millis); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime minusMillis(int millis) { [EOL]     if (millis == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().millis().subtract(getLocalMillis(), millis); [EOL]     return withLocalMillis(instant); [EOL] }
public LocalDateTime minusMillis(int millis) { [EOL]     if (millis == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().millis().subtract(getLocalMillis(), millis); [EOL]     return withLocalMillis(instant); [EOL] }
public Property property(DateTimeFieldType fieldType) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     return new Property(this, fieldType.getField(getChronology())); [EOL] }
public Property property(DateTimeFieldType fieldType) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     return new Property(this, fieldType.getField(getChronology())); [EOL] }
public Property property(DateTimeFieldType fieldType) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     if (isSupported(fieldType) == false) { [EOL]         throw new IllegalArgumentException("Field '" + fieldType + "' is not supported"); [EOL]     } [EOL]     return new Property(this, fieldType.getField(getChronology())); [EOL] }
public Property era() { [EOL]     return new Property(this, getChronology().era()); [EOL] }
public Property yearOfCentury() { [EOL]     return new Property(this, getChronology().yearOfCentury()); [EOL] }
public Property weekOfWeekyear() { [EOL]     return new Property(this, getChronology().weekOfWeekyear()); [EOL] }
public Property dayOfYear() { [EOL]     return new Property(this, getChronology().dayOfYear()); [EOL] }
public Property dayOfWeek() { [EOL]     return new Property(this, getChronology().dayOfWeek()); [EOL] }
public Property millisOfDay() { [EOL]     return new Property(this, getChronology().millisOfDay()); [EOL] }
@ToString [EOL] public String toString() { [EOL]     return ISODateTimeFormat.dateTime().print(this); [EOL] }
public LocalDateTime roundFloorCopy() { [EOL]     return iInstant.withLocalMillis(iField.roundFloor(iInstant.getLocalMillis())); [EOL] }
public LocalDateTime roundCeilingCopy() { [EOL]     return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis())); [EOL] }
public LocalDateTime roundCeilingCopy() { [EOL]     return iInstant.withLocalMillis(iField.roundCeiling(iInstant.getLocalMillis())); [EOL] }
public LocalDateTime roundHalfFloorCopy() { [EOL]     return iInstant.withLocalMillis(iField.roundHalfFloor(iInstant.getLocalMillis())); [EOL] }
public LocalDateTime roundHalfCeilingCopy() { [EOL]     return iInstant.withLocalMillis(iField.roundHalfCeiling(iInstant.getLocalMillis())); [EOL] }
public LocalDateTime roundHalfEvenCopy() { [EOL]     return iInstant.withLocalMillis(iField.roundHalfEven(iInstant.getLocalMillis())); [EOL] }
public DateTimeFormatter(DateTimePrinter printer, DateTimeParser parser) { [EOL]     super(); [EOL]     iPrinter = printer; [EOL]     iParser = parser; [EOL]     iLocale = null; [EOL]     iOffsetParsed = false; [EOL]     iChrono = null; [EOL]     iZone = null; [EOL]     iPivotYear = null; [EOL]     iDefaultYear = 2000; [EOL] }
public boolean isPrinter() { [EOL]     return (iPrinter != null); [EOL] }
public boolean isPrinter() { [EOL]     return (iPrinter != null); [EOL] }
public boolean isParser() { [EOL]     return (iParser != null); [EOL] }
public boolean isParser() { [EOL]     return (iParser != null); [EOL] }
public void printTo(StringBuffer buf, ReadableInstant instant) { [EOL]     long millis = DateTimeUtils.getInstantMillis(instant); [EOL]     Chronology chrono = DateTimeUtils.getInstantChronology(instant); [EOL]     printTo(buf, millis, chrono); [EOL] }
public String print(ReadableInstant instant) { [EOL]     StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength()); [EOL]     printTo(buf, instant); [EOL]     return buf.toString(); [EOL] }
private void printTo(StringBuffer buf, long instant, Chronology chrono) { [EOL]     DateTimePrinter printer = requirePrinter(); [EOL]     chrono = selectChronology(chrono); [EOL]     DateTimeZone zone = chrono.getZone(); [EOL]     int offset = zone.getOffset(instant); [EOL]     long adjustedInstant = instant + offset; [EOL]     if ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) { [EOL]         zone = DateTimeZone.UTC; [EOL]         offset = 0; [EOL]         adjustedInstant = instant; [EOL]     } [EOL]     printer.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale); [EOL] }
private DateTimePrinter requirePrinter() { [EOL]     DateTimePrinter printer = iPrinter; [EOL]     if (printer == null) { [EOL]         throw new UnsupportedOperationException("Printing not supported"); [EOL]     } [EOL]     return printer; [EOL] }
private DateTimePrinter requirePrinter() { [EOL]     DateTimePrinter printer = iPrinter; [EOL]     if (printer == null) { [EOL]         throw new UnsupportedOperationException("Printing not supported"); [EOL]     } [EOL]     return printer; [EOL] }
public DateTime parseDateTime(String text) { [EOL]     DateTimeParser parser = requireParser(); [EOL]     Chronology chrono = selectChronology(null); [EOL]     DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear); [EOL]     int newPos = parser.parseInto(bucket, text, 0); [EOL]     if (newPos >= 0) { [EOL]         if (newPos >= text.length()) { [EOL]             long millis = bucket.computeMillis(true, text); [EOL]             if (iOffsetParsed && bucket.getOffsetInteger() != null) { [EOL]                 int parsedOffset = bucket.getOffsetInteger(); [EOL]                 DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); [EOL]                 chrono = chrono.withZone(parsedZone); [EOL]             } else if (bucket.getZone() != null) { [EOL]                 chrono = chrono.withZone(bucket.getZone()); [EOL]             } [EOL]             DateTime dt = new DateTime(millis, chrono); [EOL]             if (iZone != null) { [EOL]                 dt = dt.withZone(iZone); [EOL]             } [EOL]             return dt; [EOL]         } [EOL]     } else { [EOL]         newPos = ~newPos; [EOL]     } [EOL]     throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos)); [EOL] }
private DateTimeParser requireParser() { [EOL]     DateTimeParser parser = iParser; [EOL]     if (parser == null) { [EOL]         throw new UnsupportedOperationException("Parsing not supported"); [EOL]     } [EOL]     return parser; [EOL] }
private DateTimeParser requireParser() { [EOL]     DateTimeParser parser = iParser; [EOL]     if (parser == null) { [EOL]         throw new UnsupportedOperationException("Parsing not supported"); [EOL]     } [EOL]     return parser; [EOL] }
public long set(ReadablePartial partial, long instant) { [EOL]     for (int i = 0, isize = partial.size(); i < isize; i++) { [EOL]         instant = partial.getFieldType(i).getField(this).set(instant, partial.getValue(i)); [EOL]     } [EOL]     return instant; [EOL] }
public int[] get(ReadablePeriod period, long duration) { [EOL]     int size = period.size(); [EOL]     int[] values = new int[size]; [EOL]     if (duration != 0) { [EOL]         long current = 0; [EOL]         for (int i = 0; i < size; i++) { [EOL]             DurationField field = period.getFieldType(i).getField(this); [EOL]             if (field.isPrecise()) { [EOL]                 int value = field.getDifference(duration, current); [EOL]                 current = field.add(current, value); [EOL]                 values[i] = value; [EOL]             } [EOL]         } [EOL]     } [EOL]     return values; [EOL] }
public int[] get(ReadablePeriod period, long duration) { [EOL]     int size = period.size(); [EOL]     int[] values = new int[size]; [EOL]     if (duration != 0) { [EOL]         long current = 0; [EOL]         for (int i = 0; i < size; i++) { [EOL]             DurationField field = period.getFieldType(i).getField(this); [EOL]             if (field.isPrecise()) { [EOL]                 int value = field.getDifference(duration, current); [EOL]                 current = field.add(current, value); [EOL]                 values[i] = value; [EOL]             } [EOL]         } [EOL]     } [EOL]     return values; [EOL] }
public int[] get(ReadablePeriod period, long duration) { [EOL]     int size = period.size(); [EOL]     int[] values = new int[size]; [EOL]     if (duration != 0) { [EOL]         long current = 0; [EOL]         for (int i = 0; i < size; i++) { [EOL]             DurationField field = period.getFieldType(i).getField(this); [EOL]             if (field.isPrecise()) { [EOL]                 int value = field.getDifference(duration, current); [EOL]                 current = field.add(current, value); [EOL]                 values[i] = value; [EOL]             } [EOL]         } [EOL]     } [EOL]     return values; [EOL] }
public long add(long instant, long duration, int scalar) { [EOL]     if (duration == 0 || scalar == 0) { [EOL]         return instant; [EOL]     } [EOL]     long add = FieldUtils.safeMultiply(duration, scalar); [EOL]     return FieldUtils.safeAdd(instant, add); [EOL] }
public long add(long instant, long duration, int scalar) { [EOL]     if (duration == 0 || scalar == 0) { [EOL]         return instant; [EOL]     } [EOL]     long add = FieldUtils.safeMultiply(duration, scalar); [EOL]     return FieldUtils.safeAdd(instant, add); [EOL] }
public long add(long instant, long duration, int scalar) { [EOL]     if (duration == 0 || scalar == 0) { [EOL]         return instant; [EOL]     } [EOL]     long add = FieldUtils.safeMultiply(duration, scalar); [EOL]     return FieldUtils.safeAdd(instant, add); [EOL] }
public boolean isSupported() { [EOL]     return true; [EOL] }
public final long getUnitMillis() { [EOL]     return 1; [EOL] }
public int getValue(long duration, long instant) { [EOL]     return FieldUtils.safeToInt(duration); [EOL] }
public int getValue(long duration, long instant) { [EOL]     return FieldUtils.safeToInt(duration); [EOL] }
public int getValue(long duration, long instant) { [EOL]     return FieldUtils.safeToInt(duration); [EOL] }
public int getValue(long duration, long instant) { [EOL]     return FieldUtils.safeToInt(duration); [EOL] }
public int getValue(long duration, long instant) { [EOL]     return FieldUtils.safeToInt(duration); [EOL] }
public long getValueAsLong(long duration, long instant) { [EOL]     return duration; [EOL] }
public long add(long instant, long value) { [EOL]     return FieldUtils.safeAdd(instant, value); [EOL] }
public int compareTo(DurationField otherField) { [EOL]     long otherMillis = otherField.getUnitMillis(); [EOL]     long thisMillis = getUnitMillis(); [EOL]     if (thisMillis == otherMillis) { [EOL]         return 0; [EOL]     } [EOL]     if (thisMillis < otherMillis) { [EOL]         return -1; [EOL]     } else { [EOL]         return 1; [EOL]     } [EOL] }
public int compareTo(DurationField otherField) { [EOL]     long otherMillis = otherField.getUnitMillis(); [EOL]     long thisMillis = getUnitMillis(); [EOL]     if (thisMillis == otherMillis) { [EOL]         return 0; [EOL]     } [EOL]     if (thisMillis < otherMillis) { [EOL]         return -1; [EOL]     } else { [EOL]         return 1; [EOL]     } [EOL] }
public int compareTo(DurationField otherField) { [EOL]     long otherMillis = otherField.getUnitMillis(); [EOL]     long thisMillis = getUnitMillis(); [EOL]     if (thisMillis == otherMillis) { [EOL]         return 0; [EOL]     } [EOL]     if (thisMillis < otherMillis) { [EOL]         return -1; [EOL]     } else { [EOL]         return 1; [EOL]     } [EOL] }
public static DateTimeFieldType weekyearOfCentury() { [EOL]     return WEEKYEAR_OF_CENTURY_TYPE; [EOL] }
public static DateTimeFieldType yearOfCentury() { [EOL]     return YEAR_OF_CENTURY_TYPE; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof StandardDateTimeFieldType) { [EOL]         return iOrdinal == ((StandardDateTimeFieldType) obj).iOrdinal; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof StandardDateTimeFieldType) { [EOL]         return iOrdinal == ((StandardDateTimeFieldType) obj).iOrdinal; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof StandardDateTimeFieldType) { [EOL]         return iOrdinal == ((StandardDateTimeFieldType) obj).iOrdinal; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof StandardDateTimeFieldType) { [EOL]         return iOrdinal == ((StandardDateTimeFieldType) obj).iOrdinal; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean equals(Object obj) { [EOL]     if (this == obj) { [EOL]         return true; [EOL]     } [EOL]     if (obj instanceof StandardDateTimeFieldType) { [EOL]         return iOrdinal == ((StandardDateTimeFieldType) obj).iOrdinal; [EOL]     } [EOL]     return false; [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
public DateTimeField getField(Chronology chronology) { [EOL]     chronology = DateTimeUtils.getChronology(chronology); [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return chronology.era(); [EOL]         case YEAR_OF_ERA: [EOL]             return chronology.yearOfEra(); [EOL]         case CENTURY_OF_ERA: [EOL]             return chronology.centuryOfEra(); [EOL]         case YEAR_OF_CENTURY: [EOL]             return chronology.yearOfCentury(); [EOL]         case YEAR: [EOL]             return chronology.year(); [EOL]         case DAY_OF_YEAR: [EOL]             return chronology.dayOfYear(); [EOL]         case MONTH_OF_YEAR: [EOL]             return chronology.monthOfYear(); [EOL]         case DAY_OF_MONTH: [EOL]             return chronology.dayOfMonth(); [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return chronology.weekyearOfCentury(); [EOL]         case WEEKYEAR: [EOL]             return chronology.weekyear(); [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return chronology.weekOfWeekyear(); [EOL]         case DAY_OF_WEEK: [EOL]             return chronology.dayOfWeek(); [EOL]         case HALFDAY_OF_DAY: [EOL]             return chronology.halfdayOfDay(); [EOL]         case HOUR_OF_HALFDAY: [EOL]             return chronology.hourOfHalfday(); [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return chronology.clockhourOfHalfday(); [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return chronology.clockhourOfDay(); [EOL]         case HOUR_OF_DAY: [EOL]             return chronology.hourOfDay(); [EOL]         case MINUTE_OF_DAY: [EOL]             return chronology.minuteOfDay(); [EOL]         case MINUTE_OF_HOUR: [EOL]             return chronology.minuteOfHour(); [EOL]         case SECOND_OF_DAY: [EOL]             return chronology.secondOfDay(); [EOL]         case SECOND_OF_MINUTE: [EOL]             return chronology.secondOfMinute(); [EOL]         case MILLIS_OF_DAY: [EOL]             return chronology.millisOfDay(); [EOL]         case MILLIS_OF_SECOND: [EOL]             return chronology.millisOfSecond(); [EOL]         default: [EOL]             throw new InternalError(); [EOL]     } [EOL] }
private Object readResolve() { [EOL]     switch(iOrdinal) { [EOL]         case ERA: [EOL]             return ERA_TYPE; [EOL]         case YEAR_OF_ERA: [EOL]             return YEAR_OF_ERA_TYPE; [EOL]         case CENTURY_OF_ERA: [EOL]             return CENTURY_OF_ERA_TYPE; [EOL]         case YEAR_OF_CENTURY: [EOL]             return YEAR_OF_CENTURY_TYPE; [EOL]         case YEAR: [EOL]             return YEAR_TYPE; [EOL]         case DAY_OF_YEAR: [EOL]             return DAY_OF_YEAR_TYPE; [EOL]         case MONTH_OF_YEAR: [EOL]             return MONTH_OF_YEAR_TYPE; [EOL]         case DAY_OF_MONTH: [EOL]             return DAY_OF_MONTH_TYPE; [EOL]         case WEEKYEAR_OF_CENTURY: [EOL]             return WEEKYEAR_OF_CENTURY_TYPE; [EOL]         case WEEKYEAR: [EOL]             return WEEKYEAR_TYPE; [EOL]         case WEEK_OF_WEEKYEAR: [EOL]             return WEEK_OF_WEEKYEAR_TYPE; [EOL]         case DAY_OF_WEEK: [EOL]             return DAY_OF_WEEK_TYPE; [EOL]         case HALFDAY_OF_DAY: [EOL]             return HALFDAY_OF_DAY_TYPE; [EOL]         case HOUR_OF_HALFDAY: [EOL]             return HOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_HALFDAY: [EOL]             return CLOCKHOUR_OF_HALFDAY_TYPE; [EOL]         case CLOCKHOUR_OF_DAY: [EOL]             return CLOCKHOUR_OF_DAY_TYPE; [EOL]         case HOUR_OF_DAY: [EOL]             return HOUR_OF_DAY_TYPE; [EOL]         case MINUTE_OF_DAY: [EOL]             return MINUTE_OF_DAY_TYPE; [EOL]         case MINUTE_OF_HOUR: [EOL]             return MINUTE_OF_HOUR_TYPE; [EOL]         case SECOND_OF_DAY: [EOL]             return SECOND_OF_DAY_TYPE; [EOL]         case SECOND_OF_MINUTE: [EOL]             return SECOND_OF_MINUTE_TYPE; [EOL]         case MILLIS_OF_DAY: [EOL]             return MILLIS_OF_DAY_TYPE; [EOL]         case MILLIS_OF_SECOND: [EOL]             return MILLIS_OF_SECOND_TYPE; [EOL]         default: [EOL]             return this; [EOL]     } [EOL] }
protected AbstractDuration() { [EOL]     super(); [EOL] }
public void setInto(ReadWritablePeriod writablePeriod, Object object, Chronology chrono) { [EOL]     ReadableInterval interval = (ReadableInterval) object; [EOL]     chrono = (chrono != null ? chrono : DateTimeUtils.getIntervalChronology(interval)); [EOL]     long start = interval.getStartMillis(); [EOL]     long end = interval.getEndMillis(); [EOL]     int[] values = chrono.get(writablePeriod, start, end); [EOL]     for (int i = 0; i < values.length; i++) { [EOL]         writablePeriod.setValue(i, values[i]); [EOL]     } [EOL] }
public void setInto(ReadWritablePeriod writablePeriod, Object object, Chronology chrono) { [EOL]     ReadableInterval interval = (ReadableInterval) object; [EOL]     chrono = (chrono != null ? chrono : DateTimeUtils.getIntervalChronology(interval)); [EOL]     long start = interval.getStartMillis(); [EOL]     long end = interval.getEndMillis(); [EOL]     int[] values = chrono.get(writablePeriod, start, end); [EOL]     for (int i = 0; i < values.length; i++) { [EOL]         writablePeriod.setValue(i, values[i]); [EOL]     } [EOL] }
public boolean isReadableInterval(Object object, Chronology chrono) { [EOL]     return true; [EOL] }
public boolean isReadableInterval(Object object, Chronology chrono) { [EOL]     return true; [EOL] }
public boolean isReadableInterval(Object object, Chronology chrono) { [EOL]     return true; [EOL] }
public boolean isReadableInterval(Object object, Chronology chrono) { [EOL]     return true; [EOL] }
public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) { [EOL]     ReadableInterval input = (ReadableInterval) object; [EOL]     writableInterval.setInterval(input); [EOL]     if (chrono != null) { [EOL]         writableInterval.setChronology(chrono); [EOL]     } else { [EOL]         writableInterval.setChronology(input.getChronology()); [EOL]     } [EOL] }
public void setInto(ReadWritableInterval writableInterval, Object object, Chronology chrono) { [EOL]     ReadableInterval input = (ReadableInterval) object; [EOL]     writableInterval.setInterval(input); [EOL]     if (chrono != null) { [EOL]         writableInterval.setChronology(chrono); [EOL]     } else { [EOL]         writableInterval.setChronology(input.getChronology()); [EOL]     } [EOL] }
public Class<?> getSupportedType() { [EOL]     return ReadableInterval.class; [EOL] }
public String getName(Locale locale, String id, String nameKey) { [EOL]     String[] nameSet = getNameSet(locale, id, nameKey); [EOL]     return nameSet == null ? null : nameSet[1]; [EOL] }
public String getName(Locale locale, String id, String nameKey) { [EOL]     String[] nameSet = getNameSet(locale, id, nameKey); [EOL]     return nameSet == null ? null : nameSet[1]; [EOL] }
private synchronized String[] getNameSet(Locale locale, String id, String nameKey) { [EOL]     if (locale == null || id == null || nameKey == null) { [EOL]         return null; [EOL]     } [EOL]     Map<String, Map<String, Object>> byIdCache = iByLocaleCache.get(locale); [EOL]     if (byIdCache == null) { [EOL]         iByLocaleCache.put(locale, byIdCache = createCache()); [EOL]     } [EOL]     Map<String, Object> byNameKeyCache = byIdCache.get(id); [EOL]     if (byNameKeyCache == null) { [EOL]         byIdCache.put(id, byNameKeyCache = createCache()); [EOL]         String[][] zoneStringsEn = DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings(); [EOL]         String[] setEn = null; [EOL]         for (String[] strings : zoneStringsEn) { [EOL]             if (strings != null && strings.length == 5 && id.equals(strings[0])) { [EOL]                 setEn = strings; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         String[][] zoneStringsLoc = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings(); [EOL]         String[] setLoc = null; [EOL]         for (String[] strings : zoneStringsLoc) { [EOL]             if (strings != null && strings.length == 5 && id.equals(strings[0])) { [EOL]                 setLoc = strings; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (setEn != null && setLoc != null) { [EOL]             byNameKeyCache.put(setEn[2], new String[] { setLoc[2], setLoc[1] }); [EOL]             if (setEn[2].equals(setEn[4])) { [EOL]                 byNameKeyCache.put(setEn[4] + "-Summer", new String[] { setLoc[4], setLoc[3] }); [EOL]             } else { [EOL]                 byNameKeyCache.put(setEn[4], new String[] { setLoc[4], setLoc[3] }); [EOL]             } [EOL]         } [EOL]     } [EOL]     return (String[]) byNameKeyCache.get(nameKey); [EOL] }
private synchronized String[] getNameSet(Locale locale, String id, String nameKey) { [EOL]     if (locale == null || id == null || nameKey == null) { [EOL]         return null; [EOL]     } [EOL]     Map<String, Map<String, Object>> byIdCache = iByLocaleCache.get(locale); [EOL]     if (byIdCache == null) { [EOL]         iByLocaleCache.put(locale, byIdCache = createCache()); [EOL]     } [EOL]     Map<String, Object> byNameKeyCache = byIdCache.get(id); [EOL]     if (byNameKeyCache == null) { [EOL]         byIdCache.put(id, byNameKeyCache = createCache()); [EOL]         String[][] zoneStringsEn = DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings(); [EOL]         String[] setEn = null; [EOL]         for (String[] strings : zoneStringsEn) { [EOL]             if (strings != null && strings.length == 5 && id.equals(strings[0])) { [EOL]                 setEn = strings; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         String[][] zoneStringsLoc = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings(); [EOL]         String[] setLoc = null; [EOL]         for (String[] strings : zoneStringsLoc) { [EOL]             if (strings != null && strings.length == 5 && id.equals(strings[0])) { [EOL]                 setLoc = strings; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (setEn != null && setLoc != null) { [EOL]             byNameKeyCache.put(setEn[2], new String[] { setLoc[2], setLoc[1] }); [EOL]             if (setEn[2].equals(setEn[4])) { [EOL]                 byNameKeyCache.put(setEn[4] + "-Summer", new String[] { setLoc[4], setLoc[3] }); [EOL]             } else { [EOL]                 byNameKeyCache.put(setEn[4], new String[] { setLoc[4], setLoc[3] }); [EOL]             } [EOL]         } [EOL]     } [EOL]     return (String[]) byNameKeyCache.get(nameKey); [EOL] }
private synchronized String[] getNameSet(Locale locale, String id, String nameKey) { [EOL]     if (locale == null || id == null || nameKey == null) { [EOL]         return null; [EOL]     } [EOL]     Map<String, Map<String, Object>> byIdCache = iByLocaleCache.get(locale); [EOL]     if (byIdCache == null) { [EOL]         iByLocaleCache.put(locale, byIdCache = createCache()); [EOL]     } [EOL]     Map<String, Object> byNameKeyCache = byIdCache.get(id); [EOL]     if (byNameKeyCache == null) { [EOL]         byIdCache.put(id, byNameKeyCache = createCache()); [EOL]         String[][] zoneStringsEn = DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings(); [EOL]         String[] setEn = null; [EOL]         for (String[] strings : zoneStringsEn) { [EOL]             if (strings != null && strings.length == 5 && id.equals(strings[0])) { [EOL]                 setEn = strings; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         String[][] zoneStringsLoc = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings(); [EOL]         String[] setLoc = null; [EOL]         for (String[] strings : zoneStringsLoc) { [EOL]             if (strings != null && strings.length == 5 && id.equals(strings[0])) { [EOL]                 setLoc = strings; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (setEn != null && setLoc != null) { [EOL]             byNameKeyCache.put(setEn[2], new String[] { setLoc[2], setLoc[1] }); [EOL]             if (setEn[2].equals(setEn[4])) { [EOL]                 byNameKeyCache.put(setEn[4] + "-Summer", new String[] { setLoc[4], setLoc[3] }); [EOL]             } else { [EOL]                 byNameKeyCache.put(setEn[4], new String[] { setLoc[4], setLoc[3] }); [EOL]             } [EOL]         } [EOL]     } [EOL]     return (String[]) byNameKeyCache.get(nameKey); [EOL] }
private synchronized String[] getNameSet(Locale locale, String id, String nameKey) { [EOL]     if (locale == null || id == null || nameKey == null) { [EOL]         return null; [EOL]     } [EOL]     Map<String, Map<String, Object>> byIdCache = iByLocaleCache.get(locale); [EOL]     if (byIdCache == null) { [EOL]         iByLocaleCache.put(locale, byIdCache = createCache()); [EOL]     } [EOL]     Map<String, Object> byNameKeyCache = byIdCache.get(id); [EOL]     if (byNameKeyCache == null) { [EOL]         byIdCache.put(id, byNameKeyCache = createCache()); [EOL]         String[][] zoneStringsEn = DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings(); [EOL]         String[] setEn = null; [EOL]         for (String[] strings : zoneStringsEn) { [EOL]             if (strings != null && strings.length == 5 && id.equals(strings[0])) { [EOL]                 setEn = strings; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         String[][] zoneStringsLoc = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings(); [EOL]         String[] setLoc = null; [EOL]         for (String[] strings : zoneStringsLoc) { [EOL]             if (strings != null && strings.length == 5 && id.equals(strings[0])) { [EOL]                 setLoc = strings; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (setEn != null && setLoc != null) { [EOL]             byNameKeyCache.put(setEn[2], new String[] { setLoc[2], setLoc[1] }); [EOL]             if (setEn[2].equals(setEn[4])) { [EOL]                 byNameKeyCache.put(setEn[4] + "-Summer", new String[] { setLoc[4], setLoc[3] }); [EOL]             } else { [EOL]                 byNameKeyCache.put(setEn[4], new String[] { setLoc[4], setLoc[3] }); [EOL]             } [EOL]         } [EOL]     } [EOL]     return (String[]) byNameKeyCache.get(nameKey); [EOL] }
private synchronized String[] getNameSet(Locale locale, String id, String nameKey) { [EOL]     if (locale == null || id == null || nameKey == null) { [EOL]         return null; [EOL]     } [EOL]     Map<String, Map<String, Object>> byIdCache = iByLocaleCache.get(locale); [EOL]     if (byIdCache == null) { [EOL]         iByLocaleCache.put(locale, byIdCache = createCache()); [EOL]     } [EOL]     Map<String, Object> byNameKeyCache = byIdCache.get(id); [EOL]     if (byNameKeyCache == null) { [EOL]         byIdCache.put(id, byNameKeyCache = createCache()); [EOL]         String[][] zoneStringsEn = DateTimeUtils.getDateFormatSymbols(Locale.ENGLISH).getZoneStrings(); [EOL]         String[] setEn = null; [EOL]         for (String[] strings : zoneStringsEn) { [EOL]             if (strings != null && strings.length == 5 && id.equals(strings[0])) { [EOL]                 setEn = strings; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         String[][] zoneStringsLoc = DateTimeUtils.getDateFormatSymbols(locale).getZoneStrings(); [EOL]         String[] setLoc = null; [EOL]         for (String[] strings : zoneStringsLoc) { [EOL]             if (strings != null && strings.length == 5 && id.equals(strings[0])) { [EOL]                 setLoc = strings; [EOL]                 break; [EOL]             } [EOL]         } [EOL]         if (setEn != null && setLoc != null) { [EOL]             byNameKeyCache.put(setEn[2], new String[] { setLoc[2], setLoc[1] }); [EOL]             if (setEn[2].equals(setEn[4])) { [EOL]                 byNameKeyCache.put(setEn[4] + "-Summer", new String[] { setLoc[4], setLoc[3] }); [EOL]             } else { [EOL]                 byNameKeyCache.put(setEn[4], new String[] { setLoc[4], setLoc[3] }); [EOL]             } [EOL]         } [EOL]     } [EOL]     return (String[]) byNameKeyCache.get(nameKey); [EOL] }
private HashMap createCache() { [EOL]     return new HashMap(7); [EOL] }
public int eraTextToValue(String text) { [EOL]     Integer era = iParseEras.get(text); [EOL]     if (era != null) { [EOL]         return era.intValue(); [EOL]     } [EOL]     throw new IllegalFieldValueException(DateTimeFieldType.era(), text); [EOL] }
public int eraTextToValue(String text) { [EOL]     Integer era = iParseEras.get(text); [EOL]     if (era != null) { [EOL]         return era.intValue(); [EOL]     } [EOL]     throw new IllegalFieldValueException(DateTimeFieldType.era(), text); [EOL] }
public String dayOfWeekValueToShortText(int value) { [EOL]     return iShortDaysOfWeek[value]; [EOL] }
public String dayOfWeekValueToShortText(int value) { [EOL]     return iShortDaysOfWeek[value]; [EOL] }
public String dayOfWeekValueToShortText(int value) { [EOL]     return iShortDaysOfWeek[value]; [EOL] }
public int dayOfWeekTextToValue(String text) { [EOL]     Integer day = iParseDaysOfWeek.get(text); [EOL]     if (day != null) { [EOL]         return day.intValue(); [EOL]     } [EOL]     throw new IllegalFieldValueException(DateTimeFieldType.dayOfWeek(), text); [EOL] }
public int dayOfWeekTextToValue(String text) { [EOL]     Integer day = iParseDaysOfWeek.get(text); [EOL]     if (day != null) { [EOL]         return day.intValue(); [EOL]     } [EOL]     throw new IllegalFieldValueException(DateTimeFieldType.dayOfWeek(), text); [EOL] }
public MutableDateTime toMutableDateTime() { [EOL]     return new MutableDateTime(getMillis(), getZone()); [EOL] }
public MutableDateTime toMutableDateTime(DateTimeZone zone) { [EOL]     Chronology chrono = DateTimeUtils.getChronology(getChronology()); [EOL]     chrono = chrono.withZone(zone); [EOL]     return new MutableDateTime(getMillis(), chrono); [EOL] }
public MutableDateTime toMutableDateTime(DateTimeZone zone) { [EOL]     Chronology chrono = DateTimeUtils.getChronology(getChronology()); [EOL]     chrono = chrono.withZone(zone); [EOL]     return new MutableDateTime(getMillis(), chrono); [EOL] }
public boolean equals(Object readableInstant) { [EOL]     if (this == readableInstant) { [EOL]         return true; [EOL]     } [EOL]     if (readableInstant instanceof ReadableInstant == false) { [EOL]         return false; [EOL]     } [EOL]     ReadableInstant otherInstant = (ReadableInstant) readableInstant; [EOL]     return getMillis() == otherInstant.getMillis() && FieldUtils.equals(getChronology(), otherInstant.getChronology()); [EOL] }
public boolean equals(Object readableInstant) { [EOL]     if (this == readableInstant) { [EOL]         return true; [EOL]     } [EOL]     if (readableInstant instanceof ReadableInstant == false) { [EOL]         return false; [EOL]     } [EOL]     ReadableInstant otherInstant = (ReadableInstant) readableInstant; [EOL]     return getMillis() == otherInstant.getMillis() && FieldUtils.equals(getChronology(), otherInstant.getChronology()); [EOL] }
public boolean equals(Object readableInstant) { [EOL]     if (this == readableInstant) { [EOL]         return true; [EOL]     } [EOL]     if (readableInstant instanceof ReadableInstant == false) { [EOL]         return false; [EOL]     } [EOL]     ReadableInstant otherInstant = (ReadableInstant) readableInstant; [EOL]     return getMillis() == otherInstant.getMillis() && FieldUtils.equals(getChronology(), otherInstant.getChronology()); [EOL] }
public boolean equals(Object readableInstant) { [EOL]     if (this == readableInstant) { [EOL]         return true; [EOL]     } [EOL]     if (readableInstant instanceof ReadableInstant == false) { [EOL]         return false; [EOL]     } [EOL]     ReadableInstant otherInstant = (ReadableInstant) readableInstant; [EOL]     return getMillis() == otherInstant.getMillis() && FieldUtils.equals(getChronology(), otherInstant.getChronology()); [EOL] }
public boolean equals(Object readableInstant) { [EOL]     if (this == readableInstant) { [EOL]         return true; [EOL]     } [EOL]     if (readableInstant instanceof ReadableInstant == false) { [EOL]         return false; [EOL]     } [EOL]     ReadableInstant otherInstant = (ReadableInstant) readableInstant; [EOL]     return getMillis() == otherInstant.getMillis() && FieldUtils.equals(getChronology(), otherInstant.getChronology()); [EOL] }
public boolean equals(Object readableInstant) { [EOL]     if (this == readableInstant) { [EOL]         return true; [EOL]     } [EOL]     if (readableInstant instanceof ReadableInstant == false) { [EOL]         return false; [EOL]     } [EOL]     ReadableInstant otherInstant = (ReadableInstant) readableInstant; [EOL]     return getMillis() == otherInstant.getMillis() && FieldUtils.equals(getChronology(), otherInstant.getChronology()); [EOL] }
public boolean isBefore(long instant) { [EOL]     return (getMillis() < instant); [EOL] }
public boolean isBefore(long instant) { [EOL]     return (getMillis() < instant); [EOL] }
public boolean isBefore(long instant) { [EOL]     return (getMillis() < instant); [EOL] }
public boolean isBefore(ReadableInstant instant) { [EOL]     long instantMillis = DateTimeUtils.getInstantMillis(instant); [EOL]     return isBefore(instantMillis); [EOL] }
public boolean isBefore(ReadableInstant instant) { [EOL]     long instantMillis = DateTimeUtils.getInstantMillis(instant); [EOL]     return isBefore(instantMillis); [EOL] }
public boolean isBefore(ReadableInstant instant) { [EOL]     long instantMillis = DateTimeUtils.getInstantMillis(instant); [EOL]     return isBefore(instantMillis); [EOL] }
public boolean isBefore(ReadableInstant instant) { [EOL]     long instantMillis = DateTimeUtils.getInstantMillis(instant); [EOL]     return isBefore(instantMillis); [EOL] }
public boolean isEqual(ReadableInstant instant) { [EOL]     long instantMillis = DateTimeUtils.getInstantMillis(instant); [EOL]     return isEqual(instantMillis); [EOL] }
public boolean isEqual(ReadableInstant instant) { [EOL]     long instantMillis = DateTimeUtils.getInstantMillis(instant); [EOL]     return isEqual(instantMillis); [EOL] }
public boolean isEqual(ReadableInstant instant) { [EOL]     long instantMillis = DateTimeUtils.getInstantMillis(instant); [EOL]     return isEqual(instantMillis); [EOL] }
public void setInterval(ReadableInstant start, ReadableInstant end) { [EOL]     if (start == null && end == null) { [EOL]         long now = DateTimeUtils.currentTimeMillis(); [EOL]         setInterval(now, now); [EOL]     } else { [EOL]         long startMillis = DateTimeUtils.getInstantMillis(start); [EOL]         long endMillis = DateTimeUtils.getInstantMillis(end); [EOL]         Chronology chrono = DateTimeUtils.getInstantChronology(start); [EOL]         super.setInterval(startMillis, endMillis, chrono); [EOL]     } [EOL] }
public void setInterval(ReadableInstant start, ReadableInstant end) { [EOL]     if (start == null && end == null) { [EOL]         long now = DateTimeUtils.currentTimeMillis(); [EOL]         setInterval(now, now); [EOL]     } else { [EOL]         long startMillis = DateTimeUtils.getInstantMillis(start); [EOL]         long endMillis = DateTimeUtils.getInstantMillis(end); [EOL]         Chronology chrono = DateTimeUtils.getInstantChronology(start); [EOL]         super.setInterval(startMillis, endMillis, chrono); [EOL]     } [EOL] }
public void setInterval(ReadableInstant start, ReadableInstant end) { [EOL]     if (start == null && end == null) { [EOL]         long now = DateTimeUtils.currentTimeMillis(); [EOL]         setInterval(now, now); [EOL]     } else { [EOL]         long startMillis = DateTimeUtils.getInstantMillis(start); [EOL]         long endMillis = DateTimeUtils.getInstantMillis(end); [EOL]         Chronology chrono = DateTimeUtils.getInstantChronology(start); [EOL]         super.setInterval(startMillis, endMillis, chrono); [EOL]     } [EOL] }
public void setInterval(ReadableInstant start, ReadableInstant end) { [EOL]     if (start == null && end == null) { [EOL]         long now = DateTimeUtils.currentTimeMillis(); [EOL]         setInterval(now, now); [EOL]     } else { [EOL]         long startMillis = DateTimeUtils.getInstantMillis(start); [EOL]         long endMillis = DateTimeUtils.getInstantMillis(end); [EOL]         Chronology chrono = DateTimeUtils.getInstantChronology(start); [EOL]         super.setInterval(startMillis, endMillis, chrono); [EOL]     } [EOL] }
public void setPeriodBeforeEnd(ReadablePeriod period) { [EOL]     if (period == null) { [EOL]         setStartMillis(getEndMillis()); [EOL]     } else { [EOL]         setStartMillis(getChronology().add(period, getEndMillis(), -1)); [EOL]     } [EOL] }
public void setPeriodBeforeEnd(ReadablePeriod period) { [EOL]     if (period == null) { [EOL]         setStartMillis(getEndMillis()); [EOL]     } else { [EOL]         setStartMillis(getChronology().add(period, getEndMillis(), -1)); [EOL]     } [EOL] }
public static DateMidnight parse(String str, DateTimeFormatter formatter) { [EOL]     return formatter.parseDateTime(str).toDateMidnight(); [EOL] }
public static DateMidnight parse(String str, DateTimeFormatter formatter) { [EOL]     return formatter.parseDateTime(str).toDateMidnight(); [EOL] }
public static DateMidnight parse(String str, DateTimeFormatter formatter) { [EOL]     return formatter.parseDateTime(str).toDateMidnight(); [EOL] }
public DateMidnight(Object instant, DateTimeZone zone) { [EOL]     super(instant, zone); [EOL] }
public DateMidnight(Object instant, DateTimeZone zone) { [EOL]     super(instant, zone); [EOL] }
public DateMidnight(Object instant, DateTimeZone zone) { [EOL]     super(instant, zone); [EOL] }
public DateMidnight(Object instant, DateTimeZone zone) { [EOL]     super(instant, zone); [EOL] }
public DateMidnight(int year, int monthOfYear, int dayOfMonth, Chronology chronology) { [EOL]     super(year, monthOfYear, dayOfMonth, 0, 0, 0, 0, chronology); [EOL] }
public DateMidnight(int year, int monthOfYear, int dayOfMonth, Chronology chronology) { [EOL]     super(year, monthOfYear, dayOfMonth, 0, 0, 0, 0, chronology); [EOL] }
public DateMidnight withMillis(long newMillis) { [EOL]     Chronology chrono = getChronology(); [EOL]     newMillis = checkInstant(newMillis, chrono); [EOL]     return (newMillis == getMillis() ? this : new DateMidnight(newMillis, chrono)); [EOL] }
public DateMidnight withMillis(long newMillis) { [EOL]     Chronology chrono = getChronology(); [EOL]     newMillis = checkInstant(newMillis, chrono); [EOL]     return (newMillis == getMillis() ? this : new DateMidnight(newMillis, chrono)); [EOL] }
public DateMidnight withField(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).set(getMillis(), value); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight withField(DateTimeFieldType fieldType, int value) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).set(getMillis(), value); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getMillis(), amount); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getMillis(), amount); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight withFieldAdded(DurationFieldType fieldType, int amount) { [EOL]     if (fieldType == null) { [EOL]         throw new IllegalArgumentException("Field must not be null"); [EOL]     } [EOL]     if (amount == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = fieldType.getField(getChronology()).add(getMillis(), amount); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight withDurationAdded(long durationToAdd, int scalar) { [EOL]     if (durationToAdd == 0 || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().add(getMillis(), durationToAdd, scalar); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight withDurationAdded(long durationToAdd, int scalar) { [EOL]     if (durationToAdd == 0 || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().add(getMillis(), durationToAdd, scalar); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight withDurationAdded(long durationToAdd, int scalar) { [EOL]     if (durationToAdd == 0 || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().add(getMillis(), durationToAdd, scalar); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight withDurationAdded(ReadableDuration durationToAdd, int scalar) { [EOL]     if (durationToAdd == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     return withDurationAdded(durationToAdd.getMillis(), scalar); [EOL] }
public DateMidnight withDurationAdded(ReadableDuration durationToAdd, int scalar) { [EOL]     if (durationToAdd == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     return withDurationAdded(durationToAdd.getMillis(), scalar); [EOL] }
public DateMidnight withDurationAdded(ReadableDuration durationToAdd, int scalar) { [EOL]     if (durationToAdd == null || scalar == 0) { [EOL]         return this; [EOL]     } [EOL]     return withDurationAdded(durationToAdd.getMillis(), scalar); [EOL] }
public DateMidnight plus(long duration) { [EOL]     return withDurationAdded(duration, 1); [EOL] }
public DateMidnight plus(ReadableDuration duration) { [EOL]     return withDurationAdded(duration, 1); [EOL] }
public DateMidnight minusYears(int years) { [EOL]     if (years == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().years().subtract(getMillis(), years); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight minusYears(int years) { [EOL]     if (years == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().years().subtract(getMillis(), years); [EOL]     return withMillis(instant); [EOL] }
public DateMidnight minusYears(int years) { [EOL]     if (years == 0) { [EOL]         return this; [EOL]     } [EOL]     long instant = getChronology().years().subtract(getMillis(), years); [EOL]     return withMillis(instant); [EOL] }
public Property property(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     DateTimeField field = type.getField(getChronology()); [EOL]     if (field.isSupported() == false) { [EOL]         throw new IllegalArgumentException("Field '" + type + "' is not supported"); [EOL]     } [EOL]     return new Property(this, field); [EOL] }
public Property property(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     DateTimeField field = type.getField(getChronology()); [EOL]     if (field.isSupported() == false) { [EOL]         throw new IllegalArgumentException("Field '" + type + "' is not supported"); [EOL]     } [EOL]     return new Property(this, field); [EOL] }
public Property property(DateTimeFieldType type) { [EOL]     if (type == null) { [EOL]         throw new IllegalArgumentException("The DateTimeFieldType must not be null"); [EOL]     } [EOL]     DateTimeField field = type.getField(getChronology()); [EOL]     if (field.isSupported() == false) { [EOL]         throw new IllegalArgumentException("Field '" + type + "' is not supported"); [EOL]     } [EOL]     return new Property(this, field); [EOL] }
public LocalDate toLocalDate() { [EOL]     return new LocalDate(getMillis(), getChronology()); [EOL] }
public Interval toInterval() { [EOL]     Chronology chrono = getChronology(); [EOL]     long start = getMillis(); [EOL]     long end = DurationFieldType.days().getField(chrono).add(start, 1); [EOL]     return new Interval(start, end, chrono); [EOL] }
public Interval toInterval() { [EOL]     Chronology chrono = getChronology(); [EOL]     long start = getMillis(); [EOL]     long end = DurationFieldType.days().getField(chrono).add(start, 1); [EOL]     return new Interval(start, end, chrono); [EOL] }
public Property dayOfMonth() { [EOL]     return new Property(this, getChronology().dayOfMonth()); [EOL] }
protected long getMillis() { [EOL]     return iInstant.getMillis(); [EOL] }
public DateMidnight getDateMidnight() { [EOL]     return iInstant; [EOL] }
public DateMidnight addToCopy(int value) { [EOL]     return iInstant.withMillis(iField.add(iInstant.getMillis(), value)); [EOL] }
public DateMidnight addToCopy(int value) { [EOL]     return iInstant.withMillis(iField.add(iInstant.getMillis(), value)); [EOL] }
public DateMidnight addToCopy(int value) { [EOL]     return iInstant.withMillis(iField.add(iInstant.getMillis(), value)); [EOL] }
public DateMidnight setCopy(int value) { [EOL]     return iInstant.withMillis(iField.set(iInstant.getMillis(), value)); [EOL] }
public DateMidnight setCopy(int value) { [EOL]     return iInstant.withMillis(iField.set(iInstant.getMillis(), value)); [EOL] }
public DateMidnight withMaximumValue() { [EOL]     return setCopy(getMaximumValue()); [EOL] }
public DateMidnight withMinimumValue() { [EOL]     return setCopy(getMinimumValue()); [EOL] }
public DateMidnight roundFloorCopy() { [EOL]     return iInstant.withMillis(iField.roundFloor(iInstant.getMillis())); [EOL] }
public DateMidnight roundCeilingCopy() { [EOL]     return iInstant.withMillis(iField.roundCeiling(iInstant.getMillis())); [EOL] }
protected BasePartial(Chronology chronology) { [EOL]     this(DateTimeUtils.currentTimeMillis(), chronology); [EOL] }
