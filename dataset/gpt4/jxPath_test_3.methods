public boolean computeContextDependent() { [EOL]     if (super.computeContextDependent()) { [EOL]         return true; [EOL]     } [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return true; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]         case Compiler.FUNCTION_NAME: [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]         case Compiler.FUNCTION_STRING: [EOL]         case Compiler.FUNCTION_LANG: [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return args == null || args.length == 0; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]         case Compiler.FUNCTION_ID: [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]         case Compiler.FUNCTION_NOT: [EOL]         case Compiler.FUNCTION_TRUE: [EOL]         case Compiler.FUNCTION_FALSE: [EOL]         case Compiler.FUNCTION_SUM: [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]         case Compiler.FUNCTION_CEILING: [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return false; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return args != null && args.length == 2; [EOL]     } [EOL]     return false; [EOL] }
public boolean computeContextDependent() { [EOL]     if (super.computeContextDependent()) { [EOL]         return true; [EOL]     } [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return true; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]         case Compiler.FUNCTION_NAME: [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]         case Compiler.FUNCTION_STRING: [EOL]         case Compiler.FUNCTION_LANG: [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return args == null || args.length == 0; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]         case Compiler.FUNCTION_ID: [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]         case Compiler.FUNCTION_NOT: [EOL]         case Compiler.FUNCTION_TRUE: [EOL]         case Compiler.FUNCTION_FALSE: [EOL]         case Compiler.FUNCTION_SUM: [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]         case Compiler.FUNCTION_CEILING: [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return false; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return args != null && args.length == 2; [EOL]     } [EOL]     return false; [EOL] }
public boolean computeContextDependent() { [EOL]     if (super.computeContextDependent()) { [EOL]         return true; [EOL]     } [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return true; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]         case Compiler.FUNCTION_NAME: [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]         case Compiler.FUNCTION_STRING: [EOL]         case Compiler.FUNCTION_LANG: [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return args == null || args.length == 0; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]         case Compiler.FUNCTION_ID: [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]         case Compiler.FUNCTION_NOT: [EOL]         case Compiler.FUNCTION_TRUE: [EOL]         case Compiler.FUNCTION_FALSE: [EOL]         case Compiler.FUNCTION_SUM: [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]         case Compiler.FUNCTION_CEILING: [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return false; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return args != null && args.length == 2; [EOL]     } [EOL]     return false; [EOL] }
public boolean computeContextDependent() { [EOL]     if (super.computeContextDependent()) { [EOL]         return true; [EOL]     } [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return true; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]         case Compiler.FUNCTION_NAME: [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]         case Compiler.FUNCTION_STRING: [EOL]         case Compiler.FUNCTION_LANG: [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return args == null || args.length == 0; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]         case Compiler.FUNCTION_ID: [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]         case Compiler.FUNCTION_NOT: [EOL]         case Compiler.FUNCTION_TRUE: [EOL]         case Compiler.FUNCTION_FALSE: [EOL]         case Compiler.FUNCTION_SUM: [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]         case Compiler.FUNCTION_CEILING: [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return false; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return args != null && args.length == 2; [EOL]     } [EOL]     return false; [EOL] }
public boolean computeContextDependent() { [EOL]     if (super.computeContextDependent()) { [EOL]         return true; [EOL]     } [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return true; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]         case Compiler.FUNCTION_NAME: [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]         case Compiler.FUNCTION_STRING: [EOL]         case Compiler.FUNCTION_LANG: [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return args == null || args.length == 0; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]         case Compiler.FUNCTION_ID: [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]         case Compiler.FUNCTION_NOT: [EOL]         case Compiler.FUNCTION_TRUE: [EOL]         case Compiler.FUNCTION_FALSE: [EOL]         case Compiler.FUNCTION_SUM: [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]         case Compiler.FUNCTION_CEILING: [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return false; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return args != null && args.length == 2; [EOL]     } [EOL]     return false; [EOL] }
public boolean computeContextDependent() { [EOL]     if (super.computeContextDependent()) { [EOL]         return true; [EOL]     } [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return true; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]         case Compiler.FUNCTION_NAME: [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]         case Compiler.FUNCTION_STRING: [EOL]         case Compiler.FUNCTION_LANG: [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return args == null || args.length == 0; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]         case Compiler.FUNCTION_ID: [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]         case Compiler.FUNCTION_NOT: [EOL]         case Compiler.FUNCTION_TRUE: [EOL]         case Compiler.FUNCTION_FALSE: [EOL]         case Compiler.FUNCTION_SUM: [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]         case Compiler.FUNCTION_CEILING: [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return false; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return args != null && args.length == 2; [EOL]     } [EOL]     return false; [EOL] }
public boolean computeContextDependent() { [EOL]     if (super.computeContextDependent()) { [EOL]         return true; [EOL]     } [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return true; [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]         case Compiler.FUNCTION_NAME: [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]         case Compiler.FUNCTION_STRING: [EOL]         case Compiler.FUNCTION_LANG: [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return args == null || args.length == 0; [EOL]         case Compiler.FUNCTION_COUNT: [EOL]         case Compiler.FUNCTION_ID: [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]         case Compiler.FUNCTION_NOT: [EOL]         case Compiler.FUNCTION_TRUE: [EOL]         case Compiler.FUNCTION_FALSE: [EOL]         case Compiler.FUNCTION_SUM: [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]         case Compiler.FUNCTION_CEILING: [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return false; [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return args != null && args.length == 2; [EOL]     } [EOL]     return false; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     switch(functionCode) { [EOL]         case Compiler.FUNCTION_LAST: [EOL]             return functionLast(context); [EOL]         case Compiler.FUNCTION_POSITION: [EOL]             return functionPosition(context); [EOL]         case Compiler.FUNCTION_COUNT: [EOL]             return functionCount(context); [EOL]         case Compiler.FUNCTION_LANG: [EOL]             return functionLang(context); [EOL]         case Compiler.FUNCTION_ID: [EOL]             return functionID(context); [EOL]         case Compiler.FUNCTION_LOCAL_NAME: [EOL]             return functionLocalName(context); [EOL]         case Compiler.FUNCTION_NAMESPACE_URI: [EOL]             return functionNamespaceURI(context); [EOL]         case Compiler.FUNCTION_NAME: [EOL]             return functionName(context); [EOL]         case Compiler.FUNCTION_STRING: [EOL]             return functionString(context); [EOL]         case Compiler.FUNCTION_CONCAT: [EOL]             return functionConcat(context); [EOL]         case Compiler.FUNCTION_STARTS_WITH: [EOL]             return functionStartsWith(context); [EOL]         case Compiler.FUNCTION_CONTAINS: [EOL]             return functionContains(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_BEFORE: [EOL]             return functionSubstringBefore(context); [EOL]         case Compiler.FUNCTION_SUBSTRING_AFTER: [EOL]             return functionSubstringAfter(context); [EOL]         case Compiler.FUNCTION_SUBSTRING: [EOL]             return functionSubstring(context); [EOL]         case Compiler.FUNCTION_STRING_LENGTH: [EOL]             return functionStringLength(context); [EOL]         case Compiler.FUNCTION_NORMALIZE_SPACE: [EOL]             return functionNormalizeSpace(context); [EOL]         case Compiler.FUNCTION_TRANSLATE: [EOL]             return functionTranslate(context); [EOL]         case Compiler.FUNCTION_BOOLEAN: [EOL]             return functionBoolean(context); [EOL]         case Compiler.FUNCTION_NOT: [EOL]             return functionNot(context); [EOL]         case Compiler.FUNCTION_TRUE: [EOL]             return functionTrue(context); [EOL]         case Compiler.FUNCTION_FALSE: [EOL]             return functionFalse(context); [EOL]         case Compiler.FUNCTION_NULL: [EOL]             return functionNull(context); [EOL]         case Compiler.FUNCTION_NUMBER: [EOL]             return functionNumber(context); [EOL]         case Compiler.FUNCTION_SUM: [EOL]             return functionSum(context); [EOL]         case Compiler.FUNCTION_FLOOR: [EOL]             return functionFloor(context); [EOL]         case Compiler.FUNCTION_CEILING: [EOL]             return functionCeiling(context); [EOL]         case Compiler.FUNCTION_ROUND: [EOL]             return functionRound(context); [EOL]         case Compiler.FUNCTION_KEY: [EOL]             return functionKey(context); [EOL]         case Compiler.FUNCTION_FORMAT_NUMBER: [EOL]             return functionFormatNumber(context); [EOL]     } [EOL]     return null; [EOL] }
protected Object functionCount(EvalContext context) { [EOL]     assertArgCount(1); [EOL]     Expression arg1 = getArg1(); [EOL]     int count = 0; [EOL]     Object value = arg1.compute(context); [EOL]     if (value instanceof NodePointer) { [EOL]         value = ((NodePointer) value).getValue(); [EOL]     } [EOL]     if (value instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) value; [EOL]         while (ctx.hasNext()) { [EOL]             ctx.next(); [EOL]             count++; [EOL]         } [EOL]     } else if (value instanceof Collection) { [EOL]         count = ((Collection) value).size(); [EOL]     } else if (value == null) { [EOL]         count = 0; [EOL]     } else { [EOL]         count = 1; [EOL]     } [EOL]     return new Double(count); [EOL] }
protected Object functionNamespaceURI(EvalContext context) { [EOL]     if (getArgumentCount() == 0) { [EOL]         NodePointer ptr = context.getCurrentNodePointer(); [EOL]         String str = ptr.getNamespaceURI(); [EOL]         return str == null ? "" : str; [EOL]     } [EOL]     assertArgCount(1); [EOL]     Object set = getArg1().compute(context); [EOL]     if (set instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) set; [EOL]         if (ctx.hasNext()) { [EOL]             NodePointer ptr = (NodePointer) ctx.next(); [EOL]             String str = ptr.getNamespaceURI(); [EOL]             return str == null ? "" : str; [EOL]         } [EOL]     } [EOL]     return ""; [EOL] }
protected Object functionNamespaceURI(EvalContext context) { [EOL]     if (getArgumentCount() == 0) { [EOL]         NodePointer ptr = context.getCurrentNodePointer(); [EOL]         String str = ptr.getNamespaceURI(); [EOL]         return str == null ? "" : str; [EOL]     } [EOL]     assertArgCount(1); [EOL]     Object set = getArg1().compute(context); [EOL]     if (set instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) set; [EOL]         if (ctx.hasNext()) { [EOL]             NodePointer ptr = (NodePointer) ctx.next(); [EOL]             String str = ptr.getNamespaceURI(); [EOL]             return str == null ? "" : str; [EOL]         } [EOL]     } [EOL]     return ""; [EOL] }
protected Object functionNamespaceURI(EvalContext context) { [EOL]     if (getArgumentCount() == 0) { [EOL]         NodePointer ptr = context.getCurrentNodePointer(); [EOL]         String str = ptr.getNamespaceURI(); [EOL]         return str == null ? "" : str; [EOL]     } [EOL]     assertArgCount(1); [EOL]     Object set = getArg1().compute(context); [EOL]     if (set instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) set; [EOL]         if (ctx.hasNext()) { [EOL]             NodePointer ptr = (NodePointer) ctx.next(); [EOL]             String str = ptr.getNamespaceURI(); [EOL]             return str == null ? "" : str; [EOL]         } [EOL]     } [EOL]     return ""; [EOL] }
protected Object functionNamespaceURI(EvalContext context) { [EOL]     if (getArgumentCount() == 0) { [EOL]         NodePointer ptr = context.getCurrentNodePointer(); [EOL]         String str = ptr.getNamespaceURI(); [EOL]         return str == null ? "" : str; [EOL]     } [EOL]     assertArgCount(1); [EOL]     Object set = getArg1().compute(context); [EOL]     if (set instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) set; [EOL]         if (ctx.hasNext()) { [EOL]             NodePointer ptr = (NodePointer) ctx.next(); [EOL]             String str = ptr.getNamespaceURI(); [EOL]             return str == null ? "" : str; [EOL]         } [EOL]     } [EOL]     return ""; [EOL] }
protected Object functionLocalName(EvalContext context) { [EOL]     if (getArgumentCount() == 0) { [EOL]         NodePointer ptr = context.getCurrentNodePointer(); [EOL]         return ptr.getName().getName(); [EOL]     } [EOL]     assertArgCount(1); [EOL]     Object set = getArg1().compute(context); [EOL]     if (set instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) set; [EOL]         if (ctx.hasNext()) { [EOL]             NodePointer ptr = (NodePointer) ctx.next(); [EOL]             return ptr.getName().getName(); [EOL]         } [EOL]     } [EOL]     return ""; [EOL] }
protected Object functionLocalName(EvalContext context) { [EOL]     if (getArgumentCount() == 0) { [EOL]         NodePointer ptr = context.getCurrentNodePointer(); [EOL]         return ptr.getName().getName(); [EOL]     } [EOL]     assertArgCount(1); [EOL]     Object set = getArg1().compute(context); [EOL]     if (set instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) set; [EOL]         if (ctx.hasNext()) { [EOL]             NodePointer ptr = (NodePointer) ctx.next(); [EOL]             return ptr.getName().getName(); [EOL]         } [EOL]     } [EOL]     return ""; [EOL] }
protected Object functionLocalName(EvalContext context) { [EOL]     if (getArgumentCount() == 0) { [EOL]         NodePointer ptr = context.getCurrentNodePointer(); [EOL]         return ptr.getName().getName(); [EOL]     } [EOL]     assertArgCount(1); [EOL]     Object set = getArg1().compute(context); [EOL]     if (set instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) set; [EOL]         if (ctx.hasNext()) { [EOL]             NodePointer ptr = (NodePointer) ctx.next(); [EOL]             return ptr.getName().getName(); [EOL]         } [EOL]     } [EOL]     return ""; [EOL] }
protected Object functionName(EvalContext context) { [EOL]     if (getArgumentCount() == 0) { [EOL]         NodePointer ptr = context.getCurrentNodePointer(); [EOL]         return ptr.getName().toString(); [EOL]     } [EOL]     assertArgCount(1); [EOL]     Object set = getArg1().compute(context); [EOL]     if (set instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) set; [EOL]         if (ctx.hasNext()) { [EOL]             NodePointer ptr = (NodePointer) ctx.next(); [EOL]             return ptr.getName().toString(); [EOL]         } [EOL]     } [EOL]     return ""; [EOL] }
protected Object functionName(EvalContext context) { [EOL]     if (getArgumentCount() == 0) { [EOL]         NodePointer ptr = context.getCurrentNodePointer(); [EOL]         return ptr.getName().toString(); [EOL]     } [EOL]     assertArgCount(1); [EOL]     Object set = getArg1().compute(context); [EOL]     if (set instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) set; [EOL]         if (ctx.hasNext()) { [EOL]             NodePointer ptr = (NodePointer) ctx.next(); [EOL]             return ptr.getName().toString(); [EOL]         } [EOL]     } [EOL]     return ""; [EOL] }
protected Object functionName(EvalContext context) { [EOL]     if (getArgumentCount() == 0) { [EOL]         NodePointer ptr = context.getCurrentNodePointer(); [EOL]         return ptr.getName().toString(); [EOL]     } [EOL]     assertArgCount(1); [EOL]     Object set = getArg1().compute(context); [EOL]     if (set instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) set; [EOL]         if (ctx.hasNext()) { [EOL]             NodePointer ptr = (NodePointer) ctx.next(); [EOL]             return ptr.getName().toString(); [EOL]         } [EOL]     } [EOL]     return ""; [EOL] }
protected Object functionString(EvalContext context) { [EOL]     if (getArgumentCount() == 0) { [EOL]         return InfoSetUtil.stringValue(context.getCurrentNodePointer()); [EOL]     } [EOL]     assertArgCount(1); [EOL]     return InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL] }
protected Object functionString(EvalContext context) { [EOL]     if (getArgumentCount() == 0) { [EOL]         return InfoSetUtil.stringValue(context.getCurrentNodePointer()); [EOL]     } [EOL]     assertArgCount(1); [EOL]     return InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL] }
protected Object functionConcat(EvalContext context) { [EOL]     if (getArgumentCount() < 2) { [EOL]         assertArgCount(2); [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     Expression[] args = getArguments(); [EOL]     for (int i = 0; i < args.length; i++) { [EOL]         buffer.append(InfoSetUtil.stringValue(args[i].compute(context))); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
protected Object functionConcat(EvalContext context) { [EOL]     if (getArgumentCount() < 2) { [EOL]         assertArgCount(2); [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     Expression[] args = getArguments(); [EOL]     for (int i = 0; i < args.length; i++) { [EOL]         buffer.append(InfoSetUtil.stringValue(args[i].compute(context))); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
protected Object functionConcat(EvalContext context) { [EOL]     if (getArgumentCount() < 2) { [EOL]         assertArgCount(2); [EOL]     } [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     Expression[] args = getArguments(); [EOL]     for (int i = 0; i < args.length; i++) { [EOL]         buffer.append(InfoSetUtil.stringValue(args[i].compute(context))); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
protected Object functionStartsWith(EvalContext context) { [EOL]     assertArgCount(2); [EOL]     String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context)); [EOL]     return s1.startsWith(s2) ? Boolean.TRUE : Boolean.FALSE; [EOL] }
protected Object functionStartsWith(EvalContext context) { [EOL]     assertArgCount(2); [EOL]     String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context)); [EOL]     return s1.startsWith(s2) ? Boolean.TRUE : Boolean.FALSE; [EOL] }
protected Object functionStartsWith(EvalContext context) { [EOL]     assertArgCount(2); [EOL]     String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context)); [EOL]     return s1.startsWith(s2) ? Boolean.TRUE : Boolean.FALSE; [EOL] }
protected Object functionStartsWith(EvalContext context) { [EOL]     assertArgCount(2); [EOL]     String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context)); [EOL]     return s1.startsWith(s2) ? Boolean.TRUE : Boolean.FALSE; [EOL] }
protected Object functionStartsWith(EvalContext context) { [EOL]     assertArgCount(2); [EOL]     String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context)); [EOL]     return s1.startsWith(s2) ? Boolean.TRUE : Boolean.FALSE; [EOL] }
protected Object functionContains(EvalContext context) { [EOL]     assertArgCount(2); [EOL]     String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context)); [EOL]     return s1.indexOf(s2) != -1 ? Boolean.TRUE : Boolean.FALSE; [EOL] }
protected Object functionContains(EvalContext context) { [EOL]     assertArgCount(2); [EOL]     String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context)); [EOL]     return s1.indexOf(s2) != -1 ? Boolean.TRUE : Boolean.FALSE; [EOL] }
protected Object functionContains(EvalContext context) { [EOL]     assertArgCount(2); [EOL]     String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context)); [EOL]     return s1.indexOf(s2) != -1 ? Boolean.TRUE : Boolean.FALSE; [EOL] }
protected Object functionContains(EvalContext context) { [EOL]     assertArgCount(2); [EOL]     String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context)); [EOL]     return s1.indexOf(s2) != -1 ? Boolean.TRUE : Boolean.FALSE; [EOL] }
protected Object functionSubstringBefore(EvalContext context) { [EOL]     assertArgCount(2); [EOL]     String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context)); [EOL]     int index = s1.indexOf(s2); [EOL]     if (index == -1) { [EOL]         return ""; [EOL]     } [EOL]     return s1.substring(0, index); [EOL] }
protected Object functionSubstringBefore(EvalContext context) { [EOL]     assertArgCount(2); [EOL]     String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context)); [EOL]     int index = s1.indexOf(s2); [EOL]     if (index == -1) { [EOL]         return ""; [EOL]     } [EOL]     return s1.substring(0, index); [EOL] }
protected Object functionSubstringBefore(EvalContext context) { [EOL]     assertArgCount(2); [EOL]     String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context)); [EOL]     int index = s1.indexOf(s2); [EOL]     if (index == -1) { [EOL]         return ""; [EOL]     } [EOL]     return s1.substring(0, index); [EOL] }
protected Object functionSubstringBefore(EvalContext context) { [EOL]     assertArgCount(2); [EOL]     String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context)); [EOL]     int index = s1.indexOf(s2); [EOL]     if (index == -1) { [EOL]         return ""; [EOL]     } [EOL]     return s1.substring(0, index); [EOL] }
protected Object functionSubstringAfter(EvalContext context) { [EOL]     assertArgCount(2); [EOL]     String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context)); [EOL]     int index = s1.indexOf(s2); [EOL]     if (index == -1) { [EOL]         return ""; [EOL]     } [EOL]     return s1.substring(index + s2.length()); [EOL] }
protected Object functionSubstring(EvalContext context) { [EOL]     int ac = getArgumentCount(); [EOL]     if (ac != 2 && ac != 3) { [EOL]         assertArgCount(2); [EOL]     } [EOL]     String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     double from = InfoSetUtil.doubleValue(getArg2().computeValue(context)); [EOL]     if (Double.isNaN(from)) { [EOL]         return ""; [EOL]     } [EOL]     from = Math.round(from); [EOL]     if (from > s1.length() + 1) { [EOL]         return ""; [EOL]     } [EOL]     if (ac == 2) { [EOL]         if (from < 1) { [EOL]             from = 1; [EOL]         } [EOL]         return s1.substring((int) from - 1); [EOL]     } else { [EOL]         double length = InfoSetUtil.doubleValue(getArg3().computeValue(context)); [EOL]         length = Math.round(length); [EOL]         if (length < 0) { [EOL]             return ""; [EOL]         } [EOL]         double to = from + length; [EOL]         if (to < 1) { [EOL]             return ""; [EOL]         } [EOL]         if (to > s1.length() + 1) { [EOL]             if (from < 1) { [EOL]                 from = 1; [EOL]             } [EOL]             return s1.substring((int) from - 1); [EOL]         } [EOL]         if (from < 1) { [EOL]             from = 1; [EOL]         } [EOL]         return s1.substring((int) from - 1, (int) (to - 1)); [EOL]     } [EOL] }
protected Object functionSubstring(EvalContext context) { [EOL]     int ac = getArgumentCount(); [EOL]     if (ac != 2 && ac != 3) { [EOL]         assertArgCount(2); [EOL]     } [EOL]     String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     double from = InfoSetUtil.doubleValue(getArg2().computeValue(context)); [EOL]     if (Double.isNaN(from)) { [EOL]         return ""; [EOL]     } [EOL]     from = Math.round(from); [EOL]     if (from > s1.length() + 1) { [EOL]         return ""; [EOL]     } [EOL]     if (ac == 2) { [EOL]         if (from < 1) { [EOL]             from = 1; [EOL]         } [EOL]         return s1.substring((int) from - 1); [EOL]     } else { [EOL]         double length = InfoSetUtil.doubleValue(getArg3().computeValue(context)); [EOL]         length = Math.round(length); [EOL]         if (length < 0) { [EOL]             return ""; [EOL]         } [EOL]         double to = from + length; [EOL]         if (to < 1) { [EOL]             return ""; [EOL]         } [EOL]         if (to > s1.length() + 1) { [EOL]             if (from < 1) { [EOL]                 from = 1; [EOL]             } [EOL]             return s1.substring((int) from - 1); [EOL]         } [EOL]         if (from < 1) { [EOL]             from = 1; [EOL]         } [EOL]         return s1.substring((int) from - 1, (int) (to - 1)); [EOL]     } [EOL] }
protected Object functionSubstring(EvalContext context) { [EOL]     int ac = getArgumentCount(); [EOL]     if (ac != 2 && ac != 3) { [EOL]         assertArgCount(2); [EOL]     } [EOL]     String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     double from = InfoSetUtil.doubleValue(getArg2().computeValue(context)); [EOL]     if (Double.isNaN(from)) { [EOL]         return ""; [EOL]     } [EOL]     from = Math.round(from); [EOL]     if (from > s1.length() + 1) { [EOL]         return ""; [EOL]     } [EOL]     if (ac == 2) { [EOL]         if (from < 1) { [EOL]             from = 1; [EOL]         } [EOL]         return s1.substring((int) from - 1); [EOL]     } else { [EOL]         double length = InfoSetUtil.doubleValue(getArg3().computeValue(context)); [EOL]         length = Math.round(length); [EOL]         if (length < 0) { [EOL]             return ""; [EOL]         } [EOL]         double to = from + length; [EOL]         if (to < 1) { [EOL]             return ""; [EOL]         } [EOL]         if (to > s1.length() + 1) { [EOL]             if (from < 1) { [EOL]                 from = 1; [EOL]             } [EOL]             return s1.substring((int) from - 1); [EOL]         } [EOL]         if (from < 1) { [EOL]             from = 1; [EOL]         } [EOL]         return s1.substring((int) from - 1, (int) (to - 1)); [EOL]     } [EOL] }
protected Object functionSubstring(EvalContext context) { [EOL]     int ac = getArgumentCount(); [EOL]     if (ac != 2 && ac != 3) { [EOL]         assertArgCount(2); [EOL]     } [EOL]     String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     double from = InfoSetUtil.doubleValue(getArg2().computeValue(context)); [EOL]     if (Double.isNaN(from)) { [EOL]         return ""; [EOL]     } [EOL]     from = Math.round(from); [EOL]     if (from > s1.length() + 1) { [EOL]         return ""; [EOL]     } [EOL]     if (ac == 2) { [EOL]         if (from < 1) { [EOL]             from = 1; [EOL]         } [EOL]         return s1.substring((int) from - 1); [EOL]     } else { [EOL]         double length = InfoSetUtil.doubleValue(getArg3().computeValue(context)); [EOL]         length = Math.round(length); [EOL]         if (length < 0) { [EOL]             return ""; [EOL]         } [EOL]         double to = from + length; [EOL]         if (to < 1) { [EOL]             return ""; [EOL]         } [EOL]         if (to > s1.length() + 1) { [EOL]             if (from < 1) { [EOL]                 from = 1; [EOL]             } [EOL]             return s1.substring((int) from - 1); [EOL]         } [EOL]         if (from < 1) { [EOL]             from = 1; [EOL]         } [EOL]         return s1.substring((int) from - 1, (int) (to - 1)); [EOL]     } [EOL] }
protected Object functionSubstring(EvalContext context) { [EOL]     int ac = getArgumentCount(); [EOL]     if (ac != 2 && ac != 3) { [EOL]         assertArgCount(2); [EOL]     } [EOL]     String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     double from = InfoSetUtil.doubleValue(getArg2().computeValue(context)); [EOL]     if (Double.isNaN(from)) { [EOL]         return ""; [EOL]     } [EOL]     from = Math.round(from); [EOL]     if (from > s1.length() + 1) { [EOL]         return ""; [EOL]     } [EOL]     if (ac == 2) { [EOL]         if (from < 1) { [EOL]             from = 1; [EOL]         } [EOL]         return s1.substring((int) from - 1); [EOL]     } else { [EOL]         double length = InfoSetUtil.doubleValue(getArg3().computeValue(context)); [EOL]         length = Math.round(length); [EOL]         if (length < 0) { [EOL]             return ""; [EOL]         } [EOL]         double to = from + length; [EOL]         if (to < 1) { [EOL]             return ""; [EOL]         } [EOL]         if (to > s1.length() + 1) { [EOL]             if (from < 1) { [EOL]                 from = 1; [EOL]             } [EOL]             return s1.substring((int) from - 1); [EOL]         } [EOL]         if (from < 1) { [EOL]             from = 1; [EOL]         } [EOL]         return s1.substring((int) from - 1, (int) (to - 1)); [EOL]     } [EOL] }
protected Object functionSubstring(EvalContext context) { [EOL]     int ac = getArgumentCount(); [EOL]     if (ac != 2 && ac != 3) { [EOL]         assertArgCount(2); [EOL]     } [EOL]     String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     double from = InfoSetUtil.doubleValue(getArg2().computeValue(context)); [EOL]     if (Double.isNaN(from)) { [EOL]         return ""; [EOL]     } [EOL]     from = Math.round(from); [EOL]     if (from > s1.length() + 1) { [EOL]         return ""; [EOL]     } [EOL]     if (ac == 2) { [EOL]         if (from < 1) { [EOL]             from = 1; [EOL]         } [EOL]         return s1.substring((int) from - 1); [EOL]     } else { [EOL]         double length = InfoSetUtil.doubleValue(getArg3().computeValue(context)); [EOL]         length = Math.round(length); [EOL]         if (length < 0) { [EOL]             return ""; [EOL]         } [EOL]         double to = from + length; [EOL]         if (to < 1) { [EOL]             return ""; [EOL]         } [EOL]         if (to > s1.length() + 1) { [EOL]             if (from < 1) { [EOL]                 from = 1; [EOL]             } [EOL]             return s1.substring((int) from - 1); [EOL]         } [EOL]         if (from < 1) { [EOL]             from = 1; [EOL]         } [EOL]         return s1.substring((int) from - 1, (int) (to - 1)); [EOL]     } [EOL] }
protected Object functionStringLength(EvalContext context) { [EOL]     String s; [EOL]     if (getArgumentCount() == 0) { [EOL]         s = InfoSetUtil.stringValue(context.getCurrentNodePointer()); [EOL]     } else { [EOL]         assertArgCount(1); [EOL]         s = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     } [EOL]     return new Double(s.length()); [EOL] }
protected Object functionStringLength(EvalContext context) { [EOL]     String s; [EOL]     if (getArgumentCount() == 0) { [EOL]         s = InfoSetUtil.stringValue(context.getCurrentNodePointer()); [EOL]     } else { [EOL]         assertArgCount(1); [EOL]         s = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     } [EOL]     return new Double(s.length()); [EOL] }
protected Object functionNormalizeSpace(EvalContext context) { [EOL]     assertArgCount(1); [EOL]     String s = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     char[] chars = s.toCharArray(); [EOL]     int out = 0; [EOL]     int phase = 0; [EOL]     for (int in = 0; in < chars.length; in++) { [EOL]         switch(chars[in]) { [EOL]             case 0x20: [EOL]             case 0x9: [EOL]             case 0xD: [EOL]             case 0xA: [EOL]                 if (phase == 0) { [EOL]                     ; [EOL]                 } else if (phase == 1) { [EOL]                     phase = 2; [EOL]                     chars[out++] = ' '; [EOL]                 } [EOL]                 break; [EOL]             default: [EOL]                 chars[out++] = chars[in]; [EOL]                 phase = 1; [EOL]         } [EOL]     } [EOL]     if (phase == 2) { [EOL]         out--; [EOL]     } [EOL]     return new String(chars, 0, out); [EOL] }
protected Object functionTranslate(EvalContext context) { [EOL]     assertArgCount(3); [EOL]     String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context)); [EOL]     String s3 = InfoSetUtil.stringValue(getArg3().computeValue(context)); [EOL]     char[] chars = s1.toCharArray(); [EOL]     int out = 0; [EOL]     for (int in = 0; in < chars.length; in++) { [EOL]         char c = chars[in]; [EOL]         int inx = s2.indexOf(c); [EOL]         if (inx != -1) { [EOL]             if (inx < s3.length()) { [EOL]                 chars[out++] = s3.charAt(inx); [EOL]             } [EOL]         } else { [EOL]             chars[out++] = c; [EOL]         } [EOL]     } [EOL]     return new String(chars, 0, out); [EOL] }
protected Object functionTranslate(EvalContext context) { [EOL]     assertArgCount(3); [EOL]     String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context)); [EOL]     String s3 = InfoSetUtil.stringValue(getArg3().computeValue(context)); [EOL]     char[] chars = s1.toCharArray(); [EOL]     int out = 0; [EOL]     for (int in = 0; in < chars.length; in++) { [EOL]         char c = chars[in]; [EOL]         int inx = s2.indexOf(c); [EOL]         if (inx != -1) { [EOL]             if (inx < s3.length()) { [EOL]                 chars[out++] = s3.charAt(inx); [EOL]             } [EOL]         } else { [EOL]             chars[out++] = c; [EOL]         } [EOL]     } [EOL]     return new String(chars, 0, out); [EOL] }
protected Object functionTranslate(EvalContext context) { [EOL]     assertArgCount(3); [EOL]     String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context)); [EOL]     String s3 = InfoSetUtil.stringValue(getArg3().computeValue(context)); [EOL]     char[] chars = s1.toCharArray(); [EOL]     int out = 0; [EOL]     for (int in = 0; in < chars.length; in++) { [EOL]         char c = chars[in]; [EOL]         int inx = s2.indexOf(c); [EOL]         if (inx != -1) { [EOL]             if (inx < s3.length()) { [EOL]                 chars[out++] = s3.charAt(inx); [EOL]             } [EOL]         } else { [EOL]             chars[out++] = c; [EOL]         } [EOL]     } [EOL]     return new String(chars, 0, out); [EOL] }
protected Object functionTranslate(EvalContext context) { [EOL]     assertArgCount(3); [EOL]     String s1 = InfoSetUtil.stringValue(getArg1().computeValue(context)); [EOL]     String s2 = InfoSetUtil.stringValue(getArg2().computeValue(context)); [EOL]     String s3 = InfoSetUtil.stringValue(getArg3().computeValue(context)); [EOL]     char[] chars = s1.toCharArray(); [EOL]     int out = 0; [EOL]     for (int in = 0; in < chars.length; in++) { [EOL]         char c = chars[in]; [EOL]         int inx = s2.indexOf(c); [EOL]         if (inx != -1) { [EOL]             if (inx < s3.length()) { [EOL]                 chars[out++] = s3.charAt(inx); [EOL]             } [EOL]         } else { [EOL]             chars[out++] = c; [EOL]         } [EOL]     } [EOL]     return new String(chars, 0, out); [EOL] }
protected Object functionNot(EvalContext context) { [EOL]     assertArgCount(1); [EOL]     return InfoSetUtil.booleanValue(getArg1().computeValue(context)) ? Boolean.FALSE : Boolean.TRUE; [EOL] }
protected Object functionNot(EvalContext context) { [EOL]     assertArgCount(1); [EOL]     return InfoSetUtil.booleanValue(getArg1().computeValue(context)) ? Boolean.FALSE : Boolean.TRUE; [EOL] }
protected Object functionTrue(EvalContext context) { [EOL]     assertArgCount(0); [EOL]     return Boolean.TRUE; [EOL] }
protected Object functionNull(EvalContext context) { [EOL]     assertArgCount(0); [EOL]     return null; [EOL] }
protected Object functionNumber(EvalContext context) { [EOL]     if (getArgumentCount() == 0) { [EOL]         return InfoSetUtil.number(context.getCurrentNodePointer()); [EOL]     } [EOL]     assertArgCount(1); [EOL]     return InfoSetUtil.number(getArg1().computeValue(context)); [EOL] }
protected Object functionNumber(EvalContext context) { [EOL]     if (getArgumentCount() == 0) { [EOL]         return InfoSetUtil.number(context.getCurrentNodePointer()); [EOL]     } [EOL]     assertArgCount(1); [EOL]     return InfoSetUtil.number(getArg1().computeValue(context)); [EOL] }
protected Object functionFloor(EvalContext context) { [EOL]     assertArgCount(1); [EOL]     double v = InfoSetUtil.doubleValue(getArg1().computeValue(context)); [EOL]     return new Double(Math.floor(v)); [EOL] }
protected Object functionFloor(EvalContext context) { [EOL]     assertArgCount(1); [EOL]     double v = InfoSetUtil.doubleValue(getArg1().computeValue(context)); [EOL]     return new Double(Math.floor(v)); [EOL] }
protected Object functionFloor(EvalContext context) { [EOL]     assertArgCount(1); [EOL]     double v = InfoSetUtil.doubleValue(getArg1().computeValue(context)); [EOL]     return new Double(Math.floor(v)); [EOL] }
protected Object functionCeiling(EvalContext context) { [EOL]     assertArgCount(1); [EOL]     double v = InfoSetUtil.doubleValue(getArg1().computeValue(context)); [EOL]     return new Double(Math.ceil(v)); [EOL] }
protected Object functionCeiling(EvalContext context) { [EOL]     assertArgCount(1); [EOL]     double v = InfoSetUtil.doubleValue(getArg1().computeValue(context)); [EOL]     return new Double(Math.ceil(v)); [EOL] }
protected Object functionCeiling(EvalContext context) { [EOL]     assertArgCount(1); [EOL]     double v = InfoSetUtil.doubleValue(getArg1().computeValue(context)); [EOL]     return new Double(Math.ceil(v)); [EOL] }
protected Object functionCeiling(EvalContext context) { [EOL]     assertArgCount(1); [EOL]     double v = InfoSetUtil.doubleValue(getArg1().computeValue(context)); [EOL]     return new Double(Math.ceil(v)); [EOL] }
protected Object functionCeiling(EvalContext context) { [EOL]     assertArgCount(1); [EOL]     double v = InfoSetUtil.doubleValue(getArg1().computeValue(context)); [EOL]     return new Double(Math.ceil(v)); [EOL] }
protected Object functionCeiling(EvalContext context) { [EOL]     assertArgCount(1); [EOL]     double v = InfoSetUtil.doubleValue(getArg1().computeValue(context)); [EOL]     return new Double(Math.ceil(v)); [EOL] }
protected Object functionRound(EvalContext context) { [EOL]     assertArgCount(1); [EOL]     double v = InfoSetUtil.doubleValue(getArg1().computeValue(context)); [EOL]     return new Double(Math.round(v)); [EOL] }
protected Object functionRound(EvalContext context) { [EOL]     assertArgCount(1); [EOL]     double v = InfoSetUtil.doubleValue(getArg1().computeValue(context)); [EOL]     return new Double(Math.round(v)); [EOL] }
protected Object functionRound(EvalContext context) { [EOL]     assertArgCount(1); [EOL]     double v = InfoSetUtil.doubleValue(getArg1().computeValue(context)); [EOL]     return new Double(Math.round(v)); [EOL] }
private void collectNamespaces(List attributes, Node node) { [EOL]     Node parent = node.getParentNode(); [EOL]     if (parent != null) { [EOL]         collectNamespaces(attributes, parent); [EOL]     } [EOL]     if (node.getNodeType() == Node.DOCUMENT_NODE) { [EOL]         node = ((Document) node).getDocumentElement(); [EOL]     } [EOL]     if (node.getNodeType() == Node.ELEMENT_NODE) { [EOL]         NamedNodeMap map = node.getAttributes(); [EOL]         int count = map.getLength(); [EOL]         for (int i = 0; i < count; i++) { [EOL]             Attr attr = (Attr) map.item(i); [EOL]             String prefix = DOMNodePointer.getPrefix(attr); [EOL]             String name = DOMNodePointer.getLocalName(attr); [EOL]             if ((prefix != null && prefix.equals("xmlns")) || (prefix == null && name.equals("xmlns"))) { [EOL]                 attributes.add(attr); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void collectNamespaces(List attributes, Node node) { [EOL]     Node parent = node.getParentNode(); [EOL]     if (parent != null) { [EOL]         collectNamespaces(attributes, parent); [EOL]     } [EOL]     if (node.getNodeType() == Node.DOCUMENT_NODE) { [EOL]         node = ((Document) node).getDocumentElement(); [EOL]     } [EOL]     if (node.getNodeType() == Node.ELEMENT_NODE) { [EOL]         NamedNodeMap map = node.getAttributes(); [EOL]         int count = map.getLength(); [EOL]         for (int i = 0; i < count; i++) { [EOL]             Attr attr = (Attr) map.item(i); [EOL]             String prefix = DOMNodePointer.getPrefix(attr); [EOL]             String name = DOMNodePointer.getLocalName(attr); [EOL]             if ((prefix != null && prefix.equals("xmlns")) || (prefix == null && name.equals("xmlns"))) { [EOL]                 attributes.add(attr); [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void collectNamespaces(List attributes, Node node) { [EOL]     Node parent = node.getParentNode(); [EOL]     if (parent != null) { [EOL]         collectNamespaces(attributes, parent); [EOL]     } [EOL]     if (node.getNodeType() == Node.DOCUMENT_NODE) { [EOL]         node = ((Document) node).getDocumentElement(); [EOL]     } [EOL]     if (node.getNodeType() == Node.ELEMENT_NODE) { [EOL]         NamedNodeMap map = node.getAttributes(); [EOL]         int count = map.getLength(); [EOL]         for (int i = 0; i < count; i++) { [EOL]             Attr attr = (Attr) map.item(i); [EOL]             String prefix = DOMNodePointer.getPrefix(attr); [EOL]             String name = DOMNodePointer.getLocalName(attr); [EOL]             if ((prefix != null && prefix.equals("xmlns")) || (prefix == null && name.equals("xmlns"))) { [EOL]                 attributes.add(attr); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public int getPosition() { [EOL]     return position; [EOL] }
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     if (bean == null) { [EOL]         return new NullPointer(parent, name); [EOL]     } [EOL]     JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass()); [EOL]     if (bi.isDynamic()) { [EOL]         DynamicPropertyHandler handler = ValueUtils.getDynamicPropertyHandler(bi.getDynamicPropertyHandlerClass()); [EOL]         return new DynamicPointer(parent, name, bean, handler); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     if (bean == null) { [EOL]         return new NullPointer(parent, name); [EOL]     } [EOL]     JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass()); [EOL]     if (bi.isDynamic()) { [EOL]         DynamicPropertyHandler handler = ValueUtils.getDynamicPropertyHandler(bi.getDynamicPropertyHandlerClass()); [EOL]         return new DynamicPointer(parent, name, bean, handler); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     if (bean == null) { [EOL]         return new NullPointer(parent, name); [EOL]     } [EOL]     JXPathBeanInfo bi = JXPathIntrospector.getBeanInfo(bean.getClass()); [EOL]     if (bi.isDynamic()) { [EOL]         DynamicPropertyHandler handler = ValueUtils.getDynamicPropertyHandler(bi.getDynamicPropertyHandlerClass()); [EOL]         return new DynamicPointer(parent, name, bean, handler); [EOL]     } [EOL]     return null; [EOL] }
public JDOMNodePointer(NodePointer parent, Object node) { [EOL]     super(parent); [EOL]     this.node = node; [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     return new JDOMNodeIterator(this, test, reverse, startWith); [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     return new JDOMNodeIterator(this, test, reverse, startWith); [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     return new JDOMNodeIterator(this, test, reverse, startWith); [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     return new JDOMNodeIterator(this, test, reverse, startWith); [EOL] }
public NodeIterator attributeIterator(QName name) { [EOL]     return new JDOMAttributeIterator(this, name); [EOL] }
public NodeIterator attributeIterator(QName name) { [EOL]     return new JDOMAttributeIterator(this, name); [EOL] }
public NodePointer namespacePointer(String prefix) { [EOL]     return new JDOMNamespacePointer(this, prefix); [EOL] }
public NodePointer namespacePointer(String prefix) { [EOL]     return new JDOMNamespacePointer(this, prefix); [EOL] }
public String getNamespaceURI() { [EOL]     return getNamespaceURI(node); [EOL] }
public String getNamespaceURI() { [EOL]     return getNamespaceURI(node); [EOL] }
private static String getNamespaceURI(Object node) { [EOL]     if (node instanceof Element) { [EOL]         Element element = (Element) node; [EOL]         String ns = element.getNamespaceURI(); [EOL]         if (ns != null && ns.equals("")) { [EOL]             ns = null; [EOL]         } [EOL]         return ns; [EOL]     } [EOL]     return null; [EOL] }
private static String getNamespaceURI(Object node) { [EOL]     if (node instanceof Element) { [EOL]         Element element = (Element) node; [EOL]         String ns = element.getNamespaceURI(); [EOL]         if (ns != null && ns.equals("")) { [EOL]             ns = null; [EOL]         } [EOL]         return ns; [EOL]     } [EOL]     return null; [EOL] }
private static String getNamespaceURI(Object node) { [EOL]     if (node instanceof Element) { [EOL]         Element element = (Element) node; [EOL]         String ns = element.getNamespaceURI(); [EOL]         if (ns != null && ns.equals("")) { [EOL]             ns = null; [EOL]         } [EOL]         return ns; [EOL]     } [EOL]     return null; [EOL] }
private static String getNamespaceURI(Object node) { [EOL]     if (node instanceof Element) { [EOL]         Element element = (Element) node; [EOL]         String ns = element.getNamespaceURI(); [EOL]         if (ns != null && ns.equals("")) { [EOL]             ns = null; [EOL]         } [EOL]         return ns; [EOL]     } [EOL]     return null; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     if (node instanceof Document) { [EOL]         Element element = ((Document) node).getRootElement(); [EOL]         Namespace ns = element.getNamespace(prefix); [EOL]         if (ns != null) { [EOL]             return ns.getURI(); [EOL]         } [EOL]     } else if (node instanceof Element) { [EOL]         Element element = (Element) node; [EOL]         Namespace ns = element.getNamespace(prefix); [EOL]         if (ns != null) { [EOL]             return ns.getURI(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     if (node instanceof Document) { [EOL]         Element element = ((Document) node).getRootElement(); [EOL]         Namespace ns = element.getNamespace(prefix); [EOL]         if (ns != null) { [EOL]             return ns.getURI(); [EOL]         } [EOL]     } else if (node instanceof Element) { [EOL]         Element element = (Element) node; [EOL]         Namespace ns = element.getNamespace(prefix); [EOL]         if (ns != null) { [EOL]             return ns.getURI(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     if (node instanceof Document) { [EOL]         Element element = ((Document) node).getRootElement(); [EOL]         Namespace ns = element.getNamespace(prefix); [EOL]         if (ns != null) { [EOL]             return ns.getURI(); [EOL]         } [EOL]     } else if (node instanceof Element) { [EOL]         Element element = (Element) node; [EOL]         Namespace ns = element.getNamespace(prefix); [EOL]         if (ns != null) { [EOL]             return ns.getURI(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     if (node instanceof Document) { [EOL]         Element element = ((Document) node).getRootElement(); [EOL]         Namespace ns = element.getNamespace(prefix); [EOL]         if (ns != null) { [EOL]             return ns.getURI(); [EOL]         } [EOL]     } else if (node instanceof Element) { [EOL]         Element element = (Element) node; [EOL]         Namespace ns = element.getNamespace(prefix); [EOL]         if (ns != null) { [EOL]             return ns.getURI(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     if (node instanceof Document) { [EOL]         Element element = ((Document) node).getRootElement(); [EOL]         Namespace ns = element.getNamespace(prefix); [EOL]         if (ns != null) { [EOL]             return ns.getURI(); [EOL]         } [EOL]     } else if (node instanceof Element) { [EOL]         Element element = (Element) node; [EOL]         Namespace ns = element.getNamespace(prefix); [EOL]         if (ns != null) { [EOL]             return ns.getURI(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public int getLength() { [EOL]     return 1; [EOL] }
public boolean isLeaf() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getContent().size() == 0; [EOL]     } else if (node instanceof Document) { [EOL]         return ((Document) node).getContent().size() == 0; [EOL]     } [EOL]     return true; [EOL] }
public boolean isLeaf() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getContent().size() == 0; [EOL]     } else if (node instanceof Document) { [EOL]         return ((Document) node).getContent().size() == 0; [EOL]     } [EOL]     return true; [EOL] }
public boolean isLeaf() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getContent().size() == 0; [EOL]     } else if (node instanceof Document) { [EOL]         return ((Document) node).getContent().size() == 0; [EOL]     } [EOL]     return true; [EOL] }
public boolean isLeaf() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getContent().size() == 0; [EOL]     } else if (node instanceof Document) { [EOL]         return ((Document) node).getContent().size() == 0; [EOL]     } [EOL]     return true; [EOL] }
public boolean isLeaf() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getContent().size() == 0; [EOL]     } else if (node instanceof Document) { [EOL]         return ((Document) node).getContent().size() == 0; [EOL]     } [EOL]     return true; [EOL] }
public QName getName() { [EOL]     String ns = null; [EOL]     String ln = null; [EOL]     if (node instanceof Element) { [EOL]         ns = ((Element) node).getNamespacePrefix(); [EOL]         if (ns != null && ns.equals("")) { [EOL]             ns = null; [EOL]         } [EOL]         ln = ((Element) node).getName(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         ln = ((ProcessingInstruction) node).getTarget(); [EOL]     } [EOL]     return new QName(ns, ln); [EOL] }
public QName getName() { [EOL]     String ns = null; [EOL]     String ln = null; [EOL]     if (node instanceof Element) { [EOL]         ns = ((Element) node).getNamespacePrefix(); [EOL]         if (ns != null && ns.equals("")) { [EOL]             ns = null; [EOL]         } [EOL]         ln = ((Element) node).getName(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         ln = ((ProcessingInstruction) node).getTarget(); [EOL]     } [EOL]     return new QName(ns, ln); [EOL] }
public QName getName() { [EOL]     String ns = null; [EOL]     String ln = null; [EOL]     if (node instanceof Element) { [EOL]         ns = ((Element) node).getNamespacePrefix(); [EOL]         if (ns != null && ns.equals("")) { [EOL]             ns = null; [EOL]         } [EOL]         ln = ((Element) node).getName(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         ln = ((ProcessingInstruction) node).getTarget(); [EOL]     } [EOL]     return new QName(ns, ln); [EOL] }
public QName getName() { [EOL]     String ns = null; [EOL]     String ln = null; [EOL]     if (node instanceof Element) { [EOL]         ns = ((Element) node).getNamespacePrefix(); [EOL]         if (ns != null && ns.equals("")) { [EOL]             ns = null; [EOL]         } [EOL]         ln = ((Element) node).getName(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         ln = ((ProcessingInstruction) node).getTarget(); [EOL]     } [EOL]     return new QName(ns, ln); [EOL] }
public QName getName() { [EOL]     String ns = null; [EOL]     String ln = null; [EOL]     if (node instanceof Element) { [EOL]         ns = ((Element) node).getNamespacePrefix(); [EOL]         if (ns != null && ns.equals("")) { [EOL]             ns = null; [EOL]         } [EOL]         ln = ((Element) node).getName(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         ln = ((ProcessingInstruction) node).getTarget(); [EOL]     } [EOL]     return new QName(ns, ln); [EOL] }
public Object getImmediateNode() { [EOL]     return node; [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public Object getValue() { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getTextTrim(); [EOL]     } else if (node instanceof Comment) { [EOL]         String text = ((Comment) node).getText(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } else if (node instanceof Text) { [EOL]         return ((Text) node).getTextTrim(); [EOL]     } else if (node instanceof CDATA) { [EOL]         return ((CDATA) node).getTextTrim(); [EOL]     } else if (node instanceof ProcessingInstruction) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         if (text != null) { [EOL]             text = text.trim(); [EOL]         } [EOL]         return text; [EOL]     } [EOL]     return null; [EOL] }
public boolean testNode(NodeTest test) { [EOL]     return testNode(this, node, test); [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (!(node instanceof Element)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return (node instanceof Element) || (node instanceof Document); [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return (node instanceof Text) || (node instanceof CDATA); [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return node instanceof Comment; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return node instanceof ProcessingInstruction; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node instanceof ProcessingInstruction) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (!(node instanceof Element)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return (node instanceof Element) || (node instanceof Document); [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return (node instanceof Text) || (node instanceof CDATA); [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return node instanceof Comment; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return node instanceof ProcessingInstruction; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node instanceof ProcessingInstruction) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (!(node instanceof Element)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return (node instanceof Element) || (node instanceof Document); [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return (node instanceof Text) || (node instanceof CDATA); [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return node instanceof Comment; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return node instanceof ProcessingInstruction; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node instanceof ProcessingInstruction) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (!(node instanceof Element)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return (node instanceof Element) || (node instanceof Document); [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return (node instanceof Text) || (node instanceof CDATA); [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return node instanceof Comment; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return node instanceof ProcessingInstruction; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node instanceof ProcessingInstruction) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (!(node instanceof Element)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return (node instanceof Element) || (node instanceof Document); [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return (node instanceof Text) || (node instanceof CDATA); [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return node instanceof Comment; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return node instanceof ProcessingInstruction; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node instanceof ProcessingInstruction) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (!(node instanceof Element)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return (node instanceof Element) || (node instanceof Document); [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return (node instanceof Text) || (node instanceof CDATA); [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return node instanceof Comment; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return node instanceof ProcessingInstruction; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node instanceof ProcessingInstruction) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (!(node instanceof Element)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return (node instanceof Element) || (node instanceof Document); [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return (node instanceof Text) || (node instanceof CDATA); [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return node instanceof Comment; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return node instanceof ProcessingInstruction; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node instanceof ProcessingInstruction) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (!(node instanceof Element)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return (node instanceof Element) || (node instanceof Document); [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return (node instanceof Text) || (node instanceof CDATA); [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return node instanceof Comment; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return node instanceof ProcessingInstruction; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node instanceof ProcessingInstruction) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (!(node instanceof Element)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return (node instanceof Element) || (node instanceof Document); [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return (node instanceof Text) || (node instanceof CDATA); [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return node instanceof Comment; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return node instanceof ProcessingInstruction; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node instanceof ProcessingInstruction) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(NodePointer pointer, Object node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (!(node instanceof Element)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(JDOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = JDOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return (node instanceof Element) || (node instanceof Document); [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return (node instanceof Text) || (node instanceof CDATA); [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return node instanceof Comment; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return node instanceof ProcessingInstruction; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node instanceof ProcessingInstruction) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null && s2 != null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && s2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && !s1.trim().equals(s2.trim())) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null && s2 != null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && s2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && !s1.trim().equals(s2.trim())) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null && s2 != null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && s2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && !s1.trim().equals(s2.trim())) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null && s2 != null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && s2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && !s1.trim().equals(s2.trim())) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null && s2 != null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && s2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && !s1.trim().equals(s2.trim())) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null && s2 != null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && s2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && !s1.trim().equals(s2.trim())) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null && s2 != null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && s2 == null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && !s1.trim().equals(s2.trim())) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static String getLocalName(Object node) { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getName(); [EOL]     } else if (node instanceof Attribute) { [EOL]         return ((Attribute) node).getName(); [EOL]     } [EOL]     return null; [EOL] }
public static String getLocalName(Object node) { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getName(); [EOL]     } else if (node instanceof Attribute) { [EOL]         return ((Attribute) node).getName(); [EOL]     } [EOL]     return null; [EOL] }
public static String getLocalName(Object node) { [EOL]     if (node instanceof Element) { [EOL]         return ((Element) node).getName(); [EOL]     } else if (node instanceof Attribute) { [EOL]         return ((Attribute) node).getName(); [EOL]     } [EOL]     return null; [EOL] }
public DynaBeanPointer(QName name, DynaBean dynaBean, Locale locale) { [EOL]     super(null, locale); [EOL]     this.name = name; [EOL]     this.dynaBean = dynaBean; [EOL] }
public PropertyPointer getPropertyPointer() { [EOL]     return new DynaBeanPropertyPointer(this, dynaBean); [EOL] }
public Object getImmediateNode() { [EOL]     return dynaBean; [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } [EOL]     return "/"; [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } [EOL]     return "/"; [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public String NCName() throws ParseException { [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NCName: [EOL]             NCName_Without_CoreFunctions(); [EOL]             break; [EOL]         case NODE: [EOL]             jj_consume_token(NODE); [EOL]             break; [EOL]         case TEXT: [EOL]             jj_consume_token(TEXT); [EOL]             break; [EOL]         case COMMENT: [EOL]             jj_consume_token(COMMENT); [EOL]             break; [EOL]         case PI: [EOL]             jj_consume_token(PI); [EOL]             break; [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             break; [EOL]         default: [EOL]             jj_la1[0] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return token.image; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int CoreFunctionName() throws ParseException { [EOL]     int code; [EOL]     switch(jj_nt.kind) { [EOL]         case FUNCTION_LAST: [EOL]             jj_consume_token(FUNCTION_LAST); [EOL]             code = Compiler.FUNCTION_LAST; [EOL]             break; [EOL]         case FUNCTION_POSITION: [EOL]             jj_consume_token(FUNCTION_POSITION); [EOL]             code = Compiler.FUNCTION_POSITION; [EOL]             break; [EOL]         case FUNCTION_COUNT: [EOL]             jj_consume_token(FUNCTION_COUNT); [EOL]             code = Compiler.FUNCTION_COUNT; [EOL]             break; [EOL]         case FUNCTION_ID: [EOL]             jj_consume_token(FUNCTION_ID); [EOL]             code = Compiler.FUNCTION_ID; [EOL]             break; [EOL]         case FUNCTION_LOCAL_NAME: [EOL]             jj_consume_token(FUNCTION_LOCAL_NAME); [EOL]             code = Compiler.FUNCTION_LOCAL_NAME; [EOL]             break; [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]             jj_consume_token(FUNCTION_NAMESPACE_URI); [EOL]             code = Compiler.FUNCTION_NAMESPACE_URI; [EOL]             break; [EOL]         case FUNCTION_NAME: [EOL]             jj_consume_token(FUNCTION_NAME); [EOL]             code = Compiler.FUNCTION_NAME; [EOL]             break; [EOL]         case FUNCTION_STRING: [EOL]             jj_consume_token(FUNCTION_STRING); [EOL]             code = Compiler.FUNCTION_STRING; [EOL]             break; [EOL]         case FUNCTION_CONCAT: [EOL]             jj_consume_token(FUNCTION_CONCAT); [EOL]             code = Compiler.FUNCTION_CONCAT; [EOL]             break; [EOL]         case FUNCTION_STARTS_WITH: [EOL]             jj_consume_token(FUNCTION_STARTS_WITH); [EOL]             code = Compiler.FUNCTION_STARTS_WITH; [EOL]             break; [EOL]         case FUNCTION_CONTAINS: [EOL]             jj_consume_token(FUNCTION_CONTAINS); [EOL]             code = Compiler.FUNCTION_CONTAINS; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_BEFORE); [EOL]             code = Compiler.FUNCTION_SUBSTRING_BEFORE; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]             jj_consume_token(FUNCTION_SUBSTRING_AFTER); [EOL]             code = Compiler.FUNCTION_SUBSTRING_AFTER; [EOL]             break; [EOL]         case FUNCTION_SUBSTRING: [EOL]             jj_consume_token(FUNCTION_SUBSTRING); [EOL]             code = Compiler.FUNCTION_SUBSTRING; [EOL]             break; [EOL]         case FUNCTION_STRING_LENGTH: [EOL]             jj_consume_token(FUNCTION_STRING_LENGTH); [EOL]             code = Compiler.FUNCTION_STRING_LENGTH; [EOL]             break; [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]             jj_consume_token(FUNCTION_NORMALIZE_SPACE); [EOL]             code = Compiler.FUNCTION_NORMALIZE_SPACE; [EOL]             break; [EOL]         case FUNCTION_TRANSLATE: [EOL]             jj_consume_token(FUNCTION_TRANSLATE); [EOL]             code = Compiler.FUNCTION_TRANSLATE; [EOL]             break; [EOL]         case FUNCTION_BOOLEAN: [EOL]             jj_consume_token(FUNCTION_BOOLEAN); [EOL]             code = Compiler.FUNCTION_BOOLEAN; [EOL]             break; [EOL]         case FUNCTION_NOT: [EOL]             jj_consume_token(FUNCTION_NOT); [EOL]             code = Compiler.FUNCTION_NOT; [EOL]             break; [EOL]         case FUNCTION_TRUE: [EOL]             jj_consume_token(FUNCTION_TRUE); [EOL]             code = Compiler.FUNCTION_TRUE; [EOL]             break; [EOL]         case FUNCTION_FALSE: [EOL]             jj_consume_token(FUNCTION_FALSE); [EOL]             code = Compiler.FUNCTION_FALSE; [EOL]             break; [EOL]         case FUNCTION_NULL: [EOL]             jj_consume_token(FUNCTION_NULL); [EOL]             code = Compiler.FUNCTION_NULL; [EOL]             break; [EOL]         case FUNCTION_LANG: [EOL]             jj_consume_token(FUNCTION_LANG); [EOL]             code = Compiler.FUNCTION_LANG; [EOL]             break; [EOL]         case FUNCTION_NUMBER: [EOL]             jj_consume_token(FUNCTION_NUMBER); [EOL]             code = Compiler.FUNCTION_NUMBER; [EOL]             break; [EOL]         case FUNCTION_SUM: [EOL]             jj_consume_token(FUNCTION_SUM); [EOL]             code = Compiler.FUNCTION_SUM; [EOL]             break; [EOL]         case FUNCTION_FLOOR: [EOL]             jj_consume_token(FUNCTION_FLOOR); [EOL]             code = Compiler.FUNCTION_FLOOR; [EOL]             break; [EOL]         case FUNCTION_CEILING: [EOL]             jj_consume_token(FUNCTION_CEILING); [EOL]             code = Compiler.FUNCTION_CEILING; [EOL]             break; [EOL]         case FUNCTION_ROUND: [EOL]             jj_consume_token(FUNCTION_ROUND); [EOL]             code = Compiler.FUNCTION_ROUND; [EOL]             break; [EOL]         case FUNCTION_KEY: [EOL]             jj_consume_token(FUNCTION_KEY); [EOL]             code = Compiler.FUNCTION_KEY; [EOL]             break; [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]             jj_consume_token(FUNCTION_FORMAT_NUMBER); [EOL]             code = Compiler.FUNCTION_FORMAT_NUMBER; [EOL]             break; [EOL]         default: [EOL]             jj_la1[2] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return code; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object LocationPath() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = RelativeLocationPath(); [EOL]             break; [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]             ex = AbsoluteLocationPath(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[5] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object LocationPath() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = RelativeLocationPath(); [EOL]             break; [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]             ex = AbsoluteLocationPath(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[5] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object LocationPath() throws ParseException { [EOL]     Object ex = null; [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = RelativeLocationPath(); [EOL]             break; [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]             ex = AbsoluteLocationPath(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[5] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object RelativeLocationPath() throws ParseException { [EOL]     ArrayList steps = new ArrayList(); [EOL]     NodeTest(steps); [EOL]     label_2: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]             case SLASHSLASH: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[8] = jj_gen; [EOL]                 break label_2; [EOL]         } [EOL]         LocationStep(steps); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return compiler.locationPath(false, steps.toArray()); [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object RelativeLocationPath() throws ParseException { [EOL]     ArrayList steps = new ArrayList(); [EOL]     NodeTest(steps); [EOL]     label_2: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]             case SLASHSLASH: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[8] = jj_gen; [EOL]                 break label_2; [EOL]         } [EOL]         LocationStep(steps); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return compiler.locationPath(false, steps.toArray()); [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object RelativeLocationPath() throws ParseException { [EOL]     ArrayList steps = new ArrayList(); [EOL]     NodeTest(steps); [EOL]     label_2: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]             case SLASHSLASH: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[8] = jj_gen; [EOL]                 break label_2; [EOL]         } [EOL]         LocationStep(steps); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return compiler.locationPath(false, steps.toArray()); [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public void NodeTest(ArrayList steps) throws ParseException { [EOL]     int axis; [EOL]     int type = -1; [EOL]     String instruction = null; [EOL]     Object name = null; [EOL]     Object s; [EOL]     Object p; [EOL]     ArrayList ps = new ArrayList(); [EOL]     switch(jj_nt.kind) { [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 86: [EOL]         case 88: [EOL]             axis = AxisSpecifier(); [EOL]             if (jj_2_3(2147483647)) { [EOL]                 type = NodeType(); [EOL]                 jj_consume_token(80); [EOL]                 jj_consume_token(81); [EOL]             } else if (jj_2_4(2147483647)) { [EOL]                 jj_consume_token(PI); [EOL]                 jj_consume_token(80); [EOL]                 jj_consume_token(Literal); [EOL]                 instruction = unescape(token.image.substring(1, token.image.length() - 1)); [EOL]                 jj_consume_token(81); [EOL]             } else { [EOL]                 switch(jj_nt.kind) { [EOL]                     case OR: [EOL]                     case AND: [EOL]                     case MOD: [EOL]                     case DIV: [EOL]                     case NODE: [EOL]                     case TEXT: [EOL]                     case COMMENT: [EOL]                     case PI: [EOL]                     case FUNCTION_LAST: [EOL]                     case FUNCTION_POSITION: [EOL]                     case FUNCTION_COUNT: [EOL]                     case FUNCTION_ID: [EOL]                     case FUNCTION_KEY: [EOL]                     case FUNCTION_LOCAL_NAME: [EOL]                     case FUNCTION_NAMESPACE_URI: [EOL]                     case FUNCTION_NAME: [EOL]                     case FUNCTION_STRING: [EOL]                     case FUNCTION_CONCAT: [EOL]                     case FUNCTION_STARTS_WITH: [EOL]                     case FUNCTION_CONTAINS: [EOL]                     case FUNCTION_SUBSTRING_BEFORE: [EOL]                     case FUNCTION_SUBSTRING_AFTER: [EOL]                     case FUNCTION_SUBSTRING: [EOL]                     case FUNCTION_STRING_LENGTH: [EOL]                     case FUNCTION_NORMALIZE_SPACE: [EOL]                     case FUNCTION_TRANSLATE: [EOL]                     case FUNCTION_BOOLEAN: [EOL]                     case FUNCTION_NOT: [EOL]                     case FUNCTION_TRUE: [EOL]                     case FUNCTION_FALSE: [EOL]                     case FUNCTION_NULL: [EOL]                     case FUNCTION_LANG: [EOL]                     case FUNCTION_NUMBER: [EOL]                     case FUNCTION_SUM: [EOL]                     case FUNCTION_FLOOR: [EOL]                     case FUNCTION_CEILING: [EOL]                     case FUNCTION_ROUND: [EOL]                     case FUNCTION_FORMAT_NUMBER: [EOL]                     case NCName: [EOL]                     case 88: [EOL]                         name = WildcardName(); [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[10] = jj_gen; [EOL]                         jj_consume_token(-1); [EOL]                         throw new ParseException(); [EOL]                 } [EOL]             } [EOL]             break; [EOL]         case 82: [EOL]             jj_consume_token(82); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             type = Compiler.NODE_TYPE_NODE; [EOL]             break; [EOL]         case 83: [EOL]             jj_consume_token(83); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             type = Compiler.NODE_TYPE_NODE; [EOL]             break; [EOL]         default: [EOL]             jj_la1[11] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     label_3: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case 84: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[12] = jj_gen; [EOL]                 break label_3; [EOL]         } [EOL]         p = Predicate(); [EOL]         ps.add(p); [EOL]     } [EOL]     if (name != null) { [EOL]         s = compiler.nodeNameTest(name); [EOL]     } else if (instruction != null) { [EOL]         s = compiler.processingInstructionTest(instruction); [EOL]     } else { [EOL]         s = compiler.nodeTypeTest(type); [EOL]     } [EOL]     steps.add(compiler.step(axis, s, ps.toArray())); [EOL] }
final public int AxisSpecifier() throws ParseException { [EOL]     int axis; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             axis = AxisName(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[13] = jj_gen; [EOL]             axis = AbbreviatedAxisSpecifier(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public int AxisName() throws ParseException { [EOL]     int axis = 0; [EOL]     switch(jj_nt.kind) { [EOL]         case AXIS_SELF: [EOL]             jj_consume_token(AXIS_SELF); [EOL]             axis = Compiler.AXIS_SELF; [EOL]             break; [EOL]         case AXIS_CHILD: [EOL]             jj_consume_token(AXIS_CHILD); [EOL]             axis = Compiler.AXIS_CHILD; [EOL]             break; [EOL]         case AXIS_PARENT: [EOL]             jj_consume_token(AXIS_PARENT); [EOL]             axis = Compiler.AXIS_PARENT; [EOL]             break; [EOL]         case AXIS_ANCESTOR: [EOL]             jj_consume_token(AXIS_ANCESTOR); [EOL]             axis = Compiler.AXIS_ANCESTOR; [EOL]             break; [EOL]         case AXIS_ATTRIBUTE: [EOL]             jj_consume_token(AXIS_ATTRIBUTE); [EOL]             axis = Compiler.AXIS_ATTRIBUTE; [EOL]             break; [EOL]         case AXIS_NAMESPACE: [EOL]             jj_consume_token(AXIS_NAMESPACE); [EOL]             axis = Compiler.AXIS_NAMESPACE; [EOL]             break; [EOL]         case AXIS_PRECEDING: [EOL]             jj_consume_token(AXIS_PRECEDING); [EOL]             axis = Compiler.AXIS_PRECEDING; [EOL]             break; [EOL]         case AXIS_FOLLOWING: [EOL]             jj_consume_token(AXIS_FOLLOWING); [EOL]             axis = Compiler.AXIS_FOLLOWING; [EOL]             break; [EOL]         case AXIS_DESCENDANT: [EOL]             jj_consume_token(AXIS_DESCENDANT); [EOL]             axis = Compiler.AXIS_DESCENDANT; [EOL]             break; [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]             jj_consume_token(AXIS_ANCESTOR_OR_SELF); [EOL]             axis = Compiler.AXIS_ANCESTOR_OR_SELF; [EOL]             break; [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]             jj_consume_token(AXIS_FOLLOWING_SIBLING); [EOL]             axis = Compiler.AXIS_FOLLOWING_SIBLING; [EOL]             break; [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]             jj_consume_token(AXIS_PRECEDING_SIBLING); [EOL]             axis = Compiler.AXIS_PRECEDING_SIBLING; [EOL]             break; [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]             jj_consume_token(AXIS_DESCENDANT_OR_SELF); [EOL]             axis = Compiler.AXIS_DESCENDANT_OR_SELF; [EOL]             break; [EOL]         default: [EOL]             jj_la1[14] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return axis; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object CoreFunctionCall() throws ParseException { [EOL]     int code = 0; [EOL]     ArrayList args; [EOL]     code = CoreFunctionName(); [EOL]     args = ArgumentList(); [EOL]     if (args == null) { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.function(code, null); [EOL]         } [EOL]     } else { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.function(code, args.toArray()); [EOL]         } [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object CoreFunctionCall() throws ParseException { [EOL]     int code = 0; [EOL]     ArrayList args; [EOL]     code = CoreFunctionName(); [EOL]     args = ArgumentList(); [EOL]     if (args == null) { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.function(code, null); [EOL]         } [EOL]     } else { [EOL]         { [EOL]             if (true) [EOL]                 return compiler.function(code, args.toArray()); [EOL]         } [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public ArrayList ArgumentList() throws ParseException { [EOL]     ArrayList args = null; [EOL]     Object arg; [EOL]     jj_consume_token(80); [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]         case MINUS: [EOL]         case VARIABLE: [EOL]         case Literal: [EOL]         case Number: [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 80: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             arg = Argument(); [EOL]             args = new ArrayList(); [EOL]             args.add(arg); [EOL]             label_4: while (true) { [EOL]                 switch(jj_nt.kind) { [EOL]                     case 87: [EOL]                         ; [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[18] = jj_gen; [EOL]                         break label_4; [EOL]                 } [EOL]                 jj_consume_token(87); [EOL]                 arg = Argument(); [EOL]                 args.add(arg); [EOL]             } [EOL]             break; [EOL]         default: [EOL]             jj_la1[19] = jj_gen; [EOL]             ; [EOL]     } [EOL]     jj_consume_token(81); [EOL]     { [EOL]         if (true) [EOL]             return args; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public ArrayList ArgumentList() throws ParseException { [EOL]     ArrayList args = null; [EOL]     Object arg; [EOL]     jj_consume_token(80); [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]         case MINUS: [EOL]         case VARIABLE: [EOL]         case Literal: [EOL]         case Number: [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 80: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             arg = Argument(); [EOL]             args = new ArrayList(); [EOL]             args.add(arg); [EOL]             label_4: while (true) { [EOL]                 switch(jj_nt.kind) { [EOL]                     case 87: [EOL]                         ; [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[18] = jj_gen; [EOL]                         break label_4; [EOL]                 } [EOL]                 jj_consume_token(87); [EOL]                 arg = Argument(); [EOL]                 args.add(arg); [EOL]             } [EOL]             break; [EOL]         default: [EOL]             jj_la1[19] = jj_gen; [EOL]             ; [EOL]     } [EOL]     jj_consume_token(81); [EOL]     { [EOL]         if (true) [EOL]             return args; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public ArrayList ArgumentList() throws ParseException { [EOL]     ArrayList args = null; [EOL]     Object arg; [EOL]     jj_consume_token(80); [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]         case MINUS: [EOL]         case VARIABLE: [EOL]         case Literal: [EOL]         case Number: [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 80: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             arg = Argument(); [EOL]             args = new ArrayList(); [EOL]             args.add(arg); [EOL]             label_4: while (true) { [EOL]                 switch(jj_nt.kind) { [EOL]                     case 87: [EOL]                         ; [EOL]                         break; [EOL]                     default: [EOL]                         jj_la1[18] = jj_gen; [EOL]                         break label_4; [EOL]                 } [EOL]                 jj_consume_token(87); [EOL]                 arg = Argument(); [EOL]                 args.add(arg); [EOL]             } [EOL]             break; [EOL]         default: [EOL]             jj_la1[19] = jj_gen; [EOL]             ; [EOL]     } [EOL]     jj_consume_token(81); [EOL]     { [EOL]         if (true) [EOL]             return args; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PathExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     Object[] steps; [EOL]     if (jj_2_6(2147483647)) { [EOL]         ex = FilterExpr(); [EOL]     } else { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]             case SLASHSLASH: [EOL]             case OR: [EOL]             case AND: [EOL]             case MOD: [EOL]             case DIV: [EOL]             case NODE: [EOL]             case TEXT: [EOL]             case COMMENT: [EOL]             case PI: [EOL]             case AXIS_SELF: [EOL]             case AXIS_CHILD: [EOL]             case AXIS_PARENT: [EOL]             case AXIS_ANCESTOR: [EOL]             case AXIS_ATTRIBUTE: [EOL]             case AXIS_NAMESPACE: [EOL]             case AXIS_PRECEDING: [EOL]             case AXIS_FOLLOWING: [EOL]             case AXIS_DESCENDANT: [EOL]             case AXIS_ANCESTOR_OR_SELF: [EOL]             case AXIS_FOLLOWING_SIBLING: [EOL]             case AXIS_PRECEDING_SIBLING: [EOL]             case AXIS_DESCENDANT_OR_SELF: [EOL]             case FUNCTION_LAST: [EOL]             case FUNCTION_POSITION: [EOL]             case FUNCTION_COUNT: [EOL]             case FUNCTION_ID: [EOL]             case FUNCTION_KEY: [EOL]             case FUNCTION_LOCAL_NAME: [EOL]             case FUNCTION_NAMESPACE_URI: [EOL]             case FUNCTION_NAME: [EOL]             case FUNCTION_STRING: [EOL]             case FUNCTION_CONCAT: [EOL]             case FUNCTION_STARTS_WITH: [EOL]             case FUNCTION_CONTAINS: [EOL]             case FUNCTION_SUBSTRING_BEFORE: [EOL]             case FUNCTION_SUBSTRING_AFTER: [EOL]             case FUNCTION_SUBSTRING: [EOL]             case FUNCTION_STRING_LENGTH: [EOL]             case FUNCTION_NORMALIZE_SPACE: [EOL]             case FUNCTION_TRANSLATE: [EOL]             case FUNCTION_BOOLEAN: [EOL]             case FUNCTION_NOT: [EOL]             case FUNCTION_TRUE: [EOL]             case FUNCTION_FALSE: [EOL]             case FUNCTION_NULL: [EOL]             case FUNCTION_LANG: [EOL]             case FUNCTION_NUMBER: [EOL]             case FUNCTION_SUM: [EOL]             case FUNCTION_FLOOR: [EOL]             case FUNCTION_CEILING: [EOL]             case FUNCTION_ROUND: [EOL]             case FUNCTION_FORMAT_NUMBER: [EOL]             case NCName: [EOL]             case 82: [EOL]             case 83: [EOL]             case 86: [EOL]             case 88: [EOL]                 ex = LocationPath(); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[21] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PathExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     Object[] steps; [EOL]     if (jj_2_6(2147483647)) { [EOL]         ex = FilterExpr(); [EOL]     } else { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]             case SLASHSLASH: [EOL]             case OR: [EOL]             case AND: [EOL]             case MOD: [EOL]             case DIV: [EOL]             case NODE: [EOL]             case TEXT: [EOL]             case COMMENT: [EOL]             case PI: [EOL]             case AXIS_SELF: [EOL]             case AXIS_CHILD: [EOL]             case AXIS_PARENT: [EOL]             case AXIS_ANCESTOR: [EOL]             case AXIS_ATTRIBUTE: [EOL]             case AXIS_NAMESPACE: [EOL]             case AXIS_PRECEDING: [EOL]             case AXIS_FOLLOWING: [EOL]             case AXIS_DESCENDANT: [EOL]             case AXIS_ANCESTOR_OR_SELF: [EOL]             case AXIS_FOLLOWING_SIBLING: [EOL]             case AXIS_PRECEDING_SIBLING: [EOL]             case AXIS_DESCENDANT_OR_SELF: [EOL]             case FUNCTION_LAST: [EOL]             case FUNCTION_POSITION: [EOL]             case FUNCTION_COUNT: [EOL]             case FUNCTION_ID: [EOL]             case FUNCTION_KEY: [EOL]             case FUNCTION_LOCAL_NAME: [EOL]             case FUNCTION_NAMESPACE_URI: [EOL]             case FUNCTION_NAME: [EOL]             case FUNCTION_STRING: [EOL]             case FUNCTION_CONCAT: [EOL]             case FUNCTION_STARTS_WITH: [EOL]             case FUNCTION_CONTAINS: [EOL]             case FUNCTION_SUBSTRING_BEFORE: [EOL]             case FUNCTION_SUBSTRING_AFTER: [EOL]             case FUNCTION_SUBSTRING: [EOL]             case FUNCTION_STRING_LENGTH: [EOL]             case FUNCTION_NORMALIZE_SPACE: [EOL]             case FUNCTION_TRANSLATE: [EOL]             case FUNCTION_BOOLEAN: [EOL]             case FUNCTION_NOT: [EOL]             case FUNCTION_TRUE: [EOL]             case FUNCTION_FALSE: [EOL]             case FUNCTION_NULL: [EOL]             case FUNCTION_LANG: [EOL]             case FUNCTION_NUMBER: [EOL]             case FUNCTION_SUM: [EOL]             case FUNCTION_FLOOR: [EOL]             case FUNCTION_CEILING: [EOL]             case FUNCTION_ROUND: [EOL]             case FUNCTION_FORMAT_NUMBER: [EOL]             case NCName: [EOL]             case 82: [EOL]             case 83: [EOL]             case 86: [EOL]             case 88: [EOL]                 ex = LocationPath(); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[21] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object PathExpr() throws ParseException { [EOL]     Object ex = null; [EOL]     Object[] steps; [EOL]     if (jj_2_6(2147483647)) { [EOL]         ex = FilterExpr(); [EOL]     } else { [EOL]         switch(jj_nt.kind) { [EOL]             case SLASH: [EOL]             case SLASHSLASH: [EOL]             case OR: [EOL]             case AND: [EOL]             case MOD: [EOL]             case DIV: [EOL]             case NODE: [EOL]             case TEXT: [EOL]             case COMMENT: [EOL]             case PI: [EOL]             case AXIS_SELF: [EOL]             case AXIS_CHILD: [EOL]             case AXIS_PARENT: [EOL]             case AXIS_ANCESTOR: [EOL]             case AXIS_ATTRIBUTE: [EOL]             case AXIS_NAMESPACE: [EOL]             case AXIS_PRECEDING: [EOL]             case AXIS_FOLLOWING: [EOL]             case AXIS_DESCENDANT: [EOL]             case AXIS_ANCESTOR_OR_SELF: [EOL]             case AXIS_FOLLOWING_SIBLING: [EOL]             case AXIS_PRECEDING_SIBLING: [EOL]             case AXIS_DESCENDANT_OR_SELF: [EOL]             case FUNCTION_LAST: [EOL]             case FUNCTION_POSITION: [EOL]             case FUNCTION_COUNT: [EOL]             case FUNCTION_ID: [EOL]             case FUNCTION_KEY: [EOL]             case FUNCTION_LOCAL_NAME: [EOL]             case FUNCTION_NAMESPACE_URI: [EOL]             case FUNCTION_NAME: [EOL]             case FUNCTION_STRING: [EOL]             case FUNCTION_CONCAT: [EOL]             case FUNCTION_STARTS_WITH: [EOL]             case FUNCTION_CONTAINS: [EOL]             case FUNCTION_SUBSTRING_BEFORE: [EOL]             case FUNCTION_SUBSTRING_AFTER: [EOL]             case FUNCTION_SUBSTRING: [EOL]             case FUNCTION_STRING_LENGTH: [EOL]             case FUNCTION_NORMALIZE_SPACE: [EOL]             case FUNCTION_TRANSLATE: [EOL]             case FUNCTION_BOOLEAN: [EOL]             case FUNCTION_NOT: [EOL]             case FUNCTION_TRUE: [EOL]             case FUNCTION_FALSE: [EOL]             case FUNCTION_NULL: [EOL]             case FUNCTION_LANG: [EOL]             case FUNCTION_NUMBER: [EOL]             case FUNCTION_SUM: [EOL]             case FUNCTION_FLOOR: [EOL]             case FUNCTION_CEILING: [EOL]             case FUNCTION_ROUND: [EOL]             case FUNCTION_FORMAT_NUMBER: [EOL]             case NCName: [EOL]             case 82: [EOL]             case 83: [EOL]             case 86: [EOL]             case 88: [EOL]                 ex = LocationPath(); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[21] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object OrExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ArrayList list = null; [EOL]     ex = AndExpr(); [EOL]     label_8: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case OR: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[24] = jj_gen; [EOL]                 break label_8; [EOL]         } [EOL]         jj_consume_token(OR); [EOL]         r = AndExpr(); [EOL]         if (list == null) { [EOL]             list = new ArrayList(); [EOL]             list.add(ex); [EOL]         } [EOL]         list.add(r); [EOL]     } [EOL]     if (list != null) { [EOL]         ex = compiler.or(list.toArray()); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object AndExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ArrayList list = null; [EOL]     ex = EqualityExpr(); [EOL]     label_9: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case AND: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[25] = jj_gen; [EOL]                 break label_9; [EOL]         } [EOL]         jj_consume_token(AND); [EOL]         r = EqualityExpr(); [EOL]         if (list == null) { [EOL]             list = new ArrayList(); [EOL]             list.add(ex); [EOL]         } [EOL]         list.add(r); [EOL]     } [EOL]     if (list != null) { [EOL]         ex = compiler.and(list.toArray()); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object AndExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ArrayList list = null; [EOL]     ex = EqualityExpr(); [EOL]     label_9: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case AND: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[25] = jj_gen; [EOL]                 break label_9; [EOL]         } [EOL]         jj_consume_token(AND); [EOL]         r = EqualityExpr(); [EOL]         if (list == null) { [EOL]             list = new ArrayList(); [EOL]             list.add(ex); [EOL]         } [EOL]         list.add(r); [EOL]     } [EOL]     if (list != null) { [EOL]         ex = compiler.and(list.toArray()); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object EqualityExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ex = RelationalExpr(); [EOL]     label_10: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case EQ: [EOL]             case NEQ: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[26] = jj_gen; [EOL]                 break label_10; [EOL]         } [EOL]         switch(jj_nt.kind) { [EOL]             case EQ: [EOL]                 jj_consume_token(EQ); [EOL]                 r = RelationalExpr(); [EOL]                 ex = compiler.equal(ex, r); [EOL]                 break; [EOL]             case NEQ: [EOL]                 jj_consume_token(NEQ); [EOL]                 r = RelationalExpr(); [EOL]                 ex = compiler.notEqual(ex, r); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[27] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object EqualityExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ex = RelationalExpr(); [EOL]     label_10: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case EQ: [EOL]             case NEQ: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[26] = jj_gen; [EOL]                 break label_10; [EOL]         } [EOL]         switch(jj_nt.kind) { [EOL]             case EQ: [EOL]                 jj_consume_token(EQ); [EOL]                 r = RelationalExpr(); [EOL]                 ex = compiler.equal(ex, r); [EOL]                 break; [EOL]             case NEQ: [EOL]                 jj_consume_token(NEQ); [EOL]                 r = RelationalExpr(); [EOL]                 ex = compiler.notEqual(ex, r); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[27] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object EqualityExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ex = RelationalExpr(); [EOL]     label_10: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case EQ: [EOL]             case NEQ: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[26] = jj_gen; [EOL]                 break label_10; [EOL]         } [EOL]         switch(jj_nt.kind) { [EOL]             case EQ: [EOL]                 jj_consume_token(EQ); [EOL]                 r = RelationalExpr(); [EOL]                 ex = compiler.equal(ex, r); [EOL]                 break; [EOL]             case NEQ: [EOL]                 jj_consume_token(NEQ); [EOL]                 r = RelationalExpr(); [EOL]                 ex = compiler.notEqual(ex, r); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[27] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object RelationalExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ex = AdditiveExpr(); [EOL]     label_11: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case LT: [EOL]             case LTE: [EOL]             case GT: [EOL]             case GTE: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[28] = jj_gen; [EOL]                 break label_11; [EOL]         } [EOL]         switch(jj_nt.kind) { [EOL]             case LT: [EOL]                 jj_consume_token(LT); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.lessThan(ex, r); [EOL]                 break; [EOL]             case GT: [EOL]                 jj_consume_token(GT); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.greaterThan(ex, r); [EOL]                 break; [EOL]             case LTE: [EOL]                 jj_consume_token(LTE); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.lessThanOrEqual(ex, r); [EOL]                 break; [EOL]             case GTE: [EOL]                 jj_consume_token(GTE); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.greaterThanOrEqual(ex, r); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[29] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object RelationalExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ex = AdditiveExpr(); [EOL]     label_11: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case LT: [EOL]             case LTE: [EOL]             case GT: [EOL]             case GTE: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[28] = jj_gen; [EOL]                 break label_11; [EOL]         } [EOL]         switch(jj_nt.kind) { [EOL]             case LT: [EOL]                 jj_consume_token(LT); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.lessThan(ex, r); [EOL]                 break; [EOL]             case GT: [EOL]                 jj_consume_token(GT); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.greaterThan(ex, r); [EOL]                 break; [EOL]             case LTE: [EOL]                 jj_consume_token(LTE); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.lessThanOrEqual(ex, r); [EOL]                 break; [EOL]             case GTE: [EOL]                 jj_consume_token(GTE); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.greaterThanOrEqual(ex, r); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[29] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object RelationalExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ex = AdditiveExpr(); [EOL]     label_11: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case LT: [EOL]             case LTE: [EOL]             case GT: [EOL]             case GTE: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[28] = jj_gen; [EOL]                 break label_11; [EOL]         } [EOL]         switch(jj_nt.kind) { [EOL]             case LT: [EOL]                 jj_consume_token(LT); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.lessThan(ex, r); [EOL]                 break; [EOL]             case GT: [EOL]                 jj_consume_token(GT); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.greaterThan(ex, r); [EOL]                 break; [EOL]             case LTE: [EOL]                 jj_consume_token(LTE); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.lessThanOrEqual(ex, r); [EOL]                 break; [EOL]             case GTE: [EOL]                 jj_consume_token(GTE); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.greaterThanOrEqual(ex, r); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[29] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object RelationalExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ex = AdditiveExpr(); [EOL]     label_11: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case LT: [EOL]             case LTE: [EOL]             case GT: [EOL]             case GTE: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[28] = jj_gen; [EOL]                 break label_11; [EOL]         } [EOL]         switch(jj_nt.kind) { [EOL]             case LT: [EOL]                 jj_consume_token(LT); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.lessThan(ex, r); [EOL]                 break; [EOL]             case GT: [EOL]                 jj_consume_token(GT); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.greaterThan(ex, r); [EOL]                 break; [EOL]             case LTE: [EOL]                 jj_consume_token(LTE); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.lessThanOrEqual(ex, r); [EOL]                 break; [EOL]             case GTE: [EOL]                 jj_consume_token(GTE); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.greaterThanOrEqual(ex, r); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[29] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object RelationalExpr() throws ParseException { [EOL]     Object ex, r; [EOL]     ex = AdditiveExpr(); [EOL]     label_11: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case LT: [EOL]             case LTE: [EOL]             case GT: [EOL]             case GTE: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[28] = jj_gen; [EOL]                 break label_11; [EOL]         } [EOL]         switch(jj_nt.kind) { [EOL]             case LT: [EOL]                 jj_consume_token(LT); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.lessThan(ex, r); [EOL]                 break; [EOL]             case GT: [EOL]                 jj_consume_token(GT); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.greaterThan(ex, r); [EOL]                 break; [EOL]             case LTE: [EOL]                 jj_consume_token(LTE); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.lessThanOrEqual(ex, r); [EOL]                 break; [EOL]             case GTE: [EOL]                 jj_consume_token(GTE); [EOL]                 r = AdditiveExpr(); [EOL]                 ex = compiler.greaterThanOrEqual(ex, r); [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[29] = jj_gen; [EOL]                 jj_consume_token(-1); [EOL]                 throw new ParseException(); [EOL]         } [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object SubtractiveExpr() throws ParseException { [EOL]     Object ex, r = null; [EOL]     ex = MultiplicativeExpr(); [EOL]     label_13: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case MINUS: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[31] = jj_gen; [EOL]                 break label_13; [EOL]         } [EOL]         jj_consume_token(MINUS); [EOL]         r = MultiplicativeExpr(); [EOL]         ex = compiler.minus(ex, r); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object SubtractiveExpr() throws ParseException { [EOL]     Object ex, r = null; [EOL]     ex = MultiplicativeExpr(); [EOL]     label_13: while (true) { [EOL]         switch(jj_nt.kind) { [EOL]             case MINUS: [EOL]                 ; [EOL]                 break; [EOL]             default: [EOL]                 jj_la1[31] = jj_gen; [EOL]                 break label_13; [EOL]         } [EOL]         jj_consume_token(MINUS); [EOL]         r = MultiplicativeExpr(); [EOL]         ex = compiler.minus(ex, r); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object UnaryExpr() throws ParseException { [EOL]     Object ex; [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]         case VARIABLE: [EOL]         case Literal: [EOL]         case Number: [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 80: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = UnionExpr(); [EOL]             break; [EOL]         case MINUS: [EOL]             jj_consume_token(MINUS); [EOL]             ex = UnaryExpr(); [EOL]             ex = compiler.minus(ex); [EOL]             break; [EOL]         default: [EOL]             jj_la1[34] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object UnaryExpr() throws ParseException { [EOL]     Object ex; [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]         case VARIABLE: [EOL]         case Literal: [EOL]         case Number: [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 80: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = UnionExpr(); [EOL]             break; [EOL]         case MINUS: [EOL]             jj_consume_token(MINUS); [EOL]             ex = UnaryExpr(); [EOL]             ex = compiler.minus(ex); [EOL]             break; [EOL]         default: [EOL]             jj_la1[34] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object UnaryExpr() throws ParseException { [EOL]     Object ex; [EOL]     switch(jj_nt.kind) { [EOL]         case SLASH: [EOL]         case SLASHSLASH: [EOL]         case VARIABLE: [EOL]         case Literal: [EOL]         case Number: [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case AXIS_SELF: [EOL]         case AXIS_CHILD: [EOL]         case AXIS_PARENT: [EOL]         case AXIS_ANCESTOR: [EOL]         case AXIS_ATTRIBUTE: [EOL]         case AXIS_NAMESPACE: [EOL]         case AXIS_PRECEDING: [EOL]         case AXIS_FOLLOWING: [EOL]         case AXIS_DESCENDANT: [EOL]         case AXIS_ANCESTOR_OR_SELF: [EOL]         case AXIS_FOLLOWING_SIBLING: [EOL]         case AXIS_PRECEDING_SIBLING: [EOL]         case AXIS_DESCENDANT_OR_SELF: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]         case 80: [EOL]         case 82: [EOL]         case 83: [EOL]         case 86: [EOL]         case 88: [EOL]             ex = UnionExpr(); [EOL]             break; [EOL]         case MINUS: [EOL]             jj_consume_token(MINUS); [EOL]             ex = UnaryExpr(); [EOL]             ex = compiler.minus(ex); [EOL]             break; [EOL]         default: [EOL]             jj_la1[34] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return ex; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object WildcardName() throws ParseException { [EOL]     Object qn; [EOL]     String nc1, nc2 = null; [EOL]     switch(jj_nt.kind) { [EOL]         case 88: [EOL]             jj_consume_token(88); [EOL]             break; [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]             NCName(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[35] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     nc1 = token.image; [EOL]     switch(jj_nt.kind) { [EOL]         case 79: [EOL]             jj_consume_token(79); [EOL]             switch(jj_nt.kind) { [EOL]                 case 88: [EOL]                     jj_consume_token(88); [EOL]                     break; [EOL]                 case OR: [EOL]                 case AND: [EOL]                 case MOD: [EOL]                 case DIV: [EOL]                 case NODE: [EOL]                 case TEXT: [EOL]                 case COMMENT: [EOL]                 case PI: [EOL]                 case FUNCTION_LAST: [EOL]                 case FUNCTION_POSITION: [EOL]                 case FUNCTION_COUNT: [EOL]                 case FUNCTION_ID: [EOL]                 case FUNCTION_KEY: [EOL]                 case FUNCTION_LOCAL_NAME: [EOL]                 case FUNCTION_NAMESPACE_URI: [EOL]                 case FUNCTION_NAME: [EOL]                 case FUNCTION_STRING: [EOL]                 case FUNCTION_CONCAT: [EOL]                 case FUNCTION_STARTS_WITH: [EOL]                 case FUNCTION_CONTAINS: [EOL]                 case FUNCTION_SUBSTRING_BEFORE: [EOL]                 case FUNCTION_SUBSTRING_AFTER: [EOL]                 case FUNCTION_SUBSTRING: [EOL]                 case FUNCTION_STRING_LENGTH: [EOL]                 case FUNCTION_NORMALIZE_SPACE: [EOL]                 case FUNCTION_TRANSLATE: [EOL]                 case FUNCTION_BOOLEAN: [EOL]                 case FUNCTION_NOT: [EOL]                 case FUNCTION_TRUE: [EOL]                 case FUNCTION_FALSE: [EOL]                 case FUNCTION_NULL: [EOL]                 case FUNCTION_LANG: [EOL]                 case FUNCTION_NUMBER: [EOL]                 case FUNCTION_SUM: [EOL]                 case FUNCTION_FLOOR: [EOL]                 case FUNCTION_CEILING: [EOL]                 case FUNCTION_ROUND: [EOL]                 case FUNCTION_FORMAT_NUMBER: [EOL]                 case NCName: [EOL]                     NCName(); [EOL]                     break; [EOL]                 default: [EOL]                     jj_la1[36] = jj_gen; [EOL]                     jj_consume_token(-1); [EOL]                     throw new ParseException(); [EOL]             } [EOL]             nc2 = token.image; [EOL]             break; [EOL]         default: [EOL]             jj_la1[37] = jj_gen; [EOL]             ; [EOL]     } [EOL]     if (nc2 != null) { [EOL]         qn = compiler.qname(nc1, nc2); [EOL]     } else { [EOL]         qn = compiler.qname(null, nc1); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return qn; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object WildcardName() throws ParseException { [EOL]     Object qn; [EOL]     String nc1, nc2 = null; [EOL]     switch(jj_nt.kind) { [EOL]         case 88: [EOL]             jj_consume_token(88); [EOL]             break; [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]             NCName(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[35] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     nc1 = token.image; [EOL]     switch(jj_nt.kind) { [EOL]         case 79: [EOL]             jj_consume_token(79); [EOL]             switch(jj_nt.kind) { [EOL]                 case 88: [EOL]                     jj_consume_token(88); [EOL]                     break; [EOL]                 case OR: [EOL]                 case AND: [EOL]                 case MOD: [EOL]                 case DIV: [EOL]                 case NODE: [EOL]                 case TEXT: [EOL]                 case COMMENT: [EOL]                 case PI: [EOL]                 case FUNCTION_LAST: [EOL]                 case FUNCTION_POSITION: [EOL]                 case FUNCTION_COUNT: [EOL]                 case FUNCTION_ID: [EOL]                 case FUNCTION_KEY: [EOL]                 case FUNCTION_LOCAL_NAME: [EOL]                 case FUNCTION_NAMESPACE_URI: [EOL]                 case FUNCTION_NAME: [EOL]                 case FUNCTION_STRING: [EOL]                 case FUNCTION_CONCAT: [EOL]                 case FUNCTION_STARTS_WITH: [EOL]                 case FUNCTION_CONTAINS: [EOL]                 case FUNCTION_SUBSTRING_BEFORE: [EOL]                 case FUNCTION_SUBSTRING_AFTER: [EOL]                 case FUNCTION_SUBSTRING: [EOL]                 case FUNCTION_STRING_LENGTH: [EOL]                 case FUNCTION_NORMALIZE_SPACE: [EOL]                 case FUNCTION_TRANSLATE: [EOL]                 case FUNCTION_BOOLEAN: [EOL]                 case FUNCTION_NOT: [EOL]                 case FUNCTION_TRUE: [EOL]                 case FUNCTION_FALSE: [EOL]                 case FUNCTION_NULL: [EOL]                 case FUNCTION_LANG: [EOL]                 case FUNCTION_NUMBER: [EOL]                 case FUNCTION_SUM: [EOL]                 case FUNCTION_FLOOR: [EOL]                 case FUNCTION_CEILING: [EOL]                 case FUNCTION_ROUND: [EOL]                 case FUNCTION_FORMAT_NUMBER: [EOL]                 case NCName: [EOL]                     NCName(); [EOL]                     break; [EOL]                 default: [EOL]                     jj_la1[36] = jj_gen; [EOL]                     jj_consume_token(-1); [EOL]                     throw new ParseException(); [EOL]             } [EOL]             nc2 = token.image; [EOL]             break; [EOL]         default: [EOL]             jj_la1[37] = jj_gen; [EOL]             ; [EOL]     } [EOL]     if (nc2 != null) { [EOL]         qn = compiler.qname(nc1, nc2); [EOL]     } else { [EOL]         qn = compiler.qname(null, nc1); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return qn; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object WildcardName() throws ParseException { [EOL]     Object qn; [EOL]     String nc1, nc2 = null; [EOL]     switch(jj_nt.kind) { [EOL]         case 88: [EOL]             jj_consume_token(88); [EOL]             break; [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]             NCName(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[35] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     nc1 = token.image; [EOL]     switch(jj_nt.kind) { [EOL]         case 79: [EOL]             jj_consume_token(79); [EOL]             switch(jj_nt.kind) { [EOL]                 case 88: [EOL]                     jj_consume_token(88); [EOL]                     break; [EOL]                 case OR: [EOL]                 case AND: [EOL]                 case MOD: [EOL]                 case DIV: [EOL]                 case NODE: [EOL]                 case TEXT: [EOL]                 case COMMENT: [EOL]                 case PI: [EOL]                 case FUNCTION_LAST: [EOL]                 case FUNCTION_POSITION: [EOL]                 case FUNCTION_COUNT: [EOL]                 case FUNCTION_ID: [EOL]                 case FUNCTION_KEY: [EOL]                 case FUNCTION_LOCAL_NAME: [EOL]                 case FUNCTION_NAMESPACE_URI: [EOL]                 case FUNCTION_NAME: [EOL]                 case FUNCTION_STRING: [EOL]                 case FUNCTION_CONCAT: [EOL]                 case FUNCTION_STARTS_WITH: [EOL]                 case FUNCTION_CONTAINS: [EOL]                 case FUNCTION_SUBSTRING_BEFORE: [EOL]                 case FUNCTION_SUBSTRING_AFTER: [EOL]                 case FUNCTION_SUBSTRING: [EOL]                 case FUNCTION_STRING_LENGTH: [EOL]                 case FUNCTION_NORMALIZE_SPACE: [EOL]                 case FUNCTION_TRANSLATE: [EOL]                 case FUNCTION_BOOLEAN: [EOL]                 case FUNCTION_NOT: [EOL]                 case FUNCTION_TRUE: [EOL]                 case FUNCTION_FALSE: [EOL]                 case FUNCTION_NULL: [EOL]                 case FUNCTION_LANG: [EOL]                 case FUNCTION_NUMBER: [EOL]                 case FUNCTION_SUM: [EOL]                 case FUNCTION_FLOOR: [EOL]                 case FUNCTION_CEILING: [EOL]                 case FUNCTION_ROUND: [EOL]                 case FUNCTION_FORMAT_NUMBER: [EOL]                 case NCName: [EOL]                     NCName(); [EOL]                     break; [EOL]                 default: [EOL]                     jj_la1[36] = jj_gen; [EOL]                     jj_consume_token(-1); [EOL]                     throw new ParseException(); [EOL]             } [EOL]             nc2 = token.image; [EOL]             break; [EOL]         default: [EOL]             jj_la1[37] = jj_gen; [EOL]             ; [EOL]     } [EOL]     if (nc2 != null) { [EOL]         qn = compiler.qname(nc1, nc2); [EOL]     } else { [EOL]         qn = compiler.qname(null, nc1); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return qn; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object WildcardName() throws ParseException { [EOL]     Object qn; [EOL]     String nc1, nc2 = null; [EOL]     switch(jj_nt.kind) { [EOL]         case 88: [EOL]             jj_consume_token(88); [EOL]             break; [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]             NCName(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[35] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     nc1 = token.image; [EOL]     switch(jj_nt.kind) { [EOL]         case 79: [EOL]             jj_consume_token(79); [EOL]             switch(jj_nt.kind) { [EOL]                 case 88: [EOL]                     jj_consume_token(88); [EOL]                     break; [EOL]                 case OR: [EOL]                 case AND: [EOL]                 case MOD: [EOL]                 case DIV: [EOL]                 case NODE: [EOL]                 case TEXT: [EOL]                 case COMMENT: [EOL]                 case PI: [EOL]                 case FUNCTION_LAST: [EOL]                 case FUNCTION_POSITION: [EOL]                 case FUNCTION_COUNT: [EOL]                 case FUNCTION_ID: [EOL]                 case FUNCTION_KEY: [EOL]                 case FUNCTION_LOCAL_NAME: [EOL]                 case FUNCTION_NAMESPACE_URI: [EOL]                 case FUNCTION_NAME: [EOL]                 case FUNCTION_STRING: [EOL]                 case FUNCTION_CONCAT: [EOL]                 case FUNCTION_STARTS_WITH: [EOL]                 case FUNCTION_CONTAINS: [EOL]                 case FUNCTION_SUBSTRING_BEFORE: [EOL]                 case FUNCTION_SUBSTRING_AFTER: [EOL]                 case FUNCTION_SUBSTRING: [EOL]                 case FUNCTION_STRING_LENGTH: [EOL]                 case FUNCTION_NORMALIZE_SPACE: [EOL]                 case FUNCTION_TRANSLATE: [EOL]                 case FUNCTION_BOOLEAN: [EOL]                 case FUNCTION_NOT: [EOL]                 case FUNCTION_TRUE: [EOL]                 case FUNCTION_FALSE: [EOL]                 case FUNCTION_NULL: [EOL]                 case FUNCTION_LANG: [EOL]                 case FUNCTION_NUMBER: [EOL]                 case FUNCTION_SUM: [EOL]                 case FUNCTION_FLOOR: [EOL]                 case FUNCTION_CEILING: [EOL]                 case FUNCTION_ROUND: [EOL]                 case FUNCTION_FORMAT_NUMBER: [EOL]                 case NCName: [EOL]                     NCName(); [EOL]                     break; [EOL]                 default: [EOL]                     jj_la1[36] = jj_gen; [EOL]                     jj_consume_token(-1); [EOL]                     throw new ParseException(); [EOL]             } [EOL]             nc2 = token.image; [EOL]             break; [EOL]         default: [EOL]             jj_la1[37] = jj_gen; [EOL]             ; [EOL]     } [EOL]     if (nc2 != null) { [EOL]         qn = compiler.qname(nc1, nc2); [EOL]     } else { [EOL]         qn = compiler.qname(null, nc1); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return qn; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object WildcardName() throws ParseException { [EOL]     Object qn; [EOL]     String nc1, nc2 = null; [EOL]     switch(jj_nt.kind) { [EOL]         case 88: [EOL]             jj_consume_token(88); [EOL]             break; [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]             NCName(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[35] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     nc1 = token.image; [EOL]     switch(jj_nt.kind) { [EOL]         case 79: [EOL]             jj_consume_token(79); [EOL]             switch(jj_nt.kind) { [EOL]                 case 88: [EOL]                     jj_consume_token(88); [EOL]                     break; [EOL]                 case OR: [EOL]                 case AND: [EOL]                 case MOD: [EOL]                 case DIV: [EOL]                 case NODE: [EOL]                 case TEXT: [EOL]                 case COMMENT: [EOL]                 case PI: [EOL]                 case FUNCTION_LAST: [EOL]                 case FUNCTION_POSITION: [EOL]                 case FUNCTION_COUNT: [EOL]                 case FUNCTION_ID: [EOL]                 case FUNCTION_KEY: [EOL]                 case FUNCTION_LOCAL_NAME: [EOL]                 case FUNCTION_NAMESPACE_URI: [EOL]                 case FUNCTION_NAME: [EOL]                 case FUNCTION_STRING: [EOL]                 case FUNCTION_CONCAT: [EOL]                 case FUNCTION_STARTS_WITH: [EOL]                 case FUNCTION_CONTAINS: [EOL]                 case FUNCTION_SUBSTRING_BEFORE: [EOL]                 case FUNCTION_SUBSTRING_AFTER: [EOL]                 case FUNCTION_SUBSTRING: [EOL]                 case FUNCTION_STRING_LENGTH: [EOL]                 case FUNCTION_NORMALIZE_SPACE: [EOL]                 case FUNCTION_TRANSLATE: [EOL]                 case FUNCTION_BOOLEAN: [EOL]                 case FUNCTION_NOT: [EOL]                 case FUNCTION_TRUE: [EOL]                 case FUNCTION_FALSE: [EOL]                 case FUNCTION_NULL: [EOL]                 case FUNCTION_LANG: [EOL]                 case FUNCTION_NUMBER: [EOL]                 case FUNCTION_SUM: [EOL]                 case FUNCTION_FLOOR: [EOL]                 case FUNCTION_CEILING: [EOL]                 case FUNCTION_ROUND: [EOL]                 case FUNCTION_FORMAT_NUMBER: [EOL]                 case NCName: [EOL]                     NCName(); [EOL]                     break; [EOL]                 default: [EOL]                     jj_la1[36] = jj_gen; [EOL]                     jj_consume_token(-1); [EOL]                     throw new ParseException(); [EOL]             } [EOL]             nc2 = token.image; [EOL]             break; [EOL]         default: [EOL]             jj_la1[37] = jj_gen; [EOL]             ; [EOL]     } [EOL]     if (nc2 != null) { [EOL]         qn = compiler.qname(nc1, nc2); [EOL]     } else { [EOL]         qn = compiler.qname(null, nc1); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return qn; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final public Object WildcardName() throws ParseException { [EOL]     Object qn; [EOL]     String nc1, nc2 = null; [EOL]     switch(jj_nt.kind) { [EOL]         case 88: [EOL]             jj_consume_token(88); [EOL]             break; [EOL]         case OR: [EOL]         case AND: [EOL]         case MOD: [EOL]         case DIV: [EOL]         case NODE: [EOL]         case TEXT: [EOL]         case COMMENT: [EOL]         case PI: [EOL]         case FUNCTION_LAST: [EOL]         case FUNCTION_POSITION: [EOL]         case FUNCTION_COUNT: [EOL]         case FUNCTION_ID: [EOL]         case FUNCTION_KEY: [EOL]         case FUNCTION_LOCAL_NAME: [EOL]         case FUNCTION_NAMESPACE_URI: [EOL]         case FUNCTION_NAME: [EOL]         case FUNCTION_STRING: [EOL]         case FUNCTION_CONCAT: [EOL]         case FUNCTION_STARTS_WITH: [EOL]         case FUNCTION_CONTAINS: [EOL]         case FUNCTION_SUBSTRING_BEFORE: [EOL]         case FUNCTION_SUBSTRING_AFTER: [EOL]         case FUNCTION_SUBSTRING: [EOL]         case FUNCTION_STRING_LENGTH: [EOL]         case FUNCTION_NORMALIZE_SPACE: [EOL]         case FUNCTION_TRANSLATE: [EOL]         case FUNCTION_BOOLEAN: [EOL]         case FUNCTION_NOT: [EOL]         case FUNCTION_TRUE: [EOL]         case FUNCTION_FALSE: [EOL]         case FUNCTION_NULL: [EOL]         case FUNCTION_LANG: [EOL]         case FUNCTION_NUMBER: [EOL]         case FUNCTION_SUM: [EOL]         case FUNCTION_FLOOR: [EOL]         case FUNCTION_CEILING: [EOL]         case FUNCTION_ROUND: [EOL]         case FUNCTION_FORMAT_NUMBER: [EOL]         case NCName: [EOL]             NCName(); [EOL]             break; [EOL]         default: [EOL]             jj_la1[35] = jj_gen; [EOL]             jj_consume_token(-1); [EOL]             throw new ParseException(); [EOL]     } [EOL]     nc1 = token.image; [EOL]     switch(jj_nt.kind) { [EOL]         case 79: [EOL]             jj_consume_token(79); [EOL]             switch(jj_nt.kind) { [EOL]                 case 88: [EOL]                     jj_consume_token(88); [EOL]                     break; [EOL]                 case OR: [EOL]                 case AND: [EOL]                 case MOD: [EOL]                 case DIV: [EOL]                 case NODE: [EOL]                 case TEXT: [EOL]                 case COMMENT: [EOL]                 case PI: [EOL]                 case FUNCTION_LAST: [EOL]                 case FUNCTION_POSITION: [EOL]                 case FUNCTION_COUNT: [EOL]                 case FUNCTION_ID: [EOL]                 case FUNCTION_KEY: [EOL]                 case FUNCTION_LOCAL_NAME: [EOL]                 case FUNCTION_NAMESPACE_URI: [EOL]                 case FUNCTION_NAME: [EOL]                 case FUNCTION_STRING: [EOL]                 case FUNCTION_CONCAT: [EOL]                 case FUNCTION_STARTS_WITH: [EOL]                 case FUNCTION_CONTAINS: [EOL]                 case FUNCTION_SUBSTRING_BEFORE: [EOL]                 case FUNCTION_SUBSTRING_AFTER: [EOL]                 case FUNCTION_SUBSTRING: [EOL]                 case FUNCTION_STRING_LENGTH: [EOL]                 case FUNCTION_NORMALIZE_SPACE: [EOL]                 case FUNCTION_TRANSLATE: [EOL]                 case FUNCTION_BOOLEAN: [EOL]                 case FUNCTION_NOT: [EOL]                 case FUNCTION_TRUE: [EOL]                 case FUNCTION_FALSE: [EOL]                 case FUNCTION_NULL: [EOL]                 case FUNCTION_LANG: [EOL]                 case FUNCTION_NUMBER: [EOL]                 case FUNCTION_SUM: [EOL]                 case FUNCTION_FLOOR: [EOL]                 case FUNCTION_CEILING: [EOL]                 case FUNCTION_ROUND: [EOL]                 case FUNCTION_FORMAT_NUMBER: [EOL]                 case NCName: [EOL]                     NCName(); [EOL]                     break; [EOL]                 default: [EOL]                     jj_la1[36] = jj_gen; [EOL]                     jj_consume_token(-1); [EOL]                     throw new ParseException(); [EOL]             } [EOL]             nc2 = token.image; [EOL]             break; [EOL]         default: [EOL]             jj_la1[37] = jj_gen; [EOL]             ; [EOL]     } [EOL]     if (nc2 != null) { [EOL]         qn = compiler.qname(nc1, nc2); [EOL]     } else { [EOL]         qn = compiler.qname(null, nc1); [EOL]     } [EOL]     { [EOL]         if (true) [EOL]             return qn; [EOL]     } [EOL]     throw new Error("Missing return statement in function"); [EOL] }
final private boolean jj_3R_64() { [EOL]     if (jj_scan_token(FUNCTION_COUNT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_64() { [EOL]     if (jj_scan_token(FUNCTION_COUNT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_64() { [EOL]     if (jj_scan_token(FUNCTION_COUNT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_62() { [EOL]     if (jj_scan_token(FUNCTION_LAST)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_62() { [EOL]     if (jj_scan_token(FUNCTION_LAST)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_62() { [EOL]     if (jj_scan_token(FUNCTION_LAST)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_18() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_62()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_63()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_64()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_65()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_66()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_67()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_68()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_69()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_70()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_71()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_72()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_73()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_74()) { [EOL]                                                         jj_scanpos = xsp; [EOL]                                                         if (jj_3R_75()) { [EOL]                                                             jj_scanpos = xsp; [EOL]                                                             if (jj_3R_76()) { [EOL]                                                                 jj_scanpos = xsp; [EOL]                                                                 if (jj_3R_77()) { [EOL]                                                                     jj_scanpos = xsp; [EOL]                                                                     if (jj_3R_78()) { [EOL]                                                                         jj_scanpos = xsp; [EOL]                                                                         if (jj_3R_79()) { [EOL]                                                                             jj_scanpos = xsp; [EOL]                                                                             if (jj_3R_80()) { [EOL]                                                                                 jj_scanpos = xsp; [EOL]                                                                                 if (jj_3R_81()) { [EOL]                                                                                     jj_scanpos = xsp; [EOL]                                                                                     if (jj_3R_82()) { [EOL]                                                                                         jj_scanpos = xsp; [EOL]                                                                                         if (jj_3R_83()) { [EOL]                                                                                             jj_scanpos = xsp; [EOL]                                                                                             if (jj_3R_84()) { [EOL]                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                 if (jj_3R_85()) { [EOL]                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                     if (jj_3R_86()) { [EOL]                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                         if (jj_3R_87()) { [EOL]                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                             if (jj_3R_88()) { [EOL]                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                 if (jj_3R_89()) { [EOL]                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                     if (jj_3R_90()) { [EOL]                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                         if (jj_3R_91()) [EOL]                                                                                                                             return true; [EOL]                                                                                                                         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                             return false; [EOL]                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                         return false; [EOL]                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                     return false; [EOL]                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                 return false; [EOL]                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                             return false; [EOL]                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                         return false; [EOL]                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                     return false; [EOL]                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                 return false; [EOL]                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                             return false; [EOL]                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                         return false; [EOL]                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                     return false; [EOL]                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                 return false; [EOL]                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                             return false; [EOL]                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                         return false; [EOL]                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                     return false; [EOL]                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                 return false; [EOL]                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                             return false; [EOL]                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_173() { [EOL]     if (jj_scan_token(MINUS)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_170()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_173() { [EOL]     if (jj_scan_token(MINUS)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_170()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_173() { [EOL]     if (jj_scan_token(MINUS)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_170()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_173() { [EOL]     if (jj_scan_token(MINUS)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_170()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_171() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_174()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_175()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_176()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_171() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_174()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_175()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_176()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_171() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_174()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_175()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_176()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_171() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_174()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_175()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_176()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_170() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_172()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_173()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_170() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_172()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_173()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_170() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_172()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_173()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_170() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_172()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_173()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_170() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_172()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_173()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_175() { [EOL]     if (jj_scan_token(DIV)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_170()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_175() { [EOL]     if (jj_scan_token(DIV)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_170()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_175() { [EOL]     if (jj_scan_token(DIV)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_170()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_175() { [EOL]     if (jj_scan_token(DIV)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_170()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_42() { [EOL]     if (jj_scan_token(FUNCTION_BOOLEAN)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_42() { [EOL]     if (jj_scan_token(FUNCTION_BOOLEAN)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_42() { [EOL]     if (jj_scan_token(FUNCTION_BOOLEAN)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_168() { [EOL]     if (jj_3R_170()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_171()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_168() { [EOL]     if (jj_3R_170()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_171()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_168() { [EOL]     if (jj_3R_170()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_171()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_168() { [EOL]     if (jj_3R_170()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_171()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_169() { [EOL]     if (jj_scan_token(MINUS)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_168()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_169() { [EOL]     if (jj_scan_token(MINUS)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_168()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_169() { [EOL]     if (jj_scan_token(MINUS)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_168()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_169() { [EOL]     if (jj_scan_token(MINUS)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_168()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_27() { [EOL]     if (jj_scan_token(FUNCTION_COUNT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_27() { [EOL]     if (jj_scan_token(FUNCTION_COUNT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_27() { [EOL]     if (jj_scan_token(FUNCTION_COUNT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_150() { [EOL]     if (jj_scan_token(AXIS_FOLLOWING_SIBLING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_150() { [EOL]     if (jj_scan_token(AXIS_FOLLOWING_SIBLING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_148() { [EOL]     if (jj_scan_token(AXIS_DESCENDANT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_148() { [EOL]     if (jj_scan_token(AXIS_DESCENDANT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_148() { [EOL]     if (jj_scan_token(AXIS_DESCENDANT)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_146() { [EOL]     if (jj_scan_token(AXIS_PRECEDING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_146() { [EOL]     if (jj_scan_token(AXIS_PRECEDING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_146() { [EOL]     if (jj_scan_token(AXIS_PRECEDING)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_145() { [EOL]     if (jj_scan_token(AXIS_NAMESPACE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_145() { [EOL]     if (jj_scan_token(AXIS_NAMESPACE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_145() { [EOL]     if (jj_scan_token(AXIS_NAMESPACE)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_162() { [EOL]     if (jj_3R_168()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_169()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_162() { [EOL]     if (jj_3R_168()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_169()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_162() { [EOL]     if (jj_3R_168()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_169()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_162() { [EOL]     if (jj_3R_168()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_169()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_15() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_20()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_21()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_22()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_23()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_24()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_25()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_26()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_27()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_28()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_29()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_30()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_31()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_32()) { [EOL]                                                         jj_scanpos = xsp; [EOL]                                                         if (jj_3R_33()) { [EOL]                                                             jj_scanpos = xsp; [EOL]                                                             if (jj_3R_34()) { [EOL]                                                                 jj_scanpos = xsp; [EOL]                                                                 if (jj_3R_35()) { [EOL]                                                                     jj_scanpos = xsp; [EOL]                                                                     if (jj_3R_36()) { [EOL]                                                                         jj_scanpos = xsp; [EOL]                                                                         if (jj_3R_37()) { [EOL]                                                                             jj_scanpos = xsp; [EOL]                                                                             if (jj_3R_38()) { [EOL]                                                                                 jj_scanpos = xsp; [EOL]                                                                                 if (jj_3R_39()) { [EOL]                                                                                     jj_scanpos = xsp; [EOL]                                                                                     if (jj_3R_40()) { [EOL]                                                                                         jj_scanpos = xsp; [EOL]                                                                                         if (jj_3R_41()) { [EOL]                                                                                             jj_scanpos = xsp; [EOL]                                                                                             if (jj_3R_42()) { [EOL]                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                 if (jj_3R_43()) { [EOL]                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                     if (jj_3R_44()) { [EOL]                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                         if (jj_3R_45()) { [EOL]                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                             if (jj_3R_46()) { [EOL]                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                 if (jj_3R_47()) { [EOL]                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                     if (jj_3R_48()) { [EOL]                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                         if (jj_3R_49()) { [EOL]                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                             if (jj_3R_50()) { [EOL]                                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                                 if (jj_3R_51()) { [EOL]                                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                                     if (jj_3R_52()) { [EOL]                                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                                         if (jj_3R_53()) { [EOL]                                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                                             if (jj_3R_54()) [EOL]                                                                                                                                                 return true; [EOL]                                                                                                                                             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                                 return false; [EOL]                                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                             return false; [EOL]                                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                         return false; [EOL]                                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                     return false; [EOL]                                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                 return false; [EOL]                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                             return false; [EOL]                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                         return false; [EOL]                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                     return false; [EOL]                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                 return false; [EOL]                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                             return false; [EOL]                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                         return false; [EOL]                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                     return false; [EOL]                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                 return false; [EOL]                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                             return false; [EOL]                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                         return false; [EOL]                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                     return false; [EOL]                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                 return false; [EOL]                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                             return false; [EOL]                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                         return false; [EOL]                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                     return false; [EOL]                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                 return false; [EOL]                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                             return false; [EOL]                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_15() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_20()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_21()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_22()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_23()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_24()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_25()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_26()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_27()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_28()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_29()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_30()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_31()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_32()) { [EOL]                                                         jj_scanpos = xsp; [EOL]                                                         if (jj_3R_33()) { [EOL]                                                             jj_scanpos = xsp; [EOL]                                                             if (jj_3R_34()) { [EOL]                                                                 jj_scanpos = xsp; [EOL]                                                                 if (jj_3R_35()) { [EOL]                                                                     jj_scanpos = xsp; [EOL]                                                                     if (jj_3R_36()) { [EOL]                                                                         jj_scanpos = xsp; [EOL]                                                                         if (jj_3R_37()) { [EOL]                                                                             jj_scanpos = xsp; [EOL]                                                                             if (jj_3R_38()) { [EOL]                                                                                 jj_scanpos = xsp; [EOL]                                                                                 if (jj_3R_39()) { [EOL]                                                                                     jj_scanpos = xsp; [EOL]                                                                                     if (jj_3R_40()) { [EOL]                                                                                         jj_scanpos = xsp; [EOL]                                                                                         if (jj_3R_41()) { [EOL]                                                                                             jj_scanpos = xsp; [EOL]                                                                                             if (jj_3R_42()) { [EOL]                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                 if (jj_3R_43()) { [EOL]                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                     if (jj_3R_44()) { [EOL]                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                         if (jj_3R_45()) { [EOL]                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                             if (jj_3R_46()) { [EOL]                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                 if (jj_3R_47()) { [EOL]                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                     if (jj_3R_48()) { [EOL]                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                         if (jj_3R_49()) { [EOL]                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                             if (jj_3R_50()) { [EOL]                                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                                 if (jj_3R_51()) { [EOL]                                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                                     if (jj_3R_52()) { [EOL]                                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                                         if (jj_3R_53()) { [EOL]                                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                                             if (jj_3R_54()) [EOL]                                                                                                                                                 return true; [EOL]                                                                                                                                             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                                 return false; [EOL]                                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                             return false; [EOL]                                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                         return false; [EOL]                                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                     return false; [EOL]                                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                 return false; [EOL]                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                             return false; [EOL]                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                         return false; [EOL]                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                     return false; [EOL]                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                 return false; [EOL]                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                             return false; [EOL]                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                         return false; [EOL]                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                     return false; [EOL]                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                 return false; [EOL]                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                             return false; [EOL]                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                         return false; [EOL]                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                     return false; [EOL]                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                 return false; [EOL]                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                             return false; [EOL]                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                         return false; [EOL]                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                     return false; [EOL]                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                 return false; [EOL]                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                             return false; [EOL]                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_15() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_20()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_21()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_22()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_23()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_24()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_25()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_26()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_27()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_28()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_29()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_30()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_31()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_32()) { [EOL]                                                         jj_scanpos = xsp; [EOL]                                                         if (jj_3R_33()) { [EOL]                                                             jj_scanpos = xsp; [EOL]                                                             if (jj_3R_34()) { [EOL]                                                                 jj_scanpos = xsp; [EOL]                                                                 if (jj_3R_35()) { [EOL]                                                                     jj_scanpos = xsp; [EOL]                                                                     if (jj_3R_36()) { [EOL]                                                                         jj_scanpos = xsp; [EOL]                                                                         if (jj_3R_37()) { [EOL]                                                                             jj_scanpos = xsp; [EOL]                                                                             if (jj_3R_38()) { [EOL]                                                                                 jj_scanpos = xsp; [EOL]                                                                                 if (jj_3R_39()) { [EOL]                                                                                     jj_scanpos = xsp; [EOL]                                                                                     if (jj_3R_40()) { [EOL]                                                                                         jj_scanpos = xsp; [EOL]                                                                                         if (jj_3R_41()) { [EOL]                                                                                             jj_scanpos = xsp; [EOL]                                                                                             if (jj_3R_42()) { [EOL]                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                 if (jj_3R_43()) { [EOL]                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                     if (jj_3R_44()) { [EOL]                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                         if (jj_3R_45()) { [EOL]                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                             if (jj_3R_46()) { [EOL]                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                 if (jj_3R_47()) { [EOL]                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                     if (jj_3R_48()) { [EOL]                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                         if (jj_3R_49()) { [EOL]                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                             if (jj_3R_50()) { [EOL]                                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                                 if (jj_3R_51()) { [EOL]                                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                                     if (jj_3R_52()) { [EOL]                                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                                         if (jj_3R_53()) { [EOL]                                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                                             if (jj_3R_54()) [EOL]                                                                                                                                                 return true; [EOL]                                                                                                                                             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                                 return false; [EOL]                                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                             return false; [EOL]                                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                         return false; [EOL]                                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                     return false; [EOL]                                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                 return false; [EOL]                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                             return false; [EOL]                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                         return false; [EOL]                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                     return false; [EOL]                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                 return false; [EOL]                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                             return false; [EOL]                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                         return false; [EOL]                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                     return false; [EOL]                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                 return false; [EOL]                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                             return false; [EOL]                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                         return false; [EOL]                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                     return false; [EOL]                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                 return false; [EOL]                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                             return false; [EOL]                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                         return false; [EOL]                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                     return false; [EOL]                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                 return false; [EOL]                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                             return false; [EOL]                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_15() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_20()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_21()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_22()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_23()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_24()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_25()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_26()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_27()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_28()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_29()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_30()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_31()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_32()) { [EOL]                                                         jj_scanpos = xsp; [EOL]                                                         if (jj_3R_33()) { [EOL]                                                             jj_scanpos = xsp; [EOL]                                                             if (jj_3R_34()) { [EOL]                                                                 jj_scanpos = xsp; [EOL]                                                                 if (jj_3R_35()) { [EOL]                                                                     jj_scanpos = xsp; [EOL]                                                                     if (jj_3R_36()) { [EOL]                                                                         jj_scanpos = xsp; [EOL]                                                                         if (jj_3R_37()) { [EOL]                                                                             jj_scanpos = xsp; [EOL]                                                                             if (jj_3R_38()) { [EOL]                                                                                 jj_scanpos = xsp; [EOL]                                                                                 if (jj_3R_39()) { [EOL]                                                                                     jj_scanpos = xsp; [EOL]                                                                                     if (jj_3R_40()) { [EOL]                                                                                         jj_scanpos = xsp; [EOL]                                                                                         if (jj_3R_41()) { [EOL]                                                                                             jj_scanpos = xsp; [EOL]                                                                                             if (jj_3R_42()) { [EOL]                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                 if (jj_3R_43()) { [EOL]                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                     if (jj_3R_44()) { [EOL]                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                         if (jj_3R_45()) { [EOL]                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                             if (jj_3R_46()) { [EOL]                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                 if (jj_3R_47()) { [EOL]                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                     if (jj_3R_48()) { [EOL]                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                         if (jj_3R_49()) { [EOL]                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                             if (jj_3R_50()) { [EOL]                                                                                                                                 jj_scanpos = xsp; [EOL]                                                                                                                                 if (jj_3R_51()) { [EOL]                                                                                                                                     jj_scanpos = xsp; [EOL]                                                                                                                                     if (jj_3R_52()) { [EOL]                                                                                                                                         jj_scanpos = xsp; [EOL]                                                                                                                                         if (jj_3R_53()) { [EOL]                                                                                                                                             jj_scanpos = xsp; [EOL]                                                                                                                                             if (jj_3R_54()) [EOL]                                                                                                                                                 return true; [EOL]                                                                                                                                             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                                 return false; [EOL]                                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                             return false; [EOL]                                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                         return false; [EOL]                                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                     return false; [EOL]                                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                                 return false; [EOL]                                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                             return false; [EOL]                                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                         return false; [EOL]                                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                     return false; [EOL]                                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                                 return false; [EOL]                                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                             return false; [EOL]                                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                         return false; [EOL]                                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                     return false; [EOL]                                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                                 return false; [EOL]                                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                             return false; [EOL]                                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                         return false; [EOL]                                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                     return false; [EOL]                                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                                 return false; [EOL]                                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                             return false; [EOL]                                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                         return false; [EOL]                                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                     return false; [EOL]                                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                                 return false; [EOL]                                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                             return false; [EOL]                                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_141() { [EOL]     if (jj_scan_token(AXIS_CHILD)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_141() { [EOL]     if (jj_scan_token(AXIS_CHILD)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_141() { [EOL]     if (jj_scan_token(AXIS_CHILD)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_129() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_140()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_141()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_142()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_143()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_144()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_145()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_146()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_147()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_148()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_149()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_150()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_151()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_152()) [EOL]                                                         return true; [EOL]                                                     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_129() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_140()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_141()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_142()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_143()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_144()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_145()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_146()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_147()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_148()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_149()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_150()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_151()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_152()) [EOL]                                                         return true; [EOL]                                                     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_129() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_140()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_141()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_142()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_143()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_144()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_145()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_146()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_147()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_148()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_149()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_150()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_151()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_152()) [EOL]                                                         return true; [EOL]                                                     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_129() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_140()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_141()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_142()) { [EOL]                 jj_scanpos = xsp; [EOL]                 if (jj_3R_143()) { [EOL]                     jj_scanpos = xsp; [EOL]                     if (jj_3R_144()) { [EOL]                         jj_scanpos = xsp; [EOL]                         if (jj_3R_145()) { [EOL]                             jj_scanpos = xsp; [EOL]                             if (jj_3R_146()) { [EOL]                                 jj_scanpos = xsp; [EOL]                                 if (jj_3R_147()) { [EOL]                                     jj_scanpos = xsp; [EOL]                                     if (jj_3R_148()) { [EOL]                                         jj_scanpos = xsp; [EOL]                                         if (jj_3R_149()) { [EOL]                                             jj_scanpos = xsp; [EOL]                                             if (jj_3R_150()) { [EOL]                                                 jj_scanpos = xsp; [EOL]                                                 if (jj_3R_151()) { [EOL]                                                     jj_scanpos = xsp; [EOL]                                                     if (jj_3R_152()) [EOL]                                                         return true; [EOL]                                                     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                         return false; [EOL]                                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                     return false; [EOL]                                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                                 return false; [EOL]                                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                             return false; [EOL]                                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                         return false; [EOL]                                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                     return false; [EOL]                             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                                 return false; [EOL]                         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                             return false; [EOL]                     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                         return false; [EOL]                 } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                     return false; [EOL]             } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_121() { [EOL]     if (jj_3R_129()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_121() { [EOL]     if (jj_3R_129()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_121() { [EOL]     if (jj_3R_129()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_112() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_121()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_122()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_112() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_121()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_122()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_112() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_121()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_122()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_101() { [EOL]     if (jj_scan_token(83)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_101() { [EOL]     if (jj_scan_token(83)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_100() { [EOL]     if (jj_scan_token(82)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_100() { [EOL]     if (jj_scan_token(82)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_113() { [EOL]     if (jj_3R_17()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_113() { [EOL]     if (jj_3R_17()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_113() { [EOL]     if (jj_3R_17()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_113() { [EOL]     if (jj_3R_17()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(80)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(81)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_99() { [EOL]     if (jj_3R_112()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_113()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_114()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_115()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_99() { [EOL]     if (jj_3R_112()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_113()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_114()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_115()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_99() { [EOL]     if (jj_3R_112()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_113()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_114()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_115()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_99() { [EOL]     if (jj_3R_112()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_113()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_114()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_115()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_99() { [EOL]     if (jj_3R_112()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_113()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_114()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_115()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_99() { [EOL]     if (jj_3R_112()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_113()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_114()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_115()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_57() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_99()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_100()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_101()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_102()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_57() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_99()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_100()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_101()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_102()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_57() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_99()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_100()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_101()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_102()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_57() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_99()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_100()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_101()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_102()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_57() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_99()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_100()) { [EOL]             jj_scanpos = xsp; [EOL]             if (jj_3R_101()) [EOL]                 return true; [EOL]             if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]                 return false; [EOL]         } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_102()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_193() { [EOL]     if (jj_3R_16()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_190() { [EOL]     if (jj_3R_16()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_188() { [EOL]     if (jj_3R_57()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_190()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_188() { [EOL]     if (jj_3R_57()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_190()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_188() { [EOL]     if (jj_3R_57()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_190()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_188() { [EOL]     if (jj_3R_57()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_190()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_191() { [EOL]     if (jj_3R_16()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_193()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_191() { [EOL]     if (jj_3R_16()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_193()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_191() { [EOL]     if (jj_3R_16()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_193()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_184() { [EOL]     if (jj_3R_116()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_189() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_191()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_192()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_189() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_191()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_192()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_189() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_191()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_192()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_189() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_191()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_192()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_182() { [EOL]     if (jj_3R_19()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_184()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_185()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_187() { [EOL]     if (jj_3R_189()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_187() { [EOL]     if (jj_3R_189()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_187() { [EOL]     if (jj_3R_189()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_186() { [EOL]     if (jj_3R_188()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_186() { [EOL]     if (jj_3R_188()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_186() { [EOL]     if (jj_3R_188()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_183() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_186()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_187()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_183() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_186()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_187()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_183() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_186()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_187()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_181() { [EOL]     if (jj_3R_183()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_181() { [EOL]     if (jj_3R_183()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_181() { [EOL]     if (jj_3R_183()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_181() { [EOL]     if (jj_3R_183()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_178() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_180()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_181()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_178() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_180()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_181()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_178() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_180()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_181()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_179() { [EOL]     if (jj_scan_token(UNION)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_178()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_179() { [EOL]     if (jj_scan_token(UNION)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_178()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_179() { [EOL]     if (jj_scan_token(UNION)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_178()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_179() { [EOL]     if (jj_scan_token(UNION)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_178()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_177() { [EOL]     if (jj_3R_178()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_179()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_177() { [EOL]     if (jj_3R_178()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_179()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_177() { [EOL]     if (jj_3R_178()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_179()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_177() { [EOL]     if (jj_3R_178()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_179()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_137() { [EOL]     if (jj_scan_token(87)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_136()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_137() { [EOL]     if (jj_scan_token(87)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_136()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_137() { [EOL]     if (jj_scan_token(87)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_136()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_137() { [EOL]     if (jj_scan_token(87)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_136()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_127() { [EOL]     if (jj_3R_136()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_137()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_127() { [EOL]     if (jj_3R_136()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_137()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_127() { [EOL]     if (jj_3R_136()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_137()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_127() { [EOL]     if (jj_3R_136()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     while (true) { [EOL]         xsp = jj_scanpos; [EOL]         if (jj_3R_137()) { [EOL]             jj_scanpos = xsp; [EOL]             break; [EOL]         } [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } [EOL]     return false; [EOL] }
final private boolean jj_3R_155() { [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_155() { [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_155() { [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_139() { [EOL]     if (jj_3R_98()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_138() { [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(79)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_138() { [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(79)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_138() { [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(79)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_138() { [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_scan_token(79)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_15()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_154() { [EOL]     if (jj_scan_token(88)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_154() { [EOL]     if (jj_scan_token(88)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_154() { [EOL]     if (jj_scan_token(88)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_133() { [EOL]     if (jj_scan_token(79)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_154()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_155()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_133() { [EOL]     if (jj_scan_token(79)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_154()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_155()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_133() { [EOL]     if (jj_scan_token(79)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_154()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_155()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_133() { [EOL]     if (jj_scan_token(79)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_154()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_155()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_133() { [EOL]     if (jj_scan_token(79)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_154()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_155()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_128() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_138()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_139()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_128() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_138()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_139()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_128() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_138()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_139()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_128() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_138()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_139()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_131() { [EOL]     if (jj_scan_token(88)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_131() { [EOL]     if (jj_scan_token(88)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_123() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_131()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_132()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_133()) [EOL]         jj_scanpos = xsp; [EOL]     else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_123() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_131()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_132()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_133()) [EOL]         jj_scanpos = xsp; [EOL]     else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_123() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_131()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_132()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_133()) [EOL]         jj_scanpos = xsp; [EOL]     else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_123() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_131()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_132()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_133()) [EOL]         jj_scanpos = xsp; [EOL]     else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_123() { [EOL]     Token xsp; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_131()) { [EOL]         jj_scanpos = xsp; [EOL]         if (jj_3R_132()) [EOL]             return true; [EOL]         if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]             return false; [EOL]     } else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     xsp = jj_scanpos; [EOL]     if (jj_3R_133()) [EOL]         jj_scanpos = xsp; [EOL]     else if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_106() { [EOL]     if (jj_3R_120()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_119()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_106() { [EOL]     if (jj_3R_120()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_119()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_106() { [EOL]     if (jj_3R_120()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_119()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_106() { [EOL]     if (jj_3R_120()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     if (jj_3R_119()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_85() { [EOL]     if (jj_scan_token(FUNCTION_NUMBER)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_85() { [EOL]     if (jj_scan_token(FUNCTION_NUMBER)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_85() { [EOL]     if (jj_scan_token(FUNCTION_NUMBER)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_83() { [EOL]     if (jj_scan_token(FUNCTION_NULL)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_83() { [EOL]     if (jj_scan_token(FUNCTION_NULL)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_83() { [EOL]     if (jj_scan_token(FUNCTION_NULL)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_120() { [EOL]     if (jj_3R_128()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_120() { [EOL]     if (jj_3R_128()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_120() { [EOL]     if (jj_3R_128()) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_79() { [EOL]     if (jj_scan_token(FUNCTION_BOOLEAN)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_79() { [EOL]     if (jj_scan_token(FUNCTION_BOOLEAN)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_79() { [EOL]     if (jj_scan_token(FUNCTION_BOOLEAN)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_72() { [EOL]     if (jj_scan_token(FUNCTION_CONTAINS)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_72() { [EOL]     if (jj_scan_token(FUNCTION_CONTAINS)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_72() { [EOL]     if (jj_scan_token(FUNCTION_CONTAINS)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_68() { [EOL]     if (jj_scan_token(FUNCTION_NAME)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_68() { [EOL]     if (jj_scan_token(FUNCTION_NAME)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_68() { [EOL]     if (jj_scan_token(FUNCTION_NAME)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_67() { [EOL]     if (jj_scan_token(FUNCTION_NAMESPACE_URI)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_67() { [EOL]     if (jj_scan_token(FUNCTION_NAMESPACE_URI)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_67() { [EOL]     if (jj_scan_token(FUNCTION_NAMESPACE_URI)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_66() { [EOL]     if (jj_scan_token(FUNCTION_LOCAL_NAME)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_66() { [EOL]     if (jj_scan_token(FUNCTION_LOCAL_NAME)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
final private boolean jj_3R_66() { [EOL]     if (jj_scan_token(FUNCTION_LOCAL_NAME)) [EOL]         return true; [EOL]     if (jj_la == 0 && jj_scanpos == jj_lastpos) [EOL]         return false; [EOL]     return false; [EOL] }
public JXPathNotFoundException(String message) { [EOL]     super(message); [EOL] }
public Object compute(EvalContext context) { [EOL]     return computeValue(context); [EOL] }
public CoreOperationOr(Expression[] args) { [EOL]     super(args); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     for (int i = 0; i < args.length; i++) { [EOL]         if (InfoSetUtil.booleanValue(args[i].computeValue(context))) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]     } [EOL]     return Boolean.FALSE; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     for (int i = 0; i < args.length; i++) { [EOL]         if (InfoSetUtil.booleanValue(args[i].computeValue(context))) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]     } [EOL]     return Boolean.FALSE; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     for (int i = 0; i < args.length; i++) { [EOL]         if (InfoSetUtil.booleanValue(args[i].computeValue(context))) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]     } [EOL]     return Boolean.FALSE; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     for (int i = 0; i < args.length; i++) { [EOL]         if (InfoSetUtil.booleanValue(args[i].computeValue(context))) { [EOL]             return Boolean.TRUE; [EOL]         } [EOL]     } [EOL]     return Boolean.FALSE; [EOL] }
protected int getPrecedence() { [EOL]     return 0; [EOL] }
public String getSymbol() { [EOL]     return "or"; [EOL] }
public JXPathInvalidSyntaxException(String message) { [EOL]     super(message); [EOL] }
public JXPathInvalidSyntaxException(String message) { [EOL]     super(message); [EOL] }
public JXPathInvalidSyntaxException(String message) { [EOL]     super(message); [EOL] }
public Object getProperty(Object object, String propertyName) { [EOL]     return ((Map) object).get(propertyName); [EOL] }
public String toString() { [EOL]     if (prefix != null) { [EOL]         return prefix + ':' + name; [EOL]     } [EOL]     return name; [EOL] }
public String toString() { [EOL]     if (prefix != null) { [EOL]         return prefix + ':' + name; [EOL]     } [EOL]     return name; [EOL] }
public int hashCode() { [EOL]     return name.hashCode(); [EOL] }
public boolean equals(Object object) { [EOL]     if (!(object instanceof QName)) { [EOL]         return false; [EOL]     } [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     QName that = (QName) object; [EOL]     if (!this.name.equals(that.name)) { [EOL]         return false; [EOL]     } [EOL]     if ((this.prefix == null && that.prefix != null) || (this.prefix != null && !this.prefix.equals(that.prefix))) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public boolean equals(Object object) { [EOL]     if (!(object instanceof QName)) { [EOL]         return false; [EOL]     } [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     QName that = (QName) object; [EOL]     if (!this.name.equals(that.name)) { [EOL]         return false; [EOL]     } [EOL]     if ((this.prefix == null && that.prefix != null) || (this.prefix != null && !this.prefix.equals(that.prefix))) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public boolean equals(Object object) { [EOL]     if (!(object instanceof QName)) { [EOL]         return false; [EOL]     } [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     QName that = (QName) object; [EOL]     if (!this.name.equals(that.name)) { [EOL]         return false; [EOL]     } [EOL]     if ((this.prefix == null && that.prefix != null) || (this.prefix != null && !this.prefix.equals(that.prefix))) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public boolean equals(Object object) { [EOL]     if (!(object instanceof QName)) { [EOL]         return false; [EOL]     } [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     QName that = (QName) object; [EOL]     if (!this.name.equals(that.name)) { [EOL]         return false; [EOL]     } [EOL]     if ((this.prefix == null && that.prefix != null) || (this.prefix != null && !this.prefix.equals(that.prefix))) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public boolean equals(Object object) { [EOL]     if (!(object instanceof QName)) { [EOL]         return false; [EOL]     } [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     QName that = (QName) object; [EOL]     if (!this.name.equals(that.name)) { [EOL]         return false; [EOL]     } [EOL]     if ((this.prefix == null && that.prefix != null) || (this.prefix != null && !this.prefix.equals(that.prefix))) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public boolean equals(Object object) { [EOL]     if (!(object instanceof QName)) { [EOL]         return false; [EOL]     } [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     QName that = (QName) object; [EOL]     if (!this.name.equals(that.name)) { [EOL]         return false; [EOL]     } [EOL]     if ((this.prefix == null && that.prefix != null) || (this.prefix != null && !this.prefix.equals(that.prefix))) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public boolean equals(Object object) { [EOL]     if (!(object instanceof QName)) { [EOL]         return false; [EOL]     } [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     QName that = (QName) object; [EOL]     if (!this.name.equals(that.name)) { [EOL]         return false; [EOL]     } [EOL]     if ((this.prefix == null && that.prefix != null) || (this.prefix != null && !this.prefix.equals(that.prefix))) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public boolean equals(Object object) { [EOL]     if (!(object instanceof QName)) { [EOL]         return false; [EOL]     } [EOL]     if (this == object) { [EOL]         return true; [EOL]     } [EOL]     QName that = (QName) object; [EOL]     if (!this.name.equals(that.name)) { [EOL]         return false; [EOL]     } [EOL]     if ((this.prefix == null && that.prefix != null) || (this.prefix != null && !this.prefix.equals(that.prefix))) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private static NodePointer doStepPredicatesPropertyOwner(EvalContext context, PropertyOwnerPointer parentPointer, Step[] steps, int currentStep) { [EOL]     Step step = steps[currentStep]; [EOL]     Expression[] predicates = step.getPredicates(); [EOL]     NodePointer childPointer = createChildPointerForStep(parentPointer, step); [EOL]     if (!childPointer.isActual()) { [EOL]         return createNullPointer(context, parentPointer, steps, currentStep); [EOL]     } [EOL]     return doPredicate(context, childPointer, steps, currentStep, predicates, 0); [EOL] }
private static NodePointer doStepPredicatesPropertyOwner(EvalContext context, PropertyOwnerPointer parentPointer, Step[] steps, int currentStep) { [EOL]     Step step = steps[currentStep]; [EOL]     Expression[] predicates = step.getPredicates(); [EOL]     NodePointer childPointer = createChildPointerForStep(parentPointer, step); [EOL]     if (!childPointer.isActual()) { [EOL]         return createNullPointer(context, parentPointer, steps, currentStep); [EOL]     } [EOL]     return doPredicate(context, childPointer, steps, currentStep, predicates, 0); [EOL] }
private static NodePointer doStepPredicatesStandard(EvalContext context, NodePointer parent, Step[] steps, int currentStep) { [EOL]     Step step = steps[currentStep]; [EOL]     Expression[] predicates = step.getPredicates(); [EOL]     int axis = step.getAxis(); [EOL]     if (axis == Compiler.AXIS_SELF) { [EOL]         return doPredicate(context, parent, steps, currentStep, predicates, 0); [EOL]     } [EOL]     Expression predicate = predicates[0]; [EOL]     if (predicates.length == 1) { [EOL]         NodeIterator it = getNodeIterator(context, parent, step); [EOL]         NodePointer pointer = null; [EOL]         if (it != null) { [EOL]             if (predicate instanceof NameAttributeTest) { [EOL]                 String key = keyFromPredicate(context, predicate); [EOL]                 for (int i = 1; it.setPosition(i); i++) { [EOL]                     NodePointer ptr = it.getNodePointer(); [EOL]                     if (isNameAttributeEqual(ptr, key)) { [EOL]                         pointer = ptr; [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } else { [EOL]                 int index = indexFromPredicate(context, predicate); [EOL]                 if (it.setPosition(index + 1)) { [EOL]                     pointer = it.getNodePointer(); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (pointer != null) { [EOL]             return doStep(context, pointer, steps, currentStep + 1); [EOL]         } [EOL]     } else { [EOL]         NodeIterator it = getNodeIterator(context, parent, step); [EOL]         if (it != null) { [EOL]             List list = new ArrayList(); [EOL]             for (int i = 1; it.setPosition(i); i++) { [EOL]                 list.add(it.getNodePointer()); [EOL]             } [EOL]             NodePointer pointer = doPredicatesStandard(context, list, steps, currentStep, predicates, 0); [EOL]             if (pointer != null) { [EOL]                 return pointer; [EOL]             } [EOL]         } [EOL]     } [EOL]     return createNullPointer(context, parent, steps, currentStep); [EOL] }
private static NodeIterator getNodeIterator(EvalContext context, NodePointer pointer, Step step) { [EOL]     if (step.getAxis() == Compiler.AXIS_CHILD) { [EOL]         NodeTest nodeTest = step.getNodeTest(); [EOL]         QName qname = ((NodeNameTest) nodeTest).getNodeName(); [EOL]         String prefix = qname.getPrefix(); [EOL]         String namespaceURI = prefix != null ? context.getJXPathContext().getNamespaceURI(prefix) : context.getJXPathContext().getDefaultNamespaceURI(); [EOL]         if (namespaceURI != null) { [EOL]             nodeTest = new NodeNameTest(qname, namespaceURI); [EOL]         } [EOL]         return pointer.childIterator(nodeTest, false, null); [EOL]     } else { [EOL]         if (!(step.getNodeTest() instanceof NodeNameTest)) { [EOL]             throw new UnsupportedOperationException("Not supported node test for attributes: " + step.getNodeTest()); [EOL]         } [EOL]         return pointer.attributeIterator(((NodeNameTest) step.getNodeTest()).getNodeName()); [EOL]     } [EOL] }
public JXPathBasicBeanInfo(Class clazz) { [EOL]     this.clazz = clazz; [EOL] }
public JXPathBasicBeanInfo(Class clazz, boolean atomic) { [EOL]     this.clazz = clazz; [EOL]     this.atomic = atomic; [EOL] }
public JXPathBasicBeanInfo(Class clazz, boolean atomic) { [EOL]     this.clazz = clazz; [EOL]     this.atomic = atomic; [EOL] }
public JXPathBasicBeanInfo(Class clazz, Class dynamicPropertyHandlerClass) { [EOL]     this.clazz = clazz; [EOL]     this.atomic = false; [EOL]     this.dynamicPropertyHandlerClass = dynamicPropertyHandlerClass; [EOL] }
public JXPathBasicBeanInfo(Class clazz, Class dynamicPropertyHandlerClass) { [EOL]     this.clazz = clazz; [EOL]     this.atomic = false; [EOL]     this.dynamicPropertyHandlerClass = dynamicPropertyHandlerClass; [EOL] }
public PropertyDescriptor[] getPropertyDescriptors() { [EOL]     if (propertyDescriptors == null) { [EOL]         try { [EOL]             BeanInfo bi = null; [EOL]             if (clazz.isInterface()) { [EOL]                 bi = Introspector.getBeanInfo(clazz); [EOL]             } else { [EOL]                 bi = Introspector.getBeanInfo(clazz, Object.class); [EOL]             } [EOL]             PropertyDescriptor[] pds = bi.getPropertyDescriptors(); [EOL]             PropertyDescriptor[] descriptors = new PropertyDescriptor[pds.length]; [EOL]             System.arraycopy(pds, 0, descriptors, 0, pds.length); [EOL]             Arrays.sort(descriptors, new Comparator() { [EOL]  [EOL]                 public int compare(Object left, Object right) { [EOL]                     return ((PropertyDescriptor) left).getName().compareTo(((PropertyDescriptor) right).getName()); [EOL]                 } [EOL]             }); [EOL]             propertyDescriptors = descriptors; [EOL]         } catch (IntrospectionException ex) { [EOL]             ex.printStackTrace(); [EOL]         } [EOL]     } [EOL]     return propertyDescriptors; [EOL] }
public PropertyDescriptor[] getPropertyDescriptors() { [EOL]     if (propertyDescriptors == null) { [EOL]         try { [EOL]             BeanInfo bi = null; [EOL]             if (clazz.isInterface()) { [EOL]                 bi = Introspector.getBeanInfo(clazz); [EOL]             } else { [EOL]                 bi = Introspector.getBeanInfo(clazz, Object.class); [EOL]             } [EOL]             PropertyDescriptor[] pds = bi.getPropertyDescriptors(); [EOL]             PropertyDescriptor[] descriptors = new PropertyDescriptor[pds.length]; [EOL]             System.arraycopy(pds, 0, descriptors, 0, pds.length); [EOL]             Arrays.sort(descriptors, new Comparator() { [EOL]  [EOL]                 public int compare(Object left, Object right) { [EOL]                     return ((PropertyDescriptor) left).getName().compareTo(((PropertyDescriptor) right).getName()); [EOL]                 } [EOL]             }); [EOL]             propertyDescriptors = descriptors; [EOL]         } catch (IntrospectionException ex) { [EOL]             ex.printStackTrace(); [EOL]         } [EOL]     } [EOL]     return propertyDescriptors; [EOL] }
public PropertyDescriptor[] getPropertyDescriptors() { [EOL]     if (propertyDescriptors == null) { [EOL]         try { [EOL]             BeanInfo bi = null; [EOL]             if (clazz.isInterface()) { [EOL]                 bi = Introspector.getBeanInfo(clazz); [EOL]             } else { [EOL]                 bi = Introspector.getBeanInfo(clazz, Object.class); [EOL]             } [EOL]             PropertyDescriptor[] pds = bi.getPropertyDescriptors(); [EOL]             PropertyDescriptor[] descriptors = new PropertyDescriptor[pds.length]; [EOL]             System.arraycopy(pds, 0, descriptors, 0, pds.length); [EOL]             Arrays.sort(descriptors, new Comparator() { [EOL]  [EOL]                 public int compare(Object left, Object right) { [EOL]                     return ((PropertyDescriptor) left).getName().compareTo(((PropertyDescriptor) right).getName()); [EOL]                 } [EOL]             }); [EOL]             propertyDescriptors = descriptors; [EOL]         } catch (IntrospectionException ex) { [EOL]             ex.printStackTrace(); [EOL]         } [EOL]     } [EOL]     return propertyDescriptors; [EOL] }
public PropertyDescriptor[] getPropertyDescriptors() { [EOL]     if (propertyDescriptors == null) { [EOL]         try { [EOL]             BeanInfo bi = null; [EOL]             if (clazz.isInterface()) { [EOL]                 bi = Introspector.getBeanInfo(clazz); [EOL]             } else { [EOL]                 bi = Introspector.getBeanInfo(clazz, Object.class); [EOL]             } [EOL]             PropertyDescriptor[] pds = bi.getPropertyDescriptors(); [EOL]             PropertyDescriptor[] descriptors = new PropertyDescriptor[pds.length]; [EOL]             System.arraycopy(pds, 0, descriptors, 0, pds.length); [EOL]             Arrays.sort(descriptors, new Comparator() { [EOL]  [EOL]                 public int compare(Object left, Object right) { [EOL]                     return ((PropertyDescriptor) left).getName().compareTo(((PropertyDescriptor) right).getName()); [EOL]                 } [EOL]             }); [EOL]             propertyDescriptors = descriptors; [EOL]         } catch (IntrospectionException ex) { [EOL]             ex.printStackTrace(); [EOL]         } [EOL]     } [EOL]     return propertyDescriptors; [EOL] }
public PropertyDescriptor getPropertyDescriptor(String propertyName) { [EOL]     if (propertyNames == null) { [EOL]         PropertyDescriptor[] pds = getPropertyDescriptors(); [EOL]         String[] names = new String[pds.length]; [EOL]         for (int i = 0; i < pds.length; i++) { [EOL]             names[i] = pds[i].getName(); [EOL]         } [EOL]         propertyNames = names; [EOL]     } [EOL]     for (int i = 0; i < propertyNames.length; i++) { [EOL]         if (propertyNames[i] == propertyName) { [EOL]             return propertyDescriptors[i]; [EOL]         } [EOL]     } [EOL]     for (int i = 0; i < propertyNames.length; i++) { [EOL]         if (propertyNames[i].equals(propertyName)) { [EOL]             return propertyDescriptors[i]; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public boolean isContextDependent() { [EOL]     if (!contextDependencyKnown) { [EOL]         contextDependent = computeContextDependent(); [EOL]         contextDependencyKnown = true; [EOL]     } [EOL]     return contextDependent; [EOL] }
public boolean isContextDependent() { [EOL]     if (!contextDependencyKnown) { [EOL]         contextDependent = computeContextDependent(); [EOL]         contextDependencyKnown = true; [EOL]     } [EOL]     return contextDependent; [EOL] }
public Iterator iterate(EvalContext context) { [EOL]     Object result = compute(context); [EOL]     if (result instanceof EvalContext) { [EOL]         return new ValueIterator((EvalContext) result); [EOL]     } [EOL]     return ValueUtils.iterate(result); [EOL] }
public Iterator iterate(EvalContext context) { [EOL]     Object result = compute(context); [EOL]     if (result instanceof EvalContext) { [EOL]         return new ValueIterator((EvalContext) result); [EOL]     } [EOL]     return ValueUtils.iterate(result); [EOL] }
public Iterator iteratePointers(EvalContext context) { [EOL]     Object result = compute(context); [EOL]     if (result == null) { [EOL]         return Collections.EMPTY_LIST.iterator(); [EOL]     } [EOL]     if (result instanceof EvalContext) { [EOL]         return (EvalContext) result; [EOL]     } [EOL]     return new PointerIterator(ValueUtils.iterate(result), new QName(null, "value"), context.getRootContext().getCurrentNodePointer().getLocale()); [EOL] }
public Iterator iteratePointers(EvalContext context) { [EOL]     Object result = compute(context); [EOL]     if (result == null) { [EOL]         return Collections.EMPTY_LIST.iterator(); [EOL]     } [EOL]     if (result instanceof EvalContext) { [EOL]         return (EvalContext) result; [EOL]     } [EOL]     return new PointerIterator(ValueUtils.iterate(result), new QName(null, "value"), context.getRootContext().getCurrentNodePointer().getLocale()); [EOL] }
public Iterator iteratePointers(EvalContext context) { [EOL]     Object result = compute(context); [EOL]     if (result == null) { [EOL]         return Collections.EMPTY_LIST.iterator(); [EOL]     } [EOL]     if (result instanceof EvalContext) { [EOL]         return (EvalContext) result; [EOL]     } [EOL]     return new PointerIterator(ValueUtils.iterate(result), new QName(null, "value"), context.getRootContext().getCurrentNodePointer().getLocale()); [EOL] }
public PointerIterator(Iterator it, QName qname, Locale locale) { [EOL]     this.iterator = it; [EOL]     this.qname = qname; [EOL]     this.locale = locale; [EOL] }
public Object next() { [EOL]     Object o = iterator.next(); [EOL]     return NodePointer.newNodePointer(qname, o, locale); [EOL] }
public Object next() { [EOL]     Object o = iterator.next(); [EOL]     return NodePointer.newNodePointer(qname, o, locale); [EOL] }
public ValueIterator(Iterator it) { [EOL]     this.iterator = it; [EOL] }
public ValueIterator(Iterator it) { [EOL]     this.iterator = it; [EOL] }
public boolean hasNext() { [EOL]     return iterator.hasNext(); [EOL] }
public Object next() { [EOL]     Object o = iterator.next(); [EOL]     if (o instanceof Pointer) { [EOL]         return ((Pointer) o).getValue(); [EOL]     } [EOL]     return o; [EOL] }
public Object next() { [EOL]     Object o = iterator.next(); [EOL]     if (o instanceof Pointer) { [EOL]         return ((Pointer) o).getValue(); [EOL]     } [EOL]     return o; [EOL] }
public NullPropertyPointer(NodePointer parent) { [EOL]     super(parent); [EOL] }
public NullPropertyPointer(NodePointer parent) { [EOL]     super(parent); [EOL] }
public QName getName() { [EOL]     return new QName(propertyName); [EOL] }
public NodePointer getValuePointer() { [EOL]     return new NullPointer(this, new QName(getPropertyName())); [EOL] }
public boolean isActual() { [EOL]     return false; [EOL] }
public boolean isContainer() { [EOL]     return true; [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     NodePointer newParent = parent.createPath(context); [EOL]     if (isAttribute()) { [EOL]         return newParent.createAttribute(context, getName()); [EOL]     } else { [EOL]         if (newParent instanceof PropertyOwnerPointer) { [EOL]             PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent; [EOL]             newParent = pop.getPropertyPointer(); [EOL]         } [EOL]         return newParent.createChild(context, getName(), getIndex()); [EOL]     } [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     NodePointer newParent = parent.createPath(context); [EOL]     if (isAttribute()) { [EOL]         return newParent.createAttribute(context, getName()); [EOL]     } else { [EOL]         if (newParent instanceof PropertyOwnerPointer) { [EOL]             PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent; [EOL]             newParent = pop.getPropertyPointer(); [EOL]         } [EOL]         return newParent.createChild(context, getName(), getIndex()); [EOL]     } [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     NodePointer newParent = parent.createPath(context); [EOL]     if (isAttribute()) { [EOL]         return newParent.createAttribute(context, getName()); [EOL]     } else { [EOL]         if (newParent instanceof PropertyOwnerPointer) { [EOL]             PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent; [EOL]             newParent = pop.getPropertyPointer(); [EOL]         } [EOL]         return newParent.createChild(context, getName(), getIndex()); [EOL]     } [EOL] }
public NodePointer createPath(JXPathContext context, Object value) { [EOL]     NodePointer newParent = parent.createPath(context); [EOL]     if (isAttribute()) { [EOL]         NodePointer pointer = newParent.createAttribute(context, getName()); [EOL]         pointer.setValue(value); [EOL]         return pointer; [EOL]     } else { [EOL]         if (newParent instanceof PropertyOwnerPointer) { [EOL]             PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent; [EOL]             newParent = pop.getPropertyPointer(); [EOL]         } [EOL]         return newParent.createChild(context, getName(), index, value); [EOL]     } [EOL] }
public NodePointer createPath(JXPathContext context, Object value) { [EOL]     NodePointer newParent = parent.createPath(context); [EOL]     if (isAttribute()) { [EOL]         NodePointer pointer = newParent.createAttribute(context, getName()); [EOL]         pointer.setValue(value); [EOL]         return pointer; [EOL]     } else { [EOL]         if (newParent instanceof PropertyOwnerPointer) { [EOL]             PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent; [EOL]             newParent = pop.getPropertyPointer(); [EOL]         } [EOL]         return newParent.createChild(context, getName(), index, value); [EOL]     } [EOL] }
public NodePointer createPath(JXPathContext context, Object value) { [EOL]     NodePointer newParent = parent.createPath(context); [EOL]     if (isAttribute()) { [EOL]         NodePointer pointer = newParent.createAttribute(context, getName()); [EOL]         pointer.setValue(value); [EOL]         return pointer; [EOL]     } else { [EOL]         if (newParent instanceof PropertyOwnerPointer) { [EOL]             PropertyOwnerPointer pop = (PropertyOwnerPointer) newParent; [EOL]             newParent = pop.getPropertyPointer(); [EOL]         } [EOL]         return newParent.createChild(context, getName(), index, value); [EOL]     } [EOL] }
public String getPropertyName() { [EOL]     return propertyName; [EOL] }
public String getPropertyName() { [EOL]     return propertyName; [EOL] }
public void setPropertyName(String propertyName) { [EOL]     this.propertyName = propertyName; [EOL] }
public void setNameAttributeValue(String attributeValue) { [EOL]     this.propertyName = attributeValue; [EOL]     byNameAttribute = true; [EOL] }
public NullPointer(NodePointer parent, QName name) { [EOL]     super(parent); [EOL]     this.name = name; [EOL] }
public NullPointer(NodePointer parent, QName name) { [EOL]     super(parent); [EOL]     this.name = name; [EOL] }
public NullPointer(NodePointer parent, QName name) { [EOL]     super(parent); [EOL]     this.name = name; [EOL] }
public Object getBaseValue() { [EOL]     return null; [EOL] }
public PropertyPointer getPropertyPointer() { [EOL]     return new NullPropertyPointer(this); [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     if (parent != null) { [EOL]         return parent.createPath(context).getValuePointer(); [EOL]     } else { [EOL]         throw new UnsupportedOperationException("Cannot create the root object: " + asPath()); [EOL]     } [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     if (parent != null) { [EOL]         return parent.createPath(context).getValuePointer(); [EOL]     } else { [EOL]         throw new UnsupportedOperationException("Cannot create the root object: " + asPath()); [EOL]     } [EOL] }
public Object computeValue(EvalContext context) { [EOL]     double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); [EOL]     double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); [EOL]     return l >= r ? Boolean.TRUE : Boolean.FALSE; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); [EOL]     double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); [EOL]     return l >= r ? Boolean.TRUE : Boolean.FALSE; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); [EOL]     double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); [EOL]     return l >= r ? Boolean.TRUE : Boolean.FALSE; [EOL] }
public static String stringValue(Object object) { [EOL]     if (object instanceof String) { [EOL]         return (String) object; [EOL]     } else if (object instanceof Number) { [EOL]         double d = ((Number) object).doubleValue(); [EOL]         long l = ((Number) object).longValue(); [EOL]         if (d == l) { [EOL]             return String.valueOf(l); [EOL]         } [EOL]         return String.valueOf(d); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? "true" : "false"; [EOL]     } else if (object == null) { [EOL]         return ""; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return stringValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return stringValue(ptr); [EOL]         } [EOL]         return ""; [EOL]     } [EOL]     return String.valueOf(object); [EOL] }
public static String stringValue(Object object) { [EOL]     if (object instanceof String) { [EOL]         return (String) object; [EOL]     } else if (object instanceof Number) { [EOL]         double d = ((Number) object).doubleValue(); [EOL]         long l = ((Number) object).longValue(); [EOL]         if (d == l) { [EOL]             return String.valueOf(l); [EOL]         } [EOL]         return String.valueOf(d); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? "true" : "false"; [EOL]     } else if (object == null) { [EOL]         return ""; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return stringValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return stringValue(ptr); [EOL]         } [EOL]         return ""; [EOL]     } [EOL]     return String.valueOf(object); [EOL] }
public static String stringValue(Object object) { [EOL]     if (object instanceof String) { [EOL]         return (String) object; [EOL]     } else if (object instanceof Number) { [EOL]         double d = ((Number) object).doubleValue(); [EOL]         long l = ((Number) object).longValue(); [EOL]         if (d == l) { [EOL]             return String.valueOf(l); [EOL]         } [EOL]         return String.valueOf(d); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? "true" : "false"; [EOL]     } else if (object == null) { [EOL]         return ""; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return stringValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return stringValue(ptr); [EOL]         } [EOL]         return ""; [EOL]     } [EOL]     return String.valueOf(object); [EOL] }
public static String stringValue(Object object) { [EOL]     if (object instanceof String) { [EOL]         return (String) object; [EOL]     } else if (object instanceof Number) { [EOL]         double d = ((Number) object).doubleValue(); [EOL]         long l = ((Number) object).longValue(); [EOL]         if (d == l) { [EOL]             return String.valueOf(l); [EOL]         } [EOL]         return String.valueOf(d); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? "true" : "false"; [EOL]     } else if (object == null) { [EOL]         return ""; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return stringValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return stringValue(ptr); [EOL]         } [EOL]         return ""; [EOL]     } [EOL]     return String.valueOf(object); [EOL] }
public static String stringValue(Object object) { [EOL]     if (object instanceof String) { [EOL]         return (String) object; [EOL]     } else if (object instanceof Number) { [EOL]         double d = ((Number) object).doubleValue(); [EOL]         long l = ((Number) object).longValue(); [EOL]         if (d == l) { [EOL]             return String.valueOf(l); [EOL]         } [EOL]         return String.valueOf(d); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? "true" : "false"; [EOL]     } else if (object == null) { [EOL]         return ""; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return stringValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return stringValue(ptr); [EOL]         } [EOL]         return ""; [EOL]     } [EOL]     return String.valueOf(object); [EOL] }
public static String stringValue(Object object) { [EOL]     if (object instanceof String) { [EOL]         return (String) object; [EOL]     } else if (object instanceof Number) { [EOL]         double d = ((Number) object).doubleValue(); [EOL]         long l = ((Number) object).longValue(); [EOL]         if (d == l) { [EOL]             return String.valueOf(l); [EOL]         } [EOL]         return String.valueOf(d); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? "true" : "false"; [EOL]     } else if (object == null) { [EOL]         return ""; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return stringValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return stringValue(ptr); [EOL]         } [EOL]         return ""; [EOL]     } [EOL]     return String.valueOf(object); [EOL] }
public static String stringValue(Object object) { [EOL]     if (object instanceof String) { [EOL]         return (String) object; [EOL]     } else if (object instanceof Number) { [EOL]         double d = ((Number) object).doubleValue(); [EOL]         long l = ((Number) object).longValue(); [EOL]         if (d == l) { [EOL]             return String.valueOf(l); [EOL]         } [EOL]         return String.valueOf(d); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? "true" : "false"; [EOL]     } else if (object == null) { [EOL]         return ""; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return stringValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return stringValue(ptr); [EOL]         } [EOL]         return ""; [EOL]     } [EOL]     return String.valueOf(object); [EOL] }
public static String stringValue(Object object) { [EOL]     if (object instanceof String) { [EOL]         return (String) object; [EOL]     } else if (object instanceof Number) { [EOL]         double d = ((Number) object).doubleValue(); [EOL]         long l = ((Number) object).longValue(); [EOL]         if (d == l) { [EOL]             return String.valueOf(l); [EOL]         } [EOL]         return String.valueOf(d); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? "true" : "false"; [EOL]     } else if (object == null) { [EOL]         return ""; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return stringValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return stringValue(ptr); [EOL]         } [EOL]         return ""; [EOL]     } [EOL]     return String.valueOf(object); [EOL] }
public static String stringValue(Object object) { [EOL]     if (object instanceof String) { [EOL]         return (String) object; [EOL]     } else if (object instanceof Number) { [EOL]         double d = ((Number) object).doubleValue(); [EOL]         long l = ((Number) object).longValue(); [EOL]         if (d == l) { [EOL]             return String.valueOf(l); [EOL]         } [EOL]         return String.valueOf(d); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? "true" : "false"; [EOL]     } else if (object == null) { [EOL]         return ""; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return stringValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return stringValue(ptr); [EOL]         } [EOL]         return ""; [EOL]     } [EOL]     return String.valueOf(object); [EOL] }
public static String stringValue(Object object) { [EOL]     if (object instanceof String) { [EOL]         return (String) object; [EOL]     } else if (object instanceof Number) { [EOL]         double d = ((Number) object).doubleValue(); [EOL]         long l = ((Number) object).longValue(); [EOL]         if (d == l) { [EOL]             return String.valueOf(l); [EOL]         } [EOL]         return String.valueOf(d); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? "true" : "false"; [EOL]     } else if (object == null) { [EOL]         return ""; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return stringValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return stringValue(ptr); [EOL]         } [EOL]         return ""; [EOL]     } [EOL]     return String.valueOf(object); [EOL] }
public static Number number(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return (Number) object; [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? ONE : ZERO; [EOL]     } else if (object instanceof String) { [EOL]         Double value; [EOL]         try { [EOL]             value = new Double((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = NOT_A_NUMBER; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return number(ptr); [EOL]         } [EOL]         return NOT_A_NUMBER; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return number(((NodePointer) object).getValue()); [EOL]     } [EOL]     return number(stringValue(object)); [EOL] }
public static Number number(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return (Number) object; [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? ONE : ZERO; [EOL]     } else if (object instanceof String) { [EOL]         Double value; [EOL]         try { [EOL]             value = new Double((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = NOT_A_NUMBER; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return number(ptr); [EOL]         } [EOL]         return NOT_A_NUMBER; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return number(((NodePointer) object).getValue()); [EOL]     } [EOL]     return number(stringValue(object)); [EOL] }
public static Number number(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return (Number) object; [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? ONE : ZERO; [EOL]     } else if (object instanceof String) { [EOL]         Double value; [EOL]         try { [EOL]             value = new Double((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = NOT_A_NUMBER; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return number(ptr); [EOL]         } [EOL]         return NOT_A_NUMBER; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return number(((NodePointer) object).getValue()); [EOL]     } [EOL]     return number(stringValue(object)); [EOL] }
public static Number number(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return (Number) object; [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? ONE : ZERO; [EOL]     } else if (object instanceof String) { [EOL]         Double value; [EOL]         try { [EOL]             value = new Double((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = NOT_A_NUMBER; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return number(ptr); [EOL]         } [EOL]         return NOT_A_NUMBER; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return number(((NodePointer) object).getValue()); [EOL]     } [EOL]     return number(stringValue(object)); [EOL] }
public static Number number(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return (Number) object; [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? ONE : ZERO; [EOL]     } else if (object instanceof String) { [EOL]         Double value; [EOL]         try { [EOL]             value = new Double((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = NOT_A_NUMBER; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return number(ptr); [EOL]         } [EOL]         return NOT_A_NUMBER; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return number(((NodePointer) object).getValue()); [EOL]     } [EOL]     return number(stringValue(object)); [EOL] }
public static Number number(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return (Number) object; [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? ONE : ZERO; [EOL]     } else if (object instanceof String) { [EOL]         Double value; [EOL]         try { [EOL]             value = new Double((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = NOT_A_NUMBER; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return number(ptr); [EOL]         } [EOL]         return NOT_A_NUMBER; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return number(((NodePointer) object).getValue()); [EOL]     } [EOL]     return number(stringValue(object)); [EOL] }
public static Number number(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return (Number) object; [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? ONE : ZERO; [EOL]     } else if (object instanceof String) { [EOL]         Double value; [EOL]         try { [EOL]             value = new Double((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = NOT_A_NUMBER; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return number(ptr); [EOL]         } [EOL]         return NOT_A_NUMBER; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return number(((NodePointer) object).getValue()); [EOL]     } [EOL]     return number(stringValue(object)); [EOL] }
public static Number number(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return (Number) object; [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? ONE : ZERO; [EOL]     } else if (object instanceof String) { [EOL]         Double value; [EOL]         try { [EOL]             value = new Double((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = NOT_A_NUMBER; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return number(ptr); [EOL]         } [EOL]         return NOT_A_NUMBER; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return number(((NodePointer) object).getValue()); [EOL]     } [EOL]     return number(stringValue(object)); [EOL] }
public static Number number(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return (Number) object; [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? ONE : ZERO; [EOL]     } else if (object instanceof String) { [EOL]         Double value; [EOL]         try { [EOL]             value = new Double((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = NOT_A_NUMBER; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return number(ptr); [EOL]         } [EOL]         return NOT_A_NUMBER; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return number(((NodePointer) object).getValue()); [EOL]     } [EOL]     return number(stringValue(object)); [EOL] }
public static double doubleValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return ((Number) object).doubleValue(); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? 0.0 : 1.0; [EOL]     } else if (object instanceof String) { [EOL]         if (object.equals("")) { [EOL]             return 0.0; [EOL]         } [EOL]         double value; [EOL]         try { [EOL]             value = Double.parseDouble((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = Double.NaN; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return doubleValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return doubleValue(ptr); [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     return doubleValue(stringValue(object)); [EOL] }
public static double doubleValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return ((Number) object).doubleValue(); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? 0.0 : 1.0; [EOL]     } else if (object instanceof String) { [EOL]         if (object.equals("")) { [EOL]             return 0.0; [EOL]         } [EOL]         double value; [EOL]         try { [EOL]             value = Double.parseDouble((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = Double.NaN; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return doubleValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return doubleValue(ptr); [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     return doubleValue(stringValue(object)); [EOL] }
public static double doubleValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return ((Number) object).doubleValue(); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? 0.0 : 1.0; [EOL]     } else if (object instanceof String) { [EOL]         if (object.equals("")) { [EOL]             return 0.0; [EOL]         } [EOL]         double value; [EOL]         try { [EOL]             value = Double.parseDouble((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = Double.NaN; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return doubleValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return doubleValue(ptr); [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     return doubleValue(stringValue(object)); [EOL] }
public static double doubleValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return ((Number) object).doubleValue(); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? 0.0 : 1.0; [EOL]     } else if (object instanceof String) { [EOL]         if (object.equals("")) { [EOL]             return 0.0; [EOL]         } [EOL]         double value; [EOL]         try { [EOL]             value = Double.parseDouble((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = Double.NaN; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return doubleValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return doubleValue(ptr); [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     return doubleValue(stringValue(object)); [EOL] }
public static double doubleValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return ((Number) object).doubleValue(); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? 0.0 : 1.0; [EOL]     } else if (object instanceof String) { [EOL]         if (object.equals("")) { [EOL]             return 0.0; [EOL]         } [EOL]         double value; [EOL]         try { [EOL]             value = Double.parseDouble((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = Double.NaN; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return doubleValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return doubleValue(ptr); [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     return doubleValue(stringValue(object)); [EOL] }
public static double doubleValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return ((Number) object).doubleValue(); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? 0.0 : 1.0; [EOL]     } else if (object instanceof String) { [EOL]         if (object.equals("")) { [EOL]             return 0.0; [EOL]         } [EOL]         double value; [EOL]         try { [EOL]             value = Double.parseDouble((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = Double.NaN; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return doubleValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return doubleValue(ptr); [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     return doubleValue(stringValue(object)); [EOL] }
public static double doubleValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return ((Number) object).doubleValue(); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? 0.0 : 1.0; [EOL]     } else if (object instanceof String) { [EOL]         if (object.equals("")) { [EOL]             return 0.0; [EOL]         } [EOL]         double value; [EOL]         try { [EOL]             value = Double.parseDouble((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = Double.NaN; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return doubleValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return doubleValue(ptr); [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     return doubleValue(stringValue(object)); [EOL] }
public static double doubleValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return ((Number) object).doubleValue(); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? 0.0 : 1.0; [EOL]     } else if (object instanceof String) { [EOL]         if (object.equals("")) { [EOL]             return 0.0; [EOL]         } [EOL]         double value; [EOL]         try { [EOL]             value = Double.parseDouble((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = Double.NaN; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return doubleValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return doubleValue(ptr); [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     return doubleValue(stringValue(object)); [EOL] }
public static double doubleValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return ((Number) object).doubleValue(); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? 0.0 : 1.0; [EOL]     } else if (object instanceof String) { [EOL]         if (object.equals("")) { [EOL]             return 0.0; [EOL]         } [EOL]         double value; [EOL]         try { [EOL]             value = Double.parseDouble((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = Double.NaN; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return doubleValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return doubleValue(ptr); [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     return doubleValue(stringValue(object)); [EOL] }
public static double doubleValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         return ((Number) object).doubleValue(); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue() ? 0.0 : 1.0; [EOL]     } else if (object instanceof String) { [EOL]         if (object.equals("")) { [EOL]             return 0.0; [EOL]         } [EOL]         double value; [EOL]         try { [EOL]             value = Double.parseDouble((String) object); [EOL]         } catch (NumberFormatException ex) { [EOL]             value = Double.NaN; [EOL]         } [EOL]         return value; [EOL]     } else if (object instanceof NodePointer) { [EOL]         return doubleValue(((NodePointer) object).getValue()); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr != null) { [EOL]             return doubleValue(ptr); [EOL]         } [EOL]         return Double.NaN; [EOL]     } [EOL]     return doubleValue(stringValue(object)); [EOL] }
public static boolean booleanValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         double value = ((Number) object).doubleValue(); [EOL]         return value != 0 && value != -0 && !Double.isNaN(value); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue(); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr == null) { [EOL]             return false; [EOL]         } [EOL]         return booleanValue(ptr); [EOL]     } else if (object instanceof String) { [EOL]         return ((String) object).length() != 0; [EOL]     } else if (object instanceof NodePointer) { [EOL]         NodePointer pointer = (NodePointer) object; [EOL]         if (pointer instanceof VariablePointer) { [EOL]             return booleanValue(pointer.getNode()); [EOL]         } [EOL]         pointer = pointer.getValuePointer(); [EOL]         return pointer.isActual(); [EOL]     } else if (object == null) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean booleanValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         double value = ((Number) object).doubleValue(); [EOL]         return value != 0 && value != -0 && !Double.isNaN(value); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue(); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr == null) { [EOL]             return false; [EOL]         } [EOL]         return booleanValue(ptr); [EOL]     } else if (object instanceof String) { [EOL]         return ((String) object).length() != 0; [EOL]     } else if (object instanceof NodePointer) { [EOL]         NodePointer pointer = (NodePointer) object; [EOL]         if (pointer instanceof VariablePointer) { [EOL]             return booleanValue(pointer.getNode()); [EOL]         } [EOL]         pointer = pointer.getValuePointer(); [EOL]         return pointer.isActual(); [EOL]     } else if (object == null) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean booleanValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         double value = ((Number) object).doubleValue(); [EOL]         return value != 0 && value != -0 && !Double.isNaN(value); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue(); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr == null) { [EOL]             return false; [EOL]         } [EOL]         return booleanValue(ptr); [EOL]     } else if (object instanceof String) { [EOL]         return ((String) object).length() != 0; [EOL]     } else if (object instanceof NodePointer) { [EOL]         NodePointer pointer = (NodePointer) object; [EOL]         if (pointer instanceof VariablePointer) { [EOL]             return booleanValue(pointer.getNode()); [EOL]         } [EOL]         pointer = pointer.getValuePointer(); [EOL]         return pointer.isActual(); [EOL]     } else if (object == null) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean booleanValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         double value = ((Number) object).doubleValue(); [EOL]         return value != 0 && value != -0 && !Double.isNaN(value); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue(); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr == null) { [EOL]             return false; [EOL]         } [EOL]         return booleanValue(ptr); [EOL]     } else if (object instanceof String) { [EOL]         return ((String) object).length() != 0; [EOL]     } else if (object instanceof NodePointer) { [EOL]         NodePointer pointer = (NodePointer) object; [EOL]         if (pointer instanceof VariablePointer) { [EOL]             return booleanValue(pointer.getNode()); [EOL]         } [EOL]         pointer = pointer.getValuePointer(); [EOL]         return pointer.isActual(); [EOL]     } else if (object == null) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean booleanValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         double value = ((Number) object).doubleValue(); [EOL]         return value != 0 && value != -0 && !Double.isNaN(value); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue(); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr == null) { [EOL]             return false; [EOL]         } [EOL]         return booleanValue(ptr); [EOL]     } else if (object instanceof String) { [EOL]         return ((String) object).length() != 0; [EOL]     } else if (object instanceof NodePointer) { [EOL]         NodePointer pointer = (NodePointer) object; [EOL]         if (pointer instanceof VariablePointer) { [EOL]             return booleanValue(pointer.getNode()); [EOL]         } [EOL]         pointer = pointer.getValuePointer(); [EOL]         return pointer.isActual(); [EOL]     } else if (object == null) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean booleanValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         double value = ((Number) object).doubleValue(); [EOL]         return value != 0 && value != -0 && !Double.isNaN(value); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue(); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr == null) { [EOL]             return false; [EOL]         } [EOL]         return booleanValue(ptr); [EOL]     } else if (object instanceof String) { [EOL]         return ((String) object).length() != 0; [EOL]     } else if (object instanceof NodePointer) { [EOL]         NodePointer pointer = (NodePointer) object; [EOL]         if (pointer instanceof VariablePointer) { [EOL]             return booleanValue(pointer.getNode()); [EOL]         } [EOL]         pointer = pointer.getValuePointer(); [EOL]         return pointer.isActual(); [EOL]     } else if (object == null) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public static boolean booleanValue(Object object) { [EOL]     if (object instanceof Number) { [EOL]         double value = ((Number) object).doubleValue(); [EOL]         return value != 0 && value != -0 && !Double.isNaN(value); [EOL]     } else if (object instanceof Boolean) { [EOL]         return ((Boolean) object).booleanValue(); [EOL]     } else if (object instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) object; [EOL]         Pointer ptr = ctx.getSingleNodePointer(); [EOL]         if (ptr == null) { [EOL]             return false; [EOL]         } [EOL]         return booleanValue(ptr); [EOL]     } else if (object instanceof String) { [EOL]         return ((String) object).length() != 0; [EOL]     } else if (object instanceof NodePointer) { [EOL]         NodePointer pointer = (NodePointer) object; [EOL]         if (pointer instanceof VariablePointer) { [EOL]             return booleanValue(pointer.getNode()); [EOL]         } [EOL]         pointer = pointer.getValuePointer(); [EOL]         return pointer.isActual(); [EOL]     } else if (object == null) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public PropertyPointer getPropertyPointer() { [EOL]     return new BeanPropertyPointer(this, beanInfo); [EOL] }
public QName getName() { [EOL]     return name; [EOL] }
public Object getBaseValue() { [EOL]     return bean; [EOL] }
public int hashCode() { [EOL]     return name == null ? 0 : name.hashCode(); [EOL] }
public int hashCode() { [EOL]     return name == null ? 0 : name.hashCode(); [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof BeanPointer)) { [EOL]         return false; [EOL]     } [EOL]     BeanPointer other = (BeanPointer) object; [EOL]     if (parent != other.parent) { [EOL]         if (parent == null || !parent.equals(other.parent)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if ((name == null && other.name != null) || (name != null && !name.equals(other.name))) { [EOL]         return false; [EOL]     } [EOL]     int iThis = (index == WHOLE_COLLECTION ? 0 : index); [EOL]     int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index); [EOL]     if (iThis != iOther) { [EOL]         return false; [EOL]     } [EOL]     if (bean instanceof Number || bean instanceof String || bean instanceof Boolean) { [EOL]         return bean.equals(other.bean); [EOL]     } [EOL]     return bean == other.bean; [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof BeanPointer)) { [EOL]         return false; [EOL]     } [EOL]     BeanPointer other = (BeanPointer) object; [EOL]     if (parent != other.parent) { [EOL]         if (parent == null || !parent.equals(other.parent)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if ((name == null && other.name != null) || (name != null && !name.equals(other.name))) { [EOL]         return false; [EOL]     } [EOL]     int iThis = (index == WHOLE_COLLECTION ? 0 : index); [EOL]     int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index); [EOL]     if (iThis != iOther) { [EOL]         return false; [EOL]     } [EOL]     if (bean instanceof Number || bean instanceof String || bean instanceof Boolean) { [EOL]         return bean.equals(other.bean); [EOL]     } [EOL]     return bean == other.bean; [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } else if (bean == null) { [EOL]         return "null()"; [EOL]     } else if (bean instanceof Number) { [EOL]         String string = bean.toString(); [EOL]         if (string.endsWith(".0")) { [EOL]             string = string.substring(0, string.length() - 2); [EOL]         } [EOL]         return string; [EOL]     } else if (bean instanceof Boolean) { [EOL]         return ((Boolean) bean).booleanValue() ? "true()" : "false()"; [EOL]     } else if (bean instanceof String) { [EOL]         return "'" + bean + "'"; [EOL]     } [EOL]     return "/"; [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } else if (bean == null) { [EOL]         return "null()"; [EOL]     } else if (bean instanceof Number) { [EOL]         String string = bean.toString(); [EOL]         if (string.endsWith(".0")) { [EOL]             string = string.substring(0, string.length() - 2); [EOL]         } [EOL]         return string; [EOL]     } else if (bean instanceof Boolean) { [EOL]         return ((Boolean) bean).booleanValue() ? "true()" : "false()"; [EOL]     } else if (bean instanceof String) { [EOL]         return "'" + bean + "'"; [EOL]     } [EOL]     return "/"; [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } else if (bean == null) { [EOL]         return "null()"; [EOL]     } else if (bean instanceof Number) { [EOL]         String string = bean.toString(); [EOL]         if (string.endsWith(".0")) { [EOL]             string = string.substring(0, string.length() - 2); [EOL]         } [EOL]         return string; [EOL]     } else if (bean instanceof Boolean) { [EOL]         return ((Boolean) bean).booleanValue() ? "true()" : "false()"; [EOL]     } else if (bean instanceof String) { [EOL]         return "'" + bean + "'"; [EOL]     } [EOL]     return "/"; [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } else if (bean == null) { [EOL]         return "null()"; [EOL]     } else if (bean instanceof Number) { [EOL]         String string = bean.toString(); [EOL]         if (string.endsWith(".0")) { [EOL]             string = string.substring(0, string.length() - 2); [EOL]         } [EOL]         return string; [EOL]     } else if (bean instanceof Boolean) { [EOL]         return ((Boolean) bean).booleanValue() ? "true()" : "false()"; [EOL]     } else if (bean instanceof String) { [EOL]         return "'" + bean + "'"; [EOL]     } [EOL]     return "/"; [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } else if (bean == null) { [EOL]         return "null()"; [EOL]     } else if (bean instanceof Number) { [EOL]         String string = bean.toString(); [EOL]         if (string.endsWith(".0")) { [EOL]             string = string.substring(0, string.length() - 2); [EOL]         } [EOL]         return string; [EOL]     } else if (bean instanceof Boolean) { [EOL]         return ((Boolean) bean).booleanValue() ? "true()" : "false()"; [EOL]     } else if (bean instanceof String) { [EOL]         return "'" + bean + "'"; [EOL]     } [EOL]     return "/"; [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } else if (bean == null) { [EOL]         return "null()"; [EOL]     } else if (bean instanceof Number) { [EOL]         String string = bean.toString(); [EOL]         if (string.endsWith(".0")) { [EOL]             string = string.substring(0, string.length() - 2); [EOL]         } [EOL]         return string; [EOL]     } else if (bean instanceof Boolean) { [EOL]         return ((Boolean) bean).booleanValue() ? "true()" : "false()"; [EOL]     } else if (bean instanceof String) { [EOL]         return "'" + bean + "'"; [EOL]     } [EOL]     return "/"; [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } else if (bean == null) { [EOL]         return "null()"; [EOL]     } else if (bean instanceof Number) { [EOL]         String string = bean.toString(); [EOL]         if (string.endsWith(".0")) { [EOL]             string = string.substring(0, string.length() - 2); [EOL]         } [EOL]         return string; [EOL]     } else if (bean instanceof Boolean) { [EOL]         return ((Boolean) bean).booleanValue() ? "true()" : "false()"; [EOL]     } else if (bean instanceof String) { [EOL]         return "'" + bean + "'"; [EOL]     } [EOL]     return "/"; [EOL] }
public String asPath() { [EOL]     if (parent != null) { [EOL]         return super.asPath(); [EOL]     } else if (bean == null) { [EOL]         return "null()"; [EOL]     } else if (bean instanceof Number) { [EOL]         String string = bean.toString(); [EOL]         if (string.endsWith(".0")) { [EOL]             string = string.substring(0, string.length() - 2); [EOL]         } [EOL]         return string; [EOL]     } else if (bean instanceof Boolean) { [EOL]         return ((Boolean) bean).booleanValue() ? "true()" : "false()"; [EOL]     } else if (bean instanceof String) { [EOL]         return "'" + bean + "'"; [EOL]     } [EOL]     return "/"; [EOL] }
public NodePointer createPath(JXPathContext context, Object value) { [EOL]     return parent.createChild(context, null, index, value); [EOL] }
public NodePointer createPath(JXPathContext context, Object value) { [EOL]     return parent.createChild(context, null, index, value); [EOL] }
public CoreOperationSubtract(Expression arg1, Expression arg2) { [EOL]     super(new Expression[] { arg1, arg2 }); [EOL] }
public CoreOperationSubtract(Expression arg1, Expression arg2) { [EOL]     super(new Expression[] { arg1, arg2 }); [EOL] }
public CoreOperationSubtract(Expression arg1, Expression arg2) { [EOL]     super(new Expression[] { arg1, arg2 }); [EOL] }
public CoreOperationSubtract(Expression arg1, Expression arg2) { [EOL]     super(new Expression[] { arg1, arg2 }); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); [EOL]     double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); [EOL]     return new Double(l - r); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); [EOL]     double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); [EOL]     return new Double(l - r); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); [EOL]     double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); [EOL]     return new Double(l - r); [EOL] }
protected int getPrecedence() { [EOL]     return 4; [EOL] }
protected boolean isSymmetric() { [EOL]     return false; [EOL] }
public String getSymbol() { [EOL]     return "-"; [EOL] }
public DynamicPropertyPointer(NodePointer parent, DynamicPropertyHandler handler) { [EOL]     super(parent); [EOL]     this.handler = handler; [EOL] }
public DynamicPropertyPointer(NodePointer parent, DynamicPropertyHandler handler) { [EOL]     super(parent); [EOL]     this.handler = handler; [EOL] }
public DynamicPropertyPointer(NodePointer parent, DynamicPropertyHandler handler) { [EOL]     super(parent); [EOL]     this.handler = handler; [EOL] }
public String getPropertyName() { [EOL]     if (name == null) { [EOL]         String[] names = getPropertyNames(); [EOL]         if (propertyIndex >= 0 && propertyIndex < names.length) { [EOL]             name = names[propertyIndex]; [EOL]         } else { [EOL]             name = "*"; [EOL]         } [EOL]     } [EOL]     return name; [EOL] }
public String getPropertyName() { [EOL]     if (name == null) { [EOL]         String[] names = getPropertyNames(); [EOL]         if (propertyIndex >= 0 && propertyIndex < names.length) { [EOL]             name = names[propertyIndex]; [EOL]         } else { [EOL]             name = "*"; [EOL]         } [EOL]     } [EOL]     return name; [EOL] }
public String getPropertyName() { [EOL]     if (name == null) { [EOL]         String[] names = getPropertyNames(); [EOL]         if (propertyIndex >= 0 && propertyIndex < names.length) { [EOL]             name = names[propertyIndex]; [EOL]         } else { [EOL]             name = "*"; [EOL]         } [EOL]     } [EOL]     return name; [EOL] }
public void setPropertyName(String propertyName) { [EOL]     setPropertyIndex(UNSPECIFIED_PROPERTY); [EOL]     this.name = propertyName; [EOL]     requiredPropertyName = propertyName; [EOL]     if (names != null && Arrays.binarySearch(names, propertyName) < 0) { [EOL]         names = null; [EOL]     } [EOL] }
public void setPropertyName(String propertyName) { [EOL]     setPropertyIndex(UNSPECIFIED_PROPERTY); [EOL]     this.name = propertyName; [EOL]     requiredPropertyName = propertyName; [EOL]     if (names != null && Arrays.binarySearch(names, propertyName) < 0) { [EOL]         names = null; [EOL]     } [EOL] }
public int getPropertyIndex() { [EOL]     if (propertyIndex == UNSPECIFIED_PROPERTY) { [EOL]         String[] names = getPropertyNames(); [EOL]         for (int i = 0; i < names.length; i++) { [EOL]             if (names[i].equals(name)) { [EOL]                 setPropertyIndex(i); [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return super.getPropertyIndex(); [EOL] }
public void setPropertyIndex(int index) { [EOL]     if (propertyIndex != index) { [EOL]         super.setPropertyIndex(index); [EOL]         name = null; [EOL]     } [EOL] }
public void setPropertyIndex(int index) { [EOL]     if (propertyIndex != index) { [EOL]         super.setPropertyIndex(index); [EOL]         name = null; [EOL]     } [EOL] }
public Object getBaseValue() { [EOL]     return handler.getProperty(getBean(), getPropertyName()); [EOL] }
public Object getImmediateNode() { [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(handler.getProperty(getBean(), getPropertyName())); [EOL]     } else { [EOL]         value = ValueUtils.getValue(handler.getProperty(getBean(), getPropertyName()), index); [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(handler.getProperty(getBean(), getPropertyName())); [EOL]     } else { [EOL]         value = ValueUtils.getValue(handler.getProperty(getBean(), getPropertyName()), index); [EOL]     } [EOL]     return value; [EOL] }
protected boolean isActualProperty() { [EOL]     return true; [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     Object collection = getBaseValue(); [EOL]     if (collection == null) { [EOL]         AbstractFactory factory = getAbstractFactory(context); [EOL]         boolean success = factory.createObject(context, this, getBean(), getPropertyName(), 0); [EOL]         if (!success) { [EOL]             throw new JXPathAbstractFactoryException("Factory could not create an object for path: " + asPath()); [EOL]         } [EOL]         collection = getBaseValue(); [EOL]     } [EOL]     if (index != WHOLE_COLLECTION) { [EOL]         if (index < 0) { [EOL]             throw new JXPathInvalidAccessException("Index is less than 1: " + asPath()); [EOL]         } [EOL]         if (index >= getLength()) { [EOL]             collection = ValueUtils.expandCollection(collection, index + 1); [EOL]             handler.setProperty(getBean(), getPropertyName(), collection); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     Object collection = getBaseValue(); [EOL]     if (collection == null) { [EOL]         AbstractFactory factory = getAbstractFactory(context); [EOL]         boolean success = factory.createObject(context, this, getBean(), getPropertyName(), 0); [EOL]         if (!success) { [EOL]             throw new JXPathAbstractFactoryException("Factory could not create an object for path: " + asPath()); [EOL]         } [EOL]         collection = getBaseValue(); [EOL]     } [EOL]     if (index != WHOLE_COLLECTION) { [EOL]         if (index < 0) { [EOL]             throw new JXPathInvalidAccessException("Index is less than 1: " + asPath()); [EOL]         } [EOL]         if (index >= getLength()) { [EOL]             collection = ValueUtils.expandCollection(collection, index + 1); [EOL]             handler.setProperty(getBean(), getPropertyName(), collection); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     Object collection = getBaseValue(); [EOL]     if (collection == null) { [EOL]         AbstractFactory factory = getAbstractFactory(context); [EOL]         boolean success = factory.createObject(context, this, getBean(), getPropertyName(), 0); [EOL]         if (!success) { [EOL]             throw new JXPathAbstractFactoryException("Factory could not create an object for path: " + asPath()); [EOL]         } [EOL]         collection = getBaseValue(); [EOL]     } [EOL]     if (index != WHOLE_COLLECTION) { [EOL]         if (index < 0) { [EOL]             throw new JXPathInvalidAccessException("Index is less than 1: " + asPath()); [EOL]         } [EOL]         if (index >= getLength()) { [EOL]             collection = ValueUtils.expandCollection(collection, index + 1); [EOL]             handler.setProperty(getBean(), getPropertyName(), collection); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     Object collection = getBaseValue(); [EOL]     if (collection == null) { [EOL]         AbstractFactory factory = getAbstractFactory(context); [EOL]         boolean success = factory.createObject(context, this, getBean(), getPropertyName(), 0); [EOL]         if (!success) { [EOL]             throw new JXPathAbstractFactoryException("Factory could not create an object for path: " + asPath()); [EOL]         } [EOL]         collection = getBaseValue(); [EOL]     } [EOL]     if (index != WHOLE_COLLECTION) { [EOL]         if (index < 0) { [EOL]             throw new JXPathInvalidAccessException("Index is less than 1: " + asPath()); [EOL]         } [EOL]         if (index >= getLength()) { [EOL]             collection = ValueUtils.expandCollection(collection, index + 1); [EOL]             handler.setProperty(getBean(), getPropertyName(), collection); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     Object collection = getBaseValue(); [EOL]     if (collection == null) { [EOL]         AbstractFactory factory = getAbstractFactory(context); [EOL]         boolean success = factory.createObject(context, this, getBean(), getPropertyName(), 0); [EOL]         if (!success) { [EOL]             throw new JXPathAbstractFactoryException("Factory could not create an object for path: " + asPath()); [EOL]         } [EOL]         collection = getBaseValue(); [EOL]     } [EOL]     if (index != WHOLE_COLLECTION) { [EOL]         if (index < 0) { [EOL]             throw new JXPathInvalidAccessException("Index is less than 1: " + asPath()); [EOL]         } [EOL]         if (index >= getLength()) { [EOL]             collection = ValueUtils.expandCollection(collection, index + 1); [EOL]             handler.setProperty(getBean(), getPropertyName(), collection); [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
public void remove() { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         removeKey(); [EOL]     } else if (isCollection()) { [EOL]         Object collection = ValueUtils.remove(getBaseValue(), index); [EOL]         handler.setProperty(getBean(), getPropertyName(), collection); [EOL]     } else if (index == 0) { [EOL]         removeKey(); [EOL]     } [EOL] }
public void remove() { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         removeKey(); [EOL]     } else if (isCollection()) { [EOL]         Object collection = ValueUtils.remove(getBaseValue(), index); [EOL]         handler.setProperty(getBean(), getPropertyName(), collection); [EOL]     } else if (index == 0) { [EOL]         removeKey(); [EOL]     } [EOL] }
public void remove() { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         removeKey(); [EOL]     } else if (isCollection()) { [EOL]         Object collection = ValueUtils.remove(getBaseValue(), index); [EOL]         handler.setProperty(getBean(), getPropertyName(), collection); [EOL]     } else if (index == 0) { [EOL]         removeKey(); [EOL]     } [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     buffer.append(getImmediateParentPointer().asPath()); [EOL]     if (buffer.length() == 0) { [EOL]         buffer.append("/."); [EOL]     } else if (buffer.charAt(buffer.length() - 1) == '/') { [EOL]         buffer.append('.'); [EOL]     } [EOL]     buffer.append("[@name='"); [EOL]     buffer.append(escape(getPropertyName())); [EOL]     buffer.append("']"); [EOL]     if (index != WHOLE_COLLECTION && isCollection()) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     buffer.append(getImmediateParentPointer().asPath()); [EOL]     if (buffer.length() == 0) { [EOL]         buffer.append("/."); [EOL]     } else if (buffer.charAt(buffer.length() - 1) == '/') { [EOL]         buffer.append('.'); [EOL]     } [EOL]     buffer.append("[@name='"); [EOL]     buffer.append(escape(getPropertyName())); [EOL]     buffer.append("']"); [EOL]     if (index != WHOLE_COLLECTION && isCollection()) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     buffer.append(getImmediateParentPointer().asPath()); [EOL]     if (buffer.length() == 0) { [EOL]         buffer.append("/."); [EOL]     } else if (buffer.charAt(buffer.length() - 1) == '/') { [EOL]         buffer.append('.'); [EOL]     } [EOL]     buffer.append("[@name='"); [EOL]     buffer.append(escape(getPropertyName())); [EOL]     buffer.append("']"); [EOL]     if (index != WHOLE_COLLECTION && isCollection()) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     buffer.append(getImmediateParentPointer().asPath()); [EOL]     if (buffer.length() == 0) { [EOL]         buffer.append("/."); [EOL]     } else if (buffer.charAt(buffer.length() - 1) == '/') { [EOL]         buffer.append('.'); [EOL]     } [EOL]     buffer.append("[@name='"); [EOL]     buffer.append(escape(getPropertyName())); [EOL]     buffer.append("']"); [EOL]     if (index != WHOLE_COLLECTION && isCollection()) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
private String escape(String string) { [EOL]     int index = string.indexOf('\''); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "&apos;" + string.substring(index + 1); [EOL]         index = string.indexOf('\''); [EOL]     } [EOL]     index = string.indexOf('\"'); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "&quot;" + string.substring(index + 1); [EOL]         index = string.indexOf('\"'); [EOL]     } [EOL]     return string; [EOL] }
private String escape(String string) { [EOL]     int index = string.indexOf('\''); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "&apos;" + string.substring(index + 1); [EOL]         index = string.indexOf('\''); [EOL]     } [EOL]     index = string.indexOf('\"'); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "&quot;" + string.substring(index + 1); [EOL]         index = string.indexOf('\"'); [EOL]     } [EOL]     return string; [EOL] }
private String escape(String string) { [EOL]     int index = string.indexOf('\''); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "&apos;" + string.substring(index + 1); [EOL]         index = string.indexOf('\''); [EOL]     } [EOL]     index = string.indexOf('\"'); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "&quot;" + string.substring(index + 1); [EOL]         index = string.indexOf('\"'); [EOL]     } [EOL]     return string; [EOL] }
private String escape(String string) { [EOL]     int index = string.indexOf('\''); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "&apos;" + string.substring(index + 1); [EOL]         index = string.indexOf('\''); [EOL]     } [EOL]     index = string.indexOf('\"'); [EOL]     while (index != -1) { [EOL]         string = string.substring(0, index) + "&quot;" + string.substring(index + 1); [EOL]         index = string.indexOf('\"'); [EOL]     } [EOL]     return string; [EOL] }
private AbstractFactory getAbstractFactory(JXPathContext context) { [EOL]     AbstractFactory factory = context.getFactory(); [EOL]     if (factory == null) { [EOL]         throw new JXPathException("Factory is not set on the JXPathContext - cannot create path: " + asPath()); [EOL]     } [EOL]     return factory; [EOL] }
private AbstractFactory getAbstractFactory(JXPathContext context) { [EOL]     AbstractFactory factory = context.getFactory(); [EOL]     if (factory == null) { [EOL]         throw new JXPathException("Factory is not set on the JXPathContext - cannot create path: " + asPath()); [EOL]     } [EOL]     return factory; [EOL] }
public CoreOperationAnd(Expression[] args) { [EOL]     super(args); [EOL] }
public CoreOperationAnd(Expression[] args) { [EOL]     super(args); [EOL] }
public CoreOperationAnd(Expression[] args) { [EOL]     super(args); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     for (int i = 0; i < args.length; i++) { [EOL]         if (!InfoSetUtil.booleanValue(args[i].computeValue(context))) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]     } [EOL]     return Boolean.TRUE; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     for (int i = 0; i < args.length; i++) { [EOL]         if (!InfoSetUtil.booleanValue(args[i].computeValue(context))) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]     } [EOL]     return Boolean.TRUE; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     for (int i = 0; i < args.length; i++) { [EOL]         if (!InfoSetUtil.booleanValue(args[i].computeValue(context))) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]     } [EOL]     return Boolean.TRUE; [EOL] }
protected int getPrecedence() { [EOL]     return 1; [EOL] }
public String getSymbol() { [EOL]     return "and"; [EOL] }
public static void registerAtomicClass(Class beanClass) { [EOL]     byClass.put(beanClass, new JXPathBasicBeanInfo(beanClass, true)); [EOL] }
public static void registerDynamicClass(Class beanClass, Class dynamicPropertyHandlerClass) { [EOL]     JXPathBasicBeanInfo bi = new JXPathBasicBeanInfo(beanClass, dynamicPropertyHandlerClass); [EOL]     if (beanClass.isInterface()) { [EOL]         byInterface.put(beanClass, bi); [EOL]     } else { [EOL]         byClass.put(beanClass, bi); [EOL]     } [EOL] }
public static void registerDynamicClass(Class beanClass, Class dynamicPropertyHandlerClass) { [EOL]     JXPathBasicBeanInfo bi = new JXPathBasicBeanInfo(beanClass, dynamicPropertyHandlerClass); [EOL]     if (beanClass.isInterface()) { [EOL]         byInterface.put(beanClass, bi); [EOL]     } else { [EOL]         byClass.put(beanClass, bi); [EOL]     } [EOL] }
public static JXPathBeanInfo getBeanInfo(Class beanClass) { [EOL]     JXPathBeanInfo beanInfo = (JXPathBeanInfo) byClass.get(beanClass); [EOL]     if (beanInfo == null) { [EOL]         beanInfo = findDynamicBeanInfo(beanClass); [EOL]         if (beanInfo == null) { [EOL]             beanInfo = findInformant(beanClass); [EOL]             if (beanInfo == null) { [EOL]                 beanInfo = new JXPathBasicBeanInfo(beanClass); [EOL]             } [EOL]         } [EOL]         byClass.put(beanClass, beanInfo); [EOL]     } [EOL]     return beanInfo; [EOL] }
public static JXPathBeanInfo getBeanInfo(Class beanClass) { [EOL]     JXPathBeanInfo beanInfo = (JXPathBeanInfo) byClass.get(beanClass); [EOL]     if (beanInfo == null) { [EOL]         beanInfo = findDynamicBeanInfo(beanClass); [EOL]         if (beanInfo == null) { [EOL]             beanInfo = findInformant(beanClass); [EOL]             if (beanInfo == null) { [EOL]                 beanInfo = new JXPathBasicBeanInfo(beanClass); [EOL]             } [EOL]         } [EOL]         byClass.put(beanClass, beanInfo); [EOL]     } [EOL]     return beanInfo; [EOL] }
public static JXPathBeanInfo getBeanInfo(Class beanClass) { [EOL]     JXPathBeanInfo beanInfo = (JXPathBeanInfo) byClass.get(beanClass); [EOL]     if (beanInfo == null) { [EOL]         beanInfo = findDynamicBeanInfo(beanClass); [EOL]         if (beanInfo == null) { [EOL]             beanInfo = findInformant(beanClass); [EOL]             if (beanInfo == null) { [EOL]                 beanInfo = new JXPathBasicBeanInfo(beanClass); [EOL]             } [EOL]         } [EOL]         byClass.put(beanClass, beanInfo); [EOL]     } [EOL]     return beanInfo; [EOL] }
public static JXPathBeanInfo getBeanInfo(Class beanClass) { [EOL]     JXPathBeanInfo beanInfo = (JXPathBeanInfo) byClass.get(beanClass); [EOL]     if (beanInfo == null) { [EOL]         beanInfo = findDynamicBeanInfo(beanClass); [EOL]         if (beanInfo == null) { [EOL]             beanInfo = findInformant(beanClass); [EOL]             if (beanInfo == null) { [EOL]                 beanInfo = new JXPathBasicBeanInfo(beanClass); [EOL]             } [EOL]         } [EOL]         byClass.put(beanClass, beanInfo); [EOL]     } [EOL]     return beanInfo; [EOL] }
private static JXPathBeanInfo findDynamicBeanInfo(Class beanClass) { [EOL]     JXPathBeanInfo beanInfo = null; [EOL]     if (beanClass.isInterface()) { [EOL]         beanInfo = (JXPathBeanInfo) byInterface.get(beanClass); [EOL]         if (beanInfo != null && beanInfo.isDynamic()) { [EOL]             return beanInfo; [EOL]         } [EOL]     } [EOL]     Class[] interfaces = beanClass.getInterfaces(); [EOL]     if (interfaces != null) { [EOL]         for (int i = 0; i < interfaces.length; i++) { [EOL]             beanInfo = findDynamicBeanInfo(interfaces[i]); [EOL]             if (beanInfo != null && beanInfo.isDynamic()) { [EOL]                 return beanInfo; [EOL]             } [EOL]         } [EOL]     } [EOL]     Class sup = beanClass.getSuperclass(); [EOL]     if (sup != null) { [EOL]         beanInfo = (JXPathBeanInfo) byClass.get(sup); [EOL]         if (beanInfo != null && beanInfo.isDynamic()) { [EOL]             return beanInfo; [EOL]         } [EOL]         return findDynamicBeanInfo(sup); [EOL]     } [EOL]     return null; [EOL] }
private static synchronized JXPathBeanInfo findInformant(Class beanClass) { [EOL]     String name = beanClass.getName() + "XBeanInfo"; [EOL]     try { [EOL]         return (JXPathBeanInfo) instantiate(beanClass, name); [EOL]     } catch (Exception ex) { [EOL]     } [EOL]     try { [EOL]         if (JXPathBeanInfo.class.isAssignableFrom(beanClass)) { [EOL]             return (JXPathBeanInfo) beanClass.newInstance(); [EOL]         } [EOL]     } catch (Exception ex) { [EOL]     } [EOL]     return null; [EOL] }
private static synchronized JXPathBeanInfo findInformant(Class beanClass) { [EOL]     String name = beanClass.getName() + "XBeanInfo"; [EOL]     try { [EOL]         return (JXPathBeanInfo) instantiate(beanClass, name); [EOL]     } catch (Exception ex) { [EOL]     } [EOL]     try { [EOL]         if (JXPathBeanInfo.class.isAssignableFrom(beanClass)) { [EOL]             return (JXPathBeanInfo) beanClass.newInstance(); [EOL]         } [EOL]     } catch (Exception ex) { [EOL]     } [EOL]     return null; [EOL] }
private static synchronized JXPathBeanInfo findInformant(Class beanClass) { [EOL]     String name = beanClass.getName() + "XBeanInfo"; [EOL]     try { [EOL]         return (JXPathBeanInfo) instantiate(beanClass, name); [EOL]     } catch (Exception ex) { [EOL]     } [EOL]     try { [EOL]         if (JXPathBeanInfo.class.isAssignableFrom(beanClass)) { [EOL]             return (JXPathBeanInfo) beanClass.newInstance(); [EOL]         } [EOL]     } catch (Exception ex) { [EOL]     } [EOL]     return null; [EOL] }
private static Object instantiate(Class sibling, String className) throws Exception { [EOL]     ClassLoader cl = sibling.getClassLoader(); [EOL]     if (cl != null) { [EOL]         try { [EOL]             Class cls = cl.loadClass(className); [EOL]             return cls.newInstance(); [EOL]         } catch (Exception ex) { [EOL]         } [EOL]     } [EOL]     Class cls = Class.forName(className); [EOL]     return cls.newInstance(); [EOL] }
private static Object instantiate(Class sibling, String className) throws Exception { [EOL]     ClassLoader cl = sibling.getClassLoader(); [EOL]     if (cl != null) { [EOL]         try { [EOL]             Class cls = cl.loadClass(className); [EOL]             return cls.newInstance(); [EOL]         } catch (Exception ex) { [EOL]         } [EOL]     } [EOL]     Class cls = Class.forName(className); [EOL]     return cls.newInstance(); [EOL] }
public Pointer getContextNodePointer() { [EOL]     return getCurrentNodePointer(); [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public int getDocumentOrder() { [EOL]     if (parentContext != null && parentContext.isChildOrderingRequired()) { [EOL]         return 1; [EOL]     } [EOL]     return 0; [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public int getDocumentOrder() { [EOL]     if (parentContext != null && parentContext.isChildOrderingRequired()) { [EOL]         return 1; [EOL]     } [EOL]     return 0; [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public int getDocumentOrder() { [EOL]     if (parentContext != null && parentContext.isChildOrderingRequired()) { [EOL]         return 1; [EOL]     } [EOL]     return 0; [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public boolean isChildOrderingRequired() { [EOL]     if (getDocumentOrder() != 0) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public boolean hasNext() { [EOL]     if (pointerIterator != null) { [EOL]         return pointerIterator.hasNext(); [EOL]     } [EOL]     if (getDocumentOrder() != 0) { [EOL]         return constructIterator(); [EOL]     } else { [EOL]         if (!done && !hasPerformedIteratorStep) { [EOL]             performIteratorStep(); [EOL]         } [EOL]         return !done; [EOL]     } [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public boolean hasNext() { [EOL]     if (pointerIterator != null) { [EOL]         return pointerIterator.hasNext(); [EOL]     } [EOL]     if (getDocumentOrder() != 0) { [EOL]         return constructIterator(); [EOL]     } else { [EOL]         if (!done && !hasPerformedIteratorStep) { [EOL]             performIteratorStep(); [EOL]         } [EOL]         return !done; [EOL]     } [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public boolean hasNext() { [EOL]     if (pointerIterator != null) { [EOL]         return pointerIterator.hasNext(); [EOL]     } [EOL]     if (getDocumentOrder() != 0) { [EOL]         return constructIterator(); [EOL]     } else { [EOL]         if (!done && !hasPerformedIteratorStep) { [EOL]             performIteratorStep(); [EOL]         } [EOL]         return !done; [EOL]     } [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public boolean hasNext() { [EOL]     if (pointerIterator != null) { [EOL]         return pointerIterator.hasNext(); [EOL]     } [EOL]     if (getDocumentOrder() != 0) { [EOL]         return constructIterator(); [EOL]     } else { [EOL]         if (!done && !hasPerformedIteratorStep) { [EOL]             performIteratorStep(); [EOL]         } [EOL]         return !done; [EOL]     } [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public Object next() { [EOL]     if (pointerIterator != null) { [EOL]         return pointerIterator.next(); [EOL]     } [EOL]     if (getDocumentOrder() != 0) { [EOL]         if (!constructIterator()) { [EOL]             throw new NoSuchElementException(); [EOL]         } [EOL]         return pointerIterator.next(); [EOL]     } else { [EOL]         if (!done && !hasPerformedIteratorStep) { [EOL]             performIteratorStep(); [EOL]         } [EOL]         if (done) { [EOL]             throw new NoSuchElementException(); [EOL]         } [EOL]         hasPerformedIteratorStep = false; [EOL]         return getCurrentNodePointer(); [EOL]     } [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
private void performIteratorStep() { [EOL]     done = true; [EOL]     if (position != 0 && nextNode()) { [EOL]         done = false; [EOL]     } else { [EOL]         while (nextSet()) { [EOL]             if (nextNode()) { [EOL]                 done = false; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     hasPerformedIteratorStep = true; [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public Pointer getSingleNodePointer() { [EOL]     reset(); [EOL]     while (nextSet()) { [EOL]         if (nextNode()) { [EOL]             return getCurrentNodePointer(); [EOL]         } [EOL]     } [EOL]     return null; [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public boolean nextSet() { [EOL]     reset(); [EOL]     if (!startedSetIteration) { [EOL]         startedSetIteration = true; [EOL]         while (parentContext.nextSet()) { [EOL]             if (parentContext.nextNode()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL]     if (parentContext.nextNode()) { [EOL]         return true; [EOL]     } [EOL]     while (parentContext.nextSet()) { [EOL]         if (parentContext.nextNode()) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } public EvalContext(EvalContext parentContext); public int compare(Object o1, Object o2); public Pointer getContextNodePointer(); public JXPathContext getJXPathContext(); public int getPosition(); public int getDocumentOrder(); public boolean isChildOrderingRequired(); public boolean hasNext(); public Object next(); private void performIteratorStep(); public void remove(); private boolean constructIterator(); public List getContextNodeList(); public NodeSet getNodeSet(); public Object getValue(); public String toString(); public RootContext getRootContext(); public void reset(); public int getCurrentPosition(); public Pointer getSingleNodePointer(); public abstract NodePointer getCurrentNodePointer(); public boolean nextSet(); public abstract boolean nextNode(); public boolean setPosition(int position); EvalContext parentContext; RootContext rootContext; int position=Optional[0]; boolean startedSetIteration=Optional[false]; boolean done=Optional[false]; boolean hasPerformedIteratorStep=Optional[false]; Iterator pointerIterator; Comparator REVERSE_COMPARATOR=Optional[new Comparator() {; ;     public int compare(Object o1, Object o2) {;         return ((Comparable) o2).compareTo(o1);;     }; }
public Object compute(EvalContext context) { [EOL]     return value; [EOL] }
public BeanPropertyPointer(NodePointer parent, JXPathBeanInfo beanInfo) { [EOL]     super(parent); [EOL]     this.beanInfo = beanInfo; [EOL] }
public void setPropertyName(String propertyName) { [EOL]     setPropertyIndex(UNSPECIFIED_PROPERTY); [EOL]     this.propertyName = propertyName; [EOL] }
public void setPropertyName(String propertyName) { [EOL]     setPropertyIndex(UNSPECIFIED_PROPERTY); [EOL]     this.propertyName = propertyName; [EOL] }
public void setPropertyIndex(int index) { [EOL]     if (propertyIndex != index) { [EOL]         super.setPropertyIndex(index); [EOL]         propertyName = null; [EOL]         propertyDescriptor = null; [EOL]         baseValue = UNINITIALIZED; [EOL]         value = UNINITIALIZED; [EOL]     } [EOL] }
public void setPropertyIndex(int index) { [EOL]     if (propertyIndex != index) { [EOL]         super.setPropertyIndex(index); [EOL]         propertyName = null; [EOL]         propertyDescriptor = null; [EOL]         baseValue = UNINITIALIZED; [EOL]         value = UNINITIALIZED; [EOL]     } [EOL] }
public Object getBaseValue() { [EOL]     if (baseValue == UNINITIALIZED) { [EOL]         PropertyDescriptor pd = getPropertyDescriptor(); [EOL]         if (pd == null) { [EOL]             return null; [EOL]         } [EOL]         baseValue = ValueUtils.getValue(getBean(), pd); [EOL]     } [EOL]     return baseValue; [EOL] }
public Object getBaseValue() { [EOL]     if (baseValue == UNINITIALIZED) { [EOL]         PropertyDescriptor pd = getPropertyDescriptor(); [EOL]         if (pd == null) { [EOL]             return null; [EOL]         } [EOL]         baseValue = ValueUtils.getValue(getBean(), pd); [EOL]     } [EOL]     return baseValue; [EOL] }
public Object getBaseValue() { [EOL]     if (baseValue == UNINITIALIZED) { [EOL]         PropertyDescriptor pd = getPropertyDescriptor(); [EOL]         if (pd == null) { [EOL]             return null; [EOL]         } [EOL]         baseValue = ValueUtils.getValue(getBean(), pd); [EOL]     } [EOL]     return baseValue; [EOL] }
public void setIndex(int index) { [EOL]     if (this.index != index) { [EOL]         if (this.index != WHOLE_COLLECTION || index != 0 || isCollection()) { [EOL]             super.setIndex(index); [EOL]             value = UNINITIALIZED; [EOL]         } [EOL]     } [EOL] }
public void setIndex(int index) { [EOL]     if (this.index != index) { [EOL]         if (this.index != WHOLE_COLLECTION || index != 0 || isCollection()) { [EOL]             super.setIndex(index); [EOL]             value = UNINITIALIZED; [EOL]         } [EOL]     } [EOL] }
public void setIndex(int index) { [EOL]     if (this.index != index) { [EOL]         if (this.index != WHOLE_COLLECTION || index != 0 || isCollection()) { [EOL]             super.setIndex(index); [EOL]             value = UNINITIALIZED; [EOL]         } [EOL]     } [EOL] }
public void setIndex(int index) { [EOL]     if (this.index != index) { [EOL]         if (this.index != WHOLE_COLLECTION || index != 0 || isCollection()) { [EOL]             super.setIndex(index); [EOL]             value = UNINITIALIZED; [EOL]         } [EOL]     } [EOL] }
public void setIndex(int index) { [EOL]     if (this.index != index) { [EOL]         if (this.index != WHOLE_COLLECTION || index != 0 || isCollection()) { [EOL]             super.setIndex(index); [EOL]             value = UNINITIALIZED; [EOL]         } [EOL]     } [EOL] }
public Object getImmediateNode() { [EOL]     if (value == UNINITIALIZED) { [EOL]         if (index == WHOLE_COLLECTION) { [EOL]             value = ValueUtils.getValue(getBaseValue()); [EOL]         } else { [EOL]             PropertyDescriptor pd = getPropertyDescriptor(); [EOL]             if (pd == null) { [EOL]                 value = null; [EOL]             } else { [EOL]                 value = ValueUtils.getValue(getBean(), pd, index); [EOL]             } [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     if (value == UNINITIALIZED) { [EOL]         if (index == WHOLE_COLLECTION) { [EOL]             value = ValueUtils.getValue(getBaseValue()); [EOL]         } else { [EOL]             PropertyDescriptor pd = getPropertyDescriptor(); [EOL]             if (pd == null) { [EOL]                 value = null; [EOL]             } else { [EOL]                 value = ValueUtils.getValue(getBean(), pd, index); [EOL]             } [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     if (value == UNINITIALIZED) { [EOL]         if (index == WHOLE_COLLECTION) { [EOL]             value = ValueUtils.getValue(getBaseValue()); [EOL]         } else { [EOL]             PropertyDescriptor pd = getPropertyDescriptor(); [EOL]             if (pd == null) { [EOL]                 value = null; [EOL]             } else { [EOL]                 value = ValueUtils.getValue(getBean(), pd, index); [EOL]             } [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     if (value == UNINITIALIZED) { [EOL]         if (index == WHOLE_COLLECTION) { [EOL]             value = ValueUtils.getValue(getBaseValue()); [EOL]         } else { [EOL]             PropertyDescriptor pd = getPropertyDescriptor(); [EOL]             if (pd == null) { [EOL]                 value = null; [EOL]             } else { [EOL]                 value = ValueUtils.getValue(getBean(), pd, index); [EOL]             } [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
protected boolean isActualProperty() { [EOL]     return getPropertyDescriptor() != null; [EOL] }
public boolean isCollection() { [EOL]     PropertyDescriptor pd = getPropertyDescriptor(); [EOL]     if (pd == null) { [EOL]         return false; [EOL]     } [EOL]     if (pd instanceof IndexedPropertyDescriptor) { [EOL]         return true; [EOL]     } [EOL]     int hint = ValueUtils.getCollectionHint(pd.getPropertyType()); [EOL]     if (hint == -1) { [EOL]         return false; [EOL]     } [EOL]     if (hint == 1) { [EOL]         return true; [EOL]     } [EOL]     Object value = getBaseValue(); [EOL]     return value != null && ValueUtils.isCollection(value); [EOL] }
public boolean isCollection() { [EOL]     PropertyDescriptor pd = getPropertyDescriptor(); [EOL]     if (pd == null) { [EOL]         return false; [EOL]     } [EOL]     if (pd instanceof IndexedPropertyDescriptor) { [EOL]         return true; [EOL]     } [EOL]     int hint = ValueUtils.getCollectionHint(pd.getPropertyType()); [EOL]     if (hint == -1) { [EOL]         return false; [EOL]     } [EOL]     if (hint == 1) { [EOL]         return true; [EOL]     } [EOL]     Object value = getBaseValue(); [EOL]     return value != null && ValueUtils.isCollection(value); [EOL] }
public boolean isCollection() { [EOL]     PropertyDescriptor pd = getPropertyDescriptor(); [EOL]     if (pd == null) { [EOL]         return false; [EOL]     } [EOL]     if (pd instanceof IndexedPropertyDescriptor) { [EOL]         return true; [EOL]     } [EOL]     int hint = ValueUtils.getCollectionHint(pd.getPropertyType()); [EOL]     if (hint == -1) { [EOL]         return false; [EOL]     } [EOL]     if (hint == 1) { [EOL]         return true; [EOL]     } [EOL]     Object value = getBaseValue(); [EOL]     return value != null && ValueUtils.isCollection(value); [EOL] }
public boolean isCollection() { [EOL]     PropertyDescriptor pd = getPropertyDescriptor(); [EOL]     if (pd == null) { [EOL]         return false; [EOL]     } [EOL]     if (pd instanceof IndexedPropertyDescriptor) { [EOL]         return true; [EOL]     } [EOL]     int hint = ValueUtils.getCollectionHint(pd.getPropertyType()); [EOL]     if (hint == -1) { [EOL]         return false; [EOL]     } [EOL]     if (hint == 1) { [EOL]         return true; [EOL]     } [EOL]     Object value = getBaseValue(); [EOL]     return value != null && ValueUtils.isCollection(value); [EOL] }
public boolean isCollection() { [EOL]     PropertyDescriptor pd = getPropertyDescriptor(); [EOL]     if (pd == null) { [EOL]         return false; [EOL]     } [EOL]     if (pd instanceof IndexedPropertyDescriptor) { [EOL]         return true; [EOL]     } [EOL]     int hint = ValueUtils.getCollectionHint(pd.getPropertyType()); [EOL]     if (hint == -1) { [EOL]         return false; [EOL]     } [EOL]     if (hint == 1) { [EOL]         return true; [EOL]     } [EOL]     Object value = getBaseValue(); [EOL]     return value != null && ValueUtils.isCollection(value); [EOL] }
public boolean isCollection() { [EOL]     PropertyDescriptor pd = getPropertyDescriptor(); [EOL]     if (pd == null) { [EOL]         return false; [EOL]     } [EOL]     if (pd instanceof IndexedPropertyDescriptor) { [EOL]         return true; [EOL]     } [EOL]     int hint = ValueUtils.getCollectionHint(pd.getPropertyType()); [EOL]     if (hint == -1) { [EOL]         return false; [EOL]     } [EOL]     if (hint == 1) { [EOL]         return true; [EOL]     } [EOL]     Object value = getBaseValue(); [EOL]     return value != null && ValueUtils.isCollection(value); [EOL] }
public void setValue(Object value) { [EOL]     PropertyDescriptor pd = getPropertyDescriptor(); [EOL]     if (pd == null) { [EOL]         throw new JXPathInvalidAccessException("Cannot set property: " + asPath() + " - no such property"); [EOL]     } [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         ValueUtils.setValue(getBean(), pd, value); [EOL]     } else { [EOL]         ValueUtils.setValue(getBean(), pd, index, value); [EOL]     } [EOL]     this.value = value; [EOL] }
public void setValue(Object value) { [EOL]     PropertyDescriptor pd = getPropertyDescriptor(); [EOL]     if (pd == null) { [EOL]         throw new JXPathInvalidAccessException("Cannot set property: " + asPath() + " - no such property"); [EOL]     } [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         ValueUtils.setValue(getBean(), pd, value); [EOL]     } else { [EOL]         ValueUtils.setValue(getBean(), pd, index, value); [EOL]     } [EOL]     this.value = value; [EOL] }
public void setValue(Object value) { [EOL]     PropertyDescriptor pd = getPropertyDescriptor(); [EOL]     if (pd == null) { [EOL]         throw new JXPathInvalidAccessException("Cannot set property: " + asPath() + " - no such property"); [EOL]     } [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         ValueUtils.setValue(getBean(), pd, value); [EOL]     } else { [EOL]         ValueUtils.setValue(getBean(), pd, index, value); [EOL]     } [EOL]     this.value = value; [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     if (getImmediateNode() == null) { [EOL]         super.createPath(context); [EOL]         baseValue = UNINITIALIZED; [EOL]         value = UNINITIALIZED; [EOL]     } [EOL]     return this; [EOL] }
public NodePointer createPath(JXPathContext context) { [EOL]     if (getImmediateNode() == null) { [EOL]         super.createPath(context); [EOL]         baseValue = UNINITIALIZED; [EOL]         value = UNINITIALIZED; [EOL]     } [EOL]     return this; [EOL] }
public void remove() { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         setValue(null); [EOL]     } else if (isCollection()) { [EOL]         Object collection = ValueUtils.remove(getBaseValue(), index); [EOL]         ValueUtils.setValue(getBean(), getPropertyDescriptor(), collection); [EOL]     } else if (index == 0) { [EOL]         index = WHOLE_COLLECTION; [EOL]         setValue(null); [EOL]     } [EOL] }
public void remove() { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         setValue(null); [EOL]     } else if (isCollection()) { [EOL]         Object collection = ValueUtils.remove(getBaseValue(), index); [EOL]         ValueUtils.setValue(getBean(), getPropertyDescriptor(), collection); [EOL]     } else if (index == 0) { [EOL]         index = WHOLE_COLLECTION; [EOL]         setValue(null); [EOL]     } [EOL] }
public void remove() { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         setValue(null); [EOL]     } else if (isCollection()) { [EOL]         Object collection = ValueUtils.remove(getBaseValue(), index); [EOL]         ValueUtils.setValue(getBean(), getPropertyDescriptor(), collection); [EOL]     } else if (index == 0) { [EOL]         index = WHOLE_COLLECTION; [EOL]         setValue(null); [EOL]     } [EOL] }
public String getPropertyName() { [EOL]     if (propertyName == null) { [EOL]         PropertyDescriptor pd = getPropertyDescriptor(); [EOL]         if (pd != null) { [EOL]             propertyName = pd.getName(); [EOL]         } [EOL]     } [EOL]     return propertyName != null ? propertyName : "*"; [EOL] }
public String getPropertyName() { [EOL]     if (propertyName == null) { [EOL]         PropertyDescriptor pd = getPropertyDescriptor(); [EOL]         if (pd != null) { [EOL]             propertyName = pd.getName(); [EOL]         } [EOL]     } [EOL]     return propertyName != null ? propertyName : "*"; [EOL] }
public String getPropertyName() { [EOL]     if (propertyName == null) { [EOL]         PropertyDescriptor pd = getPropertyDescriptor(); [EOL]         if (pd != null) { [EOL]             propertyName = pd.getName(); [EOL]         } [EOL]     } [EOL]     return propertyName != null ? propertyName : "*"; [EOL] }
private PropertyDescriptor getPropertyDescriptor() { [EOL]     if (propertyDescriptor == null) { [EOL]         int inx = getPropertyIndex(); [EOL]         if (inx == UNSPECIFIED_PROPERTY) { [EOL]             propertyDescriptor = beanInfo.getPropertyDescriptor(propertyName); [EOL]         } else { [EOL]             PropertyDescriptor[] propertyDescriptors = getPropertyDescriptors(); [EOL]             if (inx >= 0 && inx < propertyDescriptors.length) { [EOL]                 propertyDescriptor = propertyDescriptors[inx]; [EOL]             } else { [EOL]                 propertyDescriptor = null; [EOL]             } [EOL]         } [EOL]     } [EOL]     return propertyDescriptor; [EOL] }
private PropertyDescriptor getPropertyDescriptor() { [EOL]     if (propertyDescriptor == null) { [EOL]         int inx = getPropertyIndex(); [EOL]         if (inx == UNSPECIFIED_PROPERTY) { [EOL]             propertyDescriptor = beanInfo.getPropertyDescriptor(propertyName); [EOL]         } else { [EOL]             PropertyDescriptor[] propertyDescriptors = getPropertyDescriptors(); [EOL]             if (inx >= 0 && inx < propertyDescriptors.length) { [EOL]                 propertyDescriptor = propertyDescriptors[inx]; [EOL]             } else { [EOL]                 propertyDescriptor = null; [EOL]             } [EOL]         } [EOL]     } [EOL]     return propertyDescriptor; [EOL] }
private PropertyDescriptor getPropertyDescriptor() { [EOL]     if (propertyDescriptor == null) { [EOL]         int inx = getPropertyIndex(); [EOL]         if (inx == UNSPECIFIED_PROPERTY) { [EOL]             propertyDescriptor = beanInfo.getPropertyDescriptor(propertyName); [EOL]         } else { [EOL]             PropertyDescriptor[] propertyDescriptors = getPropertyDescriptors(); [EOL]             if (inx >= 0 && inx < propertyDescriptors.length) { [EOL]                 propertyDescriptor = propertyDescriptors[inx]; [EOL]             } else { [EOL]                 propertyDescriptor = null; [EOL]             } [EOL]         } [EOL]     } [EOL]     return propertyDescriptor; [EOL] }
private PropertyDescriptor getPropertyDescriptor() { [EOL]     if (propertyDescriptor == null) { [EOL]         int inx = getPropertyIndex(); [EOL]         if (inx == UNSPECIFIED_PROPERTY) { [EOL]             propertyDescriptor = beanInfo.getPropertyDescriptor(propertyName); [EOL]         } else { [EOL]             PropertyDescriptor[] propertyDescriptors = getPropertyDescriptors(); [EOL]             if (inx >= 0 && inx < propertyDescriptors.length) { [EOL]                 propertyDescriptor = propertyDescriptors[inx]; [EOL]             } else { [EOL]                 propertyDescriptor = null; [EOL]             } [EOL]         } [EOL]     } [EOL]     return propertyDescriptor; [EOL] }
private PropertyDescriptor getPropertyDescriptor() { [EOL]     if (propertyDescriptor == null) { [EOL]         int inx = getPropertyIndex(); [EOL]         if (inx == UNSPECIFIED_PROPERTY) { [EOL]             propertyDescriptor = beanInfo.getPropertyDescriptor(propertyName); [EOL]         } else { [EOL]             PropertyDescriptor[] propertyDescriptors = getPropertyDescriptors(); [EOL]             if (inx >= 0 && inx < propertyDescriptors.length) { [EOL]                 propertyDescriptor = propertyDescriptors[inx]; [EOL]             } else { [EOL]                 propertyDescriptor = null; [EOL]             } [EOL]         } [EOL]     } [EOL]     return propertyDescriptor; [EOL] }
public JDOMAttributeIterator(NodePointer parent, QName name) { [EOL]     this.parent = parent; [EOL]     this.name = name; [EOL]     if (parent.getNode() instanceof Element) { [EOL]         Element element = (Element) parent.getNode(); [EOL]         String prefix = name.getPrefix(); [EOL]         Namespace ns; [EOL]         if (prefix != null) { [EOL]             if (prefix.equals("xml")) { [EOL]                 ns = Namespace.XML_NAMESPACE; [EOL]             } else { [EOL]                 ns = element.getNamespace(prefix); [EOL]                 if (ns == null) { [EOL]                     attributes = Collections.EMPTY_LIST; [EOL]                     return; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             ns = Namespace.NO_NAMESPACE; [EOL]         } [EOL]         String lname = name.getName(); [EOL]         if (!lname.equals("*")) { [EOL]             attributes = new ArrayList(); [EOL]             if (ns != null) { [EOL]                 Attribute attr = element.getAttribute(lname, ns); [EOL]                 if (attr != null) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             attributes = new ArrayList(); [EOL]             List allAttributes = element.getAttributes(); [EOL]             for (int i = 0; i < allAttributes.size(); i++) { [EOL]                 Attribute attr = (Attribute) allAttributes.get(i); [EOL]                 if (attr.getNamespace().equals(ns)) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public JDOMAttributeIterator(NodePointer parent, QName name) { [EOL]     this.parent = parent; [EOL]     this.name = name; [EOL]     if (parent.getNode() instanceof Element) { [EOL]         Element element = (Element) parent.getNode(); [EOL]         String prefix = name.getPrefix(); [EOL]         Namespace ns; [EOL]         if (prefix != null) { [EOL]             if (prefix.equals("xml")) { [EOL]                 ns = Namespace.XML_NAMESPACE; [EOL]             } else { [EOL]                 ns = element.getNamespace(prefix); [EOL]                 if (ns == null) { [EOL]                     attributes = Collections.EMPTY_LIST; [EOL]                     return; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             ns = Namespace.NO_NAMESPACE; [EOL]         } [EOL]         String lname = name.getName(); [EOL]         if (!lname.equals("*")) { [EOL]             attributes = new ArrayList(); [EOL]             if (ns != null) { [EOL]                 Attribute attr = element.getAttribute(lname, ns); [EOL]                 if (attr != null) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             attributes = new ArrayList(); [EOL]             List allAttributes = element.getAttributes(); [EOL]             for (int i = 0; i < allAttributes.size(); i++) { [EOL]                 Attribute attr = (Attribute) allAttributes.get(i); [EOL]                 if (attr.getNamespace().equals(ns)) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public JDOMAttributeIterator(NodePointer parent, QName name) { [EOL]     this.parent = parent; [EOL]     this.name = name; [EOL]     if (parent.getNode() instanceof Element) { [EOL]         Element element = (Element) parent.getNode(); [EOL]         String prefix = name.getPrefix(); [EOL]         Namespace ns; [EOL]         if (prefix != null) { [EOL]             if (prefix.equals("xml")) { [EOL]                 ns = Namespace.XML_NAMESPACE; [EOL]             } else { [EOL]                 ns = element.getNamespace(prefix); [EOL]                 if (ns == null) { [EOL]                     attributes = Collections.EMPTY_LIST; [EOL]                     return; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             ns = Namespace.NO_NAMESPACE; [EOL]         } [EOL]         String lname = name.getName(); [EOL]         if (!lname.equals("*")) { [EOL]             attributes = new ArrayList(); [EOL]             if (ns != null) { [EOL]                 Attribute attr = element.getAttribute(lname, ns); [EOL]                 if (attr != null) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             attributes = new ArrayList(); [EOL]             List allAttributes = element.getAttributes(); [EOL]             for (int i = 0; i < allAttributes.size(); i++) { [EOL]                 Attribute attr = (Attribute) allAttributes.get(i); [EOL]                 if (attr.getNamespace().equals(ns)) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public JDOMAttributeIterator(NodePointer parent, QName name) { [EOL]     this.parent = parent; [EOL]     this.name = name; [EOL]     if (parent.getNode() instanceof Element) { [EOL]         Element element = (Element) parent.getNode(); [EOL]         String prefix = name.getPrefix(); [EOL]         Namespace ns; [EOL]         if (prefix != null) { [EOL]             if (prefix.equals("xml")) { [EOL]                 ns = Namespace.XML_NAMESPACE; [EOL]             } else { [EOL]                 ns = element.getNamespace(prefix); [EOL]                 if (ns == null) { [EOL]                     attributes = Collections.EMPTY_LIST; [EOL]                     return; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             ns = Namespace.NO_NAMESPACE; [EOL]         } [EOL]         String lname = name.getName(); [EOL]         if (!lname.equals("*")) { [EOL]             attributes = new ArrayList(); [EOL]             if (ns != null) { [EOL]                 Attribute attr = element.getAttribute(lname, ns); [EOL]                 if (attr != null) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             attributes = new ArrayList(); [EOL]             List allAttributes = element.getAttributes(); [EOL]             for (int i = 0; i < allAttributes.size(); i++) { [EOL]                 Attribute attr = (Attribute) allAttributes.get(i); [EOL]                 if (attr.getNamespace().equals(ns)) { [EOL]                     attributes.add(attr); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]         position = 0; [EOL]     } [EOL]     int index = position - 1; [EOL]     if (index < 0) { [EOL]         index = 0; [EOL]     } [EOL]     return new JDOMAttributePointer(parent, (Attribute) attributes.get(index)); [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]         position = 0; [EOL]     } [EOL]     int index = position - 1; [EOL]     if (index < 0) { [EOL]         index = 0; [EOL]     } [EOL]     return new JDOMAttributePointer(parent, (Attribute) attributes.get(index)); [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]         position = 0; [EOL]     } [EOL]     int index = position - 1; [EOL]     if (index < 0) { [EOL]         index = 0; [EOL]     } [EOL]     return new JDOMAttributePointer(parent, (Attribute) attributes.get(index)); [EOL] }
public boolean setPosition(int position) { [EOL]     if (attributes == null) { [EOL]         return false; [EOL]     } [EOL]     this.position = position; [EOL]     return position >= 1 && position <= attributes.size(); [EOL] }
public boolean setPosition(int position) { [EOL]     if (attributes == null) { [EOL]         return false; [EOL]     } [EOL]     this.position = position; [EOL]     return position >= 1 && position <= attributes.size(); [EOL] }
protected boolean equal(EvalContext context, Expression left, Expression right) { [EOL]     Object l = left.compute(context); [EOL]     Object r = right.compute(context); [EOL]     if (l instanceof InitialContext || l instanceof SelfContext) { [EOL]         l = ((EvalContext) l).getSingleNodePointer(); [EOL]     } [EOL]     if (r instanceof InitialContext || r instanceof SelfContext) { [EOL]         r = ((EvalContext) r).getSingleNodePointer(); [EOL]     } [EOL]     if (l instanceof Collection) { [EOL]         l = ((Collection) l).iterator(); [EOL]     } [EOL]     if (r instanceof Collection) { [EOL]         r = ((Collection) r).iterator(); [EOL]     } [EOL]     if ((l instanceof Iterator) && !(r instanceof Iterator)) { [EOL]         return contains((Iterator) l, r); [EOL]     } else if (!(l instanceof Iterator) && (r instanceof Iterator)) { [EOL]         return contains((Iterator) r, l); [EOL]     } else if (l instanceof Iterator && r instanceof Iterator) { [EOL]         return findMatch((Iterator) l, (Iterator) r); [EOL]     } [EOL]     return equal(l, r); [EOL] }
protected boolean equal(Object l, Object r) { [EOL]     if (l instanceof Pointer && r instanceof Pointer) { [EOL]         if (l.equals(r)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     if (l instanceof Pointer) { [EOL]         l = ((Pointer) l).getValue(); [EOL]     } [EOL]     if (r instanceof Pointer) { [EOL]         r = ((Pointer) r).getValue(); [EOL]     } [EOL]     if (l == r) { [EOL]         return true; [EOL]     } [EOL]     if (l instanceof Boolean || r instanceof Boolean) { [EOL]         return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); [EOL]     } else if (l instanceof Number || r instanceof Number) { [EOL]         return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); [EOL]     } else if (l instanceof String || r instanceof String) { [EOL]         return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); [EOL]     } else if (l == null) { [EOL]         return r == null; [EOL]     } [EOL]     return l.equals(r); [EOL] }
protected boolean equal(Object l, Object r) { [EOL]     if (l instanceof Pointer && r instanceof Pointer) { [EOL]         if (l.equals(r)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     if (l instanceof Pointer) { [EOL]         l = ((Pointer) l).getValue(); [EOL]     } [EOL]     if (r instanceof Pointer) { [EOL]         r = ((Pointer) r).getValue(); [EOL]     } [EOL]     if (l == r) { [EOL]         return true; [EOL]     } [EOL]     if (l instanceof Boolean || r instanceof Boolean) { [EOL]         return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); [EOL]     } else if (l instanceof Number || r instanceof Number) { [EOL]         return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); [EOL]     } else if (l instanceof String || r instanceof String) { [EOL]         return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); [EOL]     } else if (l == null) { [EOL]         return r == null; [EOL]     } [EOL]     return l.equals(r); [EOL] }
protected boolean equal(Object l, Object r) { [EOL]     if (l instanceof Pointer && r instanceof Pointer) { [EOL]         if (l.equals(r)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     if (l instanceof Pointer) { [EOL]         l = ((Pointer) l).getValue(); [EOL]     } [EOL]     if (r instanceof Pointer) { [EOL]         r = ((Pointer) r).getValue(); [EOL]     } [EOL]     if (l == r) { [EOL]         return true; [EOL]     } [EOL]     if (l instanceof Boolean || r instanceof Boolean) { [EOL]         return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); [EOL]     } else if (l instanceof Number || r instanceof Number) { [EOL]         return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); [EOL]     } else if (l instanceof String || r instanceof String) { [EOL]         return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); [EOL]     } else if (l == null) { [EOL]         return r == null; [EOL]     } [EOL]     return l.equals(r); [EOL] }
protected boolean equal(Object l, Object r) { [EOL]     if (l instanceof Pointer && r instanceof Pointer) { [EOL]         if (l.equals(r)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     if (l instanceof Pointer) { [EOL]         l = ((Pointer) l).getValue(); [EOL]     } [EOL]     if (r instanceof Pointer) { [EOL]         r = ((Pointer) r).getValue(); [EOL]     } [EOL]     if (l == r) { [EOL]         return true; [EOL]     } [EOL]     if (l instanceof Boolean || r instanceof Boolean) { [EOL]         return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); [EOL]     } else if (l instanceof Number || r instanceof Number) { [EOL]         return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); [EOL]     } else if (l instanceof String || r instanceof String) { [EOL]         return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); [EOL]     } else if (l == null) { [EOL]         return r == null; [EOL]     } [EOL]     return l.equals(r); [EOL] }
protected boolean equal(Object l, Object r) { [EOL]     if (l instanceof Pointer && r instanceof Pointer) { [EOL]         if (l.equals(r)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     if (l instanceof Pointer) { [EOL]         l = ((Pointer) l).getValue(); [EOL]     } [EOL]     if (r instanceof Pointer) { [EOL]         r = ((Pointer) r).getValue(); [EOL]     } [EOL]     if (l == r) { [EOL]         return true; [EOL]     } [EOL]     if (l instanceof Boolean || r instanceof Boolean) { [EOL]         return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); [EOL]     } else if (l instanceof Number || r instanceof Number) { [EOL]         return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); [EOL]     } else if (l instanceof String || r instanceof String) { [EOL]         return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); [EOL]     } else if (l == null) { [EOL]         return r == null; [EOL]     } [EOL]     return l.equals(r); [EOL] }
protected boolean equal(Object l, Object r) { [EOL]     if (l instanceof Pointer && r instanceof Pointer) { [EOL]         if (l.equals(r)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     if (l instanceof Pointer) { [EOL]         l = ((Pointer) l).getValue(); [EOL]     } [EOL]     if (r instanceof Pointer) { [EOL]         r = ((Pointer) r).getValue(); [EOL]     } [EOL]     if (l == r) { [EOL]         return true; [EOL]     } [EOL]     if (l instanceof Boolean || r instanceof Boolean) { [EOL]         return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); [EOL]     } else if (l instanceof Number || r instanceof Number) { [EOL]         return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); [EOL]     } else if (l instanceof String || r instanceof String) { [EOL]         return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); [EOL]     } else if (l == null) { [EOL]         return r == null; [EOL]     } [EOL]     return l.equals(r); [EOL] }
protected boolean equal(Object l, Object r) { [EOL]     if (l instanceof Pointer && r instanceof Pointer) { [EOL]         if (l.equals(r)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     if (l instanceof Pointer) { [EOL]         l = ((Pointer) l).getValue(); [EOL]     } [EOL]     if (r instanceof Pointer) { [EOL]         r = ((Pointer) r).getValue(); [EOL]     } [EOL]     if (l == r) { [EOL]         return true; [EOL]     } [EOL]     if (l instanceof Boolean || r instanceof Boolean) { [EOL]         return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); [EOL]     } else if (l instanceof Number || r instanceof Number) { [EOL]         return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); [EOL]     } else if (l instanceof String || r instanceof String) { [EOL]         return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); [EOL]     } else if (l == null) { [EOL]         return r == null; [EOL]     } [EOL]     return l.equals(r); [EOL] }
protected boolean equal(Object l, Object r) { [EOL]     if (l instanceof Pointer && r instanceof Pointer) { [EOL]         if (l.equals(r)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     if (l instanceof Pointer) { [EOL]         l = ((Pointer) l).getValue(); [EOL]     } [EOL]     if (r instanceof Pointer) { [EOL]         r = ((Pointer) r).getValue(); [EOL]     } [EOL]     if (l == r) { [EOL]         return true; [EOL]     } [EOL]     if (l instanceof Boolean || r instanceof Boolean) { [EOL]         return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); [EOL]     } else if (l instanceof Number || r instanceof Number) { [EOL]         return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); [EOL]     } else if (l instanceof String || r instanceof String) { [EOL]         return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); [EOL]     } else if (l == null) { [EOL]         return r == null; [EOL]     } [EOL]     return l.equals(r); [EOL] }
protected boolean equal(Object l, Object r) { [EOL]     if (l instanceof Pointer && r instanceof Pointer) { [EOL]         if (l.equals(r)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     if (l instanceof Pointer) { [EOL]         l = ((Pointer) l).getValue(); [EOL]     } [EOL]     if (r instanceof Pointer) { [EOL]         r = ((Pointer) r).getValue(); [EOL]     } [EOL]     if (l == r) { [EOL]         return true; [EOL]     } [EOL]     if (l instanceof Boolean || r instanceof Boolean) { [EOL]         return (InfoSetUtil.booleanValue(l) == InfoSetUtil.booleanValue(r)); [EOL]     } else if (l instanceof Number || r instanceof Number) { [EOL]         return (InfoSetUtil.doubleValue(l) == InfoSetUtil.doubleValue(r)); [EOL]     } else if (l instanceof String || r instanceof String) { [EOL]         return (InfoSetUtil.stringValue(l).equals(InfoSetUtil.stringValue(r))); [EOL]     } else if (l == null) { [EOL]         return r == null; [EOL]     } [EOL]     return l.equals(r); [EOL] }
public PredicateContext(EvalContext parentContext, Expression expression) { [EOL]     super(parentContext); [EOL]     this.expression = expression; [EOL]     if (expression instanceof NameAttributeTest) { [EOL]         nameTestExpression = ((NameAttributeTest) expression).getNameTestExpression(); [EOL]     } [EOL] }
public PredicateContext(EvalContext parentContext, Expression expression) { [EOL]     super(parentContext); [EOL]     this.expression = expression; [EOL]     if (expression instanceof NameAttributeTest) { [EOL]         nameTestExpression = ((NameAttributeTest) expression).getNameTestExpression(); [EOL]     } [EOL] }
public PredicateContext(EvalContext parentContext, Expression expression) { [EOL]     super(parentContext); [EOL]     this.expression = expression; [EOL]     if (expression instanceof NameAttributeTest) { [EOL]         nameTestExpression = ((NameAttributeTest) expression).getNameTestExpression(); [EOL]     } [EOL] }
public boolean nextNode() { [EOL]     if (done) { [EOL]         return false; [EOL]     } [EOL]     while (parentContext.nextNode()) { [EOL]         if (setupDynamicPropertyPointer()) { [EOL]             Object pred = nameTestExpression.computeValue(parentContext); [EOL]             String propertyName = InfoSetUtil.stringValue(pred); [EOL]             boolean ok = false; [EOL]             String[] names = dynamicPropertyPointer.getPropertyNames(); [EOL]             for (int i = 0; i < names.length; i++) { [EOL]                 if (names[i].equals(propertyName)) { [EOL]                     ok = true; [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             if (ok) { [EOL]                 dynamicPropertyPointer.setPropertyName(propertyName); [EOL]                 position++; [EOL]                 return true; [EOL]             } [EOL]         } else { [EOL]             Object pred = expression.computeValue(parentContext); [EOL]             if (pred instanceof Iterator) { [EOL]                 if (!((Iterator) pred).hasNext()) { [EOL]                     return false; [EOL]                 } [EOL]                 pred = ((Iterator) pred).next(); [EOL]             } [EOL]             if (pred instanceof NodePointer) { [EOL]                 pred = ((NodePointer) pred).getNode(); [EOL]             } [EOL]             if (pred instanceof Number) { [EOL]                 int pos = (int) InfoSetUtil.doubleValue(pred); [EOL]                 position++; [EOL]                 done = true; [EOL]                 return parentContext.setPosition(pos); [EOL]             } else if (InfoSetUtil.booleanValue(pred)) { [EOL]                 position++; [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean setupDynamicPropertyPointer() { [EOL]     if (nameTestExpression == null) { [EOL]         return false; [EOL]     } [EOL]     NodePointer parent = parentContext.getCurrentNodePointer(); [EOL]     if (parent == null) { [EOL]         return false; [EOL]     } [EOL]     parent = parent.getValuePointer(); [EOL]     if (!(parent instanceof PropertyOwnerPointer)) { [EOL]         return false; [EOL]     } [EOL]     dynamicPropertyPointer = (PropertyPointer) ((PropertyOwnerPointer) parent).getPropertyPointer().clone(); [EOL]     return true; [EOL] }
private boolean setupDynamicPropertyPointer() { [EOL]     if (nameTestExpression == null) { [EOL]         return false; [EOL]     } [EOL]     NodePointer parent = parentContext.getCurrentNodePointer(); [EOL]     if (parent == null) { [EOL]         return false; [EOL]     } [EOL]     parent = parent.getValuePointer(); [EOL]     if (!(parent instanceof PropertyOwnerPointer)) { [EOL]         return false; [EOL]     } [EOL]     dynamicPropertyPointer = (PropertyPointer) ((PropertyOwnerPointer) parent).getPropertyPointer().clone(); [EOL]     return true; [EOL] }
private boolean setupDynamicPropertyPointer() { [EOL]     if (nameTestExpression == null) { [EOL]         return false; [EOL]     } [EOL]     NodePointer parent = parentContext.getCurrentNodePointer(); [EOL]     if (parent == null) { [EOL]         return false; [EOL]     } [EOL]     parent = parent.getValuePointer(); [EOL]     if (!(parent instanceof PropertyOwnerPointer)) { [EOL]         return false; [EOL]     } [EOL]     dynamicPropertyPointer = (PropertyPointer) ((PropertyOwnerPointer) parent).getPropertyPointer().clone(); [EOL]     return true; [EOL] }
private boolean setupDynamicPropertyPointer() { [EOL]     if (nameTestExpression == null) { [EOL]         return false; [EOL]     } [EOL]     NodePointer parent = parentContext.getCurrentNodePointer(); [EOL]     if (parent == null) { [EOL]         return false; [EOL]     } [EOL]     parent = parent.getValuePointer(); [EOL]     if (!(parent instanceof PropertyOwnerPointer)) { [EOL]         return false; [EOL]     } [EOL]     dynamicPropertyPointer = (PropertyPointer) ((PropertyOwnerPointer) parent).getPropertyPointer().clone(); [EOL]     return true; [EOL] }
public AttributeContext(EvalContext parentContext, NodeTest nodeTest) { [EOL]     super(parentContext); [EOL]     this.nodeTest = nodeTest; [EOL] }
public AttributeContext(EvalContext parentContext, NodeTest nodeTest) { [EOL]     super(parentContext); [EOL]     this.nodeTest = nodeTest; [EOL] }
public NodePointer getCurrentNodePointer() { [EOL]     return currentNodePointer; [EOL] }
public void reset() { [EOL]     setStarted = false; [EOL]     iterator = null; [EOL]     super.reset(); [EOL] }
public boolean nextNode() { [EOL]     super.setPosition(getCurrentPosition() + 1); [EOL]     if (!setStarted) { [EOL]         setStarted = true; [EOL]         if (!(nodeTest instanceof NodeNameTest)) { [EOL]             return false; [EOL]         } [EOL]         QName name = ((NodeNameTest) nodeTest).getNodeName(); [EOL]         iterator = parentContext.getCurrentNodePointer().attributeIterator(name); [EOL]     } [EOL]     if (iterator == null) { [EOL]         return false; [EOL]     } [EOL]     if (!iterator.setPosition(iterator.getPosition() + 1)) { [EOL]         return false; [EOL]     } [EOL]     currentNodePointer = iterator.getNodePointer(); [EOL]     return true; [EOL] }
public boolean nextNode() { [EOL]     super.setPosition(getCurrentPosition() + 1); [EOL]     if (!setStarted) { [EOL]         setStarted = true; [EOL]         if (!(nodeTest instanceof NodeNameTest)) { [EOL]             return false; [EOL]         } [EOL]         QName name = ((NodeNameTest) nodeTest).getNodeName(); [EOL]         iterator = parentContext.getCurrentNodePointer().attributeIterator(name); [EOL]     } [EOL]     if (iterator == null) { [EOL]         return false; [EOL]     } [EOL]     if (!iterator.setPosition(iterator.getPosition() + 1)) { [EOL]         return false; [EOL]     } [EOL]     currentNodePointer = iterator.getNodePointer(); [EOL]     return true; [EOL] }
public boolean nextNode() { [EOL]     super.setPosition(getCurrentPosition() + 1); [EOL]     if (!setStarted) { [EOL]         setStarted = true; [EOL]         if (!(nodeTest instanceof NodeNameTest)) { [EOL]             return false; [EOL]         } [EOL]         QName name = ((NodeNameTest) nodeTest).getNodeName(); [EOL]         iterator = parentContext.getCurrentNodePointer().attributeIterator(name); [EOL]     } [EOL]     if (iterator == null) { [EOL]         return false; [EOL]     } [EOL]     if (!iterator.setPosition(iterator.getPosition() + 1)) { [EOL]         return false; [EOL]     } [EOL]     currentNodePointer = iterator.getNodePointer(); [EOL]     return true; [EOL] }
public boolean nextNode() { [EOL]     super.setPosition(getCurrentPosition() + 1); [EOL]     if (!setStarted) { [EOL]         setStarted = true; [EOL]         if (!(nodeTest instanceof NodeNameTest)) { [EOL]             return false; [EOL]         } [EOL]         QName name = ((NodeNameTest) nodeTest).getNodeName(); [EOL]         iterator = parentContext.getCurrentNodePointer().attributeIterator(name); [EOL]     } [EOL]     if (iterator == null) { [EOL]         return false; [EOL]     } [EOL]     if (!iterator.setPosition(iterator.getPosition() + 1)) { [EOL]         return false; [EOL]     } [EOL]     currentNodePointer = iterator.getNodePointer(); [EOL]     return true; [EOL] }
public boolean canConvert(Object object, Class toType) { [EOL]     if (object == null) { [EOL]         return true; [EOL]     } [EOL]     if (toType == Object.class) { [EOL]         return true; [EOL]     } [EOL]     Class fromType = object.getClass(); [EOL]     if (fromType.equals(toType)) { [EOL]         return true; [EOL]     } [EOL]     if (toType.isAssignableFrom(fromType)) { [EOL]         return true; [EOL]     } [EOL]     if (toType == String.class) { [EOL]         return true; [EOL]     } [EOL]     if (object instanceof Boolean) { [EOL]         if (toType == boolean.class || Number.class.isAssignableFrom(toType)) { [EOL]             return true; [EOL]         } [EOL]     } else if (object instanceof Number) { [EOL]         if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) { [EOL]             return true; [EOL]         } [EOL]     } else if (object instanceof Character) { [EOL]         if (toType == char.class) { [EOL]             return true; [EOL]         } [EOL]     } else if (object instanceof String) { [EOL]         if (toType.isPrimitive()) { [EOL]             return true; [EOL]         } [EOL]         if (toType == Boolean.class || toType == Character.class || toType == Byte.class || toType == Short.class || toType == Integer.class || toType == Long.class || toType == Float.class || toType == Double.class) { [EOL]             return true; [EOL]         } [EOL]     } else if (fromType.isArray()) { [EOL]         if (toType.isArray()) { [EOL]             Class cType = toType.getComponentType(); [EOL]             int length = Array.getLength(object); [EOL]             for (int i = 0; i < length; i++) { [EOL]                 Object value = Array.get(object, i); [EOL]                 if (!canConvert(value, cType)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]             return true; [EOL]         } else if (Collection.class.isAssignableFrom(toType)) { [EOL]             return canCreateCollection(toType); [EOL]         } else { [EOL]             if (Array.getLength(object) > 0) { [EOL]                 Object value = Array.get(object, 0); [EOL]                 return canConvert(value, toType); [EOL]             } else { [EOL]                 return canConvert("", toType); [EOL]             } [EOL]         } [EOL]     } else if (object instanceof Collection) { [EOL]         if (toType.isArray()) { [EOL]             Class cType = toType.getComponentType(); [EOL]             Iterator it = ((Collection) object).iterator(); [EOL]             while (it.hasNext()) { [EOL]                 Object value = it.next(); [EOL]                 if (!canConvert(value, cType)) { [EOL]                     return false; [EOL]                 } [EOL]             } [EOL]             return true; [EOL]         } else if (Collection.class.isAssignableFrom(toType)) { [EOL]             return canCreateCollection(toType); [EOL]         } else { [EOL]             if (((Collection) object).size() > 0) { [EOL]                 Object value; [EOL]                 if (object instanceof List) { [EOL]                     value = ((List) object).get(0); [EOL]                 } else { [EOL]                     Iterator it = ((Collection) object).iterator(); [EOL]                     value = it.next(); [EOL]                 } [EOL]                 return canConvert(value, toType); [EOL]             } else { [EOL]                 return canConvert("", toType); [EOL]             } [EOL]         } [EOL]     } else if (object instanceof NodeSet) { [EOL]         return canConvert(((NodeSet) object).getValues(), toType); [EOL]     } else if (object instanceof Pointer) { [EOL]         return canConvert(((Pointer) object).getValue(), toType); [EOL]     } [EOL]     return ConvertUtils.lookup(toType) != null; [EOL] }
public Object convert(Object object, Class toType) { [EOL]     if (object == null) { [EOL]         if (toType.isPrimitive()) { [EOL]             return convertNullToPrimitive(toType); [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (toType == Object.class) { [EOL]         if (object instanceof NodeSet) { [EOL]             return convert(((NodeSet) object).getValues(), toType); [EOL]         } else if (object instanceof Pointer) { [EOL]             return convert(((Pointer) object).getValue(), toType); [EOL]         } [EOL]         return object; [EOL]     } [EOL]     Class fromType = object.getClass(); [EOL]     if (fromType.equals(toType) || toType.isAssignableFrom(fromType)) { [EOL]         return object; [EOL]     } [EOL]     if (fromType.isArray()) { [EOL]         int length = Array.getLength(object); [EOL]         if (toType.isArray()) { [EOL]             Class cType = toType.getComponentType(); [EOL]             Object array = Array.newInstance(cType, length); [EOL]             for (int i = 0; i < length; i++) { [EOL]                 Object value = Array.get(object, i); [EOL]                 Array.set(array, i, convert(value, cType)); [EOL]             } [EOL]             return array; [EOL]         } else if (Collection.class.isAssignableFrom(toType)) { [EOL]             Collection collection = allocateCollection(toType); [EOL]             for (int i = 0; i < length; i++) { [EOL]                 collection.add(Array.get(object, i)); [EOL]             } [EOL]             return unmodifiableCollection(collection); [EOL]         } else { [EOL]             if (length > 0) { [EOL]                 Object value = Array.get(object, 0); [EOL]                 return convert(value, toType); [EOL]             } else { [EOL]                 return convert("", toType); [EOL]             } [EOL]         } [EOL]     } else if (object instanceof Collection) { [EOL]         int length = ((Collection) object).size(); [EOL]         if (toType.isArray()) { [EOL]             Class cType = toType.getComponentType(); [EOL]             Object array = Array.newInstance(cType, length); [EOL]             Iterator it = ((Collection) object).iterator(); [EOL]             for (int i = 0; i < length; i++) { [EOL]                 Object value = it.next(); [EOL]                 Array.set(array, i, convert(value, cType)); [EOL]             } [EOL]             return array; [EOL]         } else if (Collection.class.isAssignableFrom(toType)) { [EOL]             Collection collection = allocateCollection(toType); [EOL]             collection.addAll((Collection) object); [EOL]             return unmodifiableCollection(collection); [EOL]         } else { [EOL]             if (length > 0) { [EOL]                 Object value; [EOL]                 if (object instanceof List) { [EOL]                     value = ((List) object).get(0); [EOL]                 } else { [EOL]                     Iterator it = ((Collection) object).iterator(); [EOL]                     value = it.next(); [EOL]                 } [EOL]                 return convert(value, toType); [EOL]             } else { [EOL]                 return convert("", toType); [EOL]             } [EOL]         } [EOL]     } else if (object instanceof NodeSet) { [EOL]         return convert(((NodeSet) object).getValues(), toType); [EOL]     } else if (object instanceof Pointer) { [EOL]         return convert(((Pointer) object).getValue(), toType); [EOL]     } else if (toType == String.class) { [EOL]         return object.toString(); [EOL]     } else if (object instanceof Boolean) { [EOL]         if (toType == boolean.class) { [EOL]             return object; [EOL]         } [EOL]         boolean value = ((Boolean) object).booleanValue(); [EOL]         return allocateNumber(toType, value ? 1 : 0); [EOL]     } else if (object instanceof Number) { [EOL]         double value = ((Number) object).doubleValue(); [EOL]         if (toType == boolean.class || toType == Boolean.class) { [EOL]             return value == 0.0 ? Boolean.FALSE : Boolean.TRUE; [EOL]         } [EOL]         if (toType.isPrimitive() || Number.class.isAssignableFrom(toType)) { [EOL]             return allocateNumber(toType, value); [EOL]         } [EOL]     } else if (object instanceof Character) { [EOL]         if (toType == char.class) { [EOL]             return object; [EOL]         } [EOL]     } else if (object instanceof String) { [EOL]         Object value = convertStringToPrimitive(object, toType); [EOL]         if (value != null) { [EOL]             return value; [EOL]         } [EOL]     } [EOL]     Converter converter = ConvertUtils.lookup(toType); [EOL]     if (converter != null) { [EOL]         return converter.convert(toType, object); [EOL]     } [EOL]     throw new JXPathTypeConversionException("Cannot convert " + object.getClass() + " to " + toType); [EOL] }
protected Object convertStringToPrimitive(Object object, Class toType) { [EOL]     if (toType == boolean.class || toType == Boolean.class) { [EOL]         return Boolean.valueOf((String) object); [EOL]     } [EOL]     if (toType == char.class || toType == Character.class) { [EOL]         return new Character(((String) object).charAt(0)); [EOL]     } [EOL]     if (toType == byte.class || toType == Byte.class) { [EOL]         return new Byte((String) object); [EOL]     } [EOL]     if (toType == short.class || toType == Short.class) { [EOL]         return new Short((String) object); [EOL]     } [EOL]     if (toType == int.class || toType == Integer.class) { [EOL]         return new Integer((String) object); [EOL]     } [EOL]     if (toType == long.class || toType == Long.class) { [EOL]         return new Long((String) object); [EOL]     } [EOL]     if (toType == float.class || toType == Float.class) { [EOL]         return new Float((String) object); [EOL]     } [EOL]     if (toType == double.class || toType == Double.class) { [EOL]         return new Double((String) object); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertStringToPrimitive(Object object, Class toType) { [EOL]     if (toType == boolean.class || toType == Boolean.class) { [EOL]         return Boolean.valueOf((String) object); [EOL]     } [EOL]     if (toType == char.class || toType == Character.class) { [EOL]         return new Character(((String) object).charAt(0)); [EOL]     } [EOL]     if (toType == byte.class || toType == Byte.class) { [EOL]         return new Byte((String) object); [EOL]     } [EOL]     if (toType == short.class || toType == Short.class) { [EOL]         return new Short((String) object); [EOL]     } [EOL]     if (toType == int.class || toType == Integer.class) { [EOL]         return new Integer((String) object); [EOL]     } [EOL]     if (toType == long.class || toType == Long.class) { [EOL]         return new Long((String) object); [EOL]     } [EOL]     if (toType == float.class || toType == Float.class) { [EOL]         return new Float((String) object); [EOL]     } [EOL]     if (toType == double.class || toType == Double.class) { [EOL]         return new Double((String) object); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertStringToPrimitive(Object object, Class toType) { [EOL]     if (toType == boolean.class || toType == Boolean.class) { [EOL]         return Boolean.valueOf((String) object); [EOL]     } [EOL]     if (toType == char.class || toType == Character.class) { [EOL]         return new Character(((String) object).charAt(0)); [EOL]     } [EOL]     if (toType == byte.class || toType == Byte.class) { [EOL]         return new Byte((String) object); [EOL]     } [EOL]     if (toType == short.class || toType == Short.class) { [EOL]         return new Short((String) object); [EOL]     } [EOL]     if (toType == int.class || toType == Integer.class) { [EOL]         return new Integer((String) object); [EOL]     } [EOL]     if (toType == long.class || toType == Long.class) { [EOL]         return new Long((String) object); [EOL]     } [EOL]     if (toType == float.class || toType == Float.class) { [EOL]         return new Float((String) object); [EOL]     } [EOL]     if (toType == double.class || toType == Double.class) { [EOL]         return new Double((String) object); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertStringToPrimitive(Object object, Class toType) { [EOL]     if (toType == boolean.class || toType == Boolean.class) { [EOL]         return Boolean.valueOf((String) object); [EOL]     } [EOL]     if (toType == char.class || toType == Character.class) { [EOL]         return new Character(((String) object).charAt(0)); [EOL]     } [EOL]     if (toType == byte.class || toType == Byte.class) { [EOL]         return new Byte((String) object); [EOL]     } [EOL]     if (toType == short.class || toType == Short.class) { [EOL]         return new Short((String) object); [EOL]     } [EOL]     if (toType == int.class || toType == Integer.class) { [EOL]         return new Integer((String) object); [EOL]     } [EOL]     if (toType == long.class || toType == Long.class) { [EOL]         return new Long((String) object); [EOL]     } [EOL]     if (toType == float.class || toType == Float.class) { [EOL]         return new Float((String) object); [EOL]     } [EOL]     if (toType == double.class || toType == Double.class) { [EOL]         return new Double((String) object); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertStringToPrimitive(Object object, Class toType) { [EOL]     if (toType == boolean.class || toType == Boolean.class) { [EOL]         return Boolean.valueOf((String) object); [EOL]     } [EOL]     if (toType == char.class || toType == Character.class) { [EOL]         return new Character(((String) object).charAt(0)); [EOL]     } [EOL]     if (toType == byte.class || toType == Byte.class) { [EOL]         return new Byte((String) object); [EOL]     } [EOL]     if (toType == short.class || toType == Short.class) { [EOL]         return new Short((String) object); [EOL]     } [EOL]     if (toType == int.class || toType == Integer.class) { [EOL]         return new Integer((String) object); [EOL]     } [EOL]     if (toType == long.class || toType == Long.class) { [EOL]         return new Long((String) object); [EOL]     } [EOL]     if (toType == float.class || toType == Float.class) { [EOL]         return new Float((String) object); [EOL]     } [EOL]     if (toType == double.class || toType == Double.class) { [EOL]         return new Double((String) object); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertStringToPrimitive(Object object, Class toType) { [EOL]     if (toType == boolean.class || toType == Boolean.class) { [EOL]         return Boolean.valueOf((String) object); [EOL]     } [EOL]     if (toType == char.class || toType == Character.class) { [EOL]         return new Character(((String) object).charAt(0)); [EOL]     } [EOL]     if (toType == byte.class || toType == Byte.class) { [EOL]         return new Byte((String) object); [EOL]     } [EOL]     if (toType == short.class || toType == Short.class) { [EOL]         return new Short((String) object); [EOL]     } [EOL]     if (toType == int.class || toType == Integer.class) { [EOL]         return new Integer((String) object); [EOL]     } [EOL]     if (toType == long.class || toType == Long.class) { [EOL]         return new Long((String) object); [EOL]     } [EOL]     if (toType == float.class || toType == Float.class) { [EOL]         return new Float((String) object); [EOL]     } [EOL]     if (toType == double.class || toType == Double.class) { [EOL]         return new Double((String) object); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertStringToPrimitive(Object object, Class toType) { [EOL]     if (toType == boolean.class || toType == Boolean.class) { [EOL]         return Boolean.valueOf((String) object); [EOL]     } [EOL]     if (toType == char.class || toType == Character.class) { [EOL]         return new Character(((String) object).charAt(0)); [EOL]     } [EOL]     if (toType == byte.class || toType == Byte.class) { [EOL]         return new Byte((String) object); [EOL]     } [EOL]     if (toType == short.class || toType == Short.class) { [EOL]         return new Short((String) object); [EOL]     } [EOL]     if (toType == int.class || toType == Integer.class) { [EOL]         return new Integer((String) object); [EOL]     } [EOL]     if (toType == long.class || toType == Long.class) { [EOL]         return new Long((String) object); [EOL]     } [EOL]     if (toType == float.class || toType == Float.class) { [EOL]         return new Float((String) object); [EOL]     } [EOL]     if (toType == double.class || toType == Double.class) { [EOL]         return new Double((String) object); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertStringToPrimitive(Object object, Class toType) { [EOL]     if (toType == boolean.class || toType == Boolean.class) { [EOL]         return Boolean.valueOf((String) object); [EOL]     } [EOL]     if (toType == char.class || toType == Character.class) { [EOL]         return new Character(((String) object).charAt(0)); [EOL]     } [EOL]     if (toType == byte.class || toType == Byte.class) { [EOL]         return new Byte((String) object); [EOL]     } [EOL]     if (toType == short.class || toType == Short.class) { [EOL]         return new Short((String) object); [EOL]     } [EOL]     if (toType == int.class || toType == Integer.class) { [EOL]         return new Integer((String) object); [EOL]     } [EOL]     if (toType == long.class || toType == Long.class) { [EOL]         return new Long((String) object); [EOL]     } [EOL]     if (toType == float.class || toType == Float.class) { [EOL]         return new Float((String) object); [EOL]     } [EOL]     if (toType == double.class || toType == Double.class) { [EOL]         return new Double((String) object); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertStringToPrimitive(Object object, Class toType) { [EOL]     if (toType == boolean.class || toType == Boolean.class) { [EOL]         return Boolean.valueOf((String) object); [EOL]     } [EOL]     if (toType == char.class || toType == Character.class) { [EOL]         return new Character(((String) object).charAt(0)); [EOL]     } [EOL]     if (toType == byte.class || toType == Byte.class) { [EOL]         return new Byte((String) object); [EOL]     } [EOL]     if (toType == short.class || toType == Short.class) { [EOL]         return new Short((String) object); [EOL]     } [EOL]     if (toType == int.class || toType == Integer.class) { [EOL]         return new Integer((String) object); [EOL]     } [EOL]     if (toType == long.class || toType == Long.class) { [EOL]         return new Long((String) object); [EOL]     } [EOL]     if (toType == float.class || toType == Float.class) { [EOL]         return new Float((String) object); [EOL]     } [EOL]     if (toType == double.class || toType == Double.class) { [EOL]         return new Double((String) object); [EOL]     } [EOL]     return null; [EOL] }
protected Object convertStringToPrimitive(Object object, Class toType) { [EOL]     if (toType == boolean.class || toType == Boolean.class) { [EOL]         return Boolean.valueOf((String) object); [EOL]     } [EOL]     if (toType == char.class || toType == Character.class) { [EOL]         return new Character(((String) object).charAt(0)); [EOL]     } [EOL]     if (toType == byte.class || toType == Byte.class) { [EOL]         return new Byte((String) object); [EOL]     } [EOL]     if (toType == short.class || toType == Short.class) { [EOL]         return new Short((String) object); [EOL]     } [EOL]     if (toType == int.class || toType == Integer.class) { [EOL]         return new Integer((String) object); [EOL]     } [EOL]     if (toType == long.class || toType == Long.class) { [EOL]         return new Long((String) object); [EOL]     } [EOL]     if (toType == float.class || toType == Float.class) { [EOL]         return new Float((String) object); [EOL]     } [EOL]     if (toType == double.class || toType == Double.class) { [EOL]         return new Double((String) object); [EOL]     } [EOL]     return null; [EOL] }
protected Number allocateNumber(Class type, double value) { [EOL]     if (type == Byte.class || type == byte.class) { [EOL]         return new Byte((byte) value); [EOL]     } [EOL]     if (type == Short.class || type == short.class) { [EOL]         return new Short((short) value); [EOL]     } [EOL]     if (type == Integer.class || type == int.class) { [EOL]         return new Integer((int) value); [EOL]     } [EOL]     if (type == Long.class || type == long.class) { [EOL]         return new Long((long) value); [EOL]     } [EOL]     if (type == Float.class || type == float.class) { [EOL]         return new Float((float) value); [EOL]     } [EOL]     if (type == Double.class || type == double.class) { [EOL]         return new Double(value); [EOL]     } [EOL]     return null; [EOL] }
protected Number allocateNumber(Class type, double value) { [EOL]     if (type == Byte.class || type == byte.class) { [EOL]         return new Byte((byte) value); [EOL]     } [EOL]     if (type == Short.class || type == short.class) { [EOL]         return new Short((short) value); [EOL]     } [EOL]     if (type == Integer.class || type == int.class) { [EOL]         return new Integer((int) value); [EOL]     } [EOL]     if (type == Long.class || type == long.class) { [EOL]         return new Long((long) value); [EOL]     } [EOL]     if (type == Float.class || type == float.class) { [EOL]         return new Float((float) value); [EOL]     } [EOL]     if (type == Double.class || type == double.class) { [EOL]         return new Double(value); [EOL]     } [EOL]     return null; [EOL] }
protected Number allocateNumber(Class type, double value) { [EOL]     if (type == Byte.class || type == byte.class) { [EOL]         return new Byte((byte) value); [EOL]     } [EOL]     if (type == Short.class || type == short.class) { [EOL]         return new Short((short) value); [EOL]     } [EOL]     if (type == Integer.class || type == int.class) { [EOL]         return new Integer((int) value); [EOL]     } [EOL]     if (type == Long.class || type == long.class) { [EOL]         return new Long((long) value); [EOL]     } [EOL]     if (type == Float.class || type == float.class) { [EOL]         return new Float((float) value); [EOL]     } [EOL]     if (type == Double.class || type == double.class) { [EOL]         return new Double(value); [EOL]     } [EOL]     return null; [EOL] }
protected Number allocateNumber(Class type, double value) { [EOL]     if (type == Byte.class || type == byte.class) { [EOL]         return new Byte((byte) value); [EOL]     } [EOL]     if (type == Short.class || type == short.class) { [EOL]         return new Short((short) value); [EOL]     } [EOL]     if (type == Integer.class || type == int.class) { [EOL]         return new Integer((int) value); [EOL]     } [EOL]     if (type == Long.class || type == long.class) { [EOL]         return new Long((long) value); [EOL]     } [EOL]     if (type == Float.class || type == float.class) { [EOL]         return new Float((float) value); [EOL]     } [EOL]     if (type == Double.class || type == double.class) { [EOL]         return new Double(value); [EOL]     } [EOL]     return null; [EOL] }
protected Number allocateNumber(Class type, double value) { [EOL]     if (type == Byte.class || type == byte.class) { [EOL]         return new Byte((byte) value); [EOL]     } [EOL]     if (type == Short.class || type == short.class) { [EOL]         return new Short((short) value); [EOL]     } [EOL]     if (type == Integer.class || type == int.class) { [EOL]         return new Integer((int) value); [EOL]     } [EOL]     if (type == Long.class || type == long.class) { [EOL]         return new Long((long) value); [EOL]     } [EOL]     if (type == Float.class || type == float.class) { [EOL]         return new Float((float) value); [EOL]     } [EOL]     if (type == Double.class || type == double.class) { [EOL]         return new Double(value); [EOL]     } [EOL]     return null; [EOL] }
protected Number allocateNumber(Class type, double value) { [EOL]     if (type == Byte.class || type == byte.class) { [EOL]         return new Byte((byte) value); [EOL]     } [EOL]     if (type == Short.class || type == short.class) { [EOL]         return new Short((short) value); [EOL]     } [EOL]     if (type == Integer.class || type == int.class) { [EOL]         return new Integer((int) value); [EOL]     } [EOL]     if (type == Long.class || type == long.class) { [EOL]         return new Long((long) value); [EOL]     } [EOL]     if (type == Float.class || type == float.class) { [EOL]         return new Float((float) value); [EOL]     } [EOL]     if (type == Double.class || type == double.class) { [EOL]         return new Double(value); [EOL]     } [EOL]     return null; [EOL] }
protected Number allocateNumber(Class type, double value) { [EOL]     if (type == Byte.class || type == byte.class) { [EOL]         return new Byte((byte) value); [EOL]     } [EOL]     if (type == Short.class || type == short.class) { [EOL]         return new Short((short) value); [EOL]     } [EOL]     if (type == Integer.class || type == int.class) { [EOL]         return new Integer((int) value); [EOL]     } [EOL]     if (type == Long.class || type == long.class) { [EOL]         return new Long((long) value); [EOL]     } [EOL]     if (type == Float.class || type == float.class) { [EOL]         return new Float((float) value); [EOL]     } [EOL]     if (type == Double.class || type == double.class) { [EOL]         return new Double(value); [EOL]     } [EOL]     return null; [EOL] }
public boolean isDeclaredVariable(String varName) { [EOL]     return vars.containsKey(varName); [EOL] }
public boolean isDeclaredVariable(String varName) { [EOL]     return vars.containsKey(varName); [EOL] }
public Object getVariable(String varName) { [EOL]     if (vars.containsKey(varName)) { [EOL]         return vars.get(varName); [EOL]     } [EOL]     throw new IllegalArgumentException("No such variable: '" + varName + "'"); [EOL] }
public Object getVariable(String varName) { [EOL]     if (vars.containsKey(varName)) { [EOL]         return vars.get(varName); [EOL]     } [EOL]     throw new IllegalArgumentException("No such variable: '" + varName + "'"); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); [EOL]     double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); [EOL]     return l <= r ? Boolean.TRUE : Boolean.FALSE; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); [EOL]     double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); [EOL]     return l <= r ? Boolean.TRUE : Boolean.FALSE; [EOL] }
public NamespacePointer(NodePointer parent, String prefix) { [EOL]     super(parent); [EOL]     this.prefix = prefix; [EOL] }
public NamespacePointer(NodePointer parent, String prefix) { [EOL]     super(parent); [EOL]     this.prefix = prefix; [EOL] }
public NamespacePointer(NodePointer parent, String prefix) { [EOL]     super(parent); [EOL]     this.prefix = prefix; [EOL] }
public NamespacePointer(NodePointer parent, String prefix) { [EOL]     super(parent); [EOL]     this.prefix = prefix; [EOL] }
public Object getImmediateNode() { [EOL]     return getNamespaceURI(); [EOL] }
public String getNamespaceURI() { [EOL]     if (namespaceURI == null) { [EOL]         namespaceURI = parent.getNamespaceURI(prefix); [EOL]     } [EOL]     return namespaceURI; [EOL] }
public String getNamespaceURI() { [EOL]     if (namespaceURI == null) { [EOL]         namespaceURI = parent.getNamespaceURI(prefix); [EOL]     } [EOL]     return namespaceURI; [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]         if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]             buffer.append('/'); [EOL]         } [EOL]     } [EOL]     buffer.append("namespace::"); [EOL]     buffer.append(prefix); [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]         if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]             buffer.append('/'); [EOL]         } [EOL]     } [EOL]     buffer.append("namespace::"); [EOL]     buffer.append(prefix); [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]         if (buffer.length() == 0 || buffer.charAt(buffer.length() - 1) != '/') { [EOL]             buffer.append('/'); [EOL]         } [EOL]     } [EOL]     buffer.append("namespace::"); [EOL]     buffer.append(prefix); [EOL]     return buffer.toString(); [EOL] }
public DynamicPointer(NodePointer parent, QName name, Object bean, DynamicPropertyHandler handler) { [EOL]     super(parent); [EOL]     this.name = name; [EOL]     this.bean = bean; [EOL]     this.handler = handler; [EOL] }
public PropertyPointer getPropertyPointer() { [EOL]     return new DynamicPropertyPointer(this, handler); [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof DynamicPointer)) { [EOL]         return false; [EOL]     } [EOL]     DynamicPointer other = (DynamicPointer) object; [EOL]     return bean == other.bean && name.equals(other.name); [EOL] }
public Pointer getSingleNodePointer() { [EOL]     return nodePointer; [EOL] }
public boolean setPosition(int position) { [EOL]     this.position = position; [EOL]     if (collection) { [EOL]         if (position >= 1 && position <= nodePointer.getLength()) { [EOL]             nodePointer.setIndex(position - 1); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } else { [EOL]         return position == 1; [EOL]     } [EOL] }
public boolean setPosition(int position) { [EOL]     this.position = position; [EOL]     if (collection) { [EOL]         if (position >= 1 && position <= nodePointer.getLength()) { [EOL]             nodePointer.setIndex(position - 1); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } else { [EOL]         return position == 1; [EOL]     } [EOL] }
public boolean setPosition(int position) { [EOL]     this.position = position; [EOL]     if (collection) { [EOL]         if (position >= 1 && position <= nodePointer.getLength()) { [EOL]             nodePointer.setIndex(position - 1); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } else { [EOL]         return position == 1; [EOL]     } [EOL] }
public boolean setPosition(int position) { [EOL]     this.position = position; [EOL]     if (collection) { [EOL]         if (position >= 1 && position <= nodePointer.getLength()) { [EOL]             nodePointer.setIndex(position - 1); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } else { [EOL]         return position == 1; [EOL]     } [EOL] }
public boolean nextSet() { [EOL]     if (started) { [EOL]         return false; [EOL]     } [EOL]     started = true; [EOL]     return true; [EOL] }
public boolean nextSet() { [EOL]     if (started) { [EOL]         return false; [EOL]     } [EOL]     started = true; [EOL]     return true; [EOL] }
public PropertyIterator(PropertyOwnerPointer pointer, String name, boolean reverse, NodePointer startWith) { [EOL]     propertyNodePointer = (PropertyPointer) pointer.getPropertyPointer().clone(); [EOL]     this.name = name; [EOL]     this.reverse = reverse; [EOL]     this.includeStart = true; [EOL]     if (reverse) { [EOL]         this.startPropertyIndex = PropertyPointer.UNSPECIFIED_PROPERTY; [EOL]         this.startIndex = -1; [EOL]     } [EOL]     if (startWith != null) { [EOL]         while (startWith != null && startWith.getImmediateParentPointer() != pointer) { [EOL]             startWith = startWith.getImmediateParentPointer(); [EOL]         } [EOL]         if (startWith == null) { [EOL]             throw new JXPathException("PropertyIerator startWith parameter is " + "not a child of the supplied parent"); [EOL]         } [EOL]         this.startPropertyIndex = ((PropertyPointer) startWith).getPropertyIndex(); [EOL]         this.startIndex = startWith.getIndex(); [EOL]         if (this.startIndex == NodePointer.WHOLE_COLLECTION) { [EOL]             this.startIndex = 0; [EOL]         } [EOL]         this.includeStart = false; [EOL]         if (reverse && startIndex == -1) { [EOL]             this.includeStart = true; [EOL]         } [EOL]     } [EOL] }
public PropertyIterator(PropertyOwnerPointer pointer, String name, boolean reverse, NodePointer startWith) { [EOL]     propertyNodePointer = (PropertyPointer) pointer.getPropertyPointer().clone(); [EOL]     this.name = name; [EOL]     this.reverse = reverse; [EOL]     this.includeStart = true; [EOL]     if (reverse) { [EOL]         this.startPropertyIndex = PropertyPointer.UNSPECIFIED_PROPERTY; [EOL]         this.startIndex = -1; [EOL]     } [EOL]     if (startWith != null) { [EOL]         while (startWith != null && startWith.getImmediateParentPointer() != pointer) { [EOL]             startWith = startWith.getImmediateParentPointer(); [EOL]         } [EOL]         if (startWith == null) { [EOL]             throw new JXPathException("PropertyIerator startWith parameter is " + "not a child of the supplied parent"); [EOL]         } [EOL]         this.startPropertyIndex = ((PropertyPointer) startWith).getPropertyIndex(); [EOL]         this.startIndex = startWith.getIndex(); [EOL]         if (this.startIndex == NodePointer.WHOLE_COLLECTION) { [EOL]             this.startIndex = 0; [EOL]         } [EOL]         this.includeStart = false; [EOL]         if (reverse && startIndex == -1) { [EOL]             this.includeStart = true; [EOL]         } [EOL]     } [EOL] }
public PropertyIterator(PropertyOwnerPointer pointer, String name, boolean reverse, NodePointer startWith) { [EOL]     propertyNodePointer = (PropertyPointer) pointer.getPropertyPointer().clone(); [EOL]     this.name = name; [EOL]     this.reverse = reverse; [EOL]     this.includeStart = true; [EOL]     if (reverse) { [EOL]         this.startPropertyIndex = PropertyPointer.UNSPECIFIED_PROPERTY; [EOL]         this.startIndex = -1; [EOL]     } [EOL]     if (startWith != null) { [EOL]         while (startWith != null && startWith.getImmediateParentPointer() != pointer) { [EOL]             startWith = startWith.getImmediateParentPointer(); [EOL]         } [EOL]         if (startWith == null) { [EOL]             throw new JXPathException("PropertyIerator startWith parameter is " + "not a child of the supplied parent"); [EOL]         } [EOL]         this.startPropertyIndex = ((PropertyPointer) startWith).getPropertyIndex(); [EOL]         this.startIndex = startWith.getIndex(); [EOL]         if (this.startIndex == NodePointer.WHOLE_COLLECTION) { [EOL]             this.startIndex = 0; [EOL]         } [EOL]         this.includeStart = false; [EOL]         if (reverse && startIndex == -1) { [EOL]             this.includeStart = true; [EOL]         } [EOL]     } [EOL] }
public PropertyIterator(PropertyOwnerPointer pointer, String name, boolean reverse, NodePointer startWith) { [EOL]     propertyNodePointer = (PropertyPointer) pointer.getPropertyPointer().clone(); [EOL]     this.name = name; [EOL]     this.reverse = reverse; [EOL]     this.includeStart = true; [EOL]     if (reverse) { [EOL]         this.startPropertyIndex = PropertyPointer.UNSPECIFIED_PROPERTY; [EOL]         this.startIndex = -1; [EOL]     } [EOL]     if (startWith != null) { [EOL]         while (startWith != null && startWith.getImmediateParentPointer() != pointer) { [EOL]             startWith = startWith.getImmediateParentPointer(); [EOL]         } [EOL]         if (startWith == null) { [EOL]             throw new JXPathException("PropertyIerator startWith parameter is " + "not a child of the supplied parent"); [EOL]         } [EOL]         this.startPropertyIndex = ((PropertyPointer) startWith).getPropertyIndex(); [EOL]         this.startIndex = startWith.getIndex(); [EOL]         if (this.startIndex == NodePointer.WHOLE_COLLECTION) { [EOL]             this.startIndex = 0; [EOL]         } [EOL]         this.includeStart = false; [EOL]         if (reverse && startIndex == -1) { [EOL]             this.includeStart = true; [EOL]         } [EOL]     } [EOL] }
public PropertyIterator(PropertyOwnerPointer pointer, String name, boolean reverse, NodePointer startWith) { [EOL]     propertyNodePointer = (PropertyPointer) pointer.getPropertyPointer().clone(); [EOL]     this.name = name; [EOL]     this.reverse = reverse; [EOL]     this.includeStart = true; [EOL]     if (reverse) { [EOL]         this.startPropertyIndex = PropertyPointer.UNSPECIFIED_PROPERTY; [EOL]         this.startIndex = -1; [EOL]     } [EOL]     if (startWith != null) { [EOL]         while (startWith != null && startWith.getImmediateParentPointer() != pointer) { [EOL]             startWith = startWith.getImmediateParentPointer(); [EOL]         } [EOL]         if (startWith == null) { [EOL]             throw new JXPathException("PropertyIerator startWith parameter is " + "not a child of the supplied parent"); [EOL]         } [EOL]         this.startPropertyIndex = ((PropertyPointer) startWith).getPropertyIndex(); [EOL]         this.startIndex = startWith.getIndex(); [EOL]         if (this.startIndex == NodePointer.WHOLE_COLLECTION) { [EOL]             this.startIndex = 0; [EOL]         } [EOL]         this.includeStart = false; [EOL]         if (reverse && startIndex == -1) { [EOL]             this.includeStart = true; [EOL]         } [EOL]     } [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         if (name != null) { [EOL]             if (!targetReady) { [EOL]                 prepareForIndividualProperty(name); [EOL]             } [EOL]             if (empty) { [EOL]                 return null; [EOL]             } [EOL]         } else { [EOL]             if (!setPosition(1)) { [EOL]                 return null; [EOL]             } [EOL]             reset(); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return propertyNodePointer.getValuePointer(); [EOL]     } catch (Throwable ex) { [EOL]         NullPropertyPointer npp = new NullPropertyPointer(propertyNodePointer.getImmediateParentPointer()); [EOL]         npp.setPropertyName(propertyNodePointer.getPropertyName()); [EOL]         npp.setIndex(propertyNodePointer.getIndex()); [EOL]         return npp.getValuePointer(); [EOL]     } [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         if (name != null) { [EOL]             if (!targetReady) { [EOL]                 prepareForIndividualProperty(name); [EOL]             } [EOL]             if (empty) { [EOL]                 return null; [EOL]             } [EOL]         } else { [EOL]             if (!setPosition(1)) { [EOL]                 return null; [EOL]             } [EOL]             reset(); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return propertyNodePointer.getValuePointer(); [EOL]     } catch (Throwable ex) { [EOL]         NullPropertyPointer npp = new NullPropertyPointer(propertyNodePointer.getImmediateParentPointer()); [EOL]         npp.setPropertyName(propertyNodePointer.getPropertyName()); [EOL]         npp.setIndex(propertyNodePointer.getIndex()); [EOL]         return npp.getValuePointer(); [EOL]     } [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         if (name != null) { [EOL]             if (!targetReady) { [EOL]                 prepareForIndividualProperty(name); [EOL]             } [EOL]             if (empty) { [EOL]                 return null; [EOL]             } [EOL]         } else { [EOL]             if (!setPosition(1)) { [EOL]                 return null; [EOL]             } [EOL]             reset(); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return propertyNodePointer.getValuePointer(); [EOL]     } catch (Throwable ex) { [EOL]         NullPropertyPointer npp = new NullPropertyPointer(propertyNodePointer.getImmediateParentPointer()); [EOL]         npp.setPropertyName(propertyNodePointer.getPropertyName()); [EOL]         npp.setIndex(propertyNodePointer.getIndex()); [EOL]         return npp.getValuePointer(); [EOL]     } [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         if (name != null) { [EOL]             if (!targetReady) { [EOL]                 prepareForIndividualProperty(name); [EOL]             } [EOL]             if (empty) { [EOL]                 return null; [EOL]             } [EOL]         } else { [EOL]             if (!setPosition(1)) { [EOL]                 return null; [EOL]             } [EOL]             reset(); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return propertyNodePointer.getValuePointer(); [EOL]     } catch (Throwable ex) { [EOL]         NullPropertyPointer npp = new NullPropertyPointer(propertyNodePointer.getImmediateParentPointer()); [EOL]         npp.setPropertyName(propertyNodePointer.getPropertyName()); [EOL]         npp.setIndex(propertyNodePointer.getIndex()); [EOL]         return npp.getValuePointer(); [EOL]     } [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         if (name != null) { [EOL]             if (!targetReady) { [EOL]                 prepareForIndividualProperty(name); [EOL]             } [EOL]             if (empty) { [EOL]                 return null; [EOL]             } [EOL]         } else { [EOL]             if (!setPosition(1)) { [EOL]                 return null; [EOL]             } [EOL]             reset(); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return propertyNodePointer.getValuePointer(); [EOL]     } catch (Throwable ex) { [EOL]         NullPropertyPointer npp = new NullPropertyPointer(propertyNodePointer.getImmediateParentPointer()); [EOL]         npp.setPropertyName(propertyNodePointer.getPropertyName()); [EOL]         npp.setIndex(propertyNodePointer.getIndex()); [EOL]         return npp.getValuePointer(); [EOL]     } [EOL] }
public boolean setPosition(int position) { [EOL]     if (name != null) { [EOL]         return setPositionIndividualProperty(position); [EOL]     } else { [EOL]         return setPositionAllProperties(position); [EOL]     } [EOL] }
public boolean setPosition(int position) { [EOL]     if (name != null) { [EOL]         return setPositionIndividualProperty(position); [EOL]     } else { [EOL]         return setPositionAllProperties(position); [EOL]     } [EOL] }
private boolean setPositionIndividualProperty(int position) { [EOL]     this.position = position; [EOL]     if (position < 1) { [EOL]         return false; [EOL]     } [EOL]     if (!targetReady) { [EOL]         prepareForIndividualProperty(name); [EOL]     } [EOL]     if (empty) { [EOL]         return false; [EOL]     } [EOL]     int length = getLength(); [EOL]     int index; [EOL]     if (!reverse) { [EOL]         index = position + startIndex; [EOL]         if (!includeStart) { [EOL]             index++; [EOL]         } [EOL]         if (index > length) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         int end = startIndex; [EOL]         if (end == -1) { [EOL]             end = length - 1; [EOL]         } [EOL]         index = end - position + 2; [EOL]         if (!includeStart) { [EOL]             index--; [EOL]         } [EOL]         if (index < 1) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     propertyNodePointer.setIndex(index - 1); [EOL]     return true; [EOL] }
private boolean setPositionIndividualProperty(int position) { [EOL]     this.position = position; [EOL]     if (position < 1) { [EOL]         return false; [EOL]     } [EOL]     if (!targetReady) { [EOL]         prepareForIndividualProperty(name); [EOL]     } [EOL]     if (empty) { [EOL]         return false; [EOL]     } [EOL]     int length = getLength(); [EOL]     int index; [EOL]     if (!reverse) { [EOL]         index = position + startIndex; [EOL]         if (!includeStart) { [EOL]             index++; [EOL]         } [EOL]         if (index > length) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         int end = startIndex; [EOL]         if (end == -1) { [EOL]             end = length - 1; [EOL]         } [EOL]         index = end - position + 2; [EOL]         if (!includeStart) { [EOL]             index--; [EOL]         } [EOL]         if (index < 1) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     propertyNodePointer.setIndex(index - 1); [EOL]     return true; [EOL] }
private boolean setPositionIndividualProperty(int position) { [EOL]     this.position = position; [EOL]     if (position < 1) { [EOL]         return false; [EOL]     } [EOL]     if (!targetReady) { [EOL]         prepareForIndividualProperty(name); [EOL]     } [EOL]     if (empty) { [EOL]         return false; [EOL]     } [EOL]     int length = getLength(); [EOL]     int index; [EOL]     if (!reverse) { [EOL]         index = position + startIndex; [EOL]         if (!includeStart) { [EOL]             index++; [EOL]         } [EOL]         if (index > length) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         int end = startIndex; [EOL]         if (end == -1) { [EOL]             end = length - 1; [EOL]         } [EOL]         index = end - position + 2; [EOL]         if (!includeStart) { [EOL]             index--; [EOL]         } [EOL]         if (index < 1) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     propertyNodePointer.setIndex(index - 1); [EOL]     return true; [EOL] }
private boolean setPositionIndividualProperty(int position) { [EOL]     this.position = position; [EOL]     if (position < 1) { [EOL]         return false; [EOL]     } [EOL]     if (!targetReady) { [EOL]         prepareForIndividualProperty(name); [EOL]     } [EOL]     if (empty) { [EOL]         return false; [EOL]     } [EOL]     int length = getLength(); [EOL]     int index; [EOL]     if (!reverse) { [EOL]         index = position + startIndex; [EOL]         if (!includeStart) { [EOL]             index++; [EOL]         } [EOL]         if (index > length) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         int end = startIndex; [EOL]         if (end == -1) { [EOL]             end = length - 1; [EOL]         } [EOL]         index = end - position + 2; [EOL]         if (!includeStart) { [EOL]             index--; [EOL]         } [EOL]         if (index < 1) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     propertyNodePointer.setIndex(index - 1); [EOL]     return true; [EOL] }
private boolean setPositionIndividualProperty(int position) { [EOL]     this.position = position; [EOL]     if (position < 1) { [EOL]         return false; [EOL]     } [EOL]     if (!targetReady) { [EOL]         prepareForIndividualProperty(name); [EOL]     } [EOL]     if (empty) { [EOL]         return false; [EOL]     } [EOL]     int length = getLength(); [EOL]     int index; [EOL]     if (!reverse) { [EOL]         index = position + startIndex; [EOL]         if (!includeStart) { [EOL]             index++; [EOL]         } [EOL]         if (index > length) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         int end = startIndex; [EOL]         if (end == -1) { [EOL]             end = length - 1; [EOL]         } [EOL]         index = end - position + 2; [EOL]         if (!includeStart) { [EOL]             index--; [EOL]         } [EOL]         if (index < 1) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     propertyNodePointer.setIndex(index - 1); [EOL]     return true; [EOL] }
private boolean setPositionIndividualProperty(int position) { [EOL]     this.position = position; [EOL]     if (position < 1) { [EOL]         return false; [EOL]     } [EOL]     if (!targetReady) { [EOL]         prepareForIndividualProperty(name); [EOL]     } [EOL]     if (empty) { [EOL]         return false; [EOL]     } [EOL]     int length = getLength(); [EOL]     int index; [EOL]     if (!reverse) { [EOL]         index = position + startIndex; [EOL]         if (!includeStart) { [EOL]             index++; [EOL]         } [EOL]         if (index > length) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         int end = startIndex; [EOL]         if (end == -1) { [EOL]             end = length - 1; [EOL]         } [EOL]         index = end - position + 2; [EOL]         if (!includeStart) { [EOL]             index--; [EOL]         } [EOL]         if (index < 1) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     propertyNodePointer.setIndex(index - 1); [EOL]     return true; [EOL] }
private boolean setPositionIndividualProperty(int position) { [EOL]     this.position = position; [EOL]     if (position < 1) { [EOL]         return false; [EOL]     } [EOL]     if (!targetReady) { [EOL]         prepareForIndividualProperty(name); [EOL]     } [EOL]     if (empty) { [EOL]         return false; [EOL]     } [EOL]     int length = getLength(); [EOL]     int index; [EOL]     if (!reverse) { [EOL]         index = position + startIndex; [EOL]         if (!includeStart) { [EOL]             index++; [EOL]         } [EOL]         if (index > length) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         int end = startIndex; [EOL]         if (end == -1) { [EOL]             end = length - 1; [EOL]         } [EOL]         index = end - position + 2; [EOL]         if (!includeStart) { [EOL]             index--; [EOL]         } [EOL]         if (index < 1) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     propertyNodePointer.setIndex(index - 1); [EOL]     return true; [EOL] }
private boolean setPositionAllProperties(int position) { [EOL]     this.position = position; [EOL]     if (position < 1) { [EOL]         return false; [EOL]     } [EOL]     int offset; [EOL]     int count = propertyNodePointer.getPropertyCount(); [EOL]     if (!reverse) { [EOL]         int index = 1; [EOL]         for (int i = startPropertyIndex; i < count; i++) { [EOL]             propertyNodePointer.setPropertyIndex(i); [EOL]             int length = getLength(); [EOL]             if (i == startPropertyIndex) { [EOL]                 length -= startIndex; [EOL]                 if (!includeStart) { [EOL]                     length--; [EOL]                 } [EOL]                 offset = startIndex + position - index; [EOL]                 if (!includeStart) { [EOL]                     offset++; [EOL]                 } [EOL]             } else { [EOL]                 offset = position - index; [EOL]             } [EOL]             if (index <= position && position < index + length) { [EOL]                 propertyNodePointer.setIndex(offset); [EOL]                 return true; [EOL]             } [EOL]             index += length; [EOL]         } [EOL]     } else { [EOL]         int index = 1; [EOL]         int start = startPropertyIndex; [EOL]         if (start == PropertyPointer.UNSPECIFIED_PROPERTY) { [EOL]             start = count - 1; [EOL]         } [EOL]         for (int i = start; i >= 0; i--) { [EOL]             propertyNodePointer.setPropertyIndex(i); [EOL]             int length = getLength(); [EOL]             if (i == startPropertyIndex) { [EOL]                 int end = startIndex; [EOL]                 if (end == -1) { [EOL]                     end = length - 1; [EOL]                 } [EOL]                 length = end + 1; [EOL]                 offset = end - position + 1; [EOL]                 if (!includeStart) { [EOL]                     offset--; [EOL]                     length--; [EOL]                 } [EOL]             } else { [EOL]                 offset = length - (position - index) - 1; [EOL]             } [EOL]             if (index <= position && position < index + length) { [EOL]                 propertyNodePointer.setIndex(offset); [EOL]                 return true; [EOL]             } [EOL]             index += length; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean setPositionAllProperties(int position) { [EOL]     this.position = position; [EOL]     if (position < 1) { [EOL]         return false; [EOL]     } [EOL]     int offset; [EOL]     int count = propertyNodePointer.getPropertyCount(); [EOL]     if (!reverse) { [EOL]         int index = 1; [EOL]         for (int i = startPropertyIndex; i < count; i++) { [EOL]             propertyNodePointer.setPropertyIndex(i); [EOL]             int length = getLength(); [EOL]             if (i == startPropertyIndex) { [EOL]                 length -= startIndex; [EOL]                 if (!includeStart) { [EOL]                     length--; [EOL]                 } [EOL]                 offset = startIndex + position - index; [EOL]                 if (!includeStart) { [EOL]                     offset++; [EOL]                 } [EOL]             } else { [EOL]                 offset = position - index; [EOL]             } [EOL]             if (index <= position && position < index + length) { [EOL]                 propertyNodePointer.setIndex(offset); [EOL]                 return true; [EOL]             } [EOL]             index += length; [EOL]         } [EOL]     } else { [EOL]         int index = 1; [EOL]         int start = startPropertyIndex; [EOL]         if (start == PropertyPointer.UNSPECIFIED_PROPERTY) { [EOL]             start = count - 1; [EOL]         } [EOL]         for (int i = start; i >= 0; i--) { [EOL]             propertyNodePointer.setPropertyIndex(i); [EOL]             int length = getLength(); [EOL]             if (i == startPropertyIndex) { [EOL]                 int end = startIndex; [EOL]                 if (end == -1) { [EOL]                     end = length - 1; [EOL]                 } [EOL]                 length = end + 1; [EOL]                 offset = end - position + 1; [EOL]                 if (!includeStart) { [EOL]                     offset--; [EOL]                     length--; [EOL]                 } [EOL]             } else { [EOL]                 offset = length - (position - index) - 1; [EOL]             } [EOL]             if (index <= position && position < index + length) { [EOL]                 propertyNodePointer.setIndex(offset); [EOL]                 return true; [EOL]             } [EOL]             index += length; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean setPositionAllProperties(int position) { [EOL]     this.position = position; [EOL]     if (position < 1) { [EOL]         return false; [EOL]     } [EOL]     int offset; [EOL]     int count = propertyNodePointer.getPropertyCount(); [EOL]     if (!reverse) { [EOL]         int index = 1; [EOL]         for (int i = startPropertyIndex; i < count; i++) { [EOL]             propertyNodePointer.setPropertyIndex(i); [EOL]             int length = getLength(); [EOL]             if (i == startPropertyIndex) { [EOL]                 length -= startIndex; [EOL]                 if (!includeStart) { [EOL]                     length--; [EOL]                 } [EOL]                 offset = startIndex + position - index; [EOL]                 if (!includeStart) { [EOL]                     offset++; [EOL]                 } [EOL]             } else { [EOL]                 offset = position - index; [EOL]             } [EOL]             if (index <= position && position < index + length) { [EOL]                 propertyNodePointer.setIndex(offset); [EOL]                 return true; [EOL]             } [EOL]             index += length; [EOL]         } [EOL]     } else { [EOL]         int index = 1; [EOL]         int start = startPropertyIndex; [EOL]         if (start == PropertyPointer.UNSPECIFIED_PROPERTY) { [EOL]             start = count - 1; [EOL]         } [EOL]         for (int i = start; i >= 0; i--) { [EOL]             propertyNodePointer.setPropertyIndex(i); [EOL]             int length = getLength(); [EOL]             if (i == startPropertyIndex) { [EOL]                 int end = startIndex; [EOL]                 if (end == -1) { [EOL]                     end = length - 1; [EOL]                 } [EOL]                 length = end + 1; [EOL]                 offset = end - position + 1; [EOL]                 if (!includeStart) { [EOL]                     offset--; [EOL]                     length--; [EOL]                 } [EOL]             } else { [EOL]                 offset = length - (position - index) - 1; [EOL]             } [EOL]             if (index <= position && position < index + length) { [EOL]                 propertyNodePointer.setIndex(offset); [EOL]                 return true; [EOL]             } [EOL]             index += length; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean setPositionAllProperties(int position) { [EOL]     this.position = position; [EOL]     if (position < 1) { [EOL]         return false; [EOL]     } [EOL]     int offset; [EOL]     int count = propertyNodePointer.getPropertyCount(); [EOL]     if (!reverse) { [EOL]         int index = 1; [EOL]         for (int i = startPropertyIndex; i < count; i++) { [EOL]             propertyNodePointer.setPropertyIndex(i); [EOL]             int length = getLength(); [EOL]             if (i == startPropertyIndex) { [EOL]                 length -= startIndex; [EOL]                 if (!includeStart) { [EOL]                     length--; [EOL]                 } [EOL]                 offset = startIndex + position - index; [EOL]                 if (!includeStart) { [EOL]                     offset++; [EOL]                 } [EOL]             } else { [EOL]                 offset = position - index; [EOL]             } [EOL]             if (index <= position && position < index + length) { [EOL]                 propertyNodePointer.setIndex(offset); [EOL]                 return true; [EOL]             } [EOL]             index += length; [EOL]         } [EOL]     } else { [EOL]         int index = 1; [EOL]         int start = startPropertyIndex; [EOL]         if (start == PropertyPointer.UNSPECIFIED_PROPERTY) { [EOL]             start = count - 1; [EOL]         } [EOL]         for (int i = start; i >= 0; i--) { [EOL]             propertyNodePointer.setPropertyIndex(i); [EOL]             int length = getLength(); [EOL]             if (i == startPropertyIndex) { [EOL]                 int end = startIndex; [EOL]                 if (end == -1) { [EOL]                     end = length - 1; [EOL]                 } [EOL]                 length = end + 1; [EOL]                 offset = end - position + 1; [EOL]                 if (!includeStart) { [EOL]                     offset--; [EOL]                     length--; [EOL]                 } [EOL]             } else { [EOL]                 offset = length - (position - index) - 1; [EOL]             } [EOL]             if (index <= position && position < index + length) { [EOL]                 propertyNodePointer.setIndex(offset); [EOL]                 return true; [EOL]             } [EOL]             index += length; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean setPositionAllProperties(int position) { [EOL]     this.position = position; [EOL]     if (position < 1) { [EOL]         return false; [EOL]     } [EOL]     int offset; [EOL]     int count = propertyNodePointer.getPropertyCount(); [EOL]     if (!reverse) { [EOL]         int index = 1; [EOL]         for (int i = startPropertyIndex; i < count; i++) { [EOL]             propertyNodePointer.setPropertyIndex(i); [EOL]             int length = getLength(); [EOL]             if (i == startPropertyIndex) { [EOL]                 length -= startIndex; [EOL]                 if (!includeStart) { [EOL]                     length--; [EOL]                 } [EOL]                 offset = startIndex + position - index; [EOL]                 if (!includeStart) { [EOL]                     offset++; [EOL]                 } [EOL]             } else { [EOL]                 offset = position - index; [EOL]             } [EOL]             if (index <= position && position < index + length) { [EOL]                 propertyNodePointer.setIndex(offset); [EOL]                 return true; [EOL]             } [EOL]             index += length; [EOL]         } [EOL]     } else { [EOL]         int index = 1; [EOL]         int start = startPropertyIndex; [EOL]         if (start == PropertyPointer.UNSPECIFIED_PROPERTY) { [EOL]             start = count - 1; [EOL]         } [EOL]         for (int i = start; i >= 0; i--) { [EOL]             propertyNodePointer.setPropertyIndex(i); [EOL]             int length = getLength(); [EOL]             if (i == startPropertyIndex) { [EOL]                 int end = startIndex; [EOL]                 if (end == -1) { [EOL]                     end = length - 1; [EOL]                 } [EOL]                 length = end + 1; [EOL]                 offset = end - position + 1; [EOL]                 if (!includeStart) { [EOL]                     offset--; [EOL]                     length--; [EOL]                 } [EOL]             } else { [EOL]                 offset = length - (position - index) - 1; [EOL]             } [EOL]             if (index <= position && position < index + length) { [EOL]                 propertyNodePointer.setIndex(offset); [EOL]                 return true; [EOL]             } [EOL]             index += length; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
protected void prepareForIndividualProperty(String name) { [EOL]     targetReady = true; [EOL]     empty = true; [EOL]     String[] names = propertyNodePointer.getPropertyNames(); [EOL]     if (!reverse) { [EOL]         if (startPropertyIndex == PropertyPointer.UNSPECIFIED_PROPERTY) { [EOL]             startPropertyIndex = 0; [EOL]         } [EOL]         if (startIndex == NodePointer.WHOLE_COLLECTION) { [EOL]             startIndex = 0; [EOL]         } [EOL]         for (int i = startPropertyIndex; i < names.length; i++) { [EOL]             if (names[i].equals(name)) { [EOL]                 propertyNodePointer.setPropertyIndex(i); [EOL]                 if (i != startPropertyIndex) { [EOL]                     startIndex = 0; [EOL]                     includeStart = true; [EOL]                 } [EOL]                 empty = false; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (startPropertyIndex == PropertyPointer.UNSPECIFIED_PROPERTY) { [EOL]             startPropertyIndex = names.length - 1; [EOL]         } [EOL]         if (startIndex == NodePointer.WHOLE_COLLECTION) { [EOL]             startIndex = -1; [EOL]         } [EOL]         for (int i = startPropertyIndex; i >= 0; i--) { [EOL]             if (names[i].equals(name)) { [EOL]                 propertyNodePointer.setPropertyIndex(i); [EOL]                 if (i != startPropertyIndex) { [EOL]                     startIndex = -1; [EOL]                     includeStart = true; [EOL]                 } [EOL]                 empty = false; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL] }
private int getLength() { [EOL]     int length; [EOL]     try { [EOL]         length = propertyNodePointer.getLength(); [EOL]     } catch (Throwable t) { [EOL]         length = 0; [EOL]     } [EOL]     return length; [EOL] }
private int getLength() { [EOL]     int length; [EOL]     try { [EOL]         length = propertyNodePointer.getLength(); [EOL]     } catch (Throwable t) { [EOL]         length = 0; [EOL]     } [EOL]     return length; [EOL] }
public boolean isContextDependent() { [EOL]     return false; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     return context.getRootContext().getVariableContext(varName); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     return context.getRootContext().getVariableContext(varName); [EOL] }
public PrecedingOrFollowingContext(EvalContext parentContext, NodeTest nodeTest, boolean reverse) { [EOL]     super(parentContext); [EOL]     this.nodeTest = nodeTest; [EOL]     this.reverse = reverse; [EOL] }
public PrecedingOrFollowingContext(EvalContext parentContext, NodeTest nodeTest, boolean reverse) { [EOL]     super(parentContext); [EOL]     this.nodeTest = nodeTest; [EOL]     this.reverse = reverse; [EOL] }
public int getDocumentOrder() { [EOL]     return reverse ? -1 : 1; [EOL] }
public void reset() { [EOL]     super.reset(); [EOL]     stack = new Stack(); [EOL]     setStarted = false; [EOL] }
public boolean nextNode() { [EOL]     if (!setStarted) { [EOL]         setStarted = true; [EOL]         currentRootLocation = parentContext.getCurrentNodePointer(); [EOL]         NodePointer parent = currentRootLocation.getParent(); [EOL]         if (parent != null) { [EOL]             stack.push(parent.childIterator(null, reverse, currentRootLocation)); [EOL]         } [EOL]     } [EOL]     while (true) { [EOL]         if (stack.isEmpty()) { [EOL]             currentRootLocation = currentRootLocation.getParent(); [EOL]             if (currentRootLocation == null || currentRootLocation.isRoot()) { [EOL]                 break; [EOL]             } [EOL]             NodePointer parent = currentRootLocation.getParent(); [EOL]             if (parent != null) { [EOL]                 stack.push(parent.childIterator(null, reverse, currentRootLocation)); [EOL]             } [EOL]         } [EOL]         while (!stack.isEmpty()) { [EOL]             if (!reverse) { [EOL]                 NodeIterator it = (NodeIterator) stack.peek(); [EOL]                 if (it.setPosition(it.getPosition() + 1)) { [EOL]                     currentNodePointer = it.getNodePointer(); [EOL]                     if (!currentNodePointer.isLeaf()) { [EOL]                         stack.push(currentNodePointer.childIterator(null, reverse, null)); [EOL]                     } [EOL]                     if (currentNodePointer.testNode(nodeTest)) { [EOL]                         super.setPosition(getCurrentPosition() + 1); [EOL]                         return true; [EOL]                     } [EOL]                 } else { [EOL]                     stack.pop(); [EOL]                 } [EOL]             } else { [EOL]                 NodeIterator it = (NodeIterator) stack.peek(); [EOL]                 if (it.setPosition(it.getPosition() + 1)) { [EOL]                     currentNodePointer = it.getNodePointer(); [EOL]                     if (!currentNodePointer.isLeaf()) { [EOL]                         stack.push(currentNodePointer.childIterator(null, reverse, null)); [EOL]                     } else if (currentNodePointer.testNode(nodeTest)) { [EOL]                         super.setPosition(getCurrentPosition() + 1); [EOL]                         return true; [EOL]                     } [EOL]                 } else { [EOL]                     stack.pop(); [EOL]                     if (!stack.isEmpty()) { [EOL]                         it = (PropertyIterator) stack.peek(); [EOL]                         currentNodePointer = it.getNodePointer(); [EOL]                         if (currentNodePointer.testNode(nodeTest)) { [EOL]                             super.setPosition(getCurrentPosition() + 1); [EOL]                             return true; [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean isAbsolute() { [EOL]     return absolute; [EOL] }
public boolean isAbsolute() { [EOL]     return absolute; [EOL] }
public boolean computeContextDependent() { [EOL]     if (!absolute) { [EOL]         return true; [EOL]     } [EOL]     return super.computeContextDependent(); [EOL] }
public boolean computeContextDependent() { [EOL]     if (!absolute) { [EOL]         return true; [EOL]     } [EOL]     return super.computeContextDependent(); [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     Step[] steps = getSteps(); [EOL]     if (steps != null) { [EOL]         for (int i = 0; i < steps.length; i++) { [EOL]             if (i > 0 || absolute) { [EOL]                 buffer.append('/'); [EOL]             } [EOL]             buffer.append(steps[i]); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String toString() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     Step[] steps = getSteps(); [EOL]     if (steps != null) { [EOL]         for (int i = 0; i < steps.length; i++) { [EOL]             if (i > 0 || absolute) { [EOL]                 buffer.append('/'); [EOL]             } [EOL]             buffer.append(steps[i]); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public Object compute(EvalContext context) { [EOL]     EvalContext rootContext; [EOL]     if (isAbsolute()) { [EOL]         rootContext = context.getRootContext().getAbsoluteRootContext(); [EOL]     } else { [EOL]         rootContext = new InitialContext(context); [EOL]     } [EOL]     return evalSteps(rootContext); [EOL] }
public Object compute(EvalContext context) { [EOL]     EvalContext rootContext; [EOL]     if (isAbsolute()) { [EOL]         rootContext = context.getRootContext().getAbsoluteRootContext(); [EOL]     } else { [EOL]         rootContext = new InitialContext(context); [EOL]     } [EOL]     return evalSteps(rootContext); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     EvalContext rootContext; [EOL]     if (isAbsolute()) { [EOL]         rootContext = context.getRootContext().getAbsoluteRootContext(); [EOL]     } else { [EOL]         rootContext = new InitialContext(context); [EOL]     } [EOL]     return getSingleNodePointerForSteps(rootContext); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     EvalContext rootContext; [EOL]     if (isAbsolute()) { [EOL]         rootContext = context.getRootContext().getAbsoluteRootContext(); [EOL]     } else { [EOL]         rootContext = new InitialContext(context); [EOL]     } [EOL]     return getSingleNodePointerForSteps(rootContext); [EOL] }
public Object minus(Object left, Object right) { [EOL]     return new CoreOperationSubtract((Expression) left, (Expression) right); [EOL] }
public Object lessThan(Object left, Object right) { [EOL]     return new CoreOperationLessThan((Expression) left, (Expression) right); [EOL] }
public Object lessThanOrEqual(Object left, Object right) { [EOL]     return new CoreOperationLessThanOrEqual((Expression) left, (Expression) right); [EOL] }
public Object greaterThan(Object left, Object right) { [EOL]     return new CoreOperationGreaterThan((Expression) left, (Expression) right); [EOL] }
public Object equal(Object left, Object right) { [EOL]     if (isNameAttributeTest((Expression) left)) { [EOL]         return new NameAttributeTest((Expression) left, (Expression) right); [EOL]     } else { [EOL]         return new CoreOperationEqual((Expression) left, (Expression) right); [EOL]     } [EOL] }
public Object equal(Object left, Object right) { [EOL]     if (isNameAttributeTest((Expression) left)) { [EOL]         return new NameAttributeTest((Expression) left, (Expression) right); [EOL]     } else { [EOL]         return new CoreOperationEqual((Expression) left, (Expression) right); [EOL]     } [EOL] }
public Object and(Object[] arguments) { [EOL]     return new CoreOperationAnd(toExpressionArray(arguments)); [EOL] }
public Object and(Object[] arguments) { [EOL]     return new CoreOperationAnd(toExpressionArray(arguments)); [EOL] }
public Object and(Object[] arguments) { [EOL]     return new CoreOperationAnd(toExpressionArray(arguments)); [EOL] }
public Object or(Object[] arguments) { [EOL]     return new CoreOperationOr(toExpressionArray(arguments)); [EOL] }
private boolean isNameAttributeTest(Expression arg) { [EOL]     if (!(arg instanceof LocationPath)) { [EOL]         return false; [EOL]     } [EOL]     Step[] steps = ((LocationPath) arg).getSteps(); [EOL]     if (steps.length != 1) { [EOL]         return false; [EOL]     } [EOL]     if (steps[0].getAxis() != Compiler.AXIS_ATTRIBUTE) { [EOL]         return false; [EOL]     } [EOL]     NodeTest test = steps[0].getNodeTest(); [EOL]     if (!(test instanceof NodeNameTest)) { [EOL]         return false; [EOL]     } [EOL]     if (!((NodeNameTest) test).getNodeName().equals(QNAME_NAME)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private boolean isNameAttributeTest(Expression arg) { [EOL]     if (!(arg instanceof LocationPath)) { [EOL]         return false; [EOL]     } [EOL]     Step[] steps = ((LocationPath) arg).getSteps(); [EOL]     if (steps.length != 1) { [EOL]         return false; [EOL]     } [EOL]     if (steps[0].getAxis() != Compiler.AXIS_ATTRIBUTE) { [EOL]         return false; [EOL]     } [EOL]     NodeTest test = steps[0].getNodeTest(); [EOL]     if (!(test instanceof NodeNameTest)) { [EOL]         return false; [EOL]     } [EOL]     if (!((NodeNameTest) test).getNodeName().equals(QNAME_NAME)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private boolean isNameAttributeTest(Expression arg) { [EOL]     if (!(arg instanceof LocationPath)) { [EOL]         return false; [EOL]     } [EOL]     Step[] steps = ((LocationPath) arg).getSteps(); [EOL]     if (steps.length != 1) { [EOL]         return false; [EOL]     } [EOL]     if (steps[0].getAxis() != Compiler.AXIS_ATTRIBUTE) { [EOL]         return false; [EOL]     } [EOL]     NodeTest test = steps[0].getNodeTest(); [EOL]     if (!(test instanceof NodeNameTest)) { [EOL]         return false; [EOL]     } [EOL]     if (!((NodeNameTest) test).getNodeName().equals(QNAME_NAME)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private boolean isNameAttributeTest(Expression arg) { [EOL]     if (!(arg instanceof LocationPath)) { [EOL]         return false; [EOL]     } [EOL]     Step[] steps = ((LocationPath) arg).getSteps(); [EOL]     if (steps.length != 1) { [EOL]         return false; [EOL]     } [EOL]     if (steps[0].getAxis() != Compiler.AXIS_ATTRIBUTE) { [EOL]         return false; [EOL]     } [EOL]     NodeTest test = steps[0].getNodeTest(); [EOL]     if (!(test instanceof NodeNameTest)) { [EOL]         return false; [EOL]     } [EOL]     if (!((NodeNameTest) test).getNodeName().equals(QNAME_NAME)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private boolean isNameAttributeTest(Expression arg) { [EOL]     if (!(arg instanceof LocationPath)) { [EOL]         return false; [EOL]     } [EOL]     Step[] steps = ((LocationPath) arg).getSteps(); [EOL]     if (steps.length != 1) { [EOL]         return false; [EOL]     } [EOL]     if (steps[0].getAxis() != Compiler.AXIS_ATTRIBUTE) { [EOL]         return false; [EOL]     } [EOL]     NodeTest test = steps[0].getNodeTest(); [EOL]     if (!(test instanceof NodeNameTest)) { [EOL]         return false; [EOL]     } [EOL]     if (!((NodeNameTest) test).getNodeName().equals(QNAME_NAME)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private boolean isNameAttributeTest(Expression arg) { [EOL]     if (!(arg instanceof LocationPath)) { [EOL]         return false; [EOL]     } [EOL]     Step[] steps = ((LocationPath) arg).getSteps(); [EOL]     if (steps.length != 1) { [EOL]         return false; [EOL]     } [EOL]     if (steps[0].getAxis() != Compiler.AXIS_ATTRIBUTE) { [EOL]         return false; [EOL]     } [EOL]     NodeTest test = steps[0].getNodeTest(); [EOL]     if (!(test instanceof NodeNameTest)) { [EOL]         return false; [EOL]     } [EOL]     if (!((NodeNameTest) test).getNodeName().equals(QNAME_NAME)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public Object compute(EvalContext context) { [EOL]     return expressionPath(context, false); [EOL] }
protected Object expressionPath(EvalContext evalContext, boolean firstMatch) { [EOL]     Object value = expression.compute(evalContext); [EOL]     EvalContext context; [EOL]     if (value instanceof InitialContext) { [EOL]         context = (InitialContext) value; [EOL]     } else if (value instanceof EvalContext) { [EOL]         context = new UnionContext(evalContext, new EvalContext[] { (EvalContext) value }); [EOL]     } else { [EOL]         context = evalContext.getRootContext().getConstantContext(value); [EOL]     } [EOL]     if (firstMatch && isSimpleExpressionPath() && !(context instanceof NodeSetContext)) { [EOL]         EvalContext ctx = context; [EOL]         NodePointer ptr = (NodePointer) ctx.getSingleNodePointer(); [EOL]         if (ptr != null && (ptr.getIndex() == NodePointer.WHOLE_COLLECTION || predicates == null || predicates.length == 0)) { [EOL]             return SimplePathInterpreter.interpretSimpleExpressionPath(evalContext, ptr, predicates, getSteps()); [EOL]         } [EOL]     } [EOL]     if (predicates != null) { [EOL]         for (int j = 0; j < predicates.length; j++) { [EOL]             if (j != 0) { [EOL]                 context = new UnionContext(context, new EvalContext[] { context }); [EOL]             } [EOL]             context = new PredicateContext(context, predicates[j]); [EOL]         } [EOL]     } [EOL]     if (firstMatch) { [EOL]         return getSingleNodePointerForSteps(context); [EOL]     } else { [EOL]         return evalSteps(context); [EOL]     } [EOL] }
public DynaBeanPropertyPointer(NodePointer parent, DynaBean dynaBean) { [EOL]     super(parent); [EOL]     this.dynaBean = dynaBean; [EOL] }
public DynaBeanPropertyPointer(NodePointer parent, DynaBean dynaBean) { [EOL]     super(parent); [EOL]     this.dynaBean = dynaBean; [EOL] }
public DynaBeanPropertyPointer(NodePointer parent, DynaBean dynaBean) { [EOL]     super(parent); [EOL]     this.dynaBean = dynaBean; [EOL] }
public DynaBeanPropertyPointer(NodePointer parent, DynaBean dynaBean) { [EOL]     super(parent); [EOL]     this.dynaBean = dynaBean; [EOL] }
public Object getBaseValue() { [EOL]     return dynaBean.get(getPropertyName()); [EOL] }
public Object getBaseValue() { [EOL]     return dynaBean.get(getPropertyName()); [EOL] }
public void setPropertyName(String propertyName) { [EOL]     setPropertyIndex(UNSPECIFIED_PROPERTY); [EOL]     this.name = propertyName; [EOL] }
public Object getImmediateNode() { [EOL]     String name = getPropertyName(); [EOL]     if (name.equals("*")) { [EOL]         return null; [EOL]     } [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(dynaBean.get(name)); [EOL]     } else if (isIndexedProperty()) { [EOL]         try { [EOL]             value = ValueUtils.getValue(dynaBean.get(name, index)); [EOL]         } catch (ArrayIndexOutOfBoundsException ex) { [EOL]             value = null; [EOL]         } catch (IllegalArgumentException ex) { [EOL]             value = dynaBean.get(name); [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } [EOL]     } else { [EOL]         value = dynaBean.get(name); [EOL]         if (ValueUtils.isCollection(value)) { [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } else if (index != 0) { [EOL]             value = null; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     String name = getPropertyName(); [EOL]     if (name.equals("*")) { [EOL]         return null; [EOL]     } [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(dynaBean.get(name)); [EOL]     } else if (isIndexedProperty()) { [EOL]         try { [EOL]             value = ValueUtils.getValue(dynaBean.get(name, index)); [EOL]         } catch (ArrayIndexOutOfBoundsException ex) { [EOL]             value = null; [EOL]         } catch (IllegalArgumentException ex) { [EOL]             value = dynaBean.get(name); [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } [EOL]     } else { [EOL]         value = dynaBean.get(name); [EOL]         if (ValueUtils.isCollection(value)) { [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } else if (index != 0) { [EOL]             value = null; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     String name = getPropertyName(); [EOL]     if (name.equals("*")) { [EOL]         return null; [EOL]     } [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(dynaBean.get(name)); [EOL]     } else if (isIndexedProperty()) { [EOL]         try { [EOL]             value = ValueUtils.getValue(dynaBean.get(name, index)); [EOL]         } catch (ArrayIndexOutOfBoundsException ex) { [EOL]             value = null; [EOL]         } catch (IllegalArgumentException ex) { [EOL]             value = dynaBean.get(name); [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } [EOL]     } else { [EOL]         value = dynaBean.get(name); [EOL]         if (ValueUtils.isCollection(value)) { [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } else if (index != 0) { [EOL]             value = null; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     String name = getPropertyName(); [EOL]     if (name.equals("*")) { [EOL]         return null; [EOL]     } [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(dynaBean.get(name)); [EOL]     } else if (isIndexedProperty()) { [EOL]         try { [EOL]             value = ValueUtils.getValue(dynaBean.get(name, index)); [EOL]         } catch (ArrayIndexOutOfBoundsException ex) { [EOL]             value = null; [EOL]         } catch (IllegalArgumentException ex) { [EOL]             value = dynaBean.get(name); [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } [EOL]     } else { [EOL]         value = dynaBean.get(name); [EOL]         if (ValueUtils.isCollection(value)) { [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } else if (index != 0) { [EOL]             value = null; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     String name = getPropertyName(); [EOL]     if (name.equals("*")) { [EOL]         return null; [EOL]     } [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(dynaBean.get(name)); [EOL]     } else if (isIndexedProperty()) { [EOL]         try { [EOL]             value = ValueUtils.getValue(dynaBean.get(name, index)); [EOL]         } catch (ArrayIndexOutOfBoundsException ex) { [EOL]             value = null; [EOL]         } catch (IllegalArgumentException ex) { [EOL]             value = dynaBean.get(name); [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } [EOL]     } else { [EOL]         value = dynaBean.get(name); [EOL]         if (ValueUtils.isCollection(value)) { [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } else if (index != 0) { [EOL]             value = null; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     String name = getPropertyName(); [EOL]     if (name.equals("*")) { [EOL]         return null; [EOL]     } [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(dynaBean.get(name)); [EOL]     } else if (isIndexedProperty()) { [EOL]         try { [EOL]             value = ValueUtils.getValue(dynaBean.get(name, index)); [EOL]         } catch (ArrayIndexOutOfBoundsException ex) { [EOL]             value = null; [EOL]         } catch (IllegalArgumentException ex) { [EOL]             value = dynaBean.get(name); [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } [EOL]     } else { [EOL]         value = dynaBean.get(name); [EOL]         if (ValueUtils.isCollection(value)) { [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } else if (index != 0) { [EOL]             value = null; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     String name = getPropertyName(); [EOL]     if (name.equals("*")) { [EOL]         return null; [EOL]     } [EOL]     Object value; [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         value = ValueUtils.getValue(dynaBean.get(name)); [EOL]     } else if (isIndexedProperty()) { [EOL]         try { [EOL]             value = ValueUtils.getValue(dynaBean.get(name, index)); [EOL]         } catch (ArrayIndexOutOfBoundsException ex) { [EOL]             value = null; [EOL]         } catch (IllegalArgumentException ex) { [EOL]             value = dynaBean.get(name); [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } [EOL]     } else { [EOL]         value = dynaBean.get(name); [EOL]         if (ValueUtils.isCollection(value)) { [EOL]             value = ValueUtils.getValue(value, index); [EOL]         } else if (index != 0) { [EOL]             value = null; [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
protected boolean isActualProperty() { [EOL]     DynaClass dynaClass = dynaBean.getDynaClass(); [EOL]     return dynaClass.getDynaProperty(getPropertyName()) != null; [EOL] }
protected boolean isIndexedProperty() { [EOL]     DynaClass dynaClass = dynaBean.getDynaClass(); [EOL]     DynaProperty property = dynaClass.getDynaProperty(name); [EOL]     return property.isIndexed(); [EOL] }
protected boolean isIndexedProperty() { [EOL]     DynaClass dynaClass = dynaBean.getDynaClass(); [EOL]     DynaProperty property = dynaClass.getDynaProperty(name); [EOL]     return property.isIndexed(); [EOL] }
public void setValue(Object value) { [EOL]     setValue(index, value); [EOL] }
public void setValue(Object value) { [EOL]     setValue(index, value); [EOL] }
public void remove() { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         dynaBean.set(getPropertyName(), null); [EOL]     } else if (isIndexedProperty()) { [EOL]         dynaBean.set(getPropertyName(), index, null); [EOL]     } else if (isCollection()) { [EOL]         Object collection = ValueUtils.remove(getBaseValue(), index); [EOL]         dynaBean.set(getPropertyName(), collection); [EOL]     } else if (index == 0) { [EOL]         dynaBean.set(getPropertyName(), null); [EOL]     } [EOL] }
public void remove() { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         dynaBean.set(getPropertyName(), null); [EOL]     } else if (isIndexedProperty()) { [EOL]         dynaBean.set(getPropertyName(), index, null); [EOL]     } else if (isCollection()) { [EOL]         Object collection = ValueUtils.remove(getBaseValue(), index); [EOL]         dynaBean.set(getPropertyName(), collection); [EOL]     } else if (index == 0) { [EOL]         dynaBean.set(getPropertyName(), null); [EOL]     } [EOL] }
public void remove() { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         dynaBean.set(getPropertyName(), null); [EOL]     } else if (isIndexedProperty()) { [EOL]         dynaBean.set(getPropertyName(), index, null); [EOL]     } else if (isCollection()) { [EOL]         Object collection = ValueUtils.remove(getBaseValue(), index); [EOL]         dynaBean.set(getPropertyName(), collection); [EOL]     } else if (index == 0) { [EOL]         dynaBean.set(getPropertyName(), null); [EOL]     } [EOL] }
public void remove() { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         dynaBean.set(getPropertyName(), null); [EOL]     } else if (isIndexedProperty()) { [EOL]         dynaBean.set(getPropertyName(), index, null); [EOL]     } else if (isCollection()) { [EOL]         Object collection = ValueUtils.remove(getBaseValue(), index); [EOL]         dynaBean.set(getPropertyName(), collection); [EOL]     } else if (index == 0) { [EOL]         dynaBean.set(getPropertyName(), null); [EOL]     } [EOL] }
private void setValue(int index, Object value) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         dynaBean.set(getPropertyName(), convert(value, false)); [EOL]     } else if (isIndexedProperty()) { [EOL]         dynaBean.set(getPropertyName(), index, convert(value, true)); [EOL]     } else { [EOL]         Object baseValue = dynaBean.get(getPropertyName()); [EOL]         ValueUtils.setValue(baseValue, index, value); [EOL]     } [EOL] }
private void setValue(int index, Object value) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         dynaBean.set(getPropertyName(), convert(value, false)); [EOL]     } else if (isIndexedProperty()) { [EOL]         dynaBean.set(getPropertyName(), index, convert(value, true)); [EOL]     } else { [EOL]         Object baseValue = dynaBean.get(getPropertyName()); [EOL]         ValueUtils.setValue(baseValue, index, value); [EOL]     } [EOL] }
private void setValue(int index, Object value) { [EOL]     if (index == WHOLE_COLLECTION) { [EOL]         dynaBean.set(getPropertyName(), convert(value, false)); [EOL]     } else if (isIndexedProperty()) { [EOL]         dynaBean.set(getPropertyName(), index, convert(value, true)); [EOL]     } else { [EOL]         Object baseValue = dynaBean.get(getPropertyName()); [EOL]         ValueUtils.setValue(baseValue, index, value); [EOL]     } [EOL] }
private Object convert(Object value, boolean element) { [EOL]     DynaClass dynaClass = (DynaClass) dynaBean.getDynaClass(); [EOL]     DynaProperty property = dynaClass.getDynaProperty(getPropertyName()); [EOL]     Class type = property.getType(); [EOL]     if (element) { [EOL]         if (type.isArray()) { [EOL]             type = type.getComponentType(); [EOL]         } else { [EOL]             return value; [EOL]         } [EOL]     } [EOL]     try { [EOL]         return TypeUtils.convert(value, type); [EOL]     } catch (Exception ex) { [EOL]         String string = value == null ? "null" : value.getClass().getName(); [EOL]         throw new JXPathTypeConversionException("Cannot convert value of class " + string + " to type " + type, ex); [EOL]     } [EOL] }
public Object computeValue(EvalContext context) { [EOL]     double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); [EOL]     double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); [EOL]     return new Double(l * r); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); [EOL]     double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); [EOL]     return new Double(l * r); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); [EOL]     double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); [EOL]     return new Double(l * r); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     long l = (long) InfoSetUtil.doubleValue(args[0].computeValue(context)); [EOL]     long r = (long) InfoSetUtil.doubleValue(args[1].computeValue(context)); [EOL]     return new Double(l % r); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     long l = (long) InfoSetUtil.doubleValue(args[0].computeValue(context)); [EOL]     long r = (long) InfoSetUtil.doubleValue(args[1].computeValue(context)); [EOL]     return new Double(l % r); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     long l = (long) InfoSetUtil.doubleValue(args[0].computeValue(context)); [EOL]     long r = (long) InfoSetUtil.doubleValue(args[1].computeValue(context)); [EOL]     return new Double(l % r); [EOL] }
public boolean isContextDependent() { [EOL]     if (predicates != null) { [EOL]         for (int i = 0; i < predicates.length; i++) { [EOL]             if (predicates[i].isContextDependent()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean isContextDependent() { [EOL]     if (predicates != null) { [EOL]         for (int i = 0; i < predicates.length; i++) { [EOL]             if (predicates[i].isContextDependent()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean isContextDependent() { [EOL]     if (predicates != null) { [EOL]         for (int i = 0; i < predicates.length; i++) { [EOL]             if (predicates[i].isContextDependent()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean isContextDependent() { [EOL]     if (predicates != null) { [EOL]         for (int i = 0; i < predicates.length; i++) { [EOL]             if (predicates[i].isContextDependent()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public void registerNamespace(String prefix, String namespaceURI) { [EOL]     namespaceMap.put(prefix, namespaceURI); [EOL]     reverseMap = null; [EOL] }
public void registerNamespace(String prefix, String namespaceURI) { [EOL]     namespaceMap.put(prefix, namespaceURI); [EOL]     reverseMap = null; [EOL] }
public void registerNamespace(String prefix, String namespaceURI) { [EOL]     namespaceMap.put(prefix, namespaceURI); [EOL]     reverseMap = null; [EOL] }
public boolean isSealed() { [EOL]     return sealed; [EOL] }
public Object clone() { [EOL]     try { [EOL]         return super.clone(); [EOL]     } catch (CloneNotSupportedException e) { [EOL]         e.printStackTrace(); [EOL]         return null; [EOL]     } [EOL] }
public Object clone() { [EOL]     try { [EOL]         return super.clone(); [EOL]     } catch (CloneNotSupportedException e) { [EOL]         e.printStackTrace(); [EOL]         return null; [EOL]     } [EOL] }
public void setFactory(AbstractFactory factory) { [EOL]     this.factory = factory; [EOL] }
public void setFactory(AbstractFactory factory) { [EOL]     this.factory = factory; [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     if (test == null) { [EOL]         return createNodeIterator(null, reverse, startWith); [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String property; [EOL]         if (!isDefaultNamespace(testName.getPrefix())) { [EOL]             return null; [EOL]         } else if (nodeNameTest.isWildcard()) { [EOL]             property = null; [EOL]         } else { [EOL]             property = testName.getName(); [EOL]         } [EOL]         return createNodeIterator(property, reverse, startWith); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return createNodeIterator(null, reverse, startWith); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     if (test == null) { [EOL]         return createNodeIterator(null, reverse, startWith); [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String property; [EOL]         if (!isDefaultNamespace(testName.getPrefix())) { [EOL]             return null; [EOL]         } else if (nodeNameTest.isWildcard()) { [EOL]             property = null; [EOL]         } else { [EOL]             property = testName.getName(); [EOL]         } [EOL]         return createNodeIterator(property, reverse, startWith); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return createNodeIterator(null, reverse, startWith); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     if (test == null) { [EOL]         return createNodeIterator(null, reverse, startWith); [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String property; [EOL]         if (!isDefaultNamespace(testName.getPrefix())) { [EOL]             return null; [EOL]         } else if (nodeNameTest.isWildcard()) { [EOL]             property = null; [EOL]         } else { [EOL]             property = testName.getName(); [EOL]         } [EOL]         return createNodeIterator(property, reverse, startWith); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return createNodeIterator(null, reverse, startWith); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     if (test == null) { [EOL]         return createNodeIterator(null, reverse, startWith); [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String property; [EOL]         if (!isDefaultNamespace(testName.getPrefix())) { [EOL]             return null; [EOL]         } else if (nodeNameTest.isWildcard()) { [EOL]             property = null; [EOL]         } else { [EOL]             property = testName.getName(); [EOL]         } [EOL]         return createNodeIterator(property, reverse, startWith); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return createNodeIterator(null, reverse, startWith); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     if (test == null) { [EOL]         return createNodeIterator(null, reverse, startWith); [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String property; [EOL]         if (!isDefaultNamespace(testName.getPrefix())) { [EOL]             return null; [EOL]         } else if (nodeNameTest.isWildcard()) { [EOL]             property = null; [EOL]         } else { [EOL]             property = testName.getName(); [EOL]         } [EOL]         return createNodeIterator(property, reverse, startWith); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return createNodeIterator(null, reverse, startWith); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     if (test == null) { [EOL]         return createNodeIterator(null, reverse, startWith); [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String property; [EOL]         if (!isDefaultNamespace(testName.getPrefix())) { [EOL]             return null; [EOL]         } else if (nodeNameTest.isWildcard()) { [EOL]             property = null; [EOL]         } else { [EOL]             property = testName.getName(); [EOL]         } [EOL]         return createNodeIterator(property, reverse, startWith); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return createNodeIterator(null, reverse, startWith); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected PropertyOwnerPointer(NodePointer parent) { [EOL]     super(parent); [EOL] }
public Object getImmediateNode() { [EOL]     if (value == UNINITIALIZED) { [EOL]         if (index == WHOLE_COLLECTION) { [EOL]             value = ValueUtils.getValue(getBaseValue()); [EOL]         } else { [EOL]             value = ValueUtils.getValue(getBaseValue(), index); [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     if (value == UNINITIALIZED) { [EOL]         if (index == WHOLE_COLLECTION) { [EOL]             value = ValueUtils.getValue(getBaseValue()); [EOL]         } else { [EOL]             value = ValueUtils.getValue(getBaseValue(), index); [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public Object getImmediateNode() { [EOL]     if (value == UNINITIALIZED) { [EOL]         if (index == WHOLE_COLLECTION) { [EOL]             value = ValueUtils.getValue(getBaseValue()); [EOL]         } else { [EOL]             value = ValueUtils.getValue(getBaseValue(), index); [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2) { [EOL]     int r = pointer1.getName().toString().compareTo(pointer2.getName().toString()); [EOL]     if (r != 0) { [EOL]         return r; [EOL]     } [EOL]     return pointer1.getIndex() - pointer2.getIndex(); [EOL] }
public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2) { [EOL]     int r = pointer1.getName().toString().compareTo(pointer2.getName().toString()); [EOL]     if (r != 0) { [EOL]         return r; [EOL]     } [EOL]     return pointer1.getIndex() - pointer2.getIndex(); [EOL] }
public int compareChildNodePointers(NodePointer pointer1, NodePointer pointer2) { [EOL]     int r = pointer1.getName().toString().compareTo(pointer2.getName().toString()); [EOL]     if (r != 0) { [EOL]         return r; [EOL]     } [EOL]     return pointer1.getIndex() - pointer2.getIndex(); [EOL] }
private void collectNamespaces(Element element) { [EOL]     Namespace ns = element.getNamespace(); [EOL]     if (ns != null && !prefixes.contains(ns.getPrefix())) { [EOL]         namespaces.add(ns); [EOL]         prefixes.add(ns.getPrefix()); [EOL]     } [EOL]     List others = element.getAdditionalNamespaces(); [EOL]     for (int i = 0; i < others.size(); i++) { [EOL]         ns = (Namespace) others.get(i); [EOL]         if (ns != null && !prefixes.contains(ns.getPrefix())) { [EOL]             namespaces.add(ns); [EOL]             prefixes.add(ns.getPrefix()); [EOL]         } [EOL]     } [EOL]     Object parent = element.getParent(); [EOL]     if (parent instanceof Element) { [EOL]         collectNamespaces((Element) parent); [EOL]     } [EOL] }
private void collectNamespaces(Element element) { [EOL]     Namespace ns = element.getNamespace(); [EOL]     if (ns != null && !prefixes.contains(ns.getPrefix())) { [EOL]         namespaces.add(ns); [EOL]         prefixes.add(ns.getPrefix()); [EOL]     } [EOL]     List others = element.getAdditionalNamespaces(); [EOL]     for (int i = 0; i < others.size(); i++) { [EOL]         ns = (Namespace) others.get(i); [EOL]         if (ns != null && !prefixes.contains(ns.getPrefix())) { [EOL]             namespaces.add(ns); [EOL]             prefixes.add(ns.getPrefix()); [EOL]         } [EOL]     } [EOL]     Object parent = element.getParent(); [EOL]     if (parent instanceof Element) { [EOL]         collectNamespaces((Element) parent); [EOL]     } [EOL] }
private void collectNamespaces(Element element) { [EOL]     Namespace ns = element.getNamespace(); [EOL]     if (ns != null && !prefixes.contains(ns.getPrefix())) { [EOL]         namespaces.add(ns); [EOL]         prefixes.add(ns.getPrefix()); [EOL]     } [EOL]     List others = element.getAdditionalNamespaces(); [EOL]     for (int i = 0; i < others.size(); i++) { [EOL]         ns = (Namespace) others.get(i); [EOL]         if (ns != null && !prefixes.contains(ns.getPrefix())) { [EOL]             namespaces.add(ns); [EOL]             prefixes.add(ns.getPrefix()); [EOL]         } [EOL]     } [EOL]     Object parent = element.getParent(); [EOL]     if (parent instanceof Element) { [EOL]         collectNamespaces((Element) parent); [EOL]     } [EOL] }
private void collectNamespaces(Element element) { [EOL]     Namespace ns = element.getNamespace(); [EOL]     if (ns != null && !prefixes.contains(ns.getPrefix())) { [EOL]         namespaces.add(ns); [EOL]         prefixes.add(ns.getPrefix()); [EOL]     } [EOL]     List others = element.getAdditionalNamespaces(); [EOL]     for (int i = 0; i < others.size(); i++) { [EOL]         ns = (Namespace) others.get(i); [EOL]         if (ns != null && !prefixes.contains(ns.getPrefix())) { [EOL]             namespaces.add(ns); [EOL]             prefixes.add(ns.getPrefix()); [EOL]         } [EOL]     } [EOL]     Object parent = element.getParent(); [EOL]     if (parent instanceof Element) { [EOL]         collectNamespaces((Element) parent); [EOL]     } [EOL] }
public DescendantContext(EvalContext parentContext, boolean includeSelf, NodeTest nodeTest) { [EOL]     super(parentContext); [EOL]     this.includeSelf = includeSelf; [EOL]     this.nodeTest = nodeTest; [EOL] }
public DescendantContext(EvalContext parentContext, boolean includeSelf, NodeTest nodeTest) { [EOL]     super(parentContext); [EOL]     this.includeSelf = includeSelf; [EOL]     this.nodeTest = nodeTest; [EOL] }
public NodePointer getCurrentNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     return currentNodePointer; [EOL] }
public NodePointer getCurrentNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     return currentNodePointer; [EOL] }
public NodePointer getCurrentNodePointer() { [EOL]     if (position == 0) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]     } [EOL]     return currentNodePointer; [EOL] }
public void reset() { [EOL]     super.reset(); [EOL]     setStarted = false; [EOL] }
public boolean nextNode() { [EOL]     if (!setStarted) { [EOL]         setStarted = true; [EOL]         stack = new Stack(); [EOL]         currentNodePointer = parentContext.getCurrentNodePointer(); [EOL]         if (currentNodePointer != null) { [EOL]             if (!currentNodePointer.isLeaf()) { [EOL]                 stack.push(currentNodePointer.childIterator(ELEMENT_NODE_TEST, false, null)); [EOL]             } [EOL]             if (includeSelf) { [EOL]                 if (currentNodePointer.testNode(nodeTest)) { [EOL]                     position++; [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     while (!stack.isEmpty()) { [EOL]         NodeIterator it = (NodeIterator) stack.peek(); [EOL]         if (it.setPosition(it.getPosition() + 1)) { [EOL]             currentNodePointer = it.getNodePointer(); [EOL]             if (!isRecursive()) { [EOL]                 if (!currentNodePointer.isLeaf()) { [EOL]                     stack.push(currentNodePointer.childIterator(ELEMENT_NODE_TEST, false, null)); [EOL]                 } [EOL]                 if (currentNodePointer.testNode(nodeTest)) { [EOL]                     position++; [EOL]                     return true; [EOL]                 } [EOL]             } [EOL]         } else { [EOL]             stack.pop(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean isRecursive() { [EOL]     Object node = currentNodePointer.getNode(); [EOL]     for (int i = stack.size() - 1; --i >= 0; ) { [EOL]         NodeIterator it = (NodeIterator) stack.get(i); [EOL]         Pointer pointer = it.getNodePointer(); [EOL]         if (pointer != null && pointer.getNode() == node) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean isRecursive() { [EOL]     Object node = currentNodePointer.getNode(); [EOL]     for (int i = stack.size() - 1; --i >= 0; ) { [EOL]         NodeIterator it = (NodeIterator) stack.get(i); [EOL]         Pointer pointer = it.getNodePointer(); [EOL]         if (pointer != null && pointer.getNode() == node) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private boolean isRecursive() { [EOL]     Object node = currentNodePointer.getNode(); [EOL]     for (int i = stack.size() - 1; --i >= 0; ) { [EOL]         NodeIterator it = (NodeIterator) stack.get(i); [EOL]         Pointer pointer = it.getNodePointer(); [EOL]         if (pointer != null && pointer.getNode() == node) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public NamespaceContext(EvalContext parentContext, NodeTest nodeTest) { [EOL]     super(parentContext); [EOL]     this.nodeTest = nodeTest; [EOL] }
public NamespaceContext(EvalContext parentContext, NodeTest nodeTest) { [EOL]     super(parentContext); [EOL]     this.nodeTest = nodeTest; [EOL] }
public NamespaceContext(EvalContext parentContext, NodeTest nodeTest) { [EOL]     super(parentContext); [EOL]     this.nodeTest = nodeTest; [EOL] }
public NamespaceContext(EvalContext parentContext, NodeTest nodeTest) { [EOL]     super(parentContext); [EOL]     this.nodeTest = nodeTest; [EOL] }
public boolean nextNode() { [EOL]     super.setPosition(getCurrentPosition() + 1); [EOL]     if (!setStarted) { [EOL]         setStarted = true; [EOL]         if (!(nodeTest instanceof NodeNameTest)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) nodeTest; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         if (testName.getPrefix() != null) { [EOL]             return false; [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             iterator = parentContext.getCurrentNodePointer().namespaceIterator(); [EOL]         } else { [EOL]             currentNodePointer = parentContext.getCurrentNodePointer().namespacePointer(testName.getName()); [EOL]             return currentNodePointer != null; [EOL]         } [EOL]     } [EOL]     if (iterator == null) { [EOL]         return false; [EOL]     } [EOL]     if (!iterator.setPosition(iterator.getPosition() + 1)) { [EOL]         return false; [EOL]     } [EOL]     currentNodePointer = iterator.getNodePointer(); [EOL]     return true; [EOL] }
public boolean nextNode() { [EOL]     super.setPosition(getCurrentPosition() + 1); [EOL]     if (!setStarted) { [EOL]         setStarted = true; [EOL]         if (!(nodeTest instanceof NodeNameTest)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) nodeTest; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         if (testName.getPrefix() != null) { [EOL]             return false; [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             iterator = parentContext.getCurrentNodePointer().namespaceIterator(); [EOL]         } else { [EOL]             currentNodePointer = parentContext.getCurrentNodePointer().namespacePointer(testName.getName()); [EOL]             return currentNodePointer != null; [EOL]         } [EOL]     } [EOL]     if (iterator == null) { [EOL]         return false; [EOL]     } [EOL]     if (!iterator.setPosition(iterator.getPosition() + 1)) { [EOL]         return false; [EOL]     } [EOL]     currentNodePointer = iterator.getNodePointer(); [EOL]     return true; [EOL] }
public boolean nextNode() { [EOL]     super.setPosition(getCurrentPosition() + 1); [EOL]     if (!setStarted) { [EOL]         setStarted = true; [EOL]         if (!(nodeTest instanceof NodeNameTest)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) nodeTest; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         if (testName.getPrefix() != null) { [EOL]             return false; [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             iterator = parentContext.getCurrentNodePointer().namespaceIterator(); [EOL]         } else { [EOL]             currentNodePointer = parentContext.getCurrentNodePointer().namespacePointer(testName.getName()); [EOL]             return currentNodePointer != null; [EOL]         } [EOL]     } [EOL]     if (iterator == null) { [EOL]         return false; [EOL]     } [EOL]     if (!iterator.setPosition(iterator.getPosition() + 1)) { [EOL]         return false; [EOL]     } [EOL]     currentNodePointer = iterator.getNodePointer(); [EOL]     return true; [EOL] }
public boolean nextNode() { [EOL]     super.setPosition(getCurrentPosition() + 1); [EOL]     if (!setStarted) { [EOL]         setStarted = true; [EOL]         if (!(nodeTest instanceof NodeNameTest)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) nodeTest; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         if (testName.getPrefix() != null) { [EOL]             return false; [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             iterator = parentContext.getCurrentNodePointer().namespaceIterator(); [EOL]         } else { [EOL]             currentNodePointer = parentContext.getCurrentNodePointer().namespacePointer(testName.getName()); [EOL]             return currentNodePointer != null; [EOL]         } [EOL]     } [EOL]     if (iterator == null) { [EOL]         return false; [EOL]     } [EOL]     if (!iterator.setPosition(iterator.getPosition() + 1)) { [EOL]         return false; [EOL]     } [EOL]     currentNodePointer = iterator.getNodePointer(); [EOL]     return true; [EOL] }
public boolean nextNode() { [EOL]     super.setPosition(getCurrentPosition() + 1); [EOL]     if (!setStarted) { [EOL]         setStarted = true; [EOL]         if (!(nodeTest instanceof NodeNameTest)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) nodeTest; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         if (testName.getPrefix() != null) { [EOL]             return false; [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             iterator = parentContext.getCurrentNodePointer().namespaceIterator(); [EOL]         } else { [EOL]             currentNodePointer = parentContext.getCurrentNodePointer().namespacePointer(testName.getName()); [EOL]             return currentNodePointer != null; [EOL]         } [EOL]     } [EOL]     if (iterator == null) { [EOL]         return false; [EOL]     } [EOL]     if (!iterator.setPosition(iterator.getPosition() + 1)) { [EOL]         return false; [EOL]     } [EOL]     currentNodePointer = iterator.getNodePointer(); [EOL]     return true; [EOL] }
public boolean nextNode() { [EOL]     super.setPosition(getCurrentPosition() + 1); [EOL]     if (!setStarted) { [EOL]         setStarted = true; [EOL]         if (!(nodeTest instanceof NodeNameTest)) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) nodeTest; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         if (testName.getPrefix() != null) { [EOL]             return false; [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             iterator = parentContext.getCurrentNodePointer().namespaceIterator(); [EOL]         } else { [EOL]             currentNodePointer = parentContext.getCurrentNodePointer().namespacePointer(testName.getName()); [EOL]             return currentNodePointer != null; [EOL]         } [EOL]     } [EOL]     if (iterator == null) { [EOL]         return false; [EOL]     } [EOL]     if (!iterator.setPosition(iterator.getPosition() + 1)) { [EOL]         return false; [EOL]     } [EOL]     currentNodePointer = iterator.getNodePointer(); [EOL]     return true; [EOL] }
public boolean computeContextDependent() { [EOL]     if (steps != null) { [EOL]         for (int i = 0; i < steps.length; i++) { [EOL]             if (steps[i].isContextDependent()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean computeContextDependent() { [EOL]     if (steps != null) { [EOL]         for (int i = 0; i < steps.length; i++) { [EOL]             if (steps[i].isContextDependent()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean computeContextDependent() { [EOL]     if (steps != null) { [EOL]         for (int i = 0; i < steps.length; i++) { [EOL]             if (steps[i].isContextDependent()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean computeContextDependent() { [EOL]     if (steps != null) { [EOL]         for (int i = 0; i < steps.length; i++) { [EOL]             if (steps[i].isContextDependent()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean isSimplePath() { [EOL]     if (!basicKnown) { [EOL]         basicKnown = true; [EOL]         basic = true; [EOL]         Step[] steps = getSteps(); [EOL]         for (int i = 0; i < steps.length; i++) { [EOL]             if (!isSimpleStep(steps[i])) { [EOL]                 basic = false; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return basic; [EOL] }
public boolean isSimplePath() { [EOL]     if (!basicKnown) { [EOL]         basicKnown = true; [EOL]         basic = true; [EOL]         Step[] steps = getSteps(); [EOL]         for (int i = 0; i < steps.length; i++) { [EOL]             if (!isSimpleStep(steps[i])) { [EOL]                 basic = false; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return basic; [EOL] }
public boolean isSimplePath() { [EOL]     if (!basicKnown) { [EOL]         basicKnown = true; [EOL]         basic = true; [EOL]         Step[] steps = getSteps(); [EOL]         for (int i = 0; i < steps.length; i++) { [EOL]             if (!isSimpleStep(steps[i])) { [EOL]                 basic = false; [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return basic; [EOL] }
protected boolean isSimpleStep(Step step) { [EOL]     if (step.getAxis() == Compiler.AXIS_SELF) { [EOL]         NodeTest nodeTest = step.getNodeTest(); [EOL]         if (!(nodeTest instanceof NodeTypeTest)) { [EOL]             return false; [EOL]         } [EOL]         int nodeType = ((NodeTypeTest) nodeTest).getNodeType(); [EOL]         if (nodeType != Compiler.NODE_TYPE_NODE) { [EOL]             return false; [EOL]         } [EOL]         return areBasicPredicates(step.getPredicates()); [EOL]     } else if (step.getAxis() == Compiler.AXIS_CHILD || step.getAxis() == Compiler.AXIS_ATTRIBUTE) { [EOL]         NodeTest nodeTest = step.getNodeTest(); [EOL]         if (!(nodeTest instanceof NodeNameTest)) { [EOL]             return false; [EOL]         } [EOL]         if (((NodeNameTest) nodeTest).isWildcard()) { [EOL]             return false; [EOL]         } [EOL]         return areBasicPredicates(step.getPredicates()); [EOL]     } [EOL]     return false; [EOL] }
protected boolean areBasicPredicates(Expression[] predicates) { [EOL]     if (predicates != null && predicates.length != 0) { [EOL]         boolean firstIndex = true; [EOL]         for (int i = 0; i < predicates.length; i++) { [EOL]             if (predicates[i] instanceof NameAttributeTest) { [EOL]                 if (((NameAttributeTest) predicates[i]).getNameTestExpression().isContextDependent()) { [EOL]                     return false; [EOL]                 } [EOL]             } else if (predicates[i].isContextDependent()) { [EOL]                 return false; [EOL]             } else { [EOL]                 if (!firstIndex) { [EOL]                     return false; [EOL]                 } [EOL]                 firstIndex = false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
protected boolean areBasicPredicates(Expression[] predicates) { [EOL]     if (predicates != null && predicates.length != 0) { [EOL]         boolean firstIndex = true; [EOL]         for (int i = 0; i < predicates.length; i++) { [EOL]             if (predicates[i] instanceof NameAttributeTest) { [EOL]                 if (((NameAttributeTest) predicates[i]).getNameTestExpression().isContextDependent()) { [EOL]                     return false; [EOL]                 } [EOL]             } else if (predicates[i].isContextDependent()) { [EOL]                 return false; [EOL]             } else { [EOL]                 if (!firstIndex) { [EOL]                     return false; [EOL]                 } [EOL]                 firstIndex = false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
protected Pointer getSingleNodePointerForSteps(EvalContext context) { [EOL]     if (steps.length == 0) { [EOL]         return context.getSingleNodePointer(); [EOL]     } [EOL]     if (isSimplePath()) { [EOL]         NodePointer ptr = (NodePointer) context.getSingleNodePointer(); [EOL]         return SimplePathInterpreter.interpretSimpleLocationPath(context, ptr, steps); [EOL]     } else { [EOL]         return searchForPath(context); [EOL]     } [EOL] }
protected Pointer getSingleNodePointerForSteps(EvalContext context) { [EOL]     if (steps.length == 0) { [EOL]         return context.getSingleNodePointer(); [EOL]     } [EOL]     if (isSimplePath()) { [EOL]         NodePointer ptr = (NodePointer) context.getSingleNodePointer(); [EOL]         return SimplePathInterpreter.interpretSimpleLocationPath(context, ptr, steps); [EOL]     } else { [EOL]         return searchForPath(context); [EOL]     } [EOL] }
protected Pointer getSingleNodePointerForSteps(EvalContext context) { [EOL]     if (steps.length == 0) { [EOL]         return context.getSingleNodePointer(); [EOL]     } [EOL]     if (isSimplePath()) { [EOL]         NodePointer ptr = (NodePointer) context.getSingleNodePointer(); [EOL]         return SimplePathInterpreter.interpretSimpleLocationPath(context, ptr, steps); [EOL]     } else { [EOL]         return searchForPath(context); [EOL]     } [EOL] }
private Pointer searchForPath(EvalContext context) { [EOL]     EvalContext ctx = buildContextChain(context, steps.length, true); [EOL]     Pointer pointer = ctx.getSingleNodePointer(); [EOL]     if (pointer != null) { [EOL]         return pointer; [EOL]     } [EOL]     for (int i = steps.length; --i > 0; ) { [EOL]         if (!isSimpleStep(steps[i])) { [EOL]             return null; [EOL]         } [EOL]         ctx = buildContextChain(context, i, true); [EOL]         if (ctx.hasNext()) { [EOL]             Pointer partial = (Pointer) ctx.next(); [EOL]             if (ctx.hasNext()) { [EOL]                 return null; [EOL]             } [EOL]             if (partial instanceof NodePointer) { [EOL]                 return SimplePathInterpreter.createNullPointer(context, (NodePointer) partial, steps, i); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private Pointer searchForPath(EvalContext context) { [EOL]     EvalContext ctx = buildContextChain(context, steps.length, true); [EOL]     Pointer pointer = ctx.getSingleNodePointer(); [EOL]     if (pointer != null) { [EOL]         return pointer; [EOL]     } [EOL]     for (int i = steps.length; --i > 0; ) { [EOL]         if (!isSimpleStep(steps[i])) { [EOL]             return null; [EOL]         } [EOL]         ctx = buildContextChain(context, i, true); [EOL]         if (ctx.hasNext()) { [EOL]             Pointer partial = (Pointer) ctx.next(); [EOL]             if (ctx.hasNext()) { [EOL]                 return null; [EOL]             } [EOL]             if (partial instanceof NodePointer) { [EOL]                 return SimplePathInterpreter.createNullPointer(context, (NodePointer) partial, steps, i); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private Pointer searchForPath(EvalContext context) { [EOL]     EvalContext ctx = buildContextChain(context, steps.length, true); [EOL]     Pointer pointer = ctx.getSingleNodePointer(); [EOL]     if (pointer != null) { [EOL]         return pointer; [EOL]     } [EOL]     for (int i = steps.length; --i > 0; ) { [EOL]         if (!isSimpleStep(steps[i])) { [EOL]             return null; [EOL]         } [EOL]         ctx = buildContextChain(context, i, true); [EOL]         if (ctx.hasNext()) { [EOL]             Pointer partial = (Pointer) ctx.next(); [EOL]             if (ctx.hasNext()) { [EOL]                 return null; [EOL]             } [EOL]             if (partial instanceof NodePointer) { [EOL]                 return SimplePathInterpreter.createNullPointer(context, (NodePointer) partial, steps, i); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private Pointer searchForPath(EvalContext context) { [EOL]     EvalContext ctx = buildContextChain(context, steps.length, true); [EOL]     Pointer pointer = ctx.getSingleNodePointer(); [EOL]     if (pointer != null) { [EOL]         return pointer; [EOL]     } [EOL]     for (int i = steps.length; --i > 0; ) { [EOL]         if (!isSimpleStep(steps[i])) { [EOL]             return null; [EOL]         } [EOL]         ctx = buildContextChain(context, i, true); [EOL]         if (ctx.hasNext()) { [EOL]             Pointer partial = (Pointer) ctx.next(); [EOL]             if (ctx.hasNext()) { [EOL]                 return null; [EOL]             } [EOL]             if (partial instanceof NodePointer) { [EOL]                 return SimplePathInterpreter.createNullPointer(context, (NodePointer) partial, steps, i); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private Pointer searchForPath(EvalContext context) { [EOL]     EvalContext ctx = buildContextChain(context, steps.length, true); [EOL]     Pointer pointer = ctx.getSingleNodePointer(); [EOL]     if (pointer != null) { [EOL]         return pointer; [EOL]     } [EOL]     for (int i = steps.length; --i > 0; ) { [EOL]         if (!isSimpleStep(steps[i])) { [EOL]             return null; [EOL]         } [EOL]         ctx = buildContextChain(context, i, true); [EOL]         if (ctx.hasNext()) { [EOL]             Pointer partial = (Pointer) ctx.next(); [EOL]             if (ctx.hasNext()) { [EOL]                 return null; [EOL]             } [EOL]             if (partial instanceof NodePointer) { [EOL]                 return SimplePathInterpreter.createNullPointer(context, (NodePointer) partial, steps, i); [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private EvalContext buildContextChain(EvalContext context, int stepCount, boolean createInitialContext) { [EOL]     if (createInitialContext) { [EOL]         context = new InitialContext(context); [EOL]     } [EOL]     if (steps.length == 0) { [EOL]         return context; [EOL]     } [EOL]     for (int i = 0; i < stepCount; i++) { [EOL]         context = createContextForStep(context, steps[i].getAxis(), steps[i].getNodeTest()); [EOL]         Expression[] predicates = steps[i].getPredicates(); [EOL]         if (predicates != null) { [EOL]             for (int j = 0; j < predicates.length; j++) { [EOL]                 if (j != 0) { [EOL]                     context = new UnionContext(context, new EvalContext[] { context }); [EOL]                 } [EOL]                 context = new PredicateContext(context, predicates[j]); [EOL]             } [EOL]         } [EOL]     } [EOL]     return context; [EOL] }
protected EvalContext createContextForStep(EvalContext context, int axis, NodeTest nodeTest) { [EOL]     if (nodeTest instanceof NodeNameTest) { [EOL]         QName qname = ((NodeNameTest) nodeTest).getNodeName(); [EOL]         String prefix = qname.getPrefix(); [EOL]         String namespaceURI = prefix != null ? context.getJXPathContext().getNamespaceURI(prefix) : context.getJXPathContext().getDefaultNamespaceURI(); [EOL]         if (namespaceURI != null) { [EOL]             nodeTest = new NodeNameTest(qname, namespaceURI); [EOL]         } [EOL]     } [EOL]     switch(axis) { [EOL]         case Compiler.AXIS_ANCESTOR: [EOL]             return new AncestorContext(context, false, nodeTest); [EOL]         case Compiler.AXIS_ANCESTOR_OR_SELF: [EOL]             return new AncestorContext(context, true, nodeTest); [EOL]         case Compiler.AXIS_ATTRIBUTE: [EOL]             return new AttributeContext(context, nodeTest); [EOL]         case Compiler.AXIS_CHILD: [EOL]             return new ChildContext(context, nodeTest, false, false); [EOL]         case Compiler.AXIS_DESCENDANT: [EOL]             return new DescendantContext(context, false, nodeTest); [EOL]         case Compiler.AXIS_DESCENDANT_OR_SELF: [EOL]             return new DescendantContext(context, true, nodeTest); [EOL]         case Compiler.AXIS_FOLLOWING: [EOL]             return new PrecedingOrFollowingContext(context, nodeTest, false); [EOL]         case Compiler.AXIS_FOLLOWING_SIBLING: [EOL]             return new ChildContext(context, nodeTest, true, false); [EOL]         case Compiler.AXIS_NAMESPACE: [EOL]             return new NamespaceContext(context, nodeTest); [EOL]         case Compiler.AXIS_PARENT: [EOL]             return new ParentContext(context, nodeTest); [EOL]         case Compiler.AXIS_PRECEDING: [EOL]             return new PrecedingOrFollowingContext(context, nodeTest, true); [EOL]         case Compiler.AXIS_PRECEDING_SIBLING: [EOL]             return new ChildContext(context, nodeTest, true, true); [EOL]         case Compiler.AXIS_SELF: [EOL]             return new SelfContext(context, nodeTest); [EOL]     } [EOL]     return null; [EOL] }
public VariablePointer(Variables variables, QName name) { [EOL]     super(null); [EOL]     this.variables = variables; [EOL]     this.name = name; [EOL]     actual = true; [EOL] }
public Object getBaseValue() { [EOL]     if (!actual) { [EOL]         throw new JXPathException("Undefined variable: " + name); [EOL]     } [EOL]     return variables.getVariable(name.toString()); [EOL] }
public Object getBaseValue() { [EOL]     if (!actual) { [EOL]         throw new JXPathException("Undefined variable: " + name); [EOL]     } [EOL]     return variables.getVariable(name.toString()); [EOL] }
public boolean isLeaf() { [EOL]     Object value = getNode(); [EOL]     return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic(); [EOL] }
public boolean isLeaf() { [EOL]     Object value = getNode(); [EOL]     return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic(); [EOL] }
public boolean isLeaf() { [EOL]     Object value = getNode(); [EOL]     return value == null || JXPathIntrospector.getBeanInfo(value.getClass()).isAtomic(); [EOL] }
public Object getImmediateNode() { [EOL]     Object value = getBaseValue(); [EOL]     if (index != WHOLE_COLLECTION) { [EOL]         return ValueUtils.getValue(value, index); [EOL]     } else { [EOL]         return ValueUtils.getValue(value); [EOL]     } [EOL] }
public Object getImmediateNode() { [EOL]     Object value = getBaseValue(); [EOL]     if (index != WHOLE_COLLECTION) { [EOL]         return ValueUtils.getValue(value, index); [EOL]     } else { [EOL]         return ValueUtils.getValue(value); [EOL]     } [EOL] }
public void setValue(Object value) { [EOL]     if (!actual) { [EOL]         throw new JXPathException("Cannot set undefined variable: " + name); [EOL]     } [EOL]     valuePointer = null; [EOL]     if (index != WHOLE_COLLECTION) { [EOL]         Object collection = getBaseValue(); [EOL]         ValueUtils.setValue(collection, index, value); [EOL]     } else { [EOL]         variables.declareVariable(name.toString(), value); [EOL]     } [EOL] }
public void setValue(Object value) { [EOL]     if (!actual) { [EOL]         throw new JXPathException("Cannot set undefined variable: " + name); [EOL]     } [EOL]     valuePointer = null; [EOL]     if (index != WHOLE_COLLECTION) { [EOL]         Object collection = getBaseValue(); [EOL]         ValueUtils.setValue(collection, index, value); [EOL]     } else { [EOL]         variables.declareVariable(name.toString(), value); [EOL]     } [EOL] }
public void setValue(Object value) { [EOL]     if (!actual) { [EOL]         throw new JXPathException("Cannot set undefined variable: " + name); [EOL]     } [EOL]     valuePointer = null; [EOL]     if (index != WHOLE_COLLECTION) { [EOL]         Object collection = getBaseValue(); [EOL]         ValueUtils.setValue(collection, index, value); [EOL]     } else { [EOL]         variables.declareVariable(name.toString(), value); [EOL]     } [EOL] }
public boolean isActual() { [EOL]     return actual; [EOL] }
public NodePointer getImmediateValuePointer() { [EOL]     if (valuePointer == null) { [EOL]         Object value = null; [EOL]         if (actual) { [EOL]             value = getImmediateNode(); [EOL]             valuePointer = NodePointer.newChildNodePointer(this, null, value); [EOL]         } else { [EOL]             return new NullPointer(this, getName()) { [EOL]  [EOL]                 public Object getImmediateNode() { [EOL]                     throw new JXPathException("Undefined variable: " + name); [EOL]                 } [EOL]             }; [EOL]         } [EOL]     } [EOL]     return valuePointer; [EOL] }
public NodePointer getImmediateValuePointer() { [EOL]     if (valuePointer == null) { [EOL]         Object value = null; [EOL]         if (actual) { [EOL]             value = getImmediateNode(); [EOL]             valuePointer = NodePointer.newChildNodePointer(this, null, value); [EOL]         } else { [EOL]             return new NullPointer(this, getName()) { [EOL]  [EOL]                 public Object getImmediateNode() { [EOL]                     throw new JXPathException("Undefined variable: " + name); [EOL]                 } [EOL]             }; [EOL]         } [EOL]     } [EOL]     return valuePointer; [EOL] }
public NodePointer getImmediateValuePointer() { [EOL]     if (valuePointer == null) { [EOL]         Object value = null; [EOL]         if (actual) { [EOL]             value = getImmediateNode(); [EOL]             valuePointer = NodePointer.newChildNodePointer(this, null, value); [EOL]         } else { [EOL]             return new NullPointer(this, getName()) { [EOL]  [EOL]                 public Object getImmediateNode() { [EOL]                     throw new JXPathException("Undefined variable: " + name); [EOL]                 } [EOL]             }; [EOL]         } [EOL]     } [EOL]     return valuePointer; [EOL] }
public NodePointer createPath(JXPathContext context, Object value) { [EOL]     if (actual) { [EOL]         setValue(value); [EOL]         return this; [EOL]     } [EOL]     NodePointer ptr = createPath(context); [EOL]     ptr.setValue(value); [EOL]     return ptr; [EOL] }
public NodePointer createPath(JXPathContext context, Object value) { [EOL]     if (actual) { [EOL]         setValue(value); [EOL]         return this; [EOL]     } [EOL]     NodePointer ptr = createPath(context); [EOL]     ptr.setValue(value); [EOL]     return ptr; [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     buffer.append('$'); [EOL]     buffer.append(name); [EOL]     if (!actual) { [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             buffer.append('[').append(index + 1).append(']'); [EOL]         } [EOL]     } else if (index != WHOLE_COLLECTION && (getNode() == null || isCollection())) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     buffer.append('$'); [EOL]     buffer.append(name); [EOL]     if (!actual) { [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             buffer.append('[').append(index + 1).append(']'); [EOL]         } [EOL]     } else if (index != WHOLE_COLLECTION && (getNode() == null || isCollection())) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     buffer.append('$'); [EOL]     buffer.append(name); [EOL]     if (!actual) { [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             buffer.append('[').append(index + 1).append(']'); [EOL]         } [EOL]     } else if (index != WHOLE_COLLECTION && (getNode() == null || isCollection())) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     buffer.append('$'); [EOL]     buffer.append(name); [EOL]     if (!actual) { [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             buffer.append('[').append(index + 1).append(']'); [EOL]         } [EOL]     } else if (index != WHOLE_COLLECTION && (getNode() == null || isCollection())) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     buffer.append('$'); [EOL]     buffer.append(name); [EOL]     if (!actual) { [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             buffer.append('[').append(index + 1).append(']'); [EOL]         } [EOL]     } else if (index != WHOLE_COLLECTION && (getNode() == null || isCollection())) { [EOL]         buffer.append('[').append(index + 1).append(']'); [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public boolean testNode(NodeTest nodeTest) { [EOL]     return getValuePointer().testNode(nodeTest); [EOL] }
public boolean testNode(NodeTest nodeTest) { [EOL]     return getValuePointer().testNode(nodeTest); [EOL] }
public NodePointer getParent() { [EOL]     NodePointer pointer = parent; [EOL]     while (pointer != null && pointer.isContainer()) { [EOL]         pointer = pointer.getImmediateParentPointer(); [EOL]     } [EOL]     return pointer; [EOL] }
public NodePointer getParent() { [EOL]     NodePointer pointer = parent; [EOL]     while (pointer != null && pointer.isContainer()) { [EOL]         pointer = pointer.getImmediateParentPointer(); [EOL]     } [EOL]     return pointer; [EOL] }
public NodePointer getImmediateParentPointer() { [EOL]     return parent; [EOL] }
public void setAttribute(boolean attribute) { [EOL]     this.attribute = attribute; [EOL] }
public void setAttribute(boolean attribute) { [EOL]     this.attribute = attribute; [EOL] }
public Object getValue() { [EOL]     NodePointer valuePointer = getValuePointer(); [EOL]     if (valuePointer != this) { [EOL]         return valuePointer.getValue(); [EOL]     } [EOL]     return getNode(); [EOL] }
public Object getValue() { [EOL]     NodePointer valuePointer = getValuePointer(); [EOL]     if (valuePointer != this) { [EOL]         return valuePointer.getValue(); [EOL]     } [EOL]     return getNode(); [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (isContainer()) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         QName nodeName = getName(); [EOL]         if (nodeName == null) { [EOL]             return false; [EOL]         } [EOL]         String testPrefix = testName.getPrefix(); [EOL]         String nodePrefix = nodeName.getPrefix(); [EOL]         if (!equalStrings(testPrefix, nodePrefix)) { [EOL]             String testNS = getNamespaceURI(testPrefix); [EOL]             String nodeNS = getNamespaceURI(nodePrefix); [EOL]             if (!equalStrings(testNS, nodeNS)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             return true; [EOL]         } [EOL]         return testName.getName().equals(nodeName.getName()); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return isNode(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (isContainer()) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         QName nodeName = getName(); [EOL]         if (nodeName == null) { [EOL]             return false; [EOL]         } [EOL]         String testPrefix = testName.getPrefix(); [EOL]         String nodePrefix = nodeName.getPrefix(); [EOL]         if (!equalStrings(testPrefix, nodePrefix)) { [EOL]             String testNS = getNamespaceURI(testPrefix); [EOL]             String nodeNS = getNamespaceURI(nodePrefix); [EOL]             if (!equalStrings(testNS, nodeNS)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             return true; [EOL]         } [EOL]         return testName.getName().equals(nodeName.getName()); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return isNode(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (isContainer()) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         QName nodeName = getName(); [EOL]         if (nodeName == null) { [EOL]             return false; [EOL]         } [EOL]         String testPrefix = testName.getPrefix(); [EOL]         String nodePrefix = nodeName.getPrefix(); [EOL]         if (!equalStrings(testPrefix, nodePrefix)) { [EOL]             String testNS = getNamespaceURI(testPrefix); [EOL]             String nodeNS = getNamespaceURI(nodePrefix); [EOL]             if (!equalStrings(testNS, nodeNS)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             return true; [EOL]         } [EOL]         return testName.getName().equals(nodeName.getName()); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return isNode(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (isContainer()) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         QName nodeName = getName(); [EOL]         if (nodeName == null) { [EOL]             return false; [EOL]         } [EOL]         String testPrefix = testName.getPrefix(); [EOL]         String nodePrefix = nodeName.getPrefix(); [EOL]         if (!equalStrings(testPrefix, nodePrefix)) { [EOL]             String testNS = getNamespaceURI(testPrefix); [EOL]             String nodeNS = getNamespaceURI(nodePrefix); [EOL]             if (!equalStrings(testNS, nodeNS)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             return true; [EOL]         } [EOL]         return testName.getName().equals(nodeName.getName()); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return isNode(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (isContainer()) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         QName nodeName = getName(); [EOL]         if (nodeName == null) { [EOL]             return false; [EOL]         } [EOL]         String testPrefix = testName.getPrefix(); [EOL]         String nodePrefix = nodeName.getPrefix(); [EOL]         if (!equalStrings(testPrefix, nodePrefix)) { [EOL]             String testNS = getNamespaceURI(testPrefix); [EOL]             String nodeNS = getNamespaceURI(nodePrefix); [EOL]             if (!equalStrings(testNS, nodeNS)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             return true; [EOL]         } [EOL]         return testName.getName().equals(nodeName.getName()); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return isNode(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (isContainer()) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         QName nodeName = getName(); [EOL]         if (nodeName == null) { [EOL]             return false; [EOL]         } [EOL]         String testPrefix = testName.getPrefix(); [EOL]         String nodePrefix = nodeName.getPrefix(); [EOL]         if (!equalStrings(testPrefix, nodePrefix)) { [EOL]             String testNS = getNamespaceURI(testPrefix); [EOL]             String nodeNS = getNamespaceURI(nodePrefix); [EOL]             if (!equalStrings(testNS, nodeNS)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             return true; [EOL]         } [EOL]         return testName.getName().equals(nodeName.getName()); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return isNode(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (isContainer()) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         QName nodeName = getName(); [EOL]         if (nodeName == null) { [EOL]             return false; [EOL]         } [EOL]         String testPrefix = testName.getPrefix(); [EOL]         String nodePrefix = nodeName.getPrefix(); [EOL]         if (!equalStrings(testPrefix, nodePrefix)) { [EOL]             String testNS = getNamespaceURI(testPrefix); [EOL]             String nodeNS = getNamespaceURI(nodePrefix); [EOL]             if (!equalStrings(testNS, nodeNS)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             return true; [EOL]         } [EOL]         return testName.getName().equals(nodeName.getName()); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return isNode(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (isContainer()) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         QName nodeName = getName(); [EOL]         if (nodeName == null) { [EOL]             return false; [EOL]         } [EOL]         String testPrefix = testName.getPrefix(); [EOL]         String nodePrefix = nodeName.getPrefix(); [EOL]         if (!equalStrings(testPrefix, nodePrefix)) { [EOL]             String testNS = getNamespaceURI(testPrefix); [EOL]             String nodeNS = getNamespaceURI(nodePrefix); [EOL]             if (!equalStrings(testNS, nodeNS)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             return true; [EOL]         } [EOL]         return testName.getName().equals(nodeName.getName()); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return isNode(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean testNode(NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (isContainer()) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         QName nodeName = getName(); [EOL]         if (nodeName == null) { [EOL]             return false; [EOL]         } [EOL]         String testPrefix = testName.getPrefix(); [EOL]         String nodePrefix = nodeName.getPrefix(); [EOL]         if (!equalStrings(testPrefix, nodePrefix)) { [EOL]             String testNS = getNamespaceURI(testPrefix); [EOL]             String nodeNS = getNamespaceURI(nodePrefix); [EOL]             if (!equalStrings(testNS, nodeNS)) { [EOL]                 return false; [EOL]             } [EOL]         } [EOL]         if (nodeNameTest.isWildcard()) { [EOL]             return true; [EOL]         } [EOL]         return testName.getName().equals(nodeName.getName()); [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         if (((NodeTypeTest) test).getNodeType() == Compiler.NODE_TYPE_NODE) { [EOL]             return isNode(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null && s2 != null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && !s1.equals(s2)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null && s2 != null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && !s1.equals(s2)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null && s2 != null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && !s1.equals(s2)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null && s2 != null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && !s1.equals(s2)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null && s2 != null) { [EOL]         return false; [EOL]     } [EOL]     if (s1 != null && !s1.equals(s2)) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     return null; [EOL] }
protected boolean isDefaultNamespace(String prefix) { [EOL]     if (prefix == null) { [EOL]         return true; [EOL]     } [EOL]     String namespace = getNamespaceURI(prefix); [EOL]     if (namespace == null) { [EOL]         return false; [EOL]     } [EOL]     return namespace.equals(getDefaultNamespaceURI()); [EOL] }
protected boolean isDefaultNamespace(String prefix) { [EOL]     if (prefix == null) { [EOL]         return true; [EOL]     } [EOL]     String namespace = getNamespaceURI(prefix); [EOL]     if (namespace == null) { [EOL]         return false; [EOL]     } [EOL]     return namespace.equals(getDefaultNamespaceURI()); [EOL] }
public Object clone() { [EOL]     try { [EOL]         NodePointer ptr = (NodePointer) super.clone(); [EOL]         if (parent != null) { [EOL]             ptr.parent = (NodePointer) parent.clone(); [EOL]         } [EOL]         return ptr; [EOL]     } catch (CloneNotSupportedException ex) { [EOL]         ex.printStackTrace(); [EOL]     } [EOL]     return null; [EOL] }
public Object clone() { [EOL]     try { [EOL]         NodePointer ptr = (NodePointer) super.clone(); [EOL]         if (parent != null) { [EOL]             ptr.parent = (NodePointer) parent.clone(); [EOL]         } [EOL]         return ptr; [EOL]     } catch (CloneNotSupportedException ex) { [EOL]         ex.printStackTrace(); [EOL]     } [EOL]     return null; [EOL] }
public int compareTo(Object object) { [EOL]     NodePointer pointer = (NodePointer) object; [EOL]     if (parent == pointer.parent) { [EOL]         if (parent == null) { [EOL]             return 0; [EOL]         } [EOL]         return parent.compareChildNodePointers(this, pointer); [EOL]     } [EOL]     int depth1 = 0; [EOL]     NodePointer p1 = this; [EOL]     while (p1 != null) { [EOL]         depth1++; [EOL]         p1 = p1.parent; [EOL]     } [EOL]     int depth2 = 0; [EOL]     NodePointer p2 = pointer; [EOL]     while (p2 != null) { [EOL]         depth2++; [EOL]         p2 = p2.parent; [EOL]     } [EOL]     return compareNodePointers(this, depth1, pointer, depth2); [EOL] }
public int compareTo(Object object) { [EOL]     NodePointer pointer = (NodePointer) object; [EOL]     if (parent == pointer.parent) { [EOL]         if (parent == null) { [EOL]             return 0; [EOL]         } [EOL]         return parent.compareChildNodePointers(this, pointer); [EOL]     } [EOL]     int depth1 = 0; [EOL]     NodePointer p1 = this; [EOL]     while (p1 != null) { [EOL]         depth1++; [EOL]         p1 = p1.parent; [EOL]     } [EOL]     int depth2 = 0; [EOL]     NodePointer p2 = pointer; [EOL]     while (p2 != null) { [EOL]         depth2++; [EOL]         p2 = p2.parent; [EOL]     } [EOL]     return compareNodePointers(this, depth1, pointer, depth2); [EOL] }
public int compareTo(Object object) { [EOL]     NodePointer pointer = (NodePointer) object; [EOL]     if (parent == pointer.parent) { [EOL]         if (parent == null) { [EOL]             return 0; [EOL]         } [EOL]         return parent.compareChildNodePointers(this, pointer); [EOL]     } [EOL]     int depth1 = 0; [EOL]     NodePointer p1 = this; [EOL]     while (p1 != null) { [EOL]         depth1++; [EOL]         p1 = p1.parent; [EOL]     } [EOL]     int depth2 = 0; [EOL]     NodePointer p2 = pointer; [EOL]     while (p2 != null) { [EOL]         depth2++; [EOL]         p2 = p2.parent; [EOL]     } [EOL]     return compareNodePointers(this, depth1, pointer, depth2); [EOL] }
private int compareNodePointers(NodePointer p1, int depth1, NodePointer p2, int depth2) { [EOL]     if (depth1 < depth2) { [EOL]         int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1); [EOL]         if (r != 0) { [EOL]             return r; [EOL]         } [EOL]         return -1; [EOL]     } else if (depth1 > depth2) { [EOL]         int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2); [EOL]         if (r != 0) { [EOL]             return r; [EOL]         } [EOL]         return 1; [EOL]     } [EOL]     if (p1 == null && p2 == null) { [EOL]         return 0; [EOL]     } [EOL]     if (p1 != null && p1.equals(p2)) { [EOL]         return 0; [EOL]     } [EOL]     if (depth1 == 1) { [EOL]         throw new JXPathException("Cannot compare pointers that do not belong to the same tree: '" + p1 + "' and '" + p2 + "'"); [EOL]     } [EOL]     int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1); [EOL]     if (r != 0) { [EOL]         return r; [EOL]     } [EOL]     return p1.parent.compareChildNodePointers(p1, p2); [EOL] }
private int compareNodePointers(NodePointer p1, int depth1, NodePointer p2, int depth2) { [EOL]     if (depth1 < depth2) { [EOL]         int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1); [EOL]         if (r != 0) { [EOL]             return r; [EOL]         } [EOL]         return -1; [EOL]     } else if (depth1 > depth2) { [EOL]         int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2); [EOL]         if (r != 0) { [EOL]             return r; [EOL]         } [EOL]         return 1; [EOL]     } [EOL]     if (p1 == null && p2 == null) { [EOL]         return 0; [EOL]     } [EOL]     if (p1 != null && p1.equals(p2)) { [EOL]         return 0; [EOL]     } [EOL]     if (depth1 == 1) { [EOL]         throw new JXPathException("Cannot compare pointers that do not belong to the same tree: '" + p1 + "' and '" + p2 + "'"); [EOL]     } [EOL]     int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1); [EOL]     if (r != 0) { [EOL]         return r; [EOL]     } [EOL]     return p1.parent.compareChildNodePointers(p1, p2); [EOL] }
private int compareNodePointers(NodePointer p1, int depth1, NodePointer p2, int depth2) { [EOL]     if (depth1 < depth2) { [EOL]         int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1); [EOL]         if (r != 0) { [EOL]             return r; [EOL]         } [EOL]         return -1; [EOL]     } else if (depth1 > depth2) { [EOL]         int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2); [EOL]         if (r != 0) { [EOL]             return r; [EOL]         } [EOL]         return 1; [EOL]     } [EOL]     if (p1 == null && p2 == null) { [EOL]         return 0; [EOL]     } [EOL]     if (p1 != null && p1.equals(p2)) { [EOL]         return 0; [EOL]     } [EOL]     if (depth1 == 1) { [EOL]         throw new JXPathException("Cannot compare pointers that do not belong to the same tree: '" + p1 + "' and '" + p2 + "'"); [EOL]     } [EOL]     int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1); [EOL]     if (r != 0) { [EOL]         return r; [EOL]     } [EOL]     return p1.parent.compareChildNodePointers(p1, p2); [EOL] }
private int compareNodePointers(NodePointer p1, int depth1, NodePointer p2, int depth2) { [EOL]     if (depth1 < depth2) { [EOL]         int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1); [EOL]         if (r != 0) { [EOL]             return r; [EOL]         } [EOL]         return -1; [EOL]     } else if (depth1 > depth2) { [EOL]         int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2); [EOL]         if (r != 0) { [EOL]             return r; [EOL]         } [EOL]         return 1; [EOL]     } [EOL]     if (p1 == null && p2 == null) { [EOL]         return 0; [EOL]     } [EOL]     if (p1 != null && p1.equals(p2)) { [EOL]         return 0; [EOL]     } [EOL]     if (depth1 == 1) { [EOL]         throw new JXPathException("Cannot compare pointers that do not belong to the same tree: '" + p1 + "' and '" + p2 + "'"); [EOL]     } [EOL]     int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1); [EOL]     if (r != 0) { [EOL]         return r; [EOL]     } [EOL]     return p1.parent.compareChildNodePointers(p1, p2); [EOL] }
private int compareNodePointers(NodePointer p1, int depth1, NodePointer p2, int depth2) { [EOL]     if (depth1 < depth2) { [EOL]         int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1); [EOL]         if (r != 0) { [EOL]             return r; [EOL]         } [EOL]         return -1; [EOL]     } else if (depth1 > depth2) { [EOL]         int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2); [EOL]         if (r != 0) { [EOL]             return r; [EOL]         } [EOL]         return 1; [EOL]     } [EOL]     if (p1 == null && p2 == null) { [EOL]         return 0; [EOL]     } [EOL]     if (p1 != null && p1.equals(p2)) { [EOL]         return 0; [EOL]     } [EOL]     if (depth1 == 1) { [EOL]         throw new JXPathException("Cannot compare pointers that do not belong to the same tree: '" + p1 + "' and '" + p2 + "'"); [EOL]     } [EOL]     int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1); [EOL]     if (r != 0) { [EOL]         return r; [EOL]     } [EOL]     return p1.parent.compareChildNodePointers(p1, p2); [EOL] }
public JDOMAttributePointer(NodePointer parent, Attribute attr) { [EOL]     super(parent); [EOL]     this.attr = attr; [EOL] }
public JDOMAttributePointer(NodePointer parent, Attribute attr) { [EOL]     super(parent); [EOL]     this.attr = attr; [EOL] }
public JDOMAttributePointer(NodePointer parent, Attribute attr) { [EOL]     super(parent); [EOL]     this.attr = attr; [EOL] }
public JDOMAttributePointer(NodePointer parent, Attribute attr) { [EOL]     super(parent); [EOL]     this.attr = attr; [EOL] }
public Object getValue() { [EOL]     return attr.getValue(); [EOL] }
public Object getImmediateNode() { [EOL]     return attr; [EOL] }
public static boolean isCollection(Object value) { [EOL]     if (value == null) { [EOL]         return false; [EOL]     } [EOL]     value = getValue(value); [EOL]     if (value.getClass().isArray()) { [EOL]         return true; [EOL]     } else if (value instanceof Collection) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public static boolean isCollection(Object value) { [EOL]     if (value == null) { [EOL]         return false; [EOL]     } [EOL]     value = getValue(value); [EOL]     if (value.getClass().isArray()) { [EOL]         return true; [EOL]     } else if (value instanceof Collection) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public static boolean isCollection(Object value) { [EOL]     if (value == null) { [EOL]         return false; [EOL]     } [EOL]     value = getValue(value); [EOL]     if (value.getClass().isArray()) { [EOL]         return true; [EOL]     } else if (value instanceof Collection) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public static boolean isCollection(Object value) { [EOL]     if (value == null) { [EOL]         return false; [EOL]     } [EOL]     value = getValue(value); [EOL]     if (value.getClass().isArray()) { [EOL]         return true; [EOL]     } else if (value instanceof Collection) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public static Iterator iterate(Object collection) { [EOL]     if (collection == null) { [EOL]         return Collections.EMPTY_LIST.iterator(); [EOL]     } [EOL]     if (collection.getClass().isArray()) { [EOL]         int length = Array.getLength(collection); [EOL]         if (length == 0) { [EOL]             return Collections.EMPTY_LIST.iterator(); [EOL]         } [EOL]         ArrayList list = new ArrayList(); [EOL]         for (int i = 0; i < length; i++) { [EOL]             list.add(Array.get(collection, i)); [EOL]         } [EOL]         return list.iterator(); [EOL]     } else if (collection instanceof Collection) { [EOL]         return ((Collection) collection).iterator(); [EOL]     } else { [EOL]         return Collections.singletonList(collection).iterator(); [EOL]     } [EOL] }
public static Iterator iterate(Object collection) { [EOL]     if (collection == null) { [EOL]         return Collections.EMPTY_LIST.iterator(); [EOL]     } [EOL]     if (collection.getClass().isArray()) { [EOL]         int length = Array.getLength(collection); [EOL]         if (length == 0) { [EOL]             return Collections.EMPTY_LIST.iterator(); [EOL]         } [EOL]         ArrayList list = new ArrayList(); [EOL]         for (int i = 0; i < length; i++) { [EOL]             list.add(Array.get(collection, i)); [EOL]         } [EOL]         return list.iterator(); [EOL]     } else if (collection instanceof Collection) { [EOL]         return ((Collection) collection).iterator(); [EOL]     } else { [EOL]         return Collections.singletonList(collection).iterator(); [EOL]     } [EOL] }
public static Iterator iterate(Object collection) { [EOL]     if (collection == null) { [EOL]         return Collections.EMPTY_LIST.iterator(); [EOL]     } [EOL]     if (collection.getClass().isArray()) { [EOL]         int length = Array.getLength(collection); [EOL]         if (length == 0) { [EOL]             return Collections.EMPTY_LIST.iterator(); [EOL]         } [EOL]         ArrayList list = new ArrayList(); [EOL]         for (int i = 0; i < length; i++) { [EOL]             list.add(Array.get(collection, i)); [EOL]         } [EOL]         return list.iterator(); [EOL]     } else if (collection instanceof Collection) { [EOL]         return ((Collection) collection).iterator(); [EOL]     } else { [EOL]         return Collections.singletonList(collection).iterator(); [EOL]     } [EOL] }
public static Iterator iterate(Object collection) { [EOL]     if (collection == null) { [EOL]         return Collections.EMPTY_LIST.iterator(); [EOL]     } [EOL]     if (collection.getClass().isArray()) { [EOL]         int length = Array.getLength(collection); [EOL]         if (length == 0) { [EOL]             return Collections.EMPTY_LIST.iterator(); [EOL]         } [EOL]         ArrayList list = new ArrayList(); [EOL]         for (int i = 0; i < length; i++) { [EOL]             list.add(Array.get(collection, i)); [EOL]         } [EOL]         return list.iterator(); [EOL]     } else if (collection instanceof Collection) { [EOL]         return ((Collection) collection).iterator(); [EOL]     } else { [EOL]         return Collections.singletonList(collection).iterator(); [EOL]     } [EOL] }
public static Iterator iterate(Object collection) { [EOL]     if (collection == null) { [EOL]         return Collections.EMPTY_LIST.iterator(); [EOL]     } [EOL]     if (collection.getClass().isArray()) { [EOL]         int length = Array.getLength(collection); [EOL]         if (length == 0) { [EOL]             return Collections.EMPTY_LIST.iterator(); [EOL]         } [EOL]         ArrayList list = new ArrayList(); [EOL]         for (int i = 0; i < length; i++) { [EOL]             list.add(Array.get(collection, i)); [EOL]         } [EOL]         return list.iterator(); [EOL]     } else if (collection instanceof Collection) { [EOL]         return ((Collection) collection).iterator(); [EOL]     } else { [EOL]         return Collections.singletonList(collection).iterator(); [EOL]     } [EOL] }
public static Object getValue(Object collection, int index) { [EOL]     collection = getValue(collection); [EOL]     Object value = collection; [EOL]     if (collection != null) { [EOL]         if (collection.getClass().isArray()) { [EOL]             if (index < 0 || index >= Array.getLength(collection)) { [EOL]                 return null; [EOL]             } [EOL]             value = Array.get(collection, index); [EOL]         } else if (collection instanceof List) { [EOL]             if (index < 0 || index >= ((List) collection).size()) { [EOL]                 return null; [EOL]             } [EOL]             value = ((List) collection).get(index); [EOL]         } else if (collection instanceof Collection) { [EOL]             int i = 0; [EOL]             Iterator it = ((Collection) collection).iterator(); [EOL]             for (; i < index; i++) { [EOL]                 it.next(); [EOL]             } [EOL]             if (it.hasNext()) { [EOL]                 value = it.next(); [EOL]             } else { [EOL]                 value = null; [EOL]             } [EOL]         } [EOL]     } [EOL]     return value; [EOL] }
public static Object getValue(Object bean, PropertyDescriptor propertyDescriptor) { [EOL]     Object value; [EOL]     try { [EOL]         Method method = getAccessibleMethod(propertyDescriptor.getReadMethod()); [EOL]         if (method == null) { [EOL]             throw new JXPathException("No read method"); [EOL]         } [EOL]         value = method.invoke(bean, new Object[0]); [EOL]     } catch (Exception ex) { [EOL]         throw new JXPathException("Cannot access property: " + (bean == null ? "null" : bean.getClass().getName()) + "." + propertyDescriptor.getName(), ex); [EOL]     } [EOL]     return value; [EOL] }
public static Object getValue(Object bean, PropertyDescriptor propertyDescriptor) { [EOL]     Object value; [EOL]     try { [EOL]         Method method = getAccessibleMethod(propertyDescriptor.getReadMethod()); [EOL]         if (method == null) { [EOL]             throw new JXPathException("No read method"); [EOL]         } [EOL]         value = method.invoke(bean, new Object[0]); [EOL]     } catch (Exception ex) { [EOL]         throw new JXPathException("Cannot access property: " + (bean == null ? "null" : bean.getClass().getName()) + "." + propertyDescriptor.getName(), ex); [EOL]     } [EOL]     return value; [EOL] }
public static Object getValue(Object bean, PropertyDescriptor propertyDescriptor) { [EOL]     Object value; [EOL]     try { [EOL]         Method method = getAccessibleMethod(propertyDescriptor.getReadMethod()); [EOL]         if (method == null) { [EOL]             throw new JXPathException("No read method"); [EOL]         } [EOL]         value = method.invoke(bean, new Object[0]); [EOL]     } catch (Exception ex) { [EOL]         throw new JXPathException("Cannot access property: " + (bean == null ? "null" : bean.getClass().getName()) + "." + propertyDescriptor.getName(), ex); [EOL]     } [EOL]     return value; [EOL] }
public static Object getValue(Object bean, PropertyDescriptor propertyDescriptor) { [EOL]     Object value; [EOL]     try { [EOL]         Method method = getAccessibleMethod(propertyDescriptor.getReadMethod()); [EOL]         if (method == null) { [EOL]             throw new JXPathException("No read method"); [EOL]         } [EOL]         value = method.invoke(bean, new Object[0]); [EOL]     } catch (Exception ex) { [EOL]         throw new JXPathException("Cannot access property: " + (bean == null ? "null" : bean.getClass().getName()) + "." + propertyDescriptor.getName(), ex); [EOL]     } [EOL]     return value; [EOL] }
public static void setValue(Object bean, PropertyDescriptor propertyDescriptor, Object value) { [EOL]     try { [EOL]         Method method = getAccessibleMethod(propertyDescriptor.getWriteMethod()); [EOL]         if (method == null) { [EOL]             throw new JXPathException("No write method"); [EOL]         } [EOL]         value = convert(value, propertyDescriptor.getPropertyType()); [EOL]         value = method.invoke(bean, new Object[] { value }); [EOL]     } catch (Exception ex) { [EOL]         throw new JXPathException("Cannot modify property: " + (bean == null ? "null" : bean.getClass().getName()) + "." + propertyDescriptor.getName(), ex); [EOL]     } [EOL] }
public static void setValue(Object bean, PropertyDescriptor propertyDescriptor, Object value) { [EOL]     try { [EOL]         Method method = getAccessibleMethod(propertyDescriptor.getWriteMethod()); [EOL]         if (method == null) { [EOL]             throw new JXPathException("No write method"); [EOL]         } [EOL]         value = convert(value, propertyDescriptor.getPropertyType()); [EOL]         value = method.invoke(bean, new Object[] { value }); [EOL]     } catch (Exception ex) { [EOL]         throw new JXPathException("Cannot modify property: " + (bean == null ? "null" : bean.getClass().getName()) + "." + propertyDescriptor.getName(), ex); [EOL]     } [EOL] }
public static void setValue(Object bean, PropertyDescriptor propertyDescriptor, Object value) { [EOL]     try { [EOL]         Method method = getAccessibleMethod(propertyDescriptor.getWriteMethod()); [EOL]         if (method == null) { [EOL]             throw new JXPathException("No write method"); [EOL]         } [EOL]         value = convert(value, propertyDescriptor.getPropertyType()); [EOL]         value = method.invoke(bean, new Object[] { value }); [EOL]     } catch (Exception ex) { [EOL]         throw new JXPathException("Cannot modify property: " + (bean == null ? "null" : bean.getClass().getName()) + "." + propertyDescriptor.getName(), ex); [EOL]     } [EOL] }
private static Object convert(Object value, Class type) { [EOL]     try { [EOL]         return TypeUtils.convert(value, type); [EOL]     } catch (Exception ex) { [EOL]         throw new JXPathException("Cannot convert value of class " + (value == null ? "null" : value.getClass().getName()) + " to type " + type, ex); [EOL]     } [EOL] }
private static Object convert(Object value, Class type) { [EOL]     try { [EOL]         return TypeUtils.convert(value, type); [EOL]     } catch (Exception ex) { [EOL]         throw new JXPathException("Cannot convert value of class " + (value == null ? "null" : value.getClass().getName()) + " to type " + type, ex); [EOL]     } [EOL] }
private static Object convert(Object value, Class type) { [EOL]     try { [EOL]         return TypeUtils.convert(value, type); [EOL]     } catch (Exception ex) { [EOL]         throw new JXPathException("Cannot convert value of class " + (value == null ? "null" : value.getClass().getName()) + " to type " + type, ex); [EOL]     } [EOL] }
public static Object getValue(Object bean, PropertyDescriptor propertyDescriptor, int index) { [EOL]     if (propertyDescriptor instanceof IndexedPropertyDescriptor) { [EOL]         try { [EOL]             IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor) propertyDescriptor; [EOL]             Method method = ipd.getIndexedReadMethod(); [EOL]             if (method != null) { [EOL]                 return method.invoke(bean, new Object[] { new Integer(index) }); [EOL]             } [EOL]         } catch (InvocationTargetException ex) { [EOL]             Throwable t = ((InvocationTargetException) ex).getTargetException(); [EOL]             if (t instanceof ArrayIndexOutOfBoundsException) { [EOL]                 return null; [EOL]             } [EOL]             throw new JXPathException("Cannot access property: " + propertyDescriptor.getName(), t); [EOL]         } catch (Throwable ex) { [EOL]             throw new JXPathException("Cannot access property: " + propertyDescriptor.getName(), ex); [EOL]         } [EOL]     } [EOL]     return getValue(getValue(bean, propertyDescriptor), index); [EOL] }
public static void setValue(Object bean, PropertyDescriptor propertyDescriptor, int index, Object value) { [EOL]     if (propertyDescriptor instanceof IndexedPropertyDescriptor) { [EOL]         try { [EOL]             IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor) propertyDescriptor; [EOL]             Method method = ipd.getIndexedWriteMethod(); [EOL]             if (method != null) { [EOL]                 method.invoke(bean, new Object[] { new Integer(index), convert(value, ipd.getIndexedPropertyType()) }); [EOL]                 return; [EOL]             } [EOL]         } catch (Exception ex) { [EOL]             throw new RuntimeException("Cannot access property: " + propertyDescriptor.getName() + ", " + ex.getMessage()); [EOL]         } [EOL]     } [EOL]     Object collection = getValue(bean, propertyDescriptor); [EOL]     if (isCollection(collection)) { [EOL]         setValue(collection, index, value); [EOL]     } else if (index == 0) { [EOL]         setValue(bean, propertyDescriptor, value); [EOL]     } else { [EOL]         throw new RuntimeException("Not a collection: " + propertyDescriptor.getName()); [EOL]     } [EOL] }
public static void setValue(Object bean, PropertyDescriptor propertyDescriptor, int index, Object value) { [EOL]     if (propertyDescriptor instanceof IndexedPropertyDescriptor) { [EOL]         try { [EOL]             IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor) propertyDescriptor; [EOL]             Method method = ipd.getIndexedWriteMethod(); [EOL]             if (method != null) { [EOL]                 method.invoke(bean, new Object[] { new Integer(index), convert(value, ipd.getIndexedPropertyType()) }); [EOL]                 return; [EOL]             } [EOL]         } catch (Exception ex) { [EOL]             throw new RuntimeException("Cannot access property: " + propertyDescriptor.getName() + ", " + ex.getMessage()); [EOL]         } [EOL]     } [EOL]     Object collection = getValue(bean, propertyDescriptor); [EOL]     if (isCollection(collection)) { [EOL]         setValue(collection, index, value); [EOL]     } else if (index == 0) { [EOL]         setValue(bean, propertyDescriptor, value); [EOL]     } else { [EOL]         throw new RuntimeException("Not a collection: " + propertyDescriptor.getName()); [EOL]     } [EOL] }
public static void setValue(Object bean, PropertyDescriptor propertyDescriptor, int index, Object value) { [EOL]     if (propertyDescriptor instanceof IndexedPropertyDescriptor) { [EOL]         try { [EOL]             IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor) propertyDescriptor; [EOL]             Method method = ipd.getIndexedWriteMethod(); [EOL]             if (method != null) { [EOL]                 method.invoke(bean, new Object[] { new Integer(index), convert(value, ipd.getIndexedPropertyType()) }); [EOL]                 return; [EOL]             } [EOL]         } catch (Exception ex) { [EOL]             throw new RuntimeException("Cannot access property: " + propertyDescriptor.getName() + ", " + ex.getMessage()); [EOL]         } [EOL]     } [EOL]     Object collection = getValue(bean, propertyDescriptor); [EOL]     if (isCollection(collection)) { [EOL]         setValue(collection, index, value); [EOL]     } else if (index == 0) { [EOL]         setValue(bean, propertyDescriptor, value); [EOL]     } else { [EOL]         throw new RuntimeException("Not a collection: " + propertyDescriptor.getName()); [EOL]     } [EOL] }
public static void setValue(Object bean, PropertyDescriptor propertyDescriptor, int index, Object value) { [EOL]     if (propertyDescriptor instanceof IndexedPropertyDescriptor) { [EOL]         try { [EOL]             IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor) propertyDescriptor; [EOL]             Method method = ipd.getIndexedWriteMethod(); [EOL]             if (method != null) { [EOL]                 method.invoke(bean, new Object[] { new Integer(index), convert(value, ipd.getIndexedPropertyType()) }); [EOL]                 return; [EOL]             } [EOL]         } catch (Exception ex) { [EOL]             throw new RuntimeException("Cannot access property: " + propertyDescriptor.getName() + ", " + ex.getMessage()); [EOL]         } [EOL]     } [EOL]     Object collection = getValue(bean, propertyDescriptor); [EOL]     if (isCollection(collection)) { [EOL]         setValue(collection, index, value); [EOL]     } else if (index == 0) { [EOL]         setValue(bean, propertyDescriptor, value); [EOL]     } else { [EOL]         throw new RuntimeException("Not a collection: " + propertyDescriptor.getName()); [EOL]     } [EOL] }
public static void setValue(Object bean, PropertyDescriptor propertyDescriptor, int index, Object value) { [EOL]     if (propertyDescriptor instanceof IndexedPropertyDescriptor) { [EOL]         try { [EOL]             IndexedPropertyDescriptor ipd = (IndexedPropertyDescriptor) propertyDescriptor; [EOL]             Method method = ipd.getIndexedWriteMethod(); [EOL]             if (method != null) { [EOL]                 method.invoke(bean, new Object[] { new Integer(index), convert(value, ipd.getIndexedPropertyType()) }); [EOL]                 return; [EOL]             } [EOL]         } catch (Exception ex) { [EOL]             throw new RuntimeException("Cannot access property: " + propertyDescriptor.getName() + ", " + ex.getMessage()); [EOL]         } [EOL]     } [EOL]     Object collection = getValue(bean, propertyDescriptor); [EOL]     if (isCollection(collection)) { [EOL]         setValue(collection, index, value); [EOL]     } else if (index == 0) { [EOL]         setValue(bean, propertyDescriptor, value); [EOL]     } else { [EOL]         throw new RuntimeException("Not a collection: " + propertyDescriptor.getName()); [EOL]     } [EOL] }
public static DynamicPropertyHandler getDynamicPropertyHandler(Class clazz) { [EOL]     DynamicPropertyHandler handler = (DynamicPropertyHandler) dynamicPropertyHandlerMap.get(clazz); [EOL]     if (handler == null) { [EOL]         try { [EOL]             handler = (DynamicPropertyHandler) clazz.newInstance(); [EOL]         } catch (Exception ex) { [EOL]             throw new JXPathException("Cannot allocate dynamic property handler of class " + clazz.getName(), ex); [EOL]         } [EOL]         dynamicPropertyHandlerMap.put(clazz, handler); [EOL]     } [EOL]     return handler; [EOL] }
public static DynamicPropertyHandler getDynamicPropertyHandler(Class clazz) { [EOL]     DynamicPropertyHandler handler = (DynamicPropertyHandler) dynamicPropertyHandlerMap.get(clazz); [EOL]     if (handler == null) { [EOL]         try { [EOL]             handler = (DynamicPropertyHandler) clazz.newInstance(); [EOL]         } catch (Exception ex) { [EOL]             throw new JXPathException("Cannot allocate dynamic property handler of class " + clazz.getName(), ex); [EOL]         } [EOL]         dynamicPropertyHandlerMap.put(clazz, handler); [EOL]     } [EOL]     return handler; [EOL] }
public static DynamicPropertyHandler getDynamicPropertyHandler(Class clazz) { [EOL]     DynamicPropertyHandler handler = (DynamicPropertyHandler) dynamicPropertyHandlerMap.get(clazz); [EOL]     if (handler == null) { [EOL]         try { [EOL]             handler = (DynamicPropertyHandler) clazz.newInstance(); [EOL]         } catch (Exception ex) { [EOL]             throw new JXPathException("Cannot allocate dynamic property handler of class " + clazz.getName(), ex); [EOL]         } [EOL]         dynamicPropertyHandlerMap.put(clazz, handler); [EOL]     } [EOL]     return handler; [EOL] }
public static DynamicPropertyHandler getDynamicPropertyHandler(Class clazz) { [EOL]     DynamicPropertyHandler handler = (DynamicPropertyHandler) dynamicPropertyHandlerMap.get(clazz); [EOL]     if (handler == null) { [EOL]         try { [EOL]             handler = (DynamicPropertyHandler) clazz.newInstance(); [EOL]         } catch (Exception ex) { [EOL]             throw new JXPathException("Cannot allocate dynamic property handler of class " + clazz.getName(), ex); [EOL]         } [EOL]         dynamicPropertyHandlerMap.put(clazz, handler); [EOL]     } [EOL]     return handler; [EOL] }
public static Method getAccessibleMethod(Method method) { [EOL]     if (method == null) { [EOL]         return (null); [EOL]     } [EOL]     if (!Modifier.isPublic(method.getModifiers())) { [EOL]         return (null); [EOL]     } [EOL]     Class clazz = method.getDeclaringClass(); [EOL]     if (Modifier.isPublic(clazz.getModifiers())) { [EOL]         return (method); [EOL]     } [EOL]     String name = method.getName(); [EOL]     Class[] parameterTypes = method.getParameterTypes(); [EOL]     while (clazz != null) { [EOL]         Method aMethod = getAccessibleMethodFromInterfaceNest(clazz, name, parameterTypes); [EOL]         if (aMethod != null) { [EOL]             return aMethod; [EOL]         } [EOL]         clazz = clazz.getSuperclass(); [EOL]         if (clazz != null && Modifier.isPublic(clazz.getModifiers())) { [EOL]             try { [EOL]                 return clazz.getDeclaredMethod(name, parameterTypes); [EOL]             } catch (NoSuchMethodException e) { [EOL]                 ; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public static Method getAccessibleMethod(Method method) { [EOL]     if (method == null) { [EOL]         return (null); [EOL]     } [EOL]     if (!Modifier.isPublic(method.getModifiers())) { [EOL]         return (null); [EOL]     } [EOL]     Class clazz = method.getDeclaringClass(); [EOL]     if (Modifier.isPublic(clazz.getModifiers())) { [EOL]         return (method); [EOL]     } [EOL]     String name = method.getName(); [EOL]     Class[] parameterTypes = method.getParameterTypes(); [EOL]     while (clazz != null) { [EOL]         Method aMethod = getAccessibleMethodFromInterfaceNest(clazz, name, parameterTypes); [EOL]         if (aMethod != null) { [EOL]             return aMethod; [EOL]         } [EOL]         clazz = clazz.getSuperclass(); [EOL]         if (clazz != null && Modifier.isPublic(clazz.getModifiers())) { [EOL]             try { [EOL]                 return clazz.getDeclaredMethod(name, parameterTypes); [EOL]             } catch (NoSuchMethodException e) { [EOL]                 ; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public static Method getAccessibleMethod(Method method) { [EOL]     if (method == null) { [EOL]         return (null); [EOL]     } [EOL]     if (!Modifier.isPublic(method.getModifiers())) { [EOL]         return (null); [EOL]     } [EOL]     Class clazz = method.getDeclaringClass(); [EOL]     if (Modifier.isPublic(clazz.getModifiers())) { [EOL]         return (method); [EOL]     } [EOL]     String name = method.getName(); [EOL]     Class[] parameterTypes = method.getParameterTypes(); [EOL]     while (clazz != null) { [EOL]         Method aMethod = getAccessibleMethodFromInterfaceNest(clazz, name, parameterTypes); [EOL]         if (aMethod != null) { [EOL]             return aMethod; [EOL]         } [EOL]         clazz = clazz.getSuperclass(); [EOL]         if (clazz != null && Modifier.isPublic(clazz.getModifiers())) { [EOL]             try { [EOL]                 return clazz.getDeclaredMethod(name, parameterTypes); [EOL]             } catch (NoSuchMethodException e) { [EOL]                 ; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public static Method getAccessibleMethod(Method method) { [EOL]     if (method == null) { [EOL]         return (null); [EOL]     } [EOL]     if (!Modifier.isPublic(method.getModifiers())) { [EOL]         return (null); [EOL]     } [EOL]     Class clazz = method.getDeclaringClass(); [EOL]     if (Modifier.isPublic(clazz.getModifiers())) { [EOL]         return (method); [EOL]     } [EOL]     String name = method.getName(); [EOL]     Class[] parameterTypes = method.getParameterTypes(); [EOL]     while (clazz != null) { [EOL]         Method aMethod = getAccessibleMethodFromInterfaceNest(clazz, name, parameterTypes); [EOL]         if (aMethod != null) { [EOL]             return aMethod; [EOL]         } [EOL]         clazz = clazz.getSuperclass(); [EOL]         if (clazz != null && Modifier.isPublic(clazz.getModifiers())) { [EOL]             try { [EOL]                 return clazz.getDeclaredMethod(name, parameterTypes); [EOL]             } catch (NoSuchMethodException e) { [EOL]                 ; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public static Method getAccessibleMethod(Method method) { [EOL]     if (method == null) { [EOL]         return (null); [EOL]     } [EOL]     if (!Modifier.isPublic(method.getModifiers())) { [EOL]         return (null); [EOL]     } [EOL]     Class clazz = method.getDeclaringClass(); [EOL]     if (Modifier.isPublic(clazz.getModifiers())) { [EOL]         return (method); [EOL]     } [EOL]     String name = method.getName(); [EOL]     Class[] parameterTypes = method.getParameterTypes(); [EOL]     while (clazz != null) { [EOL]         Method aMethod = getAccessibleMethodFromInterfaceNest(clazz, name, parameterTypes); [EOL]         if (aMethod != null) { [EOL]             return aMethod; [EOL]         } [EOL]         clazz = clazz.getSuperclass(); [EOL]         if (clazz != null && Modifier.isPublic(clazz.getModifiers())) { [EOL]             try { [EOL]                 return clazz.getDeclaredMethod(name, parameterTypes); [EOL]             } catch (NoSuchMethodException e) { [EOL]                 ; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public static Method getAccessibleMethod(Method method) { [EOL]     if (method == null) { [EOL]         return (null); [EOL]     } [EOL]     if (!Modifier.isPublic(method.getModifiers())) { [EOL]         return (null); [EOL]     } [EOL]     Class clazz = method.getDeclaringClass(); [EOL]     if (Modifier.isPublic(clazz.getModifiers())) { [EOL]         return (method); [EOL]     } [EOL]     String name = method.getName(); [EOL]     Class[] parameterTypes = method.getParameterTypes(); [EOL]     while (clazz != null) { [EOL]         Method aMethod = getAccessibleMethodFromInterfaceNest(clazz, name, parameterTypes); [EOL]         if (aMethod != null) { [EOL]             return aMethod; [EOL]         } [EOL]         clazz = clazz.getSuperclass(); [EOL]         if (clazz != null && Modifier.isPublic(clazz.getModifiers())) { [EOL]             try { [EOL]                 return clazz.getDeclaredMethod(name, parameterTypes); [EOL]             } catch (NoSuchMethodException e) { [EOL]                 ; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     if (bean instanceof Document) { [EOL]         return new JDOMNodePointer(parent, bean); [EOL]     } else if (bean instanceof Element) { [EOL]         return new JDOMNodePointer(parent, bean); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     if (bean instanceof Document) { [EOL]         return new JDOMNodePointer(parent, bean); [EOL]     } else if (bean instanceof Element) { [EOL]         return new JDOMNodePointer(parent, bean); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     if (bean instanceof Document) { [EOL]         return new JDOMNodePointer(parent, bean); [EOL]     } else if (bean instanceof Element) { [EOL]         return new JDOMNodePointer(parent, bean); [EOL]     } [EOL]     return null; [EOL] }
public Object getImmediateNode() { [EOL]     Object value = getBaseValue(); [EOL]     if (index != WHOLE_COLLECTION) { [EOL]         if (index >= 0 && index < getLength()) { [EOL]             return ValueUtils.getValue(value, index); [EOL]         } else { [EOL]             return null; [EOL]         } [EOL]     } else { [EOL]         return ValueUtils.getValue(value); [EOL]     } [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     return getValuePointer().getNamespaceURI(prefix); [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     return getValuePointer().getNamespaceURI(prefix); [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     return getValuePointer().getNamespaceURI(prefix); [EOL] }
private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1) { [EOL]     switch(pos) { [EOL]         case 0: [EOL]             if ((active1 & 0xc0000L) != 0L) [EOL]                 return 10; [EOL]             if ((active0 & 0xfffffffff8000000L) != 0L || (active1 & 0x3fffL) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 1: [EOL]             if ((active0 & 0x8000008000000L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0xfff7fffff0000000L) != 0L || (active1 & 0x3fffL) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 1; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 2: [EOL]             if ((active0 & 0x10000070000000L) != 0L || (active1 & 0x208L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0xffe7ffff80000000L) != 0L || (active1 & 0x3df7L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 2; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 3: [EOL]             if ((active0 & 0xc1010180000000L) != 0L || (active1 & 0xd0L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0xff26fefe00000000L) != 0L || (active1 & 0x3d27L) != 0L) { [EOL]                 if (jjmatchedPos != 3) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 3; [EOL]                 } [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 4: [EOL]             if ((active0 & 0xff62fff600000000L) != 0L || (active1 & 0x2907L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 4; [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x4000000000000L) != 0L || (active1 & 0x1420L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x800000000L) != 0L) { [EOL]                 if (jjmatchedPos < 3) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 3; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 5: [EOL]             if ((active0 & 0x8300000000000000L) != 0L || (active1 & 0x100L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x7c62ffe600000000L) != 0L || (active1 & 0x2807L) != 0L) { [EOL]                 if (jjmatchedPos != 5) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 5; [EOL]                 } [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x1000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 4) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 4; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x800000000L) != 0L) { [EOL]                 if (jjmatchedPos < 3) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 3; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 6: [EOL]             if ((active0 & 0x200000000L) != 0L || (active1 & 0x804L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x2000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 5) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 5; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x1000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 4) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 4; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0xfc62ffc400000000L) != 0L || (active1 & 0x2003L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 6; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 7: [EOL]             if ((active0 & 0xf460ffc400000000L) != 0L || (active1 & 0x2003L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 7; [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x802000000000000L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x2000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 5) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 5; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 8: [EOL]             if ((active0 & 0x7000000000000000L) != 0L || (active1 & 0x2L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x4000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 7) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 7; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x8460ff8400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL]                 if (jjmatchedPos != 8) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 8; [EOL]                 } [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 9: [EOL]             if ((active0 & 0x20000000000000L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x78000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 8) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 8; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x4000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 7) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 7; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0xb440f80400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 9; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 10: [EOL]             if ((active0 & 0x400000000000000L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x80000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 9) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 9; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x78000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 8) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 8; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0xb040f00400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 10; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 11: [EOL]             if ((active0 & 0xb040f00400000000L) != 0L || (active1 & 0x2001L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 11; [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x80000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 9) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 9; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 12: [EOL]             if ((active0 & 0x8040000000000000L) != 0L || (active1 & 0x2000L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x3000f00400000000L) != 0L || (active1 & 0x1L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 12; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 13: [EOL]             if ((active0 & 0x3000f00400000000L) != 0L || (active1 & 0x1L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 13; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 14: [EOL]             if ((active0 & 0x2000000000000000L) != 0L || (active1 & 0x1L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0x1000f00400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 14; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 15: [EOL]             if ((active0 & 0x1000000000000000L) != 0L) [EOL]                 return 12; [EOL]             if ((active0 & 0xf00400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 15; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 16: [EOL]             if ((active0 & 0xe00400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 16; [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x100000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 15) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 15; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 17: [EOL]             if ((active0 & 0x600000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 16) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 16; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x100000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 15) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 15; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x800400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 17; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         case 18: [EOL]             if ((active0 & 0x400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 18; [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x800000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 17) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 17; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             if ((active0 & 0x600000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 16) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 16; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 19: [EOL]             if ((active0 & 0x400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 19; [EOL]                 return 12; [EOL]             } [EOL]             if ((active0 & 0x800000000000L) != 0L) { [EOL]                 if (jjmatchedPos < 17) { [EOL]                     jjmatchedKind = 78; [EOL]                     jjmatchedPos = 17; [EOL]                 } [EOL]                 return -1; [EOL]             } [EOL]             return -1; [EOL]         case 20: [EOL]             if ((active0 & 0x400000000L) != 0L) { [EOL]                 jjmatchedKind = 78; [EOL]                 jjmatchedPos = 20; [EOL]                 return 12; [EOL]             } [EOL]             return -1; [EOL]         default: [EOL]             return -1; [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa0_0() { [EOL]     switch(curChar) { [EOL]         case 33: [EOL]             return jjMoveStringLiteralDfa1_0(0x1000L, 0x0L); [EOL]         case 36: [EOL]             return jjStopAtPos(0, 17); [EOL]         case 40: [EOL]             return jjStopAtPos(0, 80); [EOL]         case 41: [EOL]             return jjStopAtPos(0, 81); [EOL]         case 42: [EOL]             return jjStopAtPos(0, 88); [EOL]         case 43: [EOL]             return jjStopAtPos(0, 9); [EOL]         case 44: [EOL]             return jjStopAtPos(0, 87); [EOL]         case 45: [EOL]             return jjStopAtPos(0, 10); [EOL]         case 46: [EOL]             jjmatchedKind = 82; [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x80000L); [EOL]         case 47: [EOL]             jjmatchedKind = 6; [EOL]             return jjMoveStringLiteralDfa1_0(0x80L, 0x0L); [EOL]         case 58: [EOL]             return jjStopAtPos(0, 79); [EOL]         case 60: [EOL]             jjmatchedKind = 13; [EOL]             return jjMoveStringLiteralDfa1_0(0x4000L, 0x0L); [EOL]         case 61: [EOL]             return jjStopAtPos(0, 11); [EOL]         case 62: [EOL]             jjmatchedKind = 15; [EOL]             return jjMoveStringLiteralDfa1_0(0x10000L, 0x0L); [EOL]         case 64: [EOL]             return jjStopAtPos(0, 86); [EOL]         case 91: [EOL]             return jjStopAtPos(0, 84); [EOL]         case 93: [EOL]             return jjStopAtPos(0, 85); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa1_0(0x10c010000000L, 0x0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x4L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa1_0(0xa04001200000000L, 0x800L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa1_0(0x880040000000L, 0x0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa1_0(0x240000000000L, 0x2420L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000000000L, 0x0L); [EOL]         case 107: [EOL]             return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa1_0(0x21000000000000L, 0x80L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa1_0(0x20000000L, 0x0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa1_0(0xc0010080000000L, 0x149L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa1_0(0x8000000L, 0x0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa1_0(0x2422400000000L, 0x0L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa1_0(0x0L, 0x1000L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa1_0(0xf500000800000000L, 0x200L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa1_0(0x100000000L, 0x12L); [EOL]         case 124: [EOL]             return jjStopAtPos(0, 8); [EOL]         default: [EOL]             return jjMoveNfa_0(0, 0); [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa1_0(long active0, long active1) { [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(0, active0, active1); [EOL]         return 1; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 46: [EOL]             if ((active1 & 0x80000L) != 0L) [EOL]                 return jjStopAtPos(1, 83); [EOL]             break; [EOL]         case 47: [EOL]             if ((active0 & 0x80L) != 0L) [EOL]                 return jjStopAtPos(1, 7); [EOL]             break; [EOL]         case 61: [EOL]             if ((active0 & 0x1000L) != 0L) [EOL]                 return jjStopAtPos(1, 12); [EOL]             else if ((active0 & 0x4000L) != 0L) [EOL]                 return jjStopAtPos(1, 14); [EOL]             else if ((active0 & 0x10000L) != 0L) [EOL]                 return jjStopAtPos(1, 16); [EOL]             break; [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0xc1012000000000L, active1, 0xa0L); [EOL]         case 100: [EOL]             if ((active0 & 0x8000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(1, 51, 12); [EOL]             break; [EOL]         case 101: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x10880900000000L, active1, 0x800L); [EOL]         case 104: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x1000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x40000000L, active1, 0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x400L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x104010000000L, active1, 0L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0xa262402a0000000L, active1, 0x300dL); [EOL]         case 114: [EOL]             if ((active0 & 0x8000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(1, 27, 12); [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x420400000000L, active1, 0x12L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x8500008000000000L, active1, 0L); [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa2_0(active0, 0x7000000000000000L, active1, 0x340L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(0, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(0, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(1, active0, active1); [EOL]         return 2; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x400000000000000L, active1, 0x2L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x7000000000000000L, active1, 0L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x20104000000000L, active1, 0L); [EOL]         case 100: [EOL]             if ((active0 & 0x10000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 28, 12); [EOL]             else if ((active0 & 0x20000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 29, 12); [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x80000000L, active1, 0L); [EOL]         case 101: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x420000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x1000000000L, active1, 0x800L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x240800000000L, active1, 0x60L); [EOL]         case 109: [EOL]             if ((active1 & 0x200L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 73, 12); [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0xc0010200000000L, active1, 0x100L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0xa00000000000000L, active1, 0x80L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x400000000L, active1, 0x404L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x8100002000000000L, active1, 0x2001L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x3880000000000L, active1, 0L); [EOL]         case 116: [EOL]             if ((active1 & 0x8L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 67, 12); [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x8000000000L, active1, 0L); [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x4000000000000L, active1, 0x1010L); [EOL]         case 118: [EOL]             if ((active0 & 0x40000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 30, 12); [EOL]             break; [EOL]         case 120: [EOL]             return jjMoveStringLiteralDfa3_0(active0, 0x100000000L, active1, 0L); [EOL]         case 121: [EOL]             if ((active0 & 0x10000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(2, 52, 12); [EOL]             break; [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(1, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(1, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(2, active0, active1); [EOL]         return 3; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x20000000000000L, active1, 0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x100L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x200ca0400000000L, active1, 0L); [EOL]         case 101: [EOL]             if ((active0 & 0x80000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(3, 31, 12); [EOL]             else if ((active0 & 0x80000000000000L) != 0L) { [EOL]                 jjmatchedKind = 55; [EOL]                 jjmatchedPos = 3; [EOL]             } else if ((active1 & 0x10L) != 0L) [EOL]                 return jjStartNfaWithStates_0(3, 68, 12); [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x40116000000000L, active1, 0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x800000000L, active1, 0L); [EOL]         case 103: [EOL]             if ((active1 & 0x80L) != 0L) [EOL]                 return jjStartNfaWithStates_0(3, 71, 12); [EOL]             break; [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x8102000000000000L, active1, 0L); [EOL]         case 108: [EOL]             if ((active1 & 0x40L) != 0L) [EOL]                 return jjStartNfaWithStates_0(3, 70, 12); [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x241000000000L, active1, 0x804L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x200000000L, active1, 0x2001L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x4000000000000L, active1, 0x1002L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x400L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x400008000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x7000000000000000L, active1, 0x20L); [EOL]         case 116: [EOL]             if ((active0 & 0x100000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(3, 32, 12); [EOL]             else if ((active0 & 0x1000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(3, 48, 12); [EOL]             return jjMoveStringLiteralDfa4_0(active0, 0x800000000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(2, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(2, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(3, active0, active1); [EOL]         return 4; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 58: [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x800000000L, active1, 0L); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0xa00000000000000L, active1, 0x2001L); [EOL]         case 100: [EOL]             if ((active1 & 0x1000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(4, 76, 12); [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x1000000000L, active1, 0L); [EOL]         case 101: [EOL]             if ((active1 & 0x20L) != 0L) [EOL]                 return jjStartNfaWithStates_0(4, 69, 12); [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0xca0600000000L, active1, 0x104L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x8000000000L, active1, 0x800L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x20000000000000L, active1, 0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x8100002000000000L, active1, 0L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x240000000000L, active1, 0L); [EOL]         case 114: [EOL]             if ((active1 & 0x400L) != 0L) [EOL]                 return jjStartNfaWithStates_0(4, 74, 12); [EOL]             break; [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x40114000000000L, active1, 0x2L); [EOL]         case 116: [EOL]             if ((active0 & 0x4000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(4, 50, 12); [EOL]             return jjMoveStringLiteralDfa5_0(active0, 0x7402000000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(3, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(3, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(4, active0, active1); [EOL]         return 5; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x20000000000000L, active1, 0L); [EOL]         case 58: [EOL]             if ((active0 & 0x800000000L) != 0L) [EOL]                 return jjStopAtPos(5, 35); [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x1000000000L, active1, 0L); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x4L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x8000000000L, active1, 0L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x420000000000L, active1, 0L); [EOL]         case 103: [EOL]             if ((active0 & 0x100000000000000L) != 0L) { [EOL]                 jjmatchedKind = 56; [EOL]                 jjmatchedPos = 5; [EOL]             } [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x8000000000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x802000000000000L, active1, 0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x3L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x880200000000L, active1, 0x800L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x40010000000000L, active1, 0L); [EOL]         case 114: [EOL]             if ((active1 & 0x100L) != 0L) [EOL]                 return jjStartNfaWithStates_0(5, 72, 12); [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x7000000000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x400000400000000L, active1, 0L); [EOL]         case 116: [EOL]             if ((active0 & 0x200000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(5, 57, 12); [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x106000000000L, active1, 0x2000L); [EOL]         case 119: [EOL]             return jjMoveStringLiteralDfa6_0(active0, 0x240000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(4, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(4, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(5, active0, active1); [EOL]         return 6; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x8400000000000000L, active1, 0x2000L); [EOL]         case 58: [EOL]             if ((active0 & 0x1000000000L) != 0L) [EOL]                 return jjStopAtPos(6, 36); [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x2000000000L, active1, 0L); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x40010000000000L, active1, 0x2L); [EOL]         case 100: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x880000000000L, active1, 0L); [EOL]         case 103: [EOL]             if ((active1 & 0x800L) != 0L) [EOL]                 return jjStartNfaWithStates_0(6, 75, 12); [EOL]             break; [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x7000660000000000L, active1, 0x1L); [EOL]         case 110: [EOL]             if ((active1 & 0x4L) != 0L) [EOL]                 return jjStartNfaWithStates_0(6, 66, 12); [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x820000000000000L, active1, 0L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x2104000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x400000000L, active1, 0L); [EOL]         case 116: [EOL]             if ((active0 & 0x200000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(6, 33, 12); [EOL]             break; [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa7_0(active0, 0x8000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(5, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(5, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(6, active0, active1); [EOL]         return 7; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 58: [EOL]             if ((active0 & 0x2000000000L) != 0L) [EOL]                 return jjStopAtPos(7, 37); [EOL]             break; [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x20880000000000L, active1, 0L); [EOL]         case 99: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x40010000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x400000000L, active1, 0L); [EOL]         case 108: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x8000000000000000L, active1, 0L); [EOL]         case 110: [EOL]             if ((active0 & 0x2000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(7, 49, 12); [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x7000660000000000L, active1, 0x2000L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x104000000000L, active1, 0L); [EOL]         case 115: [EOL]             if ((active0 & 0x800000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(7, 59, 12); [EOL]             break; [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x8000000000L, active1, 0x2L); [EOL]         case 119: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0x400000000000000L, active1, 0L); [EOL]         case 122: [EOL]             return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x1L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(6, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(6, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(7, active0, active1); [EOL]         return 8; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x100000000000L, active1, 0L); [EOL]         case 58: [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x4000000000L, active1, 0L); [EOL]         case 101: [EOL]             if ((active1 & 0x2L) != 0L) [EOL]                 return jjStartNfaWithStates_0(8, 65, 12); [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x8040018000000000L, active1, 0x1L); [EOL]         case 103: [EOL]             if ((active0 & 0x4000000000000000L) != 0L) { [EOL]                 jjmatchedKind = 62; [EOL]                 jjmatchedPos = 8; [EOL]             } [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x3000660000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x400000000000000L, active1, 0L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x20000000000000L, active1, 0L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0x880400000000L, active1, 0L); [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x2000L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(7, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(7, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(8, active0, active1); [EOL]         return 9; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0x3040600000000000L, active1, 0x1L); [EOL]         case 58: [EOL]             if ((active0 & 0x4000000000L) != 0L) [EOL]                 return jjStopAtPos(9, 38); [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0x78000000000L, active1, 0L); [EOL]         case 101: [EOL]             if ((active0 & 0x20000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(9, 53, 12); [EOL]             break; [EOL]         case 103: [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0x400000000L, active1, 0L); [EOL]         case 109: [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0L, active1, 0x2000L); [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0x8000000000000000L, active1, 0L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0x100000000000L, active1, 0L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa10_0(active0, 0x400880000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(8, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(8, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(9, active0, active1); [EOL]         return 10; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x800400000000L, active1, 0L); [EOL]         case 58: [EOL]             if ((active0 & 0x8000000000L) != 0L) [EOL]                 return jjStopAtPos(10, 39); [EOL]             else if ((active0 & 0x10000000000L) != 0L) [EOL]                 return jjStopAtPos(10, 40); [EOL]             else if ((active0 & 0x20000000000L) != 0L) [EOL]                 return jjStopAtPos(10, 41); [EOL]             else if ((active0 & 0x40000000000L) != 0L) [EOL]                 return jjStopAtPos(10, 42); [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x80000000000L, active1, 0L); [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x2000000000000000L, active1, 0L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x1000000000000000L, active1, 0x2000L); [EOL]         case 103: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x8000000000000000L, active1, 0L); [EOL]         case 104: [EOL]             if ((active0 & 0x400000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(10, 58, 12); [EOL]             break; [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x100000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x600000000000L, active1, 0x1L); [EOL]         case 117: [EOL]             return jjMoveStringLiteralDfa11_0(active0, 0x40000000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(9, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(9, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(10, active0, active1); [EOL]         return 11; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 45: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x100000000000L, active1, 0L); [EOL]         case 58: [EOL]             if ((active0 & 0x80000000000L) != 0L) [EOL]                 return jjStopAtPos(11, 43); [EOL]             break; [EOL]         case 101: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x1000000000000000L, active1, 0x2000L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x2000000000000000L, active1, 0L); [EOL]         case 105: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x600400000000L, active1, 0L); [EOL]         case 111: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x800000000000L, active1, 0L); [EOL]         case 112: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0L, active1, 0x1L); [EOL]         case 114: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x40000000000000L, active1, 0L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa12_0(active0, 0x8000000000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(10, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1) { [EOL]     if (((active0 &= old0) | (active1 &= old1)) == 0L) [EOL]         return jjStartNfa_0(10, old0, old1); [EOL]     try { [EOL]         curChar = input_stream.readChar(); [EOL]     } catch (java.io.IOException e) { [EOL]         jjStopStringLiteralDfa_0(11, active0, active1); [EOL]         return 12; [EOL]     } [EOL]     switch(curChar) { [EOL]         case 97: [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0L, active1, 0x1L); [EOL]         case 98: [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0x600000000000L, active1, 0L); [EOL]         case 102: [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0x1000000000000000L, active1, 0L); [EOL]         case 104: [EOL]             if ((active0 & 0x8000000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(12, 63, 12); [EOL]             break; [EOL]         case 105: [EOL]             if ((active0 & 0x40000000000000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(12, 54, 12); [EOL]             break; [EOL]         case 110: [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0x400000000L, active1, 0L); [EOL]         case 114: [EOL]             if ((active1 & 0x2000L) != 0L) [EOL]                 return jjStartNfaWithStates_0(12, 77, 12); [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0x800000000000L, active1, 0L); [EOL]         case 115: [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0x100000000000L, active1, 0L); [EOL]         case 116: [EOL]             return jjMoveStringLiteralDfa13_0(active0, 0x2000000000000000L, active1, 0L); [EOL]         default: [EOL]             break; [EOL]     } [EOL]     return jjStartNfa_0(11, active0, active1); [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
private final int jjMoveNfa_0(int startState, int curPos) { [EOL]     int[] nextStates; [EOL]     int startsAt = 0; [EOL]     jjnewStateCnt = 13; [EOL]     int i = 1; [EOL]     jjstateSet[0] = startState; [EOL]     int j, kind = 0x7fffffff; [EOL]     for (; ; ) { [EOL]         if (++jjround == 0x7fffffff) [EOL]             ReInitRounds(); [EOL]         if (curChar < 64) { [EOL]             long l = 1L << curChar; [EOL]             MatchLoop: do { [EOL]                 switch(jjstateSet[--i]) { [EOL]                     case 0: [EOL]                         if ((0x3ff000000000000L & l) != 0L) { [EOL]                             if (kind > 20) [EOL]                                 kind = 20; [EOL]                             jjCheckNAddTwoStates(6, 7); [EOL]                         } else if (curChar == 46) [EOL]                             jjCheckNAdd(10); [EOL]                         else if (curChar == 39) [EOL]                             jjCheckNAddTwoStates(4, 5); [EOL]                         else if (curChar == 34) [EOL]                             jjCheckNAddTwoStates(1, 2); [EOL]                         break; [EOL]                     case 1: [EOL]                         if ((0xfffffffbffffffffL & l) != 0L) [EOL]                             jjCheckNAddTwoStates(1, 2); [EOL]                         break; [EOL]                     case 2: [EOL]                         if (curChar == 34 && kind > 18) [EOL]                             kind = 18; [EOL]                         break; [EOL]                     case 3: [EOL]                         if (curChar == 39) [EOL]                             jjCheckNAddTwoStates(4, 5); [EOL]                         break; [EOL]                     case 4: [EOL]                         if ((0xffffff7fffffffffL & l) != 0L) [EOL]                             jjCheckNAddTwoStates(4, 5); [EOL]                         break; [EOL]                     case 5: [EOL]                         if (curChar == 39 && kind > 18) [EOL]                             kind = 18; [EOL]                         break; [EOL]                     case 6: [EOL]                         if ((0x3ff000000000000L & l) == 0L) [EOL]                             break; [EOL]                         if (kind > 20) [EOL]                             kind = 20; [EOL]                         jjCheckNAddTwoStates(6, 7); [EOL]                         break; [EOL]                     case 7: [EOL]                         if (curChar != 46) [EOL]                             break; [EOL]                         if (kind > 20) [EOL]                             kind = 20; [EOL]                         jjCheckNAdd(8); [EOL]                         break; [EOL]                     case 8: [EOL]                         if ((0x3ff000000000000L & l) == 0L) [EOL]                             break; [EOL]                         if (kind > 20) [EOL]                             kind = 20; [EOL]                         jjCheckNAdd(8); [EOL]                         break; [EOL]                     case 9: [EOL]                         if (curChar == 46) [EOL]                             jjCheckNAdd(10); [EOL]                         break; [EOL]                     case 10: [EOL]                         if ((0x3ff000000000000L & l) == 0L) [EOL]                             break; [EOL]                         if (kind > 20) [EOL]                             kind = 20; [EOL]                         jjCheckNAdd(10); [EOL]                         break; [EOL]                     case 12: [EOL]                         if ((0x3ff600000000000L & l) == 0L) [EOL]                             break; [EOL]                         if (kind > 78) [EOL]                             kind = 78; [EOL]                         jjstateSet[jjnewStateCnt++] = 12; [EOL]                         break; [EOL]                     default: [EOL]                         break; [EOL]                 } [EOL]             } while (i != startsAt); [EOL]         } else if (curChar < 128) { [EOL]             long l = 1L << (curChar & 077); [EOL]             MatchLoop: do { [EOL]                 switch(jjstateSet[--i]) { [EOL]                     case 0: [EOL]                     case 12: [EOL]                         if ((0x7fffffe87fffffeL & l) == 0L) [EOL]                             break; [EOL]                         if (kind > 78) [EOL]                             kind = 78; [EOL]                         jjCheckNAdd(12); [EOL]                         break; [EOL]                     case 1: [EOL]                         jjAddStates(0, 1); [EOL]                         break; [EOL]                     case 4: [EOL]                         jjAddStates(2, 3); [EOL]                         break; [EOL]                     default: [EOL]                         break; [EOL]                 } [EOL]             } while (i != startsAt); [EOL]         } else { [EOL]             int hiByte = (int) (curChar >> 8); [EOL]             int i1 = hiByte >> 6; [EOL]             long l1 = 1L << (hiByte & 077); [EOL]             int i2 = (curChar & 0xff) >> 6; [EOL]             long l2 = 1L << (curChar & 077); [EOL]             MatchLoop: do { [EOL]                 switch(jjstateSet[--i]) { [EOL]                     case 0: [EOL]                         if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) [EOL]                             break; [EOL]                         if (kind > 78) [EOL]                             kind = 78; [EOL]                         jjCheckNAdd(12); [EOL]                         break; [EOL]                     case 1: [EOL]                         if (jjCanMove_0(hiByte, i1, i2, l1, l2)) [EOL]                             jjAddStates(0, 1); [EOL]                         break; [EOL]                     case 4: [EOL]                         if (jjCanMove_0(hiByte, i1, i2, l1, l2)) [EOL]                             jjAddStates(2, 3); [EOL]                         break; [EOL]                     case 12: [EOL]                         if (!jjCanMove_2(hiByte, i1, i2, l1, l2)) [EOL]                             break; [EOL]                         if (kind > 78) [EOL]                             kind = 78; [EOL]                         jjCheckNAdd(12); [EOL]                         break; [EOL]                     default: [EOL]                         break; [EOL]                 } [EOL]             } while (i != startsAt); [EOL]         } [EOL]         if (kind != 0x7fffffff) { [EOL]             jjmatchedKind = kind; [EOL]             jjmatchedPos = curPos; [EOL]             kind = 0x7fffffff; [EOL]         } [EOL]         ++curPos; [EOL]         if ((i = jjnewStateCnt) == (startsAt = 13 - (jjnewStateCnt = startsAt))) [EOL]             return curPos; [EOL]         try { [EOL]             curChar = input_stream.readChar(); [EOL]         } catch (java.io.IOException e) { [EOL]             return curPos; [EOL]         } [EOL]     } [EOL] } public XPathParserTokenManager(SimpleCharStream stream); public XPathParserTokenManager(SimpleCharStream stream, int lexState); public void setDebugStream(java.io.PrintStream ds); private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1); private final int jjStartNfa_0(int pos, long active0, long active1); private final int jjStopAtPos(int pos, int kind); private final int jjStartNfaWithStates_0(int pos, int kind, int state); private final int jjMoveStringLiteralDfa0_0(); private final int jjMoveStringLiteralDfa1_0(long active0, long active1); private final int jjMoveStringLiteralDfa2_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa3_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa4_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa5_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa6_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa7_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa8_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa9_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa10_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa11_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa12_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa13_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa14_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa15_0(long old0, long active0, long old1, long active1); private final int jjMoveStringLiteralDfa16_0(long old0, long active0); private final int jjMoveStringLiteralDfa17_0(long old0, long active0); private final int jjMoveStringLiteralDfa18_0(long old0, long active0); private final int jjMoveStringLiteralDfa19_0(long old0, long active0); private final int jjMoveStringLiteralDfa20_0(long old0, long active0); private final int jjMoveStringLiteralDfa21_0(long old0, long active0); private final void jjCheckNAdd(int state); private final void jjAddStates(int start, int end); private final void jjCheckNAddTwoStates(int state1, int state2); private final void jjCheckNAddStates(int start, int end); private final void jjCheckNAddStates(int start); private final int jjMoveNfa_0(int startState, int curPos); private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_1(int hiByte, int i1, int i2, long l1, long l2); private static final boolean jjCanMove_2(int hiByte, int i1, int i2, long l1, long l2); public void ReInit(SimpleCharStream stream); private final void ReInitRounds(); public void ReInit(SimpleCharStream stream, int lexState); public void SwitchTo(int lexState); protected Token jjFillToken(); public Token getNextToken(); java.io.PrintStream debugStream=Optional[System.out]; long[] jjbitVec0=Optional[{ 0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec2=Optional[{ 0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL }]; long[] jjbitVec3=Optional[{ 0x0L, 0xffffffffffffc000L, 0xfffff0007fffffffL, 0x7fffffL }]; long[] jjbitVec4=Optional[{ 0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL }]; long[] jjbitVec5=Optional[{ 0x7ff3ffffffffffffL, 0x7ffffffffffffdfeL, 0xffffffffffffffffL, 0xfc31ffffffffe00fL }]; long[] jjbitVec6=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x3L }]; long[] jjbitVec7=Optional[{ 0x0L, 0x0L, 0xfffffffbffffd740L, 0xffffd547f7fffL }]; long[] jjbitVec8=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff0003L, 0x33fcfffffff199fL }]; long[] jjbitVec9=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0x7fL, 0x707ffffff0000L }]; long[] jjbitVec10=Optional[{ 0x7fffffe00000000L, 0xfffe0000000007feL, 0x7cffffffffffffffL, 0x60002f7fffL }]; long[] jjbitVec11=Optional[{ 0x23ffffffffffffe0L, 0x3ff000000L, 0x3c5fdfffff99fe0L, 0x30003b0000000L }]; long[] jjbitVec12=Optional[{ 0x36dfdfffff987e0L, 0x1c00005e000000L, 0x23edfdfffffbafe0L, 0x100000000L }]; long[] jjbitVec13=Optional[{ 0x23cdfdfffff99fe0L, 0x3b0000000L, 0x3bfc718d63dc7e0L, 0x0L }]; long[] jjbitVec14=Optional[{ 0x3effdfffffddfe0L, 0x300000000L, 0x3effdfffffddfe0L, 0x340000000L }]; long[] jjbitVec15=Optional[{ 0x3fffdfffffddfe0L, 0x300000000L, 0x0L, 0x0L }]; long[] jjbitVec16=Optional[{ 0xd7ffffffffffeL, 0x3fL, 0x200d6caefef02596L, 0x1fL }]; long[] jjbitVec17=Optional[{ 0x0L, 0x3fffffffeffL, 0x0L, 0x0L }]; long[] jjbitVec18=Optional[{ 0x0L, 0x0L, 0xffffffff00000000L, 0x7fffffffff003fL }]; long[] jjbitVec19=Optional[{ 0x500000000007daedL, 0x2c62ab82315001L, 0xf580c90040000000L, 0x201080000000007L }]; long[] jjbitVec20=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL }]; long[] jjbitVec21=Optional[{ 0xffffffff3f3fffffL, 0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL }]; long[] jjbitVec22=Optional[{ 0x4c4000000000L, 0x0L, 0x7L, 0x0L }]; long[] jjbitVec23=Optional[{ 0x3fe00000080L, 0xfffffffffffffffeL, 0xfffffffe001fffffL, 0x7ffffffffffffffL }]; long[] jjbitVec24=Optional[{ 0x1fffffffffe0L, 0x0L, 0x0L, 0x0L }]; long[] jjbitVec25=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffL, 0x0L }]; long[] jjbitVec26=Optional[{ 0xffffffffffffffffL, 0xffffffffffffffffL, 0xfffffffffL, 0x0L }]; long[] jjbitVec27=Optional[{ 0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL }]; long[] jjbitVec28=Optional[{ 0xffffffL, 0xffffffffffff0000L, 0xf80001ffffffffffL, 0x30003L }]; long[] jjbitVec29=Optional[{ 0xffffffffffffffffL, 0x30000003fL, 0xfffffffbffffd7c0L, 0xffffd547f7fffL }]; long[] jjbitVec30=Optional[{ 0xffffffffffffdffeL, 0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL }]; long[] jjbitVec31=Optional[{ 0xfffe000000000000L, 0xfffffffe027fffffL, 0xbbfffffbfffe007fL, 0x707ffffff0016L }]; long[] jjbitVec32=Optional[{ 0x7fffffe00000000L, 0xffff03ff0007ffffL, 0x7cffffffffffffffL, 0x3ff3dffffef7fffL }]; long[] jjbitVec33=Optional[{ 0xf3ffffffffffffeeL, 0xffcfff1e3fffL, 0xd3c5fdfffff99feeL, 0x3ffcfb080399fL }]; long[] jjbitVec34=Optional[{ 0xd36dfdfffff987e4L, 0x1fffc05e003987L, 0xf3edfdfffffbafeeL, 0xffc100003bbfL }]; long[] jjbitVec35=Optional[{ 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL, 0xc3bfc718d63dc7ecL, 0xff8000803dc7L }]; long[] jjbitVec36=Optional[{ 0xc3effdfffffddfeeL, 0xffc300603ddfL, 0xc3effdfffffddfecL, 0xffc340603ddfL }]; long[] jjbitVec37=Optional[{ 0xc3fffdfffffddfecL, 0xffc300803dcfL, 0x0L, 0x0L }]; long[] jjbitVec38=Optional[{ 0x7ff7ffffffffffeL, 0x3ff7fffL, 0x3bff6caefef02596L, 0x3ff3f5fL }]; long[] jjbitVec39=Optional[{ 0xc2a003ff03000000L, 0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L }]; long[] jjbitVec40=Optional[{ 0x0L, 0x0L, 0x0L, 0x21fff0000L }]; long[] jjbitVec41=Optional[{ 0x3efffe000000a0L, 0xfffffffffffffffeL, 0xfffffffe661fffffL, 0x77ffffffffffffffL }]; int[] jjnextStates=Optional[{ 1, 2, 4, 5 }]; String[] jjstrLiteralImages=Optional[{ "", null, null, null, null, null, "\57", "\57\57", "\174", "\53", "\55", "\75", "\41\75", "\74", "\74\75", "\76", "\76\75", "\44", null, null, null, null, null, null, null, null, null, "\157\162", "\141\156\144", "\155\157\144", "\144\151\166", "\156\157\144\145", "\164\145\170\164", "\143\157\155\155\145\156\164", "\160\162\157\143\145\163\163\151\156\147\55\151\156\163\164\162\165\143\164\151\157\156", "\163\145\154\146\72\72", "\143\150\151\154\144\72\72", "\160\141\162\145\156\164\72\72", "\141\156\143\145\163\164\157\162\72\72", "\141\164\164\162\151\142\165\164\145\72\72", "\156\141\155\145\163\160\141\143\145\72\72", "\160\162\145\143\145\144\151\156\147\72\72", "\146\157\154\154\157\167\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\72\72", "\141\156\143\145\163\164\157\162\55\157\162\55\163\145\154\146\72\72", "\146\157\154\154\157\167\151\156\147\55\163\151\142\154\151\156\147\72\72", "\160\162\145\143\145\144\151\156\147\55\163\151\142\154\151\156\147\72\72", "\144\145\163\143\145\156\144\141\156\164\55\157\162\55\163\145\154\146\72\72", "\154\141\163\164", "\160\157\163\151\164\151\157\156", "\143\157\165\156\164", "\151\144", "\153\145\171", "\154\157\143\141\154\55\156\141\155\145", "\156\141\155\145\163\160\141\143\145\55\165\162\151", "\156\141\155\145", "\163\164\162\151\156\147", "\143\157\156\143\141\164", "\163\164\141\162\164\163\55\167\151\164\150", "\143\157\156\164\141\151\156\163", "\163\165\142\163\164\162\151\156\147\55\142\145\146\157\162\145", "\163\165\142\163\164\162\151\156\147\55\141\146\164\145\162", "\163\165\142\163\164\162\151\156\147", "\163\164\162\151\156\147\55\154\145\156\147\164\150", "\156\157\162\155\141\154\151\172\145\55\163\160\141\143\145", "\164\162\141\156\163\154\141\164\145", "\142\157\157\154\145\141\156", "\156\157\164", "\164\162\165\145", "\146\141\154\163\145", "\156\165\154\154", "\154\141\156\147", "\156\165\155\142\145\162", "\163\165\155", "\146\154\157\157\162", "\143\145\151\154\151\156\147", "\162\157\165\156\144", "\146\157\162\155\141\164\55\156\165\155\142\145\162", null, "\72", "\50", "\51", "\56", "\56\56", "\133", "\135", "\100", "\54", "\52" }]; String[] lexStateNames=Optional[{ "DEFAULT" }]; long[] jjtoToken=Optional[{ 0xfffffffff817ffc1L, 0x1ffffffL }]; long[] jjtoSkip=Optional[{ 0x3eL, 0x0L }
public DOMNodePointer(NodePointer parent, Node node) { [EOL]     super(parent); [EOL]     this.node = node; [EOL] }
public DOMNodePointer(NodePointer parent, Node node) { [EOL]     super(parent); [EOL]     this.node = node; [EOL] }
public DOMNodePointer(NodePointer parent, Node node) { [EOL]     super(parent); [EOL]     this.node = node; [EOL] }
public DOMNodePointer(NodePointer parent, Node node) { [EOL]     super(parent); [EOL]     this.node = node; [EOL] }
public boolean testNode(NodeTest test) { [EOL]     return testNode(node, test); [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public static boolean testNode(Node node, NodeTest test) { [EOL]     if (test == null) { [EOL]         return true; [EOL]     } else if (test instanceof NodeNameTest) { [EOL]         if (node.getNodeType() != Node.ELEMENT_NODE) { [EOL]             return false; [EOL]         } [EOL]         NodeNameTest nodeNameTest = (NodeNameTest) test; [EOL]         QName testName = nodeNameTest.getNodeName(); [EOL]         String namespaceURI = nodeNameTest.getNamespaceURI(); [EOL]         boolean wildcard = nodeNameTest.isWildcard(); [EOL]         String testPrefix = testName.getPrefix(); [EOL]         if (wildcard && testPrefix == null) { [EOL]             return true; [EOL]         } [EOL]         if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { [EOL]             String nodeNS = DOMNodePointer.getNamespaceURI(node); [EOL]             return equalStrings(namespaceURI, nodeNS); [EOL]         } [EOL]     } else if (test instanceof NodeTypeTest) { [EOL]         int nodeType = node.getNodeType(); [EOL]         switch(((NodeTypeTest) test).getNodeType()) { [EOL]             case Compiler.NODE_TYPE_NODE: [EOL]                 return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; [EOL]             case Compiler.NODE_TYPE_TEXT: [EOL]                 return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; [EOL]             case Compiler.NODE_TYPE_COMMENT: [EOL]                 return nodeType == Node.COMMENT_NODE; [EOL]             case Compiler.NODE_TYPE_PI: [EOL]                 return nodeType == Node.PROCESSING_INSTRUCTION_NODE; [EOL]         } [EOL]         return false; [EOL]     } else if (test instanceof ProcessingInstructionTest) { [EOL]         if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]             String testPI = ((ProcessingInstructionTest) test).getTarget(); [EOL]             String nodePI = ((ProcessingInstruction) node).getTarget(); [EOL]             return testPI.equals(nodePI); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null) { [EOL]         return s2 == null || s2.trim().length() == 0; [EOL]     } [EOL]     if (s2 == null) { [EOL]         return s1 == null || s1.trim().length() == 0; [EOL]     } [EOL]     if (s1 != null && !s1.trim().equals(s2.trim())) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null) { [EOL]         return s2 == null || s2.trim().length() == 0; [EOL]     } [EOL]     if (s2 == null) { [EOL]         return s1 == null || s1.trim().length() == 0; [EOL]     } [EOL]     if (s1 != null && !s1.trim().equals(s2.trim())) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null) { [EOL]         return s2 == null || s2.trim().length() == 0; [EOL]     } [EOL]     if (s2 == null) { [EOL]         return s1 == null || s1.trim().length() == 0; [EOL]     } [EOL]     if (s1 != null && !s1.trim().equals(s2.trim())) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null) { [EOL]         return s2 == null || s2.trim().length() == 0; [EOL]     } [EOL]     if (s2 == null) { [EOL]         return s1 == null || s1.trim().length() == 0; [EOL]     } [EOL]     if (s1 != null && !s1.trim().equals(s2.trim())) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null) { [EOL]         return s2 == null || s2.trim().length() == 0; [EOL]     } [EOL]     if (s2 == null) { [EOL]         return s1 == null || s1.trim().length() == 0; [EOL]     } [EOL]     if (s1 != null && !s1.trim().equals(s2.trim())) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null) { [EOL]         return s2 == null || s2.trim().length() == 0; [EOL]     } [EOL]     if (s2 == null) { [EOL]         return s1 == null || s1.trim().length() == 0; [EOL]     } [EOL]     if (s1 != null && !s1.trim().equals(s2.trim())) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null) { [EOL]         return s2 == null || s2.trim().length() == 0; [EOL]     } [EOL]     if (s2 == null) { [EOL]         return s1 == null || s1.trim().length() == 0; [EOL]     } [EOL]     if (s1 != null && !s1.trim().equals(s2.trim())) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null) { [EOL]         return s2 == null || s2.trim().length() == 0; [EOL]     } [EOL]     if (s2 == null) { [EOL]         return s1 == null || s1.trim().length() == 0; [EOL]     } [EOL]     if (s1 != null && !s1.trim().equals(s2.trim())) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null) { [EOL]         return s2 == null || s2.trim().length() == 0; [EOL]     } [EOL]     if (s2 == null) { [EOL]         return s1 == null || s1.trim().length() == 0; [EOL]     } [EOL]     if (s1 != null && !s1.trim().equals(s2.trim())) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null) { [EOL]         return s2 == null || s2.trim().length() == 0; [EOL]     } [EOL]     if (s2 == null) { [EOL]         return s1 == null || s1.trim().length() == 0; [EOL]     } [EOL]     if (s1 != null && !s1.trim().equals(s2.trim())) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
private static boolean equalStrings(String s1, String s2) { [EOL]     if (s1 == null) { [EOL]         return s2 == null || s2.trim().length() == 0; [EOL]     } [EOL]     if (s2 == null) { [EOL]         return s1 == null || s1.trim().length() == 0; [EOL]     } [EOL]     if (s1 != null && !s1.trim().equals(s2.trim())) { [EOL]         return false; [EOL]     } [EOL]     return true; [EOL] }
public QName getName() { [EOL]     String ln = null; [EOL]     String ns = null; [EOL]     int type = node.getNodeType(); [EOL]     if (type == Node.ELEMENT_NODE) { [EOL]         ns = DOMNodePointer.getPrefix(node); [EOL]         ln = DOMNodePointer.getLocalName(node); [EOL]     } else if (type == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]         ln = ((ProcessingInstruction) node).getTarget(); [EOL]     } [EOL]     return new QName(ns, ln); [EOL] }
public QName getName() { [EOL]     String ln = null; [EOL]     String ns = null; [EOL]     int type = node.getNodeType(); [EOL]     if (type == Node.ELEMENT_NODE) { [EOL]         ns = DOMNodePointer.getPrefix(node); [EOL]         ln = DOMNodePointer.getLocalName(node); [EOL]     } else if (type == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]         ln = ((ProcessingInstruction) node).getTarget(); [EOL]     } [EOL]     return new QName(ns, ln); [EOL] }
public QName getName() { [EOL]     String ln = null; [EOL]     String ns = null; [EOL]     int type = node.getNodeType(); [EOL]     if (type == Node.ELEMENT_NODE) { [EOL]         ns = DOMNodePointer.getPrefix(node); [EOL]         ln = DOMNodePointer.getLocalName(node); [EOL]     } else if (type == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]         ln = ((ProcessingInstruction) node).getTarget(); [EOL]     } [EOL]     return new QName(ns, ln); [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     return new DOMNodeIterator(this, test, reverse, startWith); [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     return new DOMNodeIterator(this, test, reverse, startWith); [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     return new DOMNodeIterator(this, test, reverse, startWith); [EOL] }
public NodeIterator childIterator(NodeTest test, boolean reverse, NodePointer startWith) { [EOL]     return new DOMNodeIterator(this, test, reverse, startWith); [EOL] }
public NodeIterator attributeIterator(QName name) { [EOL]     return new DOMAttributeIterator(this, name); [EOL] }
public NodeIterator attributeIterator(QName name) { [EOL]     return new DOMAttributeIterator(this, name); [EOL] }
public NodePointer namespacePointer(String prefix) { [EOL]     return new NamespacePointer(this, prefix); [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     if (prefix == null || prefix.equals("")) { [EOL]         return getDefaultNamespaceURI(); [EOL]     } [EOL]     if (prefix.equals("xml")) { [EOL]         return XML_NAMESPACE_URI; [EOL]     } [EOL]     if (prefix.equals("xmlns")) { [EOL]         return XMLNS_NAMESPACE_URI; [EOL]     } [EOL]     String namespace = null; [EOL]     if (namespaces == null) { [EOL]         namespaces = new HashMap(); [EOL]     } else { [EOL]         namespace = (String) namespaces.get(prefix); [EOL]     } [EOL]     if (namespace == null) { [EOL]         String qname = "xmlns:" + prefix; [EOL]         Node aNode = node; [EOL]         if (aNode instanceof Document) { [EOL]             aNode = ((Document) aNode).getDocumentElement(); [EOL]         } [EOL]         while (aNode != null) { [EOL]             if (aNode.getNodeType() == Node.ELEMENT_NODE) { [EOL]                 Attr attr = ((Element) aNode).getAttributeNode(qname); [EOL]                 if (attr != null) { [EOL]                     namespace = attr.getValue(); [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             aNode = aNode.getParentNode(); [EOL]         } [EOL]         if (namespace == null || namespace.equals("")) { [EOL]             namespace = NodePointer.UNKNOWN_NAMESPACE; [EOL]         } [EOL]     } [EOL]     namespaces.put(prefix, namespace); [EOL]     if (namespace == UNKNOWN_NAMESPACE) { [EOL]         return null; [EOL]     } [EOL]     return namespace; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     if (prefix == null || prefix.equals("")) { [EOL]         return getDefaultNamespaceURI(); [EOL]     } [EOL]     if (prefix.equals("xml")) { [EOL]         return XML_NAMESPACE_URI; [EOL]     } [EOL]     if (prefix.equals("xmlns")) { [EOL]         return XMLNS_NAMESPACE_URI; [EOL]     } [EOL]     String namespace = null; [EOL]     if (namespaces == null) { [EOL]         namespaces = new HashMap(); [EOL]     } else { [EOL]         namespace = (String) namespaces.get(prefix); [EOL]     } [EOL]     if (namespace == null) { [EOL]         String qname = "xmlns:" + prefix; [EOL]         Node aNode = node; [EOL]         if (aNode instanceof Document) { [EOL]             aNode = ((Document) aNode).getDocumentElement(); [EOL]         } [EOL]         while (aNode != null) { [EOL]             if (aNode.getNodeType() == Node.ELEMENT_NODE) { [EOL]                 Attr attr = ((Element) aNode).getAttributeNode(qname); [EOL]                 if (attr != null) { [EOL]                     namespace = attr.getValue(); [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             aNode = aNode.getParentNode(); [EOL]         } [EOL]         if (namespace == null || namespace.equals("")) { [EOL]             namespace = NodePointer.UNKNOWN_NAMESPACE; [EOL]         } [EOL]     } [EOL]     namespaces.put(prefix, namespace); [EOL]     if (namespace == UNKNOWN_NAMESPACE) { [EOL]         return null; [EOL]     } [EOL]     return namespace; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     if (prefix == null || prefix.equals("")) { [EOL]         return getDefaultNamespaceURI(); [EOL]     } [EOL]     if (prefix.equals("xml")) { [EOL]         return XML_NAMESPACE_URI; [EOL]     } [EOL]     if (prefix.equals("xmlns")) { [EOL]         return XMLNS_NAMESPACE_URI; [EOL]     } [EOL]     String namespace = null; [EOL]     if (namespaces == null) { [EOL]         namespaces = new HashMap(); [EOL]     } else { [EOL]         namespace = (String) namespaces.get(prefix); [EOL]     } [EOL]     if (namespace == null) { [EOL]         String qname = "xmlns:" + prefix; [EOL]         Node aNode = node; [EOL]         if (aNode instanceof Document) { [EOL]             aNode = ((Document) aNode).getDocumentElement(); [EOL]         } [EOL]         while (aNode != null) { [EOL]             if (aNode.getNodeType() == Node.ELEMENT_NODE) { [EOL]                 Attr attr = ((Element) aNode).getAttributeNode(qname); [EOL]                 if (attr != null) { [EOL]                     namespace = attr.getValue(); [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             aNode = aNode.getParentNode(); [EOL]         } [EOL]         if (namespace == null || namespace.equals("")) { [EOL]             namespace = NodePointer.UNKNOWN_NAMESPACE; [EOL]         } [EOL]     } [EOL]     namespaces.put(prefix, namespace); [EOL]     if (namespace == UNKNOWN_NAMESPACE) { [EOL]         return null; [EOL]     } [EOL]     return namespace; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     if (prefix == null || prefix.equals("")) { [EOL]         return getDefaultNamespaceURI(); [EOL]     } [EOL]     if (prefix.equals("xml")) { [EOL]         return XML_NAMESPACE_URI; [EOL]     } [EOL]     if (prefix.equals("xmlns")) { [EOL]         return XMLNS_NAMESPACE_URI; [EOL]     } [EOL]     String namespace = null; [EOL]     if (namespaces == null) { [EOL]         namespaces = new HashMap(); [EOL]     } else { [EOL]         namespace = (String) namespaces.get(prefix); [EOL]     } [EOL]     if (namespace == null) { [EOL]         String qname = "xmlns:" + prefix; [EOL]         Node aNode = node; [EOL]         if (aNode instanceof Document) { [EOL]             aNode = ((Document) aNode).getDocumentElement(); [EOL]         } [EOL]         while (aNode != null) { [EOL]             if (aNode.getNodeType() == Node.ELEMENT_NODE) { [EOL]                 Attr attr = ((Element) aNode).getAttributeNode(qname); [EOL]                 if (attr != null) { [EOL]                     namespace = attr.getValue(); [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             aNode = aNode.getParentNode(); [EOL]         } [EOL]         if (namespace == null || namespace.equals("")) { [EOL]             namespace = NodePointer.UNKNOWN_NAMESPACE; [EOL]         } [EOL]     } [EOL]     namespaces.put(prefix, namespace); [EOL]     if (namespace == UNKNOWN_NAMESPACE) { [EOL]         return null; [EOL]     } [EOL]     return namespace; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     if (prefix == null || prefix.equals("")) { [EOL]         return getDefaultNamespaceURI(); [EOL]     } [EOL]     if (prefix.equals("xml")) { [EOL]         return XML_NAMESPACE_URI; [EOL]     } [EOL]     if (prefix.equals("xmlns")) { [EOL]         return XMLNS_NAMESPACE_URI; [EOL]     } [EOL]     String namespace = null; [EOL]     if (namespaces == null) { [EOL]         namespaces = new HashMap(); [EOL]     } else { [EOL]         namespace = (String) namespaces.get(prefix); [EOL]     } [EOL]     if (namespace == null) { [EOL]         String qname = "xmlns:" + prefix; [EOL]         Node aNode = node; [EOL]         if (aNode instanceof Document) { [EOL]             aNode = ((Document) aNode).getDocumentElement(); [EOL]         } [EOL]         while (aNode != null) { [EOL]             if (aNode.getNodeType() == Node.ELEMENT_NODE) { [EOL]                 Attr attr = ((Element) aNode).getAttributeNode(qname); [EOL]                 if (attr != null) { [EOL]                     namespace = attr.getValue(); [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             aNode = aNode.getParentNode(); [EOL]         } [EOL]         if (namespace == null || namespace.equals("")) { [EOL]             namespace = NodePointer.UNKNOWN_NAMESPACE; [EOL]         } [EOL]     } [EOL]     namespaces.put(prefix, namespace); [EOL]     if (namespace == UNKNOWN_NAMESPACE) { [EOL]         return null; [EOL]     } [EOL]     return namespace; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     if (prefix == null || prefix.equals("")) { [EOL]         return getDefaultNamespaceURI(); [EOL]     } [EOL]     if (prefix.equals("xml")) { [EOL]         return XML_NAMESPACE_URI; [EOL]     } [EOL]     if (prefix.equals("xmlns")) { [EOL]         return XMLNS_NAMESPACE_URI; [EOL]     } [EOL]     String namespace = null; [EOL]     if (namespaces == null) { [EOL]         namespaces = new HashMap(); [EOL]     } else { [EOL]         namespace = (String) namespaces.get(prefix); [EOL]     } [EOL]     if (namespace == null) { [EOL]         String qname = "xmlns:" + prefix; [EOL]         Node aNode = node; [EOL]         if (aNode instanceof Document) { [EOL]             aNode = ((Document) aNode).getDocumentElement(); [EOL]         } [EOL]         while (aNode != null) { [EOL]             if (aNode.getNodeType() == Node.ELEMENT_NODE) { [EOL]                 Attr attr = ((Element) aNode).getAttributeNode(qname); [EOL]                 if (attr != null) { [EOL]                     namespace = attr.getValue(); [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             aNode = aNode.getParentNode(); [EOL]         } [EOL]         if (namespace == null || namespace.equals("")) { [EOL]             namespace = NodePointer.UNKNOWN_NAMESPACE; [EOL]         } [EOL]     } [EOL]     namespaces.put(prefix, namespace); [EOL]     if (namespace == UNKNOWN_NAMESPACE) { [EOL]         return null; [EOL]     } [EOL]     return namespace; [EOL] }
public String getNamespaceURI(String prefix) { [EOL]     if (prefix == null || prefix.equals("")) { [EOL]         return getDefaultNamespaceURI(); [EOL]     } [EOL]     if (prefix.equals("xml")) { [EOL]         return XML_NAMESPACE_URI; [EOL]     } [EOL]     if (prefix.equals("xmlns")) { [EOL]         return XMLNS_NAMESPACE_URI; [EOL]     } [EOL]     String namespace = null; [EOL]     if (namespaces == null) { [EOL]         namespaces = new HashMap(); [EOL]     } else { [EOL]         namespace = (String) namespaces.get(prefix); [EOL]     } [EOL]     if (namespace == null) { [EOL]         String qname = "xmlns:" + prefix; [EOL]         Node aNode = node; [EOL]         if (aNode instanceof Document) { [EOL]             aNode = ((Document) aNode).getDocumentElement(); [EOL]         } [EOL]         while (aNode != null) { [EOL]             if (aNode.getNodeType() == Node.ELEMENT_NODE) { [EOL]                 Attr attr = ((Element) aNode).getAttributeNode(qname); [EOL]                 if (attr != null) { [EOL]                     namespace = attr.getValue(); [EOL]                     break; [EOL]                 } [EOL]             } [EOL]             aNode = aNode.getParentNode(); [EOL]         } [EOL]         if (namespace == null || namespace.equals("")) { [EOL]             namespace = NodePointer.UNKNOWN_NAMESPACE; [EOL]         } [EOL]     } [EOL]     namespaces.put(prefix, namespace); [EOL]     if (namespace == UNKNOWN_NAMESPACE) { [EOL]         return null; [EOL]     } [EOL]     return namespace; [EOL] }
public boolean isActual() { [EOL]     return true; [EOL] }
public boolean isLeaf() { [EOL]     return !node.hasChildNodes(); [EOL] }
public boolean isLeaf() { [EOL]     return !node.hasChildNodes(); [EOL] }
public static String getPrefix(Node node) { [EOL]     String prefix = node.getPrefix(); [EOL]     if (prefix != null) { [EOL]         return prefix; [EOL]     } [EOL]     String name = node.getNodeName(); [EOL]     int index = name.lastIndexOf(':'); [EOL]     if (index == -1) { [EOL]         return null; [EOL]     } [EOL]     return name.substring(0, index); [EOL] }
public static String getPrefix(Node node) { [EOL]     String prefix = node.getPrefix(); [EOL]     if (prefix != null) { [EOL]         return prefix; [EOL]     } [EOL]     String name = node.getNodeName(); [EOL]     int index = name.lastIndexOf(':'); [EOL]     if (index == -1) { [EOL]         return null; [EOL]     } [EOL]     return name.substring(0, index); [EOL] }
public static String getPrefix(Node node) { [EOL]     String prefix = node.getPrefix(); [EOL]     if (prefix != null) { [EOL]         return prefix; [EOL]     } [EOL]     String name = node.getNodeName(); [EOL]     int index = name.lastIndexOf(':'); [EOL]     if (index == -1) { [EOL]         return null; [EOL]     } [EOL]     return name.substring(0, index); [EOL] }
public static String getLocalName(Node node) { [EOL]     String localName = node.getLocalName(); [EOL]     if (localName != null) { [EOL]         return localName; [EOL]     } [EOL]     String name = node.getNodeName(); [EOL]     int index = name.lastIndexOf(':'); [EOL]     if (index == -1) { [EOL]         return name; [EOL]     } [EOL]     return name.substring(index + 1); [EOL] }
public static String getLocalName(Node node) { [EOL]     String localName = node.getLocalName(); [EOL]     if (localName != null) { [EOL]         return localName; [EOL]     } [EOL]     String name = node.getNodeName(); [EOL]     int index = name.lastIndexOf(':'); [EOL]     if (index == -1) { [EOL]         return name; [EOL]     } [EOL]     return name.substring(index + 1); [EOL] }
public static String getLocalName(Node node) { [EOL]     String localName = node.getLocalName(); [EOL]     if (localName != null) { [EOL]         return localName; [EOL]     } [EOL]     String name = node.getNodeName(); [EOL]     int index = name.lastIndexOf(':'); [EOL]     if (index == -1) { [EOL]         return name; [EOL]     } [EOL]     return name.substring(index + 1); [EOL] }
public static String getNamespaceURI(Node node) { [EOL]     if (node instanceof Document) { [EOL]         node = ((Document) node).getDocumentElement(); [EOL]     } [EOL]     Element element = (Element) node; [EOL]     String uri = element.getNamespaceURI(); [EOL]     if (uri != null) { [EOL]         return uri; [EOL]     } [EOL]     String qname; [EOL]     String prefix = getPrefix(node); [EOL]     if (prefix == null) { [EOL]         qname = "xmlns"; [EOL]     } else { [EOL]         qname = "xmlns:" + prefix; [EOL]     } [EOL]     Node aNode = node; [EOL]     while (aNode != null) { [EOL]         if (aNode.getNodeType() == Node.ELEMENT_NODE) { [EOL]             Attr attr = ((Element) aNode).getAttributeNode(qname); [EOL]             if (attr != null) { [EOL]                 return attr.getValue(); [EOL]             } [EOL]         } [EOL]         aNode = aNode.getParentNode(); [EOL]     } [EOL]     return null; [EOL] }
public static String getNamespaceURI(Node node) { [EOL]     if (node instanceof Document) { [EOL]         node = ((Document) node).getDocumentElement(); [EOL]     } [EOL]     Element element = (Element) node; [EOL]     String uri = element.getNamespaceURI(); [EOL]     if (uri != null) { [EOL]         return uri; [EOL]     } [EOL]     String qname; [EOL]     String prefix = getPrefix(node); [EOL]     if (prefix == null) { [EOL]         qname = "xmlns"; [EOL]     } else { [EOL]         qname = "xmlns:" + prefix; [EOL]     } [EOL]     Node aNode = node; [EOL]     while (aNode != null) { [EOL]         if (aNode.getNodeType() == Node.ELEMENT_NODE) { [EOL]             Attr attr = ((Element) aNode).getAttributeNode(qname); [EOL]             if (attr != null) { [EOL]                 return attr.getValue(); [EOL]             } [EOL]         } [EOL]         aNode = aNode.getParentNode(); [EOL]     } [EOL]     return null; [EOL] }
public static String getNamespaceURI(Node node) { [EOL]     if (node instanceof Document) { [EOL]         node = ((Document) node).getDocumentElement(); [EOL]     } [EOL]     Element element = (Element) node; [EOL]     String uri = element.getNamespaceURI(); [EOL]     if (uri != null) { [EOL]         return uri; [EOL]     } [EOL]     String qname; [EOL]     String prefix = getPrefix(node); [EOL]     if (prefix == null) { [EOL]         qname = "xmlns"; [EOL]     } else { [EOL]         qname = "xmlns:" + prefix; [EOL]     } [EOL]     Node aNode = node; [EOL]     while (aNode != null) { [EOL]         if (aNode.getNodeType() == Node.ELEMENT_NODE) { [EOL]             Attr attr = ((Element) aNode).getAttributeNode(qname); [EOL]             if (attr != null) { [EOL]                 return attr.getValue(); [EOL]             } [EOL]         } [EOL]         aNode = aNode.getParentNode(); [EOL]     } [EOL]     return null; [EOL] }
public static String getNamespaceURI(Node node) { [EOL]     if (node instanceof Document) { [EOL]         node = ((Document) node).getDocumentElement(); [EOL]     } [EOL]     Element element = (Element) node; [EOL]     String uri = element.getNamespaceURI(); [EOL]     if (uri != null) { [EOL]         return uri; [EOL]     } [EOL]     String qname; [EOL]     String prefix = getPrefix(node); [EOL]     if (prefix == null) { [EOL]         qname = "xmlns"; [EOL]     } else { [EOL]         qname = "xmlns:" + prefix; [EOL]     } [EOL]     Node aNode = node; [EOL]     while (aNode != null) { [EOL]         if (aNode.getNodeType() == Node.ELEMENT_NODE) { [EOL]             Attr attr = ((Element) aNode).getAttributeNode(qname); [EOL]             if (attr != null) { [EOL]                 return attr.getValue(); [EOL]             } [EOL]         } [EOL]         aNode = aNode.getParentNode(); [EOL]     } [EOL]     return null; [EOL] }
public static String getNamespaceURI(Node node) { [EOL]     if (node instanceof Document) { [EOL]         node = ((Document) node).getDocumentElement(); [EOL]     } [EOL]     Element element = (Element) node; [EOL]     String uri = element.getNamespaceURI(); [EOL]     if (uri != null) { [EOL]         return uri; [EOL]     } [EOL]     String qname; [EOL]     String prefix = getPrefix(node); [EOL]     if (prefix == null) { [EOL]         qname = "xmlns"; [EOL]     } else { [EOL]         qname = "xmlns:" + prefix; [EOL]     } [EOL]     Node aNode = node; [EOL]     while (aNode != null) { [EOL]         if (aNode.getNodeType() == Node.ELEMENT_NODE) { [EOL]             Attr attr = ((Element) aNode).getAttributeNode(qname); [EOL]             if (attr != null) { [EOL]                 return attr.getValue(); [EOL]             } [EOL]         } [EOL]         aNode = aNode.getParentNode(); [EOL]     } [EOL]     return null; [EOL] }
public Object getValue() { [EOL]     return stringValue(node); [EOL] }
private String stringValue(Node node) { [EOL]     int nodeType = node.getNodeType(); [EOL]     if (nodeType == Node.COMMENT_NODE) { [EOL]         String text = ((Comment) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) { [EOL]         String text = node.getNodeValue(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else { [EOL]         NodeList list = node.getChildNodes(); [EOL]         StringBuffer buf = new StringBuffer(16); [EOL]         for (int i = 0; i < list.getLength(); i++) { [EOL]             Node child = list.item(i); [EOL]             if (child.getNodeType() == Node.TEXT_NODE) { [EOL]                 buf.append(child.getNodeValue()); [EOL]             } else { [EOL]                 buf.append(stringValue(child)); [EOL]             } [EOL]         } [EOL]         return buf.toString().trim(); [EOL]     } [EOL] }
private String stringValue(Node node) { [EOL]     int nodeType = node.getNodeType(); [EOL]     if (nodeType == Node.COMMENT_NODE) { [EOL]         String text = ((Comment) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) { [EOL]         String text = node.getNodeValue(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else { [EOL]         NodeList list = node.getChildNodes(); [EOL]         StringBuffer buf = new StringBuffer(16); [EOL]         for (int i = 0; i < list.getLength(); i++) { [EOL]             Node child = list.item(i); [EOL]             if (child.getNodeType() == Node.TEXT_NODE) { [EOL]                 buf.append(child.getNodeValue()); [EOL]             } else { [EOL]                 buf.append(stringValue(child)); [EOL]             } [EOL]         } [EOL]         return buf.toString().trim(); [EOL]     } [EOL] }
private String stringValue(Node node) { [EOL]     int nodeType = node.getNodeType(); [EOL]     if (nodeType == Node.COMMENT_NODE) { [EOL]         String text = ((Comment) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) { [EOL]         String text = node.getNodeValue(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else { [EOL]         NodeList list = node.getChildNodes(); [EOL]         StringBuffer buf = new StringBuffer(16); [EOL]         for (int i = 0; i < list.getLength(); i++) { [EOL]             Node child = list.item(i); [EOL]             if (child.getNodeType() == Node.TEXT_NODE) { [EOL]                 buf.append(child.getNodeValue()); [EOL]             } else { [EOL]                 buf.append(stringValue(child)); [EOL]             } [EOL]         } [EOL]         return buf.toString().trim(); [EOL]     } [EOL] }
private String stringValue(Node node) { [EOL]     int nodeType = node.getNodeType(); [EOL]     if (nodeType == Node.COMMENT_NODE) { [EOL]         String text = ((Comment) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) { [EOL]         String text = node.getNodeValue(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else { [EOL]         NodeList list = node.getChildNodes(); [EOL]         StringBuffer buf = new StringBuffer(16); [EOL]         for (int i = 0; i < list.getLength(); i++) { [EOL]             Node child = list.item(i); [EOL]             if (child.getNodeType() == Node.TEXT_NODE) { [EOL]                 buf.append(child.getNodeValue()); [EOL]             } else { [EOL]                 buf.append(stringValue(child)); [EOL]             } [EOL]         } [EOL]         return buf.toString().trim(); [EOL]     } [EOL] }
private String stringValue(Node node) { [EOL]     int nodeType = node.getNodeType(); [EOL]     if (nodeType == Node.COMMENT_NODE) { [EOL]         String text = ((Comment) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) { [EOL]         String text = node.getNodeValue(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else { [EOL]         NodeList list = node.getChildNodes(); [EOL]         StringBuffer buf = new StringBuffer(16); [EOL]         for (int i = 0; i < list.getLength(); i++) { [EOL]             Node child = list.item(i); [EOL]             if (child.getNodeType() == Node.TEXT_NODE) { [EOL]                 buf.append(child.getNodeValue()); [EOL]             } else { [EOL]                 buf.append(stringValue(child)); [EOL]             } [EOL]         } [EOL]         return buf.toString().trim(); [EOL]     } [EOL] }
private String stringValue(Node node) { [EOL]     int nodeType = node.getNodeType(); [EOL]     if (nodeType == Node.COMMENT_NODE) { [EOL]         String text = ((Comment) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE) { [EOL]         String text = node.getNodeValue(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else if (nodeType == Node.PROCESSING_INSTRUCTION_NODE) { [EOL]         String text = ((ProcessingInstruction) node).getData(); [EOL]         return text == null ? "" : text.trim(); [EOL]     } else { [EOL]         NodeList list = node.getChildNodes(); [EOL]         StringBuffer buf = new StringBuffer(16); [EOL]         for (int i = 0; i < list.getLength(); i++) { [EOL]             Node child = list.item(i); [EOL]             if (child.getNodeType() == Node.TEXT_NODE) { [EOL]                 buf.append(child.getNodeValue()); [EOL]             } else { [EOL]                 buf.append(stringValue(child)); [EOL]             } [EOL]         } [EOL]         return buf.toString().trim(); [EOL]     } [EOL] }
public boolean computeContextDependent() { [EOL]     return true; [EOL] }
public JDOMNamespacePointer(NodePointer parent, String prefix) { [EOL]     super(parent); [EOL]     this.prefix = prefix; [EOL] }
public JDOMNamespacePointer(NodePointer parent, String prefix) { [EOL]     super(parent); [EOL]     this.prefix = prefix; [EOL] }
public JDOMNamespacePointer(NodePointer parent, String prefix) { [EOL]     super(parent); [EOL]     this.prefix = prefix; [EOL] }
public JDOMNamespacePointer(NodePointer parent, String prefix) { [EOL]     super(parent); [EOL]     this.prefix = prefix; [EOL] }
public DOMNodeIterator(NodePointer parent, NodeTest nodeTest, boolean reverse, NodePointer startWith) { [EOL]     this.parent = parent; [EOL]     this.node = (Node) parent.getNode(); [EOL]     if (startWith != null) { [EOL]         this.child = (Node) startWith.getNode(); [EOL]     } [EOL]     this.nodeTest = nodeTest; [EOL]     this.reverse = reverse; [EOL] }
public DOMNodeIterator(NodePointer parent, NodeTest nodeTest, boolean reverse, NodePointer startWith) { [EOL]     this.parent = parent; [EOL]     this.node = (Node) parent.getNode(); [EOL]     if (startWith != null) { [EOL]         this.child = (Node) startWith.getNode(); [EOL]     } [EOL]     this.nodeTest = nodeTest; [EOL]     this.reverse = reverse; [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         setPosition(1); [EOL]     } [EOL]     if (child == null) { [EOL]         return null; [EOL]     } [EOL]     return new DOMNodePointer(parent, child); [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         setPosition(1); [EOL]     } [EOL]     if (child == null) { [EOL]         return null; [EOL]     } [EOL]     return new DOMNodePointer(parent, child); [EOL] }
public NodePointer getNodePointer() { [EOL]     if (position == 0) { [EOL]         setPosition(1); [EOL]     } [EOL]     if (child == null) { [EOL]         return null; [EOL]     } [EOL]     return new DOMNodePointer(parent, child); [EOL] }
public boolean setPosition(int position) { [EOL]     while (this.position < position) { [EOL]         if (!next()) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     while (this.position > position) { [EOL]         if (!previous()) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean setPosition(int position) { [EOL]     while (this.position < position) { [EOL]         if (!next()) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     while (this.position > position) { [EOL]         if (!previous()) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean setPosition(int position) { [EOL]     while (this.position < position) { [EOL]         if (!next()) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     while (this.position > position) { [EOL]         if (!previous()) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean setPosition(int position) { [EOL]     while (this.position < position) { [EOL]         if (!next()) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     while (this.position > position) { [EOL]         if (!previous()) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
private boolean next() { [EOL]     position++; [EOL]     if (!reverse) { [EOL]         if (position == 1) { [EOL]             if (child == null) { [EOL]                 child = node.getFirstChild(); [EOL]             } else { [EOL]                 child = child.getNextSibling(); [EOL]             } [EOL]         } else { [EOL]             child = child.getNextSibling(); [EOL]         } [EOL]         while (child != null && !testChild()) { [EOL]             child = child.getNextSibling(); [EOL]         } [EOL]     } else { [EOL]         if (position == 1) { [EOL]             if (child == null) { [EOL]                 child = node.getLastChild(); [EOL]             } else { [EOL]                 child = child.getPreviousSibling(); [EOL]             } [EOL]         } else { [EOL]             child = child.getPreviousSibling(); [EOL]         } [EOL]         while (child != null && !testChild()) { [EOL]             child = child.getPreviousSibling(); [EOL]         } [EOL]     } [EOL]     return child != null; [EOL] }
private boolean testChild() { [EOL]     return DOMNodePointer.testNode(child, nodeTest); [EOL] }
private boolean testChild() { [EOL]     return DOMNodePointer.testNode(child, nodeTest); [EOL] }
public Pointer getSingleNodePointer() { [EOL]     if (position == 0) { [EOL]         while (nextSet()) { [EOL]             prepare(); [EOL]             if (iterator == null) { [EOL]                 return null; [EOL]             } [EOL]             NodePointer pointer = iterator.getNodePointer(); [EOL]             if (pointer != null) { [EOL]                 return pointer; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     return getCurrentNodePointer(); [EOL] }
public Pointer getSingleNodePointer() { [EOL]     if (position == 0) { [EOL]         while (nextSet()) { [EOL]             prepare(); [EOL]             if (iterator == null) { [EOL]                 return null; [EOL]             } [EOL]             NodePointer pointer = iterator.getNodePointer(); [EOL]             if (pointer != null) { [EOL]                 return pointer; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     return getCurrentNodePointer(); [EOL] }
public Pointer getSingleNodePointer() { [EOL]     if (position == 0) { [EOL]         while (nextSet()) { [EOL]             prepare(); [EOL]             if (iterator == null) { [EOL]                 return null; [EOL]             } [EOL]             NodePointer pointer = iterator.getNodePointer(); [EOL]             if (pointer != null) { [EOL]                 return pointer; [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     return getCurrentNodePointer(); [EOL] }
public boolean setPosition(int position) { [EOL]     int oldPosition = getCurrentPosition(); [EOL]     super.setPosition(position); [EOL]     if (oldPosition == 0) { [EOL]         prepare(); [EOL]     } [EOL]     if (iterator == null) { [EOL]         return false; [EOL]     } [EOL]     return iterator.setPosition(position); [EOL] }
public boolean setPosition(int position) { [EOL]     int oldPosition = getCurrentPosition(); [EOL]     super.setPosition(position); [EOL]     if (oldPosition == 0) { [EOL]         prepare(); [EOL]     } [EOL]     if (iterator == null) { [EOL]         return false; [EOL]     } [EOL]     return iterator.setPosition(position); [EOL] }
public boolean setPosition(int position) { [EOL]     int oldPosition = getCurrentPosition(); [EOL]     super.setPosition(position); [EOL]     if (oldPosition == 0) { [EOL]         prepare(); [EOL]     } [EOL]     if (iterator == null) { [EOL]         return false; [EOL]     } [EOL]     return iterator.setPosition(position); [EOL] }
public boolean setPosition(int position) { [EOL]     int oldPosition = getCurrentPosition(); [EOL]     super.setPosition(position); [EOL]     if (oldPosition == 0) { [EOL]         prepare(); [EOL]     } [EOL]     if (iterator == null) { [EOL]         return false; [EOL]     } [EOL]     return iterator.setPosition(position); [EOL] }
public static Object convert(Object object, Class toType) { [EOL]     return typeConverter.convert(object, toType); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     NodePointer parent = getImmediateParentPointer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             if (parent.getIndex() != WHOLE_COLLECTION) { [EOL]                 buffer.append("/."); [EOL]             } [EOL]             buffer.append("[").append(index + 1).append(']'); [EOL]         } [EOL]     } else { [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             buffer.append("/.[").append(index + 1).append(']'); [EOL]         } else { [EOL]             buffer.append("/"); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     NodePointer parent = getImmediateParentPointer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             if (parent.getIndex() != WHOLE_COLLECTION) { [EOL]                 buffer.append("/."); [EOL]             } [EOL]             buffer.append("[").append(index + 1).append(']'); [EOL]         } [EOL]     } else { [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             buffer.append("/.[").append(index + 1).append(']'); [EOL]         } else { [EOL]             buffer.append("/"); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     NodePointer parent = getImmediateParentPointer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             if (parent.getIndex() != WHOLE_COLLECTION) { [EOL]                 buffer.append("/."); [EOL]             } [EOL]             buffer.append("[").append(index + 1).append(']'); [EOL]         } [EOL]     } else { [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             buffer.append("/.[").append(index + 1).append(']'); [EOL]         } else { [EOL]             buffer.append("/"); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public String asPath() { [EOL]     StringBuffer buffer = new StringBuffer(); [EOL]     NodePointer parent = getImmediateParentPointer(); [EOL]     if (parent != null) { [EOL]         buffer.append(parent.asPath()); [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             if (parent.getIndex() != WHOLE_COLLECTION) { [EOL]                 buffer.append("/."); [EOL]             } [EOL]             buffer.append("[").append(index + 1).append(']'); [EOL]         } [EOL]     } else { [EOL]         if (index != WHOLE_COLLECTION) { [EOL]             buffer.append("/.[").append(index + 1).append(']'); [EOL]         } else { [EOL]             buffer.append("/"); [EOL]         } [EOL]     } [EOL]     return buffer.toString(); [EOL] }
public UnionContext(EvalContext parentContext, EvalContext[] contexts) { [EOL]     super(parentContext, new BasicNodeSet()); [EOL]     this.contexts = contexts; [EOL] }
public UnionContext(EvalContext parentContext, EvalContext[] contexts) { [EOL]     super(parentContext, new BasicNodeSet()); [EOL]     this.contexts = contexts; [EOL] }
public UnionContext(EvalContext parentContext, EvalContext[] contexts) { [EOL]     super(parentContext, new BasicNodeSet()); [EOL]     this.contexts = contexts; [EOL] }
public UnionContext(EvalContext parentContext, EvalContext[] contexts) { [EOL]     super(parentContext, new BasicNodeSet()); [EOL]     this.contexts = contexts; [EOL] }
public UnionContext(EvalContext parentContext, EvalContext[] contexts) { [EOL]     super(parentContext, new BasicNodeSet()); [EOL]     this.contexts = contexts; [EOL] }
public int getDocumentOrder() { [EOL]     if (contexts.length > 1) { [EOL]         return 1; [EOL]     } [EOL]     return super.getDocumentOrder(); [EOL] }
public int getDocumentOrder() { [EOL]     if (contexts.length > 1) { [EOL]         return 1; [EOL]     } [EOL]     return super.getDocumentOrder(); [EOL] }
public boolean setPosition(int position) { [EOL]     if (!prepared) { [EOL]         prepared = true; [EOL]         BasicNodeSet nodeSet = (BasicNodeSet) getNodeSet(); [EOL]         HashSet set = new HashSet(); [EOL]         for (int i = 0; i < contexts.length; i++) { [EOL]             EvalContext ctx = (EvalContext) contexts[i]; [EOL]             while (ctx.nextSet()) { [EOL]                 while (ctx.nextNode()) { [EOL]                     NodePointer ptr = ctx.getCurrentNodePointer(); [EOL]                     if (!set.contains(ptr)) { [EOL]                         nodeSet.add(ptr); [EOL]                         set.add(ptr); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return super.setPosition(position); [EOL] }
public boolean setPosition(int position) { [EOL]     if (!prepared) { [EOL]         prepared = true; [EOL]         BasicNodeSet nodeSet = (BasicNodeSet) getNodeSet(); [EOL]         HashSet set = new HashSet(); [EOL]         for (int i = 0; i < contexts.length; i++) { [EOL]             EvalContext ctx = (EvalContext) contexts[i]; [EOL]             while (ctx.nextSet()) { [EOL]                 while (ctx.nextNode()) { [EOL]                     NodePointer ptr = ctx.getCurrentNodePointer(); [EOL]                     if (!set.contains(ptr)) { [EOL]                         nodeSet.add(ptr); [EOL]                         set.add(ptr); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return super.setPosition(position); [EOL] }
public PropertyPointer(NodePointer parent) { [EOL]     super(parent); [EOL] }
public PropertyPointer(NodePointer parent) { [EOL]     super(parent); [EOL] }
public int getPropertyIndex() { [EOL]     return propertyIndex; [EOL] }
public Object getBean() { [EOL]     if (bean == null) { [EOL]         bean = getImmediateParentPointer().getNode(); [EOL]     } [EOL]     return bean; [EOL] }
public Object getBean() { [EOL]     if (bean == null) { [EOL]         bean = getImmediateParentPointer().getNode(); [EOL]     } [EOL]     return bean; [EOL] }
public QName getName() { [EOL]     return new QName(null, getPropertyName()); [EOL] }
public boolean isActual() { [EOL]     if (!isActualProperty()) { [EOL]         return false; [EOL]     } [EOL]     return super.isActual(); [EOL] }
public boolean isActual() { [EOL]     if (!isActualProperty()) { [EOL]         return false; [EOL]     } [EOL]     return super.isActual(); [EOL] }
public NodePointer getImmediateValuePointer() { [EOL]     return NodePointer.newChildNodePointer((NodePointer) this.clone(), getName(), getImmediateNode()); [EOL] }
public NodePointer createPath(JXPathContext context, Object value) { [EOL]     if (index != WHOLE_COLLECTION && index >= getLength()) { [EOL]         createPath(context); [EOL]     } [EOL]     setValue(value); [EOL]     return this; [EOL] }
public NodePointer createPath(JXPathContext context, Object value) { [EOL]     if (index != WHOLE_COLLECTION && index >= getLength()) { [EOL]         createPath(context); [EOL]     } [EOL]     setValue(value); [EOL]     return this; [EOL] }
public NodePointer createPath(JXPathContext context, Object value) { [EOL]     if (index != WHOLE_COLLECTION && index >= getLength()) { [EOL]         createPath(context); [EOL]     } [EOL]     setValue(value); [EOL]     return this; [EOL] }
public NodePointer createChild(JXPathContext context, QName name, int index) { [EOL]     PropertyPointer prop = (PropertyPointer) clone(); [EOL]     if (name != null) { [EOL]         prop.setPropertyName(name.toString()); [EOL]     } [EOL]     prop.setIndex(index); [EOL]     return prop.createPath(context); [EOL] }
public NodePointer createChild(JXPathContext context, QName name, int index) { [EOL]     PropertyPointer prop = (PropertyPointer) clone(); [EOL]     if (name != null) { [EOL]         prop.setPropertyName(name.toString()); [EOL]     } [EOL]     prop.setIndex(index); [EOL]     return prop.createPath(context); [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof PropertyPointer)) { [EOL]         return false; [EOL]     } [EOL]     PropertyPointer other = (PropertyPointer) object; [EOL]     if (parent != other.parent) { [EOL]         if (parent == null || !parent.equals(other.parent)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (getPropertyIndex() != other.getPropertyIndex() || !getPropertyName().equals(other.getPropertyName())) { [EOL]         return false; [EOL]     } [EOL]     int iThis = (index == WHOLE_COLLECTION ? 0 : index); [EOL]     int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index); [EOL]     return iThis == iOther; [EOL] }
public boolean equals(Object object) { [EOL]     if (object == this) { [EOL]         return true; [EOL]     } [EOL]     if (!(object instanceof PropertyPointer)) { [EOL]         return false; [EOL]     } [EOL]     PropertyPointer other = (PropertyPointer) object; [EOL]     if (parent != other.parent) { [EOL]         if (parent == null || !parent.equals(other.parent)) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     if (getPropertyIndex() != other.getPropertyIndex() || !getPropertyName().equals(other.getPropertyName())) { [EOL]         return false; [EOL]     } [EOL]     int iThis = (index == WHOLE_COLLECTION ? 0 : index); [EOL]     int iOther = (other.index == WHOLE_COLLECTION ? 0 : other.index); [EOL]     return iThis == iOther; [EOL] }
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     if (bean instanceof Container) { [EOL]         return new ContainerPointer(parent, (Container) bean); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     if (bean instanceof Container) { [EOL]         return new ContainerPointer(parent, (Container) bean); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     if (bean instanceof DynaBean) { [EOL]         return new DynaBeanPointer(parent, name, (DynaBean) bean); [EOL]     } [EOL]     return null; [EOL] }
public NodePointer createNodePointer(NodePointer parent, QName name, Object bean) { [EOL]     if (bean instanceof DynaBean) { [EOL]         return new DynaBeanPointer(parent, name, (DynaBean) bean); [EOL]     } [EOL]     return null; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); [EOL]     double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); [EOL]     return new Double(l / r); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     double l = InfoSetUtil.doubleValue(args[0].computeValue(context)); [EOL]     double r = InfoSetUtil.doubleValue(args[1].computeValue(context)); [EOL]     return new Double(l / r); [EOL] }
public Object getValue(String xpath, Expression expr) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     if (result == null) { [EOL]         if (expr instanceof Path) { [EOL]             if (!isLenient()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (result instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) result; [EOL]         result = ctx.getSingleNodePointer(); [EOL]         if (!isLenient() && result == null) { [EOL]             throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]         } [EOL]     } [EOL]     if (result instanceof NodePointer) { [EOL]         result = ((NodePointer) result).getValuePointer(); [EOL]         if (!isLenient() && !((NodePointer) result).isActual()) { [EOL]             NodePointer parent = ((NodePointer) result).getImmediateParentPointer(); [EOL]             if (parent == null || !parent.isContainer() || !parent.isActual()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         result = ((NodePointer) result).getValue(); [EOL]     } [EOL]     return result; [EOL] }
public Object getValue(String xpath, Expression expr) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     if (result == null) { [EOL]         if (expr instanceof Path) { [EOL]             if (!isLenient()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (result instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) result; [EOL]         result = ctx.getSingleNodePointer(); [EOL]         if (!isLenient() && result == null) { [EOL]             throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]         } [EOL]     } [EOL]     if (result instanceof NodePointer) { [EOL]         result = ((NodePointer) result).getValuePointer(); [EOL]         if (!isLenient() && !((NodePointer) result).isActual()) { [EOL]             NodePointer parent = ((NodePointer) result).getImmediateParentPointer(); [EOL]             if (parent == null || !parent.isContainer() || !parent.isActual()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         result = ((NodePointer) result).getValue(); [EOL]     } [EOL]     return result; [EOL] }
public Object getValue(String xpath, Expression expr) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     if (result == null) { [EOL]         if (expr instanceof Path) { [EOL]             if (!isLenient()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (result instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) result; [EOL]         result = ctx.getSingleNodePointer(); [EOL]         if (!isLenient() && result == null) { [EOL]             throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]         } [EOL]     } [EOL]     if (result instanceof NodePointer) { [EOL]         result = ((NodePointer) result).getValuePointer(); [EOL]         if (!isLenient() && !((NodePointer) result).isActual()) { [EOL]             NodePointer parent = ((NodePointer) result).getImmediateParentPointer(); [EOL]             if (parent == null || !parent.isContainer() || !parent.isActual()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         result = ((NodePointer) result).getValue(); [EOL]     } [EOL]     return result; [EOL] }
public Object getValue(String xpath, Expression expr) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     if (result == null) { [EOL]         if (expr instanceof Path) { [EOL]             if (!isLenient()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (result instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) result; [EOL]         result = ctx.getSingleNodePointer(); [EOL]         if (!isLenient() && result == null) { [EOL]             throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]         } [EOL]     } [EOL]     if (result instanceof NodePointer) { [EOL]         result = ((NodePointer) result).getValuePointer(); [EOL]         if (!isLenient() && !((NodePointer) result).isActual()) { [EOL]             NodePointer parent = ((NodePointer) result).getImmediateParentPointer(); [EOL]             if (parent == null || !parent.isContainer() || !parent.isActual()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         result = ((NodePointer) result).getValue(); [EOL]     } [EOL]     return result; [EOL] }
public Object getValue(String xpath, Expression expr) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     if (result == null) { [EOL]         if (expr instanceof Path) { [EOL]             if (!isLenient()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (result instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) result; [EOL]         result = ctx.getSingleNodePointer(); [EOL]         if (!isLenient() && result == null) { [EOL]             throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]         } [EOL]     } [EOL]     if (result instanceof NodePointer) { [EOL]         result = ((NodePointer) result).getValuePointer(); [EOL]         if (!isLenient() && !((NodePointer) result).isActual()) { [EOL]             NodePointer parent = ((NodePointer) result).getImmediateParentPointer(); [EOL]             if (parent == null || !parent.isContainer() || !parent.isActual()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         result = ((NodePointer) result).getValue(); [EOL]     } [EOL]     return result; [EOL] }
public Object getValue(String xpath, Expression expr) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     if (result == null) { [EOL]         if (expr instanceof Path) { [EOL]             if (!isLenient()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         return null; [EOL]     } [EOL]     if (result instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) result; [EOL]         result = ctx.getSingleNodePointer(); [EOL]         if (!isLenient() && result == null) { [EOL]             throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]         } [EOL]     } [EOL]     if (result instanceof NodePointer) { [EOL]         result = ((NodePointer) result).getValuePointer(); [EOL]         if (!isLenient() && !((NodePointer) result).isActual()) { [EOL]             NodePointer parent = ((NodePointer) result).getImmediateParentPointer(); [EOL]             if (parent == null || !parent.isContainer() || !parent.isActual()) { [EOL]                 throw new JXPathNotFoundException("No value for xpath: " + xpath); [EOL]             } [EOL]         } [EOL]         result = ((NodePointer) result).getValue(); [EOL]     } [EOL]     return result; [EOL] }
public Object getValue(String xpath, Class requiredType) { [EOL]     Expression expr = compileExpression(xpath); [EOL]     return getValue(xpath, expr, requiredType); [EOL] }
public Object getValue(String xpath, Class requiredType) { [EOL]     Expression expr = compileExpression(xpath); [EOL]     return getValue(xpath, expr, requiredType); [EOL] }
public Object getValue(String xpath, Class requiredType) { [EOL]     Expression expr = compileExpression(xpath); [EOL]     return getValue(xpath, expr, requiredType); [EOL] }
public Object getValue(String xpath, Expression expr, Class requiredType) { [EOL]     Object value = getValue(xpath, expr); [EOL]     if (value != null && requiredType != null) { [EOL]         if (!TypeUtils.canConvert(value, requiredType)) { [EOL]             throw new JXPathTypeConversionException("Invalid expression type. '" + xpath + "' returns " + value.getClass().getName() + ". It cannot be converted to " + requiredType.getName()); [EOL]         } [EOL]         value = TypeUtils.convert(value, requiredType); [EOL]     } [EOL]     return value; [EOL] }
public Object getValue(String xpath, Expression expr, Class requiredType) { [EOL]     Object value = getValue(xpath, expr); [EOL]     if (value != null && requiredType != null) { [EOL]         if (!TypeUtils.canConvert(value, requiredType)) { [EOL]             throw new JXPathTypeConversionException("Invalid expression type. '" + xpath + "' returns " + value.getClass().getName() + ". It cannot be converted to " + requiredType.getName()); [EOL]         } [EOL]         value = TypeUtils.convert(value, requiredType); [EOL]     } [EOL]     return value; [EOL] }
public Object getValue(String xpath, Expression expr, Class requiredType) { [EOL]     Object value = getValue(xpath, expr); [EOL]     if (value != null && requiredType != null) { [EOL]         if (!TypeUtils.canConvert(value, requiredType)) { [EOL]             throw new JXPathTypeConversionException("Invalid expression type. '" + xpath + "' returns " + value.getClass().getName() + ". It cannot be converted to " + requiredType.getName()); [EOL]         } [EOL]         value = TypeUtils.convert(value, requiredType); [EOL]     } [EOL]     return value; [EOL] }
public Object getValue(String xpath, Expression expr, Class requiredType) { [EOL]     Object value = getValue(xpath, expr); [EOL]     if (value != null && requiredType != null) { [EOL]         if (!TypeUtils.canConvert(value, requiredType)) { [EOL]             throw new JXPathTypeConversionException("Invalid expression type. '" + xpath + "' returns " + value.getClass().getName() + ". It cannot be converted to " + requiredType.getName()); [EOL]         } [EOL]         value = TypeUtils.convert(value, requiredType); [EOL]     } [EOL]     return value; [EOL] }
public Pointer getPointer(String xpath, Expression expr) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     if (result instanceof EvalContext) { [EOL]         result = ((EvalContext) result).getSingleNodePointer(); [EOL]     } [EOL]     if (result instanceof Pointer) { [EOL]         if (!isLenient() && !((NodePointer) result).isActual()) { [EOL]             throw new JXPathNotFoundException("No pointer for xpath: " + xpath); [EOL]         } [EOL]         return (Pointer) result; [EOL]     } else { [EOL]         return NodePointer.newNodePointer(null, result, getLocale()); [EOL]     } [EOL] }
public Pointer getPointer(String xpath, Expression expr) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     if (result instanceof EvalContext) { [EOL]         result = ((EvalContext) result).getSingleNodePointer(); [EOL]     } [EOL]     if (result instanceof Pointer) { [EOL]         if (!isLenient() && !((NodePointer) result).isActual()) { [EOL]             throw new JXPathNotFoundException("No pointer for xpath: " + xpath); [EOL]         } [EOL]         return (Pointer) result; [EOL]     } else { [EOL]         return NodePointer.newNodePointer(null, result, getLocale()); [EOL]     } [EOL] }
public Pointer getPointer(String xpath, Expression expr) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     if (result instanceof EvalContext) { [EOL]         result = ((EvalContext) result).getSingleNodePointer(); [EOL]     } [EOL]     if (result instanceof Pointer) { [EOL]         if (!isLenient() && !((NodePointer) result).isActual()) { [EOL]             throw new JXPathNotFoundException("No pointer for xpath: " + xpath); [EOL]         } [EOL]         return (Pointer) result; [EOL]     } else { [EOL]         return NodePointer.newNodePointer(null, result, getLocale()); [EOL]     } [EOL] }
public Pointer getPointer(String xpath, Expression expr) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     if (result instanceof EvalContext) { [EOL]         result = ((EvalContext) result).getSingleNodePointer(); [EOL]     } [EOL]     if (result instanceof Pointer) { [EOL]         if (!isLenient() && !((NodePointer) result).isActual()) { [EOL]             throw new JXPathNotFoundException("No pointer for xpath: " + xpath); [EOL]         } [EOL]         return (Pointer) result; [EOL]     } else { [EOL]         return NodePointer.newNodePointer(null, result, getLocale()); [EOL]     } [EOL] }
public Pointer getPointer(String xpath, Expression expr) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     if (result instanceof EvalContext) { [EOL]         result = ((EvalContext) result).getSingleNodePointer(); [EOL]     } [EOL]     if (result instanceof Pointer) { [EOL]         if (!isLenient() && !((NodePointer) result).isActual()) { [EOL]             throw new JXPathNotFoundException("No pointer for xpath: " + xpath); [EOL]         } [EOL]         return (Pointer) result; [EOL]     } else { [EOL]         return NodePointer.newNodePointer(null, result, getLocale()); [EOL]     } [EOL] }
public void setValue(String xpath, Expression expr, Object value) { [EOL]     try { [EOL]         setValue(xpath, expr, value, false); [EOL]     } catch (Throwable ex) { [EOL]         throw new JXPathException("Exception trying to set value with xpath " + xpath, ex); [EOL]     } [EOL] }
public void setValue(String xpath, Expression expr, Object value) { [EOL]     try { [EOL]         setValue(xpath, expr, value, false); [EOL]     } catch (Throwable ex) { [EOL]         throw new JXPathException("Exception trying to set value with xpath " + xpath, ex); [EOL]     } [EOL] }
public void setValue(String xpath, Expression expr, Object value) { [EOL]     try { [EOL]         setValue(xpath, expr, value, false); [EOL]     } catch (Throwable ex) { [EOL]         throw new JXPathException("Exception trying to set value with xpath " + xpath, ex); [EOL]     } [EOL] }
public void setValue(String xpath, Expression expr, Object value) { [EOL]     try { [EOL]         setValue(xpath, expr, value, false); [EOL]     } catch (Throwable ex) { [EOL]         throw new JXPathException("Exception trying to set value with xpath " + xpath, ex); [EOL]     } [EOL] }
public Pointer createPath(String xpath) { [EOL]     return createPath(xpath, compileExpression(xpath)); [EOL] }
public Pointer createPath(String xpath, Expression expr) { [EOL]     try { [EOL]         Object result = expr.computeValue(getEvalContext()); [EOL]         Pointer pointer = null; [EOL]         if (result instanceof Pointer) { [EOL]             pointer = (Pointer) result; [EOL]         } else if (result instanceof EvalContext) { [EOL]             EvalContext ctx = (EvalContext) result; [EOL]             pointer = ctx.getSingleNodePointer(); [EOL]         } else { [EOL]             checkSimplePath(expr); [EOL]             throw new JXPathException("Cannot create path:" + xpath); [EOL]         } [EOL]         return ((NodePointer) pointer).createPath(this); [EOL]     } catch (Throwable ex) { [EOL]         throw new JXPathException("Exception trying to create xpath " + xpath, ex); [EOL]     } [EOL] }
public Pointer createPath(String xpath, Expression expr) { [EOL]     try { [EOL]         Object result = expr.computeValue(getEvalContext()); [EOL]         Pointer pointer = null; [EOL]         if (result instanceof Pointer) { [EOL]             pointer = (Pointer) result; [EOL]         } else if (result instanceof EvalContext) { [EOL]             EvalContext ctx = (EvalContext) result; [EOL]             pointer = ctx.getSingleNodePointer(); [EOL]         } else { [EOL]             checkSimplePath(expr); [EOL]             throw new JXPathException("Cannot create path:" + xpath); [EOL]         } [EOL]         return ((NodePointer) pointer).createPath(this); [EOL]     } catch (Throwable ex) { [EOL]         throw new JXPathException("Exception trying to create xpath " + xpath, ex); [EOL]     } [EOL] }
public Pointer createPath(String xpath, Expression expr) { [EOL]     try { [EOL]         Object result = expr.computeValue(getEvalContext()); [EOL]         Pointer pointer = null; [EOL]         if (result instanceof Pointer) { [EOL]             pointer = (Pointer) result; [EOL]         } else if (result instanceof EvalContext) { [EOL]             EvalContext ctx = (EvalContext) result; [EOL]             pointer = ctx.getSingleNodePointer(); [EOL]         } else { [EOL]             checkSimplePath(expr); [EOL]             throw new JXPathException("Cannot create path:" + xpath); [EOL]         } [EOL]         return ((NodePointer) pointer).createPath(this); [EOL]     } catch (Throwable ex) { [EOL]         throw new JXPathException("Exception trying to create xpath " + xpath, ex); [EOL]     } [EOL] }
public Pointer createPath(String xpath, Expression expr) { [EOL]     try { [EOL]         Object result = expr.computeValue(getEvalContext()); [EOL]         Pointer pointer = null; [EOL]         if (result instanceof Pointer) { [EOL]             pointer = (Pointer) result; [EOL]         } else if (result instanceof EvalContext) { [EOL]             EvalContext ctx = (EvalContext) result; [EOL]             pointer = ctx.getSingleNodePointer(); [EOL]         } else { [EOL]             checkSimplePath(expr); [EOL]             throw new JXPathException("Cannot create path:" + xpath); [EOL]         } [EOL]         return ((NodePointer) pointer).createPath(this); [EOL]     } catch (Throwable ex) { [EOL]         throw new JXPathException("Exception trying to create xpath " + xpath, ex); [EOL]     } [EOL] }
private Pointer setValue(String xpath, Expression expr, Object value, boolean create) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     Pointer pointer = null; [EOL]     if (result instanceof Pointer) { [EOL]         pointer = (Pointer) result; [EOL]     } else if (result instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) result; [EOL]         pointer = ctx.getSingleNodePointer(); [EOL]     } else { [EOL]         if (create) { [EOL]             checkSimplePath(expr); [EOL]         } [EOL]         throw new JXPathException("Cannot set value for xpath: " + xpath); [EOL]     } [EOL]     if (create) { [EOL]         pointer = ((NodePointer) pointer).createPath(this, value); [EOL]     } else { [EOL]         pointer.setValue(value); [EOL]     } [EOL]     return pointer; [EOL] }
private Pointer setValue(String xpath, Expression expr, Object value, boolean create) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     Pointer pointer = null; [EOL]     if (result instanceof Pointer) { [EOL]         pointer = (Pointer) result; [EOL]     } else if (result instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) result; [EOL]         pointer = ctx.getSingleNodePointer(); [EOL]     } else { [EOL]         if (create) { [EOL]             checkSimplePath(expr); [EOL]         } [EOL]         throw new JXPathException("Cannot set value for xpath: " + xpath); [EOL]     } [EOL]     if (create) { [EOL]         pointer = ((NodePointer) pointer).createPath(this, value); [EOL]     } else { [EOL]         pointer.setValue(value); [EOL]     } [EOL]     return pointer; [EOL] }
private Pointer setValue(String xpath, Expression expr, Object value, boolean create) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     Pointer pointer = null; [EOL]     if (result instanceof Pointer) { [EOL]         pointer = (Pointer) result; [EOL]     } else if (result instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) result; [EOL]         pointer = ctx.getSingleNodePointer(); [EOL]     } else { [EOL]         if (create) { [EOL]             checkSimplePath(expr); [EOL]         } [EOL]         throw new JXPathException("Cannot set value for xpath: " + xpath); [EOL]     } [EOL]     if (create) { [EOL]         pointer = ((NodePointer) pointer).createPath(this, value); [EOL]     } else { [EOL]         pointer.setValue(value); [EOL]     } [EOL]     return pointer; [EOL] }
private Pointer setValue(String xpath, Expression expr, Object value, boolean create) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     Pointer pointer = null; [EOL]     if (result instanceof Pointer) { [EOL]         pointer = (Pointer) result; [EOL]     } else if (result instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) result; [EOL]         pointer = ctx.getSingleNodePointer(); [EOL]     } else { [EOL]         if (create) { [EOL]             checkSimplePath(expr); [EOL]         } [EOL]         throw new JXPathException("Cannot set value for xpath: " + xpath); [EOL]     } [EOL]     if (create) { [EOL]         pointer = ((NodePointer) pointer).createPath(this, value); [EOL]     } else { [EOL]         pointer.setValue(value); [EOL]     } [EOL]     return pointer; [EOL] }
private Pointer setValue(String xpath, Expression expr, Object value, boolean create) { [EOL]     Object result = expr.computeValue(getEvalContext()); [EOL]     Pointer pointer = null; [EOL]     if (result instanceof Pointer) { [EOL]         pointer = (Pointer) result; [EOL]     } else if (result instanceof EvalContext) { [EOL]         EvalContext ctx = (EvalContext) result; [EOL]         pointer = ctx.getSingleNodePointer(); [EOL]     } else { [EOL]         if (create) { [EOL]             checkSimplePath(expr); [EOL]         } [EOL]         throw new JXPathException("Cannot set value for xpath: " + xpath); [EOL]     } [EOL]     if (create) { [EOL]         pointer = ((NodePointer) pointer).createPath(this, value); [EOL]     } else { [EOL]         pointer.setValue(value); [EOL]     } [EOL]     return pointer; [EOL] }
private void checkSimplePath(Expression expr) { [EOL]     if (!(expr instanceof LocationPath) || !((LocationPath) expr).isSimplePath()) { [EOL]         throw new JXPathInvalidSyntaxException("JXPath can only create a path if it uses exclusively " + "the child:: and attribute:: axes and has " + "no context-dependent predicates"); [EOL]     } [EOL] }
private void checkSimplePath(Expression expr) { [EOL]     if (!(expr instanceof LocationPath) || !((LocationPath) expr).isSimplePath()) { [EOL]         throw new JXPathInvalidSyntaxException("JXPath can only create a path if it uses exclusively " + "the child:: and attribute:: axes and has " + "no context-dependent predicates"); [EOL]     } [EOL] }
private void checkSimplePath(Expression expr) { [EOL]     if (!(expr instanceof LocationPath) || !((LocationPath) expr).isSimplePath()) { [EOL]         throw new JXPathInvalidSyntaxException("JXPath can only create a path if it uses exclusively " + "the child:: and attribute:: axes and has " + "no context-dependent predicates"); [EOL]     } [EOL] }
public void removePath(String xpath) { [EOL]     removePath(xpath, compileExpression(xpath)); [EOL] }
public void removePath(String xpath) { [EOL]     removePath(xpath, compileExpression(xpath)); [EOL] }
public void removePath(String xpath, Expression expr) { [EOL]     try { [EOL]         NodePointer pointer = (NodePointer) getPointer(xpath, expr); [EOL]         if (pointer != null) { [EOL]             ((NodePointer) pointer).remove(); [EOL]         } [EOL]     } catch (Throwable ex) { [EOL]         throw new JXPathException("Exception trying to remove xpath " + xpath, ex); [EOL]     } [EOL] }
public void removePath(String xpath, Expression expr) { [EOL]     try { [EOL]         NodePointer pointer = (NodePointer) getPointer(xpath, expr); [EOL]         if (pointer != null) { [EOL]             ((NodePointer) pointer).remove(); [EOL]         } [EOL]     } catch (Throwable ex) { [EOL]         throw new JXPathException("Exception trying to remove xpath " + xpath, ex); [EOL]     } [EOL] }
public void removePath(String xpath, Expression expr) { [EOL]     try { [EOL]         NodePointer pointer = (NodePointer) getPointer(xpath, expr); [EOL]         if (pointer != null) { [EOL]             ((NodePointer) pointer).remove(); [EOL]         } [EOL]     } catch (Throwable ex) { [EOL]         throw new JXPathException("Exception trying to remove xpath " + xpath, ex); [EOL]     } [EOL] }
public void registerNamespace(String prefix, String namespaceURI) { [EOL]     if (namespaceResolver.isSealed()) { [EOL]         namespaceResolver = (NamespaceResolver) namespaceResolver.clone(); [EOL]     } [EOL]     namespaceResolver.registerNamespace(prefix, namespaceURI); [EOL] }
public void registerNamespace(String prefix, String namespaceURI) { [EOL]     if (namespaceResolver.isSealed()) { [EOL]         namespaceResolver = (NamespaceResolver) namespaceResolver.clone(); [EOL]     } [EOL]     namespaceResolver.registerNamespace(prefix, namespaceURI); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     double a = InfoSetUtil.doubleValue(args[0].computeValue(context)); [EOL]     return new Double(-a); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     double a = InfoSetUtil.doubleValue(args[0].computeValue(context)); [EOL]     return new Double(-a); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     double a = InfoSetUtil.doubleValue(args[0].computeValue(context)); [EOL]     return new Double(-a); [EOL] }
public NodeSet getNodeSet() { [EOL]     return nodeSet; [EOL] }
public boolean computeContextDependent() { [EOL]     if (args != null) { [EOL]         for (int i = 0; i < args.length; i++) { [EOL]             if (args[i].isContextDependent()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean computeContextDependent() { [EOL]     if (args != null) { [EOL]         for (int i = 0; i < args.length; i++) { [EOL]             if (args[i].isContextDependent()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean computeContextDependent() { [EOL]     if (args != null) { [EOL]         for (int i = 0; i < args.length; i++) { [EOL]             if (args[i].isContextDependent()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean computeContextDependent() { [EOL]     if (args != null) { [EOL]         for (int i = 0; i < args.length; i++) { [EOL]             if (args[i].isContextDependent()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public Object computeValue(EvalContext context) { [EOL]     EvalContext[] argCtxs = new EvalContext[args.length]; [EOL]     for (int i = 0; i < args.length; i++) { [EOL]         Object value = args[i].compute(context); [EOL]         if (value instanceof EvalContext) { [EOL]             argCtxs[i] = (EvalContext) value; [EOL]         } else { [EOL]             argCtxs[i] = context.getRootContext().getConstantContext(value); [EOL]         } [EOL]     } [EOL]     return new UnionContext(context.getRootContext(), argCtxs); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     EvalContext[] argCtxs = new EvalContext[args.length]; [EOL]     for (int i = 0; i < args.length; i++) { [EOL]         Object value = args[i].compute(context); [EOL]         if (value instanceof EvalContext) { [EOL]             argCtxs[i] = (EvalContext) value; [EOL]         } else { [EOL]             argCtxs[i] = context.getRootContext().getConstantContext(value); [EOL]         } [EOL]     } [EOL]     return new UnionContext(context.getRootContext(), argCtxs); [EOL] }
public Object computeValue(EvalContext context) { [EOL]     EvalContext[] argCtxs = new EvalContext[args.length]; [EOL]     for (int i = 0; i < args.length; i++) { [EOL]         Object value = args[i].compute(context); [EOL]         if (value instanceof EvalContext) { [EOL]             argCtxs[i] = (EvalContext) value; [EOL]         } else { [EOL]             argCtxs[i] = context.getRootContext().getConstantContext(value); [EOL]         } [EOL]     } [EOL]     return new UnionContext(context.getRootContext(), argCtxs); [EOL] }
public JDOMNodeIterator(NodePointer parent, NodeTest nodeTest, boolean reverse, NodePointer startWith) { [EOL]     this.parent = parent; [EOL]     if (startWith != null) { [EOL]         this.child = startWith.getNode(); [EOL]     } [EOL]     Object node = parent.getNode(); [EOL]     if (node instanceof Document) { [EOL]         this.children = ((Document) node).getContent(); [EOL]     } else if (node instanceof Element) { [EOL]         this.children = ((Element) node).getContent(); [EOL]     } else { [EOL]         this.children = Collections.EMPTY_LIST; [EOL]     } [EOL]     this.nodeTest = nodeTest; [EOL]     this.reverse = reverse; [EOL] }
public JDOMNodeIterator(NodePointer parent, NodeTest nodeTest, boolean reverse, NodePointer startWith) { [EOL]     this.parent = parent; [EOL]     if (startWith != null) { [EOL]         this.child = startWith.getNode(); [EOL]     } [EOL]     Object node = parent.getNode(); [EOL]     if (node instanceof Document) { [EOL]         this.children = ((Document) node).getContent(); [EOL]     } else if (node instanceof Element) { [EOL]         this.children = ((Element) node).getContent(); [EOL]     } else { [EOL]         this.children = Collections.EMPTY_LIST; [EOL]     } [EOL]     this.nodeTest = nodeTest; [EOL]     this.reverse = reverse; [EOL] }
public JDOMNodeIterator(NodePointer parent, NodeTest nodeTest, boolean reverse, NodePointer startWith) { [EOL]     this.parent = parent; [EOL]     if (startWith != null) { [EOL]         this.child = startWith.getNode(); [EOL]     } [EOL]     Object node = parent.getNode(); [EOL]     if (node instanceof Document) { [EOL]         this.children = ((Document) node).getContent(); [EOL]     } else if (node instanceof Element) { [EOL]         this.children = ((Element) node).getContent(); [EOL]     } else { [EOL]         this.children = Collections.EMPTY_LIST; [EOL]     } [EOL]     this.nodeTest = nodeTest; [EOL]     this.reverse = reverse; [EOL] }
public JDOMNodeIterator(NodePointer parent, NodeTest nodeTest, boolean reverse, NodePointer startWith) { [EOL]     this.parent = parent; [EOL]     if (startWith != null) { [EOL]         this.child = startWith.getNode(); [EOL]     } [EOL]     Object node = parent.getNode(); [EOL]     if (node instanceof Document) { [EOL]         this.children = ((Document) node).getContent(); [EOL]     } else if (node instanceof Element) { [EOL]         this.children = ((Element) node).getContent(); [EOL]     } else { [EOL]         this.children = Collections.EMPTY_LIST; [EOL]     } [EOL]     this.nodeTest = nodeTest; [EOL]     this.reverse = reverse; [EOL] }
public JDOMNodeIterator(NodePointer parent, NodeTest nodeTest, boolean reverse, NodePointer startWith) { [EOL]     this.parent = parent; [EOL]     if (startWith != null) { [EOL]         this.child = startWith.getNode(); [EOL]     } [EOL]     Object node = parent.getNode(); [EOL]     if (node instanceof Document) { [EOL]         this.children = ((Document) node).getContent(); [EOL]     } else if (node instanceof Element) { [EOL]         this.children = ((Element) node).getContent(); [EOL]     } else { [EOL]         this.children = Collections.EMPTY_LIST; [EOL]     } [EOL]     this.nodeTest = nodeTest; [EOL]     this.reverse = reverse; [EOL] }
public NodePointer getNodePointer() { [EOL]     if (child == null) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]         position = 0; [EOL]     } [EOL]     return new JDOMNodePointer(parent, child); [EOL] }
public NodePointer getNodePointer() { [EOL]     if (child == null) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]         position = 0; [EOL]     } [EOL]     return new JDOMNodePointer(parent, child); [EOL] }
public NodePointer getNodePointer() { [EOL]     if (child == null) { [EOL]         if (!setPosition(1)) { [EOL]             return null; [EOL]         } [EOL]         position = 0; [EOL]     } [EOL]     return new JDOMNodePointer(parent, child); [EOL] }
private boolean next() { [EOL]     position++; [EOL]     if (!reverse) { [EOL]         if (position == 1) { [EOL]             index = 0; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) + 1; [EOL]             } [EOL]         } else { [EOL]             index++; [EOL]         } [EOL]         for (; index < children.size(); index++) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } else { [EOL]         if (position == 1) { [EOL]             index = children.size() - 1; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) - 1; [EOL]             } [EOL]         } else { [EOL]             index--; [EOL]         } [EOL]         for (; index >= 0; index--) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL] }
private boolean next() { [EOL]     position++; [EOL]     if (!reverse) { [EOL]         if (position == 1) { [EOL]             index = 0; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) + 1; [EOL]             } [EOL]         } else { [EOL]             index++; [EOL]         } [EOL]         for (; index < children.size(); index++) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } else { [EOL]         if (position == 1) { [EOL]             index = children.size() - 1; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) - 1; [EOL]             } [EOL]         } else { [EOL]             index--; [EOL]         } [EOL]         for (; index >= 0; index--) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL] }
private boolean next() { [EOL]     position++; [EOL]     if (!reverse) { [EOL]         if (position == 1) { [EOL]             index = 0; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) + 1; [EOL]             } [EOL]         } else { [EOL]             index++; [EOL]         } [EOL]         for (; index < children.size(); index++) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } else { [EOL]         if (position == 1) { [EOL]             index = children.size() - 1; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) - 1; [EOL]             } [EOL]         } else { [EOL]             index--; [EOL]         } [EOL]         for (; index >= 0; index--) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL] }
private boolean next() { [EOL]     position++; [EOL]     if (!reverse) { [EOL]         if (position == 1) { [EOL]             index = 0; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) + 1; [EOL]             } [EOL]         } else { [EOL]             index++; [EOL]         } [EOL]         for (; index < children.size(); index++) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } else { [EOL]         if (position == 1) { [EOL]             index = children.size() - 1; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) - 1; [EOL]             } [EOL]         } else { [EOL]             index--; [EOL]         } [EOL]         for (; index >= 0; index--) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL] }
private boolean next() { [EOL]     position++; [EOL]     if (!reverse) { [EOL]         if (position == 1) { [EOL]             index = 0; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) + 1; [EOL]             } [EOL]         } else { [EOL]             index++; [EOL]         } [EOL]         for (; index < children.size(); index++) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } else { [EOL]         if (position == 1) { [EOL]             index = children.size() - 1; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) - 1; [EOL]             } [EOL]         } else { [EOL]             index--; [EOL]         } [EOL]         for (; index >= 0; index--) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL] }
private boolean next() { [EOL]     position++; [EOL]     if (!reverse) { [EOL]         if (position == 1) { [EOL]             index = 0; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) + 1; [EOL]             } [EOL]         } else { [EOL]             index++; [EOL]         } [EOL]         for (; index < children.size(); index++) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } else { [EOL]         if (position == 1) { [EOL]             index = children.size() - 1; [EOL]             if (child != null) { [EOL]                 index = children.indexOf(child) - 1; [EOL]             } [EOL]         } else { [EOL]             index--; [EOL]         } [EOL]         for (; index >= 0; index--) { [EOL]             child = children.get(index); [EOL]             if (testChild()) { [EOL]                 return true; [EOL]             } [EOL]         } [EOL]         return false; [EOL]     } [EOL] }
private boolean testChild() { [EOL]     return JDOMNodePointer.testNode(parent, child, nodeTest); [EOL] }
public JXPathException(String msg) { [EOL]     super(msg); [EOL]     this.exception = null; [EOL] }
public JXPathException(String msg, Throwable e) { [EOL]     super(msg); [EOL]     this.exception = e; [EOL] }
