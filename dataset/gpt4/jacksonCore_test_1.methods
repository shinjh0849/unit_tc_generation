public static CharsToNameCanonicalizer createRoot() { [EOL]     long now = System.currentTimeMillis(); [EOL]     int seed = (((int) now) + ((int) (now >>> 32))) | 1; [EOL]     return createRoot(seed); [EOL] }
protected static CharsToNameCanonicalizer createRoot(int hashSeed) { [EOL]     return sBootstrapSymbolTable.makeOrphan(hashSeed); [EOL] }
private static int _thresholdSize(int hashAreaSize) { [EOL]     return hashAreaSize - (hashAreaSize >> 2); [EOL] }
private static int _thresholdSize(int hashAreaSize) { [EOL]     return hashAreaSize - (hashAreaSize >> 2); [EOL] }
private static int _thresholdSize(int hashAreaSize) { [EOL]     return hashAreaSize - (hashAreaSize >> 2); [EOL] }
private CharsToNameCanonicalizer(CharsToNameCanonicalizer parent, boolean canonicalize, boolean intern, String[] symbols, Bucket[] buckets, int size, int hashSeed, int longestColl) { [EOL]     _parent = parent; [EOL]     _canonicalize = canonicalize; [EOL]     _intern = intern; [EOL]     _symbols = symbols; [EOL]     _buckets = buckets; [EOL]     _size = size; [EOL]     _hashSeed = hashSeed; [EOL]     int arrayLen = (symbols.length); [EOL]     _sizeThreshold = _thresholdSize(arrayLen); [EOL]     _indexMask = (arrayLen - 1); [EOL]     _longestCollisionList = longestColl; [EOL]     _dirty = false; [EOL] }
private CharsToNameCanonicalizer(CharsToNameCanonicalizer parent, boolean canonicalize, boolean intern, String[] symbols, Bucket[] buckets, int size, int hashSeed, int longestColl) { [EOL]     _parent = parent; [EOL]     _canonicalize = canonicalize; [EOL]     _intern = intern; [EOL]     _symbols = symbols; [EOL]     _buckets = buckets; [EOL]     _size = size; [EOL]     _hashSeed = hashSeed; [EOL]     int arrayLen = (symbols.length); [EOL]     _sizeThreshold = _thresholdSize(arrayLen); [EOL]     _indexMask = (arrayLen - 1); [EOL]     _longestCollisionList = longestColl; [EOL]     _dirty = false; [EOL] }
public CharsToNameCanonicalizer makeChild(final boolean canonicalize, final boolean intern) { [EOL]     final String[] symbols; [EOL]     final Bucket[] buckets; [EOL]     final int size; [EOL]     final int hashSeed; [EOL]     final int longestCollisionList; [EOL]     synchronized (this) { [EOL]         symbols = _symbols; [EOL]         buckets = _buckets; [EOL]         size = _size; [EOL]         hashSeed = _hashSeed; [EOL]         longestCollisionList = _longestCollisionList; [EOL]     } [EOL]     return new CharsToNameCanonicalizer(this, canonicalize, intern, symbols, buckets, size, hashSeed, longestCollisionList); [EOL] }
public CharsToNameCanonicalizer makeChild(final boolean canonicalize, final boolean intern) { [EOL]     final String[] symbols; [EOL]     final Bucket[] buckets; [EOL]     final int size; [EOL]     final int hashSeed; [EOL]     final int longestCollisionList; [EOL]     synchronized (this) { [EOL]         symbols = _symbols; [EOL]         buckets = _buckets; [EOL]         size = _size; [EOL]         hashSeed = _hashSeed; [EOL]         longestCollisionList = _longestCollisionList; [EOL]     } [EOL]     return new CharsToNameCanonicalizer(this, canonicalize, intern, symbols, buckets, size, hashSeed, longestCollisionList); [EOL] }
private CharsToNameCanonicalizer makeOrphan(int seed) { [EOL]     return new CharsToNameCanonicalizer(null, true, true, _symbols, _buckets, _size, seed, _longestCollisionList); [EOL] }
private CharsToNameCanonicalizer makeOrphan(int seed) { [EOL]     return new CharsToNameCanonicalizer(null, true, true, _symbols, _buckets, _size, seed, _longestCollisionList); [EOL] }
private CharsToNameCanonicalizer makeOrphan(int seed) { [EOL]     return new CharsToNameCanonicalizer(null, true, true, _symbols, _buckets, _size, seed, _longestCollisionList); [EOL] }
private void mergeChild(CharsToNameCanonicalizer child) { [EOL]     if (child.size() > MAX_ENTRIES_FOR_REUSE || child._longestCollisionList > MAX_COLL_CHAIN_FOR_REUSE) { [EOL]         synchronized (this) { [EOL]             initTables(DEFAULT_TABLE_SIZE); [EOL]             _dirty = false; [EOL]         } [EOL]     } else { [EOL]         if (child.size() <= size()) { [EOL]             return; [EOL]         } [EOL]         synchronized (this) { [EOL]             _symbols = child._symbols; [EOL]             _buckets = child._buckets; [EOL]             _size = child._size; [EOL]             _sizeThreshold = child._sizeThreshold; [EOL]             _indexMask = child._indexMask; [EOL]             _longestCollisionList = child._longestCollisionList; [EOL]             _dirty = false; [EOL]         } [EOL]     } [EOL] }
private void mergeChild(CharsToNameCanonicalizer child) { [EOL]     if (child.size() > MAX_ENTRIES_FOR_REUSE || child._longestCollisionList > MAX_COLL_CHAIN_FOR_REUSE) { [EOL]         synchronized (this) { [EOL]             initTables(DEFAULT_TABLE_SIZE); [EOL]             _dirty = false; [EOL]         } [EOL]     } else { [EOL]         if (child.size() <= size()) { [EOL]             return; [EOL]         } [EOL]         synchronized (this) { [EOL]             _symbols = child._symbols; [EOL]             _buckets = child._buckets; [EOL]             _size = child._size; [EOL]             _sizeThreshold = child._sizeThreshold; [EOL]             _indexMask = child._indexMask; [EOL]             _longestCollisionList = child._longestCollisionList; [EOL]             _dirty = false; [EOL]         } [EOL]     } [EOL] }
private void mergeChild(CharsToNameCanonicalizer child) { [EOL]     if (child.size() > MAX_ENTRIES_FOR_REUSE || child._longestCollisionList > MAX_COLL_CHAIN_FOR_REUSE) { [EOL]         synchronized (this) { [EOL]             initTables(DEFAULT_TABLE_SIZE); [EOL]             _dirty = false; [EOL]         } [EOL]     } else { [EOL]         if (child.size() <= size()) { [EOL]             return; [EOL]         } [EOL]         synchronized (this) { [EOL]             _symbols = child._symbols; [EOL]             _buckets = child._buckets; [EOL]             _size = child._size; [EOL]             _sizeThreshold = child._sizeThreshold; [EOL]             _indexMask = child._indexMask; [EOL]             _longestCollisionList = child._longestCollisionList; [EOL]             _dirty = false; [EOL]         } [EOL]     } [EOL] }
public void release() { [EOL]     if (!maybeDirty()) { [EOL]         return; [EOL]     } [EOL]     if (_parent != null) { [EOL]         _parent.mergeChild(this); [EOL]         _dirty = false; [EOL]     } [EOL] }
public void release() { [EOL]     if (!maybeDirty()) { [EOL]         return; [EOL]     } [EOL]     if (_parent != null) { [EOL]         _parent.mergeChild(this); [EOL]         _dirty = false; [EOL]     } [EOL] }
public int size() { [EOL]     return _size; [EOL] }
public int size() { [EOL]     return _size; [EOL] }
public boolean maybeDirty() { [EOL]     return _dirty; [EOL] }
public boolean maybeDirty() { [EOL]     return _dirty; [EOL] }
public int hashSeed() { [EOL]     return _hashSeed; [EOL] }
public String findSymbol(char[] buffer, int start, int len, int h) { [EOL]     if (len < 1) { [EOL]         return ""; [EOL]     } [EOL]     if (!_canonicalize) { [EOL]         return new String(buffer, start, len); [EOL]     } [EOL]     int index = _hashToIndex(h); [EOL]     String sym = _symbols[index]; [EOL]     if (sym != null) { [EOL]         if (sym.length() == len) { [EOL]             int i = 0; [EOL]             do { [EOL]                 if (sym.charAt(i) != buffer[start + i]) { [EOL]                     break; [EOL]                 } [EOL]             } while (++i < len); [EOL]             if (i == len) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]         Bucket b = _buckets[index >> 1]; [EOL]         if (b != null) { [EOL]             sym = b.find(buffer, start, len); [EOL]             if (sym != null) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (!_dirty) { [EOL]         copyArrays(); [EOL]         _dirty = true; [EOL]     } else if (_size >= _sizeThreshold) { [EOL]         rehash(); [EOL]         index = _hashToIndex(calcHash(buffer, start, len)); [EOL]     } [EOL]     String newSymbol = new String(buffer, start, len); [EOL]     if (_intern) { [EOL]         newSymbol = InternCache.instance.intern(newSymbol); [EOL]     } [EOL]     ++_size; [EOL]     if (_symbols[index] == null) { [EOL]         _symbols[index] = newSymbol; [EOL]     } else { [EOL]         int bix = (index >> 1); [EOL]         Bucket newB = new Bucket(newSymbol, _buckets[bix]); [EOL]         _buckets[bix] = newB; [EOL]         _longestCollisionList = Math.max(newB.length(), _longestCollisionList); [EOL]         if (_longestCollisionList > MAX_COLL_CHAIN_LENGTH) { [EOL]             reportTooManyCollisions(MAX_COLL_CHAIN_LENGTH); [EOL]         } [EOL]     } [EOL]     return newSymbol; [EOL] }
public String findSymbol(char[] buffer, int start, int len, int h) { [EOL]     if (len < 1) { [EOL]         return ""; [EOL]     } [EOL]     if (!_canonicalize) { [EOL]         return new String(buffer, start, len); [EOL]     } [EOL]     int index = _hashToIndex(h); [EOL]     String sym = _symbols[index]; [EOL]     if (sym != null) { [EOL]         if (sym.length() == len) { [EOL]             int i = 0; [EOL]             do { [EOL]                 if (sym.charAt(i) != buffer[start + i]) { [EOL]                     break; [EOL]                 } [EOL]             } while (++i < len); [EOL]             if (i == len) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]         Bucket b = _buckets[index >> 1]; [EOL]         if (b != null) { [EOL]             sym = b.find(buffer, start, len); [EOL]             if (sym != null) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (!_dirty) { [EOL]         copyArrays(); [EOL]         _dirty = true; [EOL]     } else if (_size >= _sizeThreshold) { [EOL]         rehash(); [EOL]         index = _hashToIndex(calcHash(buffer, start, len)); [EOL]     } [EOL]     String newSymbol = new String(buffer, start, len); [EOL]     if (_intern) { [EOL]         newSymbol = InternCache.instance.intern(newSymbol); [EOL]     } [EOL]     ++_size; [EOL]     if (_symbols[index] == null) { [EOL]         _symbols[index] = newSymbol; [EOL]     } else { [EOL]         int bix = (index >> 1); [EOL]         Bucket newB = new Bucket(newSymbol, _buckets[bix]); [EOL]         _buckets[bix] = newB; [EOL]         _longestCollisionList = Math.max(newB.length(), _longestCollisionList); [EOL]         if (_longestCollisionList > MAX_COLL_CHAIN_LENGTH) { [EOL]             reportTooManyCollisions(MAX_COLL_CHAIN_LENGTH); [EOL]         } [EOL]     } [EOL]     return newSymbol; [EOL] }
public String findSymbol(char[] buffer, int start, int len, int h) { [EOL]     if (len < 1) { [EOL]         return ""; [EOL]     } [EOL]     if (!_canonicalize) { [EOL]         return new String(buffer, start, len); [EOL]     } [EOL]     int index = _hashToIndex(h); [EOL]     String sym = _symbols[index]; [EOL]     if (sym != null) { [EOL]         if (sym.length() == len) { [EOL]             int i = 0; [EOL]             do { [EOL]                 if (sym.charAt(i) != buffer[start + i]) { [EOL]                     break; [EOL]                 } [EOL]             } while (++i < len); [EOL]             if (i == len) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]         Bucket b = _buckets[index >> 1]; [EOL]         if (b != null) { [EOL]             sym = b.find(buffer, start, len); [EOL]             if (sym != null) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (!_dirty) { [EOL]         copyArrays(); [EOL]         _dirty = true; [EOL]     } else if (_size >= _sizeThreshold) { [EOL]         rehash(); [EOL]         index = _hashToIndex(calcHash(buffer, start, len)); [EOL]     } [EOL]     String newSymbol = new String(buffer, start, len); [EOL]     if (_intern) { [EOL]         newSymbol = InternCache.instance.intern(newSymbol); [EOL]     } [EOL]     ++_size; [EOL]     if (_symbols[index] == null) { [EOL]         _symbols[index] = newSymbol; [EOL]     } else { [EOL]         int bix = (index >> 1); [EOL]         Bucket newB = new Bucket(newSymbol, _buckets[bix]); [EOL]         _buckets[bix] = newB; [EOL]         _longestCollisionList = Math.max(newB.length(), _longestCollisionList); [EOL]         if (_longestCollisionList > MAX_COLL_CHAIN_LENGTH) { [EOL]             reportTooManyCollisions(MAX_COLL_CHAIN_LENGTH); [EOL]         } [EOL]     } [EOL]     return newSymbol; [EOL] }
public String findSymbol(char[] buffer, int start, int len, int h) { [EOL]     if (len < 1) { [EOL]         return ""; [EOL]     } [EOL]     if (!_canonicalize) { [EOL]         return new String(buffer, start, len); [EOL]     } [EOL]     int index = _hashToIndex(h); [EOL]     String sym = _symbols[index]; [EOL]     if (sym != null) { [EOL]         if (sym.length() == len) { [EOL]             int i = 0; [EOL]             do { [EOL]                 if (sym.charAt(i) != buffer[start + i]) { [EOL]                     break; [EOL]                 } [EOL]             } while (++i < len); [EOL]             if (i == len) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]         Bucket b = _buckets[index >> 1]; [EOL]         if (b != null) { [EOL]             sym = b.find(buffer, start, len); [EOL]             if (sym != null) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (!_dirty) { [EOL]         copyArrays(); [EOL]         _dirty = true; [EOL]     } else if (_size >= _sizeThreshold) { [EOL]         rehash(); [EOL]         index = _hashToIndex(calcHash(buffer, start, len)); [EOL]     } [EOL]     String newSymbol = new String(buffer, start, len); [EOL]     if (_intern) { [EOL]         newSymbol = InternCache.instance.intern(newSymbol); [EOL]     } [EOL]     ++_size; [EOL]     if (_symbols[index] == null) { [EOL]         _symbols[index] = newSymbol; [EOL]     } else { [EOL]         int bix = (index >> 1); [EOL]         Bucket newB = new Bucket(newSymbol, _buckets[bix]); [EOL]         _buckets[bix] = newB; [EOL]         _longestCollisionList = Math.max(newB.length(), _longestCollisionList); [EOL]         if (_longestCollisionList > MAX_COLL_CHAIN_LENGTH) { [EOL]             reportTooManyCollisions(MAX_COLL_CHAIN_LENGTH); [EOL]         } [EOL]     } [EOL]     return newSymbol; [EOL] }
public String findSymbol(char[] buffer, int start, int len, int h) { [EOL]     if (len < 1) { [EOL]         return ""; [EOL]     } [EOL]     if (!_canonicalize) { [EOL]         return new String(buffer, start, len); [EOL]     } [EOL]     int index = _hashToIndex(h); [EOL]     String sym = _symbols[index]; [EOL]     if (sym != null) { [EOL]         if (sym.length() == len) { [EOL]             int i = 0; [EOL]             do { [EOL]                 if (sym.charAt(i) != buffer[start + i]) { [EOL]                     break; [EOL]                 } [EOL]             } while (++i < len); [EOL]             if (i == len) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]         Bucket b = _buckets[index >> 1]; [EOL]         if (b != null) { [EOL]             sym = b.find(buffer, start, len); [EOL]             if (sym != null) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (!_dirty) { [EOL]         copyArrays(); [EOL]         _dirty = true; [EOL]     } else if (_size >= _sizeThreshold) { [EOL]         rehash(); [EOL]         index = _hashToIndex(calcHash(buffer, start, len)); [EOL]     } [EOL]     String newSymbol = new String(buffer, start, len); [EOL]     if (_intern) { [EOL]         newSymbol = InternCache.instance.intern(newSymbol); [EOL]     } [EOL]     ++_size; [EOL]     if (_symbols[index] == null) { [EOL]         _symbols[index] = newSymbol; [EOL]     } else { [EOL]         int bix = (index >> 1); [EOL]         Bucket newB = new Bucket(newSymbol, _buckets[bix]); [EOL]         _buckets[bix] = newB; [EOL]         _longestCollisionList = Math.max(newB.length(), _longestCollisionList); [EOL]         if (_longestCollisionList > MAX_COLL_CHAIN_LENGTH) { [EOL]             reportTooManyCollisions(MAX_COLL_CHAIN_LENGTH); [EOL]         } [EOL]     } [EOL]     return newSymbol; [EOL] }
public String findSymbol(char[] buffer, int start, int len, int h) { [EOL]     if (len < 1) { [EOL]         return ""; [EOL]     } [EOL]     if (!_canonicalize) { [EOL]         return new String(buffer, start, len); [EOL]     } [EOL]     int index = _hashToIndex(h); [EOL]     String sym = _symbols[index]; [EOL]     if (sym != null) { [EOL]         if (sym.length() == len) { [EOL]             int i = 0; [EOL]             do { [EOL]                 if (sym.charAt(i) != buffer[start + i]) { [EOL]                     break; [EOL]                 } [EOL]             } while (++i < len); [EOL]             if (i == len) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]         Bucket b = _buckets[index >> 1]; [EOL]         if (b != null) { [EOL]             sym = b.find(buffer, start, len); [EOL]             if (sym != null) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (!_dirty) { [EOL]         copyArrays(); [EOL]         _dirty = true; [EOL]     } else if (_size >= _sizeThreshold) { [EOL]         rehash(); [EOL]         index = _hashToIndex(calcHash(buffer, start, len)); [EOL]     } [EOL]     String newSymbol = new String(buffer, start, len); [EOL]     if (_intern) { [EOL]         newSymbol = InternCache.instance.intern(newSymbol); [EOL]     } [EOL]     ++_size; [EOL]     if (_symbols[index] == null) { [EOL]         _symbols[index] = newSymbol; [EOL]     } else { [EOL]         int bix = (index >> 1); [EOL]         Bucket newB = new Bucket(newSymbol, _buckets[bix]); [EOL]         _buckets[bix] = newB; [EOL]         _longestCollisionList = Math.max(newB.length(), _longestCollisionList); [EOL]         if (_longestCollisionList > MAX_COLL_CHAIN_LENGTH) { [EOL]             reportTooManyCollisions(MAX_COLL_CHAIN_LENGTH); [EOL]         } [EOL]     } [EOL]     return newSymbol; [EOL] }
public String findSymbol(char[] buffer, int start, int len, int h) { [EOL]     if (len < 1) { [EOL]         return ""; [EOL]     } [EOL]     if (!_canonicalize) { [EOL]         return new String(buffer, start, len); [EOL]     } [EOL]     int index = _hashToIndex(h); [EOL]     String sym = _symbols[index]; [EOL]     if (sym != null) { [EOL]         if (sym.length() == len) { [EOL]             int i = 0; [EOL]             do { [EOL]                 if (sym.charAt(i) != buffer[start + i]) { [EOL]                     break; [EOL]                 } [EOL]             } while (++i < len); [EOL]             if (i == len) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]         Bucket b = _buckets[index >> 1]; [EOL]         if (b != null) { [EOL]             sym = b.find(buffer, start, len); [EOL]             if (sym != null) { [EOL]                 return sym; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (!_dirty) { [EOL]         copyArrays(); [EOL]         _dirty = true; [EOL]     } else if (_size >= _sizeThreshold) { [EOL]         rehash(); [EOL]         index = _hashToIndex(calcHash(buffer, start, len)); [EOL]     } [EOL]     String newSymbol = new String(buffer, start, len); [EOL]     if (_intern) { [EOL]         newSymbol = InternCache.instance.intern(newSymbol); [EOL]     } [EOL]     ++_size; [EOL]     if (_symbols[index] == null) { [EOL]         _symbols[index] = newSymbol; [EOL]     } else { [EOL]         int bix = (index >> 1); [EOL]         Bucket newB = new Bucket(newSymbol, _buckets[bix]); [EOL]         _buckets[bix] = newB; [EOL]         _longestCollisionList = Math.max(newB.length(), _longestCollisionList); [EOL]         if (_longestCollisionList > MAX_COLL_CHAIN_LENGTH) { [EOL]             reportTooManyCollisions(MAX_COLL_CHAIN_LENGTH); [EOL]         } [EOL]     } [EOL]     return newSymbol; [EOL] }
public int _hashToIndex(int rawHash) { [EOL]     rawHash += (rawHash >>> 15); [EOL]     return (rawHash & _indexMask); [EOL] }
public int _hashToIndex(int rawHash) { [EOL]     rawHash += (rawHash >>> 15); [EOL]     return (rawHash & _indexMask); [EOL] }
public int _hashToIndex(int rawHash) { [EOL]     rawHash += (rawHash >>> 15); [EOL]     return (rawHash & _indexMask); [EOL] }
public int _hashToIndex(int rawHash) { [EOL]     rawHash += (rawHash >>> 15); [EOL]     return (rawHash & _indexMask); [EOL] }
public int _hashToIndex(int rawHash) { [EOL]     rawHash += (rawHash >>> 15); [EOL]     return (rawHash & _indexMask); [EOL] }
private void copyArrays() { [EOL]     final String[] oldSyms = _symbols; [EOL]     _symbols = Arrays.copyOf(oldSyms, oldSyms.length); [EOL]     final Bucket[] oldBuckets = _buckets; [EOL]     _buckets = Arrays.copyOf(oldBuckets, oldBuckets.length); [EOL] }
public Bucket(String symbol, Bucket next) { [EOL]     _symbol = symbol; [EOL]     _next = next; [EOL]     _length = (next == null) ? 1 : next._length + 1; [EOL] }
public Bucket(String symbol, Bucket next) { [EOL]     _symbol = symbol; [EOL]     _next = next; [EOL]     _length = (next == null) ? 1 : next._length + 1; [EOL] }
public int length() { [EOL]     return _length; [EOL] }
public int length() { [EOL]     return _length; [EOL] }
protected ParserBase(IOContext ctxt, int features) { [EOL]     super(); [EOL]     _features = features; [EOL]     _ioContext = ctxt; [EOL]     _textBuffer = ctxt.constructTextBuffer(); [EOL]     _parsingContext = JsonReadContext.createRootContext(); [EOL] }
@Override [EOL] public String getCurrentName() throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]         JsonReadContext parent = _parsingContext.getParent(); [EOL]         return parent.getCurrentName(); [EOL]     } [EOL]     return _parsingContext.getCurrentName(); [EOL] }
@Override [EOL] public String getCurrentName() throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]         JsonReadContext parent = _parsingContext.getParent(); [EOL]         return parent.getCurrentName(); [EOL]     } [EOL]     return _parsingContext.getCurrentName(); [EOL] }
@Override [EOL] public void close() throws IOException { [EOL]     if (!_closed) { [EOL]         _closed = true; [EOL]         try { [EOL]             _closeInput(); [EOL]         } finally { [EOL]             _releaseBuffers(); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void close() throws IOException { [EOL]     if (!_closed) { [EOL]         _closed = true; [EOL]         try { [EOL]             _closeInput(); [EOL]         } finally { [EOL]             _releaseBuffers(); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public boolean isClosed() { [EOL]     return _closed; [EOL] }
@Override [EOL] public boolean isClosed() { [EOL]     return _closed; [EOL] }
protected void _releaseBuffers() throws IOException { [EOL]     _textBuffer.releaseBuffers(); [EOL]     char[] buf = _nameCopyBuffer; [EOL]     if (buf != null) { [EOL]         _nameCopyBuffer = null; [EOL]         _ioContext.releaseNameCopyBuffer(buf); [EOL]     } [EOL] }
protected void _releaseBuffers() throws IOException { [EOL]     _textBuffer.releaseBuffers(); [EOL]     char[] buf = _nameCopyBuffer; [EOL]     if (buf != null) { [EOL]         _nameCopyBuffer = null; [EOL]         _ioContext.releaseNameCopyBuffer(buf); [EOL]     } [EOL] }
protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen) { [EOL]     if (fractLen < 1 && expLen < 1) { [EOL]         return resetInt(negative, intLen); [EOL]     } [EOL]     return resetFloat(negative, intLen, fractLen, expLen); [EOL] }
protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen) { [EOL]     if (fractLen < 1 && expLen < 1) { [EOL]         return resetInt(negative, intLen); [EOL]     } [EOL]     return resetFloat(negative, intLen, fractLen, expLen); [EOL] }
protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen) { [EOL]     if (fractLen < 1 && expLen < 1) { [EOL]         return resetInt(negative, intLen); [EOL]     } [EOL]     return resetFloat(negative, intLen, fractLen, expLen); [EOL] }
protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen) { [EOL]     if (fractLen < 1 && expLen < 1) { [EOL]         return resetInt(negative, intLen); [EOL]     } [EOL]     return resetFloat(negative, intLen, fractLen, expLen); [EOL] }
protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen) { [EOL]     if (fractLen < 1 && expLen < 1) { [EOL]         return resetInt(negative, intLen); [EOL]     } [EOL]     return resetFloat(negative, intLen, fractLen, expLen); [EOL] }
protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen) { [EOL]     if (fractLen < 1 && expLen < 1) { [EOL]         return resetInt(negative, intLen); [EOL]     } [EOL]     return resetFloat(negative, intLen, fractLen, expLen); [EOL] }
protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen) { [EOL]     if (fractLen < 1 && expLen < 1) { [EOL]         return resetInt(negative, intLen); [EOL]     } [EOL]     return resetFloat(negative, intLen, fractLen, expLen); [EOL] }
protected final JsonToken reset(boolean negative, int intLen, int fractLen, int expLen) { [EOL]     if (fractLen < 1 && expLen < 1) { [EOL]         return resetInt(negative, intLen); [EOL]     } [EOL]     return resetFloat(negative, intLen, fractLen, expLen); [EOL] }
protected final JsonToken resetInt(boolean negative, int intLen) { [EOL]     _numberNegative = negative; [EOL]     _intLength = intLen; [EOL]     _fractLength = 0; [EOL]     _expLength = 0; [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     return JsonToken.VALUE_NUMBER_INT; [EOL] }
protected final JsonToken resetInt(boolean negative, int intLen) { [EOL]     _numberNegative = negative; [EOL]     _intLength = intLen; [EOL]     _fractLength = 0; [EOL]     _expLength = 0; [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     return JsonToken.VALUE_NUMBER_INT; [EOL] }
protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen) { [EOL]     _numberNegative = negative; [EOL]     _intLength = intLen; [EOL]     _fractLength = fractLen; [EOL]     _expLength = expLen; [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     return JsonToken.VALUE_NUMBER_FLOAT; [EOL] }
protected final JsonToken resetFloat(boolean negative, int intLen, int fractLen, int expLen) { [EOL]     _numberNegative = negative; [EOL]     _intLength = intLen; [EOL]     _fractLength = fractLen; [EOL]     _expLength = expLen; [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     return JsonToken.VALUE_NUMBER_FLOAT; [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     if (_numTypesValid == NR_UNKNOWN) { [EOL]         _parseNumericValue(NR_UNKNOWN); [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         if ((_numTypesValid & NR_INT) != 0) { [EOL]             return NumberType.INT; [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) != 0) { [EOL]             return NumberType.LONG; [EOL]         } [EOL]         return NumberType.BIG_INTEGER; [EOL]     } [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         return NumberType.BIG_DECIMAL; [EOL]     } [EOL]     return NumberType.DOUBLE; [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     if (_numTypesValid == NR_UNKNOWN) { [EOL]         _parseNumericValue(NR_UNKNOWN); [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         if ((_numTypesValid & NR_INT) != 0) { [EOL]             return NumberType.INT; [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) != 0) { [EOL]             return NumberType.LONG; [EOL]         } [EOL]         return NumberType.BIG_INTEGER; [EOL]     } [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         return NumberType.BIG_DECIMAL; [EOL]     } [EOL]     return NumberType.DOUBLE; [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     if (_numTypesValid == NR_UNKNOWN) { [EOL]         _parseNumericValue(NR_UNKNOWN); [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         if ((_numTypesValid & NR_INT) != 0) { [EOL]             return NumberType.INT; [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) != 0) { [EOL]             return NumberType.LONG; [EOL]         } [EOL]         return NumberType.BIG_INTEGER; [EOL]     } [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         return NumberType.BIG_DECIMAL; [EOL]     } [EOL]     return NumberType.DOUBLE; [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     if (_numTypesValid == NR_UNKNOWN) { [EOL]         _parseNumericValue(NR_UNKNOWN); [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         if ((_numTypesValid & NR_INT) != 0) { [EOL]             return NumberType.INT; [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) != 0) { [EOL]             return NumberType.LONG; [EOL]         } [EOL]         return NumberType.BIG_INTEGER; [EOL]     } [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         return NumberType.BIG_DECIMAL; [EOL]     } [EOL]     return NumberType.DOUBLE; [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     if (_numTypesValid == NR_UNKNOWN) { [EOL]         _parseNumericValue(NR_UNKNOWN); [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         if ((_numTypesValid & NR_INT) != 0) { [EOL]             return NumberType.INT; [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) != 0) { [EOL]             return NumberType.LONG; [EOL]         } [EOL]         return NumberType.BIG_INTEGER; [EOL]     } [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         return NumberType.BIG_DECIMAL; [EOL]     } [EOL]     return NumberType.DOUBLE; [EOL] }
@Override [EOL] public NumberType getNumberType() throws IOException, JsonParseException { [EOL]     if (_numTypesValid == NR_UNKNOWN) { [EOL]         _parseNumericValue(NR_UNKNOWN); [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         if ((_numTypesValid & NR_INT) != 0) { [EOL]             return NumberType.INT; [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) != 0) { [EOL]             return NumberType.LONG; [EOL]         } [EOL]         return NumberType.BIG_INTEGER; [EOL]     } [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         return NumberType.BIG_DECIMAL; [EOL]     } [EOL]     return NumberType.DOUBLE; [EOL] }
@Override [EOL] public int getIntValue() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_INT) == 0) { [EOL]         if (_numTypesValid == NR_UNKNOWN) { [EOL]             _parseNumericValue(NR_INT); [EOL]         } [EOL]         if ((_numTypesValid & NR_INT) == 0) { [EOL]             convertNumberToInt(); [EOL]         } [EOL]     } [EOL]     return _numberInt; [EOL] }
@Override [EOL] public int getIntValue() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_INT) == 0) { [EOL]         if (_numTypesValid == NR_UNKNOWN) { [EOL]             _parseNumericValue(NR_INT); [EOL]         } [EOL]         if ((_numTypesValid & NR_INT) == 0) { [EOL]             convertNumberToInt(); [EOL]         } [EOL]     } [EOL]     return _numberInt; [EOL] }
@Override [EOL] public int getIntValue() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_INT) == 0) { [EOL]         if (_numTypesValid == NR_UNKNOWN) { [EOL]             _parseNumericValue(NR_INT); [EOL]         } [EOL]         if ((_numTypesValid & NR_INT) == 0) { [EOL]             convertNumberToInt(); [EOL]         } [EOL]     } [EOL]     return _numberInt; [EOL] }
@Override [EOL] public long getLongValue() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_LONG) == 0) { [EOL]         if (_numTypesValid == NR_UNKNOWN) { [EOL]             _parseNumericValue(NR_LONG); [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) == 0) { [EOL]             convertNumberToLong(); [EOL]         } [EOL]     } [EOL]     return _numberLong; [EOL] }
@Override [EOL] public long getLongValue() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_LONG) == 0) { [EOL]         if (_numTypesValid == NR_UNKNOWN) { [EOL]             _parseNumericValue(NR_LONG); [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) == 0) { [EOL]             convertNumberToLong(); [EOL]         } [EOL]     } [EOL]     return _numberLong; [EOL] }
@Override [EOL] public long getLongValue() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_LONG) == 0) { [EOL]         if (_numTypesValid == NR_UNKNOWN) { [EOL]             _parseNumericValue(NR_LONG); [EOL]         } [EOL]         if ((_numTypesValid & NR_LONG) == 0) { [EOL]             convertNumberToLong(); [EOL]         } [EOL]     } [EOL]     return _numberLong; [EOL] }
@Override [EOL] public BigInteger getBigIntegerValue() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_BIGINT) == 0) { [EOL]         if (_numTypesValid == NR_UNKNOWN) { [EOL]             _parseNumericValue(NR_BIGINT); [EOL]         } [EOL]         if ((_numTypesValid & NR_BIGINT) == 0) { [EOL]             convertNumberToBigInteger(); [EOL]         } [EOL]     } [EOL]     return _numberBigInt; [EOL] }
@Override [EOL] public BigInteger getBigIntegerValue() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_BIGINT) == 0) { [EOL]         if (_numTypesValid == NR_UNKNOWN) { [EOL]             _parseNumericValue(NR_BIGINT); [EOL]         } [EOL]         if ((_numTypesValid & NR_BIGINT) == 0) { [EOL]             convertNumberToBigInteger(); [EOL]         } [EOL]     } [EOL]     return _numberBigInt; [EOL] }
@Override [EOL] public BigInteger getBigIntegerValue() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_BIGINT) == 0) { [EOL]         if (_numTypesValid == NR_UNKNOWN) { [EOL]             _parseNumericValue(NR_BIGINT); [EOL]         } [EOL]         if ((_numTypesValid & NR_BIGINT) == 0) { [EOL]             convertNumberToBigInteger(); [EOL]         } [EOL]     } [EOL]     return _numberBigInt; [EOL] }
@Override [EOL] public double getDoubleValue() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_DOUBLE) == 0) { [EOL]         if (_numTypesValid == NR_UNKNOWN) { [EOL]             _parseNumericValue(NR_DOUBLE); [EOL]         } [EOL]         if ((_numTypesValid & NR_DOUBLE) == 0) { [EOL]             convertNumberToDouble(); [EOL]         } [EOL]     } [EOL]     return _numberDouble; [EOL] }
@Override [EOL] public BigDecimal getDecimalValue() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) == 0) { [EOL]         if (_numTypesValid == NR_UNKNOWN) { [EOL]             _parseNumericValue(NR_BIGDECIMAL); [EOL]         } [EOL]         if ((_numTypesValid & NR_BIGDECIMAL) == 0) { [EOL]             convertNumberToBigDecimal(); [EOL]         } [EOL]     } [EOL]     return _numberBigDecimal; [EOL] }
@Override [EOL] public BigDecimal getDecimalValue() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) == 0) { [EOL]         if (_numTypesValid == NR_UNKNOWN) { [EOL]             _parseNumericValue(NR_BIGDECIMAL); [EOL]         } [EOL]         if ((_numTypesValid & NR_BIGDECIMAL) == 0) { [EOL]             convertNumberToBigDecimal(); [EOL]         } [EOL]     } [EOL]     return _numberBigDecimal; [EOL] }
@Override [EOL] public BigDecimal getDecimalValue() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) == 0) { [EOL]         if (_numTypesValid == NR_UNKNOWN) { [EOL]             _parseNumericValue(NR_BIGDECIMAL); [EOL]         } [EOL]         if ((_numTypesValid & NR_BIGDECIMAL) == 0) { [EOL]             convertNumberToBigDecimal(); [EOL]         } [EOL]     } [EOL]     return _numberBigDecimal; [EOL] }
protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] }
protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] }
protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] }
protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] }
protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] }
protected void _parseNumericValue(int expType) throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_INT) { [EOL]         char[] buf = _textBuffer.getTextBuffer(); [EOL]         int offset = _textBuffer.getTextOffset(); [EOL]         int len = _intLength; [EOL]         if (_numberNegative) { [EOL]             ++offset; [EOL]         } [EOL]         if (len <= 9) { [EOL]             int i = NumberInput.parseInt(buf, offset, len); [EOL]             _numberInt = _numberNegative ? -i : i; [EOL]             _numTypesValid = NR_INT; [EOL]             return; [EOL]         } [EOL]         if (len <= 18) { [EOL]             long l = NumberInput.parseLong(buf, offset, len); [EOL]             if (_numberNegative) { [EOL]                 l = -l; [EOL]             } [EOL]             if (len == 10) { [EOL]                 if (_numberNegative) { [EOL]                     if (l >= MIN_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } else { [EOL]                     if (l <= MAX_INT_L) { [EOL]                         _numberInt = (int) l; [EOL]                         _numTypesValid = NR_INT; [EOL]                         return; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             _numberLong = l; [EOL]             _numTypesValid = NR_LONG; [EOL]             return; [EOL]         } [EOL]         _parseSlowIntValue(expType, buf, offset, len); [EOL]         return; [EOL]     } [EOL]     if (_currToken == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         _parseSlowFloatValue(expType); [EOL]         return; [EOL]     } [EOL]     _reportError("Current token (" + _currToken + ") not numeric, can not use numeric value accessors"); [EOL] }
private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException { [EOL]     try { [EOL]         if (expType == NR_BIGDECIMAL) { [EOL]             _numberBigDecimal = _textBuffer.contentsAsDecimal(); [EOL]             _numTypesValid = NR_BIGDECIMAL; [EOL]         } else { [EOL]             _numberDouble = _textBuffer.contentsAsDouble(); [EOL]             _numTypesValid = NR_DOUBLE; [EOL]         } [EOL]     } catch (NumberFormatException nex) { [EOL]         _wrapError("Malformed numeric value '" + _textBuffer.contentsAsString() + "'", nex); [EOL]     } [EOL] }
private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException { [EOL]     try { [EOL]         if (expType == NR_BIGDECIMAL) { [EOL]             _numberBigDecimal = _textBuffer.contentsAsDecimal(); [EOL]             _numTypesValid = NR_BIGDECIMAL; [EOL]         } else { [EOL]             _numberDouble = _textBuffer.contentsAsDouble(); [EOL]             _numTypesValid = NR_DOUBLE; [EOL]         } [EOL]     } catch (NumberFormatException nex) { [EOL]         _wrapError("Malformed numeric value '" + _textBuffer.contentsAsString() + "'", nex); [EOL]     } [EOL] }
private void _parseSlowFloatValue(int expType) throws IOException, JsonParseException { [EOL]     try { [EOL]         if (expType == NR_BIGDECIMAL) { [EOL]             _numberBigDecimal = _textBuffer.contentsAsDecimal(); [EOL]             _numTypesValid = NR_BIGDECIMAL; [EOL]         } else { [EOL]             _numberDouble = _textBuffer.contentsAsDouble(); [EOL]             _numTypesValid = NR_DOUBLE; [EOL]         } [EOL]     } catch (NumberFormatException nex) { [EOL]         _wrapError("Malformed numeric value '" + _textBuffer.contentsAsString() + "'", nex); [EOL]     } [EOL] }
private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException { [EOL]     String numStr = _textBuffer.contentsAsString(); [EOL]     try { [EOL]         if (NumberInput.inLongRange(buf, offset, len, _numberNegative)) { [EOL]             _numberLong = Long.parseLong(numStr); [EOL]             _numTypesValid = NR_LONG; [EOL]         } else { [EOL]             _numberBigInt = new BigInteger(numStr); [EOL]             _numTypesValid = NR_BIGINT; [EOL]         } [EOL]     } catch (NumberFormatException nex) { [EOL]         _wrapError("Malformed numeric value '" + numStr + "'", nex); [EOL]     } [EOL] }
private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException { [EOL]     String numStr = _textBuffer.contentsAsString(); [EOL]     try { [EOL]         if (NumberInput.inLongRange(buf, offset, len, _numberNegative)) { [EOL]             _numberLong = Long.parseLong(numStr); [EOL]             _numTypesValid = NR_LONG; [EOL]         } else { [EOL]             _numberBigInt = new BigInteger(numStr); [EOL]             _numTypesValid = NR_BIGINT; [EOL]         } [EOL]     } catch (NumberFormatException nex) { [EOL]         _wrapError("Malformed numeric value '" + numStr + "'", nex); [EOL]     } [EOL] }
private void _parseSlowIntValue(int expType, char[] buf, int offset, int len) throws IOException, JsonParseException { [EOL]     String numStr = _textBuffer.contentsAsString(); [EOL]     try { [EOL]         if (NumberInput.inLongRange(buf, offset, len, _numberNegative)) { [EOL]             _numberLong = Long.parseLong(numStr); [EOL]             _numTypesValid = NR_LONG; [EOL]         } else { [EOL]             _numberBigInt = new BigInteger(numStr); [EOL]             _numTypesValid = NR_BIGINT; [EOL]         } [EOL]     } catch (NumberFormatException nex) { [EOL]         _wrapError("Malformed numeric value '" + numStr + "'", nex); [EOL]     } [EOL] }
protected void convertNumberToLong() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_INT) != 0) { [EOL]         _numberLong = (long) _numberInt; [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         if (BI_MIN_LONG.compareTo(_numberBigInt) > 0 || BI_MAX_LONG.compareTo(_numberBigInt) < 0) { [EOL]             reportOverflowLong(); [EOL]         } [EOL]         _numberLong = _numberBigInt.longValue(); [EOL]     } else if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         if (_numberDouble < MIN_LONG_D || _numberDouble > MAX_LONG_D) { [EOL]             reportOverflowLong(); [EOL]         } [EOL]         _numberLong = (long) _numberDouble; [EOL]     } else if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         if (BD_MIN_LONG.compareTo(_numberBigDecimal) > 0 || BD_MAX_LONG.compareTo(_numberBigDecimal) < 0) { [EOL]             reportOverflowLong(); [EOL]         } [EOL]         _numberLong = _numberBigDecimal.longValue(); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_LONG; [EOL] }
protected void convertNumberToDouble() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         _numberDouble = _numberBigDecimal.doubleValue(); [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         _numberDouble = _numberBigInt.doubleValue(); [EOL]     } else if ((_numTypesValid & NR_LONG) != 0) { [EOL]         _numberDouble = (double) _numberLong; [EOL]     } else if ((_numTypesValid & NR_INT) != 0) { [EOL]         _numberDouble = (double) _numberInt; [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_DOUBLE; [EOL] }
protected void convertNumberToDouble() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         _numberDouble = _numberBigDecimal.doubleValue(); [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         _numberDouble = _numberBigInt.doubleValue(); [EOL]     } else if ((_numTypesValid & NR_LONG) != 0) { [EOL]         _numberDouble = (double) _numberLong; [EOL]     } else if ((_numTypesValid & NR_INT) != 0) { [EOL]         _numberDouble = (double) _numberInt; [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_DOUBLE; [EOL] }
protected void convertNumberToDouble() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         _numberDouble = _numberBigDecimal.doubleValue(); [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         _numberDouble = _numberBigInt.doubleValue(); [EOL]     } else if ((_numTypesValid & NR_LONG) != 0) { [EOL]         _numberDouble = (double) _numberLong; [EOL]     } else if ((_numTypesValid & NR_INT) != 0) { [EOL]         _numberDouble = (double) _numberInt; [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_DOUBLE; [EOL] }
protected void convertNumberToDouble() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         _numberDouble = _numberBigDecimal.doubleValue(); [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         _numberDouble = _numberBigInt.doubleValue(); [EOL]     } else if ((_numTypesValid & NR_LONG) != 0) { [EOL]         _numberDouble = (double) _numberLong; [EOL]     } else if ((_numTypesValid & NR_INT) != 0) { [EOL]         _numberDouble = (double) _numberInt; [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_DOUBLE; [EOL] }
protected void convertNumberToDouble() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_BIGDECIMAL) != 0) { [EOL]         _numberDouble = _numberBigDecimal.doubleValue(); [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         _numberDouble = _numberBigInt.doubleValue(); [EOL]     } else if ((_numTypesValid & NR_LONG) != 0) { [EOL]         _numberDouble = (double) _numberLong; [EOL]     } else if ((_numTypesValid & NR_INT) != 0) { [EOL]         _numberDouble = (double) _numberInt; [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_DOUBLE; [EOL] }
protected void convertNumberToBigDecimal() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         _numberBigDecimal = NumberInput.parseBigDecimal(getText()); [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         _numberBigDecimal = new BigDecimal(_numberBigInt); [EOL]     } else if ((_numTypesValid & NR_LONG) != 0) { [EOL]         _numberBigDecimal = BigDecimal.valueOf(_numberLong); [EOL]     } else if ((_numTypesValid & NR_INT) != 0) { [EOL]         _numberBigDecimal = BigDecimal.valueOf(_numberInt); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_BIGDECIMAL; [EOL] }
protected void convertNumberToBigDecimal() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         _numberBigDecimal = NumberInput.parseBigDecimal(getText()); [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         _numberBigDecimal = new BigDecimal(_numberBigInt); [EOL]     } else if ((_numTypesValid & NR_LONG) != 0) { [EOL]         _numberBigDecimal = BigDecimal.valueOf(_numberLong); [EOL]     } else if ((_numTypesValid & NR_INT) != 0) { [EOL]         _numberBigDecimal = BigDecimal.valueOf(_numberInt); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_BIGDECIMAL; [EOL] }
protected void convertNumberToBigDecimal() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         _numberBigDecimal = NumberInput.parseBigDecimal(getText()); [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         _numberBigDecimal = new BigDecimal(_numberBigInt); [EOL]     } else if ((_numTypesValid & NR_LONG) != 0) { [EOL]         _numberBigDecimal = BigDecimal.valueOf(_numberLong); [EOL]     } else if ((_numTypesValid & NR_INT) != 0) { [EOL]         _numberBigDecimal = BigDecimal.valueOf(_numberInt); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_BIGDECIMAL; [EOL] }
protected void convertNumberToBigDecimal() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         _numberBigDecimal = NumberInput.parseBigDecimal(getText()); [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         _numberBigDecimal = new BigDecimal(_numberBigInt); [EOL]     } else if ((_numTypesValid & NR_LONG) != 0) { [EOL]         _numberBigDecimal = BigDecimal.valueOf(_numberLong); [EOL]     } else if ((_numTypesValid & NR_INT) != 0) { [EOL]         _numberBigDecimal = BigDecimal.valueOf(_numberInt); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_BIGDECIMAL; [EOL] }
protected void convertNumberToBigDecimal() throws IOException, JsonParseException { [EOL]     if ((_numTypesValid & NR_DOUBLE) != 0) { [EOL]         _numberBigDecimal = NumberInput.parseBigDecimal(getText()); [EOL]     } else if ((_numTypesValid & NR_BIGINT) != 0) { [EOL]         _numberBigDecimal = new BigDecimal(_numberBigInt); [EOL]     } else if ((_numTypesValid & NR_LONG) != 0) { [EOL]         _numberBigDecimal = BigDecimal.valueOf(_numberLong); [EOL]     } else if ((_numTypesValid & NR_INT) != 0) { [EOL]         _numberBigDecimal = BigDecimal.valueOf(_numberInt); [EOL]     } else { [EOL]         _throwInternal(); [EOL]     } [EOL]     _numTypesValid |= NR_BIGDECIMAL; [EOL] }
protected final int _decodeBase64Escape(Base64Variant b64variant, int ch, int index) throws IOException, JsonParseException { [EOL]     if (ch != '\\') { [EOL]         throw reportInvalidBase64Char(b64variant, ch, index); [EOL]     } [EOL]     int unescaped = _decodeEscaped(); [EOL]     if (unescaped <= INT_SPACE) { [EOL]         if (index == 0) { [EOL]             return -1; [EOL]         } [EOL]     } [EOL]     int bits = b64variant.decodeBase64Char(unescaped); [EOL]     if (bits < 0) { [EOL]         throw reportInvalidBase64Char(b64variant, unescaped, index); [EOL]     } [EOL]     return bits; [EOL] }
protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException { [EOL]     if (ch != '\\') { [EOL]         throw reportInvalidBase64Char(b64variant, ch, index); [EOL]     } [EOL]     char unescaped = _decodeEscaped(); [EOL]     if (unescaped <= INT_SPACE) { [EOL]         if (index == 0) { [EOL]             return -1; [EOL]         } [EOL]     } [EOL]     int bits = b64variant.decodeBase64Char(unescaped); [EOL]     if (bits < 0) { [EOL]         throw reportInvalidBase64Char(b64variant, unescaped, index); [EOL]     } [EOL]     return bits; [EOL] }
protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException { [EOL]     if (ch != '\\') { [EOL]         throw reportInvalidBase64Char(b64variant, ch, index); [EOL]     } [EOL]     char unescaped = _decodeEscaped(); [EOL]     if (unescaped <= INT_SPACE) { [EOL]         if (index == 0) { [EOL]             return -1; [EOL]         } [EOL]     } [EOL]     int bits = b64variant.decodeBase64Char(unescaped); [EOL]     if (bits < 0) { [EOL]         throw reportInvalidBase64Char(b64variant, unescaped, index); [EOL]     } [EOL]     return bits; [EOL] }
protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException { [EOL]     if (ch != '\\') { [EOL]         throw reportInvalidBase64Char(b64variant, ch, index); [EOL]     } [EOL]     char unescaped = _decodeEscaped(); [EOL]     if (unescaped <= INT_SPACE) { [EOL]         if (index == 0) { [EOL]             return -1; [EOL]         } [EOL]     } [EOL]     int bits = b64variant.decodeBase64Char(unescaped); [EOL]     if (bits < 0) { [EOL]         throw reportInvalidBase64Char(b64variant, unescaped, index); [EOL]     } [EOL]     return bits; [EOL] }
protected final int _decodeBase64Escape(Base64Variant b64variant, char ch, int index) throws IOException, JsonParseException { [EOL]     if (ch != '\\') { [EOL]         throw reportInvalidBase64Char(b64variant, ch, index); [EOL]     } [EOL]     char unescaped = _decodeEscaped(); [EOL]     if (unescaped <= INT_SPACE) { [EOL]         if (index == 0) { [EOL]             return -1; [EOL]         } [EOL]     } [EOL]     int bits = b64variant.decodeBase64Char(unescaped); [EOL]     if (bits < 0) { [EOL]         throw reportInvalidBase64Char(b64variant, unescaped, index); [EOL]     } [EOL]     return bits; [EOL] }
private BytesToNameCanonicalizer(int hashSize, boolean intern, int seed) { [EOL]     _parent = null; [EOL]     _hashSeed = seed; [EOL]     _intern = intern; [EOL]     if (hashSize < MIN_HASH_SIZE) { [EOL]         hashSize = MIN_HASH_SIZE; [EOL]     } else { [EOL]         if ((hashSize & (hashSize - 1)) != 0) { [EOL]             int curr = MIN_HASH_SIZE; [EOL]             while (curr < hashSize) { [EOL]                 curr += curr; [EOL]             } [EOL]             hashSize = curr; [EOL]         } [EOL]     } [EOL]     _tableInfo = new AtomicReference<TableInfo>(initTableInfo(hashSize)); [EOL] }
private BytesToNameCanonicalizer(BytesToNameCanonicalizer parent, boolean intern, int seed, TableInfo state) { [EOL]     _parent = parent; [EOL]     _hashSeed = seed; [EOL]     _intern = intern; [EOL]     _tableInfo = null; [EOL]     _count = state.count; [EOL]     _mainHashMask = state.mainHashMask; [EOL]     _mainHash = state.mainHash; [EOL]     _mainNames = state.mainNames; [EOL]     _collList = state.collList; [EOL]     _collCount = state.collCount; [EOL]     _collEnd = state.collEnd; [EOL]     _longestCollisionList = state.longestCollisionList; [EOL]     _needRehash = false; [EOL]     _mainHashShared = true; [EOL]     _mainNamesShared = true; [EOL]     _collListShared = true; [EOL] }
private TableInfo initTableInfo(int hashSize) { [EOL]     return new TableInfo(0, hashSize - 1, new int[hashSize], new Name[hashSize], null, 0, 0, 0); [EOL] }
private TableInfo initTableInfo(int hashSize) { [EOL]     return new TableInfo(0, hashSize - 1, new int[hashSize], new Name[hashSize], null, 0, 0, 0); [EOL] }
public static BytesToNameCanonicalizer createRoot() { [EOL]     long now = System.currentTimeMillis(); [EOL]     int seed = (((int) now) + ((int) (now >>> 32))) | 1; [EOL]     return createRoot(seed); [EOL] }
protected static BytesToNameCanonicalizer createRoot(int hashSeed) { [EOL]     return new BytesToNameCanonicalizer(DEFAULT_TABLE_SIZE, true, hashSeed); [EOL] }
public BytesToNameCanonicalizer makeChild(boolean canonicalize, boolean intern) { [EOL]     return new BytesToNameCanonicalizer(this, intern, _hashSeed, _tableInfo.get()); [EOL] }
public BytesToNameCanonicalizer makeChild(boolean canonicalize, boolean intern) { [EOL]     return new BytesToNameCanonicalizer(this, intern, _hashSeed, _tableInfo.get()); [EOL] }
public void release() { [EOL]     if (_parent != null && maybeDirty()) { [EOL]         _parent.mergeChild(new TableInfo(this)); [EOL]         _mainHashShared = true; [EOL]         _mainNamesShared = true; [EOL]         _collListShared = true; [EOL]     } [EOL] }
public void release() { [EOL]     if (_parent != null && maybeDirty()) { [EOL]         _parent.mergeChild(new TableInfo(this)); [EOL]         _mainHashShared = true; [EOL]         _mainNamesShared = true; [EOL]         _collListShared = true; [EOL]     } [EOL] }
public void release() { [EOL]     if (_parent != null && maybeDirty()) { [EOL]         _parent.mergeChild(new TableInfo(this)); [EOL]         _mainHashShared = true; [EOL]         _mainNamesShared = true; [EOL]         _collListShared = true; [EOL]     } [EOL] }
private void mergeChild(TableInfo childState) { [EOL]     final int childCount = childState.count; [EOL]     TableInfo currState = _tableInfo.get(); [EOL]     if (childCount <= currState.count) { [EOL]         return; [EOL]     } [EOL]     if (childCount > MAX_ENTRIES_FOR_REUSE || childState.longestCollisionList > MAX_COLL_CHAIN_FOR_REUSE) { [EOL]         childState = initTableInfo(DEFAULT_TABLE_SIZE); [EOL]     } [EOL]     _tableInfo.compareAndSet(currState, childState); [EOL] }
private void mergeChild(TableInfo childState) { [EOL]     final int childCount = childState.count; [EOL]     TableInfo currState = _tableInfo.get(); [EOL]     if (childCount <= currState.count) { [EOL]         return; [EOL]     } [EOL]     if (childCount > MAX_ENTRIES_FOR_REUSE || childState.longestCollisionList > MAX_COLL_CHAIN_FOR_REUSE) { [EOL]         childState = initTableInfo(DEFAULT_TABLE_SIZE); [EOL]     } [EOL]     _tableInfo.compareAndSet(currState, childState); [EOL] }
private void mergeChild(TableInfo childState) { [EOL]     final int childCount = childState.count; [EOL]     TableInfo currState = _tableInfo.get(); [EOL]     if (childCount <= currState.count) { [EOL]         return; [EOL]     } [EOL]     if (childCount > MAX_ENTRIES_FOR_REUSE || childState.longestCollisionList > MAX_COLL_CHAIN_FOR_REUSE) { [EOL]         childState = initTableInfo(DEFAULT_TABLE_SIZE); [EOL]     } [EOL]     _tableInfo.compareAndSet(currState, childState); [EOL] }
private void mergeChild(TableInfo childState) { [EOL]     final int childCount = childState.count; [EOL]     TableInfo currState = _tableInfo.get(); [EOL]     if (childCount <= currState.count) { [EOL]         return; [EOL]     } [EOL]     if (childCount > MAX_ENTRIES_FOR_REUSE || childState.longestCollisionList > MAX_COLL_CHAIN_FOR_REUSE) { [EOL]         childState = initTableInfo(DEFAULT_TABLE_SIZE); [EOL]     } [EOL]     _tableInfo.compareAndSet(currState, childState); [EOL] }
public boolean maybeDirty() { [EOL]     return !_mainHashShared; [EOL] }
public boolean maybeDirty() { [EOL]     return !_mainHashShared; [EOL] }
public static Name getEmptyName() { [EOL]     return Name1.getEmptyName(); [EOL] }
public Name findName(int firstQuad) { [EOL]     int hash = calcHash(firstQuad); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null) { [EOL]             return null; [EOL]         } [EOL]         if (name.equals(firstQuad)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, firstQuad, 0); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name findName(int firstQuad) { [EOL]     int hash = calcHash(firstQuad); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null) { [EOL]             return null; [EOL]         } [EOL]         if (name.equals(firstQuad)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, firstQuad, 0); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name findName(int firstQuad) { [EOL]     int hash = calcHash(firstQuad); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null) { [EOL]             return null; [EOL]         } [EOL]         if (name.equals(firstQuad)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, firstQuad, 0); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name findName(int firstQuad) { [EOL]     int hash = calcHash(firstQuad); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null) { [EOL]             return null; [EOL]         } [EOL]         if (name.equals(firstQuad)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, firstQuad, 0); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name findName(int firstQuad, int secondQuad) { [EOL]     int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null) { [EOL]             return null; [EOL]         } [EOL]         if (name.equals(firstQuad, secondQuad)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, firstQuad, secondQuad); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name findName(int firstQuad, int secondQuad) { [EOL]     int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null) { [EOL]             return null; [EOL]         } [EOL]         if (name.equals(firstQuad, secondQuad)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, firstQuad, secondQuad); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name findName(int firstQuad, int secondQuad) { [EOL]     int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null) { [EOL]             return null; [EOL]         } [EOL]         if (name.equals(firstQuad, secondQuad)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, firstQuad, secondQuad); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name findName(int firstQuad, int secondQuad) { [EOL]     int hash = (secondQuad == 0) ? calcHash(firstQuad) : calcHash(firstQuad, secondQuad); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null) { [EOL]             return null; [EOL]         } [EOL]         if (name.equals(firstQuad, secondQuad)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, firstQuad, secondQuad); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name findName(int[] quads, int qlen) { [EOL]     if (qlen < 3) { [EOL]         return findName(quads[0], (qlen < 2) ? 0 : quads[1]); [EOL]     } [EOL]     int hash = calcHash(quads, qlen); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null || name.equals(quads, qlen)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, quads, qlen); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name findName(int[] quads, int qlen) { [EOL]     if (qlen < 3) { [EOL]         return findName(quads[0], (qlen < 2) ? 0 : quads[1]); [EOL]     } [EOL]     int hash = calcHash(quads, qlen); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null || name.equals(quads, qlen)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, quads, qlen); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name findName(int[] quads, int qlen) { [EOL]     if (qlen < 3) { [EOL]         return findName(quads[0], (qlen < 2) ? 0 : quads[1]); [EOL]     } [EOL]     int hash = calcHash(quads, qlen); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null || name.equals(quads, qlen)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, quads, qlen); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name findName(int[] quads, int qlen) { [EOL]     if (qlen < 3) { [EOL]         return findName(quads[0], (qlen < 2) ? 0 : quads[1]); [EOL]     } [EOL]     int hash = calcHash(quads, qlen); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null || name.equals(quads, qlen)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, quads, qlen); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name findName(int[] quads, int qlen) { [EOL]     if (qlen < 3) { [EOL]         return findName(quads[0], (qlen < 2) ? 0 : quads[1]); [EOL]     } [EOL]     int hash = calcHash(quads, qlen); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null || name.equals(quads, qlen)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, quads, qlen); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name findName(int[] quads, int qlen) { [EOL]     if (qlen < 3) { [EOL]         return findName(quads[0], (qlen < 2) ? 0 : quads[1]); [EOL]     } [EOL]     int hash = calcHash(quads, qlen); [EOL]     int ix = (hash & _mainHashMask); [EOL]     int val = _mainHash[ix]; [EOL]     if ((((val >> 8) ^ hash) << 8) == 0) { [EOL]         Name name = _mainNames[ix]; [EOL]         if (name == null || name.equals(quads, qlen)) { [EOL]             return name; [EOL]         } [EOL]     } else if (val == 0) { [EOL]         return null; [EOL]     } [EOL]     val &= 0xFF; [EOL]     if (val > 0) { [EOL]         val -= 1; [EOL]         Bucket bucket = _collList[val]; [EOL]         if (bucket != null) { [EOL]             return bucket.find(hash, quads, qlen); [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
public Name addName(String symbolStr, int[] quads, int qlen) { [EOL]     if (_intern) { [EOL]         symbolStr = InternCache.instance.intern(symbolStr); [EOL]     } [EOL]     int hash; [EOL]     if (qlen < 3) { [EOL]         hash = (qlen == 1) ? calcHash(quads[0]) : calcHash(quads[0], quads[1]); [EOL]     } else { [EOL]         hash = calcHash(quads, qlen); [EOL]     } [EOL]     Name symbol = constructName(hash, symbolStr, quads, qlen); [EOL]     _addSymbol(hash, symbol); [EOL]     return symbol; [EOL] }
public Name addName(String symbolStr, int[] quads, int qlen) { [EOL]     if (_intern) { [EOL]         symbolStr = InternCache.instance.intern(symbolStr); [EOL]     } [EOL]     int hash; [EOL]     if (qlen < 3) { [EOL]         hash = (qlen == 1) ? calcHash(quads[0]) : calcHash(quads[0], quads[1]); [EOL]     } else { [EOL]         hash = calcHash(quads, qlen); [EOL]     } [EOL]     Name symbol = constructName(hash, symbolStr, quads, qlen); [EOL]     _addSymbol(hash, symbol); [EOL]     return symbol; [EOL] }
public Name addName(String symbolStr, int[] quads, int qlen) { [EOL]     if (_intern) { [EOL]         symbolStr = InternCache.instance.intern(symbolStr); [EOL]     } [EOL]     int hash; [EOL]     if (qlen < 3) { [EOL]         hash = (qlen == 1) ? calcHash(quads[0]) : calcHash(quads[0], quads[1]); [EOL]     } else { [EOL]         hash = calcHash(quads, qlen); [EOL]     } [EOL]     Name symbol = constructName(hash, symbolStr, quads, qlen); [EOL]     _addSymbol(hash, symbol); [EOL]     return symbol; [EOL] }
public int calcHash(int firstQuad) { [EOL]     int hash = firstQuad ^ _hashSeed; [EOL]     hash += (hash >>> 15); [EOL]     hash ^= (hash >>> 9); [EOL]     return hash; [EOL] }
public int calcHash(int firstQuad) { [EOL]     int hash = firstQuad ^ _hashSeed; [EOL]     hash += (hash >>> 15); [EOL]     hash ^= (hash >>> 9); [EOL]     return hash; [EOL] }
public int calcHash(int firstQuad) { [EOL]     int hash = firstQuad ^ _hashSeed; [EOL]     hash += (hash >>> 15); [EOL]     hash ^= (hash >>> 9); [EOL]     return hash; [EOL] }
private void _addSymbol(int hash, Name symbol) { [EOL]     if (_mainHashShared) { [EOL]         unshareMain(); [EOL]     } [EOL]     if (_needRehash) { [EOL]         rehash(); [EOL]     } [EOL]     ++_count; [EOL]     int ix = (hash & _mainHashMask); [EOL]     if (_mainNames[ix] == null) { [EOL]         _mainHash[ix] = (hash << 8); [EOL]         if (_mainNamesShared) { [EOL]             unshareNames(); [EOL]         } [EOL]         _mainNames[ix] = symbol; [EOL]     } else { [EOL]         if (_collListShared) { [EOL]             unshareCollision(); [EOL]         } [EOL]         ++_collCount; [EOL]         int entryValue = _mainHash[ix]; [EOL]         int bucket = entryValue & 0xFF; [EOL]         if (bucket == 0) { [EOL]             if (_collEnd <= LAST_VALID_BUCKET) { [EOL]                 bucket = _collEnd; [EOL]                 ++_collEnd; [EOL]                 if (bucket >= _collList.length) { [EOL]                     expandCollision(); [EOL]                 } [EOL]             } else { [EOL]                 bucket = findBestBucket(); [EOL]             } [EOL]             _mainHash[ix] = (entryValue & ~0xFF) | (bucket + 1); [EOL]         } else { [EOL]             --bucket; [EOL]         } [EOL]         Bucket newB = new Bucket(symbol, _collList[bucket]); [EOL]         _collList[bucket] = newB; [EOL]         _longestCollisionList = Math.max(newB.length(), _longestCollisionList); [EOL]         if (_longestCollisionList > MAX_COLL_CHAIN_LENGTH) { [EOL]             reportTooManyCollisions(MAX_COLL_CHAIN_LENGTH); [EOL]         } [EOL]     } [EOL]     { [EOL]         int hashSize = _mainHash.length; [EOL]         if (_count > (hashSize >> 1)) { [EOL]             int hashQuarter = (hashSize >> 2); [EOL]             if (_count > (hashSize - hashQuarter)) { [EOL]                 _needRehash = true; [EOL]             } else if (_collCount >= hashQuarter) { [EOL]                 _needRehash = true; [EOL]             } [EOL]         } [EOL]     } [EOL] }
private void rehash() { [EOL]     _needRehash = false; [EOL]     _mainNamesShared = false; [EOL]     int[] oldMainHash = _mainHash; [EOL]     int len = oldMainHash.length; [EOL]     int newLen = len + len; [EOL]     if (newLen > MAX_TABLE_SIZE) { [EOL]         nukeSymbols(); [EOL]         return; [EOL]     } [EOL]     _mainHash = new int[newLen]; [EOL]     _mainHashMask = (newLen - 1); [EOL]     Name[] oldNames = _mainNames; [EOL]     _mainNames = new Name[newLen]; [EOL]     int symbolsSeen = 0; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Name symbol = oldNames[i]; [EOL]         if (symbol != null) { [EOL]             ++symbolsSeen; [EOL]             int hash = symbol.hashCode(); [EOL]             int ix = (hash & _mainHashMask); [EOL]             _mainNames[ix] = symbol; [EOL]             _mainHash[ix] = hash << 8; [EOL]         } [EOL]     } [EOL]     int oldEnd = _collEnd; [EOL]     if (oldEnd == 0) { [EOL]         _longestCollisionList = 0; [EOL]         return; [EOL]     } [EOL]     _collCount = 0; [EOL]     _collEnd = 0; [EOL]     _collListShared = false; [EOL]     int maxColl = 0; [EOL]     Bucket[] oldBuckets = _collList; [EOL]     _collList = new Bucket[oldBuckets.length]; [EOL]     for (int i = 0; i < oldEnd; ++i) { [EOL]         for (Bucket curr = oldBuckets[i]; curr != null; curr = curr._next) { [EOL]             ++symbolsSeen; [EOL]             Name symbol = curr._name; [EOL]             int hash = symbol.hashCode(); [EOL]             int ix = (hash & _mainHashMask); [EOL]             int val = _mainHash[ix]; [EOL]             if (_mainNames[ix] == null) { [EOL]                 _mainHash[ix] = (hash << 8); [EOL]                 _mainNames[ix] = symbol; [EOL]             } else { [EOL]                 ++_collCount; [EOL]                 int bucket = val & 0xFF; [EOL]                 if (bucket == 0) { [EOL]                     if (_collEnd <= LAST_VALID_BUCKET) { [EOL]                         bucket = _collEnd; [EOL]                         ++_collEnd; [EOL]                         if (bucket >= _collList.length) { [EOL]                             expandCollision(); [EOL]                         } [EOL]                     } else { [EOL]                         bucket = findBestBucket(); [EOL]                     } [EOL]                     _mainHash[ix] = (val & ~0xFF) | (bucket + 1); [EOL]                 } else { [EOL]                     --bucket; [EOL]                 } [EOL]                 Bucket newB = new Bucket(symbol, _collList[bucket]); [EOL]                 _collList[bucket] = newB; [EOL]                 maxColl = Math.max(maxColl, newB.length()); [EOL]             } [EOL]         } [EOL]     } [EOL]     _longestCollisionList = maxColl; [EOL]     if (symbolsSeen != _count) { [EOL]         throw new RuntimeException("Internal error: count after rehash " + symbolsSeen + "; should be " + _count); [EOL]     } [EOL] }
private void unshareMain() { [EOL]     final int[] old = _mainHash; [EOL]     _mainHash = Arrays.copyOf(old, old.length); [EOL]     _mainHashShared = false; [EOL] }
private void unshareNames() { [EOL]     final Name[] old = _mainNames; [EOL]     _mainNames = Arrays.copyOf(old, old.length); [EOL]     _mainNamesShared = false; [EOL] }
private static Name constructName(int hash, String name, int[] quads, int qlen) { [EOL]     if (qlen < 4) { [EOL]         switch(qlen) { [EOL]             case 1: [EOL]                 return new Name1(name, hash, quads[0]); [EOL]             case 2: [EOL]                 return new Name2(name, hash, quads[0], quads[1]); [EOL]             case 3: [EOL]                 return new Name3(name, hash, quads[0], quads[1], quads[2]); [EOL]             default: [EOL]         } [EOL]     } [EOL]     int[] buf = new int[qlen]; [EOL]     for (int i = 0; i < qlen; ++i) { [EOL]         buf[i] = quads[i]; [EOL]     } [EOL]     return new NameN(name, hash, buf, qlen); [EOL] }
private static Name constructName(int hash, String name, int[] quads, int qlen) { [EOL]     if (qlen < 4) { [EOL]         switch(qlen) { [EOL]             case 1: [EOL]                 return new Name1(name, hash, quads[0]); [EOL]             case 2: [EOL]                 return new Name2(name, hash, quads[0], quads[1]); [EOL]             case 3: [EOL]                 return new Name3(name, hash, quads[0], quads[1], quads[2]); [EOL]             default: [EOL]         } [EOL]     } [EOL]     int[] buf = new int[qlen]; [EOL]     for (int i = 0; i < qlen; ++i) { [EOL]         buf[i] = quads[i]; [EOL]     } [EOL]     return new NameN(name, hash, buf, qlen); [EOL] }
private static Name constructName(int hash, String name, int[] quads, int qlen) { [EOL]     if (qlen < 4) { [EOL]         switch(qlen) { [EOL]             case 1: [EOL]                 return new Name1(name, hash, quads[0]); [EOL]             case 2: [EOL]                 return new Name2(name, hash, quads[0], quads[1]); [EOL]             case 3: [EOL]                 return new Name3(name, hash, quads[0], quads[1], quads[2]); [EOL]             default: [EOL]         } [EOL]     } [EOL]     int[] buf = new int[qlen]; [EOL]     for (int i = 0; i < qlen; ++i) { [EOL]         buf[i] = quads[i]; [EOL]     } [EOL]     return new NameN(name, hash, buf, qlen); [EOL] }
private static Name constructName(int hash, String name, int[] quads, int qlen) { [EOL]     if (qlen < 4) { [EOL]         switch(qlen) { [EOL]             case 1: [EOL]                 return new Name1(name, hash, quads[0]); [EOL]             case 2: [EOL]                 return new Name2(name, hash, quads[0], quads[1]); [EOL]             case 3: [EOL]                 return new Name3(name, hash, quads[0], quads[1], quads[2]); [EOL]             default: [EOL]         } [EOL]     } [EOL]     int[] buf = new int[qlen]; [EOL]     for (int i = 0; i < qlen; ++i) { [EOL]         buf[i] = quads[i]; [EOL]     } [EOL]     return new NameN(name, hash, buf, qlen); [EOL] }
public TableInfo(int count, int mainHashMask, int[] mainHash, Name[] mainNames, Bucket[] collList, int collCount, int collEnd, int longestCollisionList) { [EOL]     this.count = count; [EOL]     this.mainHashMask = mainHashMask; [EOL]     this.mainHash = mainHash; [EOL]     this.mainNames = mainNames; [EOL]     this.collList = collList; [EOL]     this.collCount = collCount; [EOL]     this.collEnd = collEnd; [EOL]     this.longestCollisionList = longestCollisionList; [EOL] }
public TableInfo(BytesToNameCanonicalizer src) { [EOL]     count = src._count; [EOL]     mainHashMask = src._mainHashMask; [EOL]     mainHash = src._mainHash; [EOL]     mainNames = src._mainNames; [EOL]     collList = src._collList; [EOL]     collCount = src._collCount; [EOL]     collEnd = src._collEnd; [EOL]     longestCollisionList = src._longestCollisionList; [EOL] }
public Std(InputStream in, byte[] buffer) { [EOL]     _in = in; [EOL]     _buffer = buffer; [EOL]     _bufferedStart = 0; [EOL]     _ptr = 0; [EOL]     _bufferedEnd = 0; [EOL] }
@Override [EOL] public boolean hasMoreBytes() throws IOException { [EOL]     if (_ptr < _bufferedEnd) { [EOL]         return true; [EOL]     } [EOL]     if (_in == null) { [EOL]         return false; [EOL]     } [EOL]     int amount = _buffer.length - _ptr; [EOL]     if (amount < 1) { [EOL]         return false; [EOL]     } [EOL]     int count = _in.read(_buffer, _ptr, amount); [EOL]     if (count <= 0) { [EOL]         return false; [EOL]     } [EOL]     _bufferedEnd += count; [EOL]     return true; [EOL] }
@Override [EOL] public boolean hasMoreBytes() throws IOException { [EOL]     if (_ptr < _bufferedEnd) { [EOL]         return true; [EOL]     } [EOL]     if (_in == null) { [EOL]         return false; [EOL]     } [EOL]     int amount = _buffer.length - _ptr; [EOL]     if (amount < 1) { [EOL]         return false; [EOL]     } [EOL]     int count = _in.read(_buffer, _ptr, amount); [EOL]     if (count <= 0) { [EOL]         return false; [EOL]     } [EOL]     _bufferedEnd += count; [EOL]     return true; [EOL] }
@Override [EOL] public boolean hasMoreBytes() throws IOException { [EOL]     if (_ptr < _bufferedEnd) { [EOL]         return true; [EOL]     } [EOL]     if (_in == null) { [EOL]         return false; [EOL]     } [EOL]     int amount = _buffer.length - _ptr; [EOL]     if (amount < 1) { [EOL]         return false; [EOL]     } [EOL]     int count = _in.read(_buffer, _ptr, amount); [EOL]     if (count <= 0) { [EOL]         return false; [EOL]     } [EOL]     _bufferedEnd += count; [EOL]     return true; [EOL] }
@Override [EOL] public boolean hasMoreBytes() throws IOException { [EOL]     if (_ptr < _bufferedEnd) { [EOL]         return true; [EOL]     } [EOL]     if (_in == null) { [EOL]         return false; [EOL]     } [EOL]     int amount = _buffer.length - _ptr; [EOL]     if (amount < 1) { [EOL]         return false; [EOL]     } [EOL]     int count = _in.read(_buffer, _ptr, amount); [EOL]     if (count <= 0) { [EOL]         return false; [EOL]     } [EOL]     _bufferedEnd += count; [EOL]     return true; [EOL] }
@Override [EOL] public boolean hasMoreBytes() throws IOException { [EOL]     if (_ptr < _bufferedEnd) { [EOL]         return true; [EOL]     } [EOL]     if (_in == null) { [EOL]         return false; [EOL]     } [EOL]     int amount = _buffer.length - _ptr; [EOL]     if (amount < 1) { [EOL]         return false; [EOL]     } [EOL]     int count = _in.read(_buffer, _ptr, amount); [EOL]     if (count <= 0) { [EOL]         return false; [EOL]     } [EOL]     _bufferedEnd += count; [EOL]     return true; [EOL] }
@Override [EOL] public byte nextByte() throws IOException { [EOL]     if (_ptr >= _bufferedEnd) { [EOL]         if (!hasMoreBytes()) { [EOL]             throw new EOFException("Failed auto-detect: could not read more than " + _ptr + " bytes (max buffer size: " + _buffer.length + ")"); [EOL]         } [EOL]     } [EOL]     return _buffer[_ptr++]; [EOL] }
@Override [EOL] public byte nextByte() throws IOException { [EOL]     if (_ptr >= _bufferedEnd) { [EOL]         if (!hasMoreBytes()) { [EOL]             throw new EOFException("Failed auto-detect: could not read more than " + _ptr + " bytes (max buffer size: " + _buffer.length + ")"); [EOL]         } [EOL]     } [EOL]     return _buffer[_ptr++]; [EOL] }
@Override [EOL] public byte nextByte() throws IOException { [EOL]     if (_ptr >= _bufferedEnd) { [EOL]         if (!hasMoreBytes()) { [EOL]             throw new EOFException("Failed auto-detect: could not read more than " + _ptr + " bytes (max buffer size: " + _buffer.length + ")"); [EOL]         } [EOL]     } [EOL]     return _buffer[_ptr++]; [EOL] }
@Override [EOL] public void reset() { [EOL]     _ptr = _bufferedStart; [EOL] }
public DataFormatMatcher createMatcher(JsonFactory match, MatchStrength matchStrength) { [EOL]     return new DataFormatMatcher(_in, _buffer, _bufferedStart, (_bufferedEnd - _bufferedStart), match, matchStrength); [EOL] }
public DataFormatMatcher createMatcher(JsonFactory match, MatchStrength matchStrength) { [EOL]     return new DataFormatMatcher(_in, _buffer, _bufferedStart, (_bufferedEnd - _bufferedStart), match, matchStrength); [EOL] }
public final byte[] allocByteBuffer(ByteBufferType type) { [EOL]     int ix = type.ordinal(); [EOL]     byte[] buffer = _byteBuffers[ix]; [EOL]     if (buffer == null) { [EOL]         buffer = balloc(type.size); [EOL]     } else { [EOL]         _byteBuffers[ix] = null; [EOL]     } [EOL]     return buffer; [EOL] }
public final byte[] allocByteBuffer(ByteBufferType type) { [EOL]     int ix = type.ordinal(); [EOL]     byte[] buffer = _byteBuffers[ix]; [EOL]     if (buffer == null) { [EOL]         buffer = balloc(type.size); [EOL]     } else { [EOL]         _byteBuffers[ix] = null; [EOL]     } [EOL]     return buffer; [EOL] }
public final void releaseByteBuffer(ByteBufferType type, byte[] buffer) { [EOL]     _byteBuffers[type.ordinal()] = buffer; [EOL] }
public final void releaseByteBuffer(ByteBufferType type, byte[] buffer) { [EOL]     _byteBuffers[type.ordinal()] = buffer; [EOL] }
public final char[] allocCharBuffer(CharBufferType type) { [EOL]     return allocCharBuffer(type, 0); [EOL] }
public final char[] allocCharBuffer(CharBufferType type) { [EOL]     return allocCharBuffer(type, 0); [EOL] }
public final char[] allocCharBuffer(CharBufferType type, int minSize) { [EOL]     if (type.size > minSize) { [EOL]         minSize = type.size; [EOL]     } [EOL]     int ix = type.ordinal(); [EOL]     char[] buffer = _charBuffers[ix]; [EOL]     if (buffer == null || buffer.length < minSize) { [EOL]         buffer = calloc(minSize); [EOL]     } else { [EOL]         _charBuffers[ix] = null; [EOL]     } [EOL]     return buffer; [EOL] }
public final char[] allocCharBuffer(CharBufferType type, int minSize) { [EOL]     if (type.size > minSize) { [EOL]         minSize = type.size; [EOL]     } [EOL]     int ix = type.ordinal(); [EOL]     char[] buffer = _charBuffers[ix]; [EOL]     if (buffer == null || buffer.length < minSize) { [EOL]         buffer = calloc(minSize); [EOL]     } else { [EOL]         _charBuffers[ix] = null; [EOL]     } [EOL]     return buffer; [EOL] }
public final char[] allocCharBuffer(CharBufferType type, int minSize) { [EOL]     if (type.size > minSize) { [EOL]         minSize = type.size; [EOL]     } [EOL]     int ix = type.ordinal(); [EOL]     char[] buffer = _charBuffers[ix]; [EOL]     if (buffer == null || buffer.length < minSize) { [EOL]         buffer = calloc(minSize); [EOL]     } else { [EOL]         _charBuffers[ix] = null; [EOL]     } [EOL]     return buffer; [EOL] }
public final char[] allocCharBuffer(CharBufferType type, int minSize) { [EOL]     if (type.size > minSize) { [EOL]         minSize = type.size; [EOL]     } [EOL]     int ix = type.ordinal(); [EOL]     char[] buffer = _charBuffers[ix]; [EOL]     if (buffer == null || buffer.length < minSize) { [EOL]         buffer = calloc(minSize); [EOL]     } else { [EOL]         _charBuffers[ix] = null; [EOL]     } [EOL]     return buffer; [EOL] }
public final void releaseCharBuffer(CharBufferType type, char[] buffer) { [EOL]     _charBuffers[type.ordinal()] = buffer; [EOL] }
public final void releaseCharBuffer(CharBufferType type, char[] buffer) { [EOL]     _charBuffers[type.ordinal()] = buffer; [EOL] }
public final void releaseCharBuffer(CharBufferType type, char[] buffer) { [EOL]     _charBuffers[type.ordinal()] = buffer; [EOL] }
private char[] calloc(int size) { [EOL]     return new char[size]; [EOL] }
private char[] calloc(int size) { [EOL]     return new char[size]; [EOL] }
public static Base64Variant getDefaultVariant() { [EOL]     return MIME_NO_LINEFEEDS; [EOL] }
public ByteArrayBuilder() { [EOL]     this(null); [EOL] }
public void appendTwoBytes(int b16) { [EOL]     if ((_currBlockPtr + 1) < _currBlock.length) { [EOL]         _currBlock[_currBlockPtr++] = (byte) (b16 >> 8); [EOL]         _currBlock[_currBlockPtr++] = (byte) b16; [EOL]     } else { [EOL]         append(b16 >> 8); [EOL]         append(b16); [EOL]     } [EOL] }
public void appendTwoBytes(int b16) { [EOL]     if ((_currBlockPtr + 1) < _currBlock.length) { [EOL]         _currBlock[_currBlockPtr++] = (byte) (b16 >> 8); [EOL]         _currBlock[_currBlockPtr++] = (byte) b16; [EOL]     } else { [EOL]         append(b16 >> 8); [EOL]         append(b16); [EOL]     } [EOL] }
public void appendThreeBytes(int b24) { [EOL]     if ((_currBlockPtr + 2) < _currBlock.length) { [EOL]         _currBlock[_currBlockPtr++] = (byte) (b24 >> 16); [EOL]         _currBlock[_currBlockPtr++] = (byte) (b24 >> 8); [EOL]         _currBlock[_currBlockPtr++] = (byte) b24; [EOL]     } else { [EOL]         append(b24 >> 16); [EOL]         append(b24 >> 8); [EOL]         append(b24); [EOL]     } [EOL] }
public void appendThreeBytes(int b24) { [EOL]     if ((_currBlockPtr + 2) < _currBlock.length) { [EOL]         _currBlock[_currBlockPtr++] = (byte) (b24 >> 16); [EOL]         _currBlock[_currBlockPtr++] = (byte) (b24 >> 8); [EOL]         _currBlock[_currBlockPtr++] = (byte) b24; [EOL]     } else { [EOL]         append(b24 >> 16); [EOL]         append(b24 >> 8); [EOL]         append(b24); [EOL]     } [EOL] }
protected DataFormatMatcher(InputStream in, byte[] buffered, int bufferedStart, int bufferedLength, JsonFactory match, MatchStrength strength) { [EOL]     _originalStream = in; [EOL]     _bufferedData = buffered; [EOL]     _bufferedStart = bufferedStart; [EOL]     _bufferedLength = bufferedLength; [EOL]     _match = match; [EOL]     _matchStrength = strength; [EOL] }
protected DataFormatMatcher(InputStream in, byte[] buffered, int bufferedStart, int bufferedLength, JsonFactory match, MatchStrength strength) { [EOL]     _originalStream = in; [EOL]     _bufferedData = buffered; [EOL]     _bufferedStart = bufferedStart; [EOL]     _bufferedLength = bufferedLength; [EOL]     _match = match; [EOL]     _matchStrength = strength; [EOL] }
public boolean hasMatch() { [EOL]     return _match != null; [EOL] }
public boolean hasMatch() { [EOL]     return _match != null; [EOL] }
public MatchStrength getMatchStrength() { [EOL]     return (_matchStrength == null) ? MatchStrength.INCONCLUSIVE : _matchStrength; [EOL] }
public MatchStrength getMatchStrength() { [EOL]     return (_matchStrength == null) ? MatchStrength.INCONCLUSIVE : _matchStrength; [EOL] }
public JsonFactory getMatch() { [EOL]     return _match; [EOL] }
public String getMatchedFormatName() { [EOL]     return _match.getFormatName(); [EOL] }
public JsonParser createParserWithMatch() throws IOException { [EOL]     if (_match == null) { [EOL]         return null; [EOL]     } [EOL]     if (_originalStream == null) { [EOL]         return _match.createParser(_bufferedData, _bufferedStart, _bufferedLength); [EOL]     } [EOL]     return _match.createParser(getDataStream()); [EOL] }
public JsonParser createParserWithMatch() throws IOException { [EOL]     if (_match == null) { [EOL]         return null; [EOL]     } [EOL]     if (_originalStream == null) { [EOL]         return _match.createParser(_bufferedData, _bufferedStart, _bufferedLength); [EOL]     } [EOL]     return _match.createParser(getDataStream()); [EOL] }
public JsonParser createParserWithMatch() throws IOException { [EOL]     if (_match == null) { [EOL]         return null; [EOL]     } [EOL]     if (_originalStream == null) { [EOL]         return _match.createParser(_bufferedData, _bufferedStart, _bufferedLength); [EOL]     } [EOL]     return _match.createParser(getDataStream()); [EOL] }
public InputStream getDataStream() { [EOL]     if (_originalStream == null) { [EOL]         return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength); [EOL]     } [EOL]     return new MergedStream(null, _originalStream, _bufferedData, _bufferedStart, _bufferedLength); [EOL] }
public InputStream getDataStream() { [EOL]     if (_originalStream == null) { [EOL]         return new ByteArrayInputStream(_bufferedData, _bufferedStart, _bufferedLength); [EOL]     } [EOL]     return new MergedStream(null, _originalStream, _bufferedData, _bufferedStart, _bufferedLength); [EOL] }
public static int parseInt(char[] digitChars, int offset, int len) { [EOL]     int num = digitChars[offset] - '0'; [EOL]     len += offset; [EOL]     if (++offset < len) { [EOL]         num = (num * 10) + (digitChars[offset] - '0'); [EOL]         if (++offset < len) { [EOL]             num = (num * 10) + (digitChars[offset] - '0'); [EOL]             if (++offset < len) { [EOL]                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                 if (++offset < len) { [EOL]                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                     if (++offset < len) { [EOL]                         num = (num * 10) + (digitChars[offset] - '0'); [EOL]                         if (++offset < len) { [EOL]                             num = (num * 10) + (digitChars[offset] - '0'); [EOL]                             if (++offset < len) { [EOL]                                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 if (++offset < len) { [EOL]                                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 } [EOL]                             } [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return num; [EOL] }
public static int parseInt(char[] digitChars, int offset, int len) { [EOL]     int num = digitChars[offset] - '0'; [EOL]     len += offset; [EOL]     if (++offset < len) { [EOL]         num = (num * 10) + (digitChars[offset] - '0'); [EOL]         if (++offset < len) { [EOL]             num = (num * 10) + (digitChars[offset] - '0'); [EOL]             if (++offset < len) { [EOL]                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                 if (++offset < len) { [EOL]                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                     if (++offset < len) { [EOL]                         num = (num * 10) + (digitChars[offset] - '0'); [EOL]                         if (++offset < len) { [EOL]                             num = (num * 10) + (digitChars[offset] - '0'); [EOL]                             if (++offset < len) { [EOL]                                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 if (++offset < len) { [EOL]                                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 } [EOL]                             } [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return num; [EOL] }
public static int parseInt(char[] digitChars, int offset, int len) { [EOL]     int num = digitChars[offset] - '0'; [EOL]     len += offset; [EOL]     if (++offset < len) { [EOL]         num = (num * 10) + (digitChars[offset] - '0'); [EOL]         if (++offset < len) { [EOL]             num = (num * 10) + (digitChars[offset] - '0'); [EOL]             if (++offset < len) { [EOL]                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                 if (++offset < len) { [EOL]                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                     if (++offset < len) { [EOL]                         num = (num * 10) + (digitChars[offset] - '0'); [EOL]                         if (++offset < len) { [EOL]                             num = (num * 10) + (digitChars[offset] - '0'); [EOL]                             if (++offset < len) { [EOL]                                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 if (++offset < len) { [EOL]                                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 } [EOL]                             } [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return num; [EOL] }
public static int parseInt(char[] digitChars, int offset, int len) { [EOL]     int num = digitChars[offset] - '0'; [EOL]     len += offset; [EOL]     if (++offset < len) { [EOL]         num = (num * 10) + (digitChars[offset] - '0'); [EOL]         if (++offset < len) { [EOL]             num = (num * 10) + (digitChars[offset] - '0'); [EOL]             if (++offset < len) { [EOL]                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                 if (++offset < len) { [EOL]                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                     if (++offset < len) { [EOL]                         num = (num * 10) + (digitChars[offset] - '0'); [EOL]                         if (++offset < len) { [EOL]                             num = (num * 10) + (digitChars[offset] - '0'); [EOL]                             if (++offset < len) { [EOL]                                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 if (++offset < len) { [EOL]                                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 } [EOL]                             } [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return num; [EOL] }
public static int parseInt(char[] digitChars, int offset, int len) { [EOL]     int num = digitChars[offset] - '0'; [EOL]     len += offset; [EOL]     if (++offset < len) { [EOL]         num = (num * 10) + (digitChars[offset] - '0'); [EOL]         if (++offset < len) { [EOL]             num = (num * 10) + (digitChars[offset] - '0'); [EOL]             if (++offset < len) { [EOL]                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                 if (++offset < len) { [EOL]                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                     if (++offset < len) { [EOL]                         num = (num * 10) + (digitChars[offset] - '0'); [EOL]                         if (++offset < len) { [EOL]                             num = (num * 10) + (digitChars[offset] - '0'); [EOL]                             if (++offset < len) { [EOL]                                 num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 if (++offset < len) { [EOL]                                     num = (num * 10) + (digitChars[offset] - '0'); [EOL]                                 } [EOL]                             } [EOL]                         } [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return num; [EOL] }
public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative) { [EOL]     String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR; [EOL]     int cmpLen = cmpStr.length(); [EOL]     if (len < cmpLen) [EOL]         return true; [EOL]     if (len > cmpLen) [EOL]         return false; [EOL]     for (int i = 0; i < cmpLen; ++i) { [EOL]         int diff = digitChars[offset + i] - cmpStr.charAt(i); [EOL]         if (diff != 0) { [EOL]             return (diff < 0); [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative) { [EOL]     String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR; [EOL]     int cmpLen = cmpStr.length(); [EOL]     if (len < cmpLen) [EOL]         return true; [EOL]     if (len > cmpLen) [EOL]         return false; [EOL]     for (int i = 0; i < cmpLen; ++i) { [EOL]         int diff = digitChars[offset + i] - cmpStr.charAt(i); [EOL]         if (diff != 0) { [EOL]             return (diff < 0); [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative) { [EOL]     String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR; [EOL]     int cmpLen = cmpStr.length(); [EOL]     if (len < cmpLen) [EOL]         return true; [EOL]     if (len > cmpLen) [EOL]         return false; [EOL]     for (int i = 0; i < cmpLen; ++i) { [EOL]         int diff = digitChars[offset + i] - cmpStr.charAt(i); [EOL]         if (diff != 0) { [EOL]             return (diff < 0); [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative) { [EOL]     String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR; [EOL]     int cmpLen = cmpStr.length(); [EOL]     if (len < cmpLen) [EOL]         return true; [EOL]     if (len > cmpLen) [EOL]         return false; [EOL]     for (int i = 0; i < cmpLen; ++i) { [EOL]         int diff = digitChars[offset + i] - cmpStr.charAt(i); [EOL]         if (diff != 0) { [EOL]             return (diff < 0); [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static boolean inLongRange(char[] digitChars, int offset, int len, boolean negative) { [EOL]     String cmpStr = negative ? MIN_LONG_STR_NO_SIGN : MAX_LONG_STR; [EOL]     int cmpLen = cmpStr.length(); [EOL]     if (len < cmpLen) [EOL]         return true; [EOL]     if (len > cmpLen) [EOL]         return false; [EOL]     for (int i = 0; i < cmpLen; ++i) { [EOL]         int diff = digitChars[offset + i] - cmpStr.charAt(i); [EOL]         if (diff != 0) { [EOL]             return (diff < 0); [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public static long parseAsLong(String input, long defaultValue) { [EOL]     if (input == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     input = input.trim(); [EOL]     int len = input.length(); [EOL]     if (len == 0) { [EOL]         return defaultValue; [EOL]     } [EOL]     int i = 0; [EOL]     if (i < len) { [EOL]         char c = input.charAt(0); [EOL]         if (c == '+') { [EOL]             input = input.substring(1); [EOL]             len = input.length(); [EOL]         } else if (c == '-') { [EOL]             ++i; [EOL]         } [EOL]     } [EOL]     for (; i < len; ++i) { [EOL]         char c = input.charAt(i); [EOL]         if (c > '9' || c < '0') { [EOL]             try { [EOL]                 return (long) parseDouble(input); [EOL]             } catch (NumberFormatException e) { [EOL]                 return defaultValue; [EOL]             } [EOL]         } [EOL]     } [EOL]     try { [EOL]         return Long.parseLong(input); [EOL]     } catch (NumberFormatException e) { [EOL]     } [EOL]     return defaultValue; [EOL] }
public static long parseAsLong(String input, long defaultValue) { [EOL]     if (input == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     input = input.trim(); [EOL]     int len = input.length(); [EOL]     if (len == 0) { [EOL]         return defaultValue; [EOL]     } [EOL]     int i = 0; [EOL]     if (i < len) { [EOL]         char c = input.charAt(0); [EOL]         if (c == '+') { [EOL]             input = input.substring(1); [EOL]             len = input.length(); [EOL]         } else if (c == '-') { [EOL]             ++i; [EOL]         } [EOL]     } [EOL]     for (; i < len; ++i) { [EOL]         char c = input.charAt(i); [EOL]         if (c > '9' || c < '0') { [EOL]             try { [EOL]                 return (long) parseDouble(input); [EOL]             } catch (NumberFormatException e) { [EOL]                 return defaultValue; [EOL]             } [EOL]         } [EOL]     } [EOL]     try { [EOL]         return Long.parseLong(input); [EOL]     } catch (NumberFormatException e) { [EOL]     } [EOL]     return defaultValue; [EOL] }
public static long parseAsLong(String input, long defaultValue) { [EOL]     if (input == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     input = input.trim(); [EOL]     int len = input.length(); [EOL]     if (len == 0) { [EOL]         return defaultValue; [EOL]     } [EOL]     int i = 0; [EOL]     if (i < len) { [EOL]         char c = input.charAt(0); [EOL]         if (c == '+') { [EOL]             input = input.substring(1); [EOL]             len = input.length(); [EOL]         } else if (c == '-') { [EOL]             ++i; [EOL]         } [EOL]     } [EOL]     for (; i < len; ++i) { [EOL]         char c = input.charAt(i); [EOL]         if (c > '9' || c < '0') { [EOL]             try { [EOL]                 return (long) parseDouble(input); [EOL]             } catch (NumberFormatException e) { [EOL]                 return defaultValue; [EOL]             } [EOL]         } [EOL]     } [EOL]     try { [EOL]         return Long.parseLong(input); [EOL]     } catch (NumberFormatException e) { [EOL]     } [EOL]     return defaultValue; [EOL] }
public static long parseAsLong(String input, long defaultValue) { [EOL]     if (input == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     input = input.trim(); [EOL]     int len = input.length(); [EOL]     if (len == 0) { [EOL]         return defaultValue; [EOL]     } [EOL]     int i = 0; [EOL]     if (i < len) { [EOL]         char c = input.charAt(0); [EOL]         if (c == '+') { [EOL]             input = input.substring(1); [EOL]             len = input.length(); [EOL]         } else if (c == '-') { [EOL]             ++i; [EOL]         } [EOL]     } [EOL]     for (; i < len; ++i) { [EOL]         char c = input.charAt(i); [EOL]         if (c > '9' || c < '0') { [EOL]             try { [EOL]                 return (long) parseDouble(input); [EOL]             } catch (NumberFormatException e) { [EOL]                 return defaultValue; [EOL]             } [EOL]         } [EOL]     } [EOL]     try { [EOL]         return Long.parseLong(input); [EOL]     } catch (NumberFormatException e) { [EOL]     } [EOL]     return defaultValue; [EOL] }
public static long parseAsLong(String input, long defaultValue) { [EOL]     if (input == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     input = input.trim(); [EOL]     int len = input.length(); [EOL]     if (len == 0) { [EOL]         return defaultValue; [EOL]     } [EOL]     int i = 0; [EOL]     if (i < len) { [EOL]         char c = input.charAt(0); [EOL]         if (c == '+') { [EOL]             input = input.substring(1); [EOL]             len = input.length(); [EOL]         } else if (c == '-') { [EOL]             ++i; [EOL]         } [EOL]     } [EOL]     for (; i < len; ++i) { [EOL]         char c = input.charAt(i); [EOL]         if (c > '9' || c < '0') { [EOL]             try { [EOL]                 return (long) parseDouble(input); [EOL]             } catch (NumberFormatException e) { [EOL]                 return defaultValue; [EOL]             } [EOL]         } [EOL]     } [EOL]     try { [EOL]         return Long.parseLong(input); [EOL]     } catch (NumberFormatException e) { [EOL]     } [EOL]     return defaultValue; [EOL] }
public static long parseAsLong(String input, long defaultValue) { [EOL]     if (input == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     input = input.trim(); [EOL]     int len = input.length(); [EOL]     if (len == 0) { [EOL]         return defaultValue; [EOL]     } [EOL]     int i = 0; [EOL]     if (i < len) { [EOL]         char c = input.charAt(0); [EOL]         if (c == '+') { [EOL]             input = input.substring(1); [EOL]             len = input.length(); [EOL]         } else if (c == '-') { [EOL]             ++i; [EOL]         } [EOL]     } [EOL]     for (; i < len; ++i) { [EOL]         char c = input.charAt(i); [EOL]         if (c > '9' || c < '0') { [EOL]             try { [EOL]                 return (long) parseDouble(input); [EOL]             } catch (NumberFormatException e) { [EOL]                 return defaultValue; [EOL]             } [EOL]         } [EOL]     } [EOL]     try { [EOL]         return Long.parseLong(input); [EOL]     } catch (NumberFormatException e) { [EOL]     } [EOL]     return defaultValue; [EOL] }
public static long parseAsLong(String input, long defaultValue) { [EOL]     if (input == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     input = input.trim(); [EOL]     int len = input.length(); [EOL]     if (len == 0) { [EOL]         return defaultValue; [EOL]     } [EOL]     int i = 0; [EOL]     if (i < len) { [EOL]         char c = input.charAt(0); [EOL]         if (c == '+') { [EOL]             input = input.substring(1); [EOL]             len = input.length(); [EOL]         } else if (c == '-') { [EOL]             ++i; [EOL]         } [EOL]     } [EOL]     for (; i < len; ++i) { [EOL]         char c = input.charAt(i); [EOL]         if (c > '9' || c < '0') { [EOL]             try { [EOL]                 return (long) parseDouble(input); [EOL]             } catch (NumberFormatException e) { [EOL]                 return defaultValue; [EOL]             } [EOL]         } [EOL]     } [EOL]     try { [EOL]         return Long.parseLong(input); [EOL]     } catch (NumberFormatException e) { [EOL]     } [EOL]     return defaultValue; [EOL] }
public static long parseAsLong(String input, long defaultValue) { [EOL]     if (input == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     input = input.trim(); [EOL]     int len = input.length(); [EOL]     if (len == 0) { [EOL]         return defaultValue; [EOL]     } [EOL]     int i = 0; [EOL]     if (i < len) { [EOL]         char c = input.charAt(0); [EOL]         if (c == '+') { [EOL]             input = input.substring(1); [EOL]             len = input.length(); [EOL]         } else if (c == '-') { [EOL]             ++i; [EOL]         } [EOL]     } [EOL]     for (; i < len; ++i) { [EOL]         char c = input.charAt(i); [EOL]         if (c > '9' || c < '0') { [EOL]             try { [EOL]                 return (long) parseDouble(input); [EOL]             } catch (NumberFormatException e) { [EOL]                 return defaultValue; [EOL]             } [EOL]         } [EOL]     } [EOL]     try { [EOL]         return Long.parseLong(input); [EOL]     } catch (NumberFormatException e) { [EOL]     } [EOL]     return defaultValue; [EOL] }
public static double parseAsDouble(String input, double defaultValue) { [EOL]     if (input == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     input = input.trim(); [EOL]     int len = input.length(); [EOL]     if (len == 0) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return parseDouble(input); [EOL]     } catch (NumberFormatException e) { [EOL]     } [EOL]     return defaultValue; [EOL] }
public static double parseAsDouble(String input, double defaultValue) { [EOL]     if (input == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     input = input.trim(); [EOL]     int len = input.length(); [EOL]     if (len == 0) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return parseDouble(input); [EOL]     } catch (NumberFormatException e) { [EOL]     } [EOL]     return defaultValue; [EOL] }
public static double parseAsDouble(String input, double defaultValue) { [EOL]     if (input == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     input = input.trim(); [EOL]     int len = input.length(); [EOL]     if (len == 0) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return parseDouble(input); [EOL]     } catch (NumberFormatException e) { [EOL]     } [EOL]     return defaultValue; [EOL] }
public static double parseAsDouble(String input, double defaultValue) { [EOL]     if (input == null) { [EOL]         return defaultValue; [EOL]     } [EOL]     input = input.trim(); [EOL]     int len = input.length(); [EOL]     if (len == 0) { [EOL]         return defaultValue; [EOL]     } [EOL]     try { [EOL]         return parseDouble(input); [EOL]     } catch (NumberFormatException e) { [EOL]     } [EOL]     return defaultValue; [EOL] }
@Override [EOL] public String getText() throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_STRING) { [EOL]         if (_tokenIncomplete) { [EOL]             _tokenIncomplete = false; [EOL]             _finishString(); [EOL]         } [EOL]         return _textBuffer.contentsAsString(); [EOL]     } [EOL]     return _getText2(_currToken); [EOL] }
@Override [EOL] public String getText() throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_STRING) { [EOL]         if (_tokenIncomplete) { [EOL]             _tokenIncomplete = false; [EOL]             _finishString(); [EOL]         } [EOL]         return _textBuffer.contentsAsString(); [EOL]     } [EOL]     return _getText2(_currToken); [EOL] }
@Override [EOL] public String getText() throws IOException, JsonParseException { [EOL]     if (_currToken == JsonToken.VALUE_STRING) { [EOL]         if (_tokenIncomplete) { [EOL]             _tokenIncomplete = false; [EOL]             _finishString(); [EOL]         } [EOL]         return _textBuffer.contentsAsString(); [EOL]     } [EOL]     return _getText2(_currToken); [EOL] }
protected String _getText2(JsonToken t) { [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case FIELD_NAME: [EOL]             return _parsingContext.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return _textBuffer.contentsAsString(); [EOL]         default: [EOL]             return t.asString(); [EOL]     } [EOL] }
protected String _getText2(JsonToken t) { [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case FIELD_NAME: [EOL]             return _parsingContext.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return _textBuffer.contentsAsString(); [EOL]         default: [EOL]             return t.asString(); [EOL]     } [EOL] }
protected String _getText2(JsonToken t) { [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case FIELD_NAME: [EOL]             return _parsingContext.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return _textBuffer.contentsAsString(); [EOL]         default: [EOL]             return t.asString(); [EOL]     } [EOL] }
protected String _getText2(JsonToken t) { [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case FIELD_NAME: [EOL]             return _parsingContext.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return _textBuffer.contentsAsString(); [EOL]         default: [EOL]             return t.asString(); [EOL]     } [EOL] }
protected String _getText2(JsonToken t) { [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case FIELD_NAME: [EOL]             return _parsingContext.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return _textBuffer.contentsAsString(); [EOL]         default: [EOL]             return t.asString(); [EOL]     } [EOL] }
protected String _getText2(JsonToken t) { [EOL]     if (t == null) { [EOL]         return null; [EOL]     } [EOL]     switch(t) { [EOL]         case FIELD_NAME: [EOL]             return _parsingContext.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return _textBuffer.contentsAsString(); [EOL]         default: [EOL]             return t.asString(); [EOL]     } [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     if (!_parsingContext.inObject()) { [EOL]         return _nextTokenNotInObject(i); [EOL]     } [EOL]     Name n = _parseFieldName(i); [EOL]     _parsingContext.setCurrentName(n.getName()); [EOL]     _currToken = JsonToken.FIELD_NAME; [EOL]     i = _skipWS(); [EOL]     if (i != INT_COLON) { [EOL]         _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]     } [EOL]     i = _skipWS(); [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         _nextToken = JsonToken.VALUE_STRING; [EOL]         return _currToken; [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]     } [EOL]     _nextToken = t; [EOL]     return _currToken; [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
private JsonToken _nextTokenNotInObject(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_QUOTE) { [EOL]         _tokenIncomplete = true; [EOL]         return (_currToken = JsonToken.VALUE_STRING); [EOL]     } [EOL]     switch(i) { [EOL]         case INT_LBRACKET: [EOL]             _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_ARRAY); [EOL]         case INT_LCURLY: [EOL]             _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             return (_currToken = JsonToken.START_OBJECT); [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             return (_currToken = JsonToken.VALUE_TRUE); [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             return (_currToken = JsonToken.VALUE_FALSE); [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             return (_currToken = JsonToken.VALUE_NULL); [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             return (_currToken = parseNumberText(i)); [EOL]     } [EOL]     return (_currToken = _handleUnexpectedValue(i)); [EOL] }
protected JsonToken parseNumberText(int c) throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = 0; [EOL]     boolean negative = (c == INT_MINUS); [EOL]     if (negative) { [EOL]         outBuf[outPtr++] = '-'; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             return _handleInvalidNumberStart(c, true); [EOL]         } [EOL]     } [EOL]     if (c == INT_0) { [EOL]         c = _verifyNoLeadingZeroes(); [EOL]     } [EOL]     outBuf[outPtr++] = (char) c; [EOL]     int intLen = 1; [EOL]     int end = _inputPtr + outBuf.length; [EOL]     if (end > _inputEnd) { [EOL]         end = _inputEnd; [EOL]     } [EOL]     while (true) { [EOL]         if (_inputPtr >= end) { [EOL]             return _parserNumber2(outBuf, outPtr, negative, intLen); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             break; [EOL]         } [EOL]         ++intLen; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     if (c == '.' || c == 'e' || c == 'E') { [EOL]         return _parseFloatText(outBuf, outPtr, c, negative, intLen); [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intLen); [EOL] }
protected JsonToken parseNumberText(int c) throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = 0; [EOL]     boolean negative = (c == INT_MINUS); [EOL]     if (negative) { [EOL]         outBuf[outPtr++] = '-'; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             return _handleInvalidNumberStart(c, true); [EOL]         } [EOL]     } [EOL]     if (c == INT_0) { [EOL]         c = _verifyNoLeadingZeroes(); [EOL]     } [EOL]     outBuf[outPtr++] = (char) c; [EOL]     int intLen = 1; [EOL]     int end = _inputPtr + outBuf.length; [EOL]     if (end > _inputEnd) { [EOL]         end = _inputEnd; [EOL]     } [EOL]     while (true) { [EOL]         if (_inputPtr >= end) { [EOL]             return _parserNumber2(outBuf, outPtr, negative, intLen); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             break; [EOL]         } [EOL]         ++intLen; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     if (c == '.' || c == 'e' || c == 'E') { [EOL]         return _parseFloatText(outBuf, outPtr, c, negative, intLen); [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intLen); [EOL] }
protected JsonToken parseNumberText(int c) throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = 0; [EOL]     boolean negative = (c == INT_MINUS); [EOL]     if (negative) { [EOL]         outBuf[outPtr++] = '-'; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             return _handleInvalidNumberStart(c, true); [EOL]         } [EOL]     } [EOL]     if (c == INT_0) { [EOL]         c = _verifyNoLeadingZeroes(); [EOL]     } [EOL]     outBuf[outPtr++] = (char) c; [EOL]     int intLen = 1; [EOL]     int end = _inputPtr + outBuf.length; [EOL]     if (end > _inputEnd) { [EOL]         end = _inputEnd; [EOL]     } [EOL]     while (true) { [EOL]         if (_inputPtr >= end) { [EOL]             return _parserNumber2(outBuf, outPtr, negative, intLen); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             break; [EOL]         } [EOL]         ++intLen; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     if (c == '.' || c == 'e' || c == 'E') { [EOL]         return _parseFloatText(outBuf, outPtr, c, negative, intLen); [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intLen); [EOL] }
protected JsonToken parseNumberText(int c) throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = 0; [EOL]     boolean negative = (c == INT_MINUS); [EOL]     if (negative) { [EOL]         outBuf[outPtr++] = '-'; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             return _handleInvalidNumberStart(c, true); [EOL]         } [EOL]     } [EOL]     if (c == INT_0) { [EOL]         c = _verifyNoLeadingZeroes(); [EOL]     } [EOL]     outBuf[outPtr++] = (char) c; [EOL]     int intLen = 1; [EOL]     int end = _inputPtr + outBuf.length; [EOL]     if (end > _inputEnd) { [EOL]         end = _inputEnd; [EOL]     } [EOL]     while (true) { [EOL]         if (_inputPtr >= end) { [EOL]             return _parserNumber2(outBuf, outPtr, negative, intLen); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             break; [EOL]         } [EOL]         ++intLen; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     if (c == '.' || c == 'e' || c == 'E') { [EOL]         return _parseFloatText(outBuf, outPtr, c, negative, intLen); [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intLen); [EOL] }
protected JsonToken parseNumberText(int c) throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = 0; [EOL]     boolean negative = (c == INT_MINUS); [EOL]     if (negative) { [EOL]         outBuf[outPtr++] = '-'; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             return _handleInvalidNumberStart(c, true); [EOL]         } [EOL]     } [EOL]     if (c == INT_0) { [EOL]         c = _verifyNoLeadingZeroes(); [EOL]     } [EOL]     outBuf[outPtr++] = (char) c; [EOL]     int intLen = 1; [EOL]     int end = _inputPtr + outBuf.length; [EOL]     if (end > _inputEnd) { [EOL]         end = _inputEnd; [EOL]     } [EOL]     while (true) { [EOL]         if (_inputPtr >= end) { [EOL]             return _parserNumber2(outBuf, outPtr, negative, intLen); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             break; [EOL]         } [EOL]         ++intLen; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     if (c == '.' || c == 'e' || c == 'E') { [EOL]         return _parseFloatText(outBuf, outPtr, c, negative, intLen); [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intLen); [EOL] }
protected JsonToken parseNumberText(int c) throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = 0; [EOL]     boolean negative = (c == INT_MINUS); [EOL]     if (negative) { [EOL]         outBuf[outPtr++] = '-'; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             return _handleInvalidNumberStart(c, true); [EOL]         } [EOL]     } [EOL]     if (c == INT_0) { [EOL]         c = _verifyNoLeadingZeroes(); [EOL]     } [EOL]     outBuf[outPtr++] = (char) c; [EOL]     int intLen = 1; [EOL]     int end = _inputPtr + outBuf.length; [EOL]     if (end > _inputEnd) { [EOL]         end = _inputEnd; [EOL]     } [EOL]     while (true) { [EOL]         if (_inputPtr >= end) { [EOL]             return _parserNumber2(outBuf, outPtr, negative, intLen); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             break; [EOL]         } [EOL]         ++intLen; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     if (c == '.' || c == 'e' || c == 'E') { [EOL]         return _parseFloatText(outBuf, outPtr, c, negative, intLen); [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intLen); [EOL] }
protected JsonToken parseNumberText(int c) throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = 0; [EOL]     boolean negative = (c == INT_MINUS); [EOL]     if (negative) { [EOL]         outBuf[outPtr++] = '-'; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             return _handleInvalidNumberStart(c, true); [EOL]         } [EOL]     } [EOL]     if (c == INT_0) { [EOL]         c = _verifyNoLeadingZeroes(); [EOL]     } [EOL]     outBuf[outPtr++] = (char) c; [EOL]     int intLen = 1; [EOL]     int end = _inputPtr + outBuf.length; [EOL]     if (end > _inputEnd) { [EOL]         end = _inputEnd; [EOL]     } [EOL]     while (true) { [EOL]         if (_inputPtr >= end) { [EOL]             return _parserNumber2(outBuf, outPtr, negative, intLen); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             break; [EOL]         } [EOL]         ++intLen; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     if (c == '.' || c == 'e' || c == 'E') { [EOL]         return _parseFloatText(outBuf, outPtr, c, negative, intLen); [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intLen); [EOL] }
protected JsonToken parseNumberText(int c) throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = 0; [EOL]     boolean negative = (c == INT_MINUS); [EOL]     if (negative) { [EOL]         outBuf[outPtr++] = '-'; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             return _handleInvalidNumberStart(c, true); [EOL]         } [EOL]     } [EOL]     if (c == INT_0) { [EOL]         c = _verifyNoLeadingZeroes(); [EOL]     } [EOL]     outBuf[outPtr++] = (char) c; [EOL]     int intLen = 1; [EOL]     int end = _inputPtr + outBuf.length; [EOL]     if (end > _inputEnd) { [EOL]         end = _inputEnd; [EOL]     } [EOL]     while (true) { [EOL]         if (_inputPtr >= end) { [EOL]             return _parserNumber2(outBuf, outPtr, negative, intLen); [EOL]         } [EOL]         c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c < INT_0 || c > INT_9) { [EOL]             break; [EOL]         } [EOL]         ++intLen; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     if (c == '.' || c == 'e' || c == 'E') { [EOL]         return _parseFloatText(outBuf, outPtr, c, negative, intLen); [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intLen); [EOL] }
private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException { [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]             _textBuffer.setCurrentLength(outPtr); [EOL]             return resetInt(negative, intPartLength); [EOL]         } [EOL]         int c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c > INT_9 || c < INT_0) { [EOL]             if (c == '.' || c == 'e' || c == 'E') { [EOL]                 return _parseFloatText(outBuf, outPtr, c, negative, intPartLength); [EOL]             } [EOL]             break; [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]         ++intPartLength; [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intPartLength); [EOL] }
private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException { [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]             _textBuffer.setCurrentLength(outPtr); [EOL]             return resetInt(negative, intPartLength); [EOL]         } [EOL]         int c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c > INT_9 || c < INT_0) { [EOL]             if (c == '.' || c == 'e' || c == 'E') { [EOL]                 return _parseFloatText(outBuf, outPtr, c, negative, intPartLength); [EOL]             } [EOL]             break; [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]         ++intPartLength; [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intPartLength); [EOL] }
private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException { [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]             _textBuffer.setCurrentLength(outPtr); [EOL]             return resetInt(negative, intPartLength); [EOL]         } [EOL]         int c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c > INT_9 || c < INT_0) { [EOL]             if (c == '.' || c == 'e' || c == 'E') { [EOL]                 return _parseFloatText(outBuf, outPtr, c, negative, intPartLength); [EOL]             } [EOL]             break; [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]         ++intPartLength; [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intPartLength); [EOL] }
private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException { [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]             _textBuffer.setCurrentLength(outPtr); [EOL]             return resetInt(negative, intPartLength); [EOL]         } [EOL]         int c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c > INT_9 || c < INT_0) { [EOL]             if (c == '.' || c == 'e' || c == 'E') { [EOL]                 return _parseFloatText(outBuf, outPtr, c, negative, intPartLength); [EOL]             } [EOL]             break; [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]         ++intPartLength; [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intPartLength); [EOL] }
private JsonToken _parserNumber2(char[] outBuf, int outPtr, boolean negative, int intPartLength) throws IOException, JsonParseException { [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]             _textBuffer.setCurrentLength(outPtr); [EOL]             return resetInt(negative, intPartLength); [EOL]         } [EOL]         int c = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         if (c > INT_9 || c < INT_0) { [EOL]             if (c == '.' || c == 'e' || c == 'E') { [EOL]                 return _parseFloatText(outBuf, outPtr, c, negative, intPartLength); [EOL]             } [EOL]             break; [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]         ++intPartLength; [EOL]     } [EOL]     --_inputPtr; [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return resetInt(negative, intPartLength); [EOL] }
protected Name _parseFieldName(int i) throws IOException, JsonParseException { [EOL]     if (i != INT_QUOTE) { [EOL]         return _handleUnusualFieldName(i); [EOL]     } [EOL]     if ((_inputPtr + 9) > _inputEnd) { [EOL]         return slowParseFieldName(); [EOL]     } [EOL]     final byte[] input = _inputBuffer; [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     int q = input[_inputPtr++] & 0xFF; [EOL]     if (codes[q] == 0) { [EOL]         i = input[_inputPtr++] & 0xFF; [EOL]         if (codes[i] == 0) { [EOL]             q = (q << 8) | i; [EOL]             i = input[_inputPtr++] & 0xFF; [EOL]             if (codes[i] == 0) { [EOL]                 q = (q << 8) | i; [EOL]                 i = input[_inputPtr++] & 0xFF; [EOL]                 if (codes[i] == 0) { [EOL]                     q = (q << 8) | i; [EOL]                     i = input[_inputPtr++] & 0xFF; [EOL]                     if (codes[i] == 0) { [EOL]                         _quad1 = q; [EOL]                         return parseMediumFieldName(i, codes); [EOL]                     } [EOL]                     if (i == INT_QUOTE) { [EOL]                         return findName(q, 4); [EOL]                     } [EOL]                     return parseFieldName(q, i, 4); [EOL]                 } [EOL]                 if (i == INT_QUOTE) { [EOL]                     return findName(q, 3); [EOL]                 } [EOL]                 return parseFieldName(q, i, 3); [EOL]             } [EOL]             if (i == INT_QUOTE) { [EOL]                 return findName(q, 2); [EOL]             } [EOL]             return parseFieldName(q, i, 2); [EOL]         } [EOL]         if (i == INT_QUOTE) { [EOL]             return findName(q, 1); [EOL]         } [EOL]         return parseFieldName(q, i, 1); [EOL]     } [EOL]     if (q == INT_QUOTE) { [EOL]         return BytesToNameCanonicalizer.getEmptyName(); [EOL]     } [EOL]     return parseFieldName(0, q, 0); [EOL] }
protected Name slowParseFieldName() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(": was expecting closing '\"' for name"); [EOL]         } [EOL]     } [EOL]     int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (i == INT_QUOTE) { [EOL]         return BytesToNameCanonicalizer.getEmptyName(); [EOL]     } [EOL]     return parseEscapedFieldName(_quadBuffer, 0, 0, i, 0); [EOL] }
protected Name slowParseFieldName() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(": was expecting closing '\"' for name"); [EOL]         } [EOL]     } [EOL]     int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (i == INT_QUOTE) { [EOL]         return BytesToNameCanonicalizer.getEmptyName(); [EOL]     } [EOL]     return parseEscapedFieldName(_quadBuffer, 0, 0, i, 0); [EOL] }
protected Name slowParseFieldName() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(": was expecting closing '\"' for name"); [EOL]         } [EOL]     } [EOL]     int i = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (i == INT_QUOTE) { [EOL]         return BytesToNameCanonicalizer.getEmptyName(); [EOL]     } [EOL]     return parseEscapedFieldName(_quadBuffer, 0, 0, i, 0); [EOL] }
protected Name _handleUnusualFieldName(int ch) throws IOException, JsonParseException { [EOL]     if (ch == INT_APOSTROPHE && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]         return _parseApostropheFieldName(); [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { [EOL]         _reportUnexpectedChar(ch, "was expecting double-quote to start field name"); [EOL]     } [EOL]     final int[] codes = CharTypes.getInputCodeUtf8JsNames(); [EOL]     if (codes[ch] != 0) { [EOL]         _reportUnexpectedChar(ch, "was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"); [EOL]     } [EOL]     int[] quads = _quadBuffer; [EOL]     int qlen = 0; [EOL]     int currQuad = 0; [EOL]     int currQuadBytes = 0; [EOL]     while (true) { [EOL]         if (currQuadBytes < 4) { [EOL]             ++currQuadBytes; [EOL]             currQuad = (currQuad << 8) | ch; [EOL]         } else { [EOL]             if (qlen >= quads.length) { [EOL]                 _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]             } [EOL]             quads[qlen++] = currQuad; [EOL]             currQuad = ch; [EOL]             currQuadBytes = 1; [EOL]         } [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]         if (codes[ch] != 0) { [EOL]             break; [EOL]         } [EOL]         ++_inputPtr; [EOL]     } [EOL]     if (currQuadBytes > 0) { [EOL]         if (qlen >= quads.length) { [EOL]             _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]         } [EOL]         quads[qlen++] = currQuad; [EOL]     } [EOL]     Name name = _symbols.findName(quads, qlen); [EOL]     if (name == null) { [EOL]         name = addName(quads, qlen, currQuadBytes); [EOL]     } [EOL]     return name; [EOL] }
protected Name _parseApostropheFieldName() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             _reportInvalidEOF(": was expecting closing '\'' for name"); [EOL]         } [EOL]     } [EOL]     int ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     if (ch == INT_APOSTROPHE) { [EOL]         return BytesToNameCanonicalizer.getEmptyName(); [EOL]     } [EOL]     int[] quads = _quadBuffer; [EOL]     int qlen = 0; [EOL]     int currQuad = 0; [EOL]     int currQuadBytes = 0; [EOL]     final int[] codes = sInputCodesLatin1; [EOL]     while (true) { [EOL]         if (ch == INT_APOSTROPHE) { [EOL]             break; [EOL]         } [EOL]         if (ch != INT_QUOTE && codes[ch] != 0) { [EOL]             if (ch != INT_BACKSLASH) { [EOL]                 _throwUnquotedSpace(ch, "name"); [EOL]             } else { [EOL]                 ch = _decodeEscaped(); [EOL]             } [EOL]             if (ch > 127) { [EOL]                 if (currQuadBytes >= 4) { [EOL]                     if (qlen >= quads.length) { [EOL]                         _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]                     } [EOL]                     quads[qlen++] = currQuad; [EOL]                     currQuad = 0; [EOL]                     currQuadBytes = 0; [EOL]                 } [EOL]                 if (ch < 0x800) { [EOL]                     currQuad = (currQuad << 8) | (0xc0 | (ch >> 6)); [EOL]                     ++currQuadBytes; [EOL]                 } else { [EOL]                     currQuad = (currQuad << 8) | (0xe0 | (ch >> 12)); [EOL]                     ++currQuadBytes; [EOL]                     if (currQuadBytes >= 4) { [EOL]                         if (qlen >= quads.length) { [EOL]                             _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]                         } [EOL]                         quads[qlen++] = currQuad; [EOL]                         currQuad = 0; [EOL]                         currQuadBytes = 0; [EOL]                     } [EOL]                     currQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f)); [EOL]                     ++currQuadBytes; [EOL]                 } [EOL]                 ch = 0x80 | (ch & 0x3f); [EOL]             } [EOL]         } [EOL]         if (currQuadBytes < 4) { [EOL]             ++currQuadBytes; [EOL]             currQuad = (currQuad << 8) | ch; [EOL]         } else { [EOL]             if (qlen >= quads.length) { [EOL]                 _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]             } [EOL]             quads[qlen++] = currQuad; [EOL]             currQuad = ch; [EOL]             currQuadBytes = 1; [EOL]         } [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]     } [EOL]     if (currQuadBytes > 0) { [EOL]         if (qlen >= quads.length) { [EOL]             _quadBuffer = quads = growArrayBy(quads, quads.length); [EOL]         } [EOL]         quads[qlen++] = currQuad; [EOL]     } [EOL]     Name name = _symbols.findName(quads, qlen); [EOL]     if (name == null) { [EOL]         name = addName(quads, qlen, currQuadBytes); [EOL]     } [EOL]     return name; [EOL] }
private Name addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException { [EOL]     int byteLen = (qlen << 2) - 4 + lastQuadBytes; [EOL]     int lastQuad; [EOL]     if (lastQuadBytes < 4) { [EOL]         lastQuad = quads[qlen - 1]; [EOL]         quads[qlen - 1] = (lastQuad << ((4 - lastQuadBytes) << 3)); [EOL]     } else { [EOL]         lastQuad = 0; [EOL]     } [EOL]     char[] cbuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int cix = 0; [EOL]     for (int ix = 0; ix < byteLen; ) { [EOL]         int ch = quads[ix >> 2]; [EOL]         int byteIx = (ix & 3); [EOL]         ch = (ch >> ((3 - byteIx) << 3)) & 0xFF; [EOL]         ++ix; [EOL]         if (ch > 127) { [EOL]             int needed; [EOL]             if ((ch & 0xE0) == 0xC0) { [EOL]                 ch &= 0x1F; [EOL]                 needed = 1; [EOL]             } else if ((ch & 0xF0) == 0xE0) { [EOL]                 ch &= 0x0F; [EOL]                 needed = 2; [EOL]             } else if ((ch & 0xF8) == 0xF0) { [EOL]                 ch &= 0x07; [EOL]                 needed = 3; [EOL]             } else { [EOL]                 _reportInvalidInitial(ch); [EOL]                 needed = ch = 1; [EOL]             } [EOL]             if ((ix + needed) > byteLen) { [EOL]                 _reportInvalidEOF(" in field name"); [EOL]             } [EOL]             int ch2 = quads[ix >> 2]; [EOL]             byteIx = (ix & 3); [EOL]             ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]             ++ix; [EOL]             if ((ch2 & 0xC0) != 0x080) { [EOL]                 _reportInvalidOther(ch2); [EOL]             } [EOL]             ch = (ch << 6) | (ch2 & 0x3F); [EOL]             if (needed > 1) { [EOL]                 ch2 = quads[ix >> 2]; [EOL]                 byteIx = (ix & 3); [EOL]                 ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                 ++ix; [EOL]                 if ((ch2 & 0xC0) != 0x080) { [EOL]                     _reportInvalidOther(ch2); [EOL]                 } [EOL]                 ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 if (needed > 2) { [EOL]                     ch2 = quads[ix >> 2]; [EOL]                     byteIx = (ix & 3); [EOL]                     ch2 = (ch2 >> ((3 - byteIx) << 3)); [EOL]                     ++ix; [EOL]                     if ((ch2 & 0xC0) != 0x080) { [EOL]                         _reportInvalidOther(ch2 & 0xFF); [EOL]                     } [EOL]                     ch = (ch << 6) | (ch2 & 0x3F); [EOL]                 } [EOL]             } [EOL]             if (needed > 2) { [EOL]                 ch -= 0x10000; [EOL]                 if (cix >= cbuf.length) { [EOL]                     cbuf = _textBuffer.expandCurrentSegment(); [EOL]                 } [EOL]                 cbuf[cix++] = (char) (0xD800 + (ch >> 10)); [EOL]                 ch = 0xDC00 | (ch & 0x03FF); [EOL]             } [EOL]         } [EOL]         if (cix >= cbuf.length) { [EOL]             cbuf = _textBuffer.expandCurrentSegment(); [EOL]         } [EOL]         cbuf[cix++] = (char) ch; [EOL]     } [EOL]     String baseName = new String(cbuf, 0, cix); [EOL]     if (lastQuadBytes < 4) { [EOL]         quads[qlen - 1] = lastQuad; [EOL]     } [EOL]     return _symbols.addName(baseName, quads, qlen); [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleUnexpectedValue(int c) throws IOException, JsonParseException { [EOL]     switch(c) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(c)) { [EOL]         _reportInvalidToken("" + ((char) c), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(c, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleApostropheValue() throws IOException, JsonParseException { [EOL]     int c = 0; [EOL]     int outPtr = 0; [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     final int[] codes = sInputCodesUtf8; [EOL]     final byte[] inputBuffer = _inputBuffer; [EOL]     main_loop: while (true) { [EOL]         ascii_loop: while (true) { [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             int max = _inputEnd; [EOL]             { [EOL]                 int max2 = _inputPtr + (outBuf.length - outPtr); [EOL]                 if (max2 < max) { [EOL]                     max = max2; [EOL]                 } [EOL]             } [EOL]             while (_inputPtr < max) { [EOL]                 c = (int) inputBuffer[_inputPtr++] & 0xFF; [EOL]                 if (c == INT_APOSTROPHE || codes[c] != 0) { [EOL]                     break ascii_loop; [EOL]                 } [EOL]                 outBuf[outPtr++] = (char) c; [EOL]             } [EOL]         } [EOL]         if (c == INT_APOSTROPHE) { [EOL]             break main_loop; [EOL]         } [EOL]         switch(codes[c]) { [EOL]             case 1: [EOL]                 if (c != INT_QUOTE) { [EOL]                     c = _decodeEscaped(); [EOL]                 } [EOL]                 break; [EOL]             case 2: [EOL]                 c = _decodeUtf8_2(c); [EOL]                 break; [EOL]             case 3: [EOL]                 if ((_inputEnd - _inputPtr) >= 2) { [EOL]                     c = _decodeUtf8_3fast(c); [EOL]                 } else { [EOL]                     c = _decodeUtf8_3(c); [EOL]                 } [EOL]                 break; [EOL]             case 4: [EOL]                 c = _decodeUtf8_4(c); [EOL]                 outBuf[outPtr++] = (char) (0xD800 | (c >> 10)); [EOL]                 if (outPtr >= outBuf.length) { [EOL]                     outBuf = _textBuffer.finishCurrentSegment(); [EOL]                     outPtr = 0; [EOL]                 } [EOL]                 c = 0xDC00 | (c & 0x3FF); [EOL]                 break; [EOL]             default: [EOL]                 if (c < INT_SPACE) { [EOL]                     _throwUnquotedSpace(c, "string value"); [EOL]                 } [EOL]                 _reportInvalidChar(c); [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = (char) c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return JsonToken.VALUE_STRING; [EOL] }
protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException { [EOL]     final int len = matchStr.length(); [EOL]     do { [EOL]         if (((_inputPtr >= _inputEnd) && !loadMore()) || (_inputBuffer[_inputPtr] != matchStr.charAt(i))) { [EOL]             _reportInvalidToken(matchStr.substring(0, i)); [EOL]         } [EOL]         ++_inputPtr; [EOL]     } while (++i < len); [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return; [EOL]     } [EOL]     int ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]     if (ch < '0' || ch == ']' || ch == '}') { [EOL]         return; [EOL]     } [EOL]     char c = (char) _decodeCharForError(ch); [EOL]     if (Character.isJavaIdentifierPart(c)) { [EOL]         _reportInvalidToken(matchStr.substring(0, i)); [EOL]     } [EOL] }
protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException { [EOL]     final int len = matchStr.length(); [EOL]     do { [EOL]         if (((_inputPtr >= _inputEnd) && !loadMore()) || (_inputBuffer[_inputPtr] != matchStr.charAt(i))) { [EOL]             _reportInvalidToken(matchStr.substring(0, i)); [EOL]         } [EOL]         ++_inputPtr; [EOL]     } while (++i < len); [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return; [EOL]     } [EOL]     int ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]     if (ch < '0' || ch == ']' || ch == '}') { [EOL]         return; [EOL]     } [EOL]     char c = (char) _decodeCharForError(ch); [EOL]     if (Character.isJavaIdentifierPart(c)) { [EOL]         _reportInvalidToken(matchStr.substring(0, i)); [EOL]     } [EOL] }
protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException { [EOL]     final int len = matchStr.length(); [EOL]     do { [EOL]         if (((_inputPtr >= _inputEnd) && !loadMore()) || (_inputBuffer[_inputPtr] != matchStr.charAt(i))) { [EOL]             _reportInvalidToken(matchStr.substring(0, i)); [EOL]         } [EOL]         ++_inputPtr; [EOL]     } while (++i < len); [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return; [EOL]     } [EOL]     int ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]     if (ch < '0' || ch == ']' || ch == '}') { [EOL]         return; [EOL]     } [EOL]     char c = (char) _decodeCharForError(ch); [EOL]     if (Character.isJavaIdentifierPart(c)) { [EOL]         _reportInvalidToken(matchStr.substring(0, i)); [EOL]     } [EOL] }
protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException { [EOL]     final int len = matchStr.length(); [EOL]     do { [EOL]         if (((_inputPtr >= _inputEnd) && !loadMore()) || (_inputBuffer[_inputPtr] != matchStr.charAt(i))) { [EOL]             _reportInvalidToken(matchStr.substring(0, i)); [EOL]         } [EOL]         ++_inputPtr; [EOL]     } while (++i < len); [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return; [EOL]     } [EOL]     int ch = _inputBuffer[_inputPtr] & 0xFF; [EOL]     if (ch < '0' || ch == ']' || ch == '}') { [EOL]         return; [EOL]     } [EOL]     char c = (char) _decodeCharForError(ch); [EOL]     if (Character.isJavaIdentifierPart(c)) { [EOL]         _reportInvalidToken(matchStr.substring(0, i)); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException { [EOL]     ByteArrayBuilder builder = _getByteArrayBuilder(); [EOL]     while (true) { [EOL]         int ch; [EOL]         do { [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             ch = (int) _inputBuffer[_inputPtr++] & 0xFF; [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (ch == INT_QUOTE) { [EOL]                 return builder.toByteArray(); [EOL]             } [EOL]             bits = _decodeBase64Escape(b64variant, ch, 0); [EOL]             if (bits < 0) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             bits = _decodeBase64Escape(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 4; [EOL]                     builder.append(decodedData); [EOL]                     return builder.toByteArray(); [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 2); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (_inputPtr >= _inputEnd) { [EOL]                     loadMoreGuaranteed(); [EOL]                 } [EOL]                 ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]                 if (!b64variant.usesPaddingChar(ch)) { [EOL]                     throw reportInvalidBase64Char(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL]                 } [EOL]                 decodedData >>= 4; [EOL]                 builder.append(decodedData); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++] & 0xFF; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 2; [EOL]                     builder.appendTwoBytes(decodedData); [EOL]                     return builder.toByteArray(); [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 3); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 decodedData >>= 2; [EOL]                 builder.appendTwoBytes(decodedData); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         builder.appendThreeBytes(decodedData); [EOL]     } [EOL] }
public UTF8Writer(IOContext ctxt, OutputStream out) { [EOL]     _context = ctxt; [EOL]     _out = out; [EOL]     _outBuffer = ctxt.allocWriteEncodingBuffer(); [EOL]     _outBufferEnd = _outBuffer.length - 4; [EOL]     _outPtr = 0; [EOL] }
public UTF8Writer(IOContext ctxt, OutputStream out) { [EOL]     _context = ctxt; [EOL]     _out = out; [EOL]     _outBuffer = ctxt.allocWriteEncodingBuffer(); [EOL]     _outBufferEnd = _outBuffer.length - 4; [EOL]     _outPtr = 0; [EOL] }
@Override [EOL] public void close() throws IOException { [EOL]     if (_out != null) { [EOL]         if (_outPtr > 0) { [EOL]             _out.write(_outBuffer, 0, _outPtr); [EOL]             _outPtr = 0; [EOL]         } [EOL]         OutputStream out = _out; [EOL]         _out = null; [EOL]         byte[] buf = _outBuffer; [EOL]         if (buf != null) { [EOL]             _outBuffer = null; [EOL]             _context.releaseWriteEncodingBuffer(buf); [EOL]         } [EOL]         out.close(); [EOL]         int code = _surrogate; [EOL]         _surrogate = 0; [EOL]         if (code > 0) { [EOL]             illegalSurrogate(code); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void close() throws IOException { [EOL]     if (_out != null) { [EOL]         if (_outPtr > 0) { [EOL]             _out.write(_outBuffer, 0, _outPtr); [EOL]             _outPtr = 0; [EOL]         } [EOL]         OutputStream out = _out; [EOL]         _out = null; [EOL]         byte[] buf = _outBuffer; [EOL]         if (buf != null) { [EOL]             _outBuffer = null; [EOL]             _context.releaseWriteEncodingBuffer(buf); [EOL]         } [EOL]         out.close(); [EOL]         int code = _surrogate; [EOL]         _surrogate = 0; [EOL]         if (code > 0) { [EOL]             illegalSurrogate(code); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void close() throws IOException { [EOL]     if (_out != null) { [EOL]         if (_outPtr > 0) { [EOL]             _out.write(_outBuffer, 0, _outPtr); [EOL]             _outPtr = 0; [EOL]         } [EOL]         OutputStream out = _out; [EOL]         _out = null; [EOL]         byte[] buf = _outBuffer; [EOL]         if (buf != null) { [EOL]             _outBuffer = null; [EOL]             _context.releaseWriteEncodingBuffer(buf); [EOL]         } [EOL]         out.close(); [EOL]         int code = _surrogate; [EOL]         _surrogate = 0; [EOL]         if (code > 0) { [EOL]             illegalSurrogate(code); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void close() throws IOException { [EOL]     if (_out != null) { [EOL]         if (_outPtr > 0) { [EOL]             _out.write(_outBuffer, 0, _outPtr); [EOL]             _outPtr = 0; [EOL]         } [EOL]         OutputStream out = _out; [EOL]         _out = null; [EOL]         byte[] buf = _outBuffer; [EOL]         if (buf != null) { [EOL]             _outBuffer = null; [EOL]             _context.releaseWriteEncodingBuffer(buf); [EOL]         } [EOL]         out.close(); [EOL]         int code = _surrogate; [EOL]         _surrogate = 0; [EOL]         if (code > 0) { [EOL]             illegalSurrogate(code); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void flush() throws IOException { [EOL]     if (_out != null) { [EOL]         if (_outPtr > 0) { [EOL]             _out.write(_outBuffer, 0, _outPtr); [EOL]             _outPtr = 0; [EOL]         } [EOL]         _out.flush(); [EOL]     } [EOL] }
@Override [EOL] public void flush() throws IOException { [EOL]     if (_out != null) { [EOL]         if (_outPtr > 0) { [EOL]             _out.write(_outBuffer, 0, _outPtr); [EOL]             _outPtr = 0; [EOL]         } [EOL]         _out.flush(); [EOL]     } [EOL] }
@Override [EOL] public void flush() throws IOException { [EOL]     if (_out != null) { [EOL]         if (_outPtr > 0) { [EOL]             _out.write(_outBuffer, 0, _outPtr); [EOL]             _outPtr = 0; [EOL]         } [EOL]         _out.flush(); [EOL]     } [EOL] }
@Override [EOL] public void write(int c) throws IOException { [EOL]     if (_surrogate > 0) { [EOL]         c = convertSurrogate(c); [EOL]     } else if (c >= SURR1_FIRST && c <= SURR2_LAST) { [EOL]         if (c > SURR1_LAST) { [EOL]             illegalSurrogate(c); [EOL]         } [EOL]         _surrogate = c; [EOL]         return; [EOL]     } [EOL]     if (_outPtr >= _outBufferEnd) { [EOL]         _out.write(_outBuffer, 0, _outPtr); [EOL]         _outPtr = 0; [EOL]     } [EOL]     if (c < 0x80) { [EOL]         _outBuffer[_outPtr++] = (byte) c; [EOL]     } else { [EOL]         int ptr = _outPtr; [EOL]         if (c < 0x800) { [EOL]             _outBuffer[ptr++] = (byte) (0xc0 | (c >> 6)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else if (c <= 0xFFFF) { [EOL]             _outBuffer[ptr++] = (byte) (0xe0 | (c >> 12)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else { [EOL]             if (c > 0x10FFFF) { [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             _outBuffer[ptr++] = (byte) (0xf0 | (c >> 18)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } [EOL]         _outPtr = ptr; [EOL]     } [EOL] }
@Override [EOL] public void write(int c) throws IOException { [EOL]     if (_surrogate > 0) { [EOL]         c = convertSurrogate(c); [EOL]     } else if (c >= SURR1_FIRST && c <= SURR2_LAST) { [EOL]         if (c > SURR1_LAST) { [EOL]             illegalSurrogate(c); [EOL]         } [EOL]         _surrogate = c; [EOL]         return; [EOL]     } [EOL]     if (_outPtr >= _outBufferEnd) { [EOL]         _out.write(_outBuffer, 0, _outPtr); [EOL]         _outPtr = 0; [EOL]     } [EOL]     if (c < 0x80) { [EOL]         _outBuffer[_outPtr++] = (byte) c; [EOL]     } else { [EOL]         int ptr = _outPtr; [EOL]         if (c < 0x800) { [EOL]             _outBuffer[ptr++] = (byte) (0xc0 | (c >> 6)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else if (c <= 0xFFFF) { [EOL]             _outBuffer[ptr++] = (byte) (0xe0 | (c >> 12)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else { [EOL]             if (c > 0x10FFFF) { [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             _outBuffer[ptr++] = (byte) (0xf0 | (c >> 18)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } [EOL]         _outPtr = ptr; [EOL]     } [EOL] }
@Override [EOL] public void write(int c) throws IOException { [EOL]     if (_surrogate > 0) { [EOL]         c = convertSurrogate(c); [EOL]     } else if (c >= SURR1_FIRST && c <= SURR2_LAST) { [EOL]         if (c > SURR1_LAST) { [EOL]             illegalSurrogate(c); [EOL]         } [EOL]         _surrogate = c; [EOL]         return; [EOL]     } [EOL]     if (_outPtr >= _outBufferEnd) { [EOL]         _out.write(_outBuffer, 0, _outPtr); [EOL]         _outPtr = 0; [EOL]     } [EOL]     if (c < 0x80) { [EOL]         _outBuffer[_outPtr++] = (byte) c; [EOL]     } else { [EOL]         int ptr = _outPtr; [EOL]         if (c < 0x800) { [EOL]             _outBuffer[ptr++] = (byte) (0xc0 | (c >> 6)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else if (c <= 0xFFFF) { [EOL]             _outBuffer[ptr++] = (byte) (0xe0 | (c >> 12)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else { [EOL]             if (c > 0x10FFFF) { [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             _outBuffer[ptr++] = (byte) (0xf0 | (c >> 18)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } [EOL]         _outPtr = ptr; [EOL]     } [EOL] }
@Override [EOL] public void write(int c) throws IOException { [EOL]     if (_surrogate > 0) { [EOL]         c = convertSurrogate(c); [EOL]     } else if (c >= SURR1_FIRST && c <= SURR2_LAST) { [EOL]         if (c > SURR1_LAST) { [EOL]             illegalSurrogate(c); [EOL]         } [EOL]         _surrogate = c; [EOL]         return; [EOL]     } [EOL]     if (_outPtr >= _outBufferEnd) { [EOL]         _out.write(_outBuffer, 0, _outPtr); [EOL]         _outPtr = 0; [EOL]     } [EOL]     if (c < 0x80) { [EOL]         _outBuffer[_outPtr++] = (byte) c; [EOL]     } else { [EOL]         int ptr = _outPtr; [EOL]         if (c < 0x800) { [EOL]             _outBuffer[ptr++] = (byte) (0xc0 | (c >> 6)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else if (c <= 0xFFFF) { [EOL]             _outBuffer[ptr++] = (byte) (0xe0 | (c >> 12)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else { [EOL]             if (c > 0x10FFFF) { [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             _outBuffer[ptr++] = (byte) (0xf0 | (c >> 18)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } [EOL]         _outPtr = ptr; [EOL]     } [EOL] }
@Override [EOL] public void write(int c) throws IOException { [EOL]     if (_surrogate > 0) { [EOL]         c = convertSurrogate(c); [EOL]     } else if (c >= SURR1_FIRST && c <= SURR2_LAST) { [EOL]         if (c > SURR1_LAST) { [EOL]             illegalSurrogate(c); [EOL]         } [EOL]         _surrogate = c; [EOL]         return; [EOL]     } [EOL]     if (_outPtr >= _outBufferEnd) { [EOL]         _out.write(_outBuffer, 0, _outPtr); [EOL]         _outPtr = 0; [EOL]     } [EOL]     if (c < 0x80) { [EOL]         _outBuffer[_outPtr++] = (byte) c; [EOL]     } else { [EOL]         int ptr = _outPtr; [EOL]         if (c < 0x800) { [EOL]             _outBuffer[ptr++] = (byte) (0xc0 | (c >> 6)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else if (c <= 0xFFFF) { [EOL]             _outBuffer[ptr++] = (byte) (0xe0 | (c >> 12)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else { [EOL]             if (c > 0x10FFFF) { [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             _outBuffer[ptr++] = (byte) (0xf0 | (c >> 18)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } [EOL]         _outPtr = ptr; [EOL]     } [EOL] }
@Override [EOL] public void write(int c) throws IOException { [EOL]     if (_surrogate > 0) { [EOL]         c = convertSurrogate(c); [EOL]     } else if (c >= SURR1_FIRST && c <= SURR2_LAST) { [EOL]         if (c > SURR1_LAST) { [EOL]             illegalSurrogate(c); [EOL]         } [EOL]         _surrogate = c; [EOL]         return; [EOL]     } [EOL]     if (_outPtr >= _outBufferEnd) { [EOL]         _out.write(_outBuffer, 0, _outPtr); [EOL]         _outPtr = 0; [EOL]     } [EOL]     if (c < 0x80) { [EOL]         _outBuffer[_outPtr++] = (byte) c; [EOL]     } else { [EOL]         int ptr = _outPtr; [EOL]         if (c < 0x800) { [EOL]             _outBuffer[ptr++] = (byte) (0xc0 | (c >> 6)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else if (c <= 0xFFFF) { [EOL]             _outBuffer[ptr++] = (byte) (0xe0 | (c >> 12)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else { [EOL]             if (c > 0x10FFFF) { [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             _outBuffer[ptr++] = (byte) (0xf0 | (c >> 18)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } [EOL]         _outPtr = ptr; [EOL]     } [EOL] }
@Override [EOL] public void write(int c) throws IOException { [EOL]     if (_surrogate > 0) { [EOL]         c = convertSurrogate(c); [EOL]     } else if (c >= SURR1_FIRST && c <= SURR2_LAST) { [EOL]         if (c > SURR1_LAST) { [EOL]             illegalSurrogate(c); [EOL]         } [EOL]         _surrogate = c; [EOL]         return; [EOL]     } [EOL]     if (_outPtr >= _outBufferEnd) { [EOL]         _out.write(_outBuffer, 0, _outPtr); [EOL]         _outPtr = 0; [EOL]     } [EOL]     if (c < 0x80) { [EOL]         _outBuffer[_outPtr++] = (byte) c; [EOL]     } else { [EOL]         int ptr = _outPtr; [EOL]         if (c < 0x800) { [EOL]             _outBuffer[ptr++] = (byte) (0xc0 | (c >> 6)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else if (c <= 0xFFFF) { [EOL]             _outBuffer[ptr++] = (byte) (0xe0 | (c >> 12)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else { [EOL]             if (c > 0x10FFFF) { [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             _outBuffer[ptr++] = (byte) (0xf0 | (c >> 18)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } [EOL]         _outPtr = ptr; [EOL]     } [EOL] }
@Override [EOL] public void write(int c) throws IOException { [EOL]     if (_surrogate > 0) { [EOL]         c = convertSurrogate(c); [EOL]     } else if (c >= SURR1_FIRST && c <= SURR2_LAST) { [EOL]         if (c > SURR1_LAST) { [EOL]             illegalSurrogate(c); [EOL]         } [EOL]         _surrogate = c; [EOL]         return; [EOL]     } [EOL]     if (_outPtr >= _outBufferEnd) { [EOL]         _out.write(_outBuffer, 0, _outPtr); [EOL]         _outPtr = 0; [EOL]     } [EOL]     if (c < 0x80) { [EOL]         _outBuffer[_outPtr++] = (byte) c; [EOL]     } else { [EOL]         int ptr = _outPtr; [EOL]         if (c < 0x800) { [EOL]             _outBuffer[ptr++] = (byte) (0xc0 | (c >> 6)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else if (c <= 0xFFFF) { [EOL]             _outBuffer[ptr++] = (byte) (0xe0 | (c >> 12)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else { [EOL]             if (c > 0x10FFFF) { [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             _outBuffer[ptr++] = (byte) (0xf0 | (c >> 18)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } [EOL]         _outPtr = ptr; [EOL]     } [EOL] }
@Override [EOL] public void write(int c) throws IOException { [EOL]     if (_surrogate > 0) { [EOL]         c = convertSurrogate(c); [EOL]     } else if (c >= SURR1_FIRST && c <= SURR2_LAST) { [EOL]         if (c > SURR1_LAST) { [EOL]             illegalSurrogate(c); [EOL]         } [EOL]         _surrogate = c; [EOL]         return; [EOL]     } [EOL]     if (_outPtr >= _outBufferEnd) { [EOL]         _out.write(_outBuffer, 0, _outPtr); [EOL]         _outPtr = 0; [EOL]     } [EOL]     if (c < 0x80) { [EOL]         _outBuffer[_outPtr++] = (byte) c; [EOL]     } else { [EOL]         int ptr = _outPtr; [EOL]         if (c < 0x800) { [EOL]             _outBuffer[ptr++] = (byte) (0xc0 | (c >> 6)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else if (c <= 0xFFFF) { [EOL]             _outBuffer[ptr++] = (byte) (0xe0 | (c >> 12)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } else { [EOL]             if (c > 0x10FFFF) { [EOL]                 illegalSurrogate(c); [EOL]             } [EOL]             _outBuffer[ptr++] = (byte) (0xf0 | (c >> 18)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | ((c >> 12) & 0x3f)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | ((c >> 6) & 0x3f)); [EOL]             _outBuffer[ptr++] = (byte) (0x80 | (c & 0x3f)); [EOL]         } [EOL]         _outPtr = ptr; [EOL]     } [EOL] }
public SerializedString(String v) { [EOL]     if (v == null) { [EOL]         throw new IllegalStateException("Null String illegal for SerializedString"); [EOL]     } [EOL]     _value = v; [EOL] }
public SerializedString(String v) { [EOL]     if (v == null) { [EOL]         throw new IllegalStateException("Null String illegal for SerializedString"); [EOL]     } [EOL]     _value = v; [EOL] }
@Override [EOL] public final String getValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public final char[] asQuotedChars() { [EOL]     char[] result = _quotedChars; [EOL]     if (result == null) { [EOL]         result = JsonStringEncoder.getInstance().quoteAsString(_value); [EOL]         _quotedChars = result; [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public final char[] asQuotedChars() { [EOL]     char[] result = _quotedChars; [EOL]     if (result == null) { [EOL]         result = JsonStringEncoder.getInstance().quoteAsString(_value); [EOL]         _quotedChars = result; [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public final byte[] asUnquotedUTF8() { [EOL]     byte[] result = _unquotedUTF8Ref; [EOL]     if (result == null) { [EOL]         result = JsonStringEncoder.getInstance().encodeAsUTF8(_value); [EOL]         _unquotedUTF8Ref = result; [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public int appendQuotedUTF8(byte[] buffer, int offset) { [EOL]     byte[] result = _quotedUTF8Ref; [EOL]     if (result == null) { [EOL]         result = JsonStringEncoder.getInstance().quoteAsUTF8(_value); [EOL]         _quotedUTF8Ref = result; [EOL]     } [EOL]     final int length = result.length; [EOL]     if ((offset + length) > buffer.length) { [EOL]         return -1; [EOL]     } [EOL]     System.arraycopy(result, 0, buffer, offset, length); [EOL]     return length; [EOL] }
@Override [EOL] public int appendQuotedUTF8(byte[] buffer, int offset) { [EOL]     byte[] result = _quotedUTF8Ref; [EOL]     if (result == null) { [EOL]         result = JsonStringEncoder.getInstance().quoteAsUTF8(_value); [EOL]         _quotedUTF8Ref = result; [EOL]     } [EOL]     final int length = result.length; [EOL]     if ((offset + length) > buffer.length) { [EOL]         return -1; [EOL]     } [EOL]     System.arraycopy(result, 0, buffer, offset, length); [EOL]     return length; [EOL] }
@Override [EOL] public int appendQuoted(char[] buffer, int offset) { [EOL]     char[] result = _quotedChars; [EOL]     if (result == null) { [EOL]         result = JsonStringEncoder.getInstance().quoteAsString(_value); [EOL]         _quotedChars = result; [EOL]     } [EOL]     final int length = result.length; [EOL]     if ((offset + length) > buffer.length) { [EOL]         return -1; [EOL]     } [EOL]     System.arraycopy(result, 0, buffer, offset, length); [EOL]     return length; [EOL] }
@Override [EOL] public int appendQuoted(char[] buffer, int offset) { [EOL]     char[] result = _quotedChars; [EOL]     if (result == null) { [EOL]         result = JsonStringEncoder.getInstance().quoteAsString(_value); [EOL]         _quotedChars = result; [EOL]     } [EOL]     final int length = result.length; [EOL]     if ((offset + length) > buffer.length) { [EOL]         return -1; [EOL]     } [EOL]     System.arraycopy(result, 0, buffer, offset, length); [EOL]     return length; [EOL] }
@Override [EOL] public int appendQuoted(char[] buffer, int offset) { [EOL]     char[] result = _quotedChars; [EOL]     if (result == null) { [EOL]         result = JsonStringEncoder.getInstance().quoteAsString(_value); [EOL]         _quotedChars = result; [EOL]     } [EOL]     final int length = result.length; [EOL]     if ((offset + length) > buffer.length) { [EOL]         return -1; [EOL]     } [EOL]     System.arraycopy(result, 0, buffer, offset, length); [EOL]     return length; [EOL] }
@Override [EOL] public int appendUnquotedUTF8(byte[] buffer, int offset) { [EOL]     byte[] result = _unquotedUTF8Ref; [EOL]     if (result == null) { [EOL]         result = JsonStringEncoder.getInstance().encodeAsUTF8(_value); [EOL]         _unquotedUTF8Ref = result; [EOL]     } [EOL]     final int length = result.length; [EOL]     if ((offset + length) > buffer.length) { [EOL]         return -1; [EOL]     } [EOL]     System.arraycopy(result, 0, buffer, offset, length); [EOL]     return length; [EOL] }
@Override [EOL] public int appendUnquotedUTF8(byte[] buffer, int offset) { [EOL]     byte[] result = _unquotedUTF8Ref; [EOL]     if (result == null) { [EOL]         result = JsonStringEncoder.getInstance().encodeAsUTF8(_value); [EOL]         _unquotedUTF8Ref = result; [EOL]     } [EOL]     final int length = result.length; [EOL]     if ((offset + length) > buffer.length) { [EOL]         return -1; [EOL]     } [EOL]     System.arraycopy(result, 0, buffer, offset, length); [EOL]     return length; [EOL] }
@Override [EOL] public int appendUnquoted(char[] buffer, int offset) { [EOL]     String str = _value; [EOL]     final int length = str.length(); [EOL]     if ((offset + length) > buffer.length) { [EOL]         return -1; [EOL]     } [EOL]     str.getChars(0, length, buffer, offset); [EOL]     return length; [EOL] }
@Override [EOL] public int appendUnquoted(char[] buffer, int offset) { [EOL]     String str = _value; [EOL]     final int length = str.length(); [EOL]     if ((offset + length) > buffer.length) { [EOL]         return -1; [EOL]     } [EOL]     str.getChars(0, length, buffer, offset); [EOL]     return length; [EOL] }
@Override [EOL] public int appendUnquoted(char[] buffer, int offset) { [EOL]     String str = _value; [EOL]     final int length = str.length(); [EOL]     if ((offset + length) > buffer.length) { [EOL]         return -1; [EOL]     } [EOL]     str.getChars(0, length, buffer, offset); [EOL]     return length; [EOL] }
@Override [EOL] public int writeQuotedUTF8(OutputStream out) throws IOException { [EOL]     byte[] result = _quotedUTF8Ref; [EOL]     if (result == null) { [EOL]         result = JsonStringEncoder.getInstance().quoteAsUTF8(_value); [EOL]         _quotedUTF8Ref = result; [EOL]     } [EOL]     final int length = result.length; [EOL]     out.write(result, 0, length); [EOL]     return length; [EOL] }
@Override [EOL] public int writeQuotedUTF8(OutputStream out) throws IOException { [EOL]     byte[] result = _quotedUTF8Ref; [EOL]     if (result == null) { [EOL]         result = JsonStringEncoder.getInstance().quoteAsUTF8(_value); [EOL]         _quotedUTF8Ref = result; [EOL]     } [EOL]     final int length = result.length; [EOL]     out.write(result, 0, length); [EOL]     return length; [EOL] }
@Override [EOL] public int writeUnquotedUTF8(OutputStream out) throws IOException { [EOL]     byte[] result = _unquotedUTF8Ref; [EOL]     if (result == null) { [EOL]         result = JsonStringEncoder.getInstance().encodeAsUTF8(_value); [EOL]         _unquotedUTF8Ref = result; [EOL]     } [EOL]     final int length = result.length; [EOL]     out.write(result, 0, length); [EOL]     return length; [EOL] }
@Override [EOL] public int writeUnquotedUTF8(OutputStream out) throws IOException { [EOL]     byte[] result = _unquotedUTF8Ref; [EOL]     if (result == null) { [EOL]         result = JsonStringEncoder.getInstance().encodeAsUTF8(_value); [EOL]         _unquotedUTF8Ref = result; [EOL]     } [EOL]     final int length = result.length; [EOL]     out.write(result, 0, length); [EOL]     return length; [EOL] }
@Override [EOL] public int putQuotedUTF8(ByteBuffer buffer) { [EOL]     byte[] result = _quotedUTF8Ref; [EOL]     if (result == null) { [EOL]         result = JsonStringEncoder.getInstance().quoteAsUTF8(_value); [EOL]         _quotedUTF8Ref = result; [EOL]     } [EOL]     final int length = result.length; [EOL]     if (length > buffer.remaining()) { [EOL]         return -1; [EOL]     } [EOL]     buffer.put(result, 0, length); [EOL]     return length; [EOL] }
@Override [EOL] public int putQuotedUTF8(ByteBuffer buffer) { [EOL]     byte[] result = _quotedUTF8Ref; [EOL]     if (result == null) { [EOL]         result = JsonStringEncoder.getInstance().quoteAsUTF8(_value); [EOL]         _quotedUTF8Ref = result; [EOL]     } [EOL]     final int length = result.length; [EOL]     if (length > buffer.remaining()) { [EOL]         return -1; [EOL]     } [EOL]     buffer.put(result, 0, length); [EOL]     return length; [EOL] }
@Override [EOL] public int putQuotedUTF8(ByteBuffer buffer) { [EOL]     byte[] result = _quotedUTF8Ref; [EOL]     if (result == null) { [EOL]         result = JsonStringEncoder.getInstance().quoteAsUTF8(_value); [EOL]         _quotedUTF8Ref = result; [EOL]     } [EOL]     final int length = result.length; [EOL]     if (length > buffer.remaining()) { [EOL]         return -1; [EOL]     } [EOL]     buffer.put(result, 0, length); [EOL]     return length; [EOL] }
@Override [EOL] public int putUnquotedUTF8(ByteBuffer buffer) { [EOL]     byte[] result = _unquotedUTF8Ref; [EOL]     if (result == null) { [EOL]         result = JsonStringEncoder.getInstance().encodeAsUTF8(_value); [EOL]         _unquotedUTF8Ref = result; [EOL]     } [EOL]     final int length = result.length; [EOL]     if (length > buffer.remaining()) { [EOL]         return -1; [EOL]     } [EOL]     buffer.put(result, 0, length); [EOL]     return length; [EOL] }
@Override [EOL] public int putUnquotedUTF8(ByteBuffer buffer) { [EOL]     byte[] result = _unquotedUTF8Ref; [EOL]     if (result == null) { [EOL]         result = JsonStringEncoder.getInstance().encodeAsUTF8(_value); [EOL]         _unquotedUTF8Ref = result; [EOL]     } [EOL]     final int length = result.length; [EOL]     if (length > buffer.remaining()) { [EOL]         return -1; [EOL]     } [EOL]     buffer.put(result, 0, length); [EOL]     return length; [EOL] }
@Override [EOL] public final String toString() { [EOL]     return _value; [EOL] }
public void setEncoding(JsonEncoding enc) { [EOL]     _encoding = enc; [EOL] }
public void setEncoding(JsonEncoding enc) { [EOL]     _encoding = enc; [EOL] }
public void setEncoding(JsonEncoding enc) { [EOL]     _encoding = enc; [EOL] }
public void setEncoding(JsonEncoding enc) { [EOL]     _encoding = enc; [EOL] }
public void setEncoding(JsonEncoding enc) { [EOL]     _encoding = enc; [EOL] }
public void setEncoding(JsonEncoding enc) { [EOL]     _encoding = enc; [EOL] }
public void setEncoding(JsonEncoding enc) { [EOL]     _encoding = enc; [EOL] }
public boolean isResourceManaged() { [EOL]     return _managedResource; [EOL] }
public boolean isResourceManaged() { [EOL]     return _managedResource; [EOL] }
public TextBuffer constructTextBuffer() { [EOL]     return new TextBuffer(_bufferRecycler); [EOL] }
public void releaseReadIOBuffer(byte[] buf) { [EOL]     if (buf != null) { [EOL]         _verifyRelease(buf, _readIOBuffer); [EOL]         _readIOBuffer = null; [EOL]         _bufferRecycler.releaseByteBuffer(BufferRecycler.ByteBufferType.READ_IO_BUFFER, buf); [EOL]     } [EOL] }
public void releaseReadIOBuffer(byte[] buf) { [EOL]     if (buf != null) { [EOL]         _verifyRelease(buf, _readIOBuffer); [EOL]         _readIOBuffer = null; [EOL]         _bufferRecycler.releaseByteBuffer(BufferRecycler.ByteBufferType.READ_IO_BUFFER, buf); [EOL]     } [EOL] }
public void releaseTokenBuffer(char[] buf) { [EOL]     if (buf != null) { [EOL]         _verifyRelease(buf, _tokenCBuffer); [EOL]         _tokenCBuffer = null; [EOL]         _bufferRecycler.releaseCharBuffer(BufferRecycler.CharBufferType.TOKEN_BUFFER, buf); [EOL]     } [EOL] }
public void releaseTokenBuffer(char[] buf) { [EOL]     if (buf != null) { [EOL]         _verifyRelease(buf, _tokenCBuffer); [EOL]         _tokenCBuffer = null; [EOL]         _bufferRecycler.releaseCharBuffer(BufferRecycler.CharBufferType.TOKEN_BUFFER, buf); [EOL]     } [EOL] }
public static int[] standardAsciiEscapesForJSON() { [EOL]     int[] esc = CharTypes.get7BitOutputEscapes(); [EOL]     return Arrays.copyOf(esc, esc.length); [EOL] }
static Name1 getEmptyName() { [EOL]     return sEmptyName; [EOL] }
@Override [EOL] public boolean equals(int quad1, int quad2) { [EOL]     return (quad1 == mQuad) && (quad2 == 0); [EOL] }
@Override [EOL] public boolean equals(int quad1, int quad2) { [EOL]     return (quad1 == mQuad) && (quad2 == 0); [EOL] }
@Override [EOL] public boolean equals(int quad1, int quad2) { [EOL]     return (quad1 == mQuad) && (quad2 == 0); [EOL] }
@Override [EOL] public boolean equals(int quad1, int quad2) { [EOL]     return (quad1 == mQuad) && (quad2 == 0); [EOL] }
@Override [EOL] public boolean equals(int quad1, int quad2) { [EOL]     return (quad1 == mQuad) && (quad2 == 0); [EOL] }
public DataFormatDetector(JsonFactory... detectors) { [EOL]     this(detectors, MatchStrength.SOLID_MATCH, MatchStrength.WEAK_MATCH, DEFAULT_MAX_INPUT_LOOKAHEAD); [EOL] }
public DataFormatDetector(JsonFactory... detectors) { [EOL]     this(detectors, MatchStrength.SOLID_MATCH, MatchStrength.WEAK_MATCH, DEFAULT_MAX_INPUT_LOOKAHEAD); [EOL] }
public DataFormatDetector(JsonFactory... detectors) { [EOL]     this(detectors, MatchStrength.SOLID_MATCH, MatchStrength.WEAK_MATCH, DEFAULT_MAX_INPUT_LOOKAHEAD); [EOL] }
public DataFormatDetector(JsonFactory... detectors) { [EOL]     this(detectors, MatchStrength.SOLID_MATCH, MatchStrength.WEAK_MATCH, DEFAULT_MAX_INPUT_LOOKAHEAD); [EOL] }
private DataFormatDetector(JsonFactory[] detectors, MatchStrength optMatch, MatchStrength minMatch, int maxInputLookahead) { [EOL]     _detectors = detectors; [EOL]     _optimalMatch = optMatch; [EOL]     _minimalMatch = minMatch; [EOL]     _maxInputLookahead = maxInputLookahead; [EOL] }
public DataFormatMatcher findFormat(InputStream in) throws IOException { [EOL]     return _findFormat(new InputAccessor.Std(in, new byte[_maxInputLookahead])); [EOL] }
public DataFormatMatcher findFormat(InputStream in) throws IOException { [EOL]     return _findFormat(new InputAccessor.Std(in, new byte[_maxInputLookahead])); [EOL] }
public DataFormatMatcher findFormat(InputStream in) throws IOException { [EOL]     return _findFormat(new InputAccessor.Std(in, new byte[_maxInputLookahead])); [EOL] }
private DataFormatMatcher _findFormat(InputAccessor.Std acc) throws IOException { [EOL]     JsonFactory bestMatch = null; [EOL]     MatchStrength bestMatchStrength = null; [EOL]     for (JsonFactory f : _detectors) { [EOL]         acc.reset(); [EOL]         MatchStrength strength = f.hasFormat(acc); [EOL]         if (strength == null || strength.ordinal() < _minimalMatch.ordinal()) { [EOL]             continue; [EOL]         } [EOL]         if (bestMatch != null) { [EOL]             if (bestMatchStrength.ordinal() >= strength.ordinal()) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         bestMatch = f; [EOL]         bestMatchStrength = strength; [EOL]         if (strength.ordinal() >= _optimalMatch.ordinal()) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return acc.createMatcher(bestMatch, bestMatchStrength); [EOL] }
private DataFormatMatcher _findFormat(InputAccessor.Std acc) throws IOException { [EOL]     JsonFactory bestMatch = null; [EOL]     MatchStrength bestMatchStrength = null; [EOL]     for (JsonFactory f : _detectors) { [EOL]         acc.reset(); [EOL]         MatchStrength strength = f.hasFormat(acc); [EOL]         if (strength == null || strength.ordinal() < _minimalMatch.ordinal()) { [EOL]             continue; [EOL]         } [EOL]         if (bestMatch != null) { [EOL]             if (bestMatchStrength.ordinal() >= strength.ordinal()) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         bestMatch = f; [EOL]         bestMatchStrength = strength; [EOL]         if (strength.ordinal() >= _optimalMatch.ordinal()) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return acc.createMatcher(bestMatch, bestMatchStrength); [EOL] }
private DataFormatMatcher _findFormat(InputAccessor.Std acc) throws IOException { [EOL]     JsonFactory bestMatch = null; [EOL]     MatchStrength bestMatchStrength = null; [EOL]     for (JsonFactory f : _detectors) { [EOL]         acc.reset(); [EOL]         MatchStrength strength = f.hasFormat(acc); [EOL]         if (strength == null || strength.ordinal() < _minimalMatch.ordinal()) { [EOL]             continue; [EOL]         } [EOL]         if (bestMatch != null) { [EOL]             if (bestMatchStrength.ordinal() >= strength.ordinal()) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         bestMatch = f; [EOL]         bestMatchStrength = strength; [EOL]         if (strength.ordinal() >= _optimalMatch.ordinal()) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return acc.createMatcher(bestMatch, bestMatchStrength); [EOL] }
private DataFormatMatcher _findFormat(InputAccessor.Std acc) throws IOException { [EOL]     JsonFactory bestMatch = null; [EOL]     MatchStrength bestMatchStrength = null; [EOL]     for (JsonFactory f : _detectors) { [EOL]         acc.reset(); [EOL]         MatchStrength strength = f.hasFormat(acc); [EOL]         if (strength == null || strength.ordinal() < _minimalMatch.ordinal()) { [EOL]             continue; [EOL]         } [EOL]         if (bestMatch != null) { [EOL]             if (bestMatchStrength.ordinal() >= strength.ordinal()) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         bestMatch = f; [EOL]         bestMatchStrength = strength; [EOL]         if (strength.ordinal() >= _optimalMatch.ordinal()) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return acc.createMatcher(bestMatch, bestMatchStrength); [EOL] }
private DataFormatMatcher _findFormat(InputAccessor.Std acc) throws IOException { [EOL]     JsonFactory bestMatch = null; [EOL]     MatchStrength bestMatchStrength = null; [EOL]     for (JsonFactory f : _detectors) { [EOL]         acc.reset(); [EOL]         MatchStrength strength = f.hasFormat(acc); [EOL]         if (strength == null || strength.ordinal() < _minimalMatch.ordinal()) { [EOL]             continue; [EOL]         } [EOL]         if (bestMatch != null) { [EOL]             if (bestMatchStrength.ordinal() >= strength.ordinal()) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         bestMatch = f; [EOL]         bestMatchStrength = strength; [EOL]         if (strength.ordinal() >= _optimalMatch.ordinal()) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return acc.createMatcher(bestMatch, bestMatchStrength); [EOL] }
private DataFormatMatcher _findFormat(InputAccessor.Std acc) throws IOException { [EOL]     JsonFactory bestMatch = null; [EOL]     MatchStrength bestMatchStrength = null; [EOL]     for (JsonFactory f : _detectors) { [EOL]         acc.reset(); [EOL]         MatchStrength strength = f.hasFormat(acc); [EOL]         if (strength == null || strength.ordinal() < _minimalMatch.ordinal()) { [EOL]             continue; [EOL]         } [EOL]         if (bestMatch != null) { [EOL]             if (bestMatchStrength.ordinal() >= strength.ordinal()) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         bestMatch = f; [EOL]         bestMatchStrength = strength; [EOL]         if (strength.ordinal() >= _optimalMatch.ordinal()) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     return acc.createMatcher(bestMatch, bestMatchStrength); [EOL] }
public String asString() { [EOL]     return _serialized; [EOL] }
protected JsonParser() { [EOL] }
public boolean getBooleanValue() throws IOException, JsonParseException { [EOL]     JsonToken t = getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) [EOL]         return true; [EOL]     if (t == JsonToken.VALUE_FALSE) [EOL]         return false; [EOL]     throw new JsonParseException("Current token (" + t + ") not of boolean type", getCurrentLocation()); [EOL] }
public boolean getBooleanValue() throws IOException, JsonParseException { [EOL]     JsonToken t = getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) [EOL]         return true; [EOL]     if (t == JsonToken.VALUE_FALSE) [EOL]         return false; [EOL]     throw new JsonParseException("Current token (" + t + ") not of boolean type", getCurrentLocation()); [EOL] }
public long getValueAsLong() throws IOException, JsonParseException { [EOL]     return getValueAsLong(0); [EOL] }
public long getValueAsLong() throws IOException, JsonParseException { [EOL]     return getValueAsLong(0); [EOL] }
public double getValueAsDouble() throws IOException, JsonParseException { [EOL]     return getValueAsDouble(0.0); [EOL] }
public double getValueAsDouble() throws IOException, JsonParseException { [EOL]     return getValueAsDouble(0.0); [EOL] }
public boolean getValueAsBoolean() throws IOException, JsonParseException { [EOL]     return getValueAsBoolean(false); [EOL] }
@Override [EOL] public JsonGenerator setCharacterEscapes(CharacterEscapes esc) { [EOL]     _characterEscapes = esc; [EOL]     if (esc == null) { [EOL]         _outputEscapes = sOutputEscapes; [EOL]     } else { [EOL]         _outputEscapes = esc.getEscapeCodesForAscii(); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonGenerator setCharacterEscapes(CharacterEscapes esc) { [EOL]     _characterEscapes = esc; [EOL]     if (esc == null) { [EOL]         _outputEscapes = sOutputEscapes; [EOL]     } else { [EOL]         _outputEscapes = esc.getEscapeCodesForAscii(); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public final void writeStringField(String fieldName, String value) throws IOException, JsonGenerationException { [EOL]     writeFieldName(fieldName); [EOL]     writeString(value); [EOL] }
@Override [EOL] public final void writeStringField(String fieldName, String value) throws IOException, JsonGenerationException { [EOL]     writeFieldName(fieldName); [EOL]     writeString(value); [EOL] }
@Override [EOL] public final void writeStringField(String fieldName, String value) throws IOException, JsonGenerationException { [EOL]     writeFieldName(fieldName); [EOL]     writeString(value); [EOL] }
public void releaseBuffers() { [EOL]     if (_allocator == null) { [EOL]         resetWithEmpty(); [EOL]     } else { [EOL]         if (_currentSegment != null) { [EOL]             resetWithEmpty(); [EOL]             char[] buf = _currentSegment; [EOL]             _currentSegment = null; [EOL]             _allocator.releaseCharBuffer(BufferRecycler.CharBufferType.TEXT_BUFFER, buf); [EOL]         } [EOL]     } [EOL] }
public void releaseBuffers() { [EOL]     if (_allocator == null) { [EOL]         resetWithEmpty(); [EOL]     } else { [EOL]         if (_currentSegment != null) { [EOL]             resetWithEmpty(); [EOL]             char[] buf = _currentSegment; [EOL]             _currentSegment = null; [EOL]             _allocator.releaseCharBuffer(BufferRecycler.CharBufferType.TEXT_BUFFER, buf); [EOL]         } [EOL]     } [EOL] }
public void releaseBuffers() { [EOL]     if (_allocator == null) { [EOL]         resetWithEmpty(); [EOL]     } else { [EOL]         if (_currentSegment != null) { [EOL]             resetWithEmpty(); [EOL]             char[] buf = _currentSegment; [EOL]             _currentSegment = null; [EOL]             _allocator.releaseCharBuffer(BufferRecycler.CharBufferType.TEXT_BUFFER, buf); [EOL]         } [EOL]     } [EOL] }
public void resetWithEmpty() { [EOL]     _inputStart = -1; [EOL]     _currentSize = 0; [EOL]     _inputLen = 0; [EOL]     _inputBuffer = null; [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } [EOL] }
public void resetWithEmpty() { [EOL]     _inputStart = -1; [EOL]     _currentSize = 0; [EOL]     _inputLen = 0; [EOL]     _inputBuffer = null; [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } [EOL] }
private char[] findBuffer(int needed) { [EOL]     if (_allocator != null) { [EOL]         return _allocator.allocCharBuffer(BufferRecycler.CharBufferType.TEXT_BUFFER, needed); [EOL]     } [EOL]     return new char[Math.max(needed, MIN_SEGMENT_LEN)]; [EOL] }
public int getTextOffset() { [EOL]     return (_inputStart >= 0) ? _inputStart : 0; [EOL] }
public char[] getTextBuffer() { [EOL]     if (_inputStart >= 0) { [EOL]         return _inputBuffer; [EOL]     } [EOL]     if (_resultArray != null) { [EOL]         return _resultArray; [EOL]     } [EOL]     if (_resultString != null) { [EOL]         return (_resultArray = _resultString.toCharArray()); [EOL]     } [EOL]     if (!_hasSegments) { [EOL]         return _currentSegment; [EOL]     } [EOL]     return contentsAsArray(); [EOL] }
public char[] getTextBuffer() { [EOL]     if (_inputStart >= 0) { [EOL]         return _inputBuffer; [EOL]     } [EOL]     if (_resultArray != null) { [EOL]         return _resultArray; [EOL]     } [EOL]     if (_resultString != null) { [EOL]         return (_resultArray = _resultString.toCharArray()); [EOL]     } [EOL]     if (!_hasSegments) { [EOL]         return _currentSegment; [EOL]     } [EOL]     return contentsAsArray(); [EOL] }
public char[] getTextBuffer() { [EOL]     if (_inputStart >= 0) { [EOL]         return _inputBuffer; [EOL]     } [EOL]     if (_resultArray != null) { [EOL]         return _resultArray; [EOL]     } [EOL]     if (_resultString != null) { [EOL]         return (_resultArray = _resultString.toCharArray()); [EOL]     } [EOL]     if (!_hasSegments) { [EOL]         return _currentSegment; [EOL]     } [EOL]     return contentsAsArray(); [EOL] }
public char[] getTextBuffer() { [EOL]     if (_inputStart >= 0) { [EOL]         return _inputBuffer; [EOL]     } [EOL]     if (_resultArray != null) { [EOL]         return _resultArray; [EOL]     } [EOL]     if (_resultString != null) { [EOL]         return (_resultArray = _resultString.toCharArray()); [EOL]     } [EOL]     if (!_hasSegments) { [EOL]         return _currentSegment; [EOL]     } [EOL]     return contentsAsArray(); [EOL] }
public char[] getTextBuffer() { [EOL]     if (_inputStart >= 0) { [EOL]         return _inputBuffer; [EOL]     } [EOL]     if (_resultArray != null) { [EOL]         return _resultArray; [EOL]     } [EOL]     if (_resultString != null) { [EOL]         return (_resultArray = _resultString.toCharArray()); [EOL]     } [EOL]     if (!_hasSegments) { [EOL]         return _currentSegment; [EOL]     } [EOL]     return contentsAsArray(); [EOL] }
public String contentsAsString() { [EOL]     if (_resultString == null) { [EOL]         if (_resultArray != null) { [EOL]             _resultString = new String(_resultArray); [EOL]         } else { [EOL]             if (_inputStart >= 0) { [EOL]                 if (_inputLen < 1) { [EOL]                     return (_resultString = ""); [EOL]                 } [EOL]                 _resultString = new String(_inputBuffer, _inputStart, _inputLen); [EOL]             } else { [EOL]                 int segLen = _segmentSize; [EOL]                 int currLen = _currentSize; [EOL]                 if (segLen == 0) { [EOL]                     _resultString = (currLen == 0) ? "" : new String(_currentSegment, 0, currLen); [EOL]                 } else { [EOL]                     StringBuilder sb = new StringBuilder(segLen + currLen); [EOL]                     if (_segments != null) { [EOL]                         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]                             char[] curr = _segments.get(i); [EOL]                             sb.append(curr, 0, curr.length); [EOL]                         } [EOL]                     } [EOL]                     sb.append(_currentSegment, 0, _currentSize); [EOL]                     _resultString = sb.toString(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _resultString; [EOL] }
public String contentsAsString() { [EOL]     if (_resultString == null) { [EOL]         if (_resultArray != null) { [EOL]             _resultString = new String(_resultArray); [EOL]         } else { [EOL]             if (_inputStart >= 0) { [EOL]                 if (_inputLen < 1) { [EOL]                     return (_resultString = ""); [EOL]                 } [EOL]                 _resultString = new String(_inputBuffer, _inputStart, _inputLen); [EOL]             } else { [EOL]                 int segLen = _segmentSize; [EOL]                 int currLen = _currentSize; [EOL]                 if (segLen == 0) { [EOL]                     _resultString = (currLen == 0) ? "" : new String(_currentSegment, 0, currLen); [EOL]                 } else { [EOL]                     StringBuilder sb = new StringBuilder(segLen + currLen); [EOL]                     if (_segments != null) { [EOL]                         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]                             char[] curr = _segments.get(i); [EOL]                             sb.append(curr, 0, curr.length); [EOL]                         } [EOL]                     } [EOL]                     sb.append(_currentSegment, 0, _currentSize); [EOL]                     _resultString = sb.toString(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _resultString; [EOL] }
public String contentsAsString() { [EOL]     if (_resultString == null) { [EOL]         if (_resultArray != null) { [EOL]             _resultString = new String(_resultArray); [EOL]         } else { [EOL]             if (_inputStart >= 0) { [EOL]                 if (_inputLen < 1) { [EOL]                     return (_resultString = ""); [EOL]                 } [EOL]                 _resultString = new String(_inputBuffer, _inputStart, _inputLen); [EOL]             } else { [EOL]                 int segLen = _segmentSize; [EOL]                 int currLen = _currentSize; [EOL]                 if (segLen == 0) { [EOL]                     _resultString = (currLen == 0) ? "" : new String(_currentSegment, 0, currLen); [EOL]                 } else { [EOL]                     StringBuilder sb = new StringBuilder(segLen + currLen); [EOL]                     if (_segments != null) { [EOL]                         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]                             char[] curr = _segments.get(i); [EOL]                             sb.append(curr, 0, curr.length); [EOL]                         } [EOL]                     } [EOL]                     sb.append(_currentSegment, 0, _currentSize); [EOL]                     _resultString = sb.toString(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _resultString; [EOL] }
public String contentsAsString() { [EOL]     if (_resultString == null) { [EOL]         if (_resultArray != null) { [EOL]             _resultString = new String(_resultArray); [EOL]         } else { [EOL]             if (_inputStart >= 0) { [EOL]                 if (_inputLen < 1) { [EOL]                     return (_resultString = ""); [EOL]                 } [EOL]                 _resultString = new String(_inputBuffer, _inputStart, _inputLen); [EOL]             } else { [EOL]                 int segLen = _segmentSize; [EOL]                 int currLen = _currentSize; [EOL]                 if (segLen == 0) { [EOL]                     _resultString = (currLen == 0) ? "" : new String(_currentSegment, 0, currLen); [EOL]                 } else { [EOL]                     StringBuilder sb = new StringBuilder(segLen + currLen); [EOL]                     if (_segments != null) { [EOL]                         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]                             char[] curr = _segments.get(i); [EOL]                             sb.append(curr, 0, curr.length); [EOL]                         } [EOL]                     } [EOL]                     sb.append(_currentSegment, 0, _currentSize); [EOL]                     _resultString = sb.toString(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _resultString; [EOL] }
public String contentsAsString() { [EOL]     if (_resultString == null) { [EOL]         if (_resultArray != null) { [EOL]             _resultString = new String(_resultArray); [EOL]         } else { [EOL]             if (_inputStart >= 0) { [EOL]                 if (_inputLen < 1) { [EOL]                     return (_resultString = ""); [EOL]                 } [EOL]                 _resultString = new String(_inputBuffer, _inputStart, _inputLen); [EOL]             } else { [EOL]                 int segLen = _segmentSize; [EOL]                 int currLen = _currentSize; [EOL]                 if (segLen == 0) { [EOL]                     _resultString = (currLen == 0) ? "" : new String(_currentSegment, 0, currLen); [EOL]                 } else { [EOL]                     StringBuilder sb = new StringBuilder(segLen + currLen); [EOL]                     if (_segments != null) { [EOL]                         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]                             char[] curr = _segments.get(i); [EOL]                             sb.append(curr, 0, curr.length); [EOL]                         } [EOL]                     } [EOL]                     sb.append(_currentSegment, 0, _currentSize); [EOL]                     _resultString = sb.toString(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _resultString; [EOL] }
public String contentsAsString() { [EOL]     if (_resultString == null) { [EOL]         if (_resultArray != null) { [EOL]             _resultString = new String(_resultArray); [EOL]         } else { [EOL]             if (_inputStart >= 0) { [EOL]                 if (_inputLen < 1) { [EOL]                     return (_resultString = ""); [EOL]                 } [EOL]                 _resultString = new String(_inputBuffer, _inputStart, _inputLen); [EOL]             } else { [EOL]                 int segLen = _segmentSize; [EOL]                 int currLen = _currentSize; [EOL]                 if (segLen == 0) { [EOL]                     _resultString = (currLen == 0) ? "" : new String(_currentSegment, 0, currLen); [EOL]                 } else { [EOL]                     StringBuilder sb = new StringBuilder(segLen + currLen); [EOL]                     if (_segments != null) { [EOL]                         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]                             char[] curr = _segments.get(i); [EOL]                             sb.append(curr, 0, curr.length); [EOL]                         } [EOL]                     } [EOL]                     sb.append(_currentSegment, 0, _currentSize); [EOL]                     _resultString = sb.toString(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _resultString; [EOL] }
public String contentsAsString() { [EOL]     if (_resultString == null) { [EOL]         if (_resultArray != null) { [EOL]             _resultString = new String(_resultArray); [EOL]         } else { [EOL]             if (_inputStart >= 0) { [EOL]                 if (_inputLen < 1) { [EOL]                     return (_resultString = ""); [EOL]                 } [EOL]                 _resultString = new String(_inputBuffer, _inputStart, _inputLen); [EOL]             } else { [EOL]                 int segLen = _segmentSize; [EOL]                 int currLen = _currentSize; [EOL]                 if (segLen == 0) { [EOL]                     _resultString = (currLen == 0) ? "" : new String(_currentSegment, 0, currLen); [EOL]                 } else { [EOL]                     StringBuilder sb = new StringBuilder(segLen + currLen); [EOL]                     if (_segments != null) { [EOL]                         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]                             char[] curr = _segments.get(i); [EOL]                             sb.append(curr, 0, curr.length); [EOL]                         } [EOL]                     } [EOL]                     sb.append(_currentSegment, 0, _currentSize); [EOL]                     _resultString = sb.toString(); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _resultString; [EOL] }
public double contentsAsDouble() throws NumberFormatException { [EOL]     return NumberInput.parseDouble(contentsAsString()); [EOL] }
public double contentsAsDouble() throws NumberFormatException { [EOL]     return NumberInput.parseDouble(contentsAsString()); [EOL] }
public char[] emptyAndGetCurrentSegment() { [EOL]     _inputStart = -1; [EOL]     _currentSize = 0; [EOL]     _inputLen = 0; [EOL]     _inputBuffer = null; [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } [EOL]     char[] curr = _currentSegment; [EOL]     if (curr == null) { [EOL]         _currentSegment = curr = findBuffer(0); [EOL]     } [EOL]     return curr; [EOL] }
public char[] emptyAndGetCurrentSegment() { [EOL]     _inputStart = -1; [EOL]     _currentSize = 0; [EOL]     _inputLen = 0; [EOL]     _inputBuffer = null; [EOL]     _resultString = null; [EOL]     _resultArray = null; [EOL]     if (_hasSegments) { [EOL]         clearSegments(); [EOL]     } [EOL]     char[] curr = _currentSegment; [EOL]     if (curr == null) { [EOL]         _currentSegment = curr = findBuffer(0); [EOL]     } [EOL]     return curr; [EOL] }
public void setCurrentLength(int len) { [EOL]     _currentSize = len; [EOL] }
public void setCurrentLength(int len) { [EOL]     _currentSize = len; [EOL] }
public void setCurrentLength(int len) { [EOL]     _currentSize = len; [EOL] }
public char[] finishCurrentSegment() { [EOL]     if (_segments == null) { [EOL]         _segments = new ArrayList<char[]>(); [EOL]     } [EOL]     _hasSegments = true; [EOL]     _segments.add(_currentSegment); [EOL]     int oldLen = _currentSegment.length; [EOL]     _segmentSize += oldLen; [EOL]     int newLen = Math.min(oldLen + (oldLen >> 1), MAX_SEGMENT_LEN); [EOL]     char[] curr = _charArray(newLen); [EOL]     _currentSize = 0; [EOL]     _currentSegment = curr; [EOL]     return curr; [EOL] }
private char[] buildResultArray() { [EOL]     if (_resultString != null) { [EOL]         return _resultString.toCharArray(); [EOL]     } [EOL]     if (_inputStart >= 0) { [EOL]         final int len = _inputLen; [EOL]         if (len < 1) { [EOL]             return NO_CHARS; [EOL]         } [EOL]         final int start = _inputStart; [EOL]         if (start == 0) { [EOL]             return Arrays.copyOf(_inputBuffer, len); [EOL]         } [EOL]         return Arrays.copyOfRange(_inputBuffer, start, start + len); [EOL]     } [EOL]     int size = size(); [EOL]     if (size < 1) { [EOL]         return NO_CHARS; [EOL]     } [EOL]     int offset = 0; [EOL]     final char[] result = _charArray(size); [EOL]     if (_segments != null) { [EOL]         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]             char[] curr = (char[]) _segments.get(i); [EOL]             int currLen = curr.length; [EOL]             System.arraycopy(curr, 0, result, offset, currLen); [EOL]             offset += currLen; [EOL]         } [EOL]     } [EOL]     System.arraycopy(_currentSegment, 0, result, offset, _currentSize); [EOL]     return result; [EOL] }
private char[] buildResultArray() { [EOL]     if (_resultString != null) { [EOL]         return _resultString.toCharArray(); [EOL]     } [EOL]     if (_inputStart >= 0) { [EOL]         final int len = _inputLen; [EOL]         if (len < 1) { [EOL]             return NO_CHARS; [EOL]         } [EOL]         final int start = _inputStart; [EOL]         if (start == 0) { [EOL]             return Arrays.copyOf(_inputBuffer, len); [EOL]         } [EOL]         return Arrays.copyOfRange(_inputBuffer, start, start + len); [EOL]     } [EOL]     int size = size(); [EOL]     if (size < 1) { [EOL]         return NO_CHARS; [EOL]     } [EOL]     int offset = 0; [EOL]     final char[] result = _charArray(size); [EOL]     if (_segments != null) { [EOL]         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]             char[] curr = (char[]) _segments.get(i); [EOL]             int currLen = curr.length; [EOL]             System.arraycopy(curr, 0, result, offset, currLen); [EOL]             offset += currLen; [EOL]         } [EOL]     } [EOL]     System.arraycopy(_currentSegment, 0, result, offset, _currentSize); [EOL]     return result; [EOL] }
private char[] buildResultArray() { [EOL]     if (_resultString != null) { [EOL]         return _resultString.toCharArray(); [EOL]     } [EOL]     if (_inputStart >= 0) { [EOL]         final int len = _inputLen; [EOL]         if (len < 1) { [EOL]             return NO_CHARS; [EOL]         } [EOL]         final int start = _inputStart; [EOL]         if (start == 0) { [EOL]             return Arrays.copyOf(_inputBuffer, len); [EOL]         } [EOL]         return Arrays.copyOfRange(_inputBuffer, start, start + len); [EOL]     } [EOL]     int size = size(); [EOL]     if (size < 1) { [EOL]         return NO_CHARS; [EOL]     } [EOL]     int offset = 0; [EOL]     final char[] result = _charArray(size); [EOL]     if (_segments != null) { [EOL]         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]             char[] curr = (char[]) _segments.get(i); [EOL]             int currLen = curr.length; [EOL]             System.arraycopy(curr, 0, result, offset, currLen); [EOL]             offset += currLen; [EOL]         } [EOL]     } [EOL]     System.arraycopy(_currentSegment, 0, result, offset, _currentSize); [EOL]     return result; [EOL] }
private char[] buildResultArray() { [EOL]     if (_resultString != null) { [EOL]         return _resultString.toCharArray(); [EOL]     } [EOL]     if (_inputStart >= 0) { [EOL]         final int len = _inputLen; [EOL]         if (len < 1) { [EOL]             return NO_CHARS; [EOL]         } [EOL]         final int start = _inputStart; [EOL]         if (start == 0) { [EOL]             return Arrays.copyOf(_inputBuffer, len); [EOL]         } [EOL]         return Arrays.copyOfRange(_inputBuffer, start, start + len); [EOL]     } [EOL]     int size = size(); [EOL]     if (size < 1) { [EOL]         return NO_CHARS; [EOL]     } [EOL]     int offset = 0; [EOL]     final char[] result = _charArray(size); [EOL]     if (_segments != null) { [EOL]         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]             char[] curr = (char[]) _segments.get(i); [EOL]             int currLen = curr.length; [EOL]             System.arraycopy(curr, 0, result, offset, currLen); [EOL]             offset += currLen; [EOL]         } [EOL]     } [EOL]     System.arraycopy(_currentSegment, 0, result, offset, _currentSize); [EOL]     return result; [EOL] }
private char[] buildResultArray() { [EOL]     if (_resultString != null) { [EOL]         return _resultString.toCharArray(); [EOL]     } [EOL]     if (_inputStart >= 0) { [EOL]         final int len = _inputLen; [EOL]         if (len < 1) { [EOL]             return NO_CHARS; [EOL]         } [EOL]         final int start = _inputStart; [EOL]         if (start == 0) { [EOL]             return Arrays.copyOf(_inputBuffer, len); [EOL]         } [EOL]         return Arrays.copyOfRange(_inputBuffer, start, start + len); [EOL]     } [EOL]     int size = size(); [EOL]     if (size < 1) { [EOL]         return NO_CHARS; [EOL]     } [EOL]     int offset = 0; [EOL]     final char[] result = _charArray(size); [EOL]     if (_segments != null) { [EOL]         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]             char[] curr = (char[]) _segments.get(i); [EOL]             int currLen = curr.length; [EOL]             System.arraycopy(curr, 0, result, offset, currLen); [EOL]             offset += currLen; [EOL]         } [EOL]     } [EOL]     System.arraycopy(_currentSegment, 0, result, offset, _currentSize); [EOL]     return result; [EOL] }
private char[] buildResultArray() { [EOL]     if (_resultString != null) { [EOL]         return _resultString.toCharArray(); [EOL]     } [EOL]     if (_inputStart >= 0) { [EOL]         final int len = _inputLen; [EOL]         if (len < 1) { [EOL]             return NO_CHARS; [EOL]         } [EOL]         final int start = _inputStart; [EOL]         if (start == 0) { [EOL]             return Arrays.copyOf(_inputBuffer, len); [EOL]         } [EOL]         return Arrays.copyOfRange(_inputBuffer, start, start + len); [EOL]     } [EOL]     int size = size(); [EOL]     if (size < 1) { [EOL]         return NO_CHARS; [EOL]     } [EOL]     int offset = 0; [EOL]     final char[] result = _charArray(size); [EOL]     if (_segments != null) { [EOL]         for (int i = 0, len = _segments.size(); i < len; ++i) { [EOL]             char[] curr = (char[]) _segments.get(i); [EOL]             int currLen = curr.length; [EOL]             System.arraycopy(curr, 0, result, offset, currLen); [EOL]             offset += currLen; [EOL]         } [EOL]     } [EOL]     System.arraycopy(_currentSegment, 0, result, offset, _currentSize); [EOL]     return result; [EOL] }
@Override [EOL] public void writeRawValue(String text) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write raw value"); [EOL]     writeRaw(text); [EOL] }
@Override [EOL] public void writeRawValue(String text) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write raw value"); [EOL]     writeRaw(text); [EOL] }
@Override [EOL] public void writeRawValue(String text) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write raw value"); [EOL]     writeRaw(text); [EOL] }
public JsonReadContext(JsonReadContext parent, int type, int lineNr, int colNr) { [EOL]     super(); [EOL]     _type = type; [EOL]     _parent = parent; [EOL]     _lineNr = lineNr; [EOL]     _columnNr = colNr; [EOL]     _index = -1; [EOL] }
public static JsonReadContext createRootContext() { [EOL]     return new JsonReadContext(null, TYPE_ROOT, 1, 0); [EOL] }
public JsonReadContext createChildObjectContext(int lineNr, int colNr) { [EOL]     JsonReadContext ctxt = _child; [EOL]     if (ctxt == null) { [EOL]         _child = ctxt = new JsonReadContext(this, TYPE_OBJECT, lineNr, colNr); [EOL]         return ctxt; [EOL]     } [EOL]     ctxt.reset(TYPE_OBJECT, lineNr, colNr); [EOL]     return ctxt; [EOL] }
public JsonReadContext createChildObjectContext(int lineNr, int colNr) { [EOL]     JsonReadContext ctxt = _child; [EOL]     if (ctxt == null) { [EOL]         _child = ctxt = new JsonReadContext(this, TYPE_OBJECT, lineNr, colNr); [EOL]         return ctxt; [EOL]     } [EOL]     ctxt.reset(TYPE_OBJECT, lineNr, colNr); [EOL]     return ctxt; [EOL] }
@Override [EOL] public String getCurrentName() { [EOL]     return _currentName; [EOL] }
@Override [EOL] public JsonReadContext getParent() { [EOL]     return _parent; [EOL] }
public boolean expectComma() { [EOL]     int ix = ++_index; [EOL]     return (_type != TYPE_ROOT && ix > 0); [EOL] }
public boolean expectComma() { [EOL]     int ix = ++_index; [EOL]     return (_type != TYPE_ROOT && ix > 0); [EOL] }
public boolean expectComma() { [EOL]     int ix = ++_index; [EOL]     return (_type != TYPE_ROOT && ix > 0); [EOL] }
public boolean expectComma() { [EOL]     int ix = ++_index; [EOL]     return (_type != TYPE_ROOT && ix > 0); [EOL] }
public void setCurrentName(String name) { [EOL]     _currentName = name; [EOL] }
@Override [EOL] public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeFieldName(name.getValue()); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { [EOL]         _reportError("Can not write a field name, expecting a value"); [EOL]     } [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _writePPFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA)); [EOL]         return; [EOL]     } [EOL]     if (status == JsonWriteContext.STATUS_OK_AFTER_COMMA) { [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = BYTE_COMMA; [EOL]     } [EOL]     _writeFieldName(name); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException { [EOL]     if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) { [EOL]         int len = name.appendQuotedUTF8(_outputBuffer, _outputTail); [EOL]         if (len < 0) { [EOL]             _writeBytes(name.asQuotedUTF8()); [EOL]         } else { [EOL]             _outputTail += len; [EOL]         } [EOL]         return; [EOL]     } [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     int len = name.appendQuotedUTF8(_outputBuffer, _outputTail); [EOL]     if (len < 0) { [EOL]         _writeBytes(name.asQuotedUTF8()); [EOL]     } else { [EOL]         _outputTail += len; [EOL]     } [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeString(String text) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (text == null) { [EOL]         _writeNull(); [EOL]         return; [EOL]     } [EOL]     final int len = text.length(); [EOL]     if (len > _charBufferLength) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     text.getChars(0, len, _charBuffer, 0); [EOL]     if (len > _outputMaxContiguous) { [EOL]         _writeLongString(_charBuffer, 0, len); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeStringSegment(_charBuffer, 0, len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeString(String text) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (text == null) { [EOL]         _writeNull(); [EOL]         return; [EOL]     } [EOL]     final int len = text.length(); [EOL]     if (len > _charBufferLength) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     text.getChars(0, len, _charBuffer, 0); [EOL]     if (len > _outputMaxContiguous) { [EOL]         _writeLongString(_charBuffer, 0, len); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeStringSegment(_charBuffer, 0, len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeString(String text) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (text == null) { [EOL]         _writeNull(); [EOL]         return; [EOL]     } [EOL]     final int len = text.length(); [EOL]     if (len > _charBufferLength) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     text.getChars(0, len, _charBuffer, 0); [EOL]     if (len > _outputMaxContiguous) { [EOL]         _writeLongString(_charBuffer, 0, len); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeStringSegment(_charBuffer, 0, len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeString(String text) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (text == null) { [EOL]         _writeNull(); [EOL]         return; [EOL]     } [EOL]     final int len = text.length(); [EOL]     if (len > _charBufferLength) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     text.getChars(0, len, _charBuffer, 0); [EOL]     if (len > _outputMaxContiguous) { [EOL]         _writeLongString(_charBuffer, 0, len); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeStringSegment(_charBuffer, 0, len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeString(String text) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (text == null) { [EOL]         _writeNull(); [EOL]         return; [EOL]     } [EOL]     final int len = text.length(); [EOL]     if (len > _charBufferLength) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     text.getChars(0, len, _charBuffer, 0); [EOL]     if (len > _outputMaxContiguous) { [EOL]         _writeLongString(_charBuffer, 0, len); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeStringSegment(_charBuffer, 0, len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
@Override [EOL] public void writeString(String text) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (text == null) { [EOL]         _writeNull(); [EOL]         return; [EOL]     } [EOL]     final int len = text.length(); [EOL]     if (len > _charBufferLength) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     text.getChars(0, len, _charBuffer, 0); [EOL]     if (len > _outputMaxContiguous) { [EOL]         _writeLongString(_charBuffer, 0, len); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL]     _writeStringSegment(_charBuffer, 0, len); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = BYTE_QUOTE; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException { [EOL]     len += offset; [EOL]     int outputPtr = _outputTail; [EOL]     final byte[] outputBuffer = _outputBuffer; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     while (offset < len) { [EOL]         int ch = cbuf[offset]; [EOL]         if (ch > 0x7F || escCodes[ch] != 0) { [EOL]             break; [EOL]         } [EOL]         outputBuffer[outputPtr++] = (byte) ch; [EOL]         ++offset; [EOL]     } [EOL]     _outputTail = outputPtr; [EOL]     if (offset < len) { [EOL]         if (_characterEscapes != null) { [EOL]             _writeCustomStringSegment2(cbuf, offset, len); [EOL]         } else if (_maximumNonEscapedChar == 0) { [EOL]             _writeStringSegment2(cbuf, offset, len); [EOL]         } else { [EOL]             _writeStringSegmentASCII2(cbuf, offset, len); [EOL]         } [EOL]     } [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException { [EOL]     if ((_outputTail + 6 * (end - offset)) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     int outputPtr = _outputTail; [EOL]     final byte[] outputBuffer = _outputBuffer; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar; [EOL]     final CharacterEscapes customEscapes = _characterEscapes; [EOL]     while (offset < end) { [EOL]         int ch = cbuf[offset++]; [EOL]         if (ch <= 0x7F) { [EOL]             if (escCodes[ch] == 0) { [EOL]                 outputBuffer[outputPtr++] = (byte) ch; [EOL]                 continue; [EOL]             } [EOL]             int escape = escCodes[ch]; [EOL]             if (escape > 0) { [EOL]                 outputBuffer[outputPtr++] = BYTE_BACKSLASH; [EOL]                 outputBuffer[outputPtr++] = (byte) escape; [EOL]             } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) { [EOL]                 SerializableString esc = customEscapes.getEscapeSequence(ch); [EOL]                 if (esc == null) { [EOL]                     _reportError("Invalid custom escape definitions; custom escape not found for character code 0x" + Integer.toHexString(ch) + ", although was supposed to have one"); [EOL]                 } [EOL]                 outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end - offset); [EOL]             } else { [EOL]                 outputPtr = _writeGenericEscape(ch, outputPtr); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (ch > maxUnescaped) { [EOL]             outputPtr = _writeGenericEscape(ch, outputPtr); [EOL]             continue; [EOL]         } [EOL]         SerializableString esc = customEscapes.getEscapeSequence(ch); [EOL]         if (esc != null) { [EOL]             outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end - offset); [EOL]             continue; [EOL]         } [EOL]         if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             outputPtr = _outputMultiByteChar(ch, outputPtr); [EOL]         } [EOL]     } [EOL]     _outputTail = outputPtr; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException { [EOL]     if ((_outputTail + 6 * (end - offset)) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     int outputPtr = _outputTail; [EOL]     final byte[] outputBuffer = _outputBuffer; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar; [EOL]     final CharacterEscapes customEscapes = _characterEscapes; [EOL]     while (offset < end) { [EOL]         int ch = cbuf[offset++]; [EOL]         if (ch <= 0x7F) { [EOL]             if (escCodes[ch] == 0) { [EOL]                 outputBuffer[outputPtr++] = (byte) ch; [EOL]                 continue; [EOL]             } [EOL]             int escape = escCodes[ch]; [EOL]             if (escape > 0) { [EOL]                 outputBuffer[outputPtr++] = BYTE_BACKSLASH; [EOL]                 outputBuffer[outputPtr++] = (byte) escape; [EOL]             } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) { [EOL]                 SerializableString esc = customEscapes.getEscapeSequence(ch); [EOL]                 if (esc == null) { [EOL]                     _reportError("Invalid custom escape definitions; custom escape not found for character code 0x" + Integer.toHexString(ch) + ", although was supposed to have one"); [EOL]                 } [EOL]                 outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end - offset); [EOL]             } else { [EOL]                 outputPtr = _writeGenericEscape(ch, outputPtr); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (ch > maxUnescaped) { [EOL]             outputPtr = _writeGenericEscape(ch, outputPtr); [EOL]             continue; [EOL]         } [EOL]         SerializableString esc = customEscapes.getEscapeSequence(ch); [EOL]         if (esc != null) { [EOL]             outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end - offset); [EOL]             continue; [EOL]         } [EOL]         if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             outputPtr = _outputMultiByteChar(ch, outputPtr); [EOL]         } [EOL]     } [EOL]     _outputTail = outputPtr; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException { [EOL]     if ((_outputTail + 6 * (end - offset)) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     int outputPtr = _outputTail; [EOL]     final byte[] outputBuffer = _outputBuffer; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar; [EOL]     final CharacterEscapes customEscapes = _characterEscapes; [EOL]     while (offset < end) { [EOL]         int ch = cbuf[offset++]; [EOL]         if (ch <= 0x7F) { [EOL]             if (escCodes[ch] == 0) { [EOL]                 outputBuffer[outputPtr++] = (byte) ch; [EOL]                 continue; [EOL]             } [EOL]             int escape = escCodes[ch]; [EOL]             if (escape > 0) { [EOL]                 outputBuffer[outputPtr++] = BYTE_BACKSLASH; [EOL]                 outputBuffer[outputPtr++] = (byte) escape; [EOL]             } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) { [EOL]                 SerializableString esc = customEscapes.getEscapeSequence(ch); [EOL]                 if (esc == null) { [EOL]                     _reportError("Invalid custom escape definitions; custom escape not found for character code 0x" + Integer.toHexString(ch) + ", although was supposed to have one"); [EOL]                 } [EOL]                 outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end - offset); [EOL]             } else { [EOL]                 outputPtr = _writeGenericEscape(ch, outputPtr); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (ch > maxUnescaped) { [EOL]             outputPtr = _writeGenericEscape(ch, outputPtr); [EOL]             continue; [EOL]         } [EOL]         SerializableString esc = customEscapes.getEscapeSequence(ch); [EOL]         if (esc != null) { [EOL]             outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end - offset); [EOL]             continue; [EOL]         } [EOL]         if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             outputPtr = _outputMultiByteChar(ch, outputPtr); [EOL]         } [EOL]     } [EOL]     _outputTail = outputPtr; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException { [EOL]     if ((_outputTail + 6 * (end - offset)) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     int outputPtr = _outputTail; [EOL]     final byte[] outputBuffer = _outputBuffer; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar; [EOL]     final CharacterEscapes customEscapes = _characterEscapes; [EOL]     while (offset < end) { [EOL]         int ch = cbuf[offset++]; [EOL]         if (ch <= 0x7F) { [EOL]             if (escCodes[ch] == 0) { [EOL]                 outputBuffer[outputPtr++] = (byte) ch; [EOL]                 continue; [EOL]             } [EOL]             int escape = escCodes[ch]; [EOL]             if (escape > 0) { [EOL]                 outputBuffer[outputPtr++] = BYTE_BACKSLASH; [EOL]                 outputBuffer[outputPtr++] = (byte) escape; [EOL]             } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) { [EOL]                 SerializableString esc = customEscapes.getEscapeSequence(ch); [EOL]                 if (esc == null) { [EOL]                     _reportError("Invalid custom escape definitions; custom escape not found for character code 0x" + Integer.toHexString(ch) + ", although was supposed to have one"); [EOL]                 } [EOL]                 outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end - offset); [EOL]             } else { [EOL]                 outputPtr = _writeGenericEscape(ch, outputPtr); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (ch > maxUnescaped) { [EOL]             outputPtr = _writeGenericEscape(ch, outputPtr); [EOL]             continue; [EOL]         } [EOL]         SerializableString esc = customEscapes.getEscapeSequence(ch); [EOL]         if (esc != null) { [EOL]             outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end - offset); [EOL]             continue; [EOL]         } [EOL]         if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             outputPtr = _outputMultiByteChar(ch, outputPtr); [EOL]         } [EOL]     } [EOL]     _outputTail = outputPtr; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException { [EOL]     if ((_outputTail + 6 * (end - offset)) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     int outputPtr = _outputTail; [EOL]     final byte[] outputBuffer = _outputBuffer; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int maxUnescaped = (_maximumNonEscapedChar <= 0) ? 0xFFFF : _maximumNonEscapedChar; [EOL]     final CharacterEscapes customEscapes = _characterEscapes; [EOL]     while (offset < end) { [EOL]         int ch = cbuf[offset++]; [EOL]         if (ch <= 0x7F) { [EOL]             if (escCodes[ch] == 0) { [EOL]                 outputBuffer[outputPtr++] = (byte) ch; [EOL]                 continue; [EOL]             } [EOL]             int escape = escCodes[ch]; [EOL]             if (escape > 0) { [EOL]                 outputBuffer[outputPtr++] = BYTE_BACKSLASH; [EOL]                 outputBuffer[outputPtr++] = (byte) escape; [EOL]             } else if (escape == CharacterEscapes.ESCAPE_CUSTOM) { [EOL]                 SerializableString esc = customEscapes.getEscapeSequence(ch); [EOL]                 if (esc == null) { [EOL]                     _reportError("Invalid custom escape definitions; custom escape not found for character code 0x" + Integer.toHexString(ch) + ", although was supposed to have one"); [EOL]                 } [EOL]                 outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end - offset); [EOL]             } else { [EOL]                 outputPtr = _writeGenericEscape(ch, outputPtr); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (ch > maxUnescaped) { [EOL]             outputPtr = _writeGenericEscape(ch, outputPtr); [EOL]             continue; [EOL]         } [EOL]         SerializableString esc = customEscapes.getEscapeSequence(ch); [EOL]         if (esc != null) { [EOL]             outputPtr = _writeCustomEscape(outputBuffer, outputPtr, esc, end - offset); [EOL]             continue; [EOL]         } [EOL]         if (ch <= 0x7FF) { [EOL]             outputBuffer[outputPtr++] = (byte) (0xc0 | (ch >> 6)); [EOL]             outputBuffer[outputPtr++] = (byte) (0x80 | (ch & 0x3f)); [EOL]         } else { [EOL]             outputPtr = _outputMultiByteChar(ch, outputPtr); [EOL]         } [EOL]     } [EOL]     _outputTail = outputPtr; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException { [EOL]     byte[] raw = esc.asUnquotedUTF8(); [EOL]     int len = raw.length; [EOL]     if (len > 6) { [EOL]         return _handleLongCustomEscape(outputBuffer, outputPtr, _outputEnd, raw, remainingChars); [EOL]     } [EOL]     System.arraycopy(raw, 0, outputBuffer, outputPtr, len); [EOL]     return (outputPtr + len); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException { [EOL]     byte[] raw = esc.asUnquotedUTF8(); [EOL]     int len = raw.length; [EOL]     if (len > 6) { [EOL]         return _handleLongCustomEscape(outputBuffer, outputPtr, _outputEnd, raw, remainingChars); [EOL]     } [EOL]     System.arraycopy(raw, 0, outputBuffer, outputPtr, len); [EOL]     return (outputPtr + len); [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException { [EOL]     final byte[] bbuf = _outputBuffer; [EOL]     bbuf[outputPtr++] = BYTE_BACKSLASH; [EOL]     bbuf[outputPtr++] = BYTE_u; [EOL]     if (charToEscape > 0xFF) { [EOL]         int hi = (charToEscape >> 8) & 0xFF; [EOL]         bbuf[outputPtr++] = HEX_CHARS[hi >> 4]; [EOL]         bbuf[outputPtr++] = HEX_CHARS[hi & 0xF]; [EOL]         charToEscape &= 0xFF; [EOL]     } else { [EOL]         bbuf[outputPtr++] = BYTE_0; [EOL]         bbuf[outputPtr++] = BYTE_0; [EOL]     } [EOL]     bbuf[outputPtr++] = HEX_CHARS[charToEscape >> 4]; [EOL]     bbuf[outputPtr++] = HEX_CHARS[charToEscape & 0xF]; [EOL]     return outputPtr; [EOL] } public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out); public UTF8JsonGenerator(IOContext ctxt, int features, ObjectCodec codec, OutputStream out, byte[] outputBuffer, int outputOffset, boolean bufferRecyclable); public Object getOutputTarget(); public final void writeFieldName(String name) throws IOException, JsonGenerationException; public final void writeFieldName(SerializableString name) throws IOException, JsonGenerationException; public final void writeStartArray() throws IOException, JsonGenerationException; public final void writeEndArray() throws IOException, JsonGenerationException; public final void writeStartObject() throws IOException, JsonGenerationException; public final void writeEndObject() throws IOException, JsonGenerationException; protected final void _writeFieldName(String name) throws IOException, JsonGenerationException; protected final void _writeFieldName(SerializableString name) throws IOException, JsonGenerationException; protected final void _writePPFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException; protected final void _writePPFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException; public void writeString(String text) throws IOException, JsonGenerationException; private void _writeLongString(String text) throws IOException, JsonGenerationException; private void _writeLongString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException; public final void writeString(SerializableString text) throws IOException, JsonGenerationException; public void writeRawUTF8String(byte[] text, int offset, int length) throws IOException, JsonGenerationException; public void writeUTF8String(byte[] text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(String text) throws IOException, JsonGenerationException; public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(SerializableString text) throws IOException, JsonGenerationException; public final void writeRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeRaw(char ch) throws IOException, JsonGenerationException; private final void _writeSegmentedRaw(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException; public int writeBinary(Base64Variant b64variant, InputStream data, int dataLength) throws IOException, JsonGenerationException; public void writeNumber(short s) throws IOException, JsonGenerationException; private void _writeQuotedShort(short s) throws IOException; public void writeNumber(int i) throws IOException, JsonGenerationException; private void _writeQuotedInt(int i) throws IOException; public void writeNumber(long l) throws IOException, JsonGenerationException; private void _writeQuotedLong(long l) throws IOException; public void writeNumber(BigInteger value) throws IOException, JsonGenerationException; public void writeNumber(double d) throws IOException, JsonGenerationException; public void writeNumber(float f) throws IOException, JsonGenerationException; public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException; public void writeNumber(String encodedValue) throws IOException, JsonGenerationException; private void _writeQuotedRaw(Object value) throws IOException; public void writeBoolean(boolean state) throws IOException, JsonGenerationException; public void writeNull() throws IOException, JsonGenerationException; protected final void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException; protected final void _verifyPrettyValueWrite(String typeMsg, int status) throws IOException, JsonGenerationException; public final void flush() throws IOException; public void close() throws IOException; protected void _releaseBuffers(); private final void _writeBytes(byte[] bytes) throws IOException; private final void _writeBytes(byte[] bytes, int offset, int len) throws IOException; private final void _writeStringSegments(String text) throws IOException, JsonGenerationException; private final void _writeStringSegments(char[] cbuf, int offset, int totalLen) throws IOException, JsonGenerationException; private final void _writeStringSegment(char[] cbuf, int offset, int len) throws IOException, JsonGenerationException; private final void _writeStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private final void _writeStringSegmentASCII2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private void _writeCustomStringSegment2(final char[] cbuf, int offset, final int end) throws IOException, JsonGenerationException; private int _writeCustomEscape(byte[] outputBuffer, int outputPtr, SerializableString esc, int remainingChars) throws IOException, JsonGenerationException; private int _handleLongCustomEscape(byte[] outputBuffer, int outputPtr, int outputEnd, byte[] raw, int remainingChars) throws IOException, JsonGenerationException; private void _writeUTF8Segments(byte[] utf8, int offset, int totalLen) throws IOException, JsonGenerationException; private void _writeUTF8Segment(byte[] utf8, final int offset, final int len) throws IOException, JsonGenerationException; private void _writeUTF8Segment2(final byte[] utf8, int offset, int len) throws IOException, JsonGenerationException; protected void _writeBinary(Base64Variant b64variant, byte[] input, int inputPtr, final int inputEnd) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer, int bytesLeft) throws IOException, JsonGenerationException; protected int _writeBinary(Base64Variant b64variant, InputStream data, byte[] readBuffer) throws IOException, JsonGenerationException; private int _readMore(InputStream in, byte[] readBuffer, int inputPtr, int inputEnd, int maxRead) throws IOException; private int _outputRawMultiByteChar(int ch, char[] cbuf, int inputOffset, int inputLen) throws IOException; protected final void _outputSurrogates(int surr1, int surr2) throws IOException; private int _outputMultiByteChar(int ch, int outputPtr) throws IOException; protected final int _decodeSurrogate(int surr1, int surr2) throws IOException; private void _writeNull() throws IOException; private int _writeGenericEscape(int charToEscape, int outputPtr) throws IOException; protected final void _flushBuffer() throws IOException; byte BYTE_u=Optional[(byte) 'u']; byte BYTE_0=Optional[(byte) '0']; byte BYTE_LBRACKET=Optional[(byte) '[']; byte BYTE_RBRACKET=Optional[(byte) ']']; byte BYTE_LCURLY=Optional[(byte) '{']; byte BYTE_RCURLY=Optional[(byte) '}']; byte BYTE_BACKSLASH=Optional[(byte) '\\']; byte BYTE_COMMA=Optional[(byte) ',']; byte BYTE_COLON=Optional[(byte) ':']; byte BYTE_QUOTE=Optional[(byte) '"']; int SURR1_FIRST=Optional[0xD800]; int SURR1_LAST=Optional[0xDBFF]; int SURR2_FIRST=Optional[0xDC00]; int SURR2_LAST=Optional[0xDFFF]; int MAX_BYTES_TO_BUFFER=Optional[512]; byte[] HEX_CHARS=Optional[CharTypes.copyHexBytes()]; byte[] NULL_BYTES=Optional[{ 'n', 'u', 'l', 'l' }]; byte[] TRUE_BYTES=Optional[{ 't', 'r', 'u', 'e' }]; byte[] FALSE_BYTES=Optional[{ 'f', 'a', 'l', 's', 'e' }
protected JsonStreamContext() { [EOL] }
public final boolean inArray() { [EOL]     return _type == TYPE_ARRAY; [EOL] }
public final boolean inArray() { [EOL]     return _type == TYPE_ARRAY; [EOL] }
public final boolean inObject() { [EOL]     return _type == TYPE_OBJECT; [EOL] }
public final String getTypeDesc() { [EOL]     switch(_type) { [EOL]         case TYPE_ROOT: [EOL]             return "ROOT"; [EOL]         case TYPE_ARRAY: [EOL]             return "ARRAY"; [EOL]         case TYPE_OBJECT: [EOL]             return "OBJECT"; [EOL]     } [EOL]     return "?"; [EOL] }
public final String getTypeDesc() { [EOL]     switch(_type) { [EOL]         case TYPE_ROOT: [EOL]             return "ROOT"; [EOL]         case TYPE_ARRAY: [EOL]             return "ARRAY"; [EOL]         case TYPE_OBJECT: [EOL]             return "OBJECT"; [EOL]     } [EOL]     return "?"; [EOL] }
public final String getTypeDesc() { [EOL]     switch(_type) { [EOL]         case TYPE_ROOT: [EOL]             return "ROOT"; [EOL]         case TYPE_ARRAY: [EOL]             return "ARRAY"; [EOL]         case TYPE_OBJECT: [EOL]             return "OBJECT"; [EOL]     } [EOL]     return "?"; [EOL] }
public final String getTypeDesc() { [EOL]     switch(_type) { [EOL]         case TYPE_ROOT: [EOL]             return "ROOT"; [EOL]         case TYPE_ARRAY: [EOL]             return "ARRAY"; [EOL]         case TYPE_OBJECT: [EOL]             return "OBJECT"; [EOL]     } [EOL]     return "?"; [EOL] }
public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen) { [EOL]     _context = ctxt; [EOL]     _in = null; [EOL]     _inputBuffer = inputBuffer; [EOL]     _inputPtr = inputStart; [EOL]     _inputEnd = (inputStart + inputLen); [EOL]     _inputProcessed = -inputStart; [EOL]     _bufferRecyclable = false; [EOL] }
public JsonEncoding detectEncoding() throws IOException, JsonParseException { [EOL]     boolean foundEncoding = false; [EOL]     if (ensureLoaded(4)) { [EOL]         int quad = (_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[_inputPtr + 1] & 0xFF) << 16) | ((_inputBuffer[_inputPtr + 2] & 0xFF) << 8) | (_inputBuffer[_inputPtr + 3] & 0xFF); [EOL]         if (handleBOM(quad)) { [EOL]             foundEncoding = true; [EOL]         } else { [EOL]             if (checkUTF32(quad)) { [EOL]                 foundEncoding = true; [EOL]             } else if (checkUTF16(quad >>> 16)) { [EOL]                 foundEncoding = true; [EOL]             } [EOL]         } [EOL]     } else if (ensureLoaded(2)) { [EOL]         int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8) | (_inputBuffer[_inputPtr + 1] & 0xFF); [EOL]         if (checkUTF16(i16)) { [EOL]             foundEncoding = true; [EOL]         } [EOL]     } [EOL]     JsonEncoding enc; [EOL]     if (!foundEncoding) { [EOL]         enc = JsonEncoding.UTF8; [EOL]     } else { [EOL]         switch(_bytesPerChar) { [EOL]             case 1: [EOL]                 enc = JsonEncoding.UTF8; [EOL]                 break; [EOL]             case 2: [EOL]                 enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE; [EOL]                 break; [EOL]             case 4: [EOL]                 enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE; [EOL]                 break; [EOL]             default: [EOL]                 throw new RuntimeException("Internal error"); [EOL]         } [EOL]     } [EOL]     _context.setEncoding(enc); [EOL]     return enc; [EOL] }
public JsonEncoding detectEncoding() throws IOException, JsonParseException { [EOL]     boolean foundEncoding = false; [EOL]     if (ensureLoaded(4)) { [EOL]         int quad = (_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[_inputPtr + 1] & 0xFF) << 16) | ((_inputBuffer[_inputPtr + 2] & 0xFF) << 8) | (_inputBuffer[_inputPtr + 3] & 0xFF); [EOL]         if (handleBOM(quad)) { [EOL]             foundEncoding = true; [EOL]         } else { [EOL]             if (checkUTF32(quad)) { [EOL]                 foundEncoding = true; [EOL]             } else if (checkUTF16(quad >>> 16)) { [EOL]                 foundEncoding = true; [EOL]             } [EOL]         } [EOL]     } else if (ensureLoaded(2)) { [EOL]         int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8) | (_inputBuffer[_inputPtr + 1] & 0xFF); [EOL]         if (checkUTF16(i16)) { [EOL]             foundEncoding = true; [EOL]         } [EOL]     } [EOL]     JsonEncoding enc; [EOL]     if (!foundEncoding) { [EOL]         enc = JsonEncoding.UTF8; [EOL]     } else { [EOL]         switch(_bytesPerChar) { [EOL]             case 1: [EOL]                 enc = JsonEncoding.UTF8; [EOL]                 break; [EOL]             case 2: [EOL]                 enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE; [EOL]                 break; [EOL]             case 4: [EOL]                 enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE; [EOL]                 break; [EOL]             default: [EOL]                 throw new RuntimeException("Internal error"); [EOL]         } [EOL]     } [EOL]     _context.setEncoding(enc); [EOL]     return enc; [EOL] }
public JsonEncoding detectEncoding() throws IOException, JsonParseException { [EOL]     boolean foundEncoding = false; [EOL]     if (ensureLoaded(4)) { [EOL]         int quad = (_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[_inputPtr + 1] & 0xFF) << 16) | ((_inputBuffer[_inputPtr + 2] & 0xFF) << 8) | (_inputBuffer[_inputPtr + 3] & 0xFF); [EOL]         if (handleBOM(quad)) { [EOL]             foundEncoding = true; [EOL]         } else { [EOL]             if (checkUTF32(quad)) { [EOL]                 foundEncoding = true; [EOL]             } else if (checkUTF16(quad >>> 16)) { [EOL]                 foundEncoding = true; [EOL]             } [EOL]         } [EOL]     } else if (ensureLoaded(2)) { [EOL]         int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8) | (_inputBuffer[_inputPtr + 1] & 0xFF); [EOL]         if (checkUTF16(i16)) { [EOL]             foundEncoding = true; [EOL]         } [EOL]     } [EOL]     JsonEncoding enc; [EOL]     if (!foundEncoding) { [EOL]         enc = JsonEncoding.UTF8; [EOL]     } else { [EOL]         switch(_bytesPerChar) { [EOL]             case 1: [EOL]                 enc = JsonEncoding.UTF8; [EOL]                 break; [EOL]             case 2: [EOL]                 enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE; [EOL]                 break; [EOL]             case 4: [EOL]                 enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE; [EOL]                 break; [EOL]             default: [EOL]                 throw new RuntimeException("Internal error"); [EOL]         } [EOL]     } [EOL]     _context.setEncoding(enc); [EOL]     return enc; [EOL] }
public JsonEncoding detectEncoding() throws IOException, JsonParseException { [EOL]     boolean foundEncoding = false; [EOL]     if (ensureLoaded(4)) { [EOL]         int quad = (_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[_inputPtr + 1] & 0xFF) << 16) | ((_inputBuffer[_inputPtr + 2] & 0xFF) << 8) | (_inputBuffer[_inputPtr + 3] & 0xFF); [EOL]         if (handleBOM(quad)) { [EOL]             foundEncoding = true; [EOL]         } else { [EOL]             if (checkUTF32(quad)) { [EOL]                 foundEncoding = true; [EOL]             } else if (checkUTF16(quad >>> 16)) { [EOL]                 foundEncoding = true; [EOL]             } [EOL]         } [EOL]     } else if (ensureLoaded(2)) { [EOL]         int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8) | (_inputBuffer[_inputPtr + 1] & 0xFF); [EOL]         if (checkUTF16(i16)) { [EOL]             foundEncoding = true; [EOL]         } [EOL]     } [EOL]     JsonEncoding enc; [EOL]     if (!foundEncoding) { [EOL]         enc = JsonEncoding.UTF8; [EOL]     } else { [EOL]         switch(_bytesPerChar) { [EOL]             case 1: [EOL]                 enc = JsonEncoding.UTF8; [EOL]                 break; [EOL]             case 2: [EOL]                 enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE; [EOL]                 break; [EOL]             case 4: [EOL]                 enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE; [EOL]                 break; [EOL]             default: [EOL]                 throw new RuntimeException("Internal error"); [EOL]         } [EOL]     } [EOL]     _context.setEncoding(enc); [EOL]     return enc; [EOL] }
public JsonEncoding detectEncoding() throws IOException, JsonParseException { [EOL]     boolean foundEncoding = false; [EOL]     if (ensureLoaded(4)) { [EOL]         int quad = (_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[_inputPtr + 1] & 0xFF) << 16) | ((_inputBuffer[_inputPtr + 2] & 0xFF) << 8) | (_inputBuffer[_inputPtr + 3] & 0xFF); [EOL]         if (handleBOM(quad)) { [EOL]             foundEncoding = true; [EOL]         } else { [EOL]             if (checkUTF32(quad)) { [EOL]                 foundEncoding = true; [EOL]             } else if (checkUTF16(quad >>> 16)) { [EOL]                 foundEncoding = true; [EOL]             } [EOL]         } [EOL]     } else if (ensureLoaded(2)) { [EOL]         int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8) | (_inputBuffer[_inputPtr + 1] & 0xFF); [EOL]         if (checkUTF16(i16)) { [EOL]             foundEncoding = true; [EOL]         } [EOL]     } [EOL]     JsonEncoding enc; [EOL]     if (!foundEncoding) { [EOL]         enc = JsonEncoding.UTF8; [EOL]     } else { [EOL]         switch(_bytesPerChar) { [EOL]             case 1: [EOL]                 enc = JsonEncoding.UTF8; [EOL]                 break; [EOL]             case 2: [EOL]                 enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE; [EOL]                 break; [EOL]             case 4: [EOL]                 enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE; [EOL]                 break; [EOL]             default: [EOL]                 throw new RuntimeException("Internal error"); [EOL]         } [EOL]     } [EOL]     _context.setEncoding(enc); [EOL]     return enc; [EOL] }
public JsonEncoding detectEncoding() throws IOException, JsonParseException { [EOL]     boolean foundEncoding = false; [EOL]     if (ensureLoaded(4)) { [EOL]         int quad = (_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[_inputPtr + 1] & 0xFF) << 16) | ((_inputBuffer[_inputPtr + 2] & 0xFF) << 8) | (_inputBuffer[_inputPtr + 3] & 0xFF); [EOL]         if (handleBOM(quad)) { [EOL]             foundEncoding = true; [EOL]         } else { [EOL]             if (checkUTF32(quad)) { [EOL]                 foundEncoding = true; [EOL]             } else if (checkUTF16(quad >>> 16)) { [EOL]                 foundEncoding = true; [EOL]             } [EOL]         } [EOL]     } else if (ensureLoaded(2)) { [EOL]         int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8) | (_inputBuffer[_inputPtr + 1] & 0xFF); [EOL]         if (checkUTF16(i16)) { [EOL]             foundEncoding = true; [EOL]         } [EOL]     } [EOL]     JsonEncoding enc; [EOL]     if (!foundEncoding) { [EOL]         enc = JsonEncoding.UTF8; [EOL]     } else { [EOL]         switch(_bytesPerChar) { [EOL]             case 1: [EOL]                 enc = JsonEncoding.UTF8; [EOL]                 break; [EOL]             case 2: [EOL]                 enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE; [EOL]                 break; [EOL]             case 4: [EOL]                 enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE; [EOL]                 break; [EOL]             default: [EOL]                 throw new RuntimeException("Internal error"); [EOL]         } [EOL]     } [EOL]     _context.setEncoding(enc); [EOL]     return enc; [EOL] }
public JsonEncoding detectEncoding() throws IOException, JsonParseException { [EOL]     boolean foundEncoding = false; [EOL]     if (ensureLoaded(4)) { [EOL]         int quad = (_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[_inputPtr + 1] & 0xFF) << 16) | ((_inputBuffer[_inputPtr + 2] & 0xFF) << 8) | (_inputBuffer[_inputPtr + 3] & 0xFF); [EOL]         if (handleBOM(quad)) { [EOL]             foundEncoding = true; [EOL]         } else { [EOL]             if (checkUTF32(quad)) { [EOL]                 foundEncoding = true; [EOL]             } else if (checkUTF16(quad >>> 16)) { [EOL]                 foundEncoding = true; [EOL]             } [EOL]         } [EOL]     } else if (ensureLoaded(2)) { [EOL]         int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8) | (_inputBuffer[_inputPtr + 1] & 0xFF); [EOL]         if (checkUTF16(i16)) { [EOL]             foundEncoding = true; [EOL]         } [EOL]     } [EOL]     JsonEncoding enc; [EOL]     if (!foundEncoding) { [EOL]         enc = JsonEncoding.UTF8; [EOL]     } else { [EOL]         switch(_bytesPerChar) { [EOL]             case 1: [EOL]                 enc = JsonEncoding.UTF8; [EOL]                 break; [EOL]             case 2: [EOL]                 enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE; [EOL]                 break; [EOL]             case 4: [EOL]                 enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE; [EOL]                 break; [EOL]             default: [EOL]                 throw new RuntimeException("Internal error"); [EOL]         } [EOL]     } [EOL]     _context.setEncoding(enc); [EOL]     return enc; [EOL] }
public JsonEncoding detectEncoding() throws IOException, JsonParseException { [EOL]     boolean foundEncoding = false; [EOL]     if (ensureLoaded(4)) { [EOL]         int quad = (_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[_inputPtr + 1] & 0xFF) << 16) | ((_inputBuffer[_inputPtr + 2] & 0xFF) << 8) | (_inputBuffer[_inputPtr + 3] & 0xFF); [EOL]         if (handleBOM(quad)) { [EOL]             foundEncoding = true; [EOL]         } else { [EOL]             if (checkUTF32(quad)) { [EOL]                 foundEncoding = true; [EOL]             } else if (checkUTF16(quad >>> 16)) { [EOL]                 foundEncoding = true; [EOL]             } [EOL]         } [EOL]     } else if (ensureLoaded(2)) { [EOL]         int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8) | (_inputBuffer[_inputPtr + 1] & 0xFF); [EOL]         if (checkUTF16(i16)) { [EOL]             foundEncoding = true; [EOL]         } [EOL]     } [EOL]     JsonEncoding enc; [EOL]     if (!foundEncoding) { [EOL]         enc = JsonEncoding.UTF8; [EOL]     } else { [EOL]         switch(_bytesPerChar) { [EOL]             case 1: [EOL]                 enc = JsonEncoding.UTF8; [EOL]                 break; [EOL]             case 2: [EOL]                 enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE; [EOL]                 break; [EOL]             case 4: [EOL]                 enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE; [EOL]                 break; [EOL]             default: [EOL]                 throw new RuntimeException("Internal error"); [EOL]         } [EOL]     } [EOL]     _context.setEncoding(enc); [EOL]     return enc; [EOL] }
public JsonEncoding detectEncoding() throws IOException, JsonParseException { [EOL]     boolean foundEncoding = false; [EOL]     if (ensureLoaded(4)) { [EOL]         int quad = (_inputBuffer[_inputPtr] << 24) | ((_inputBuffer[_inputPtr + 1] & 0xFF) << 16) | ((_inputBuffer[_inputPtr + 2] & 0xFF) << 8) | (_inputBuffer[_inputPtr + 3] & 0xFF); [EOL]         if (handleBOM(quad)) { [EOL]             foundEncoding = true; [EOL]         } else { [EOL]             if (checkUTF32(quad)) { [EOL]                 foundEncoding = true; [EOL]             } else if (checkUTF16(quad >>> 16)) { [EOL]                 foundEncoding = true; [EOL]             } [EOL]         } [EOL]     } else if (ensureLoaded(2)) { [EOL]         int i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8) | (_inputBuffer[_inputPtr + 1] & 0xFF); [EOL]         if (checkUTF16(i16)) { [EOL]             foundEncoding = true; [EOL]         } [EOL]     } [EOL]     JsonEncoding enc; [EOL]     if (!foundEncoding) { [EOL]         enc = JsonEncoding.UTF8; [EOL]     } else { [EOL]         switch(_bytesPerChar) { [EOL]             case 1: [EOL]                 enc = JsonEncoding.UTF8; [EOL]                 break; [EOL]             case 2: [EOL]                 enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE; [EOL]                 break; [EOL]             case 4: [EOL]                 enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE; [EOL]                 break; [EOL]             default: [EOL]                 throw new RuntimeException("Internal error"); [EOL]         } [EOL]     } [EOL]     _context.setEncoding(enc); [EOL]     return enc; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException { [EOL]     if (!acc.hasMoreBytes()) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     byte b = acc.nextByte(); [EOL]     if (b == UTF8_BOM_1) { [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_2) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (acc.nextByte() != UTF8_BOM_3) { [EOL]             return MatchStrength.NO_MATCH; [EOL]         } [EOL]         if (!acc.hasMoreBytes()) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         b = acc.nextByte(); [EOL]     } [EOL]     int ch = skipSpace(acc, b); [EOL]     if (ch < 0) { [EOL]         return MatchStrength.INCONCLUSIVE; [EOL]     } [EOL]     if (ch == '{') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == '"' || ch == '}') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.NO_MATCH; [EOL]     } [EOL]     MatchStrength strength; [EOL]     if (ch == '[') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         if (ch == ']' || ch == '[') { [EOL]             return MatchStrength.SOLID_MATCH; [EOL]         } [EOL]         return MatchStrength.SOLID_MATCH; [EOL]     } else { [EOL]         strength = MatchStrength.WEAK_MATCH; [EOL]     } [EOL]     if (ch == '"') { [EOL]         return strength; [EOL]     } [EOL]     if (ch <= '9' && ch >= '0') { [EOL]         return strength; [EOL]     } [EOL]     if (ch == '-') { [EOL]         ch = skipSpace(acc); [EOL]         if (ch < 0) { [EOL]             return MatchStrength.INCONCLUSIVE; [EOL]         } [EOL]         return (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH; [EOL]     } [EOL]     if (ch == 'n') { [EOL]         return tryMatch(acc, "ull", strength); [EOL]     } [EOL]     if (ch == 't') { [EOL]         return tryMatch(acc, "rue", strength); [EOL]     } [EOL]     if (ch == 'f') { [EOL]         return tryMatch(acc, "alse", strength); [EOL]     } [EOL]     return MatchStrength.NO_MATCH; [EOL] }
private boolean handleBOM(int quad) throws IOException { [EOL]     switch(quad) { [EOL]         case 0x0000FEFF: [EOL]             _bigEndian = true; [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             return true; [EOL]         case 0xFFFE0000: [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             _bigEndian = false; [EOL]             return true; [EOL]         case 0x0000FFFE: [EOL]             reportWeirdUCS4("2143"); [EOL]         case 0xFEFF0000: [EOL]             reportWeirdUCS4("3412"); [EOL]     } [EOL]     int msw = quad >>> 16; [EOL]     if (msw == 0xFEFF) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     if (msw == 0xFFFE) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = false; [EOL]         return true; [EOL]     } [EOL]     if ((quad >>> 8) == 0xEFBBBF) { [EOL]         _inputPtr += 3; [EOL]         _bytesPerChar = 1; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
private boolean handleBOM(int quad) throws IOException { [EOL]     switch(quad) { [EOL]         case 0x0000FEFF: [EOL]             _bigEndian = true; [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             return true; [EOL]         case 0xFFFE0000: [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             _bigEndian = false; [EOL]             return true; [EOL]         case 0x0000FFFE: [EOL]             reportWeirdUCS4("2143"); [EOL]         case 0xFEFF0000: [EOL]             reportWeirdUCS4("3412"); [EOL]     } [EOL]     int msw = quad >>> 16; [EOL]     if (msw == 0xFEFF) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     if (msw == 0xFFFE) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = false; [EOL]         return true; [EOL]     } [EOL]     if ((quad >>> 8) == 0xEFBBBF) { [EOL]         _inputPtr += 3; [EOL]         _bytesPerChar = 1; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
private boolean handleBOM(int quad) throws IOException { [EOL]     switch(quad) { [EOL]         case 0x0000FEFF: [EOL]             _bigEndian = true; [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             return true; [EOL]         case 0xFFFE0000: [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             _bigEndian = false; [EOL]             return true; [EOL]         case 0x0000FFFE: [EOL]             reportWeirdUCS4("2143"); [EOL]         case 0xFEFF0000: [EOL]             reportWeirdUCS4("3412"); [EOL]     } [EOL]     int msw = quad >>> 16; [EOL]     if (msw == 0xFEFF) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     if (msw == 0xFFFE) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = false; [EOL]         return true; [EOL]     } [EOL]     if ((quad >>> 8) == 0xEFBBBF) { [EOL]         _inputPtr += 3; [EOL]         _bytesPerChar = 1; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
private boolean handleBOM(int quad) throws IOException { [EOL]     switch(quad) { [EOL]         case 0x0000FEFF: [EOL]             _bigEndian = true; [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             return true; [EOL]         case 0xFFFE0000: [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             _bigEndian = false; [EOL]             return true; [EOL]         case 0x0000FFFE: [EOL]             reportWeirdUCS4("2143"); [EOL]         case 0xFEFF0000: [EOL]             reportWeirdUCS4("3412"); [EOL]     } [EOL]     int msw = quad >>> 16; [EOL]     if (msw == 0xFEFF) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     if (msw == 0xFFFE) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = false; [EOL]         return true; [EOL]     } [EOL]     if ((quad >>> 8) == 0xEFBBBF) { [EOL]         _inputPtr += 3; [EOL]         _bytesPerChar = 1; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
private boolean handleBOM(int quad) throws IOException { [EOL]     switch(quad) { [EOL]         case 0x0000FEFF: [EOL]             _bigEndian = true; [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             return true; [EOL]         case 0xFFFE0000: [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             _bigEndian = false; [EOL]             return true; [EOL]         case 0x0000FFFE: [EOL]             reportWeirdUCS4("2143"); [EOL]         case 0xFEFF0000: [EOL]             reportWeirdUCS4("3412"); [EOL]     } [EOL]     int msw = quad >>> 16; [EOL]     if (msw == 0xFEFF) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     if (msw == 0xFFFE) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = false; [EOL]         return true; [EOL]     } [EOL]     if ((quad >>> 8) == 0xEFBBBF) { [EOL]         _inputPtr += 3; [EOL]         _bytesPerChar = 1; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
private boolean handleBOM(int quad) throws IOException { [EOL]     switch(quad) { [EOL]         case 0x0000FEFF: [EOL]             _bigEndian = true; [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             return true; [EOL]         case 0xFFFE0000: [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             _bigEndian = false; [EOL]             return true; [EOL]         case 0x0000FFFE: [EOL]             reportWeirdUCS4("2143"); [EOL]         case 0xFEFF0000: [EOL]             reportWeirdUCS4("3412"); [EOL]     } [EOL]     int msw = quad >>> 16; [EOL]     if (msw == 0xFEFF) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     if (msw == 0xFFFE) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = false; [EOL]         return true; [EOL]     } [EOL]     if ((quad >>> 8) == 0xEFBBBF) { [EOL]         _inputPtr += 3; [EOL]         _bytesPerChar = 1; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
private boolean handleBOM(int quad) throws IOException { [EOL]     switch(quad) { [EOL]         case 0x0000FEFF: [EOL]             _bigEndian = true; [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             return true; [EOL]         case 0xFFFE0000: [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             _bigEndian = false; [EOL]             return true; [EOL]         case 0x0000FFFE: [EOL]             reportWeirdUCS4("2143"); [EOL]         case 0xFEFF0000: [EOL]             reportWeirdUCS4("3412"); [EOL]     } [EOL]     int msw = quad >>> 16; [EOL]     if (msw == 0xFEFF) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     if (msw == 0xFFFE) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = false; [EOL]         return true; [EOL]     } [EOL]     if ((quad >>> 8) == 0xEFBBBF) { [EOL]         _inputPtr += 3; [EOL]         _bytesPerChar = 1; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
private boolean handleBOM(int quad) throws IOException { [EOL]     switch(quad) { [EOL]         case 0x0000FEFF: [EOL]             _bigEndian = true; [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             return true; [EOL]         case 0xFFFE0000: [EOL]             _inputPtr += 4; [EOL]             _bytesPerChar = 4; [EOL]             _bigEndian = false; [EOL]             return true; [EOL]         case 0x0000FFFE: [EOL]             reportWeirdUCS4("2143"); [EOL]         case 0xFEFF0000: [EOL]             reportWeirdUCS4("3412"); [EOL]     } [EOL]     int msw = quad >>> 16; [EOL]     if (msw == 0xFEFF) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     if (msw == 0xFFFE) { [EOL]         _inputPtr += 2; [EOL]         _bytesPerChar = 2; [EOL]         _bigEndian = false; [EOL]         return true; [EOL]     } [EOL]     if ((quad >>> 8) == 0xEFBBBF) { [EOL]         _inputPtr += 3; [EOL]         _bytesPerChar = 1; [EOL]         _bigEndian = true; [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected boolean ensureLoaded(int minimum) throws IOException { [EOL]     int gotten = (_inputEnd - _inputPtr); [EOL]     while (gotten < minimum) { [EOL]         int count; [EOL]         if (_in == null) { [EOL]             count = -1; [EOL]         } else { [EOL]             count = _in.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd); [EOL]         } [EOL]         if (count < 1) { [EOL]             return false; [EOL]         } [EOL]         _inputEnd += count; [EOL]         gotten += count; [EOL]     } [EOL]     return true; [EOL] }
protected boolean ensureLoaded(int minimum) throws IOException { [EOL]     int gotten = (_inputEnd - _inputPtr); [EOL]     while (gotten < minimum) { [EOL]         int count; [EOL]         if (_in == null) { [EOL]             count = -1; [EOL]         } else { [EOL]             count = _in.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd); [EOL]         } [EOL]         if (count < 1) { [EOL]             return false; [EOL]         } [EOL]         _inputEnd += count; [EOL]         gotten += count; [EOL]     } [EOL]     return true; [EOL] }
protected boolean ensureLoaded(int minimum) throws IOException { [EOL]     int gotten = (_inputEnd - _inputPtr); [EOL]     while (gotten < minimum) { [EOL]         int count; [EOL]         if (_in == null) { [EOL]             count = -1; [EOL]         } else { [EOL]             count = _in.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd); [EOL]         } [EOL]         if (count < 1) { [EOL]             return false; [EOL]         } [EOL]         _inputEnd += count; [EOL]         gotten += count; [EOL]     } [EOL]     return true; [EOL] }
protected boolean ensureLoaded(int minimum) throws IOException { [EOL]     int gotten = (_inputEnd - _inputPtr); [EOL]     while (gotten < minimum) { [EOL]         int count; [EOL]         if (_in == null) { [EOL]             count = -1; [EOL]         } else { [EOL]             count = _in.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd); [EOL]         } [EOL]         if (count < 1) { [EOL]             return false; [EOL]         } [EOL]         _inputEnd += count; [EOL]         gotten += count; [EOL]     } [EOL]     return true; [EOL] }
public final void writeNumberField(String fieldName, long value) throws IOException, JsonGenerationException { [EOL]     writeFieldName(fieldName); [EOL]     writeNumber(value); [EOL] }
public final void writeNumberField(String fieldName, long value) throws IOException, JsonGenerationException { [EOL]     writeFieldName(fieldName); [EOL]     writeNumber(value); [EOL] }
public final void writeNumberField(String fieldName, long value) throws IOException, JsonGenerationException { [EOL]     writeFieldName(fieldName); [EOL]     writeNumber(value); [EOL] }
public final void writeNumberField(String fieldName, double value) throws IOException, JsonGenerationException { [EOL]     writeFieldName(fieldName); [EOL]     writeNumber(value); [EOL] }
public final void writeNumberField(String fieldName, double value) throws IOException, JsonGenerationException { [EOL]     writeFieldName(fieldName); [EOL]     writeNumber(value); [EOL] }
public final void writeNumberField(String fieldName, double value) throws IOException, JsonGenerationException { [EOL]     writeFieldName(fieldName); [EOL]     writeNumber(value); [EOL] }
public final void writeNumberField(String fieldName, float value) throws IOException, JsonGenerationException { [EOL]     writeFieldName(fieldName); [EOL]     writeNumber(value); [EOL] }
public final void writeNumberField(String fieldName, float value) throws IOException, JsonGenerationException { [EOL]     writeFieldName(fieldName); [EOL]     writeNumber(value); [EOL] }
public final void writeNumberField(String fieldName, float value) throws IOException, JsonGenerationException { [EOL]     writeFieldName(fieldName); [EOL]     writeNumber(value); [EOL] }
public int decodeBase64Char(char c) { [EOL]     int ch = (int) c; [EOL]     return (ch <= 127) ? _asciiToBase64[ch] : BASE64_VALUE_INVALID; [EOL] }
public int decodeBase64Char(char c) { [EOL]     int ch = (int) c; [EOL]     return (ch <= 127) ? _asciiToBase64[ch] : BASE64_VALUE_INVALID; [EOL] }
public int decodeBase64Char(int ch) { [EOL]     return (ch <= 127) ? _asciiToBase64[ch] : BASE64_VALUE_INVALID; [EOL] }
public int decodeBase64Char(int ch) { [EOL]     return (ch <= 127) ? _asciiToBase64[ch] : BASE64_VALUE_INVALID; [EOL] }
public int decodeBase64Char(int ch) { [EOL]     return (ch <= 127) ? _asciiToBase64[ch] : BASE64_VALUE_INVALID; [EOL] }
public char encodeBase64BitsAsChar(int value) { [EOL]     return _base64ToAsciiC[value]; [EOL] }
public char encodeBase64BitsAsChar(int value) { [EOL]     return _base64ToAsciiC[value]; [EOL] }
public void encodeBase64Chunk(StringBuilder sb, int b24) { [EOL]     sb.append(_base64ToAsciiC[(b24 >> 18) & 0x3F]); [EOL]     sb.append(_base64ToAsciiC[(b24 >> 12) & 0x3F]); [EOL]     sb.append(_base64ToAsciiC[(b24 >> 6) & 0x3F]); [EOL]     sb.append(_base64ToAsciiC[b24 & 0x3F]); [EOL] }
public void encodeBase64Chunk(StringBuilder sb, int b24) { [EOL]     sb.append(_base64ToAsciiC[(b24 >> 18) & 0x3F]); [EOL]     sb.append(_base64ToAsciiC[(b24 >> 12) & 0x3F]); [EOL]     sb.append(_base64ToAsciiC[(b24 >> 6) & 0x3F]); [EOL]     sb.append(_base64ToAsciiC[b24 & 0x3F]); [EOL] }
public void encodeBase64Chunk(StringBuilder sb, int b24) { [EOL]     sb.append(_base64ToAsciiC[(b24 >> 18) & 0x3F]); [EOL]     sb.append(_base64ToAsciiC[(b24 >> 12) & 0x3F]); [EOL]     sb.append(_base64ToAsciiC[(b24 >> 6) & 0x3F]); [EOL]     sb.append(_base64ToAsciiC[b24 & 0x3F]); [EOL] }
public void encodeBase64Chunk(StringBuilder sb, int b24) { [EOL]     sb.append(_base64ToAsciiC[(b24 >> 18) & 0x3F]); [EOL]     sb.append(_base64ToAsciiC[(b24 >> 12) & 0x3F]); [EOL]     sb.append(_base64ToAsciiC[(b24 >> 6) & 0x3F]); [EOL]     sb.append(_base64ToAsciiC[b24 & 0x3F]); [EOL] }
public void encodeBase64Chunk(StringBuilder sb, int b24) { [EOL]     sb.append(_base64ToAsciiC[(b24 >> 18) & 0x3F]); [EOL]     sb.append(_base64ToAsciiC[(b24 >> 12) & 0x3F]); [EOL]     sb.append(_base64ToAsciiC[(b24 >> 6) & 0x3F]); [EOL]     sb.append(_base64ToAsciiC[b24 & 0x3F]); [EOL] }
public byte encodeBase64BitsAsByte(int value) { [EOL]     return _base64ToAsciiB[value]; [EOL] }
public byte encodeBase64BitsAsByte(int value) { [EOL]     return _base64ToAsciiB[value]; [EOL] }
public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r, ObjectCodec codec, CharsToNameCanonicalizer st) { [EOL]     super(ctxt, features); [EOL]     _reader = r; [EOL]     _inputBuffer = ctxt.allocTokenBuffer(); [EOL]     _objectCodec = codec; [EOL]     _symbols = st; [EOL]     _hashSeed = st.hashSeed(); [EOL] }
@Override [EOL] public int releaseBuffered(Writer w) throws IOException { [EOL]     int count = _inputEnd - _inputPtr; [EOL]     if (count < 1) { [EOL]         return 0; [EOL]     } [EOL]     int origPtr = _inputPtr; [EOL]     w.write(_inputBuffer, origPtr, count); [EOL]     return count; [EOL] }
@Override [EOL] public int releaseBuffered(Writer w) throws IOException { [EOL]     int count = _inputEnd - _inputPtr; [EOL]     if (count < 1) { [EOL]         return 0; [EOL]     } [EOL]     int origPtr = _inputPtr; [EOL]     w.write(_inputBuffer, origPtr, count); [EOL]     return count; [EOL] }
@Override [EOL] protected boolean loadMore() throws IOException { [EOL]     _currInputProcessed += _inputEnd; [EOL]     _currInputRowStart -= _inputEnd; [EOL]     if (_reader != null) { [EOL]         int count = _reader.read(_inputBuffer, 0, _inputBuffer.length); [EOL]         if (count > 0) { [EOL]             _inputPtr = 0; [EOL]             _inputEnd = count; [EOL]             return true; [EOL]         } [EOL]         _closeInput(); [EOL]         if (count == 0) { [EOL]             throw new IOException("Reader returned 0 characters when trying to read " + _inputEnd); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] protected boolean loadMore() throws IOException { [EOL]     _currInputProcessed += _inputEnd; [EOL]     _currInputRowStart -= _inputEnd; [EOL]     if (_reader != null) { [EOL]         int count = _reader.read(_inputBuffer, 0, _inputBuffer.length); [EOL]         if (count > 0) { [EOL]             _inputPtr = 0; [EOL]             _inputEnd = count; [EOL]             return true; [EOL]         } [EOL]         _closeInput(); [EOL]         if (count == 0) { [EOL]             throw new IOException("Reader returned 0 characters when trying to read " + _inputEnd); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] protected boolean loadMore() throws IOException { [EOL]     _currInputProcessed += _inputEnd; [EOL]     _currInputRowStart -= _inputEnd; [EOL]     if (_reader != null) { [EOL]         int count = _reader.read(_inputBuffer, 0, _inputBuffer.length); [EOL]         if (count > 0) { [EOL]             _inputPtr = 0; [EOL]             _inputEnd = count; [EOL]             return true; [EOL]         } [EOL]         _closeInput(); [EOL]         if (count == 0) { [EOL]             throw new IOException("Reader returned 0 characters when trying to read " + _inputEnd); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] protected boolean loadMore() throws IOException { [EOL]     _currInputProcessed += _inputEnd; [EOL]     _currInputRowStart -= _inputEnd; [EOL]     if (_reader != null) { [EOL]         int count = _reader.read(_inputBuffer, 0, _inputBuffer.length); [EOL]         if (count > 0) { [EOL]             _inputPtr = 0; [EOL]             _inputEnd = count; [EOL]             return true; [EOL]         } [EOL]         _closeInput(); [EOL]         if (count == 0) { [EOL]             throw new IOException("Reader returned 0 characters when trying to read " + _inputEnd); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] protected void _closeInput() throws IOException { [EOL]     if (_reader != null) { [EOL]         if (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) { [EOL]             _reader.close(); [EOL]         } [EOL]         _reader = null; [EOL]     } [EOL] }
@Override [EOL] protected void _releaseBuffers() throws IOException { [EOL]     super._releaseBuffers(); [EOL]     char[] buf = _inputBuffer; [EOL]     if (buf != null) { [EOL]         _inputBuffer = null; [EOL]         _ioContext.releaseTokenBuffer(buf); [EOL]     } [EOL] }
@Override [EOL] protected void _releaseBuffers() throws IOException { [EOL]     super._releaseBuffers(); [EOL]     char[] buf = _inputBuffer; [EOL]     if (buf != null) { [EOL]         _inputBuffer = null; [EOL]         _ioContext.releaseTokenBuffer(buf); [EOL]     } [EOL] }
@Override [EOL] public String getText() throws IOException, JsonParseException { [EOL]     JsonToken t = _currToken; [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         if (_tokenIncomplete) { [EOL]             _tokenIncomplete = false; [EOL]             _finishString(); [EOL]         } [EOL]         return _textBuffer.contentsAsString(); [EOL]     } [EOL]     return _getText2(t); [EOL] }
@Override [EOL] public String getText() throws IOException, JsonParseException { [EOL]     JsonToken t = _currToken; [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         if (_tokenIncomplete) { [EOL]             _tokenIncomplete = false; [EOL]             _finishString(); [EOL]         } [EOL]         return _textBuffer.contentsAsString(); [EOL]     } [EOL]     return _getText2(t); [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     _numTypesValid = NR_UNKNOWN; [EOL]     if (_currToken == JsonToken.FIELD_NAME) { [EOL]         return _nextAfterName(); [EOL]     } [EOL]     if (_tokenIncomplete) { [EOL]         _skipString(); [EOL]     } [EOL]     int i = _skipWSOrEnd(); [EOL]     if (i < 0) { [EOL]         close(); [EOL]         return (_currToken = null); [EOL]     } [EOL]     _tokenInputTotal = _currInputProcessed + _inputPtr - 1; [EOL]     _tokenInputRow = _currInputRow; [EOL]     _tokenInputCol = _inputPtr - _currInputRowStart - 1; [EOL]     _binaryValue = null; [EOL]     if (i == INT_RBRACKET) { [EOL]         if (!_parsingContext.inArray()) { [EOL]             _reportMismatchedEndMarker(i, '}'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_ARRAY); [EOL]     } [EOL]     if (i == INT_RCURLY) { [EOL]         if (!_parsingContext.inObject()) { [EOL]             _reportMismatchedEndMarker(i, ']'); [EOL]         } [EOL]         _parsingContext = _parsingContext.getParent(); [EOL]         return (_currToken = JsonToken.END_OBJECT); [EOL]     } [EOL]     if (_parsingContext.expectComma()) { [EOL]         if (i != INT_COMMA) { [EOL]             _reportUnexpectedChar(i, "was expecting comma to separate " + _parsingContext.getTypeDesc() + " entries"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     boolean inObject = _parsingContext.inObject(); [EOL]     if (inObject) { [EOL]         String name = _parseFieldName(i); [EOL]         _parsingContext.setCurrentName(name); [EOL]         _currToken = JsonToken.FIELD_NAME; [EOL]         i = _skipWS(); [EOL]         if (i != INT_COLON) { [EOL]             _reportUnexpectedChar(i, "was expecting a colon to separate field name and value"); [EOL]         } [EOL]         i = _skipWS(); [EOL]     } [EOL]     JsonToken t; [EOL]     switch(i) { [EOL]         case INT_QUOTE: [EOL]             _tokenIncomplete = true; [EOL]             t = JsonToken.VALUE_STRING; [EOL]             break; [EOL]         case INT_LBRACKET: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_ARRAY; [EOL]             break; [EOL]         case INT_LCURLY: [EOL]             if (!inObject) { [EOL]                 _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]             } [EOL]             t = JsonToken.START_OBJECT; [EOL]             break; [EOL]         case INT_RBRACKET: [EOL]         case INT_RCURLY: [EOL]             _reportUnexpectedChar(i, "expected a value"); [EOL]         case INT_t: [EOL]             _matchToken("true", 1); [EOL]             t = JsonToken.VALUE_TRUE; [EOL]             break; [EOL]         case INT_f: [EOL]             _matchToken("false", 1); [EOL]             t = JsonToken.VALUE_FALSE; [EOL]             break; [EOL]         case INT_n: [EOL]             _matchToken("null", 1); [EOL]             t = JsonToken.VALUE_NULL; [EOL]             break; [EOL]         case INT_MINUS: [EOL]         case INT_0: [EOL]         case INT_1: [EOL]         case INT_2: [EOL]         case INT_3: [EOL]         case INT_4: [EOL]         case INT_5: [EOL]         case INT_6: [EOL]         case INT_7: [EOL]         case INT_8: [EOL]         case INT_9: [EOL]             t = parseNumberText(i); [EOL]             break; [EOL]         default: [EOL]             t = _handleUnexpectedValue(i); [EOL]             break; [EOL]     } [EOL]     if (inObject) { [EOL]         _nextToken = t; [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = t; [EOL]     return t; [EOL] }
private JsonToken _nextAfterName() { [EOL]     _nameCopied = false; [EOL]     JsonToken t = _nextToken; [EOL]     _nextToken = null; [EOL]     if (t == JsonToken.START_ARRAY) { [EOL]         _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]     } else if (t == JsonToken.START_OBJECT) { [EOL]         _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]     } [EOL]     return (_currToken = t); [EOL] }
private JsonToken _nextAfterName() { [EOL]     _nameCopied = false; [EOL]     JsonToken t = _nextToken; [EOL]     _nextToken = null; [EOL]     if (t == JsonToken.START_ARRAY) { [EOL]         _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]     } else if (t == JsonToken.START_OBJECT) { [EOL]         _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]     } [EOL]     return (_currToken = t); [EOL] }
private JsonToken _nextAfterName() { [EOL]     _nameCopied = false; [EOL]     JsonToken t = _nextToken; [EOL]     _nextToken = null; [EOL]     if (t == JsonToken.START_ARRAY) { [EOL]         _parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol); [EOL]     } else if (t == JsonToken.START_OBJECT) { [EOL]         _parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol); [EOL]     } [EOL]     return (_currToken = t); [EOL] }
@Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     _symbols.release(); [EOL] }
@Override [EOL] public void close() throws IOException { [EOL]     super.close(); [EOL]     _symbols.release(); [EOL] }
protected JsonToken parseNumberText(int ch) throws IOException, JsonParseException { [EOL]     boolean negative = (ch == INT_MINUS); [EOL]     int ptr = _inputPtr; [EOL]     int startPtr = ptr - 1; [EOL]     final int inputLen = _inputEnd; [EOL]     dummy_loop: do { [EOL]         if (negative) { [EOL]             if (ptr >= _inputEnd) { [EOL]                 break dummy_loop; [EOL]             } [EOL]             ch = _inputBuffer[ptr++]; [EOL]             if (ch > INT_9 || ch < INT_0) { [EOL]                 _inputPtr = ptr; [EOL]                 return _handleInvalidNumberStart(ch, true); [EOL]             } [EOL]         } [EOL]         if (ch == INT_0) { [EOL]             break dummy_loop; [EOL]         } [EOL]         int intLen = 1; [EOL]         int_loop: while (true) { [EOL]             if (ptr >= _inputEnd) { [EOL]                 break dummy_loop; [EOL]             } [EOL]             ch = (int) _inputBuffer[ptr++]; [EOL]             if (ch < INT_0 || ch > INT_9) { [EOL]                 break int_loop; [EOL]             } [EOL]             ++intLen; [EOL]         } [EOL]         int fractLen = 0; [EOL]         if (ch == INT_DECIMAL_POINT) { [EOL]             fract_loop: while (true) { [EOL]                 if (ptr >= inputLen) { [EOL]                     break dummy_loop; [EOL]                 } [EOL]                 ch = (int) _inputBuffer[ptr++]; [EOL]                 if (ch < INT_0 || ch > INT_9) { [EOL]                     break fract_loop; [EOL]                 } [EOL]                 ++fractLen; [EOL]             } [EOL]             if (fractLen == 0) { [EOL]                 reportUnexpectedNumberChar(ch, "Decimal point not followed by a digit"); [EOL]             } [EOL]         } [EOL]         int expLen = 0; [EOL]         if (ch == INT_e || ch == INT_E) { [EOL]             if (ptr >= inputLen) { [EOL]                 break dummy_loop; [EOL]             } [EOL]             ch = (int) _inputBuffer[ptr++]; [EOL]             if (ch == INT_MINUS || ch == INT_PLUS) { [EOL]                 if (ptr >= inputLen) { [EOL]                     break dummy_loop; [EOL]                 } [EOL]                 ch = (int) _inputBuffer[ptr++]; [EOL]             } [EOL]             while (ch <= INT_9 && ch >= INT_0) { [EOL]                 ++expLen; [EOL]                 if (ptr >= inputLen) { [EOL]                     break dummy_loop; [EOL]                 } [EOL]                 ch = (int) _inputBuffer[ptr++]; [EOL]             } [EOL]             if (expLen == 0) { [EOL]                 reportUnexpectedNumberChar(ch, "Exponent indicator not followed by a digit"); [EOL]             } [EOL]         } [EOL]         --ptr; [EOL]         _inputPtr = ptr; [EOL]         int len = ptr - startPtr; [EOL]         _textBuffer.resetWithShared(_inputBuffer, startPtr, len); [EOL]         return reset(negative, intLen, fractLen, expLen); [EOL]     } while (false); [EOL]     _inputPtr = negative ? (startPtr + 1) : startPtr; [EOL]     return parseNumberText2(negative); [EOL] }
private JsonToken parseNumberText2(boolean negative) throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = 0; [EOL]     if (negative) { [EOL]         outBuf[outPtr++] = '-'; [EOL]     } [EOL]     int intLen = 0; [EOL]     char c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar("No digit following minus sign"); [EOL]     if (c == '0') { [EOL]         c = _verifyNoLeadingZeroes(); [EOL]     } [EOL]     boolean eof = false; [EOL]     int_loop: while (c >= '0' && c <= '9') { [EOL]         ++intLen; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]         if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]             c = CHAR_NULL; [EOL]             eof = true; [EOL]             break int_loop; [EOL]         } [EOL]         c = _inputBuffer[_inputPtr++]; [EOL]     } [EOL]     if (intLen == 0) { [EOL]         reportInvalidNumber("Missing integer part (next char " + _getCharDesc(c) + ")"); [EOL]     } [EOL]     int fractLen = 0; [EOL]     if (c == '.') { [EOL]         outBuf[outPtr++] = c; [EOL]         fract_loop: while (true) { [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break fract_loop; [EOL]             } [EOL]             c = _inputBuffer[_inputPtr++]; [EOL]             if (c < INT_0 || c > INT_9) { [EOL]                 break fract_loop; [EOL]             } [EOL]             ++fractLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = c; [EOL]         } [EOL]         if (fractLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Decimal point not followed by a digit"); [EOL]         } [EOL]     } [EOL]     int expLen = 0; [EOL]     if (c == 'e' || c == 'E') { [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]         c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar("expected a digit for number exponent"); [EOL]         if (c == '-' || c == '+') { [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = c; [EOL]             c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar("expected a digit for number exponent"); [EOL]         } [EOL]         exp_loop: while (c <= INT_9 && c >= INT_0) { [EOL]             ++expLen; [EOL]             if (outPtr >= outBuf.length) { [EOL]                 outBuf = _textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outBuf[outPtr++] = c; [EOL]             if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]                 eof = true; [EOL]                 break exp_loop; [EOL]             } [EOL]             c = _inputBuffer[_inputPtr++]; [EOL]         } [EOL]         if (expLen == 0) { [EOL]             reportUnexpectedNumberChar(c, "Exponent indicator not followed by a digit"); [EOL]         } [EOL]     } [EOL]     if (!eof) { [EOL]         --_inputPtr; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return reset(negative, intLen, fractLen, expLen); [EOL] }
private char _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return '0'; [EOL]     } [EOL]     char ch = _inputBuffer[_inputPtr]; [EOL]     if (ch < '0' || ch > '9') { [EOL]         return '0'; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr]; [EOL]             if (ch < '0' || ch > '9') { [EOL]                 return '0'; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != '0') { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] }
private char _verifyNoLeadingZeroes() throws IOException, JsonParseException { [EOL]     if (_inputPtr >= _inputEnd && !loadMore()) { [EOL]         return '0'; [EOL]     } [EOL]     char ch = _inputBuffer[_inputPtr]; [EOL]     if (ch < '0' || ch > '9') { [EOL]         return '0'; [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) { [EOL]         reportInvalidNumber("Leading zeroes not allowed"); [EOL]     } [EOL]     ++_inputPtr; [EOL]     if (ch == INT_0) { [EOL]         while (_inputPtr < _inputEnd || loadMore()) { [EOL]             ch = _inputBuffer[_inputPtr]; [EOL]             if (ch < '0' || ch > '9') { [EOL]                 return '0'; [EOL]             } [EOL]             ++_inputPtr; [EOL]             if (ch != '0') { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     return ch; [EOL] }
protected String _parseFieldName(int i) throws IOException, JsonParseException { [EOL]     if (i != INT_QUOTE) { [EOL]         return _handleUnusualFieldName(i); [EOL]     } [EOL]     int ptr = _inputPtr; [EOL]     int hash = _hashSeed; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         final int[] codes = CharTypes.getInputCodeLatin1(); [EOL]         final int maxCode = codes.length; [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch < maxCode && codes[ch] != 0) { [EOL]                 if (ch == '"') { [EOL]                     int start = _inputPtr; [EOL]                     _inputPtr = ptr + 1; [EOL]                     return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]             hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     int start = _inputPtr; [EOL]     _inputPtr = ptr; [EOL]     return _parseFieldName2(start, hash, INT_QUOTE); [EOL] }
protected String _parseFieldName(int i) throws IOException, JsonParseException { [EOL]     if (i != INT_QUOTE) { [EOL]         return _handleUnusualFieldName(i); [EOL]     } [EOL]     int ptr = _inputPtr; [EOL]     int hash = _hashSeed; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         final int[] codes = CharTypes.getInputCodeLatin1(); [EOL]         final int maxCode = codes.length; [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch < maxCode && codes[ch] != 0) { [EOL]                 if (ch == '"') { [EOL]                     int start = _inputPtr; [EOL]                     _inputPtr = ptr + 1; [EOL]                     return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]             hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     int start = _inputPtr; [EOL]     _inputPtr = ptr; [EOL]     return _parseFieldName2(start, hash, INT_QUOTE); [EOL] }
protected String _parseFieldName(int i) throws IOException, JsonParseException { [EOL]     if (i != INT_QUOTE) { [EOL]         return _handleUnusualFieldName(i); [EOL]     } [EOL]     int ptr = _inputPtr; [EOL]     int hash = _hashSeed; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         final int[] codes = CharTypes.getInputCodeLatin1(); [EOL]         final int maxCode = codes.length; [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch < maxCode && codes[ch] != 0) { [EOL]                 if (ch == '"') { [EOL]                     int start = _inputPtr; [EOL]                     _inputPtr = ptr + 1; [EOL]                     return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]             hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     int start = _inputPtr; [EOL]     _inputPtr = ptr; [EOL]     return _parseFieldName2(start, hash, INT_QUOTE); [EOL] }
protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_APOSTROPHE && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]         return _parseApostropheFieldName(); [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { [EOL]         _reportUnexpectedChar(i, "was expecting double-quote to start field name"); [EOL]     } [EOL]     final int[] codes = CharTypes.getInputCodeLatin1JsNames(); [EOL]     final int maxCode = codes.length; [EOL]     boolean firstOk; [EOL]     if (i < maxCode) { [EOL]         firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9); [EOL]     } else { [EOL]         firstOk = Character.isJavaIdentifierPart((char) i); [EOL]     } [EOL]     if (!firstOk) { [EOL]         _reportUnexpectedChar(i, "was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"); [EOL]     } [EOL]     int ptr = _inputPtr; [EOL]     int hash = _hashSeed; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch < maxCode) { [EOL]                 if (codes[ch] != 0) { [EOL]                     int start = _inputPtr - 1; [EOL]                     _inputPtr = ptr; [EOL]                     return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]                 } [EOL]             } else if (!Character.isJavaIdentifierPart((char) ch)) { [EOL]                 int start = _inputPtr - 1; [EOL]                 _inputPtr = ptr; [EOL]                 return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]             } [EOL]             hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     int start = _inputPtr - 1; [EOL]     _inputPtr = ptr; [EOL]     return _parseUnusualFieldName2(start, hash, codes); [EOL] }
protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_APOSTROPHE && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]         return _parseApostropheFieldName(); [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { [EOL]         _reportUnexpectedChar(i, "was expecting double-quote to start field name"); [EOL]     } [EOL]     final int[] codes = CharTypes.getInputCodeLatin1JsNames(); [EOL]     final int maxCode = codes.length; [EOL]     boolean firstOk; [EOL]     if (i < maxCode) { [EOL]         firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9); [EOL]     } else { [EOL]         firstOk = Character.isJavaIdentifierPart((char) i); [EOL]     } [EOL]     if (!firstOk) { [EOL]         _reportUnexpectedChar(i, "was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"); [EOL]     } [EOL]     int ptr = _inputPtr; [EOL]     int hash = _hashSeed; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch < maxCode) { [EOL]                 if (codes[ch] != 0) { [EOL]                     int start = _inputPtr - 1; [EOL]                     _inputPtr = ptr; [EOL]                     return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]                 } [EOL]             } else if (!Character.isJavaIdentifierPart((char) ch)) { [EOL]                 int start = _inputPtr - 1; [EOL]                 _inputPtr = ptr; [EOL]                 return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]             } [EOL]             hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     int start = _inputPtr - 1; [EOL]     _inputPtr = ptr; [EOL]     return _parseUnusualFieldName2(start, hash, codes); [EOL] }
protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_APOSTROPHE && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]         return _parseApostropheFieldName(); [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { [EOL]         _reportUnexpectedChar(i, "was expecting double-quote to start field name"); [EOL]     } [EOL]     final int[] codes = CharTypes.getInputCodeLatin1JsNames(); [EOL]     final int maxCode = codes.length; [EOL]     boolean firstOk; [EOL]     if (i < maxCode) { [EOL]         firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9); [EOL]     } else { [EOL]         firstOk = Character.isJavaIdentifierPart((char) i); [EOL]     } [EOL]     if (!firstOk) { [EOL]         _reportUnexpectedChar(i, "was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"); [EOL]     } [EOL]     int ptr = _inputPtr; [EOL]     int hash = _hashSeed; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch < maxCode) { [EOL]                 if (codes[ch] != 0) { [EOL]                     int start = _inputPtr - 1; [EOL]                     _inputPtr = ptr; [EOL]                     return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]                 } [EOL]             } else if (!Character.isJavaIdentifierPart((char) ch)) { [EOL]                 int start = _inputPtr - 1; [EOL]                 _inputPtr = ptr; [EOL]                 return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]             } [EOL]             hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     int start = _inputPtr - 1; [EOL]     _inputPtr = ptr; [EOL]     return _parseUnusualFieldName2(start, hash, codes); [EOL] }
protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_APOSTROPHE && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]         return _parseApostropheFieldName(); [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { [EOL]         _reportUnexpectedChar(i, "was expecting double-quote to start field name"); [EOL]     } [EOL]     final int[] codes = CharTypes.getInputCodeLatin1JsNames(); [EOL]     final int maxCode = codes.length; [EOL]     boolean firstOk; [EOL]     if (i < maxCode) { [EOL]         firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9); [EOL]     } else { [EOL]         firstOk = Character.isJavaIdentifierPart((char) i); [EOL]     } [EOL]     if (!firstOk) { [EOL]         _reportUnexpectedChar(i, "was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"); [EOL]     } [EOL]     int ptr = _inputPtr; [EOL]     int hash = _hashSeed; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch < maxCode) { [EOL]                 if (codes[ch] != 0) { [EOL]                     int start = _inputPtr - 1; [EOL]                     _inputPtr = ptr; [EOL]                     return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]                 } [EOL]             } else if (!Character.isJavaIdentifierPart((char) ch)) { [EOL]                 int start = _inputPtr - 1; [EOL]                 _inputPtr = ptr; [EOL]                 return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]             } [EOL]             hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     int start = _inputPtr - 1; [EOL]     _inputPtr = ptr; [EOL]     return _parseUnusualFieldName2(start, hash, codes); [EOL] }
protected String _handleUnusualFieldName(int i) throws IOException, JsonParseException { [EOL]     if (i == INT_APOSTROPHE && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]         return _parseApostropheFieldName(); [EOL]     } [EOL]     if (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) { [EOL]         _reportUnexpectedChar(i, "was expecting double-quote to start field name"); [EOL]     } [EOL]     final int[] codes = CharTypes.getInputCodeLatin1JsNames(); [EOL]     final int maxCode = codes.length; [EOL]     boolean firstOk; [EOL]     if (i < maxCode) { [EOL]         firstOk = (codes[i] == 0) && (i < INT_0 || i > INT_9); [EOL]     } else { [EOL]         firstOk = Character.isJavaIdentifierPart((char) i); [EOL]     } [EOL]     if (!firstOk) { [EOL]         _reportUnexpectedChar(i, "was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name"); [EOL]     } [EOL]     int ptr = _inputPtr; [EOL]     int hash = _hashSeed; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch < maxCode) { [EOL]                 if (codes[ch] != 0) { [EOL]                     int start = _inputPtr - 1; [EOL]                     _inputPtr = ptr; [EOL]                     return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]                 } [EOL]             } else if (!Character.isJavaIdentifierPart((char) ch)) { [EOL]                 int start = _inputPtr - 1; [EOL]                 _inputPtr = ptr; [EOL]                 return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]             } [EOL]             hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     int start = _inputPtr - 1; [EOL]     _inputPtr = ptr; [EOL]     return _parseUnusualFieldName2(start, hash, codes); [EOL] }
protected String _parseApostropheFieldName() throws IOException, JsonParseException { [EOL]     int ptr = _inputPtr; [EOL]     int hash = _hashSeed; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         final int[] codes = CharTypes.getInputCodeLatin1(); [EOL]         final int maxCode = codes.length; [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch == '\'') { [EOL]                 int start = _inputPtr; [EOL]                 _inputPtr = ptr + 1; [EOL]                 return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]             } [EOL]             if (ch < maxCode && codes[ch] != 0) { [EOL]                 break; [EOL]             } [EOL]             hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     int start = _inputPtr; [EOL]     _inputPtr = ptr; [EOL]     return _parseFieldName2(start, hash, INT_APOSTROPHE); [EOL] }
protected String _parseApostropheFieldName() throws IOException, JsonParseException { [EOL]     int ptr = _inputPtr; [EOL]     int hash = _hashSeed; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         final int[] codes = CharTypes.getInputCodeLatin1(); [EOL]         final int maxCode = codes.length; [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch == '\'') { [EOL]                 int start = _inputPtr; [EOL]                 _inputPtr = ptr + 1; [EOL]                 return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]             } [EOL]             if (ch < maxCode && codes[ch] != 0) { [EOL]                 break; [EOL]             } [EOL]             hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     int start = _inputPtr; [EOL]     _inputPtr = ptr; [EOL]     return _parseFieldName2(start, hash, INT_APOSTROPHE); [EOL] }
protected String _parseApostropheFieldName() throws IOException, JsonParseException { [EOL]     int ptr = _inputPtr; [EOL]     int hash = _hashSeed; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         final int[] codes = CharTypes.getInputCodeLatin1(); [EOL]         final int maxCode = codes.length; [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch == '\'') { [EOL]                 int start = _inputPtr; [EOL]                 _inputPtr = ptr + 1; [EOL]                 return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]             } [EOL]             if (ch < maxCode && codes[ch] != 0) { [EOL]                 break; [EOL]             } [EOL]             hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     int start = _inputPtr; [EOL]     _inputPtr = ptr; [EOL]     return _parseFieldName2(start, hash, INT_APOSTROPHE); [EOL] }
protected String _parseApostropheFieldName() throws IOException, JsonParseException { [EOL]     int ptr = _inputPtr; [EOL]     int hash = _hashSeed; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         final int[] codes = CharTypes.getInputCodeLatin1(); [EOL]         final int maxCode = codes.length; [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch == '\'') { [EOL]                 int start = _inputPtr; [EOL]                 _inputPtr = ptr + 1; [EOL]                 return _symbols.findSymbol(_inputBuffer, start, ptr - start, hash); [EOL]             } [EOL]             if (ch < maxCode && codes[ch] != 0) { [EOL]                 break; [EOL]             } [EOL]             hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch; [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     int start = _inputPtr; [EOL]     _inputPtr = ptr; [EOL]     return _parseFieldName2(start, hash, INT_APOSTROPHE); [EOL] }
protected JsonToken _handleUnexpectedValue(int i) throws IOException, JsonParseException { [EOL]     switch(i) { [EOL]         case '\'': [EOL]             if (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]                 return _handleApostropheValue(); [EOL]             } [EOL]             break; [EOL]         case 'N': [EOL]             _matchToken("NaN", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("NaN", Double.NaN); [EOL]             } [EOL]             _reportError("Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case 'I': [EOL]             _matchToken("Infinity", 1); [EOL]             if (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) { [EOL]                 return resetAsNaN("Infinity", Double.POSITIVE_INFINITY); [EOL]             } [EOL]             _reportError("Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow"); [EOL]             break; [EOL]         case '+': [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 if (!loadMore()) { [EOL]                     _reportInvalidEOFInValue(); [EOL]                 } [EOL]             } [EOL]             return _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false); [EOL]     } [EOL]     if (Character.isJavaIdentifierStart(i)) { [EOL]         _reportInvalidToken("" + ((char) i), "('true', 'false' or 'null')"); [EOL]     } [EOL]     _reportUnexpectedChar(i, "expected a valid value (number, String, array, object, 'true', 'false' or 'null')"); [EOL]     return null; [EOL] }
protected JsonToken _handleApostropheValue() throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= INT_APOSTROPHE) { [EOL]                 if (i == INT_APOSTROPHE) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return JsonToken.VALUE_STRING; [EOL] }
protected JsonToken _handleApostropheValue() throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= INT_APOSTROPHE) { [EOL]                 if (i == INT_APOSTROPHE) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return JsonToken.VALUE_STRING; [EOL] }
protected JsonToken _handleApostropheValue() throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= INT_APOSTROPHE) { [EOL]                 if (i == INT_APOSTROPHE) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return JsonToken.VALUE_STRING; [EOL] }
protected JsonToken _handleApostropheValue() throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= INT_APOSTROPHE) { [EOL]                 if (i == INT_APOSTROPHE) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return JsonToken.VALUE_STRING; [EOL] }
protected JsonToken _handleApostropheValue() throws IOException, JsonParseException { [EOL]     char[] outBuf = _textBuffer.emptyAndGetCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidEOF(": was expecting closing quote for a string value"); [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr++]; [EOL]         int i = (int) c; [EOL]         if (i <= INT_BACKSLASH) { [EOL]             if (i == INT_BACKSLASH) { [EOL]                 c = _decodeEscaped(); [EOL]             } else if (i <= INT_APOSTROPHE) { [EOL]                 if (i == INT_APOSTROPHE) { [EOL]                     break; [EOL]                 } [EOL]                 if (i < INT_SPACE) { [EOL]                     _throwUnquotedSpace(i, "string value"); [EOL]                 } [EOL]             } [EOL]         } [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]         outBuf[outPtr++] = c; [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     return JsonToken.VALUE_STRING; [EOL] }
private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException { [EOL]     _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     final int maxCode = codes.length; [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr]; [EOL]         int i = (int) c; [EOL]         if (i <= maxCode) { [EOL]             if (codes[i] != 0) { [EOL]                 break; [EOL]             } [EOL]         } else if (!Character.isJavaIdentifierPart(c)) { [EOL]             break; [EOL]         } [EOL]         ++_inputPtr; [EOL]         hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; [EOL]         outBuf[outPtr++] = c; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     { [EOL]         TextBuffer tb = _textBuffer; [EOL]         char[] buf = tb.getTextBuffer(); [EOL]         int start = tb.getTextOffset(); [EOL]         int len = tb.size(); [EOL]         return _symbols.findSymbol(buf, start, len, hash); [EOL]     } [EOL] }
private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException { [EOL]     _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     final int maxCode = codes.length; [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr]; [EOL]         int i = (int) c; [EOL]         if (i <= maxCode) { [EOL]             if (codes[i] != 0) { [EOL]                 break; [EOL]             } [EOL]         } else if (!Character.isJavaIdentifierPart(c)) { [EOL]             break; [EOL]         } [EOL]         ++_inputPtr; [EOL]         hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; [EOL]         outBuf[outPtr++] = c; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     { [EOL]         TextBuffer tb = _textBuffer; [EOL]         char[] buf = tb.getTextBuffer(); [EOL]         int start = tb.getTextOffset(); [EOL]         int len = tb.size(); [EOL]         return _symbols.findSymbol(buf, start, len, hash); [EOL]     } [EOL] }
private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException { [EOL]     _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     final int maxCode = codes.length; [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr]; [EOL]         int i = (int) c; [EOL]         if (i <= maxCode) { [EOL]             if (codes[i] != 0) { [EOL]                 break; [EOL]             } [EOL]         } else if (!Character.isJavaIdentifierPart(c)) { [EOL]             break; [EOL]         } [EOL]         ++_inputPtr; [EOL]         hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; [EOL]         outBuf[outPtr++] = c; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     { [EOL]         TextBuffer tb = _textBuffer; [EOL]         char[] buf = tb.getTextBuffer(); [EOL]         int start = tb.getTextOffset(); [EOL]         int len = tb.size(); [EOL]         return _symbols.findSymbol(buf, start, len, hash); [EOL]     } [EOL] }
private String _parseUnusualFieldName2(int startPtr, int hash, int[] codes) throws IOException, JsonParseException { [EOL]     _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); [EOL]     char[] outBuf = _textBuffer.getCurrentSegment(); [EOL]     int outPtr = _textBuffer.getCurrentSegmentSize(); [EOL]     final int maxCode = codes.length; [EOL]     while (true) { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]         char c = _inputBuffer[_inputPtr]; [EOL]         int i = (int) c; [EOL]         if (i <= maxCode) { [EOL]             if (codes[i] != 0) { [EOL]                 break; [EOL]             } [EOL]         } else if (!Character.isJavaIdentifierPart(c)) { [EOL]             break; [EOL]         } [EOL]         ++_inputPtr; [EOL]         hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; [EOL]         outBuf[outPtr++] = c; [EOL]         if (outPtr >= outBuf.length) { [EOL]             outBuf = _textBuffer.finishCurrentSegment(); [EOL]             outPtr = 0; [EOL]         } [EOL]     } [EOL]     _textBuffer.setCurrentLength(outPtr); [EOL]     { [EOL]         TextBuffer tb = _textBuffer; [EOL]         char[] buf = tb.getTextBuffer(); [EOL]         int start = tb.getTextOffset(); [EOL]         int len = tb.size(); [EOL]         return _symbols.findSymbol(buf, start, len, hash); [EOL]     } [EOL] }
@Override [EOL] protected void _finishString() throws IOException, JsonParseException { [EOL]     int ptr = _inputPtr; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         final int[] codes = CharTypes.getInputCodeLatin1(); [EOL]         final int maxCode = codes.length; [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch < maxCode && codes[ch] != 0) { [EOL]                 if (ch == '"') { [EOL]                     _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr)); [EOL]                     _inputPtr = ptr + 1; [EOL]                     return; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr)); [EOL]     _inputPtr = ptr; [EOL]     _finishString2(); [EOL] }
@Override [EOL] protected void _finishString() throws IOException, JsonParseException { [EOL]     int ptr = _inputPtr; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         final int[] codes = CharTypes.getInputCodeLatin1(); [EOL]         final int maxCode = codes.length; [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch < maxCode && codes[ch] != 0) { [EOL]                 if (ch == '"') { [EOL]                     _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr)); [EOL]                     _inputPtr = ptr + 1; [EOL]                     return; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr)); [EOL]     _inputPtr = ptr; [EOL]     _finishString2(); [EOL] }
@Override [EOL] protected void _finishString() throws IOException, JsonParseException { [EOL]     int ptr = _inputPtr; [EOL]     final int inputLen = _inputEnd; [EOL]     if (ptr < inputLen) { [EOL]         final int[] codes = CharTypes.getInputCodeLatin1(); [EOL]         final int maxCode = codes.length; [EOL]         do { [EOL]             int ch = _inputBuffer[ptr]; [EOL]             if (ch < maxCode && codes[ch] != 0) { [EOL]                 if (ch == '"') { [EOL]                     _textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr - _inputPtr)); [EOL]                     _inputPtr = ptr + 1; [EOL]                     return; [EOL]                 } [EOL]                 break; [EOL]             } [EOL]             ++ptr; [EOL]         } while (ptr < inputLen); [EOL]     } [EOL]     _textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr - _inputPtr)); [EOL]     _inputPtr = ptr; [EOL]     _finishString2(); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWS() throws IOException, JsonParseException { [EOL]     while (_inputPtr < _inputEnd || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i != INT_SLASH) { [EOL]                 return i; [EOL]             } [EOL]             _skipComment(); [EOL]         } else if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     throw _constructError("Unexpected end-of-input within/between " + _parsingContext.getTypeDesc() + " entries"); [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i == INT_SLASH) { [EOL]                 _skipComment(); [EOL]                 continue; [EOL]             } [EOL]             return i; [EOL]         } [EOL]         if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i == INT_SLASH) { [EOL]                 _skipComment(); [EOL]                 continue; [EOL]             } [EOL]             return i; [EOL]         } [EOL]         if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i == INT_SLASH) { [EOL]                 _skipComment(); [EOL]                 continue; [EOL]             } [EOL]             return i; [EOL]         } [EOL]         if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i == INT_SLASH) { [EOL]                 _skipComment(); [EOL]                 continue; [EOL]             } [EOL]             return i; [EOL]         } [EOL]         if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i == INT_SLASH) { [EOL]                 _skipComment(); [EOL]                 continue; [EOL]             } [EOL]             return i; [EOL]         } [EOL]         if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i == INT_SLASH) { [EOL]                 _skipComment(); [EOL]                 continue; [EOL]             } [EOL]             return i; [EOL]         } [EOL]         if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i == INT_SLASH) { [EOL]                 _skipComment(); [EOL]                 continue; [EOL]             } [EOL]             return i; [EOL]         } [EOL]         if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i == INT_SLASH) { [EOL]                 _skipComment(); [EOL]                 continue; [EOL]             } [EOL]             return i; [EOL]         } [EOL]         if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
private int _skipWSOrEnd() throws IOException, JsonParseException { [EOL]     while ((_inputPtr < _inputEnd) || loadMore()) { [EOL]         int i = (int) _inputBuffer[_inputPtr++]; [EOL]         if (i > INT_SPACE) { [EOL]             if (i == INT_SLASH) { [EOL]                 _skipComment(); [EOL]                 continue; [EOL]             } [EOL]             return i; [EOL]         } [EOL]         if (i != INT_SPACE) { [EOL]             if (i == INT_LF) { [EOL]                 _skipLF(); [EOL]             } else if (i == INT_CR) { [EOL]                 _skipCR(); [EOL]             } else if (i != INT_TAB) { [EOL]                 _throwInvalidSpace(i); [EOL]             } [EOL]         } [EOL]     } [EOL]     _handleEOF(); [EOL]     return -1; [EOL] }
protected void _matchToken(String matchStr, int i) throws IOException, JsonParseException { [EOL]     final int len = matchStr.length(); [EOL]     do { [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             if (!loadMore()) { [EOL]                 _reportInvalidToken(matchStr.substring(0, i)); [EOL]             } [EOL]         } [EOL]         if (_inputBuffer[_inputPtr] != matchStr.charAt(i)) { [EOL]             _reportInvalidToken(matchStr.substring(0, i)); [EOL]         } [EOL]         ++_inputPtr; [EOL]     } while (++i < len); [EOL]     if (_inputPtr >= _inputEnd) { [EOL]         if (!loadMore()) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     char c = _inputBuffer[_inputPtr]; [EOL]     if (c < '0' || c == ']' || c == '}') { [EOL]         return; [EOL]     } [EOL]     if (Character.isJavaIdentifierPart(c)) { [EOL]         _reportInvalidToken(matchStr.substring(0, i)); [EOL]     } [EOL]     return; [EOL] }
@SuppressWarnings("resource") [EOL] protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException { [EOL]     ByteArrayBuilder builder = _getByteArrayBuilder(); [EOL]     while (true) { [EOL]         char ch; [EOL]         do { [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             ch = _inputBuffer[_inputPtr++]; [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (ch == '"') { [EOL]                 return builder.toByteArray(); [EOL]             } [EOL]             bits = _decodeBase64Escape(b64variant, ch, 0); [EOL]             if (bits < 0) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             bits = _decodeBase64Escape(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 4; [EOL]                     builder.append(decodedData); [EOL]                     return builder.toByteArray(); [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 2); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (_inputPtr >= _inputEnd) { [EOL]                     loadMoreGuaranteed(); [EOL]                 } [EOL]                 ch = _inputBuffer[_inputPtr++]; [EOL]                 if (!b64variant.usesPaddingChar(ch)) { [EOL]                     throw reportInvalidBase64Char(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL]                 } [EOL]                 decodedData >>= 4; [EOL]                 builder.append(decodedData); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 2; [EOL]                     builder.appendTwoBytes(decodedData); [EOL]                     return builder.toByteArray(); [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 3); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 decodedData >>= 2; [EOL]                 builder.appendTwoBytes(decodedData); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         builder.appendThreeBytes(decodedData); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException { [EOL]     ByteArrayBuilder builder = _getByteArrayBuilder(); [EOL]     while (true) { [EOL]         char ch; [EOL]         do { [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             ch = _inputBuffer[_inputPtr++]; [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (ch == '"') { [EOL]                 return builder.toByteArray(); [EOL]             } [EOL]             bits = _decodeBase64Escape(b64variant, ch, 0); [EOL]             if (bits < 0) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             bits = _decodeBase64Escape(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 4; [EOL]                     builder.append(decodedData); [EOL]                     return builder.toByteArray(); [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 2); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (_inputPtr >= _inputEnd) { [EOL]                     loadMoreGuaranteed(); [EOL]                 } [EOL]                 ch = _inputBuffer[_inputPtr++]; [EOL]                 if (!b64variant.usesPaddingChar(ch)) { [EOL]                     throw reportInvalidBase64Char(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL]                 } [EOL]                 decodedData >>= 4; [EOL]                 builder.append(decodedData); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 2; [EOL]                     builder.appendTwoBytes(decodedData); [EOL]                     return builder.toByteArray(); [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 3); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 decodedData >>= 2; [EOL]                 builder.appendTwoBytes(decodedData); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         builder.appendThreeBytes(decodedData); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException { [EOL]     ByteArrayBuilder builder = _getByteArrayBuilder(); [EOL]     while (true) { [EOL]         char ch; [EOL]         do { [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             ch = _inputBuffer[_inputPtr++]; [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (ch == '"') { [EOL]                 return builder.toByteArray(); [EOL]             } [EOL]             bits = _decodeBase64Escape(b64variant, ch, 0); [EOL]             if (bits < 0) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             bits = _decodeBase64Escape(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 4; [EOL]                     builder.append(decodedData); [EOL]                     return builder.toByteArray(); [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 2); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (_inputPtr >= _inputEnd) { [EOL]                     loadMoreGuaranteed(); [EOL]                 } [EOL]                 ch = _inputBuffer[_inputPtr++]; [EOL]                 if (!b64variant.usesPaddingChar(ch)) { [EOL]                     throw reportInvalidBase64Char(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL]                 } [EOL]                 decodedData >>= 4; [EOL]                 builder.append(decodedData); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 2; [EOL]                     builder.appendTwoBytes(decodedData); [EOL]                     return builder.toByteArray(); [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 3); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 decodedData >>= 2; [EOL]                 builder.appendTwoBytes(decodedData); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         builder.appendThreeBytes(decodedData); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException { [EOL]     ByteArrayBuilder builder = _getByteArrayBuilder(); [EOL]     while (true) { [EOL]         char ch; [EOL]         do { [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             ch = _inputBuffer[_inputPtr++]; [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (ch == '"') { [EOL]                 return builder.toByteArray(); [EOL]             } [EOL]             bits = _decodeBase64Escape(b64variant, ch, 0); [EOL]             if (bits < 0) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             bits = _decodeBase64Escape(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 4; [EOL]                     builder.append(decodedData); [EOL]                     return builder.toByteArray(); [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 2); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (_inputPtr >= _inputEnd) { [EOL]                     loadMoreGuaranteed(); [EOL]                 } [EOL]                 ch = _inputBuffer[_inputPtr++]; [EOL]                 if (!b64variant.usesPaddingChar(ch)) { [EOL]                     throw reportInvalidBase64Char(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL]                 } [EOL]                 decodedData >>= 4; [EOL]                 builder.append(decodedData); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 2; [EOL]                     builder.appendTwoBytes(decodedData); [EOL]                     return builder.toByteArray(); [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 3); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 decodedData >>= 2; [EOL]                 builder.appendTwoBytes(decodedData); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         builder.appendThreeBytes(decodedData); [EOL]     } [EOL] }
@SuppressWarnings("resource") [EOL] protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException, JsonParseException { [EOL]     ByteArrayBuilder builder = _getByteArrayBuilder(); [EOL]     while (true) { [EOL]         char ch; [EOL]         do { [EOL]             if (_inputPtr >= _inputEnd) { [EOL]                 loadMoreGuaranteed(); [EOL]             } [EOL]             ch = _inputBuffer[_inputPtr++]; [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (ch == '"') { [EOL]                 return builder.toByteArray(); [EOL]             } [EOL]             bits = _decodeBase64Escape(b64variant, ch, 0); [EOL]             if (bits < 0) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             bits = _decodeBase64Escape(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 4; [EOL]                     builder.append(decodedData); [EOL]                     return builder.toByteArray(); [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 2); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (_inputPtr >= _inputEnd) { [EOL]                     loadMoreGuaranteed(); [EOL]                 } [EOL]                 ch = _inputBuffer[_inputPtr++]; [EOL]                 if (!b64variant.usesPaddingChar(ch)) { [EOL]                     throw reportInvalidBase64Char(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL]                 } [EOL]                 decodedData >>= 4; [EOL]                 builder.append(decodedData); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (_inputPtr >= _inputEnd) { [EOL]             loadMoreGuaranteed(); [EOL]         } [EOL]         ch = _inputBuffer[_inputPtr++]; [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 if (ch == '"' && !b64variant.usesPadding()) { [EOL]                     decodedData >>= 2; [EOL]                     builder.appendTwoBytes(decodedData); [EOL]                     return builder.toByteArray(); [EOL]                 } [EOL]                 bits = _decodeBase64Escape(b64variant, ch, 3); [EOL]             } [EOL]             if (bits == Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 decodedData >>= 2; [EOL]                 builder.appendTwoBytes(decodedData); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         builder.appendThreeBytes(decodedData); [EOL]     } [EOL] }
@Override [EOL] public final int hashCode() { [EOL]     return _hashCode; [EOL] }
@Override [EOL] public void writeFieldName(String name) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeFieldName(name); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { [EOL]         _reportError("Can not write a field name, expecting a value"); [EOL]     } [EOL]     _writeFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA)); [EOL] }
@Override [EOL] public void writeFieldName(String name) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeFieldName(name); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { [EOL]         _reportError("Can not write a field name, expecting a value"); [EOL]     } [EOL]     _writeFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA)); [EOL] }
@Override [EOL] public void writeFieldName(String name) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeFieldName(name); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { [EOL]         _reportError("Can not write a field name, expecting a value"); [EOL]     } [EOL]     _writeFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA)); [EOL] }
@Override [EOL] public void writeFieldName(SerializableString name) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeFieldName(name.getValue()); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_VALUE) { [EOL]         _reportError("Can not write a field name, expecting a value"); [EOL]     } [EOL]     _writeFieldName(name, (status == JsonWriteContext.STATUS_OK_AFTER_COMMA)); [EOL] }
protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException { [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _writePPFieldName(name, commaBefore); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 1) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     if (commaBefore) { [EOL]         _outputBuffer[_outputTail++] = ','; [EOL]     } [EOL]     if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) { [EOL]         _writeString(name); [EOL]         return; [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     _writeString(name); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL] }
protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException { [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _writePPFieldName(name, commaBefore); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 1) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     if (commaBefore) { [EOL]         _outputBuffer[_outputTail++] = ','; [EOL]     } [EOL]     if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) { [EOL]         _writeString(name); [EOL]         return; [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     _writeString(name); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL] }
protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException { [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _writePPFieldName(name, commaBefore); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 1) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     if (commaBefore) { [EOL]         _outputBuffer[_outputTail++] = ','; [EOL]     } [EOL]     if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) { [EOL]         _writeString(name); [EOL]         return; [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     _writeString(name); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL] }
protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException { [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _writePPFieldName(name, commaBefore); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 1) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     if (commaBefore) { [EOL]         _outputBuffer[_outputTail++] = ','; [EOL]     } [EOL]     if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) { [EOL]         _writeString(name); [EOL]         return; [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     _writeString(name); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL] }
protected void _writeFieldName(String name, boolean commaBefore) throws IOException, JsonGenerationException { [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _writePPFieldName(name, commaBefore); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 1) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     if (commaBefore) { [EOL]         _outputBuffer[_outputTail++] = ','; [EOL]     } [EOL]     if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) { [EOL]         _writeString(name); [EOL]         return; [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     _writeString(name); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL] }
public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException { [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _writePPFieldName(name, commaBefore); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 1) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     if (commaBefore) { [EOL]         _outputBuffer[_outputTail++] = ','; [EOL]     } [EOL]     final char[] quoted = name.asQuotedChars(); [EOL]     if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) { [EOL]         writeRaw(quoted, 0, quoted.length); [EOL]         return; [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     final int qlen = quoted.length; [EOL]     if ((_outputTail + qlen + 1) >= _outputEnd) { [EOL]         writeRaw(quoted, 0, qlen); [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '"'; [EOL]     } else { [EOL]         System.arraycopy(quoted, 0, _outputBuffer, _outputTail, qlen); [EOL]         _outputTail += qlen; [EOL]         _outputBuffer[_outputTail++] = '"'; [EOL]     } [EOL] }
public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException { [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _writePPFieldName(name, commaBefore); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 1) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     if (commaBefore) { [EOL]         _outputBuffer[_outputTail++] = ','; [EOL]     } [EOL]     final char[] quoted = name.asQuotedChars(); [EOL]     if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) { [EOL]         writeRaw(quoted, 0, quoted.length); [EOL]         return; [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     final int qlen = quoted.length; [EOL]     if ((_outputTail + qlen + 1) >= _outputEnd) { [EOL]         writeRaw(quoted, 0, qlen); [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '"'; [EOL]     } else { [EOL]         System.arraycopy(quoted, 0, _outputBuffer, _outputTail, qlen); [EOL]         _outputTail += qlen; [EOL]         _outputBuffer[_outputTail++] = '"'; [EOL]     } [EOL] }
public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException { [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _writePPFieldName(name, commaBefore); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 1) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     if (commaBefore) { [EOL]         _outputBuffer[_outputTail++] = ','; [EOL]     } [EOL]     final char[] quoted = name.asQuotedChars(); [EOL]     if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) { [EOL]         writeRaw(quoted, 0, quoted.length); [EOL]         return; [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     final int qlen = quoted.length; [EOL]     if ((_outputTail + qlen + 1) >= _outputEnd) { [EOL]         writeRaw(quoted, 0, qlen); [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '"'; [EOL]     } else { [EOL]         System.arraycopy(quoted, 0, _outputBuffer, _outputTail, qlen); [EOL]         _outputTail += qlen; [EOL]         _outputBuffer[_outputTail++] = '"'; [EOL]     } [EOL] }
public void _writeFieldName(SerializableString name, boolean commaBefore) throws IOException, JsonGenerationException { [EOL]     if (_cfgPrettyPrinter != null) { [EOL]         _writePPFieldName(name, commaBefore); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 1) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     if (commaBefore) { [EOL]         _outputBuffer[_outputTail++] = ','; [EOL]     } [EOL]     final char[] quoted = name.asQuotedChars(); [EOL]     if (!isEnabled(Feature.QUOTE_FIELD_NAMES)) { [EOL]         writeRaw(quoted, 0, quoted.length); [EOL]         return; [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     final int qlen = quoted.length; [EOL]     if ((_outputTail + qlen + 1) >= _outputEnd) { [EOL]         writeRaw(quoted, 0, qlen); [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail++] = '"'; [EOL]     } else { [EOL]         System.arraycopy(quoted, 0, _outputBuffer, _outputTail, qlen); [EOL]         _outputTail += qlen; [EOL]         _outputBuffer[_outputTail++] = '"'; [EOL]     } [EOL] }
@Override [EOL] public void writeString(String text) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write text value"); [EOL]     if (text == null) { [EOL]         _writeNull(); [EOL]         return; [EOL]     } [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     _writeString(text); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL] }
@Override [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedInt(i); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 11) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); [EOL] }
@Override [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedInt(i); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 11) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); [EOL] }
@Override [EOL] public void writeNumber(int i) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedInt(i); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 11) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); [EOL] }
private void _writeQuotedInt(int i) throws IOException { [EOL]     if ((_outputTail + 13) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL] }
private void _writeQuotedInt(int i) throws IOException { [EOL]     if ((_outputTail + 13) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     _outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail); [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL] }
@Override [EOL] public void writeNumber(long l) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedLong(l); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 21) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail); [EOL] }
@Override [EOL] public void writeNumber(long l) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedLong(l); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 21) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail); [EOL] }
@Override [EOL] public void writeNumber(long l) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedLong(l); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + 21) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail); [EOL] }
private void _writeQuotedLong(long l) throws IOException { [EOL]     if ((_outputTail + 23) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail); [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL] }
private void _writeQuotedLong(long l) throws IOException { [EOL]     if ((_outputTail + 23) >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     _outputTail = NumberOutput.outputLong(l, _outputBuffer, _outputTail); [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL] }
@Override [EOL] public void writeNumber(BigInteger value) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if (value == null) { [EOL]         _writeNull(); [EOL]     } else if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedRaw(value); [EOL]     } else { [EOL]         writeRaw(value.toString()); [EOL]     } [EOL] }
@Override [EOL] public void writeNumber(BigInteger value) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if (value == null) { [EOL]         _writeNull(); [EOL]     } else if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedRaw(value); [EOL]     } else { [EOL]         writeRaw(value.toString()); [EOL]     } [EOL] }
@Override [EOL] public void writeNumber(BigInteger value) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if (value == null) { [EOL]         _writeNull(); [EOL]     } else if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedRaw(value); [EOL]     } else { [EOL]         writeRaw(value.toString()); [EOL]     } [EOL] }
@Override [EOL] public void writeNumber(double d) throws IOException, JsonGenerationException { [EOL]     if (_cfgNumbersAsStrings || (((Double.isNaN(d) || Double.isInfinite(d)) && isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS)))) { [EOL]         writeString(String.valueOf(d)); [EOL]         return; [EOL]     } [EOL]     _verifyValueWrite("write number"); [EOL]     writeRaw(String.valueOf(d)); [EOL] }
@Override [EOL] public void writeNumber(double d) throws IOException, JsonGenerationException { [EOL]     if (_cfgNumbersAsStrings || (((Double.isNaN(d) || Double.isInfinite(d)) && isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS)))) { [EOL]         writeString(String.valueOf(d)); [EOL]         return; [EOL]     } [EOL]     _verifyValueWrite("write number"); [EOL]     writeRaw(String.valueOf(d)); [EOL] }
@Override [EOL] public void writeNumber(double d) throws IOException, JsonGenerationException { [EOL]     if (_cfgNumbersAsStrings || (((Double.isNaN(d) || Double.isInfinite(d)) && isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS)))) { [EOL]         writeString(String.valueOf(d)); [EOL]         return; [EOL]     } [EOL]     _verifyValueWrite("write number"); [EOL]     writeRaw(String.valueOf(d)); [EOL] }
@Override [EOL] public void writeNumber(double d) throws IOException, JsonGenerationException { [EOL]     if (_cfgNumbersAsStrings || (((Double.isNaN(d) || Double.isInfinite(d)) && isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS)))) { [EOL]         writeString(String.valueOf(d)); [EOL]         return; [EOL]     } [EOL]     _verifyValueWrite("write number"); [EOL]     writeRaw(String.valueOf(d)); [EOL] }
@Override [EOL] public void writeNumber(float f) throws IOException, JsonGenerationException { [EOL]     if (_cfgNumbersAsStrings || (((Float.isNaN(f) || Float.isInfinite(f)) && isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS)))) { [EOL]         writeString(String.valueOf(f)); [EOL]         return; [EOL]     } [EOL]     _verifyValueWrite("write number"); [EOL]     writeRaw(String.valueOf(f)); [EOL] }
@Override [EOL] public void writeNumber(float f) throws IOException, JsonGenerationException { [EOL]     if (_cfgNumbersAsStrings || (((Float.isNaN(f) || Float.isInfinite(f)) && isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS)))) { [EOL]         writeString(String.valueOf(f)); [EOL]         return; [EOL]     } [EOL]     _verifyValueWrite("write number"); [EOL]     writeRaw(String.valueOf(f)); [EOL] }
@Override [EOL] public void writeNumber(float f) throws IOException, JsonGenerationException { [EOL]     if (_cfgNumbersAsStrings || (((Float.isNaN(f) || Float.isInfinite(f)) && isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS)))) { [EOL]         writeString(String.valueOf(f)); [EOL]         return; [EOL]     } [EOL]     _verifyValueWrite("write number"); [EOL]     writeRaw(String.valueOf(f)); [EOL] }
@Override [EOL] public void writeNumber(float f) throws IOException, JsonGenerationException { [EOL]     if (_cfgNumbersAsStrings || (((Float.isNaN(f) || Float.isInfinite(f)) && isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS)))) { [EOL]         writeString(String.valueOf(f)); [EOL]         return; [EOL]     } [EOL]     _verifyValueWrite("write number"); [EOL]     writeRaw(String.valueOf(f)); [EOL] }
@Override [EOL] public void writeNumber(float f) throws IOException, JsonGenerationException { [EOL]     if (_cfgNumbersAsStrings || (((Float.isNaN(f) || Float.isInfinite(f)) && isEnabled(Feature.QUOTE_NON_NUMERIC_NUMBERS)))) { [EOL]         writeString(String.valueOf(f)); [EOL]         return; [EOL]     } [EOL]     _verifyValueWrite("write number"); [EOL]     writeRaw(String.valueOf(f)); [EOL] }
@Override [EOL] public void writeNumber(BigDecimal value) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if (value == null) { [EOL]         _writeNull(); [EOL]     } else if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedRaw(value); [EOL]     } else if (isEnabled(Feature.WRITE_BIGDECIMAL_AS_PLAIN)) { [EOL]         writeRaw(value.toPlainString()); [EOL]     } else { [EOL]         writeRaw(value.toString()); [EOL]     } [EOL] }
@Override [EOL] public void writeNumber(String encodedValue) throws IOException, JsonGenerationException { [EOL]     _verifyValueWrite("write number"); [EOL]     if (_cfgNumbersAsStrings) { [EOL]         _writeQuotedRaw(encodedValue); [EOL]     } else { [EOL]         writeRaw(encodedValue); [EOL]     } [EOL] }
private void _writeQuotedRaw(Object value) throws IOException { [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     writeRaw(value.toString()); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL] }
private void _writeQuotedRaw(Object value) throws IOException { [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL]     writeRaw(value.toString()); [EOL]     if (_outputTail >= _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     _outputBuffer[_outputTail++] = '"'; [EOL] }
@Override [EOL] protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeValue(); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL]         _reportError("Can not " + typeMsg + ", expecting field name"); [EOL]     } [EOL]     if (_cfgPrettyPrinter == null) { [EOL]         char c; [EOL]         switch(status) { [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]                 c = ','; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]                 c = ':'; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]                 if (_rootValueSeparator != null) { [EOL]                     writeRaw(_rootValueSeparator.getValue()); [EOL]                 } [EOL]                 return; [EOL]             case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             default: [EOL]                 return; [EOL]         } [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail] = c; [EOL]         ++_outputTail; [EOL]         return; [EOL]     } [EOL]     _verifyPrettyValueWrite(typeMsg, status); [EOL] }
@Override [EOL] protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeValue(); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL]         _reportError("Can not " + typeMsg + ", expecting field name"); [EOL]     } [EOL]     if (_cfgPrettyPrinter == null) { [EOL]         char c; [EOL]         switch(status) { [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]                 c = ','; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]                 c = ':'; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]                 if (_rootValueSeparator != null) { [EOL]                     writeRaw(_rootValueSeparator.getValue()); [EOL]                 } [EOL]                 return; [EOL]             case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             default: [EOL]                 return; [EOL]         } [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail] = c; [EOL]         ++_outputTail; [EOL]         return; [EOL]     } [EOL]     _verifyPrettyValueWrite(typeMsg, status); [EOL] }
@Override [EOL] protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeValue(); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL]         _reportError("Can not " + typeMsg + ", expecting field name"); [EOL]     } [EOL]     if (_cfgPrettyPrinter == null) { [EOL]         char c; [EOL]         switch(status) { [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]                 c = ','; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]                 c = ':'; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]                 if (_rootValueSeparator != null) { [EOL]                     writeRaw(_rootValueSeparator.getValue()); [EOL]                 } [EOL]                 return; [EOL]             case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             default: [EOL]                 return; [EOL]         } [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail] = c; [EOL]         ++_outputTail; [EOL]         return; [EOL]     } [EOL]     _verifyPrettyValueWrite(typeMsg, status); [EOL] }
@Override [EOL] protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeValue(); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL]         _reportError("Can not " + typeMsg + ", expecting field name"); [EOL]     } [EOL]     if (_cfgPrettyPrinter == null) { [EOL]         char c; [EOL]         switch(status) { [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]                 c = ','; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]                 c = ':'; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]                 if (_rootValueSeparator != null) { [EOL]                     writeRaw(_rootValueSeparator.getValue()); [EOL]                 } [EOL]                 return; [EOL]             case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             default: [EOL]                 return; [EOL]         } [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail] = c; [EOL]         ++_outputTail; [EOL]         return; [EOL]     } [EOL]     _verifyPrettyValueWrite(typeMsg, status); [EOL] }
@Override [EOL] protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeValue(); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL]         _reportError("Can not " + typeMsg + ", expecting field name"); [EOL]     } [EOL]     if (_cfgPrettyPrinter == null) { [EOL]         char c; [EOL]         switch(status) { [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]                 c = ','; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]                 c = ':'; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]                 if (_rootValueSeparator != null) { [EOL]                     writeRaw(_rootValueSeparator.getValue()); [EOL]                 } [EOL]                 return; [EOL]             case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             default: [EOL]                 return; [EOL]         } [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail] = c; [EOL]         ++_outputTail; [EOL]         return; [EOL]     } [EOL]     _verifyPrettyValueWrite(typeMsg, status); [EOL] }
@Override [EOL] protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeValue(); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL]         _reportError("Can not " + typeMsg + ", expecting field name"); [EOL]     } [EOL]     if (_cfgPrettyPrinter == null) { [EOL]         char c; [EOL]         switch(status) { [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]                 c = ','; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]                 c = ':'; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]                 if (_rootValueSeparator != null) { [EOL]                     writeRaw(_rootValueSeparator.getValue()); [EOL]                 } [EOL]                 return; [EOL]             case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             default: [EOL]                 return; [EOL]         } [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail] = c; [EOL]         ++_outputTail; [EOL]         return; [EOL]     } [EOL]     _verifyPrettyValueWrite(typeMsg, status); [EOL] }
@Override [EOL] protected void _verifyValueWrite(String typeMsg) throws IOException, JsonGenerationException { [EOL]     int status = _writeContext.writeValue(); [EOL]     if (status == JsonWriteContext.STATUS_EXPECT_NAME) { [EOL]         _reportError("Can not " + typeMsg + ", expecting field name"); [EOL]     } [EOL]     if (_cfgPrettyPrinter == null) { [EOL]         char c; [EOL]         switch(status) { [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COMMA: [EOL]                 c = ','; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_COLON: [EOL]                 c = ':'; [EOL]                 break; [EOL]             case JsonWriteContext.STATUS_OK_AFTER_SPACE: [EOL]                 if (_rootValueSeparator != null) { [EOL]                     writeRaw(_rootValueSeparator.getValue()); [EOL]                 } [EOL]                 return; [EOL]             case JsonWriteContext.STATUS_OK_AS_IS: [EOL]             default: [EOL]                 return; [EOL]         } [EOL]         if (_outputTail >= _outputEnd) { [EOL]             _flushBuffer(); [EOL]         } [EOL]         _outputBuffer[_outputTail] = c; [EOL]         ++_outputTail; [EOL]         return; [EOL]     } [EOL]     _verifyPrettyValueWrite(typeMsg, status); [EOL] }
private void _writeString(String text) throws IOException, JsonGenerationException { [EOL]     final int len = text.length(); [EOL]     if (len > _outputEnd) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     text.getChars(0, len, _outputBuffer, _outputTail); [EOL]     if (_characterEscapes != null) { [EOL]         _writeStringCustom(len); [EOL]     } else if (_maximumNonEscapedChar != 0) { [EOL]         _writeStringASCII(len, _maximumNonEscapedChar); [EOL]     } else { [EOL]         _writeString2(len); [EOL]     } [EOL] }
private void _writeString(String text) throws IOException, JsonGenerationException { [EOL]     final int len = text.length(); [EOL]     if (len > _outputEnd) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     text.getChars(0, len, _outputBuffer, _outputTail); [EOL]     if (_characterEscapes != null) { [EOL]         _writeStringCustom(len); [EOL]     } else if (_maximumNonEscapedChar != 0) { [EOL]         _writeStringASCII(len, _maximumNonEscapedChar); [EOL]     } else { [EOL]         _writeString2(len); [EOL]     } [EOL] }
private void _writeString(String text) throws IOException, JsonGenerationException { [EOL]     final int len = text.length(); [EOL]     if (len > _outputEnd) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     text.getChars(0, len, _outputBuffer, _outputTail); [EOL]     if (_characterEscapes != null) { [EOL]         _writeStringCustom(len); [EOL]     } else if (_maximumNonEscapedChar != 0) { [EOL]         _writeStringASCII(len, _maximumNonEscapedChar); [EOL]     } else { [EOL]         _writeString2(len); [EOL]     } [EOL] }
private void _writeString(String text) throws IOException, JsonGenerationException { [EOL]     final int len = text.length(); [EOL]     if (len > _outputEnd) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     text.getChars(0, len, _outputBuffer, _outputTail); [EOL]     if (_characterEscapes != null) { [EOL]         _writeStringCustom(len); [EOL]     } else if (_maximumNonEscapedChar != 0) { [EOL]         _writeStringASCII(len, _maximumNonEscapedChar); [EOL]     } else { [EOL]         _writeString2(len); [EOL]     } [EOL] }
private void _writeString(String text) throws IOException, JsonGenerationException { [EOL]     final int len = text.length(); [EOL]     if (len > _outputEnd) { [EOL]         _writeLongString(text); [EOL]         return; [EOL]     } [EOL]     if ((_outputTail + len) > _outputEnd) { [EOL]         _flushBuffer(); [EOL]     } [EOL]     text.getChars(0, len, _outputBuffer, _outputTail); [EOL]     if (_characterEscapes != null) { [EOL]         _writeStringCustom(len); [EOL]     } else if (_maximumNonEscapedChar != 0) { [EOL]         _writeStringASCII(len, _maximumNonEscapedChar); [EOL]     } else { [EOL]         _writeString2(len); [EOL]     } [EOL] }
private void _writeString2(final int len) throws IOException, JsonGenerationException { [EOL]     int end = _outputTail + len; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int escLen = escCodes.length; [EOL]     output_loop: while (_outputTail < end) { [EOL]         escape_loop: while (true) { [EOL]             char c = _outputBuffer[_outputTail]; [EOL]             if (c < escLen && escCodes[c] != 0) { [EOL]                 break escape_loop; [EOL]             } [EOL]             if (++_outputTail >= end) { [EOL]                 break output_loop; [EOL]             } [EOL]         } [EOL]         int flushLen = (_outputTail - _outputHead); [EOL]         if (flushLen > 0) { [EOL]             _writer.write(_outputBuffer, _outputHead, flushLen); [EOL]         } [EOL]         char c = _outputBuffer[_outputTail++]; [EOL]         _prependOrWriteCharacterEscape(c, escCodes[c]); [EOL]     } [EOL] }
private void _writeString2(final int len) throws IOException, JsonGenerationException { [EOL]     int end = _outputTail + len; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int escLen = escCodes.length; [EOL]     output_loop: while (_outputTail < end) { [EOL]         escape_loop: while (true) { [EOL]             char c = _outputBuffer[_outputTail]; [EOL]             if (c < escLen && escCodes[c] != 0) { [EOL]                 break escape_loop; [EOL]             } [EOL]             if (++_outputTail >= end) { [EOL]                 break output_loop; [EOL]             } [EOL]         } [EOL]         int flushLen = (_outputTail - _outputHead); [EOL]         if (flushLen > 0) { [EOL]             _writer.write(_outputBuffer, _outputHead, flushLen); [EOL]         } [EOL]         char c = _outputBuffer[_outputTail++]; [EOL]         _prependOrWriteCharacterEscape(c, escCodes[c]); [EOL]     } [EOL] }
private void _writeString2(final int len) throws IOException, JsonGenerationException { [EOL]     int end = _outputTail + len; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int escLen = escCodes.length; [EOL]     output_loop: while (_outputTail < end) { [EOL]         escape_loop: while (true) { [EOL]             char c = _outputBuffer[_outputTail]; [EOL]             if (c < escLen && escCodes[c] != 0) { [EOL]                 break escape_loop; [EOL]             } [EOL]             if (++_outputTail >= end) { [EOL]                 break output_loop; [EOL]             } [EOL]         } [EOL]         int flushLen = (_outputTail - _outputHead); [EOL]         if (flushLen > 0) { [EOL]             _writer.write(_outputBuffer, _outputHead, flushLen); [EOL]         } [EOL]         char c = _outputBuffer[_outputTail++]; [EOL]         _prependOrWriteCharacterEscape(c, escCodes[c]); [EOL]     } [EOL] }
private void _writeString2(final int len) throws IOException, JsonGenerationException { [EOL]     int end = _outputTail + len; [EOL]     final int[] escCodes = _outputEscapes; [EOL]     final int escLen = escCodes.length; [EOL]     output_loop: while (_outputTail < end) { [EOL]         escape_loop: while (true) { [EOL]             char c = _outputBuffer[_outputTail]; [EOL]             if (c < escLen && escCodes[c] != 0) { [EOL]                 break escape_loop; [EOL]             } [EOL]             if (++_outputTail >= end) { [EOL]                 break output_loop; [EOL]             } [EOL]         } [EOL]         int flushLen = (_outputTail - _outputHead); [EOL]         if (flushLen > 0) { [EOL]             _writer.write(_outputBuffer, _outputHead, flushLen); [EOL]         } [EOL]         char c = _outputBuffer[_outputTail++]; [EOL]         _prependOrWriteCharacterEscape(c, escCodes[c]); [EOL]     } [EOL] }
public static int[] getInputCodeLatin1() { [EOL]     return sInputCodes; [EOL] }
public static int[] getInputCodeLatin1JsNames() { [EOL]     return sInputCodesJsNames; [EOL] }
public static int[] getInputCodeUtf8JsNames() { [EOL]     return sInputCodesUtf8JsNames; [EOL] }
public static int[] get7BitOutputEscapes() { [EOL]     return sOutputEscapes128; [EOL] }
public JsonStringEncoder() { [EOL]     _quoteBuffer = new char[6]; [EOL]     _quoteBuffer[0] = '\\'; [EOL]     _quoteBuffer[2] = '0'; [EOL]     _quoteBuffer[3] = '0'; [EOL] }
public char[] quoteAsString(String input) { [EOL]     TextBuffer textBuffer = _textBuffer; [EOL]     if (textBuffer == null) { [EOL]         _textBuffer = textBuffer = new TextBuffer(null); [EOL]     } [EOL]     char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment(); [EOL]     final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]     final int escCodeCount = escCodes.length; [EOL]     int inPtr = 0; [EOL]     final int inputLen = input.length(); [EOL]     int outPtr = 0; [EOL]     outer_loop: while (inPtr < inputLen) { [EOL]         tight_loop: while (true) { [EOL]             char c = input.charAt(inPtr); [EOL]             if (c < escCodeCount && escCodes[c] != 0) { [EOL]                 break tight_loop; [EOL]             } [EOL]             if (outPtr >= outputBuffer.length) { [EOL]                 outputBuffer = textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outputBuffer[outPtr++] = c; [EOL]             if (++inPtr >= inputLen) { [EOL]                 break outer_loop; [EOL]             } [EOL]         } [EOL]         char d = input.charAt(inPtr++); [EOL]         int escCode = escCodes[d]; [EOL]         int length = (escCode < 0) ? _appendNumericEscape(d, _quoteBuffer) : _appendNamedEscape(escCode, _quoteBuffer); [EOL]         ; [EOL]         if ((outPtr + length) > outputBuffer.length) { [EOL]             int first = outputBuffer.length - outPtr; [EOL]             if (first > 0) { [EOL]                 System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first); [EOL]             } [EOL]             outputBuffer = textBuffer.finishCurrentSegment(); [EOL]             int second = length - first; [EOL]             System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second); [EOL]             outPtr = second; [EOL]         } else { [EOL]             System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length); [EOL]             outPtr += length; [EOL]         } [EOL]     } [EOL]     textBuffer.setCurrentLength(outPtr); [EOL]     return textBuffer.contentsAsArray(); [EOL] }
public char[] quoteAsString(String input) { [EOL]     TextBuffer textBuffer = _textBuffer; [EOL]     if (textBuffer == null) { [EOL]         _textBuffer = textBuffer = new TextBuffer(null); [EOL]     } [EOL]     char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment(); [EOL]     final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]     final int escCodeCount = escCodes.length; [EOL]     int inPtr = 0; [EOL]     final int inputLen = input.length(); [EOL]     int outPtr = 0; [EOL]     outer_loop: while (inPtr < inputLen) { [EOL]         tight_loop: while (true) { [EOL]             char c = input.charAt(inPtr); [EOL]             if (c < escCodeCount && escCodes[c] != 0) { [EOL]                 break tight_loop; [EOL]             } [EOL]             if (outPtr >= outputBuffer.length) { [EOL]                 outputBuffer = textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outputBuffer[outPtr++] = c; [EOL]             if (++inPtr >= inputLen) { [EOL]                 break outer_loop; [EOL]             } [EOL]         } [EOL]         char d = input.charAt(inPtr++); [EOL]         int escCode = escCodes[d]; [EOL]         int length = (escCode < 0) ? _appendNumericEscape(d, _quoteBuffer) : _appendNamedEscape(escCode, _quoteBuffer); [EOL]         ; [EOL]         if ((outPtr + length) > outputBuffer.length) { [EOL]             int first = outputBuffer.length - outPtr; [EOL]             if (first > 0) { [EOL]                 System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first); [EOL]             } [EOL]             outputBuffer = textBuffer.finishCurrentSegment(); [EOL]             int second = length - first; [EOL]             System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second); [EOL]             outPtr = second; [EOL]         } else { [EOL]             System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length); [EOL]             outPtr += length; [EOL]         } [EOL]     } [EOL]     textBuffer.setCurrentLength(outPtr); [EOL]     return textBuffer.contentsAsArray(); [EOL] }
public char[] quoteAsString(String input) { [EOL]     TextBuffer textBuffer = _textBuffer; [EOL]     if (textBuffer == null) { [EOL]         _textBuffer = textBuffer = new TextBuffer(null); [EOL]     } [EOL]     char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment(); [EOL]     final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]     final int escCodeCount = escCodes.length; [EOL]     int inPtr = 0; [EOL]     final int inputLen = input.length(); [EOL]     int outPtr = 0; [EOL]     outer_loop: while (inPtr < inputLen) { [EOL]         tight_loop: while (true) { [EOL]             char c = input.charAt(inPtr); [EOL]             if (c < escCodeCount && escCodes[c] != 0) { [EOL]                 break tight_loop; [EOL]             } [EOL]             if (outPtr >= outputBuffer.length) { [EOL]                 outputBuffer = textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outputBuffer[outPtr++] = c; [EOL]             if (++inPtr >= inputLen) { [EOL]                 break outer_loop; [EOL]             } [EOL]         } [EOL]         char d = input.charAt(inPtr++); [EOL]         int escCode = escCodes[d]; [EOL]         int length = (escCode < 0) ? _appendNumericEscape(d, _quoteBuffer) : _appendNamedEscape(escCode, _quoteBuffer); [EOL]         ; [EOL]         if ((outPtr + length) > outputBuffer.length) { [EOL]             int first = outputBuffer.length - outPtr; [EOL]             if (first > 0) { [EOL]                 System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first); [EOL]             } [EOL]             outputBuffer = textBuffer.finishCurrentSegment(); [EOL]             int second = length - first; [EOL]             System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second); [EOL]             outPtr = second; [EOL]         } else { [EOL]             System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length); [EOL]             outPtr += length; [EOL]         } [EOL]     } [EOL]     textBuffer.setCurrentLength(outPtr); [EOL]     return textBuffer.contentsAsArray(); [EOL] }
public char[] quoteAsString(String input) { [EOL]     TextBuffer textBuffer = _textBuffer; [EOL]     if (textBuffer == null) { [EOL]         _textBuffer = textBuffer = new TextBuffer(null); [EOL]     } [EOL]     char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment(); [EOL]     final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]     final int escCodeCount = escCodes.length; [EOL]     int inPtr = 0; [EOL]     final int inputLen = input.length(); [EOL]     int outPtr = 0; [EOL]     outer_loop: while (inPtr < inputLen) { [EOL]         tight_loop: while (true) { [EOL]             char c = input.charAt(inPtr); [EOL]             if (c < escCodeCount && escCodes[c] != 0) { [EOL]                 break tight_loop; [EOL]             } [EOL]             if (outPtr >= outputBuffer.length) { [EOL]                 outputBuffer = textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outputBuffer[outPtr++] = c; [EOL]             if (++inPtr >= inputLen) { [EOL]                 break outer_loop; [EOL]             } [EOL]         } [EOL]         char d = input.charAt(inPtr++); [EOL]         int escCode = escCodes[d]; [EOL]         int length = (escCode < 0) ? _appendNumericEscape(d, _quoteBuffer) : _appendNamedEscape(escCode, _quoteBuffer); [EOL]         ; [EOL]         if ((outPtr + length) > outputBuffer.length) { [EOL]             int first = outputBuffer.length - outPtr; [EOL]             if (first > 0) { [EOL]                 System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first); [EOL]             } [EOL]             outputBuffer = textBuffer.finishCurrentSegment(); [EOL]             int second = length - first; [EOL]             System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second); [EOL]             outPtr = second; [EOL]         } else { [EOL]             System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length); [EOL]             outPtr += length; [EOL]         } [EOL]     } [EOL]     textBuffer.setCurrentLength(outPtr); [EOL]     return textBuffer.contentsAsArray(); [EOL] }
public char[] quoteAsString(String input) { [EOL]     TextBuffer textBuffer = _textBuffer; [EOL]     if (textBuffer == null) { [EOL]         _textBuffer = textBuffer = new TextBuffer(null); [EOL]     } [EOL]     char[] outputBuffer = textBuffer.emptyAndGetCurrentSegment(); [EOL]     final int[] escCodes = CharTypes.get7BitOutputEscapes(); [EOL]     final int escCodeCount = escCodes.length; [EOL]     int inPtr = 0; [EOL]     final int inputLen = input.length(); [EOL]     int outPtr = 0; [EOL]     outer_loop: while (inPtr < inputLen) { [EOL]         tight_loop: while (true) { [EOL]             char c = input.charAt(inPtr); [EOL]             if (c < escCodeCount && escCodes[c] != 0) { [EOL]                 break tight_loop; [EOL]             } [EOL]             if (outPtr >= outputBuffer.length) { [EOL]                 outputBuffer = textBuffer.finishCurrentSegment(); [EOL]                 outPtr = 0; [EOL]             } [EOL]             outputBuffer[outPtr++] = c; [EOL]             if (++inPtr >= inputLen) { [EOL]                 break outer_loop; [EOL]             } [EOL]         } [EOL]         char d = input.charAt(inPtr++); [EOL]         int escCode = escCodes[d]; [EOL]         int length = (escCode < 0) ? _appendNumericEscape(d, _quoteBuffer) : _appendNamedEscape(escCode, _quoteBuffer); [EOL]         ; [EOL]         if ((outPtr + length) > outputBuffer.length) { [EOL]             int first = outputBuffer.length - outPtr; [EOL]             if (first > 0) { [EOL]                 System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, first); [EOL]             } [EOL]             outputBuffer = textBuffer.finishCurrentSegment(); [EOL]             int second = length - first; [EOL]             System.arraycopy(_quoteBuffer, first, outputBuffer, 0, second); [EOL]             outPtr = second; [EOL]         } else { [EOL]             System.arraycopy(_quoteBuffer, 0, outputBuffer, outPtr, length); [EOL]             outPtr += length; [EOL]         } [EOL]     } [EOL]     textBuffer.setCurrentLength(outPtr); [EOL]     return textBuffer.contentsAsArray(); [EOL] }
private int _appendNamedEscape(int escCode, char[] quoteBuffer) { [EOL]     quoteBuffer[1] = (char) escCode; [EOL]     return 2; [EOL] }
protected ParserMinimalBase() { [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
protected ParserMinimalBase() { [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
protected ParserMinimalBase() { [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
protected ParserMinimalBase() { [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
protected ParserMinimalBase() { [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
protected ParserMinimalBase() { [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
protected ParserMinimalBase() { [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
protected ParserMinimalBase() { [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
protected ParserMinimalBase() { [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
protected ParserMinimalBase() { [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
protected ParserMinimalBase() { [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
protected ParserMinimalBase() { [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
@Override [EOL] public JsonToken getCurrentToken() { [EOL]     return _currToken; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public JsonParser skipChildren() throws IOException, JsonParseException { [EOL]     if (_currToken != JsonToken.START_OBJECT && _currToken != JsonToken.START_ARRAY) { [EOL]         return this; [EOL]     } [EOL]     int open = 1; [EOL]     while (true) { [EOL]         JsonToken t = nextToken(); [EOL]         if (t == null) { [EOL]             _handleEOF(); [EOL]             return this; [EOL]         } [EOL]         switch(t) { [EOL]             case START_OBJECT: [EOL]             case START_ARRAY: [EOL]                 ++open; [EOL]                 break; [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]                 if (--open == 0) { [EOL]                     return this; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case VALUE_NUMBER_INT: [EOL]                 return getIntValue() != 0; [EOL]             case VALUE_TRUE: [EOL]                 return true; [EOL]             case VALUE_FALSE: [EOL]             case VALUE_NULL: [EOL]                 return false; [EOL]             case VALUE_EMBEDDED_OBJECT: [EOL]                 { [EOL]                     Object value = this.getEmbeddedObject(); [EOL]                     if (value instanceof Boolean) { [EOL]                         return (Boolean) value; [EOL]                     } [EOL]                 } [EOL]             case VALUE_STRING: [EOL]                 String str = getText().trim(); [EOL]                 if ("true".equals(str)) { [EOL]                     return true; [EOL]                 } [EOL]                 if (_hasTextualNull(str)) { [EOL]                     return false; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return defaultValue; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case VALUE_NUMBER_INT: [EOL]                 return getIntValue() != 0; [EOL]             case VALUE_TRUE: [EOL]                 return true; [EOL]             case VALUE_FALSE: [EOL]             case VALUE_NULL: [EOL]                 return false; [EOL]             case VALUE_EMBEDDED_OBJECT: [EOL]                 { [EOL]                     Object value = this.getEmbeddedObject(); [EOL]                     if (value instanceof Boolean) { [EOL]                         return (Boolean) value; [EOL]                     } [EOL]                 } [EOL]             case VALUE_STRING: [EOL]                 String str = getText().trim(); [EOL]                 if ("true".equals(str)) { [EOL]                     return true; [EOL]                 } [EOL]                 if (_hasTextualNull(str)) { [EOL]                     return false; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return defaultValue; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case VALUE_NUMBER_INT: [EOL]                 return getIntValue() != 0; [EOL]             case VALUE_TRUE: [EOL]                 return true; [EOL]             case VALUE_FALSE: [EOL]             case VALUE_NULL: [EOL]                 return false; [EOL]             case VALUE_EMBEDDED_OBJECT: [EOL]                 { [EOL]                     Object value = this.getEmbeddedObject(); [EOL]                     if (value instanceof Boolean) { [EOL]                         return (Boolean) value; [EOL]                     } [EOL]                 } [EOL]             case VALUE_STRING: [EOL]                 String str = getText().trim(); [EOL]                 if ("true".equals(str)) { [EOL]                     return true; [EOL]                 } [EOL]                 if (_hasTextualNull(str)) { [EOL]                     return false; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return defaultValue; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case VALUE_NUMBER_INT: [EOL]                 return getIntValue() != 0; [EOL]             case VALUE_TRUE: [EOL]                 return true; [EOL]             case VALUE_FALSE: [EOL]             case VALUE_NULL: [EOL]                 return false; [EOL]             case VALUE_EMBEDDED_OBJECT: [EOL]                 { [EOL]                     Object value = this.getEmbeddedObject(); [EOL]                     if (value instanceof Boolean) { [EOL]                         return (Boolean) value; [EOL]                     } [EOL]                 } [EOL]             case VALUE_STRING: [EOL]                 String str = getText().trim(); [EOL]                 if ("true".equals(str)) { [EOL]                     return true; [EOL]                 } [EOL]                 if (_hasTextualNull(str)) { [EOL]                     return false; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return defaultValue; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case VALUE_NUMBER_INT: [EOL]                 return getIntValue() != 0; [EOL]             case VALUE_TRUE: [EOL]                 return true; [EOL]             case VALUE_FALSE: [EOL]             case VALUE_NULL: [EOL]                 return false; [EOL]             case VALUE_EMBEDDED_OBJECT: [EOL]                 { [EOL]                     Object value = this.getEmbeddedObject(); [EOL]                     if (value instanceof Boolean) { [EOL]                         return (Boolean) value; [EOL]                     } [EOL]                 } [EOL]             case VALUE_STRING: [EOL]                 String str = getText().trim(); [EOL]                 if ("true".equals(str)) { [EOL]                     return true; [EOL]                 } [EOL]                 if (_hasTextualNull(str)) { [EOL]                     return false; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return defaultValue; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case VALUE_NUMBER_INT: [EOL]                 return getIntValue() != 0; [EOL]             case VALUE_TRUE: [EOL]                 return true; [EOL]             case VALUE_FALSE: [EOL]             case VALUE_NULL: [EOL]                 return false; [EOL]             case VALUE_EMBEDDED_OBJECT: [EOL]                 { [EOL]                     Object value = this.getEmbeddedObject(); [EOL]                     if (value instanceof Boolean) { [EOL]                         return (Boolean) value; [EOL]                     } [EOL]                 } [EOL]             case VALUE_STRING: [EOL]                 String str = getText().trim(); [EOL]                 if ("true".equals(str)) { [EOL]                     return true; [EOL]                 } [EOL]                 if (_hasTextualNull(str)) { [EOL]                     return false; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return defaultValue; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case VALUE_NUMBER_INT: [EOL]                 return getIntValue() != 0; [EOL]             case VALUE_TRUE: [EOL]                 return true; [EOL]             case VALUE_FALSE: [EOL]             case VALUE_NULL: [EOL]                 return false; [EOL]             case VALUE_EMBEDDED_OBJECT: [EOL]                 { [EOL]                     Object value = this.getEmbeddedObject(); [EOL]                     if (value instanceof Boolean) { [EOL]                         return (Boolean) value; [EOL]                     } [EOL]                 } [EOL]             case VALUE_STRING: [EOL]                 String str = getText().trim(); [EOL]                 if ("true".equals(str)) { [EOL]                     return true; [EOL]                 } [EOL]                 if (_hasTextualNull(str)) { [EOL]                     return false; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return defaultValue; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case VALUE_NUMBER_INT: [EOL]                 return getIntValue() != 0; [EOL]             case VALUE_TRUE: [EOL]                 return true; [EOL]             case VALUE_FALSE: [EOL]             case VALUE_NULL: [EOL]                 return false; [EOL]             case VALUE_EMBEDDED_OBJECT: [EOL]                 { [EOL]                     Object value = this.getEmbeddedObject(); [EOL]                     if (value instanceof Boolean) { [EOL]                         return (Boolean) value; [EOL]                     } [EOL]                 } [EOL]             case VALUE_STRING: [EOL]                 String str = getText().trim(); [EOL]                 if ("true".equals(str)) { [EOL]                     return true; [EOL]                 } [EOL]                 if (_hasTextualNull(str)) { [EOL]                     return false; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return defaultValue; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case VALUE_NUMBER_INT: [EOL]                 return getIntValue() != 0; [EOL]             case VALUE_TRUE: [EOL]                 return true; [EOL]             case VALUE_FALSE: [EOL]             case VALUE_NULL: [EOL]                 return false; [EOL]             case VALUE_EMBEDDED_OBJECT: [EOL]                 { [EOL]                     Object value = this.getEmbeddedObject(); [EOL]                     if (value instanceof Boolean) { [EOL]                         return (Boolean) value; [EOL]                     } [EOL]                 } [EOL]             case VALUE_STRING: [EOL]                 String str = getText().trim(); [EOL]                 if ("true".equals(str)) { [EOL]                     return true; [EOL]                 } [EOL]                 if (_hasTextualNull(str)) { [EOL]                     return false; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     return defaultValue; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
@Override [EOL] public long getValueAsLong(long defaultValue) throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return getLongValue(); [EOL]             case VALUE_TRUE: [EOL]                 return 1; [EOL]             case VALUE_FALSE: [EOL]             case VALUE_NULL: [EOL]                 return 0; [EOL]             case VALUE_STRING: [EOL]                 String str = getText(); [EOL]                 if (_hasTextualNull(str)) { [EOL]                     return 0L; [EOL]                 } [EOL]                 return NumberInput.parseAsLong(str, defaultValue); [EOL]             case VALUE_EMBEDDED_OBJECT: [EOL]                 { [EOL]                     Object value = this.getEmbeddedObject(); [EOL]                     if (value instanceof Number) { [EOL]                         return ((Number) value).longValue(); [EOL]                     } [EOL]                 } [EOL]             default: [EOL]         } [EOL]     } [EOL]     return defaultValue; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
@Override [EOL] public long getValueAsLong(long defaultValue) throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return getLongValue(); [EOL]             case VALUE_TRUE: [EOL]                 return 1; [EOL]             case VALUE_FALSE: [EOL]             case VALUE_NULL: [EOL]                 return 0; [EOL]             case VALUE_STRING: [EOL]                 String str = getText(); [EOL]                 if (_hasTextualNull(str)) { [EOL]                     return 0L; [EOL]                 } [EOL]                 return NumberInput.parseAsLong(str, defaultValue); [EOL]             case VALUE_EMBEDDED_OBJECT: [EOL]                 { [EOL]                     Object value = this.getEmbeddedObject(); [EOL]                     if (value instanceof Number) { [EOL]                         return ((Number) value).longValue(); [EOL]                     } [EOL]                 } [EOL]             default: [EOL]         } [EOL]     } [EOL]     return defaultValue; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
@Override [EOL] public long getValueAsLong(long defaultValue) throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return getLongValue(); [EOL]             case VALUE_TRUE: [EOL]                 return 1; [EOL]             case VALUE_FALSE: [EOL]             case VALUE_NULL: [EOL]                 return 0; [EOL]             case VALUE_STRING: [EOL]                 String str = getText(); [EOL]                 if (_hasTextualNull(str)) { [EOL]                     return 0L; [EOL]                 } [EOL]                 return NumberInput.parseAsLong(str, defaultValue); [EOL]             case VALUE_EMBEDDED_OBJECT: [EOL]                 { [EOL]                     Object value = this.getEmbeddedObject(); [EOL]                     if (value instanceof Number) { [EOL]                         return ((Number) value).longValue(); [EOL]                     } [EOL]                 } [EOL]             default: [EOL]         } [EOL]     } [EOL]     return defaultValue; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
@Override [EOL] public long getValueAsLong(long defaultValue) throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return getLongValue(); [EOL]             case VALUE_TRUE: [EOL]                 return 1; [EOL]             case VALUE_FALSE: [EOL]             case VALUE_NULL: [EOL]                 return 0; [EOL]             case VALUE_STRING: [EOL]                 String str = getText(); [EOL]                 if (_hasTextualNull(str)) { [EOL]                     return 0L; [EOL]                 } [EOL]                 return NumberInput.parseAsLong(str, defaultValue); [EOL]             case VALUE_EMBEDDED_OBJECT: [EOL]                 { [EOL]                     Object value = this.getEmbeddedObject(); [EOL]                     if (value instanceof Number) { [EOL]                         return ((Number) value).longValue(); [EOL]                     } [EOL]                 } [EOL]             default: [EOL]         } [EOL]     } [EOL]     return defaultValue; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
@Override [EOL] public long getValueAsLong(long defaultValue) throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return getLongValue(); [EOL]             case VALUE_TRUE: [EOL]                 return 1; [EOL]             case VALUE_FALSE: [EOL]             case VALUE_NULL: [EOL]                 return 0; [EOL]             case VALUE_STRING: [EOL]                 String str = getText(); [EOL]                 if (_hasTextualNull(str)) { [EOL]                     return 0L; [EOL]                 } [EOL]                 return NumberInput.parseAsLong(str, defaultValue); [EOL]             case VALUE_EMBEDDED_OBJECT: [EOL]                 { [EOL]                     Object value = this.getEmbeddedObject(); [EOL]                     if (value instanceof Number) { [EOL]                         return ((Number) value).longValue(); [EOL]                     } [EOL]                 } [EOL]             default: [EOL]         } [EOL]     } [EOL]     return defaultValue; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
@Override [EOL] public long getValueAsLong(long defaultValue) throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return getLongValue(); [EOL]             case VALUE_TRUE: [EOL]                 return 1; [EOL]             case VALUE_FALSE: [EOL]             case VALUE_NULL: [EOL]                 return 0; [EOL]             case VALUE_STRING: [EOL]                 String str = getText(); [EOL]                 if (_hasTextualNull(str)) { [EOL]                     return 0L; [EOL]                 } [EOL]                 return NumberInput.parseAsLong(str, defaultValue); [EOL]             case VALUE_EMBEDDED_OBJECT: [EOL]                 { [EOL]                     Object value = this.getEmbeddedObject(); [EOL]                     if (value instanceof Number) { [EOL]                         return ((Number) value).longValue(); [EOL]                     } [EOL]                 } [EOL]             default: [EOL]         } [EOL]     } [EOL]     return defaultValue; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
@Override [EOL] public long getValueAsLong(long defaultValue) throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return getLongValue(); [EOL]             case VALUE_TRUE: [EOL]                 return 1; [EOL]             case VALUE_FALSE: [EOL]             case VALUE_NULL: [EOL]                 return 0; [EOL]             case VALUE_STRING: [EOL]                 String str = getText(); [EOL]                 if (_hasTextualNull(str)) { [EOL]                     return 0L; [EOL]                 } [EOL]                 return NumberInput.parseAsLong(str, defaultValue); [EOL]             case VALUE_EMBEDDED_OBJECT: [EOL]                 { [EOL]                     Object value = this.getEmbeddedObject(); [EOL]                     if (value instanceof Number) { [EOL]                         return ((Number) value).longValue(); [EOL]                     } [EOL]                 } [EOL]             default: [EOL]         } [EOL]     } [EOL]     return defaultValue; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
@Override [EOL] public long getValueAsLong(long defaultValue) throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return getLongValue(); [EOL]             case VALUE_TRUE: [EOL]                 return 1; [EOL]             case VALUE_FALSE: [EOL]             case VALUE_NULL: [EOL]                 return 0; [EOL]             case VALUE_STRING: [EOL]                 String str = getText(); [EOL]                 if (_hasTextualNull(str)) { [EOL]                     return 0L; [EOL]                 } [EOL]                 return NumberInput.parseAsLong(str, defaultValue); [EOL]             case VALUE_EMBEDDED_OBJECT: [EOL]                 { [EOL]                     Object value = this.getEmbeddedObject(); [EOL]                     if (value instanceof Number) { [EOL]                         return ((Number) value).longValue(); [EOL]                     } [EOL]                 } [EOL]             default: [EOL]         } [EOL]     } [EOL]     return defaultValue; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
@SuppressWarnings("incomplete-switch") [EOL] @Override [EOL] public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException { [EOL]     if (_currToken != null) { [EOL]         switch(_currToken) { [EOL]             case VALUE_NUMBER_INT: [EOL]             case VALUE_NUMBER_FLOAT: [EOL]                 return getDoubleValue(); [EOL]             case VALUE_TRUE: [EOL]                 return 1; [EOL]             case VALUE_FALSE: [EOL]             case VALUE_NULL: [EOL]                 return 0; [EOL]             case VALUE_STRING: [EOL]                 String str = getText(); [EOL]                 if (_hasTextualNull(str)) { [EOL]                     return 0; [EOL]                 } [EOL]                 return NumberInput.parseAsDouble(str, defaultValue); [EOL]             case VALUE_EMBEDDED_OBJECT: [EOL]                 { [EOL]                     Object value = this.getEmbeddedObject(); [EOL]                     if (value instanceof Number) { [EOL]                         return ((Number) value).doubleValue(); [EOL]                     } [EOL]                 } [EOL]         } [EOL]     } [EOL]     return defaultValue; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
protected boolean _hasTextualNull(String value) { [EOL]     return "null".equals(value); [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException { [EOL]     if (isEnabled(Feature.ALLOW_BACKSLASH_ESCAPING_ANY_CHARACTER)) { [EOL]         return ch; [EOL]     } [EOL]     if (ch == '\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) { [EOL]         return ch; [EOL]     } [EOL]     _reportError("Unrecognized character escape " + _getCharDesc(ch)); [EOL]     return ch; [EOL] } protected ParserMinimalBase(); protected ParserMinimalBase(int features); public Version version(); public abstract JsonToken nextToken() throws IOException, JsonParseException; public JsonToken getCurrentToken(); public boolean hasCurrentToken(); public JsonToken nextValue() throws IOException, JsonParseException; public JsonParser skipChildren() throws IOException, JsonParseException; protected abstract void _handleEOF() throws JsonParseException; public abstract String getCurrentName() throws IOException, JsonParseException; public abstract void close() throws IOException; public abstract boolean isClosed(); public abstract JsonStreamContext getParsingContext(); public void clearCurrentToken(); public JsonToken getLastClearedToken(); public abstract void overrideCurrentName(String name); public abstract String getText() throws IOException, JsonParseException; public abstract char[] getTextCharacters() throws IOException, JsonParseException; public abstract boolean hasTextCharacters(); public abstract int getTextLength() throws IOException, JsonParseException; public abstract int getTextOffset() throws IOException, JsonParseException; public abstract byte[] getBinaryValue(Base64Variant b64variant) throws IOException, JsonParseException; public boolean getValueAsBoolean(boolean defaultValue) throws IOException, JsonParseException; public int getValueAsInt(int defaultValue) throws IOException, JsonParseException; public long getValueAsLong(long defaultValue) throws IOException, JsonParseException; public double getValueAsDouble(double defaultValue) throws IOException, JsonParseException; public String getValueAsString(String defaultValue) throws IOException, JsonParseException; protected void _decodeBase64(String str, ByteArrayBuilder builder, Base64Variant b64variant) throws IOException, JsonParseException; protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg) throws JsonParseException; protected void _reportBase64EOF() throws JsonParseException; protected boolean _hasTextualNull(String value); protected void _reportUnexpectedChar(int ch, String comment) throws JsonParseException; protected void _reportInvalidEOF() throws JsonParseException; protected void _reportInvalidEOF(String msg) throws JsonParseException; protected void _reportInvalidEOFInValue() throws JsonParseException; protected void _throwInvalidSpace(int i) throws JsonParseException; protected void _throwUnquotedSpace(int i, String ctxtDesc) throws JsonParseException; protected char _handleUnrecognizedCharacterEscape(char ch) throws JsonProcessingException; protected static final String _getCharDesc(int ch); protected final void _reportError(String msg) throws JsonParseException; protected final void _wrapError(String msg, Throwable t) throws JsonParseException; protected final void _throwInternal(); protected final JsonParseException _constructError(String msg, Throwable t); int INT_TAB=Optional['\t']; int INT_LF=Optional['\n']; int INT_CR=Optional['\r']; int INT_SPACE=Optional[0x0020]; int INT_LBRACKET=Optional['[']; int INT_RBRACKET=Optional[']']; int INT_LCURLY=Optional['{']; int INT_RCURLY=Optional['}
private JsonWriteContext reset(int type) { [EOL]     _type = type; [EOL]     _index = -1; [EOL]     _currentName = null; [EOL]     return this; [EOL] }
public final JsonWriteContext createChildObjectContext() { [EOL]     JsonWriteContext ctxt = _child; [EOL]     if (ctxt == null) { [EOL]         _child = ctxt = new JsonWriteContext(TYPE_OBJECT, this); [EOL]         return ctxt; [EOL]     } [EOL]     return ctxt.reset(TYPE_OBJECT); [EOL] }
public final JsonWriteContext createChildObjectContext() { [EOL]     JsonWriteContext ctxt = _child; [EOL]     if (ctxt == null) { [EOL]         _child = ctxt = new JsonWriteContext(TYPE_OBJECT, this); [EOL]         return ctxt; [EOL]     } [EOL]     return ctxt.reset(TYPE_OBJECT); [EOL] }
public final int writeFieldName(String name) { [EOL]     if (_type == TYPE_OBJECT) { [EOL]         if (_currentName != null) { [EOL]             return STATUS_EXPECT_VALUE; [EOL]         } [EOL]         _currentName = name; [EOL]         return (_index < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA; [EOL]     } [EOL]     return STATUS_EXPECT_VALUE; [EOL] }
public final int writeFieldName(String name) { [EOL]     if (_type == TYPE_OBJECT) { [EOL]         if (_currentName != null) { [EOL]             return STATUS_EXPECT_VALUE; [EOL]         } [EOL]         _currentName = name; [EOL]         return (_index < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA; [EOL]     } [EOL]     return STATUS_EXPECT_VALUE; [EOL] }
public final int writeFieldName(String name) { [EOL]     if (_type == TYPE_OBJECT) { [EOL]         if (_currentName != null) { [EOL]             return STATUS_EXPECT_VALUE; [EOL]         } [EOL]         _currentName = name; [EOL]         return (_index < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA; [EOL]     } [EOL]     return STATUS_EXPECT_VALUE; [EOL] }
public final int writeFieldName(String name) { [EOL]     if (_type == TYPE_OBJECT) { [EOL]         if (_currentName != null) { [EOL]             return STATUS_EXPECT_VALUE; [EOL]         } [EOL]         _currentName = name; [EOL]         return (_index < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA; [EOL]     } [EOL]     return STATUS_EXPECT_VALUE; [EOL] }
public final int writeValue() { [EOL]     if (_type == TYPE_OBJECT) { [EOL]         if (_currentName == null) { [EOL]             return STATUS_EXPECT_NAME; [EOL]         } [EOL]         _currentName = null; [EOL]         ++_index; [EOL]         return STATUS_OK_AFTER_COLON; [EOL]     } [EOL]     if (_type == TYPE_ARRAY) { [EOL]         int ix = _index; [EOL]         ++_index; [EOL]         return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA; [EOL]     } [EOL]     ++_index; [EOL]     return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE; [EOL] }
public final int writeValue() { [EOL]     if (_type == TYPE_OBJECT) { [EOL]         if (_currentName == null) { [EOL]             return STATUS_EXPECT_NAME; [EOL]         } [EOL]         _currentName = null; [EOL]         ++_index; [EOL]         return STATUS_OK_AFTER_COLON; [EOL]     } [EOL]     if (_type == TYPE_ARRAY) { [EOL]         int ix = _index; [EOL]         ++_index; [EOL]         return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA; [EOL]     } [EOL]     ++_index; [EOL]     return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE; [EOL] }
public final int writeValue() { [EOL]     if (_type == TYPE_OBJECT) { [EOL]         if (_currentName == null) { [EOL]             return STATUS_EXPECT_NAME; [EOL]         } [EOL]         _currentName = null; [EOL]         ++_index; [EOL]         return STATUS_OK_AFTER_COLON; [EOL]     } [EOL]     if (_type == TYPE_ARRAY) { [EOL]         int ix = _index; [EOL]         ++_index; [EOL]         return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA; [EOL]     } [EOL]     ++_index; [EOL]     return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE; [EOL] }
public final int writeValue() { [EOL]     if (_type == TYPE_OBJECT) { [EOL]         if (_currentName == null) { [EOL]             return STATUS_EXPECT_NAME; [EOL]         } [EOL]         _currentName = null; [EOL]         ++_index; [EOL]         return STATUS_OK_AFTER_COLON; [EOL]     } [EOL]     if (_type == TYPE_ARRAY) { [EOL]         int ix = _index; [EOL]         ++_index; [EOL]         return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA; [EOL]     } [EOL]     ++_index; [EOL]     return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE; [EOL] }
public final int writeValue() { [EOL]     if (_type == TYPE_OBJECT) { [EOL]         if (_currentName == null) { [EOL]             return STATUS_EXPECT_NAME; [EOL]         } [EOL]         _currentName = null; [EOL]         ++_index; [EOL]         return STATUS_OK_AFTER_COLON; [EOL]     } [EOL]     if (_type == TYPE_ARRAY) { [EOL]         int ix = _index; [EOL]         ++_index; [EOL]         return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA; [EOL]     } [EOL]     ++_index; [EOL]     return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE; [EOL] }
public final int writeValue() { [EOL]     if (_type == TYPE_OBJECT) { [EOL]         if (_currentName == null) { [EOL]             return STATUS_EXPECT_NAME; [EOL]         } [EOL]         _currentName = null; [EOL]         ++_index; [EOL]         return STATUS_OK_AFTER_COLON; [EOL]     } [EOL]     if (_type == TYPE_ARRAY) { [EOL]         int ix = _index; [EOL]         ++_index; [EOL]         return (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA; [EOL]     } [EOL]     ++_index; [EOL]     return (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE; [EOL] }
public final JsonFactory configure(JsonParser.Feature f, boolean state) { [EOL]     return state ? enable(f) : disable(f); [EOL] }
public final JsonFactory configure(JsonParser.Feature f, boolean state) { [EOL]     return state ? enable(f) : disable(f); [EOL] }
public JsonFactory setCharacterEscapes(CharacterEscapes esc) { [EOL]     _characterEscapes = esc; [EOL]     return this; [EOL] }
public JsonFactory setCharacterEscapes(CharacterEscapes esc) { [EOL]     _characterEscapes = esc; [EOL]     return this; [EOL] }
public JsonParser createParser(InputStream in) throws IOException, JsonParseException { [EOL]     IOContext ctxt = _createContext(in, false); [EOL]     if (_inputDecorator != null) { [EOL]         in = _inputDecorator.decorate(ctxt, in); [EOL]     } [EOL]     return _createParser(in, ctxt); [EOL] }
public JsonParser createParser(InputStream in) throws IOException, JsonParseException { [EOL]     IOContext ctxt = _createContext(in, false); [EOL]     if (_inputDecorator != null) { [EOL]         in = _inputDecorator.decorate(ctxt, in); [EOL]     } [EOL]     return _createParser(in, ctxt); [EOL] }
public JsonParser createParser(InputStream in) throws IOException, JsonParseException { [EOL]     IOContext ctxt = _createContext(in, false); [EOL]     if (_inputDecorator != null) { [EOL]         in = _inputDecorator.decorate(ctxt, in); [EOL]     } [EOL]     return _createParser(in, ctxt); [EOL] }
public JsonParser createParser(Reader r) throws IOException, JsonParseException { [EOL]     IOContext ctxt = _createContext(r, false); [EOL]     if (_inputDecorator != null) { [EOL]         r = _inputDecorator.decorate(ctxt, r); [EOL]     } [EOL]     return _createParser(r, ctxt); [EOL] }
public JsonParser createParser(byte[] data) throws IOException, JsonParseException { [EOL]     IOContext ctxt = _createContext(data, true); [EOL]     if (_inputDecorator != null) { [EOL]         InputStream in = _inputDecorator.decorate(ctxt, data, 0, data.length); [EOL]         if (in != null) { [EOL]             return _createParser(in, ctxt); [EOL]         } [EOL]     } [EOL]     return _createParser(data, 0, data.length, ctxt); [EOL] }
public JsonParser createParser(byte[] data) throws IOException, JsonParseException { [EOL]     IOContext ctxt = _createContext(data, true); [EOL]     if (_inputDecorator != null) { [EOL]         InputStream in = _inputDecorator.decorate(ctxt, data, 0, data.length); [EOL]         if (in != null) { [EOL]             return _createParser(in, ctxt); [EOL]         } [EOL]     } [EOL]     return _createParser(data, 0, data.length, ctxt); [EOL] }
public JsonParser createParser(byte[] data) throws IOException, JsonParseException { [EOL]     IOContext ctxt = _createContext(data, true); [EOL]     if (_inputDecorator != null) { [EOL]         InputStream in = _inputDecorator.decorate(ctxt, data, 0, data.length); [EOL]         if (in != null) { [EOL]             return _createParser(in, ctxt); [EOL]         } [EOL]     } [EOL]     return _createParser(data, 0, data.length, ctxt); [EOL] }
public JsonParser createParser(byte[] data) throws IOException, JsonParseException { [EOL]     IOContext ctxt = _createContext(data, true); [EOL]     if (_inputDecorator != null) { [EOL]         InputStream in = _inputDecorator.decorate(ctxt, data, 0, data.length); [EOL]         if (in != null) { [EOL]             return _createParser(in, ctxt); [EOL]         } [EOL]     } [EOL]     return _createParser(data, 0, data.length, ctxt); [EOL] }
protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException { [EOL]     return new ByteSourceJsonBootstrapper(ctxt, data, offset, len).constructParser(_parserFeatures, _objectCodec, _rootByteSymbols, _rootCharSymbols, isEnabled(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES), isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL] }
protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException { [EOL]     return new ByteSourceJsonBootstrapper(ctxt, data, offset, len).constructParser(_parserFeatures, _objectCodec, _rootByteSymbols, _rootCharSymbols, isEnabled(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES), isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL] }
protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException, JsonParseException { [EOL]     return new ByteSourceJsonBootstrapper(ctxt, data, offset, len).constructParser(_parserFeatures, _objectCodec, _rootByteSymbols, _rootCharSymbols, isEnabled(JsonFactory.Feature.CANONICALIZE_FIELD_NAMES), isEnabled(JsonFactory.Feature.INTERN_FIELD_NAMES)); [EOL] }
protected JsonGenerator _createUTF8Generator(OutputStream out, IOContext ctxt) throws IOException { [EOL]     UTF8JsonGenerator gen = new UTF8JsonGenerator(ctxt, _generatorFeatures, _objectCodec, out); [EOL]     if (_characterEscapes != null) { [EOL]         gen.setCharacterEscapes(_characterEscapes); [EOL]     } [EOL]     SerializableString rootSep = _rootValueSeparator; [EOL]     if (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) { [EOL]         gen.setRootValueSeparator(rootSep); [EOL]     } [EOL]     return gen; [EOL] }
protected InputStream _optimizedStreamFromURL(URL url) throws IOException { [EOL]     if ("file".equals(url.getProtocol())) { [EOL]         String host = url.getHost(); [EOL]         if (host == null || host.length() == 0) { [EOL]             String path = url.getPath(); [EOL]             if (path.indexOf('%') < 0) { [EOL]                 return new FileInputStream(url.getPath()); [EOL]             } [EOL]         } [EOL]     } [EOL]     return url.openStream(); [EOL] }
protected InputStream _optimizedStreamFromURL(URL url) throws IOException { [EOL]     if ("file".equals(url.getProtocol())) { [EOL]         String host = url.getHost(); [EOL]         if (host == null || host.length() == 0) { [EOL]             String path = url.getPath(); [EOL]             if (path.indexOf('%') < 0) { [EOL]                 return new FileInputStream(url.getPath()); [EOL]             } [EOL]         } [EOL]     } [EOL]     return url.openStream(); [EOL] }
protected InputStream _optimizedStreamFromURL(URL url) throws IOException { [EOL]     if ("file".equals(url.getProtocol())) { [EOL]         String host = url.getHost(); [EOL]         if (host == null || host.length() == 0) { [EOL]             String path = url.getPath(); [EOL]             if (path.indexOf('%') < 0) { [EOL]                 return new FileInputStream(url.getPath()); [EOL]             } [EOL]         } [EOL]     } [EOL]     return url.openStream(); [EOL] }
protected InputStream _optimizedStreamFromURL(URL url) throws IOException { [EOL]     if ("file".equals(url.getProtocol())) { [EOL]         String host = url.getHost(); [EOL]         if (host == null || host.length() == 0) { [EOL]             String path = url.getPath(); [EOL]             if (path.indexOf('%') < 0) { [EOL]                 return new FileInputStream(url.getPath()); [EOL]             } [EOL]         } [EOL]     } [EOL]     return url.openStream(); [EOL] }
