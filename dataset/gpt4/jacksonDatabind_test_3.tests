public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testAnnotatedMap() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     AnnotatedMap result = mapper.readValue("{\"a\":true }", AnnotatedMap.class); [EOL]     assertEquals(1, result.size()); [EOL]     Map.Entry<Object, Object> en = result.entrySet().iterator().next(); [EOL]     assertEquals(StringWrapper.class, en.getKey().getClass()); [EOL]     assertEquals(BooleanWrapper.class, en.getValue().getClass()); [EOL]     assertEquals("a", ((StringWrapper) en.getKey()).str); [EOL]     assertEquals(Boolean.TRUE, ((BooleanWrapper) en.getValue()).b); [EOL] }
public void testAnnotatedMap() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     AnnotatedMap result = mapper.readValue("{\"a\":true }", AnnotatedMap.class); [EOL]     assertEquals(1, result.size()); [EOL]     Map.Entry<Object, Object> en = result.entrySet().iterator().next(); [EOL]     assertEquals(StringWrapper.class, en.getKey().getClass()); [EOL]     assertEquals(BooleanWrapper.class, en.getValue().getClass()); [EOL]     assertEquals("a", ((StringWrapper) en.getKey()).str); [EOL]     assertEquals(Boolean.TRUE, ((BooleanWrapper) en.getValue()).b); [EOL] }
public void testAnnotatedMap() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     AnnotatedMap result = mapper.readValue("{\"a\":true }", AnnotatedMap.class); [EOL]     assertEquals(1, result.size()); [EOL]     Map.Entry<Object, Object> en = result.entrySet().iterator().next(); [EOL]     assertEquals(StringWrapper.class, en.getKey().getClass()); [EOL]     assertEquals(BooleanWrapper.class, en.getValue().getClass()); [EOL]     assertEquals("a", ((StringWrapper) en.getKey()).str); [EOL]     assertEquals(Boolean.TRUE, ((BooleanWrapper) en.getValue()).b); [EOL] }
public void testAnnotatedMap() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     AnnotatedMap result = mapper.readValue("{\"a\":true }", AnnotatedMap.class); [EOL]     assertEquals(1, result.size()); [EOL]     Map.Entry<Object, Object> en = result.entrySet().iterator().next(); [EOL]     assertEquals(StringWrapper.class, en.getKey().getClass()); [EOL]     assertEquals(BooleanWrapper.class, en.getValue().getClass()); [EOL]     assertEquals("a", ((StringWrapper) en.getKey()).str); [EOL]     assertEquals(Boolean.TRUE, ((BooleanWrapper) en.getValue()).b); [EOL] }
public void testAnnotatedMap() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     AnnotatedMap result = mapper.readValue("{\"a\":true }", AnnotatedMap.class); [EOL]     assertEquals(1, result.size()); [EOL]     Map.Entry<Object, Object> en = result.entrySet().iterator().next(); [EOL]     assertEquals(StringWrapper.class, en.getKey().getClass()); [EOL]     assertEquals(BooleanWrapper.class, en.getValue().getClass()); [EOL]     assertEquals("a", ((StringWrapper) en.getKey()).str); [EOL]     assertEquals(Boolean.TRUE, ((BooleanWrapper) en.getValue()).b); [EOL] }
public void testMultiAccess() throws Exception { [EOL]     String json = "{\"c\":3,\"a\":2,\"b\":-9}"; [EOL]     ValueClassABC value = mapper.readValue(json, ValueClassABC.class); [EOL]     assertNotNull(value); [EOL]     assertEquals(value.a, 2); [EOL]     assertEquals(value.b, -9); [EOL]     assertEquals(value.c, 3); [EOL] }
public void testMultiAccess() throws Exception { [EOL]     String json = "{\"c\":3,\"a\":2,\"b\":-9}"; [EOL]     ValueClassABC value = mapper.readValue(json, ValueClassABC.class); [EOL]     assertNotNull(value); [EOL]     assertEquals(value.a, 2); [EOL]     assertEquals(value.b, -9); [EOL]     assertEquals(value.c, 3); [EOL] }
public void testMultiAccess() throws Exception { [EOL]     String json = "{\"c\":3,\"a\":2,\"b\":-9}"; [EOL]     ValueClassABC value = mapper.readValue(json, ValueClassABC.class); [EOL]     assertNotNull(value); [EOL]     assertEquals(value.a, 2); [EOL]     assertEquals(value.b, -9); [EOL]     assertEquals(value.c, 3); [EOL] }
public void testMultiAccess() throws Exception { [EOL]     String json = "{\"c\":3,\"a\":2,\"b\":-9}"; [EOL]     ValueClassABC value = mapper.readValue(json, ValueClassABC.class); [EOL]     assertNotNull(value); [EOL]     assertEquals(value.a, 2); [EOL]     assertEquals(value.b, -9); [EOL]     assertEquals(value.c, 3); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testNullForPrimitives() throws IOException { [EOL]     PrimitivesBean bean = mapper.readValue("{\"intValue\":null, \"booleanValue\":null, \"doubleValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals(0, bean.intValue); [EOL]     assertEquals(false, bean.booleanValue); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL]     bean = mapper.readValue("{\"byteValue\":null, \"longValue\":null, \"floatValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     assertEquals(0L, bean.longValue); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     final ObjectMapper mapper2 = new ObjectMapper(); [EOL]     mapper2.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true); [EOL]     try { [EOL]         mapper2.readValue("{\"booleanValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for boolean + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type boolean"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"byteValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for byte + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type byte"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"charValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for char + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type char"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"shortValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for short + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type short"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"intValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for int + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type int"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"longValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for long + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type long"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"floatValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for float + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type float"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"doubleValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for double + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type double"); [EOL]     } [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testMapError() throws Exception { [EOL]     try { [EOL]         Object result = MAPPER.readValue("[ 1, 2 ]", new TypeReference<Map<String, String>>() { [EOL]         }); [EOL]         fail("Expected an exception, but got result value: " + result); [EOL]     } catch (JsonMappingException jex) { [EOL]         verifyException(jex, "START_ARRAY"); [EOL]     } [EOL] }
public void testMapError() throws Exception { [EOL]     try { [EOL]         Object result = MAPPER.readValue("[ 1, 2 ]", new TypeReference<Map<String, String>>() { [EOL]         }); [EOL]         fail("Expected an exception, but got result value: " + result); [EOL]     } catch (JsonMappingException jex) { [EOL]         verifyException(jex, "START_ARRAY"); [EOL]     } [EOL] }
public void testMapError() throws Exception { [EOL]     try { [EOL]         Object result = MAPPER.readValue("[ 1, 2 ]", new TypeReference<Map<String, String>>() { [EOL]         }); [EOL]         fail("Expected an exception, but got result value: " + result); [EOL]     } catch (JsonMappingException jex) { [EOL]         verifyException(jex, "START_ARRAY"); [EOL]     } [EOL] }
public void testMapError() throws Exception { [EOL]     try { [EOL]         Object result = MAPPER.readValue("[ 1, 2 ]", new TypeReference<Map<String, String>>() { [EOL]         }); [EOL]         fail("Expected an exception, but got result value: " + result); [EOL]     } catch (JsonMappingException jex) { [EOL]         verifyException(jex, "START_ARRAY"); [EOL]     } [EOL] }
public void testMapError() throws Exception { [EOL]     try { [EOL]         Object result = MAPPER.readValue("[ 1, 2 ]", new TypeReference<Map<String, String>>() { [EOL]         }); [EOL]         fail("Expected an exception, but got result value: " + result); [EOL]     } catch (JsonMappingException jex) { [EOL]         verifyException(jex, "START_ARRAY"); [EOL]     } [EOL] }
public void testNullForPrimitives() throws IOException { [EOL]     PrimitivesBean bean = mapper.readValue("{\"intValue\":null, \"booleanValue\":null, \"doubleValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals(0, bean.intValue); [EOL]     assertEquals(false, bean.booleanValue); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL]     bean = mapper.readValue("{\"byteValue\":null, \"longValue\":null, \"floatValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     assertEquals(0L, bean.longValue); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     final ObjectMapper mapper2 = new ObjectMapper(); [EOL]     mapper2.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true); [EOL]     try { [EOL]         mapper2.readValue("{\"booleanValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for boolean + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type boolean"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"byteValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for byte + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type byte"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"charValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for char + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type char"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"shortValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for short + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type short"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"intValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for int + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type int"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"longValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for long + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type long"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"floatValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for float + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type float"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"doubleValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for double + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type double"); [EOL]     } [EOL] }
public void testNullForPrimitives() throws IOException { [EOL]     PrimitivesBean bean = mapper.readValue("{\"intValue\":null, \"booleanValue\":null, \"doubleValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals(0, bean.intValue); [EOL]     assertEquals(false, bean.booleanValue); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL]     bean = mapper.readValue("{\"byteValue\":null, \"longValue\":null, \"floatValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     assertEquals(0L, bean.longValue); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     final ObjectMapper mapper2 = new ObjectMapper(); [EOL]     mapper2.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true); [EOL]     try { [EOL]         mapper2.readValue("{\"booleanValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for boolean + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type boolean"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"byteValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for byte + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type byte"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"charValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for char + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type char"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"shortValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for short + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type short"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"intValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for int + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type int"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"longValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for long + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type long"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"floatValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for float + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type float"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"doubleValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for double + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type double"); [EOL]     } [EOL] }
public void testNullForPrimitives() throws IOException { [EOL]     PrimitivesBean bean = mapper.readValue("{\"intValue\":null, \"booleanValue\":null, \"doubleValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals(0, bean.intValue); [EOL]     assertEquals(false, bean.booleanValue); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL]     bean = mapper.readValue("{\"byteValue\":null, \"longValue\":null, \"floatValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     assertEquals(0L, bean.longValue); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     final ObjectMapper mapper2 = new ObjectMapper(); [EOL]     mapper2.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true); [EOL]     try { [EOL]         mapper2.readValue("{\"booleanValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for boolean + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type boolean"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"byteValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for byte + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type byte"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"charValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for char + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type char"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"shortValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for short + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type short"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"intValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for int + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type int"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"longValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for long + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type long"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"floatValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for float + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type float"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"doubleValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for double + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type double"); [EOL]     } [EOL] }
public void testMapError() throws Exception { [EOL]     try { [EOL]         Object result = MAPPER.readValue("[ 1, 2 ]", new TypeReference<Map<String, String>>() { [EOL]         }); [EOL]         fail("Expected an exception, but got result value: " + result); [EOL]     } catch (JsonMappingException jex) { [EOL]         verifyException(jex, "START_ARRAY"); [EOL]     } [EOL] }
public void testMapError() throws Exception { [EOL]     try { [EOL]         Object result = MAPPER.readValue("[ 1, 2 ]", new TypeReference<Map<String, String>>() { [EOL]         }); [EOL]         fail("Expected an exception, but got result value: " + result); [EOL]     } catch (JsonMappingException jex) { [EOL]         verifyException(jex, "START_ARRAY"); [EOL]     } [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testSimpleDeserWithForwardRefs() throws Exception { [EOL]     IdWrapper result = mapper.readValue("{\"node\":{\"value\":7,\"next\":{\"node\":1}, \"@id\":1}}", IdWrapper.class); [EOL]     assertEquals(7, result.node.value); [EOL]     assertSame(result.node, result.node.next.node); [EOL] }
public void testSimpleDeserWithForwardRefs() throws Exception { [EOL]     IdWrapper result = mapper.readValue("{\"node\":{\"value\":7,\"next\":{\"node\":1}, \"@id\":1}}", IdWrapper.class); [EOL]     assertEquals(7, result.node.value); [EOL]     assertSame(result.node, result.node.next.node); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testWithCtorAndDelegate() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Pooka")); [EOL]     CtorBean711 bean = null; [EOL]     try { [EOL]         bean = mapper.readValue("38", CtorBean711.class); [EOL]     } catch (JsonMappingException e) { [EOL]         fail("Did not expect problems, got: " + e.getMessage()); [EOL]     } [EOL]     assertEquals(38, bean.age); [EOL]     assertEquals("Pooka", bean.name); [EOL] }
public void testWithCtorAndDelegate() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Pooka")); [EOL]     CtorBean711 bean = null; [EOL]     try { [EOL]         bean = mapper.readValue("38", CtorBean711.class); [EOL]     } catch (JsonMappingException e) { [EOL]         fail("Did not expect problems, got: " + e.getMessage()); [EOL]     } [EOL]     assertEquals(38, bean.age); [EOL]     assertEquals("Pooka", bean.name); [EOL] }
public void testWithCtorAndDelegate() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Pooka")); [EOL]     CtorBean711 bean = null; [EOL]     try { [EOL]         bean = mapper.readValue("38", CtorBean711.class); [EOL]     } catch (JsonMappingException e) { [EOL]         fail("Did not expect problems, got: " + e.getMessage()); [EOL]     } [EOL]     assertEquals(38, bean.age); [EOL]     assertEquals("Pooka", bean.name); [EOL] }
public void testWithCtorAndDelegate() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Pooka")); [EOL]     CtorBean711 bean = null; [EOL]     try { [EOL]         bean = mapper.readValue("38", CtorBean711.class); [EOL]     } catch (JsonMappingException e) { [EOL]         fail("Did not expect problems, got: " + e.getMessage()); [EOL]     } [EOL]     assertEquals(38, bean.age); [EOL]     assertEquals("Pooka", bean.name); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testWithCtorAndDelegate() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Pooka")); [EOL]     CtorBean711 bean = null; [EOL]     try { [EOL]         bean = mapper.readValue("38", CtorBean711.class); [EOL]     } catch (JsonMappingException e) { [EOL]         fail("Did not expect problems, got: " + e.getMessage()); [EOL]     } [EOL]     assertEquals(38, bean.age); [EOL]     assertEquals("Pooka", bean.name); [EOL] }
public void testWithCtorAndDelegate() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Pooka")); [EOL]     CtorBean711 bean = null; [EOL]     try { [EOL]         bean = mapper.readValue("38", CtorBean711.class); [EOL]     } catch (JsonMappingException e) { [EOL]         fail("Did not expect problems, got: " + e.getMessage()); [EOL]     } [EOL]     assertEquals(38, bean.age); [EOL]     assertEquals("Pooka", bean.name); [EOL] }
public void testWithCtorAndDelegate() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Pooka")); [EOL]     CtorBean711 bean = null; [EOL]     try { [EOL]         bean = mapper.readValue("38", CtorBean711.class); [EOL]     } catch (JsonMappingException e) { [EOL]         fail("Did not expect problems, got: " + e.getMessage()); [EOL]     } [EOL]     assertEquals(38, bean.age); [EOL]     assertEquals("Pooka", bean.name); [EOL] }
public void testWithCtorAndDelegate() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Pooka")); [EOL]     CtorBean711 bean = null; [EOL]     try { [EOL]         bean = mapper.readValue("38", CtorBean711.class); [EOL]     } catch (JsonMappingException e) { [EOL]         fail("Did not expect problems, got: " + e.getMessage()); [EOL]     } [EOL]     assertEquals(38, bean.age); [EOL]     assertEquals("Pooka", bean.name); [EOL] }
public void testWithCtorAndDelegate() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Pooka")); [EOL]     CtorBean711 bean = null; [EOL]     try { [EOL]         bean = mapper.readValue("38", CtorBean711.class); [EOL]     } catch (JsonMappingException e) { [EOL]         fail("Did not expect problems, got: " + e.getMessage()); [EOL]     } [EOL]     assertEquals(38, bean.age); [EOL]     assertEquals("Pooka", bean.name); [EOL] }
public void testWithCtorAndDelegate() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Pooka")); [EOL]     CtorBean711 bean = null; [EOL]     try { [EOL]         bean = mapper.readValue("38", CtorBean711.class); [EOL]     } catch (JsonMappingException e) { [EOL]         fail("Did not expect problems, got: " + e.getMessage()); [EOL]     } [EOL]     assertEquals(38, bean.age); [EOL]     assertEquals("Pooka", bean.name); [EOL] }
public void testWithCtorAndDelegate() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Pooka")); [EOL]     CtorBean711 bean = null; [EOL]     try { [EOL]         bean = mapper.readValue("38", CtorBean711.class); [EOL]     } catch (JsonMappingException e) { [EOL]         fail("Did not expect problems, got: " + e.getMessage()); [EOL]     } [EOL]     assertEquals(38, bean.age); [EOL]     assertEquals("Pooka", bean.name); [EOL] }
public void testDecimalNode() throws Exception { [EOL]     BigDecimal value = new BigDecimal("0.1"); [EOL]     JsonNode result = DecimalNode.valueOf(value); [EOL]     assertFalse(result.isArray()); [EOL]     assertFalse(result.isObject()); [EOL]     assertTrue(result.isNumber()); [EOL]     assertFalse(result.isIntegralNumber()); [EOL]     assertFalse(result.isLong()); [EOL]     assertType(result, DecimalNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertTrue(result.isFloatingPointNumber()); [EOL]     assertTrue(result.isBigDecimal()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue()); [EOL]     assertEquals(value.toString(), result.asText()); [EOL]     assertEquals(result, DecimalNode.valueOf(value)); [EOL] }
public void testDecimalNode() throws Exception { [EOL]     BigDecimal value = new BigDecimal("0.1"); [EOL]     JsonNode result = DecimalNode.valueOf(value); [EOL]     assertFalse(result.isArray()); [EOL]     assertFalse(result.isObject()); [EOL]     assertTrue(result.isNumber()); [EOL]     assertFalse(result.isIntegralNumber()); [EOL]     assertFalse(result.isLong()); [EOL]     assertType(result, DecimalNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertTrue(result.isFloatingPointNumber()); [EOL]     assertTrue(result.isBigDecimal()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue()); [EOL]     assertEquals(value.toString(), result.asText()); [EOL]     assertEquals(result, DecimalNode.valueOf(value)); [EOL] }
public void testBoolean() { [EOL]     BooleanNode f = BooleanNode.getFalse(); [EOL]     assertNotNull(f); [EOL]     assertTrue(f.isBoolean()); [EOL]     assertSame(f, BooleanNode.valueOf(false)); [EOL]     assertStandardEquals(f); [EOL]     assertFalse(f.booleanValue()); [EOL]     assertFalse(f.asBoolean()); [EOL]     assertEquals("false", f.asText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, f.asToken()); [EOL]     BooleanNode t = BooleanNode.getTrue(); [EOL]     assertNotNull(t); [EOL]     assertTrue(t.isBoolean()); [EOL]     assertSame(t, BooleanNode.valueOf(true)); [EOL]     assertStandardEquals(t); [EOL]     assertTrue(t.booleanValue()); [EOL]     assertTrue(t.asBoolean()); [EOL]     assertEquals("true", t.asText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, t.asToken()); [EOL]     assertNodeNumbers(f, 0, 0.0); [EOL]     assertNodeNumbers(t, 1, 1.0); [EOL] }
public void testBoolean() { [EOL]     BooleanNode f = BooleanNode.getFalse(); [EOL]     assertNotNull(f); [EOL]     assertTrue(f.isBoolean()); [EOL]     assertSame(f, BooleanNode.valueOf(false)); [EOL]     assertStandardEquals(f); [EOL]     assertFalse(f.booleanValue()); [EOL]     assertFalse(f.asBoolean()); [EOL]     assertEquals("false", f.asText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, f.asToken()); [EOL]     BooleanNode t = BooleanNode.getTrue(); [EOL]     assertNotNull(t); [EOL]     assertTrue(t.isBoolean()); [EOL]     assertSame(t, BooleanNode.valueOf(true)); [EOL]     assertStandardEquals(t); [EOL]     assertTrue(t.booleanValue()); [EOL]     assertTrue(t.asBoolean()); [EOL]     assertEquals("true", t.asText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, t.asToken()); [EOL]     assertNodeNumbers(f, 0, 0.0); [EOL]     assertNodeNumbers(t, 1, 1.0); [EOL] }
public void testGeneratingJsonSchema() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class); [EOL]     assertNotNull(jsonSchema); [EOL]     assertTrue(jsonSchema.equals(jsonSchema)); [EOL]     assertFalse(jsonSchema.equals(null)); [EOL]     assertFalse(jsonSchema.equals("foo")); [EOL]     assertNotNull(jsonSchema.toString()); [EOL]     assertNotNull(JsonSchema.getDefaultSchemaNode()); [EOL]     ObjectNode root = jsonSchema.getSchemaNode(); [EOL]     assertEquals("object", root.get("type").asText()); [EOL]     assertEquals(false, root.path("required").booleanValue()); [EOL]     JsonNode propertiesSchema = root.get("properties"); [EOL]     assertNotNull(propertiesSchema); [EOL]     JsonNode property1Schema = propertiesSchema.get("property1"); [EOL]     assertNotNull(property1Schema); [EOL]     assertEquals("integer", property1Schema.get("type").asText()); [EOL]     assertEquals(false, property1Schema.path("required").booleanValue()); [EOL]     JsonNode property2Schema = propertiesSchema.get("property2"); [EOL]     assertNotNull(property2Schema); [EOL]     assertEquals("string", property2Schema.get("type").asText()); [EOL]     assertEquals(false, property2Schema.path("required").booleanValue()); [EOL]     JsonNode property3Schema = propertiesSchema.get("property3"); [EOL]     assertNotNull(property3Schema); [EOL]     assertEquals("array", property3Schema.get("type").asText()); [EOL]     assertEquals(false, property3Schema.path("required").booleanValue()); [EOL]     assertEquals("string", property3Schema.get("items").get("type").asText()); [EOL]     JsonNode property4Schema = propertiesSchema.get("property4"); [EOL]     assertNotNull(property4Schema); [EOL]     assertEquals("array", property4Schema.get("type").asText()); [EOL]     assertEquals(false, property4Schema.path("required").booleanValue()); [EOL]     assertEquals("number", property4Schema.get("items").get("type").asText()); [EOL] }
public void testBasics() { [EOL]     ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [EOL]     assertStandardEquals(n); [EOL]     assertFalse(n.elements().hasNext()); [EOL]     assertFalse(n.fields().hasNext()); [EOL]     assertFalse(n.fieldNames().hasNext()); [EOL]     assertNull(n.get("a")); [EOL]     assertTrue(n.path("a").isMissingNode()); [EOL]     TextNode text = TextNode.valueOf("x"); [EOL]     n.set("a", text); [EOL]     assertEquals(1, n.size()); [EOL]     assertTrue(n.elements().hasNext()); [EOL]     assertTrue(n.fields().hasNext()); [EOL]     assertTrue(n.fieldNames().hasNext()); [EOL]     assertSame(text, n.get("a")); [EOL]     assertSame(text, n.path("a")); [EOL]     assertNull(n.get("b")); [EOL]     assertNull(n.get(0)); [EOL]     assertFalse(n.has(0)); [EOL]     assertFalse(n.hasNonNull(0)); [EOL]     assertTrue(n.has("a")); [EOL]     assertTrue(n.hasNonNull("a")); [EOL]     assertFalse(n.has("b")); [EOL]     assertFalse(n.hasNonNull("b")); [EOL]     ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance); [EOL]     n2.put("b", 13); [EOL]     assertFalse(n.equals(n2)); [EOL]     n.setAll(n2); [EOL]     assertEquals(2, n.size()); [EOL]     n.set("null", (JsonNode) null); [EOL]     assertEquals(3, n.size()); [EOL]     assertTrue(n.has("null")); [EOL]     assertFalse(n.hasNonNull("null")); [EOL]     n.put("null", "notReallNull"); [EOL]     assertEquals(3, n.size()); [EOL]     assertNotNull(n.remove("null")); [EOL]     assertEquals(2, n.size()); [EOL]     Map<String, JsonNode> nodes = new HashMap<String, JsonNode>(); [EOL]     nodes.put("d", text); [EOL]     n.setAll(nodes); [EOL]     assertEquals(3, n.size()); [EOL]     n.removeAll(); [EOL]     assertEquals(0, n.size()); [EOL] }
public void testBasics() { [EOL]     ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [EOL]     assertStandardEquals(n); [EOL]     assertFalse(n.elements().hasNext()); [EOL]     assertFalse(n.fields().hasNext()); [EOL]     assertFalse(n.fieldNames().hasNext()); [EOL]     assertNull(n.get("a")); [EOL]     assertTrue(n.path("a").isMissingNode()); [EOL]     TextNode text = TextNode.valueOf("x"); [EOL]     n.set("a", text); [EOL]     assertEquals(1, n.size()); [EOL]     assertTrue(n.elements().hasNext()); [EOL]     assertTrue(n.fields().hasNext()); [EOL]     assertTrue(n.fieldNames().hasNext()); [EOL]     assertSame(text, n.get("a")); [EOL]     assertSame(text, n.path("a")); [EOL]     assertNull(n.get("b")); [EOL]     assertNull(n.get(0)); [EOL]     assertFalse(n.has(0)); [EOL]     assertFalse(n.hasNonNull(0)); [EOL]     assertTrue(n.has("a")); [EOL]     assertTrue(n.hasNonNull("a")); [EOL]     assertFalse(n.has("b")); [EOL]     assertFalse(n.hasNonNull("b")); [EOL]     ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance); [EOL]     n2.put("b", 13); [EOL]     assertFalse(n.equals(n2)); [EOL]     n.setAll(n2); [EOL]     assertEquals(2, n.size()); [EOL]     n.set("null", (JsonNode) null); [EOL]     assertEquals(3, n.size()); [EOL]     assertTrue(n.has("null")); [EOL]     assertFalse(n.hasNonNull("null")); [EOL]     n.put("null", "notReallNull"); [EOL]     assertEquals(3, n.size()); [EOL]     assertNotNull(n.remove("null")); [EOL]     assertEquals(2, n.size()); [EOL]     Map<String, JsonNode> nodes = new HashMap<String, JsonNode>(); [EOL]     nodes.put("d", text); [EOL]     n.setAll(nodes); [EOL]     assertEquals(3, n.size()); [EOL]     n.removeAll(); [EOL]     assertEquals(0, n.size()); [EOL] }
public void testBasics() { [EOL]     ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [EOL]     assertStandardEquals(n); [EOL]     assertFalse(n.elements().hasNext()); [EOL]     assertFalse(n.fields().hasNext()); [EOL]     assertFalse(n.fieldNames().hasNext()); [EOL]     assertNull(n.get("a")); [EOL]     assertTrue(n.path("a").isMissingNode()); [EOL]     TextNode text = TextNode.valueOf("x"); [EOL]     n.set("a", text); [EOL]     assertEquals(1, n.size()); [EOL]     assertTrue(n.elements().hasNext()); [EOL]     assertTrue(n.fields().hasNext()); [EOL]     assertTrue(n.fieldNames().hasNext()); [EOL]     assertSame(text, n.get("a")); [EOL]     assertSame(text, n.path("a")); [EOL]     assertNull(n.get("b")); [EOL]     assertNull(n.get(0)); [EOL]     assertFalse(n.has(0)); [EOL]     assertFalse(n.hasNonNull(0)); [EOL]     assertTrue(n.has("a")); [EOL]     assertTrue(n.hasNonNull("a")); [EOL]     assertFalse(n.has("b")); [EOL]     assertFalse(n.hasNonNull("b")); [EOL]     ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance); [EOL]     n2.put("b", 13); [EOL]     assertFalse(n.equals(n2)); [EOL]     n.setAll(n2); [EOL]     assertEquals(2, n.size()); [EOL]     n.set("null", (JsonNode) null); [EOL]     assertEquals(3, n.size()); [EOL]     assertTrue(n.has("null")); [EOL]     assertFalse(n.hasNonNull("null")); [EOL]     n.put("null", "notReallNull"); [EOL]     assertEquals(3, n.size()); [EOL]     assertNotNull(n.remove("null")); [EOL]     assertEquals(2, n.size()); [EOL]     Map<String, JsonNode> nodes = new HashMap<String, JsonNode>(); [EOL]     nodes.put("d", text); [EOL]     n.setAll(nodes); [EOL]     assertEquals(3, n.size()); [EOL]     n.removeAll(); [EOL]     assertEquals(0, n.size()); [EOL] }
public void testBasics() { [EOL]     ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [EOL]     assertStandardEquals(n); [EOL]     assertFalse(n.elements().hasNext()); [EOL]     assertFalse(n.fields().hasNext()); [EOL]     assertFalse(n.fieldNames().hasNext()); [EOL]     assertNull(n.get("a")); [EOL]     assertTrue(n.path("a").isMissingNode()); [EOL]     TextNode text = TextNode.valueOf("x"); [EOL]     n.set("a", text); [EOL]     assertEquals(1, n.size()); [EOL]     assertTrue(n.elements().hasNext()); [EOL]     assertTrue(n.fields().hasNext()); [EOL]     assertTrue(n.fieldNames().hasNext()); [EOL]     assertSame(text, n.get("a")); [EOL]     assertSame(text, n.path("a")); [EOL]     assertNull(n.get("b")); [EOL]     assertNull(n.get(0)); [EOL]     assertFalse(n.has(0)); [EOL]     assertFalse(n.hasNonNull(0)); [EOL]     assertTrue(n.has("a")); [EOL]     assertTrue(n.hasNonNull("a")); [EOL]     assertFalse(n.has("b")); [EOL]     assertFalse(n.hasNonNull("b")); [EOL]     ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance); [EOL]     n2.put("b", 13); [EOL]     assertFalse(n.equals(n2)); [EOL]     n.setAll(n2); [EOL]     assertEquals(2, n.size()); [EOL]     n.set("null", (JsonNode) null); [EOL]     assertEquals(3, n.size()); [EOL]     assertTrue(n.has("null")); [EOL]     assertFalse(n.hasNonNull("null")); [EOL]     n.put("null", "notReallNull"); [EOL]     assertEquals(3, n.size()); [EOL]     assertNotNull(n.remove("null")); [EOL]     assertEquals(2, n.size()); [EOL]     Map<String, JsonNode> nodes = new HashMap<String, JsonNode>(); [EOL]     nodes.put("d", text); [EOL]     n.setAll(nodes); [EOL]     assertEquals(3, n.size()); [EOL]     n.removeAll(); [EOL]     assertEquals(0, n.size()); [EOL] }
public void testBasics() { [EOL]     ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [EOL]     assertStandardEquals(n); [EOL]     assertFalse(n.elements().hasNext()); [EOL]     assertFalse(n.fields().hasNext()); [EOL]     assertFalse(n.fieldNames().hasNext()); [EOL]     assertNull(n.get("a")); [EOL]     assertTrue(n.path("a").isMissingNode()); [EOL]     TextNode text = TextNode.valueOf("x"); [EOL]     n.set("a", text); [EOL]     assertEquals(1, n.size()); [EOL]     assertTrue(n.elements().hasNext()); [EOL]     assertTrue(n.fields().hasNext()); [EOL]     assertTrue(n.fieldNames().hasNext()); [EOL]     assertSame(text, n.get("a")); [EOL]     assertSame(text, n.path("a")); [EOL]     assertNull(n.get("b")); [EOL]     assertNull(n.get(0)); [EOL]     assertFalse(n.has(0)); [EOL]     assertFalse(n.hasNonNull(0)); [EOL]     assertTrue(n.has("a")); [EOL]     assertTrue(n.hasNonNull("a")); [EOL]     assertFalse(n.has("b")); [EOL]     assertFalse(n.hasNonNull("b")); [EOL]     ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance); [EOL]     n2.put("b", 13); [EOL]     assertFalse(n.equals(n2)); [EOL]     n.setAll(n2); [EOL]     assertEquals(2, n.size()); [EOL]     n.set("null", (JsonNode) null); [EOL]     assertEquals(3, n.size()); [EOL]     assertTrue(n.has("null")); [EOL]     assertFalse(n.hasNonNull("null")); [EOL]     n.put("null", "notReallNull"); [EOL]     assertEquals(3, n.size()); [EOL]     assertNotNull(n.remove("null")); [EOL]     assertEquals(2, n.size()); [EOL]     Map<String, JsonNode> nodes = new HashMap<String, JsonNode>(); [EOL]     nodes.put("d", text); [EOL]     n.setAll(nodes); [EOL]     assertEquals(3, n.size()); [EOL]     n.removeAll(); [EOL]     assertEquals(0, n.size()); [EOL] }
public void testBasics() { [EOL]     ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [EOL]     assertStandardEquals(n); [EOL]     assertFalse(n.elements().hasNext()); [EOL]     assertFalse(n.fields().hasNext()); [EOL]     assertFalse(n.fieldNames().hasNext()); [EOL]     assertNull(n.get("a")); [EOL]     assertTrue(n.path("a").isMissingNode()); [EOL]     TextNode text = TextNode.valueOf("x"); [EOL]     n.set("a", text); [EOL]     assertEquals(1, n.size()); [EOL]     assertTrue(n.elements().hasNext()); [EOL]     assertTrue(n.fields().hasNext()); [EOL]     assertTrue(n.fieldNames().hasNext()); [EOL]     assertSame(text, n.get("a")); [EOL]     assertSame(text, n.path("a")); [EOL]     assertNull(n.get("b")); [EOL]     assertNull(n.get(0)); [EOL]     assertFalse(n.has(0)); [EOL]     assertFalse(n.hasNonNull(0)); [EOL]     assertTrue(n.has("a")); [EOL]     assertTrue(n.hasNonNull("a")); [EOL]     assertFalse(n.has("b")); [EOL]     assertFalse(n.hasNonNull("b")); [EOL]     ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance); [EOL]     n2.put("b", 13); [EOL]     assertFalse(n.equals(n2)); [EOL]     n.setAll(n2); [EOL]     assertEquals(2, n.size()); [EOL]     n.set("null", (JsonNode) null); [EOL]     assertEquals(3, n.size()); [EOL]     assertTrue(n.has("null")); [EOL]     assertFalse(n.hasNonNull("null")); [EOL]     n.put("null", "notReallNull"); [EOL]     assertEquals(3, n.size()); [EOL]     assertNotNull(n.remove("null")); [EOL]     assertEquals(2, n.size()); [EOL]     Map<String, JsonNode> nodes = new HashMap<String, JsonNode>(); [EOL]     nodes.put("d", text); [EOL]     n.setAll(nodes); [EOL]     assertEquals(3, n.size()); [EOL]     n.removeAll(); [EOL]     assertEquals(0, n.size()); [EOL] }
public void testBasics() { [EOL]     ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [EOL]     assertStandardEquals(n); [EOL]     assertFalse(n.elements().hasNext()); [EOL]     assertFalse(n.fields().hasNext()); [EOL]     assertFalse(n.fieldNames().hasNext()); [EOL]     assertNull(n.get("a")); [EOL]     assertTrue(n.path("a").isMissingNode()); [EOL]     TextNode text = TextNode.valueOf("x"); [EOL]     n.set("a", text); [EOL]     assertEquals(1, n.size()); [EOL]     assertTrue(n.elements().hasNext()); [EOL]     assertTrue(n.fields().hasNext()); [EOL]     assertTrue(n.fieldNames().hasNext()); [EOL]     assertSame(text, n.get("a")); [EOL]     assertSame(text, n.path("a")); [EOL]     assertNull(n.get("b")); [EOL]     assertNull(n.get(0)); [EOL]     assertFalse(n.has(0)); [EOL]     assertFalse(n.hasNonNull(0)); [EOL]     assertTrue(n.has("a")); [EOL]     assertTrue(n.hasNonNull("a")); [EOL]     assertFalse(n.has("b")); [EOL]     assertFalse(n.hasNonNull("b")); [EOL]     ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance); [EOL]     n2.put("b", 13); [EOL]     assertFalse(n.equals(n2)); [EOL]     n.setAll(n2); [EOL]     assertEquals(2, n.size()); [EOL]     n.set("null", (JsonNode) null); [EOL]     assertEquals(3, n.size()); [EOL]     assertTrue(n.has("null")); [EOL]     assertFalse(n.hasNonNull("null")); [EOL]     n.put("null", "notReallNull"); [EOL]     assertEquals(3, n.size()); [EOL]     assertNotNull(n.remove("null")); [EOL]     assertEquals(2, n.size()); [EOL]     Map<String, JsonNode> nodes = new HashMap<String, JsonNode>(); [EOL]     nodes.put("d", text); [EOL]     n.setAll(nodes); [EOL]     assertEquals(3, n.size()); [EOL]     n.removeAll(); [EOL]     assertEquals(0, n.size()); [EOL] }
public void testBasics() { [EOL]     ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [EOL]     assertStandardEquals(n); [EOL]     assertFalse(n.elements().hasNext()); [EOL]     assertFalse(n.fields().hasNext()); [EOL]     assertFalse(n.fieldNames().hasNext()); [EOL]     assertNull(n.get("a")); [EOL]     assertTrue(n.path("a").isMissingNode()); [EOL]     TextNode text = TextNode.valueOf("x"); [EOL]     n.set("a", text); [EOL]     assertEquals(1, n.size()); [EOL]     assertTrue(n.elements().hasNext()); [EOL]     assertTrue(n.fields().hasNext()); [EOL]     assertTrue(n.fieldNames().hasNext()); [EOL]     assertSame(text, n.get("a")); [EOL]     assertSame(text, n.path("a")); [EOL]     assertNull(n.get("b")); [EOL]     assertNull(n.get(0)); [EOL]     assertFalse(n.has(0)); [EOL]     assertFalse(n.hasNonNull(0)); [EOL]     assertTrue(n.has("a")); [EOL]     assertTrue(n.hasNonNull("a")); [EOL]     assertFalse(n.has("b")); [EOL]     assertFalse(n.hasNonNull("b")); [EOL]     ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance); [EOL]     n2.put("b", 13); [EOL]     assertFalse(n.equals(n2)); [EOL]     n.setAll(n2); [EOL]     assertEquals(2, n.size()); [EOL]     n.set("null", (JsonNode) null); [EOL]     assertEquals(3, n.size()); [EOL]     assertTrue(n.has("null")); [EOL]     assertFalse(n.hasNonNull("null")); [EOL]     n.put("null", "notReallNull"); [EOL]     assertEquals(3, n.size()); [EOL]     assertNotNull(n.remove("null")); [EOL]     assertEquals(2, n.size()); [EOL]     Map<String, JsonNode> nodes = new HashMap<String, JsonNode>(); [EOL]     nodes.put("d", text); [EOL]     n.setAll(nodes); [EOL]     assertEquals(3, n.size()); [EOL]     n.removeAll(); [EOL]     assertEquals(0, n.size()); [EOL] }
public void testBasics() { [EOL]     ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [EOL]     assertStandardEquals(n); [EOL]     assertFalse(n.elements().hasNext()); [EOL]     assertFalse(n.fields().hasNext()); [EOL]     assertFalse(n.fieldNames().hasNext()); [EOL]     assertNull(n.get("a")); [EOL]     assertTrue(n.path("a").isMissingNode()); [EOL]     TextNode text = TextNode.valueOf("x"); [EOL]     n.set("a", text); [EOL]     assertEquals(1, n.size()); [EOL]     assertTrue(n.elements().hasNext()); [EOL]     assertTrue(n.fields().hasNext()); [EOL]     assertTrue(n.fieldNames().hasNext()); [EOL]     assertSame(text, n.get("a")); [EOL]     assertSame(text, n.path("a")); [EOL]     assertNull(n.get("b")); [EOL]     assertNull(n.get(0)); [EOL]     assertFalse(n.has(0)); [EOL]     assertFalse(n.hasNonNull(0)); [EOL]     assertTrue(n.has("a")); [EOL]     assertTrue(n.hasNonNull("a")); [EOL]     assertFalse(n.has("b")); [EOL]     assertFalse(n.hasNonNull("b")); [EOL]     ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance); [EOL]     n2.put("b", 13); [EOL]     assertFalse(n.equals(n2)); [EOL]     n.setAll(n2); [EOL]     assertEquals(2, n.size()); [EOL]     n.set("null", (JsonNode) null); [EOL]     assertEquals(3, n.size()); [EOL]     assertTrue(n.has("null")); [EOL]     assertFalse(n.hasNonNull("null")); [EOL]     n.put("null", "notReallNull"); [EOL]     assertEquals(3, n.size()); [EOL]     assertNotNull(n.remove("null")); [EOL]     assertEquals(2, n.size()); [EOL]     Map<String, JsonNode> nodes = new HashMap<String, JsonNode>(); [EOL]     nodes.put("d", text); [EOL]     n.setAll(nodes); [EOL]     assertEquals(3, n.size()); [EOL]     n.removeAll(); [EOL]     assertEquals(0, n.size()); [EOL] }
public void testBasics() { [EOL]     ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [EOL]     assertStandardEquals(n); [EOL]     assertFalse(n.elements().hasNext()); [EOL]     assertFalse(n.fields().hasNext()); [EOL]     assertFalse(n.fieldNames().hasNext()); [EOL]     assertNull(n.get("a")); [EOL]     assertTrue(n.path("a").isMissingNode()); [EOL]     TextNode text = TextNode.valueOf("x"); [EOL]     n.set("a", text); [EOL]     assertEquals(1, n.size()); [EOL]     assertTrue(n.elements().hasNext()); [EOL]     assertTrue(n.fields().hasNext()); [EOL]     assertTrue(n.fieldNames().hasNext()); [EOL]     assertSame(text, n.get("a")); [EOL]     assertSame(text, n.path("a")); [EOL]     assertNull(n.get("b")); [EOL]     assertNull(n.get(0)); [EOL]     assertFalse(n.has(0)); [EOL]     assertFalse(n.hasNonNull(0)); [EOL]     assertTrue(n.has("a")); [EOL]     assertTrue(n.hasNonNull("a")); [EOL]     assertFalse(n.has("b")); [EOL]     assertFalse(n.hasNonNull("b")); [EOL]     ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance); [EOL]     n2.put("b", 13); [EOL]     assertFalse(n.equals(n2)); [EOL]     n.setAll(n2); [EOL]     assertEquals(2, n.size()); [EOL]     n.set("null", (JsonNode) null); [EOL]     assertEquals(3, n.size()); [EOL]     assertTrue(n.has("null")); [EOL]     assertFalse(n.hasNonNull("null")); [EOL]     n.put("null", "notReallNull"); [EOL]     assertEquals(3, n.size()); [EOL]     assertNotNull(n.remove("null")); [EOL]     assertEquals(2, n.size()); [EOL]     Map<String, JsonNode> nodes = new HashMap<String, JsonNode>(); [EOL]     nodes.put("d", text); [EOL]     n.setAll(nodes); [EOL]     assertEquals(3, n.size()); [EOL]     n.removeAll(); [EOL]     assertEquals(0, n.size()); [EOL] }
public void testInvalidWith() throws Exception { [EOL]     JsonNode root = MAPPER.createArrayNode(); [EOL]     try { [EOL]         root.with("prop"); [EOL]         fail("Expected exception"); [EOL]     } catch (UnsupportedOperationException e) { [EOL]         verifyException(e, "not of type ObjectNode"); [EOL]     } [EOL]     ObjectNode root2 = MAPPER.createObjectNode(); [EOL]     root2.put("prop", 13); [EOL]     try { [EOL]         root2.with("prop"); [EOL]         fail("Expected exception"); [EOL]     } catch (UnsupportedOperationException e) { [EOL]         verifyException(e, "has value that is not"); [EOL]     } [EOL] }
public void testInvalidWithArray() throws Exception { [EOL]     JsonNode root = MAPPER.createArrayNode(); [EOL]     try { [EOL]         root.withArray("prop"); [EOL]         fail("Expected exception"); [EOL]     } catch (UnsupportedOperationException e) { [EOL]         verifyException(e, "not of type ObjectNode"); [EOL]     } [EOL]     ObjectNode root2 = MAPPER.createObjectNode(); [EOL]     root2.put("prop", 13); [EOL]     try { [EOL]         root2.withArray("prop"); [EOL]         fail("Expected exception"); [EOL]     } catch (UnsupportedOperationException e) { [EOL]         verifyException(e, "has value that is not"); [EOL]     } [EOL] }
public void testSuperTypes() { [EOL]     Collection<Class<?>> result = ClassUtil.findSuperTypes(SubClass.class, null); [EOL]     Class<?>[] classes = result.toArray(new Class<?>[result.size()]); [EOL]     Class<?>[] exp = new Class[] { SubInt.class, BaseInt.class, BaseClass.class, Comparable.class }; [EOL]     assertArrayEquals(exp, classes); [EOL] }
public void testSuperTypes() { [EOL]     Collection<Class<?>> result = ClassUtil.findSuperTypes(SubClass.class, null); [EOL]     Class<?>[] classes = result.toArray(new Class<?>[result.size()]); [EOL]     Class<?>[] exp = new Class[] { SubInt.class, BaseInt.class, BaseClass.class, Comparable.class }; [EOL]     assertArrayEquals(exp, classes); [EOL] }
public void testSuperTypes() { [EOL]     Collection<Class<?>> result = ClassUtil.findSuperTypes(SubClass.class, null); [EOL]     Class<?>[] classes = result.toArray(new Class<?>[result.size()]); [EOL]     Class<?>[] exp = new Class[] { SubInt.class, BaseInt.class, BaseClass.class, Comparable.class }; [EOL]     assertArrayEquals(exp, classes); [EOL] }
public void testSuperTypes() { [EOL]     Collection<Class<?>> result = ClassUtil.findSuperTypes(SubClass.class, null); [EOL]     Class<?>[] classes = result.toArray(new Class<?>[result.size()]); [EOL]     Class<?>[] exp = new Class[] { SubInt.class, BaseInt.class, BaseClass.class, Comparable.class }; [EOL]     assertArrayEquals(exp, classes); [EOL] }
public void testSuperTypes() { [EOL]     Collection<Class<?>> result = ClassUtil.findSuperTypes(SubClass.class, null); [EOL]     Class<?>[] classes = result.toArray(new Class<?>[result.size()]); [EOL]     Class<?>[] exp = new Class[] { SubInt.class, BaseInt.class, BaseClass.class, Comparable.class }; [EOL]     assertArrayEquals(exp, classes); [EOL] }
public void testSuperTypes() { [EOL]     Collection<Class<?>> result = ClassUtil.findSuperTypes(SubClass.class, null); [EOL]     Class<?>[] classes = result.toArray(new Class<?>[result.size()]); [EOL]     Class<?>[] exp = new Class[] { SubInt.class, BaseInt.class, BaseClass.class, Comparable.class }; [EOL]     assertArrayEquals(exp, classes); [EOL] }
public void testSuperTypes() { [EOL]     Collection<Class<?>> result = ClassUtil.findSuperTypes(SubClass.class, null); [EOL]     Class<?>[] classes = result.toArray(new Class<?>[result.size()]); [EOL]     Class<?>[] exp = new Class[] { SubInt.class, BaseInt.class, BaseClass.class, Comparable.class }; [EOL]     assertArrayEquals(exp, classes); [EOL] }
public void testInnerClassWithType() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(DefaultTyping.NON_FINAL); [EOL]     String json = mapper.writeValueAsString(new BeanWithAnon()); [EOL]     BeanWithAnon result = mapper.readValue(json, BeanWithAnon.class); [EOL]     assertEquals(BeanWithAnon.class, result.getClass()); [EOL] }
public void testInnerClassWithType() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(DefaultTyping.NON_FINAL); [EOL]     String json = mapper.writeValueAsString(new BeanWithAnon()); [EOL]     BeanWithAnon result = mapper.readValue(json, BeanWithAnon.class); [EOL]     assertEquals(BeanWithAnon.class, result.getClass()); [EOL] }
public void testInnerClassWithType() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(DefaultTyping.NON_FINAL); [EOL]     String json = mapper.writeValueAsString(new BeanWithAnon()); [EOL]     BeanWithAnon result = mapper.readValue(json, BeanWithAnon.class); [EOL]     assertEquals(BeanWithAnon.class, result.getClass()); [EOL] }
public void testInnerClassWithType() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(DefaultTyping.NON_FINAL); [EOL]     String json = mapper.writeValueAsString(new BeanWithAnon()); [EOL]     BeanWithAnon result = mapper.readValue(json, BeanWithAnon.class); [EOL]     assertEquals(BeanWithAnon.class, result.getClass()); [EOL] }
public void testInnerClassWithType() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(DefaultTyping.NON_FINAL); [EOL]     String json = mapper.writeValueAsString(new BeanWithAnon()); [EOL]     BeanWithAnon result = mapper.readValue(json, BeanWithAnon.class); [EOL]     assertEquals(BeanWithAnon.class, result.getClass()); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testOverrideContentClassValid() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     ListContentHolder result = m.readValue("{ \"list\" : [ \"abc\" ] }", ListContentHolder.class); [EOL]     List<StringWrapper> list = (List<StringWrapper>) result._list; [EOL]     assertEquals(1, list.size()); [EOL]     Object value = list.get(0); [EOL]     assertEquals(StringWrapper.class, value.getClass()); [EOL]     assertEquals("abc", ((StringWrapper) value)._string); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testOverrideContentClassValid() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     ListContentHolder result = m.readValue("{ \"list\" : [ \"abc\" ] }", ListContentHolder.class); [EOL]     List<StringWrapper> list = (List<StringWrapper>) result._list; [EOL]     assertEquals(1, list.size()); [EOL]     Object value = list.get(0); [EOL]     assertEquals(StringWrapper.class, value.getClass()); [EOL]     assertEquals("abc", ((StringWrapper) value)._string); [EOL] }
public void testListContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     ListBean result = m.readValue(" { \"values\" : [ 1, 2, 3 ] } ", ListBean.class); [EOL]     assertNotNull(result); [EOL]     List<Object> obs = result.values; [EOL]     assertNotNull(obs); [EOL]     assertEquals(3, obs.size()); [EOL]     assertEquals(ValueClass.class, obs.get(0).getClass()); [EOL]     assertEquals(1, ((ValueClass) obs.get(0))._a); [EOL]     assertEquals(ValueClass.class, obs.get(1).getClass()); [EOL]     assertEquals(2, ((ValueClass) obs.get(1))._a); [EOL]     assertEquals(ValueClass.class, obs.get(2).getClass()); [EOL]     assertEquals(3, ((ValueClass) obs.get(2))._a); [EOL] }
public void testListContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     ListBean result = m.readValue(" { \"values\" : [ 1, 2, 3 ] } ", ListBean.class); [EOL]     assertNotNull(result); [EOL]     List<Object> obs = result.values; [EOL]     assertNotNull(obs); [EOL]     assertEquals(3, obs.size()); [EOL]     assertEquals(ValueClass.class, obs.get(0).getClass()); [EOL]     assertEquals(1, ((ValueClass) obs.get(0))._a); [EOL]     assertEquals(ValueClass.class, obs.get(1).getClass()); [EOL]     assertEquals(2, ((ValueClass) obs.get(1))._a); [EOL]     assertEquals(ValueClass.class, obs.get(2).getClass()); [EOL]     assertEquals(3, ((ValueClass) obs.get(2))._a); [EOL] }
public void testIssue508() throws Exception { [EOL]     List<List<Issue508A>> l = new ArrayList<List<Issue508A>>(); [EOL]     List<Issue508A> l2 = new ArrayList<Issue508A>(); [EOL]     l2.add(new Issue508A()); [EOL]     l.add(l2); [EOL]     TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() { [EOL]     }; [EOL]     String json = mapper.writerWithType(typeRef).writeValueAsString(l); [EOL]     List<?> output = mapper.readValue(json, typeRef); [EOL]     assertEquals(1, output.size()); [EOL]     Object ob = output.get(0); [EOL]     assertTrue(ob instanceof List<?>); [EOL]     List<?> list2 = (List<?>) ob; [EOL]     assertEquals(1, list2.size()); [EOL]     ob = list2.get(0); [EOL]     assertSame(Issue508A.class, ob.getClass()); [EOL] }
public void testIssue508() throws Exception { [EOL]     List<List<Issue508A>> l = new ArrayList<List<Issue508A>>(); [EOL]     List<Issue508A> l2 = new ArrayList<Issue508A>(); [EOL]     l2.add(new Issue508A()); [EOL]     l.add(l2); [EOL]     TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() { [EOL]     }; [EOL]     String json = mapper.writerWithType(typeRef).writeValueAsString(l); [EOL]     List<?> output = mapper.readValue(json, typeRef); [EOL]     assertEquals(1, output.size()); [EOL]     Object ob = output.get(0); [EOL]     assertTrue(ob instanceof List<?>); [EOL]     List<?> list2 = (List<?>) ob; [EOL]     assertEquals(1, list2.size()); [EOL]     ob = list2.get(0); [EOL]     assertSame(Issue508A.class, ob.getClass()); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testMapToBean() { [EOL]     EnumMap<AB, String> map = new EnumMap<AB, String>(AB.class); [EOL]     map.put(AB.A, "   17"); [EOL]     map.put(AB.B, " -1"); [EOL]     Bean bean = mapper.convertValue(map, Bean.class); [EOL]     assertEquals(Integer.valueOf(17), bean.A); [EOL]     assertEquals(" -1", bean.B); [EOL] }
public void testMapToBean() { [EOL]     EnumMap<AB, String> map = new EnumMap<AB, String>(AB.class); [EOL]     map.put(AB.A, "   17"); [EOL]     map.put(AB.B, " -1"); [EOL]     Bean bean = mapper.convertValue(map, Bean.class); [EOL]     assertEquals(Integer.valueOf(17), bean.A); [EOL]     assertEquals(" -1", bean.B); [EOL] }
public void testMapToBean() { [EOL]     EnumMap<AB, String> map = new EnumMap<AB, String>(AB.class); [EOL]     map.put(AB.A, "   17"); [EOL]     map.put(AB.B, " -1"); [EOL]     Bean bean = mapper.convertValue(map, Bean.class); [EOL]     assertEquals(Integer.valueOf(17), bean.A); [EOL]     assertEquals(" -1", bean.B); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testEmptyBeanEnumMap() throws IOException { [EOL]     EnumMap<Key, String> map = new EnumMap<Key, String>(Key.class); [EOL]     EnumMapBean b = new EnumMapBean(map); [EOL]     Map<String, Object> result = writeAndMap(MAPPER, b); [EOL]     assertEquals(1, result.size()); [EOL]     assertTrue(result.containsKey("map")); [EOL]     Map<Object, Object> map2 = (Map<Object, Object>) result.get("map"); [EOL]     assertNotNull(map2); [EOL]     assertEquals(0, map2.size()); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testEmptyBeanEnumMap() throws IOException { [EOL]     EnumMap<Key, String> map = new EnumMap<Key, String>(Key.class); [EOL]     EnumMapBean b = new EnumMapBean(map); [EOL]     Map<String, Object> result = writeAndMap(MAPPER, b); [EOL]     assertEquals(1, result.size()); [EOL]     assertTrue(result.containsKey("map")); [EOL]     Map<Object, Object> map2 = (Map<Object, Object>) result.get("map"); [EOL]     assertNotNull(map2); [EOL]     assertEquals(0, map2.size()); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testEmptyBeanEnumMap() throws IOException { [EOL]     EnumMap<Key, String> map = new EnumMap<Key, String>(Key.class); [EOL]     EnumMapBean b = new EnumMapBean(map); [EOL]     Map<String, Object> result = writeAndMap(MAPPER, b); [EOL]     assertEquals(1, result.size()); [EOL]     assertTrue(result.containsKey("map")); [EOL]     Map<Object, Object> map2 = (Map<Object, Object>) result.get("map"); [EOL]     assertNotNull(map2); [EOL]     assertEquals(0, map2.size()); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testEmptyBeanEnumMap() throws IOException { [EOL]     EnumMap<Key, String> map = new EnumMap<Key, String>(Key.class); [EOL]     EnumMapBean b = new EnumMapBean(map); [EOL]     Map<String, Object> result = writeAndMap(MAPPER, b); [EOL]     assertEquals(1, result.size()); [EOL]     assertTrue(result.containsKey("map")); [EOL]     Map<Object, Object> map2 = (Map<Object, Object>) result.get("map"); [EOL]     assertNotNull(map2); [EOL]     assertEquals(0, map2.size()); [EOL] }
public void testMapToBean() { [EOL]     EnumMap<AB, String> map = new EnumMap<AB, String>(AB.class); [EOL]     map.put(AB.A, "   17"); [EOL]     map.put(AB.B, " -1"); [EOL]     Bean bean = mapper.convertValue(map, Bean.class); [EOL]     assertEquals(Integer.valueOf(17), bean.A); [EOL]     assertEquals(" -1", bean.B); [EOL] }
public void testMapToBean() { [EOL]     EnumMap<AB, String> map = new EnumMap<AB, String>(AB.class); [EOL]     map.put(AB.A, "   17"); [EOL]     map.put(AB.B, " -1"); [EOL]     Bean bean = mapper.convertValue(map, Bean.class); [EOL]     assertEquals(Integer.valueOf(17), bean.A); [EOL]     assertEquals(" -1", bean.B); [EOL] }
public void testMapToBean() { [EOL]     EnumMap<AB, String> map = new EnumMap<AB, String>(AB.class); [EOL]     map.put(AB.A, "   17"); [EOL]     map.put(AB.B, " -1"); [EOL]     Bean bean = mapper.convertValue(map, Bean.class); [EOL]     assertEquals(Integer.valueOf(17), bean.A); [EOL]     assertEquals(" -1", bean.B); [EOL] }
public void testMapToBean() { [EOL]     EnumMap<AB, String> map = new EnumMap<AB, String>(AB.class); [EOL]     map.put(AB.A, "   17"); [EOL]     map.put(AB.B, " -1"); [EOL]     Bean bean = mapper.convertValue(map, Bean.class); [EOL]     assertEquals(Integer.valueOf(17), bean.A); [EOL]     assertEquals(" -1", bean.B); [EOL] }
public void testMapToBean() { [EOL]     EnumMap<AB, String> map = new EnumMap<AB, String>(AB.class); [EOL]     map.put(AB.A, "   17"); [EOL]     map.put(AB.B, " -1"); [EOL]     Bean bean = mapper.convertValue(map, Bean.class); [EOL]     assertEquals(Integer.valueOf(17), bean.A); [EOL]     assertEquals(" -1", bean.B); [EOL] }
public void testMapToBean() { [EOL]     EnumMap<AB, String> map = new EnumMap<AB, String>(AB.class); [EOL]     map.put(AB.A, "   17"); [EOL]     map.put(AB.B, " -1"); [EOL]     Bean bean = mapper.convertValue(map, Bean.class); [EOL]     assertEquals(Integer.valueOf(17), bean.A); [EOL]     assertEquals(" -1", bean.B); [EOL] }
public void testMapToBean() { [EOL]     EnumMap<AB, String> map = new EnumMap<AB, String>(AB.class); [EOL]     map.put(AB.A, "   17"); [EOL]     map.put(AB.B, " -1"); [EOL]     Bean bean = mapper.convertValue(map, Bean.class); [EOL]     assertEquals(Integer.valueOf(17), bean.A); [EOL]     assertEquals(" -1", bean.B); [EOL] }
public void testMapToBean() { [EOL]     EnumMap<AB, String> map = new EnumMap<AB, String>(AB.class); [EOL]     map.put(AB.A, "   17"); [EOL]     map.put(AB.B, " -1"); [EOL]     Bean bean = mapper.convertValue(map, Bean.class); [EOL]     assertEquals(Integer.valueOf(17), bean.A); [EOL]     assertEquals(" -1", bean.B); [EOL] }
public void testSimpleKeySer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.addKeySerializer(String.class, new ContextualKeySerializer("prefix")); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> input = new HashMap<String, Object>(); [EOL]     input.put("a", Integer.valueOf(3)); [EOL]     String json = mapper.writerWithType(TypeFactory.defaultInstance().constructMapType(HashMap.class, String.class, Object.class)).writeValueAsString(input); [EOL]     assertEquals("{\"prefix:a\":3}", json); [EOL] }
public void testSimpleKeySer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.addKeySerializer(String.class, new ContextualKeySerializer("prefix")); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> input = new HashMap<String, Object>(); [EOL]     input.put("a", Integer.valueOf(3)); [EOL]     String json = mapper.writerWithType(TypeFactory.defaultInstance().constructMapType(HashMap.class, String.class, Object.class)).writeValueAsString(input); [EOL]     assertEquals("{\"prefix:a\":3}", json); [EOL] }
public void testSimpleKeySer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.addKeySerializer(String.class, new ContextualKeySerializer("prefix")); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> input = new HashMap<String, Object>(); [EOL]     input.put("a", Integer.valueOf(3)); [EOL]     String json = mapper.writerWithType(TypeFactory.defaultInstance().constructMapType(HashMap.class, String.class, Object.class)).writeValueAsString(input); [EOL]     assertEquals("{\"prefix:a\":3}", json); [EOL] }
public void testSimpleKeySer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.addKeySerializer(String.class, new ContextualKeySerializer("prefix")); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> input = new HashMap<String, Object>(); [EOL]     input.put("a", Integer.valueOf(3)); [EOL]     String json = mapper.writerWithType(TypeFactory.defaultInstance().constructMapType(HashMap.class, String.class, Object.class)).writeValueAsString(input); [EOL]     assertEquals("{\"prefix:a\":3}", json); [EOL] }
public void testSimpleInterfaceSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule mod = new SimpleModule("test", Version.unknownVersion()); [EOL]     mod.addSerializer(new BaseSerializer()); [EOL]     mapper.registerModule(mod); [EOL]     assertEquals(quote("Base:1"), mapper.writeValueAsString(new Impl1())); [EOL]     assertEquals(quote("Base:2"), mapper.writeValueAsString(new Impl2())); [EOL] }
public void testSimpleInterfaceSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule mod = new SimpleModule("test", Version.unknownVersion()); [EOL]     mod.addSerializer(new BaseSerializer()); [EOL]     mapper.registerModule(mod); [EOL]     assertEquals(quote("Base:1"), mapper.writeValueAsString(new Impl1())); [EOL]     assertEquals(quote("Base:2"), mapper.writeValueAsString(new Impl2())); [EOL] }
public void testSimpleInterfaceSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule mod = new SimpleModule("test", Version.unknownVersion()); [EOL]     mod.addSerializer(new BaseSerializer()); [EOL]     mapper.registerModule(mod); [EOL]     assertEquals(quote("Base:1"), mapper.writeValueAsString(new Impl1())); [EOL]     assertEquals(quote("Base:2"), mapper.writeValueAsString(new Impl2())); [EOL] }
public void testSimpleInterfaceSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule mod = new SimpleModule("test", Version.unknownVersion()); [EOL]     mod.addSerializer(new BaseSerializer()); [EOL]     mapper.registerModule(mod); [EOL]     assertEquals(quote("Base:1"), mapper.writeValueAsString(new Impl1())); [EOL]     assertEquals(quote("Base:2"), mapper.writeValueAsString(new Impl2())); [EOL] }
public void testSimpleInterfaceSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule mod = new SimpleModule("test", Version.unknownVersion()); [EOL]     mod.addSerializer(new BaseSerializer()); [EOL]     mapper.registerModule(mod); [EOL]     assertEquals(quote("Base:1"), mapper.writeValueAsString(new Impl1())); [EOL]     assertEquals(quote("Base:2"), mapper.writeValueAsString(new Impl2())); [EOL] }
public void testSimpleInterfaceSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule mod = new SimpleModule("test", Version.unknownVersion()); [EOL]     mod.addSerializer(new BaseSerializer()); [EOL]     mapper.registerModule(mod); [EOL]     assertEquals(quote("Base:1"), mapper.writeValueAsString(new Impl1())); [EOL]     assertEquals(quote("Base:2"), mapper.writeValueAsString(new Impl2())); [EOL] }
public void testSimpleInterfaceSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule mod = new SimpleModule("test", Version.unknownVersion()); [EOL]     mod.addSerializer(new BaseSerializer()); [EOL]     mapper.registerModule(mod); [EOL]     assertEquals(quote("Base:1"), mapper.writeValueAsString(new Impl1())); [EOL]     assertEquals(quote("Base:2"), mapper.writeValueAsString(new Impl2())); [EOL] }
public void testIssue508() throws Exception { [EOL]     List<List<Issue508A>> l = new ArrayList<List<Issue508A>>(); [EOL]     List<Issue508A> l2 = new ArrayList<Issue508A>(); [EOL]     l2.add(new Issue508A()); [EOL]     l.add(l2); [EOL]     TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() { [EOL]     }; [EOL]     String json = mapper.writerWithType(typeRef).writeValueAsString(l); [EOL]     List<?> output = mapper.readValue(json, typeRef); [EOL]     assertEquals(1, output.size()); [EOL]     Object ob = output.get(0); [EOL]     assertTrue(ob instanceof List<?>); [EOL]     List<?> list2 = (List<?>) ob; [EOL]     assertEquals(1, list2.size()); [EOL]     ob = list2.get(0); [EOL]     assertSame(Issue508A.class, ob.getClass()); [EOL] }
public void testIssue508() throws Exception { [EOL]     List<List<Issue508A>> l = new ArrayList<List<Issue508A>>(); [EOL]     List<Issue508A> l2 = new ArrayList<Issue508A>(); [EOL]     l2.add(new Issue508A()); [EOL]     l.add(l2); [EOL]     TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() { [EOL]     }; [EOL]     String json = mapper.writerWithType(typeRef).writeValueAsString(l); [EOL]     List<?> output = mapper.readValue(json, typeRef); [EOL]     assertEquals(1, output.size()); [EOL]     Object ob = output.get(0); [EOL]     assertTrue(ob instanceof List<?>); [EOL]     List<?> list2 = (List<?>) ob; [EOL]     assertEquals(1, list2.size()); [EOL]     ob = list2.get(0); [EOL]     assertSame(Issue508A.class, ob.getClass()); [EOL] }
public void testIssue508() throws Exception { [EOL]     List<List<Issue508A>> l = new ArrayList<List<Issue508A>>(); [EOL]     List<Issue508A> l2 = new ArrayList<Issue508A>(); [EOL]     l2.add(new Issue508A()); [EOL]     l.add(l2); [EOL]     TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() { [EOL]     }; [EOL]     String json = mapper.writerWithType(typeRef).writeValueAsString(l); [EOL]     List<?> output = mapper.readValue(json, typeRef); [EOL]     assertEquals(1, output.size()); [EOL]     Object ob = output.get(0); [EOL]     assertTrue(ob instanceof List<?>); [EOL]     List<?> list2 = (List<?>) ob; [EOL]     assertEquals(1, list2.size()); [EOL]     ob = list2.get(0); [EOL]     assertSame(Issue508A.class, ob.getClass()); [EOL] }
public void testIssue508() throws Exception { [EOL]     List<List<Issue508A>> l = new ArrayList<List<Issue508A>>(); [EOL]     List<Issue508A> l2 = new ArrayList<Issue508A>(); [EOL]     l2.add(new Issue508A()); [EOL]     l.add(l2); [EOL]     TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() { [EOL]     }; [EOL]     String json = mapper.writerWithType(typeRef).writeValueAsString(l); [EOL]     List<?> output = mapper.readValue(json, typeRef); [EOL]     assertEquals(1, output.size()); [EOL]     Object ob = output.get(0); [EOL]     assertTrue(ob instanceof List<?>); [EOL]     List<?> list2 = (List<?>) ob; [EOL]     assertEquals(1, list2.size()); [EOL]     ob = list2.get(0); [EOL]     assertSame(Issue508A.class, ob.getClass()); [EOL] }
public void testIssue508() throws Exception { [EOL]     List<List<Issue508A>> l = new ArrayList<List<Issue508A>>(); [EOL]     List<Issue508A> l2 = new ArrayList<Issue508A>(); [EOL]     l2.add(new Issue508A()); [EOL]     l.add(l2); [EOL]     TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() { [EOL]     }; [EOL]     String json = mapper.writerWithType(typeRef).writeValueAsString(l); [EOL]     List<?> output = mapper.readValue(json, typeRef); [EOL]     assertEquals(1, output.size()); [EOL]     Object ob = output.get(0); [EOL]     assertTrue(ob instanceof List<?>); [EOL]     List<?> list2 = (List<?>) ob; [EOL]     assertEquals(1, list2.size()); [EOL]     ob = list2.get(0); [EOL]     assertSame(Issue508A.class, ob.getClass()); [EOL] }
public void testIssue508() throws Exception { [EOL]     List<List<Issue508A>> l = new ArrayList<List<Issue508A>>(); [EOL]     List<Issue508A> l2 = new ArrayList<Issue508A>(); [EOL]     l2.add(new Issue508A()); [EOL]     l.add(l2); [EOL]     TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() { [EOL]     }; [EOL]     String json = mapper.writerWithType(typeRef).writeValueAsString(l); [EOL]     List<?> output = mapper.readValue(json, typeRef); [EOL]     assertEquals(1, output.size()); [EOL]     Object ob = output.get(0); [EOL]     assertTrue(ob instanceof List<?>); [EOL]     List<?> list2 = (List<?>) ob; [EOL]     assertEquals(1, list2.size()); [EOL]     ob = list2.get(0); [EOL]     assertSame(Issue508A.class, ob.getClass()); [EOL] }
public void testIssue508() throws Exception { [EOL]     List<List<Issue508A>> l = new ArrayList<List<Issue508A>>(); [EOL]     List<Issue508A> l2 = new ArrayList<Issue508A>(); [EOL]     l2.add(new Issue508A()); [EOL]     l.add(l2); [EOL]     TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() { [EOL]     }; [EOL]     String json = mapper.writerWithType(typeRef).writeValueAsString(l); [EOL]     List<?> output = mapper.readValue(json, typeRef); [EOL]     assertEquals(1, output.size()); [EOL]     Object ob = output.get(0); [EOL]     assertTrue(ob instanceof List<?>); [EOL]     List<?> list2 = (List<?>) ob; [EOL]     assertEquals(1, list2.size()); [EOL]     ob = list2.get(0); [EOL]     assertSame(Issue508A.class, ob.getClass()); [EOL] }
public void testIssue508() throws Exception { [EOL]     List<List<Issue508A>> l = new ArrayList<List<Issue508A>>(); [EOL]     List<Issue508A> l2 = new ArrayList<Issue508A>(); [EOL]     l2.add(new Issue508A()); [EOL]     l.add(l2); [EOL]     TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() { [EOL]     }; [EOL]     String json = mapper.writerWithType(typeRef).writeValueAsString(l); [EOL]     List<?> output = mapper.readValue(json, typeRef); [EOL]     assertEquals(1, output.size()); [EOL]     Object ob = output.get(0); [EOL]     assertTrue(ob instanceof List<?>); [EOL]     List<?> list2 = (List<?>) ob; [EOL]     assertEquals(1, list2.size()); [EOL]     ob = list2.get(0); [EOL]     assertSame(Issue508A.class, ob.getClass()); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testStaticTypingWithArrayList() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(MapperFeature.USE_STATIC_TYPING, true); [EOL]     ValueList list = new ValueList(); [EOL]     list.add(new ValueClass()); [EOL]     assertEquals("[{\"x\":3}]", m.writeValueAsString(list)); [EOL] }
public void testStaticTypingWithArrayList() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(MapperFeature.USE_STATIC_TYPING, true); [EOL]     ValueList list = new ValueList(); [EOL]     list.add(new ValueClass()); [EOL]     assertEquals("[{\"x\":3}]", m.writeValueAsString(list)); [EOL] }
public void testStaticTypingWithArrayList() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(MapperFeature.USE_STATIC_TYPING, true); [EOL]     ValueList list = new ValueList(); [EOL]     list.add(new ValueClass()); [EOL]     assertEquals("[{\"x\":3}]", m.writeValueAsString(list)); [EOL] }
public void testBase64Variants() throws Exception { [EOL]     final byte[] INPUT = "abcdefghijklmnopqrstuvwxyz1234567890abcdefghijklmnopqrstuvwxyz1234567890X".getBytes("UTF-8"); [EOL]     Assert.assertArrayEquals(INPUT, MAPPER.readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="), byte[].class)); [EOL]     ObjectReader reader = MAPPER.reader(byte[].class); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MIME_NO_LINEFEEDS).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="))); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MIME).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1\\ndnd4eXoxMjM0NTY3ODkwWA=="))); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MODIFIED_FOR_URL).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA"))); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.PEM).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamts\\nbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="))); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals("java.util.Calendar", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.ArrayList<java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] }
public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals("java.util.Calendar", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.ArrayList<java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] }
public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals("java.util.Calendar", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.ArrayList<java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] }
public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals("java.util.Calendar", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.ArrayList<java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] }
public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals("java.util.Calendar", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.ArrayList<java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] }
public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals("java.util.Calendar", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.ArrayList<java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] }
public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals("java.util.Calendar", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.ArrayList<java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] }
public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals("java.util.Calendar", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.ArrayList<java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] }
public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals("java.util.Calendar", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.ArrayList<java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] }
public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals("java.util.Calendar", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.ArrayList<java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] }
public void testBytestoCharArray() throws Exception { [EOL]     byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 }; [EOL]     char[] expEncoded = MAPPER.convertValue(input, String.class).toCharArray(); [EOL]     char[] actEncoded = MAPPER.convertValue(input, char[].class); [EOL]     assertArrayEquals(expEncoded, actEncoded); [EOL] }
public void testBytestoCharArray() throws Exception { [EOL]     byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 }; [EOL]     char[] expEncoded = MAPPER.convertValue(input, String.class).toCharArray(); [EOL]     char[] actEncoded = MAPPER.convertValue(input, char[].class); [EOL]     assertArrayEquals(expEncoded, actEncoded); [EOL] }
public void testBytestoCharArray() throws Exception { [EOL]     byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 }; [EOL]     char[] expEncoded = MAPPER.convertValue(input, String.class).toCharArray(); [EOL]     char[] actEncoded = MAPPER.convertValue(input, char[].class); [EOL]     assertArrayEquals(expEncoded, actEncoded); [EOL] }
public void testBytestoCharArray() throws Exception { [EOL]     byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 }; [EOL]     char[] expEncoded = MAPPER.convertValue(input, String.class).toCharArray(); [EOL]     char[] actEncoded = MAPPER.convertValue(input, char[].class); [EOL]     assertArrayEquals(expEncoded, actEncoded); [EOL] }
public void testBytestoCharArray() throws Exception { [EOL]     byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 }; [EOL]     char[] expEncoded = MAPPER.convertValue(input, String.class).toCharArray(); [EOL]     char[] actEncoded = MAPPER.convertValue(input, char[].class); [EOL]     assertArrayEquals(expEncoded, actEncoded); [EOL] }
public void testIssue506WithNumber() throws Exception { [EOL]     Issue506NumberBean input = new Issue506NumberBean(); [EOL]     input.number = Long.valueOf(4567L); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(input); [EOL]     Issue506NumberBean output = mapper.readValue(json, Issue506NumberBean.class); [EOL]     assertEquals(input.number, output.number); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testTypeIdFromArray() throws Exception { [EOL]     assertEquals("[\"SomeType\",{\"a\":3}]", mapper.writeValueAsString(new TypeIdFromFieldArray())); [EOL] }
public void testTypeIdFromArray() throws Exception { [EOL]     assertEquals("[\"SomeType\",{\"a\":3}]", mapper.writeValueAsString(new TypeIdFromFieldArray())); [EOL] }
public void testAbstract368() throws Exception { [EOL]     AbstractNode parent = new ConcreteNode("p"); [EOL]     AbstractNode child = new ConcreteNode("c"); [EOL]     parent.next = child; [EOL]     child.prev = parent; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(parent); [EOL]     AbstractNode root = mapper.readValue(json, AbstractNode.class); [EOL]     assertEquals(ConcreteNode.class, root.getClass()); [EOL]     assertEquals("p", root.id); [EOL]     assertNull(root.prev); [EOL]     AbstractNode leaf = root.next; [EOL]     assertNotNull(leaf); [EOL]     assertEquals("c", leaf.id); [EOL]     assertSame(root, leaf.prev); [EOL] }
public void testAbstract368() throws Exception { [EOL]     AbstractNode parent = new ConcreteNode("p"); [EOL]     AbstractNode child = new ConcreteNode("c"); [EOL]     parent.next = child; [EOL]     child.prev = parent; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(parent); [EOL]     AbstractNode root = mapper.readValue(json, AbstractNode.class); [EOL]     assertEquals(ConcreteNode.class, root.getClass()); [EOL]     assertEquals("p", root.id); [EOL]     assertNull(root.prev); [EOL]     AbstractNode leaf = root.next; [EOL]     assertNotNull(leaf); [EOL]     assertEquals("c", leaf.id); [EOL]     assertSame(root, leaf.prev); [EOL] }
public void testAbstract368() throws Exception { [EOL]     AbstractNode parent = new ConcreteNode("p"); [EOL]     AbstractNode child = new ConcreteNode("c"); [EOL]     parent.next = child; [EOL]     child.prev = parent; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(parent); [EOL]     AbstractNode root = mapper.readValue(json, AbstractNode.class); [EOL]     assertEquals(ConcreteNode.class, root.getClass()); [EOL]     assertEquals("p", root.id); [EOL]     assertNull(root.prev); [EOL]     AbstractNode leaf = root.next; [EOL]     assertNotNull(leaf); [EOL]     assertEquals("c", leaf.id); [EOL]     assertSame(root, leaf.prev); [EOL] }
public void testAbstract368() throws Exception { [EOL]     AbstractNode parent = new ConcreteNode("p"); [EOL]     AbstractNode child = new ConcreteNode("c"); [EOL]     parent.next = child; [EOL]     child.prev = parent; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(parent); [EOL]     AbstractNode root = mapper.readValue(json, AbstractNode.class); [EOL]     assertEquals(ConcreteNode.class, root.getClass()); [EOL]     assertEquals("p", root.id); [EOL]     assertNull(root.prev); [EOL]     AbstractNode leaf = root.next; [EOL]     assertNotNull(leaf); [EOL]     assertEquals("c", leaf.id); [EOL]     assertSame(root, leaf.prev); [EOL] }
public void testAbstract368() throws Exception { [EOL]     AbstractNode parent = new ConcreteNode("p"); [EOL]     AbstractNode child = new ConcreteNode("c"); [EOL]     parent.next = child; [EOL]     child.prev = parent; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(parent); [EOL]     AbstractNode root = mapper.readValue(json, AbstractNode.class); [EOL]     assertEquals(ConcreteNode.class, root.getClass()); [EOL]     assertEquals("p", root.id); [EOL]     assertNull(root.prev); [EOL]     AbstractNode leaf = root.next; [EOL]     assertNotNull(leaf); [EOL]     assertEquals("c", leaf.id); [EOL]     assertSame(root, leaf.prev); [EOL] }
public void testAbstract368() throws Exception { [EOL]     AbstractNode parent = new ConcreteNode("p"); [EOL]     AbstractNode child = new ConcreteNode("c"); [EOL]     parent.next = child; [EOL]     child.prev = parent; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(parent); [EOL]     AbstractNode root = mapper.readValue(json, AbstractNode.class); [EOL]     assertEquals(ConcreteNode.class, root.getClass()); [EOL]     assertEquals("p", root.id); [EOL]     assertNull(root.prev); [EOL]     AbstractNode leaf = root.next; [EOL]     assertNotNull(leaf); [EOL]     assertEquals("c", leaf.id); [EOL]     assertSame(root, leaf.prev); [EOL] }
public void testAbstract368() throws Exception { [EOL]     AbstractNode parent = new ConcreteNode("p"); [EOL]     AbstractNode child = new ConcreteNode("c"); [EOL]     parent.next = child; [EOL]     child.prev = parent; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(parent); [EOL]     AbstractNode root = mapper.readValue(json, AbstractNode.class); [EOL]     assertEquals(ConcreteNode.class, root.getClass()); [EOL]     assertEquals("p", root.id); [EOL]     assertNull(root.prev); [EOL]     AbstractNode leaf = root.next; [EOL]     assertNotNull(leaf); [EOL]     assertEquals("c", leaf.id); [EOL]     assertSame(root, leaf.prev); [EOL] }
public void testAbstract368() throws Exception { [EOL]     AbstractNode parent = new ConcreteNode("p"); [EOL]     AbstractNode child = new ConcreteNode("c"); [EOL]     parent.next = child; [EOL]     child.prev = parent; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(parent); [EOL]     AbstractNode root = mapper.readValue(json, AbstractNode.class); [EOL]     assertEquals(ConcreteNode.class, root.getClass()); [EOL]     assertEquals("p", root.id); [EOL]     assertNull(root.prev); [EOL]     AbstractNode leaf = root.next; [EOL]     assertNotNull(leaf); [EOL]     assertEquals("c", leaf.id); [EOL]     assertSame(root, leaf.prev); [EOL] }
public void testAbstract368() throws Exception { [EOL]     AbstractNode parent = new ConcreteNode("p"); [EOL]     AbstractNode child = new ConcreteNode("c"); [EOL]     parent.next = child; [EOL]     child.prev = parent; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(parent); [EOL]     AbstractNode root = mapper.readValue(json, AbstractNode.class); [EOL]     assertEquals(ConcreteNode.class, root.getClass()); [EOL]     assertEquals("p", root.id); [EOL]     assertNull(root.prev); [EOL]     AbstractNode leaf = root.next; [EOL]     assertNotNull(leaf); [EOL]     assertEquals("c", leaf.id); [EOL]     assertSame(root, leaf.prev); [EOL] }
public void testAbstract368() throws Exception { [EOL]     AbstractNode parent = new ConcreteNode("p"); [EOL]     AbstractNode child = new ConcreteNode("c"); [EOL]     parent.next = child; [EOL]     child.prev = parent; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(parent); [EOL]     AbstractNode root = mapper.readValue(json, AbstractNode.class); [EOL]     assertEquals(ConcreteNode.class, root.getClass()); [EOL]     assertEquals("p", root.id); [EOL]     assertNull(root.prev); [EOL]     AbstractNode leaf = root.next; [EOL]     assertNotNull(leaf); [EOL]     assertEquals("c", leaf.id); [EOL]     assertSame(root, leaf.prev); [EOL] }
public void testAbstract368() throws Exception { [EOL]     AbstractNode parent = new ConcreteNode("p"); [EOL]     AbstractNode child = new ConcreteNode("c"); [EOL]     parent.next = child; [EOL]     child.prev = parent; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(parent); [EOL]     AbstractNode root = mapper.readValue(json, AbstractNode.class); [EOL]     assertEquals(ConcreteNode.class, root.getClass()); [EOL]     assertEquals("p", root.id); [EOL]     assertNull(root.prev); [EOL]     AbstractNode leaf = root.next; [EOL]     assertNotNull(leaf); [EOL]     assertEquals("c", leaf.id); [EOL]     assertSame(root, leaf.prev); [EOL] }
public void testAbstract368() throws Exception { [EOL]     AbstractNode parent = new ConcreteNode("p"); [EOL]     AbstractNode child = new ConcreteNode("c"); [EOL]     parent.next = child; [EOL]     child.prev = parent; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(parent); [EOL]     AbstractNode root = mapper.readValue(json, AbstractNode.class); [EOL]     assertEquals(ConcreteNode.class, root.getClass()); [EOL]     assertEquals("p", root.id); [EOL]     assertNull(root.prev); [EOL]     AbstractNode leaf = root.next; [EOL]     assertNotNull(leaf); [EOL]     assertEquals("c", leaf.id); [EOL]     assertSame(root, leaf.prev); [EOL] }
public void testAbstract368() throws Exception { [EOL]     AbstractNode parent = new ConcreteNode("p"); [EOL]     AbstractNode child = new ConcreteNode("c"); [EOL]     parent.next = child; [EOL]     child.prev = parent; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(parent); [EOL]     AbstractNode root = mapper.readValue(json, AbstractNode.class); [EOL]     assertEquals(ConcreteNode.class, root.getClass()); [EOL]     assertEquals("p", root.id); [EOL]     assertNull(root.prev); [EOL]     AbstractNode leaf = root.next; [EOL]     assertNotNull(leaf); [EOL]     assertEquals("c", leaf.id); [EOL]     assertSame(root, leaf.prev); [EOL] }
public void testAbstract368() throws Exception { [EOL]     AbstractNode parent = new ConcreteNode("p"); [EOL]     AbstractNode child = new ConcreteNode("c"); [EOL]     parent.next = child; [EOL]     child.prev = parent; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(parent); [EOL]     AbstractNode root = mapper.readValue(json, AbstractNode.class); [EOL]     assertEquals(ConcreteNode.class, root.getClass()); [EOL]     assertEquals("p", root.id); [EOL]     assertNull(root.prev); [EOL]     AbstractNode leaf = root.next; [EOL]     assertNotNull(leaf); [EOL]     assertEquals("c", leaf.id); [EOL]     assertSame(root, leaf.prev); [EOL] }
public void testAbstract368() throws Exception { [EOL]     AbstractNode parent = new ConcreteNode("p"); [EOL]     AbstractNode child = new ConcreteNode("c"); [EOL]     parent.next = child; [EOL]     child.prev = parent; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(parent); [EOL]     AbstractNode root = mapper.readValue(json, AbstractNode.class); [EOL]     assertEquals(ConcreteNode.class, root.getClass()); [EOL]     assertEquals("p", root.id); [EOL]     assertNull(root.prev); [EOL]     AbstractNode leaf = root.next; [EOL]     assertNotNull(leaf); [EOL]     assertEquals("c", leaf.id); [EOL]     assertSame(root, leaf.prev); [EOL] }
public void testPropertyReorder() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new ModuleImpl(new ReorderingModifier())); [EOL]     Bean bean = new Bean(); [EOL]     assertEquals("{\"a\":\"a\",\"b\":\"b\"}", mapper.writeValueAsString(bean)); [EOL] }
public void testPropertyReorder() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new ModuleImpl(new ReorderingModifier())); [EOL]     Bean bean = new Bean(); [EOL]     assertEquals("{\"a\":\"a\",\"b\":\"b\"}", mapper.writeValueAsString(bean)); [EOL] }
public void testEmptyWithAnnotations() throws Exception { [EOL]     try { [EOL]         serializeAsString(mapper, new Empty()); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "No serializer found for class"); [EOL]     } [EOL]     assertEquals("{}", serializeAsString(mapper, new EmptyWithAnno())); [EOL]     ObjectMapper m2 = new ObjectMapper(); [EOL]     m2.addMixInAnnotations(Empty.class, EmptyWithAnno.class); [EOL]     assertEquals("{}", m2.writeValueAsString(new Empty())); [EOL] }
public void testEmptyWithAnnotations() throws Exception { [EOL]     try { [EOL]         serializeAsString(mapper, new Empty()); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "No serializer found for class"); [EOL]     } [EOL]     assertEquals("{}", serializeAsString(mapper, new EmptyWithAnno())); [EOL]     ObjectMapper m2 = new ObjectMapper(); [EOL]     m2.addMixInAnnotations(Empty.class, EmptyWithAnno.class); [EOL]     assertEquals("{}", m2.writeValueAsString(new Empty())); [EOL] }
public void testDeepUnwrappingSerialize() throws Exception { [EOL]     assertEquals("{\"name\":\"Tatu\",\"x\":1,\"y\":2}", mapper.writeValueAsString(new DeepUnwrapping("Tatu", 1, 2))); [EOL] }
public void testDeepUnwrappingSerialize() throws Exception { [EOL]     assertEquals("{\"name\":\"Tatu\",\"x\":1,\"y\":2}", mapper.writeValueAsString(new DeepUnwrapping("Tatu", 1, 2))); [EOL] }
public void testPropertyReorder() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new ModuleImpl(new ReorderingModifier())); [EOL]     Bean bean = new Bean(); [EOL]     assertEquals("{\"a\":\"a\",\"b\":\"b\"}", mapper.writeValueAsString(bean)); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = "{ \"petType\": \"dog\",\n" + "\"pet\": { \"name\": \"Pluto\" }\n}"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals("dog", result.petType); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = "{ \"petType\": \"dog\",\n" + "\"pet\": { \"name\": \"Pluto\" }\n}"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals("dog", result.petType); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = "{ \"petType\": \"dog\",\n" + "\"pet\": { \"name\": \"Pluto\" }\n}"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals("dog", result.petType); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = "{ \"petType\": \"dog\",\n" + "\"pet\": { \"name\": \"Pluto\" }\n}"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals("dog", result.petType); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testNullForPrimitives() throws IOException { [EOL]     PrimitivesBean bean = mapper.readValue("{\"intValue\":null, \"booleanValue\":null, \"doubleValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals(0, bean.intValue); [EOL]     assertEquals(false, bean.booleanValue); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL]     bean = mapper.readValue("{\"byteValue\":null, \"longValue\":null, \"floatValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     assertEquals(0L, bean.longValue); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     final ObjectMapper mapper2 = new ObjectMapper(); [EOL]     mapper2.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true); [EOL]     try { [EOL]         mapper2.readValue("{\"booleanValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for boolean + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type boolean"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"byteValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for byte + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type byte"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"charValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for char + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type char"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"shortValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for short + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type short"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"intValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for int + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type int"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"longValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for long + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type long"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"floatValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for float + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type float"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"doubleValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for double + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type double"); [EOL]     } [EOL] }
public void testNullForPrimitives() throws IOException { [EOL]     PrimitivesBean bean = mapper.readValue("{\"intValue\":null, \"booleanValue\":null, \"doubleValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals(0, bean.intValue); [EOL]     assertEquals(false, bean.booleanValue); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL]     bean = mapper.readValue("{\"byteValue\":null, \"longValue\":null, \"floatValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     assertEquals(0L, bean.longValue); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     final ObjectMapper mapper2 = new ObjectMapper(); [EOL]     mapper2.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true); [EOL]     try { [EOL]         mapper2.readValue("{\"booleanValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for boolean + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type boolean"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"byteValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for byte + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type byte"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"charValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for char + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type char"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"shortValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for short + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type short"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"intValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for int + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type int"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"longValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for long + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type long"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"floatValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for float + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type float"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"doubleValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for double + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type double"); [EOL]     } [EOL] }
public void testNullForPrimitives() throws IOException { [EOL]     PrimitivesBean bean = mapper.readValue("{\"intValue\":null, \"booleanValue\":null, \"doubleValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals(0, bean.intValue); [EOL]     assertEquals(false, bean.booleanValue); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL]     bean = mapper.readValue("{\"byteValue\":null, \"longValue\":null, \"floatValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     assertEquals(0L, bean.longValue); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     final ObjectMapper mapper2 = new ObjectMapper(); [EOL]     mapper2.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true); [EOL]     try { [EOL]         mapper2.readValue("{\"booleanValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for boolean + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type boolean"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"byteValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for byte + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type byte"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"charValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for char + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type char"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"shortValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for short + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type short"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"intValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for int + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type int"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"longValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for long + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type long"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"floatValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for float + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type float"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"doubleValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for double + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type double"); [EOL]     } [EOL] }
public void testGeneratingJsonSchema() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class); [EOL]     assertNotNull(jsonSchema); [EOL]     assertTrue(jsonSchema.equals(jsonSchema)); [EOL]     assertFalse(jsonSchema.equals(null)); [EOL]     assertFalse(jsonSchema.equals("foo")); [EOL]     assertNotNull(jsonSchema.toString()); [EOL]     assertNotNull(JsonSchema.getDefaultSchemaNode()); [EOL]     ObjectNode root = jsonSchema.getSchemaNode(); [EOL]     assertEquals("object", root.get("type").asText()); [EOL]     assertEquals(false, root.path("required").booleanValue()); [EOL]     JsonNode propertiesSchema = root.get("properties"); [EOL]     assertNotNull(propertiesSchema); [EOL]     JsonNode property1Schema = propertiesSchema.get("property1"); [EOL]     assertNotNull(property1Schema); [EOL]     assertEquals("integer", property1Schema.get("type").asText()); [EOL]     assertEquals(false, property1Schema.path("required").booleanValue()); [EOL]     JsonNode property2Schema = propertiesSchema.get("property2"); [EOL]     assertNotNull(property2Schema); [EOL]     assertEquals("string", property2Schema.get("type").asText()); [EOL]     assertEquals(false, property2Schema.path("required").booleanValue()); [EOL]     JsonNode property3Schema = propertiesSchema.get("property3"); [EOL]     assertNotNull(property3Schema); [EOL]     assertEquals("array", property3Schema.get("type").asText()); [EOL]     assertEquals(false, property3Schema.path("required").booleanValue()); [EOL]     assertEquals("string", property3Schema.get("items").get("type").asText()); [EOL]     JsonNode property4Schema = propertiesSchema.get("property4"); [EOL]     assertNotNull(property4Schema); [EOL]     assertEquals("array", property4Schema.get("type").asText()); [EOL]     assertEquals(false, property4Schema.path("required").booleanValue()); [EOL]     assertEquals("number", property4Schema.get("items").get("type").asText()); [EOL] }
public void testMatchingSingle() throws Exception { [EOL]     JsonNode root = _buildTree(); [EOL]     JsonNode node = root.findValue("b"); [EOL]     assertNotNull(node); [EOL]     assertEquals(3, node.intValue()); [EOL]     node = root.findParent("b"); [EOL]     assertNotNull(node); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, ((ObjectNode) node).size()); [EOL]     assertEquals(3, node.path("b").intValue()); [EOL] }
public void testMatchingSingle() throws Exception { [EOL]     JsonNode root = _buildTree(); [EOL]     JsonNode node = root.findValue("b"); [EOL]     assertNotNull(node); [EOL]     assertEquals(3, node.intValue()); [EOL]     node = root.findParent("b"); [EOL]     assertNotNull(node); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, ((ObjectNode) node).size()); [EOL]     assertEquals(3, node.path("b").intValue()); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = "{ \"petType\": \"dog\",\n" + "\"pet\": { \"name\": \"Pluto\" }\n}"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals("dog", result.petType); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = "{ \"petType\": \"dog\",\n" + "\"pet\": { \"name\": \"Pluto\" }\n}"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals("dog", result.petType); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = "{ \"petType\": \"dog\",\n" + "\"pet\": { \"name\": \"Pluto\" }\n}"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals("dog", result.petType); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = "{ \"petType\": \"dog\",\n" + "\"pet\": { \"name\": \"Pluto\" }\n}"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals("dog", result.petType); [EOL] }
public void testArrayTypingNested() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(DefaultTyping.NON_CONCRETE_AND_ARRAYS); [EOL]     ArrayBean bean = new ArrayBean(new String[0][0]); [EOL]     String json = m.writeValueAsString(bean); [EOL]     ArrayBean result = m.readValue(json, ArrayBean.class); [EOL]     assertNotNull(result.values); [EOL]     assertEquals(String[][].class, result.values.getClass()); [EOL] }
public void testArrayTypingNested() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(DefaultTyping.NON_CONCRETE_AND_ARRAYS); [EOL]     ArrayBean bean = new ArrayBean(new String[0][0]); [EOL]     String json = m.writeValueAsString(bean); [EOL]     ArrayBean result = m.readValue(json, ArrayBean.class); [EOL]     assertNotNull(result.values); [EOL]     assertEquals(String[][].class, result.values.getClass()); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testComplexObject() throws Exception { [EOL]     FixtureObject aTestObj = new FixtureObject(); [EOL]     ObjectMapper aMapper = new ObjectMapper(); [EOL]     StringWriter aWriter = new StringWriter(); [EOL]     JsonGenerator aGen = new JsonFactory().createGenerator(aWriter); [EOL]     aMapper.writeValue(aGen, aTestObj); [EOL]     aGen.close(); [EOL]     JsonParser jp = new JsonFactory().createParser(new StringReader(aWriter.toString())); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         assertEquals(JsonToken.FIELD_NAME, jp.getCurrentToken()); [EOL]         String name = jp.getCurrentName(); [EOL]         JsonToken t = jp.nextToken(); [EOL]         if (name.equals("uri")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("url")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testNull")) { [EOL]             assertToken(JsonToken.VALUE_NULL, t); [EOL]         } else if (name.equals("testString")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testBoolean")) { [EOL]             assertToken(JsonToken.VALUE_TRUE, t); [EOL]         } else if (name.equals("testEnum")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_ENUM.toString(), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_INT); [EOL]         } else if (name.equals("testLong")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_LONG); [EOL]         } else if (name.equals("testBigInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_BIGINT.longValue()); [EOL]         } else if (name.equals("testBigDecimal")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getText(), FixtureObject.VALUE_BIGDEC.toString()); [EOL]         } else if (name.equals("testCharacter")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(String.valueOf(FixtureObject.VALUE_CHAR), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testShort")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_SHORT); [EOL]         } else if (name.equals("testByte")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_BYTE); [EOL]         } else if (name.equals("testFloat")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDecimalValue().floatValue(), FixtureObject.VALUE_FLOAT); [EOL]         } else if (name.equals("testDouble")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDoubleValue(), FixtureObject.VALUE_DBL); [EOL]         } else if (name.equals("testStringBuffer")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testError")) { [EOL]             assertToken(JsonToken.START_OBJECT, t); [EOL]             while (jp.nextToken() == JsonToken.FIELD_NAME) { [EOL]                 name = jp.getCurrentName(); [EOL]                 if (name.equals("cause")) { [EOL]                     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]                 } else if (name.equals("message")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                     assertEquals(FixtureObject.VALUE_ERRTXT, getAndVerifyText(jp)); [EOL]                 } else if (name.equals("localizedMessage")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                 } else if (name.equals("stackTrace")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     int i = 0; [EOL]                     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                         if (i >= 100000) { [EOL]                             assertTrue("Probably run away loop in test. StackTrack Array was not properly closed.", false); [EOL]                         } [EOL]                     } [EOL]                 } else if (name.equals("suppressed")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]                 } else { [EOL]                     fail("Unexpected field name '" + name + "'"); [EOL]                 } [EOL]             } [EOL]             assertEquals(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]         } else { [EOL]             fail("Unexpected field, name '" + name + "'"); [EOL]         } [EOL]     } [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testComplexObject() throws Exception { [EOL]     FixtureObject aTestObj = new FixtureObject(); [EOL]     ObjectMapper aMapper = new ObjectMapper(); [EOL]     StringWriter aWriter = new StringWriter(); [EOL]     JsonGenerator aGen = new JsonFactory().createGenerator(aWriter); [EOL]     aMapper.writeValue(aGen, aTestObj); [EOL]     aGen.close(); [EOL]     JsonParser jp = new JsonFactory().createParser(new StringReader(aWriter.toString())); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         assertEquals(JsonToken.FIELD_NAME, jp.getCurrentToken()); [EOL]         String name = jp.getCurrentName(); [EOL]         JsonToken t = jp.nextToken(); [EOL]         if (name.equals("uri")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("url")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testNull")) { [EOL]             assertToken(JsonToken.VALUE_NULL, t); [EOL]         } else if (name.equals("testString")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testBoolean")) { [EOL]             assertToken(JsonToken.VALUE_TRUE, t); [EOL]         } else if (name.equals("testEnum")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_ENUM.toString(), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_INT); [EOL]         } else if (name.equals("testLong")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_LONG); [EOL]         } else if (name.equals("testBigInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_BIGINT.longValue()); [EOL]         } else if (name.equals("testBigDecimal")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getText(), FixtureObject.VALUE_BIGDEC.toString()); [EOL]         } else if (name.equals("testCharacter")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(String.valueOf(FixtureObject.VALUE_CHAR), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testShort")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_SHORT); [EOL]         } else if (name.equals("testByte")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_BYTE); [EOL]         } else if (name.equals("testFloat")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDecimalValue().floatValue(), FixtureObject.VALUE_FLOAT); [EOL]         } else if (name.equals("testDouble")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDoubleValue(), FixtureObject.VALUE_DBL); [EOL]         } else if (name.equals("testStringBuffer")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testError")) { [EOL]             assertToken(JsonToken.START_OBJECT, t); [EOL]             while (jp.nextToken() == JsonToken.FIELD_NAME) { [EOL]                 name = jp.getCurrentName(); [EOL]                 if (name.equals("cause")) { [EOL]                     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]                 } else if (name.equals("message")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                     assertEquals(FixtureObject.VALUE_ERRTXT, getAndVerifyText(jp)); [EOL]                 } else if (name.equals("localizedMessage")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                 } else if (name.equals("stackTrace")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     int i = 0; [EOL]                     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                         if (i >= 100000) { [EOL]                             assertTrue("Probably run away loop in test. StackTrack Array was not properly closed.", false); [EOL]                         } [EOL]                     } [EOL]                 } else if (name.equals("suppressed")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]                 } else { [EOL]                     fail("Unexpected field name '" + name + "'"); [EOL]                 } [EOL]             } [EOL]             assertEquals(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]         } else { [EOL]             fail("Unexpected field, name '" + name + "'"); [EOL]         } [EOL]     } [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testComplexObject() throws Exception { [EOL]     FixtureObject aTestObj = new FixtureObject(); [EOL]     ObjectMapper aMapper = new ObjectMapper(); [EOL]     StringWriter aWriter = new StringWriter(); [EOL]     JsonGenerator aGen = new JsonFactory().createGenerator(aWriter); [EOL]     aMapper.writeValue(aGen, aTestObj); [EOL]     aGen.close(); [EOL]     JsonParser jp = new JsonFactory().createParser(new StringReader(aWriter.toString())); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         assertEquals(JsonToken.FIELD_NAME, jp.getCurrentToken()); [EOL]         String name = jp.getCurrentName(); [EOL]         JsonToken t = jp.nextToken(); [EOL]         if (name.equals("uri")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("url")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testNull")) { [EOL]             assertToken(JsonToken.VALUE_NULL, t); [EOL]         } else if (name.equals("testString")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testBoolean")) { [EOL]             assertToken(JsonToken.VALUE_TRUE, t); [EOL]         } else if (name.equals("testEnum")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_ENUM.toString(), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_INT); [EOL]         } else if (name.equals("testLong")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_LONG); [EOL]         } else if (name.equals("testBigInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_BIGINT.longValue()); [EOL]         } else if (name.equals("testBigDecimal")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getText(), FixtureObject.VALUE_BIGDEC.toString()); [EOL]         } else if (name.equals("testCharacter")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(String.valueOf(FixtureObject.VALUE_CHAR), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testShort")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_SHORT); [EOL]         } else if (name.equals("testByte")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_BYTE); [EOL]         } else if (name.equals("testFloat")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDecimalValue().floatValue(), FixtureObject.VALUE_FLOAT); [EOL]         } else if (name.equals("testDouble")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDoubleValue(), FixtureObject.VALUE_DBL); [EOL]         } else if (name.equals("testStringBuffer")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testError")) { [EOL]             assertToken(JsonToken.START_OBJECT, t); [EOL]             while (jp.nextToken() == JsonToken.FIELD_NAME) { [EOL]                 name = jp.getCurrentName(); [EOL]                 if (name.equals("cause")) { [EOL]                     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]                 } else if (name.equals("message")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                     assertEquals(FixtureObject.VALUE_ERRTXT, getAndVerifyText(jp)); [EOL]                 } else if (name.equals("localizedMessage")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                 } else if (name.equals("stackTrace")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     int i = 0; [EOL]                     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                         if (i >= 100000) { [EOL]                             assertTrue("Probably run away loop in test. StackTrack Array was not properly closed.", false); [EOL]                         } [EOL]                     } [EOL]                 } else if (name.equals("suppressed")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]                 } else { [EOL]                     fail("Unexpected field name '" + name + "'"); [EOL]                 } [EOL]             } [EOL]             assertEquals(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]         } else { [EOL]             fail("Unexpected field, name '" + name + "'"); [EOL]         } [EOL]     } [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testComplexObject() throws Exception { [EOL]     FixtureObject aTestObj = new FixtureObject(); [EOL]     ObjectMapper aMapper = new ObjectMapper(); [EOL]     StringWriter aWriter = new StringWriter(); [EOL]     JsonGenerator aGen = new JsonFactory().createGenerator(aWriter); [EOL]     aMapper.writeValue(aGen, aTestObj); [EOL]     aGen.close(); [EOL]     JsonParser jp = new JsonFactory().createParser(new StringReader(aWriter.toString())); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         assertEquals(JsonToken.FIELD_NAME, jp.getCurrentToken()); [EOL]         String name = jp.getCurrentName(); [EOL]         JsonToken t = jp.nextToken(); [EOL]         if (name.equals("uri")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("url")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testNull")) { [EOL]             assertToken(JsonToken.VALUE_NULL, t); [EOL]         } else if (name.equals("testString")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testBoolean")) { [EOL]             assertToken(JsonToken.VALUE_TRUE, t); [EOL]         } else if (name.equals("testEnum")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_ENUM.toString(), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_INT); [EOL]         } else if (name.equals("testLong")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_LONG); [EOL]         } else if (name.equals("testBigInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_BIGINT.longValue()); [EOL]         } else if (name.equals("testBigDecimal")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getText(), FixtureObject.VALUE_BIGDEC.toString()); [EOL]         } else if (name.equals("testCharacter")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(String.valueOf(FixtureObject.VALUE_CHAR), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testShort")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_SHORT); [EOL]         } else if (name.equals("testByte")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_BYTE); [EOL]         } else if (name.equals("testFloat")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDecimalValue().floatValue(), FixtureObject.VALUE_FLOAT); [EOL]         } else if (name.equals("testDouble")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDoubleValue(), FixtureObject.VALUE_DBL); [EOL]         } else if (name.equals("testStringBuffer")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testError")) { [EOL]             assertToken(JsonToken.START_OBJECT, t); [EOL]             while (jp.nextToken() == JsonToken.FIELD_NAME) { [EOL]                 name = jp.getCurrentName(); [EOL]                 if (name.equals("cause")) { [EOL]                     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]                 } else if (name.equals("message")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                     assertEquals(FixtureObject.VALUE_ERRTXT, getAndVerifyText(jp)); [EOL]                 } else if (name.equals("localizedMessage")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                 } else if (name.equals("stackTrace")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     int i = 0; [EOL]                     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                         if (i >= 100000) { [EOL]                             assertTrue("Probably run away loop in test. StackTrack Array was not properly closed.", false); [EOL]                         } [EOL]                     } [EOL]                 } else if (name.equals("suppressed")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]                 } else { [EOL]                     fail("Unexpected field name '" + name + "'"); [EOL]                 } [EOL]             } [EOL]             assertEquals(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]         } else { [EOL]             fail("Unexpected field, name '" + name + "'"); [EOL]         } [EOL]     } [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testComplexObject() throws Exception { [EOL]     FixtureObject aTestObj = new FixtureObject(); [EOL]     ObjectMapper aMapper = new ObjectMapper(); [EOL]     StringWriter aWriter = new StringWriter(); [EOL]     JsonGenerator aGen = new JsonFactory().createGenerator(aWriter); [EOL]     aMapper.writeValue(aGen, aTestObj); [EOL]     aGen.close(); [EOL]     JsonParser jp = new JsonFactory().createParser(new StringReader(aWriter.toString())); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         assertEquals(JsonToken.FIELD_NAME, jp.getCurrentToken()); [EOL]         String name = jp.getCurrentName(); [EOL]         JsonToken t = jp.nextToken(); [EOL]         if (name.equals("uri")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("url")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testNull")) { [EOL]             assertToken(JsonToken.VALUE_NULL, t); [EOL]         } else if (name.equals("testString")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testBoolean")) { [EOL]             assertToken(JsonToken.VALUE_TRUE, t); [EOL]         } else if (name.equals("testEnum")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_ENUM.toString(), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_INT); [EOL]         } else if (name.equals("testLong")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_LONG); [EOL]         } else if (name.equals("testBigInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_BIGINT.longValue()); [EOL]         } else if (name.equals("testBigDecimal")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getText(), FixtureObject.VALUE_BIGDEC.toString()); [EOL]         } else if (name.equals("testCharacter")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(String.valueOf(FixtureObject.VALUE_CHAR), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testShort")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_SHORT); [EOL]         } else if (name.equals("testByte")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_BYTE); [EOL]         } else if (name.equals("testFloat")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDecimalValue().floatValue(), FixtureObject.VALUE_FLOAT); [EOL]         } else if (name.equals("testDouble")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDoubleValue(), FixtureObject.VALUE_DBL); [EOL]         } else if (name.equals("testStringBuffer")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testError")) { [EOL]             assertToken(JsonToken.START_OBJECT, t); [EOL]             while (jp.nextToken() == JsonToken.FIELD_NAME) { [EOL]                 name = jp.getCurrentName(); [EOL]                 if (name.equals("cause")) { [EOL]                     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]                 } else if (name.equals("message")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                     assertEquals(FixtureObject.VALUE_ERRTXT, getAndVerifyText(jp)); [EOL]                 } else if (name.equals("localizedMessage")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                 } else if (name.equals("stackTrace")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     int i = 0; [EOL]                     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                         if (i >= 100000) { [EOL]                             assertTrue("Probably run away loop in test. StackTrack Array was not properly closed.", false); [EOL]                         } [EOL]                     } [EOL]                 } else if (name.equals("suppressed")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]                 } else { [EOL]                     fail("Unexpected field name '" + name + "'"); [EOL]                 } [EOL]             } [EOL]             assertEquals(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]         } else { [EOL]             fail("Unexpected field, name '" + name + "'"); [EOL]         } [EOL]     } [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testComplexObject() throws Exception { [EOL]     FixtureObject aTestObj = new FixtureObject(); [EOL]     ObjectMapper aMapper = new ObjectMapper(); [EOL]     StringWriter aWriter = new StringWriter(); [EOL]     JsonGenerator aGen = new JsonFactory().createGenerator(aWriter); [EOL]     aMapper.writeValue(aGen, aTestObj); [EOL]     aGen.close(); [EOL]     JsonParser jp = new JsonFactory().createParser(new StringReader(aWriter.toString())); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         assertEquals(JsonToken.FIELD_NAME, jp.getCurrentToken()); [EOL]         String name = jp.getCurrentName(); [EOL]         JsonToken t = jp.nextToken(); [EOL]         if (name.equals("uri")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("url")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testNull")) { [EOL]             assertToken(JsonToken.VALUE_NULL, t); [EOL]         } else if (name.equals("testString")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testBoolean")) { [EOL]             assertToken(JsonToken.VALUE_TRUE, t); [EOL]         } else if (name.equals("testEnum")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_ENUM.toString(), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_INT); [EOL]         } else if (name.equals("testLong")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_LONG); [EOL]         } else if (name.equals("testBigInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_BIGINT.longValue()); [EOL]         } else if (name.equals("testBigDecimal")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getText(), FixtureObject.VALUE_BIGDEC.toString()); [EOL]         } else if (name.equals("testCharacter")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(String.valueOf(FixtureObject.VALUE_CHAR), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testShort")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_SHORT); [EOL]         } else if (name.equals("testByte")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_BYTE); [EOL]         } else if (name.equals("testFloat")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDecimalValue().floatValue(), FixtureObject.VALUE_FLOAT); [EOL]         } else if (name.equals("testDouble")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDoubleValue(), FixtureObject.VALUE_DBL); [EOL]         } else if (name.equals("testStringBuffer")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testError")) { [EOL]             assertToken(JsonToken.START_OBJECT, t); [EOL]             while (jp.nextToken() == JsonToken.FIELD_NAME) { [EOL]                 name = jp.getCurrentName(); [EOL]                 if (name.equals("cause")) { [EOL]                     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]                 } else if (name.equals("message")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                     assertEquals(FixtureObject.VALUE_ERRTXT, getAndVerifyText(jp)); [EOL]                 } else if (name.equals("localizedMessage")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                 } else if (name.equals("stackTrace")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     int i = 0; [EOL]                     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                         if (i >= 100000) { [EOL]                             assertTrue("Probably run away loop in test. StackTrack Array was not properly closed.", false); [EOL]                         } [EOL]                     } [EOL]                 } else if (name.equals("suppressed")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]                 } else { [EOL]                     fail("Unexpected field name '" + name + "'"); [EOL]                 } [EOL]             } [EOL]             assertEquals(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]         } else { [EOL]             fail("Unexpected field, name '" + name + "'"); [EOL]         } [EOL]     } [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testComplexObject() throws Exception { [EOL]     FixtureObject aTestObj = new FixtureObject(); [EOL]     ObjectMapper aMapper = new ObjectMapper(); [EOL]     StringWriter aWriter = new StringWriter(); [EOL]     JsonGenerator aGen = new JsonFactory().createGenerator(aWriter); [EOL]     aMapper.writeValue(aGen, aTestObj); [EOL]     aGen.close(); [EOL]     JsonParser jp = new JsonFactory().createParser(new StringReader(aWriter.toString())); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         assertEquals(JsonToken.FIELD_NAME, jp.getCurrentToken()); [EOL]         String name = jp.getCurrentName(); [EOL]         JsonToken t = jp.nextToken(); [EOL]         if (name.equals("uri")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("url")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testNull")) { [EOL]             assertToken(JsonToken.VALUE_NULL, t); [EOL]         } else if (name.equals("testString")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testBoolean")) { [EOL]             assertToken(JsonToken.VALUE_TRUE, t); [EOL]         } else if (name.equals("testEnum")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_ENUM.toString(), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_INT); [EOL]         } else if (name.equals("testLong")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_LONG); [EOL]         } else if (name.equals("testBigInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_BIGINT.longValue()); [EOL]         } else if (name.equals("testBigDecimal")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getText(), FixtureObject.VALUE_BIGDEC.toString()); [EOL]         } else if (name.equals("testCharacter")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(String.valueOf(FixtureObject.VALUE_CHAR), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testShort")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_SHORT); [EOL]         } else if (name.equals("testByte")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_BYTE); [EOL]         } else if (name.equals("testFloat")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDecimalValue().floatValue(), FixtureObject.VALUE_FLOAT); [EOL]         } else if (name.equals("testDouble")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDoubleValue(), FixtureObject.VALUE_DBL); [EOL]         } else if (name.equals("testStringBuffer")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testError")) { [EOL]             assertToken(JsonToken.START_OBJECT, t); [EOL]             while (jp.nextToken() == JsonToken.FIELD_NAME) { [EOL]                 name = jp.getCurrentName(); [EOL]                 if (name.equals("cause")) { [EOL]                     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]                 } else if (name.equals("message")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                     assertEquals(FixtureObject.VALUE_ERRTXT, getAndVerifyText(jp)); [EOL]                 } else if (name.equals("localizedMessage")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                 } else if (name.equals("stackTrace")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     int i = 0; [EOL]                     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                         if (i >= 100000) { [EOL]                             assertTrue("Probably run away loop in test. StackTrack Array was not properly closed.", false); [EOL]                         } [EOL]                     } [EOL]                 } else if (name.equals("suppressed")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]                 } else { [EOL]                     fail("Unexpected field name '" + name + "'"); [EOL]                 } [EOL]             } [EOL]             assertEquals(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]         } else { [EOL]             fail("Unexpected field, name '" + name + "'"); [EOL]         } [EOL]     } [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testComplexObject() throws Exception { [EOL]     FixtureObject aTestObj = new FixtureObject(); [EOL]     ObjectMapper aMapper = new ObjectMapper(); [EOL]     StringWriter aWriter = new StringWriter(); [EOL]     JsonGenerator aGen = new JsonFactory().createGenerator(aWriter); [EOL]     aMapper.writeValue(aGen, aTestObj); [EOL]     aGen.close(); [EOL]     JsonParser jp = new JsonFactory().createParser(new StringReader(aWriter.toString())); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         assertEquals(JsonToken.FIELD_NAME, jp.getCurrentToken()); [EOL]         String name = jp.getCurrentName(); [EOL]         JsonToken t = jp.nextToken(); [EOL]         if (name.equals("uri")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("url")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testNull")) { [EOL]             assertToken(JsonToken.VALUE_NULL, t); [EOL]         } else if (name.equals("testString")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testBoolean")) { [EOL]             assertToken(JsonToken.VALUE_TRUE, t); [EOL]         } else if (name.equals("testEnum")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_ENUM.toString(), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_INT); [EOL]         } else if (name.equals("testLong")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_LONG); [EOL]         } else if (name.equals("testBigInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_BIGINT.longValue()); [EOL]         } else if (name.equals("testBigDecimal")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getText(), FixtureObject.VALUE_BIGDEC.toString()); [EOL]         } else if (name.equals("testCharacter")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(String.valueOf(FixtureObject.VALUE_CHAR), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testShort")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_SHORT); [EOL]         } else if (name.equals("testByte")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_BYTE); [EOL]         } else if (name.equals("testFloat")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDecimalValue().floatValue(), FixtureObject.VALUE_FLOAT); [EOL]         } else if (name.equals("testDouble")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDoubleValue(), FixtureObject.VALUE_DBL); [EOL]         } else if (name.equals("testStringBuffer")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testError")) { [EOL]             assertToken(JsonToken.START_OBJECT, t); [EOL]             while (jp.nextToken() == JsonToken.FIELD_NAME) { [EOL]                 name = jp.getCurrentName(); [EOL]                 if (name.equals("cause")) { [EOL]                     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]                 } else if (name.equals("message")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                     assertEquals(FixtureObject.VALUE_ERRTXT, getAndVerifyText(jp)); [EOL]                 } else if (name.equals("localizedMessage")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                 } else if (name.equals("stackTrace")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     int i = 0; [EOL]                     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                         if (i >= 100000) { [EOL]                             assertTrue("Probably run away loop in test. StackTrack Array was not properly closed.", false); [EOL]                         } [EOL]                     } [EOL]                 } else if (name.equals("suppressed")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]                 } else { [EOL]                     fail("Unexpected field name '" + name + "'"); [EOL]                 } [EOL]             } [EOL]             assertEquals(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]         } else { [EOL]             fail("Unexpected field, name '" + name + "'"); [EOL]         } [EOL]     } [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testComplexObject() throws Exception { [EOL]     FixtureObject aTestObj = new FixtureObject(); [EOL]     ObjectMapper aMapper = new ObjectMapper(); [EOL]     StringWriter aWriter = new StringWriter(); [EOL]     JsonGenerator aGen = new JsonFactory().createGenerator(aWriter); [EOL]     aMapper.writeValue(aGen, aTestObj); [EOL]     aGen.close(); [EOL]     JsonParser jp = new JsonFactory().createParser(new StringReader(aWriter.toString())); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         assertEquals(JsonToken.FIELD_NAME, jp.getCurrentToken()); [EOL]         String name = jp.getCurrentName(); [EOL]         JsonToken t = jp.nextToken(); [EOL]         if (name.equals("uri")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("url")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testNull")) { [EOL]             assertToken(JsonToken.VALUE_NULL, t); [EOL]         } else if (name.equals("testString")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testBoolean")) { [EOL]             assertToken(JsonToken.VALUE_TRUE, t); [EOL]         } else if (name.equals("testEnum")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_ENUM.toString(), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_INT); [EOL]         } else if (name.equals("testLong")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_LONG); [EOL]         } else if (name.equals("testBigInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_BIGINT.longValue()); [EOL]         } else if (name.equals("testBigDecimal")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getText(), FixtureObject.VALUE_BIGDEC.toString()); [EOL]         } else if (name.equals("testCharacter")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(String.valueOf(FixtureObject.VALUE_CHAR), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testShort")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_SHORT); [EOL]         } else if (name.equals("testByte")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_BYTE); [EOL]         } else if (name.equals("testFloat")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDecimalValue().floatValue(), FixtureObject.VALUE_FLOAT); [EOL]         } else if (name.equals("testDouble")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDoubleValue(), FixtureObject.VALUE_DBL); [EOL]         } else if (name.equals("testStringBuffer")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testError")) { [EOL]             assertToken(JsonToken.START_OBJECT, t); [EOL]             while (jp.nextToken() == JsonToken.FIELD_NAME) { [EOL]                 name = jp.getCurrentName(); [EOL]                 if (name.equals("cause")) { [EOL]                     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]                 } else if (name.equals("message")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                     assertEquals(FixtureObject.VALUE_ERRTXT, getAndVerifyText(jp)); [EOL]                 } else if (name.equals("localizedMessage")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                 } else if (name.equals("stackTrace")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     int i = 0; [EOL]                     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                         if (i >= 100000) { [EOL]                             assertTrue("Probably run away loop in test. StackTrack Array was not properly closed.", false); [EOL]                         } [EOL]                     } [EOL]                 } else if (name.equals("suppressed")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]                 } else { [EOL]                     fail("Unexpected field name '" + name + "'"); [EOL]                 } [EOL]             } [EOL]             assertEquals(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]         } else { [EOL]             fail("Unexpected field, name '" + name + "'"); [EOL]         } [EOL]     } [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testComplexObject() throws Exception { [EOL]     FixtureObject aTestObj = new FixtureObject(); [EOL]     ObjectMapper aMapper = new ObjectMapper(); [EOL]     StringWriter aWriter = new StringWriter(); [EOL]     JsonGenerator aGen = new JsonFactory().createGenerator(aWriter); [EOL]     aMapper.writeValue(aGen, aTestObj); [EOL]     aGen.close(); [EOL]     JsonParser jp = new JsonFactory().createParser(new StringReader(aWriter.toString())); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         assertEquals(JsonToken.FIELD_NAME, jp.getCurrentToken()); [EOL]         String name = jp.getCurrentName(); [EOL]         JsonToken t = jp.nextToken(); [EOL]         if (name.equals("uri")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("url")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testNull")) { [EOL]             assertToken(JsonToken.VALUE_NULL, t); [EOL]         } else if (name.equals("testString")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testBoolean")) { [EOL]             assertToken(JsonToken.VALUE_TRUE, t); [EOL]         } else if (name.equals("testEnum")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_ENUM.toString(), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_INT); [EOL]         } else if (name.equals("testLong")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_LONG); [EOL]         } else if (name.equals("testBigInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_BIGINT.longValue()); [EOL]         } else if (name.equals("testBigDecimal")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getText(), FixtureObject.VALUE_BIGDEC.toString()); [EOL]         } else if (name.equals("testCharacter")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(String.valueOf(FixtureObject.VALUE_CHAR), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testShort")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_SHORT); [EOL]         } else if (name.equals("testByte")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_BYTE); [EOL]         } else if (name.equals("testFloat")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDecimalValue().floatValue(), FixtureObject.VALUE_FLOAT); [EOL]         } else if (name.equals("testDouble")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDoubleValue(), FixtureObject.VALUE_DBL); [EOL]         } else if (name.equals("testStringBuffer")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testError")) { [EOL]             assertToken(JsonToken.START_OBJECT, t); [EOL]             while (jp.nextToken() == JsonToken.FIELD_NAME) { [EOL]                 name = jp.getCurrentName(); [EOL]                 if (name.equals("cause")) { [EOL]                     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]                 } else if (name.equals("message")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                     assertEquals(FixtureObject.VALUE_ERRTXT, getAndVerifyText(jp)); [EOL]                 } else if (name.equals("localizedMessage")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                 } else if (name.equals("stackTrace")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     int i = 0; [EOL]                     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                         if (i >= 100000) { [EOL]                             assertTrue("Probably run away loop in test. StackTrack Array was not properly closed.", false); [EOL]                         } [EOL]                     } [EOL]                 } else if (name.equals("suppressed")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]                 } else { [EOL]                     fail("Unexpected field name '" + name + "'"); [EOL]                 } [EOL]             } [EOL]             assertEquals(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]         } else { [EOL]             fail("Unexpected field, name '" + name + "'"); [EOL]         } [EOL]     } [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testComplexObject() throws Exception { [EOL]     FixtureObject aTestObj = new FixtureObject(); [EOL]     ObjectMapper aMapper = new ObjectMapper(); [EOL]     StringWriter aWriter = new StringWriter(); [EOL]     JsonGenerator aGen = new JsonFactory().createGenerator(aWriter); [EOL]     aMapper.writeValue(aGen, aTestObj); [EOL]     aGen.close(); [EOL]     JsonParser jp = new JsonFactory().createParser(new StringReader(aWriter.toString())); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         assertEquals(JsonToken.FIELD_NAME, jp.getCurrentToken()); [EOL]         String name = jp.getCurrentName(); [EOL]         JsonToken t = jp.nextToken(); [EOL]         if (name.equals("uri")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("url")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testNull")) { [EOL]             assertToken(JsonToken.VALUE_NULL, t); [EOL]         } else if (name.equals("testString")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testBoolean")) { [EOL]             assertToken(JsonToken.VALUE_TRUE, t); [EOL]         } else if (name.equals("testEnum")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_ENUM.toString(), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_INT); [EOL]         } else if (name.equals("testLong")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_LONG); [EOL]         } else if (name.equals("testBigInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_BIGINT.longValue()); [EOL]         } else if (name.equals("testBigDecimal")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getText(), FixtureObject.VALUE_BIGDEC.toString()); [EOL]         } else if (name.equals("testCharacter")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(String.valueOf(FixtureObject.VALUE_CHAR), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testShort")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_SHORT); [EOL]         } else if (name.equals("testByte")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_BYTE); [EOL]         } else if (name.equals("testFloat")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDecimalValue().floatValue(), FixtureObject.VALUE_FLOAT); [EOL]         } else if (name.equals("testDouble")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDoubleValue(), FixtureObject.VALUE_DBL); [EOL]         } else if (name.equals("testStringBuffer")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testError")) { [EOL]             assertToken(JsonToken.START_OBJECT, t); [EOL]             while (jp.nextToken() == JsonToken.FIELD_NAME) { [EOL]                 name = jp.getCurrentName(); [EOL]                 if (name.equals("cause")) { [EOL]                     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]                 } else if (name.equals("message")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                     assertEquals(FixtureObject.VALUE_ERRTXT, getAndVerifyText(jp)); [EOL]                 } else if (name.equals("localizedMessage")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                 } else if (name.equals("stackTrace")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     int i = 0; [EOL]                     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                         if (i >= 100000) { [EOL]                             assertTrue("Probably run away loop in test. StackTrack Array was not properly closed.", false); [EOL]                         } [EOL]                     } [EOL]                 } else if (name.equals("suppressed")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]                 } else { [EOL]                     fail("Unexpected field name '" + name + "'"); [EOL]                 } [EOL]             } [EOL]             assertEquals(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]         } else { [EOL]             fail("Unexpected field, name '" + name + "'"); [EOL]         } [EOL]     } [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testComplexObject() throws Exception { [EOL]     FixtureObject aTestObj = new FixtureObject(); [EOL]     ObjectMapper aMapper = new ObjectMapper(); [EOL]     StringWriter aWriter = new StringWriter(); [EOL]     JsonGenerator aGen = new JsonFactory().createGenerator(aWriter); [EOL]     aMapper.writeValue(aGen, aTestObj); [EOL]     aGen.close(); [EOL]     JsonParser jp = new JsonFactory().createParser(new StringReader(aWriter.toString())); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         assertEquals(JsonToken.FIELD_NAME, jp.getCurrentToken()); [EOL]         String name = jp.getCurrentName(); [EOL]         JsonToken t = jp.nextToken(); [EOL]         if (name.equals("uri")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("url")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testNull")) { [EOL]             assertToken(JsonToken.VALUE_NULL, t); [EOL]         } else if (name.equals("testString")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testBoolean")) { [EOL]             assertToken(JsonToken.VALUE_TRUE, t); [EOL]         } else if (name.equals("testEnum")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_ENUM.toString(), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_INT); [EOL]         } else if (name.equals("testLong")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_LONG); [EOL]         } else if (name.equals("testBigInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_BIGINT.longValue()); [EOL]         } else if (name.equals("testBigDecimal")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getText(), FixtureObject.VALUE_BIGDEC.toString()); [EOL]         } else if (name.equals("testCharacter")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(String.valueOf(FixtureObject.VALUE_CHAR), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testShort")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_SHORT); [EOL]         } else if (name.equals("testByte")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_BYTE); [EOL]         } else if (name.equals("testFloat")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDecimalValue().floatValue(), FixtureObject.VALUE_FLOAT); [EOL]         } else if (name.equals("testDouble")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDoubleValue(), FixtureObject.VALUE_DBL); [EOL]         } else if (name.equals("testStringBuffer")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testError")) { [EOL]             assertToken(JsonToken.START_OBJECT, t); [EOL]             while (jp.nextToken() == JsonToken.FIELD_NAME) { [EOL]                 name = jp.getCurrentName(); [EOL]                 if (name.equals("cause")) { [EOL]                     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]                 } else if (name.equals("message")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                     assertEquals(FixtureObject.VALUE_ERRTXT, getAndVerifyText(jp)); [EOL]                 } else if (name.equals("localizedMessage")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                 } else if (name.equals("stackTrace")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     int i = 0; [EOL]                     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                         if (i >= 100000) { [EOL]                             assertTrue("Probably run away loop in test. StackTrack Array was not properly closed.", false); [EOL]                         } [EOL]                     } [EOL]                 } else if (name.equals("suppressed")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]                 } else { [EOL]                     fail("Unexpected field name '" + name + "'"); [EOL]                 } [EOL]             } [EOL]             assertEquals(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]         } else { [EOL]             fail("Unexpected field, name '" + name + "'"); [EOL]         } [EOL]     } [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testComplexObject() throws Exception { [EOL]     FixtureObject aTestObj = new FixtureObject(); [EOL]     ObjectMapper aMapper = new ObjectMapper(); [EOL]     StringWriter aWriter = new StringWriter(); [EOL]     JsonGenerator aGen = new JsonFactory().createGenerator(aWriter); [EOL]     aMapper.writeValue(aGen, aTestObj); [EOL]     aGen.close(); [EOL]     JsonParser jp = new JsonFactory().createParser(new StringReader(aWriter.toString())); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         assertEquals(JsonToken.FIELD_NAME, jp.getCurrentToken()); [EOL]         String name = jp.getCurrentName(); [EOL]         JsonToken t = jp.nextToken(); [EOL]         if (name.equals("uri")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("url")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testNull")) { [EOL]             assertToken(JsonToken.VALUE_NULL, t); [EOL]         } else if (name.equals("testString")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testBoolean")) { [EOL]             assertToken(JsonToken.VALUE_TRUE, t); [EOL]         } else if (name.equals("testEnum")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_ENUM.toString(), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_INT); [EOL]         } else if (name.equals("testLong")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_LONG); [EOL]         } else if (name.equals("testBigInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_BIGINT.longValue()); [EOL]         } else if (name.equals("testBigDecimal")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getText(), FixtureObject.VALUE_BIGDEC.toString()); [EOL]         } else if (name.equals("testCharacter")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(String.valueOf(FixtureObject.VALUE_CHAR), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testShort")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_SHORT); [EOL]         } else if (name.equals("testByte")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_BYTE); [EOL]         } else if (name.equals("testFloat")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDecimalValue().floatValue(), FixtureObject.VALUE_FLOAT); [EOL]         } else if (name.equals("testDouble")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDoubleValue(), FixtureObject.VALUE_DBL); [EOL]         } else if (name.equals("testStringBuffer")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testError")) { [EOL]             assertToken(JsonToken.START_OBJECT, t); [EOL]             while (jp.nextToken() == JsonToken.FIELD_NAME) { [EOL]                 name = jp.getCurrentName(); [EOL]                 if (name.equals("cause")) { [EOL]                     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]                 } else if (name.equals("message")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                     assertEquals(FixtureObject.VALUE_ERRTXT, getAndVerifyText(jp)); [EOL]                 } else if (name.equals("localizedMessage")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                 } else if (name.equals("stackTrace")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     int i = 0; [EOL]                     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                         if (i >= 100000) { [EOL]                             assertTrue("Probably run away loop in test. StackTrack Array was not properly closed.", false); [EOL]                         } [EOL]                     } [EOL]                 } else if (name.equals("suppressed")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]                 } else { [EOL]                     fail("Unexpected field name '" + name + "'"); [EOL]                 } [EOL]             } [EOL]             assertEquals(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]         } else { [EOL]             fail("Unexpected field, name '" + name + "'"); [EOL]         } [EOL]     } [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testComplexObject() throws Exception { [EOL]     FixtureObject aTestObj = new FixtureObject(); [EOL]     ObjectMapper aMapper = new ObjectMapper(); [EOL]     StringWriter aWriter = new StringWriter(); [EOL]     JsonGenerator aGen = new JsonFactory().createGenerator(aWriter); [EOL]     aMapper.writeValue(aGen, aTestObj); [EOL]     aGen.close(); [EOL]     JsonParser jp = new JsonFactory().createParser(new StringReader(aWriter.toString())); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         assertEquals(JsonToken.FIELD_NAME, jp.getCurrentToken()); [EOL]         String name = jp.getCurrentName(); [EOL]         JsonToken t = jp.nextToken(); [EOL]         if (name.equals("uri")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("url")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testNull")) { [EOL]             assertToken(JsonToken.VALUE_NULL, t); [EOL]         } else if (name.equals("testString")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testBoolean")) { [EOL]             assertToken(JsonToken.VALUE_TRUE, t); [EOL]         } else if (name.equals("testEnum")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_ENUM.toString(), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_INT); [EOL]         } else if (name.equals("testLong")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_LONG); [EOL]         } else if (name.equals("testBigInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_BIGINT.longValue()); [EOL]         } else if (name.equals("testBigDecimal")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getText(), FixtureObject.VALUE_BIGDEC.toString()); [EOL]         } else if (name.equals("testCharacter")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(String.valueOf(FixtureObject.VALUE_CHAR), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testShort")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_SHORT); [EOL]         } else if (name.equals("testByte")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_BYTE); [EOL]         } else if (name.equals("testFloat")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDecimalValue().floatValue(), FixtureObject.VALUE_FLOAT); [EOL]         } else if (name.equals("testDouble")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDoubleValue(), FixtureObject.VALUE_DBL); [EOL]         } else if (name.equals("testStringBuffer")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testError")) { [EOL]             assertToken(JsonToken.START_OBJECT, t); [EOL]             while (jp.nextToken() == JsonToken.FIELD_NAME) { [EOL]                 name = jp.getCurrentName(); [EOL]                 if (name.equals("cause")) { [EOL]                     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]                 } else if (name.equals("message")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                     assertEquals(FixtureObject.VALUE_ERRTXT, getAndVerifyText(jp)); [EOL]                 } else if (name.equals("localizedMessage")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                 } else if (name.equals("stackTrace")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     int i = 0; [EOL]                     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                         if (i >= 100000) { [EOL]                             assertTrue("Probably run away loop in test. StackTrack Array was not properly closed.", false); [EOL]                         } [EOL]                     } [EOL]                 } else if (name.equals("suppressed")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]                 } else { [EOL]                     fail("Unexpected field name '" + name + "'"); [EOL]                 } [EOL]             } [EOL]             assertEquals(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]         } else { [EOL]             fail("Unexpected field, name '" + name + "'"); [EOL]         } [EOL]     } [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testComplexObject() throws Exception { [EOL]     FixtureObject aTestObj = new FixtureObject(); [EOL]     ObjectMapper aMapper = new ObjectMapper(); [EOL]     StringWriter aWriter = new StringWriter(); [EOL]     JsonGenerator aGen = new JsonFactory().createGenerator(aWriter); [EOL]     aMapper.writeValue(aGen, aTestObj); [EOL]     aGen.close(); [EOL]     JsonParser jp = new JsonFactory().createParser(new StringReader(aWriter.toString())); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         assertEquals(JsonToken.FIELD_NAME, jp.getCurrentToken()); [EOL]         String name = jp.getCurrentName(); [EOL]         JsonToken t = jp.nextToken(); [EOL]         if (name.equals("uri")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("url")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testNull")) { [EOL]             assertToken(JsonToken.VALUE_NULL, t); [EOL]         } else if (name.equals("testString")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testBoolean")) { [EOL]             assertToken(JsonToken.VALUE_TRUE, t); [EOL]         } else if (name.equals("testEnum")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_ENUM.toString(), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_INT); [EOL]         } else if (name.equals("testLong")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_LONG); [EOL]         } else if (name.equals("testBigInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_BIGINT.longValue()); [EOL]         } else if (name.equals("testBigDecimal")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getText(), FixtureObject.VALUE_BIGDEC.toString()); [EOL]         } else if (name.equals("testCharacter")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(String.valueOf(FixtureObject.VALUE_CHAR), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testShort")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_SHORT); [EOL]         } else if (name.equals("testByte")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_BYTE); [EOL]         } else if (name.equals("testFloat")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDecimalValue().floatValue(), FixtureObject.VALUE_FLOAT); [EOL]         } else if (name.equals("testDouble")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDoubleValue(), FixtureObject.VALUE_DBL); [EOL]         } else if (name.equals("testStringBuffer")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testError")) { [EOL]             assertToken(JsonToken.START_OBJECT, t); [EOL]             while (jp.nextToken() == JsonToken.FIELD_NAME) { [EOL]                 name = jp.getCurrentName(); [EOL]                 if (name.equals("cause")) { [EOL]                     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]                 } else if (name.equals("message")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                     assertEquals(FixtureObject.VALUE_ERRTXT, getAndVerifyText(jp)); [EOL]                 } else if (name.equals("localizedMessage")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                 } else if (name.equals("stackTrace")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     int i = 0; [EOL]                     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                         if (i >= 100000) { [EOL]                             assertTrue("Probably run away loop in test. StackTrack Array was not properly closed.", false); [EOL]                         } [EOL]                     } [EOL]                 } else if (name.equals("suppressed")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]                 } else { [EOL]                     fail("Unexpected field name '" + name + "'"); [EOL]                 } [EOL]             } [EOL]             assertEquals(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]         } else { [EOL]             fail("Unexpected field, name '" + name + "'"); [EOL]         } [EOL]     } [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testComplexObject() throws Exception { [EOL]     FixtureObject aTestObj = new FixtureObject(); [EOL]     ObjectMapper aMapper = new ObjectMapper(); [EOL]     StringWriter aWriter = new StringWriter(); [EOL]     JsonGenerator aGen = new JsonFactory().createGenerator(aWriter); [EOL]     aMapper.writeValue(aGen, aTestObj); [EOL]     aGen.close(); [EOL]     JsonParser jp = new JsonFactory().createParser(new StringReader(aWriter.toString())); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         assertEquals(JsonToken.FIELD_NAME, jp.getCurrentToken()); [EOL]         String name = jp.getCurrentName(); [EOL]         JsonToken t = jp.nextToken(); [EOL]         if (name.equals("uri")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("url")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testNull")) { [EOL]             assertToken(JsonToken.VALUE_NULL, t); [EOL]         } else if (name.equals("testString")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testBoolean")) { [EOL]             assertToken(JsonToken.VALUE_TRUE, t); [EOL]         } else if (name.equals("testEnum")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_ENUM.toString(), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_INT); [EOL]         } else if (name.equals("testLong")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_LONG); [EOL]         } else if (name.equals("testBigInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_BIGINT.longValue()); [EOL]         } else if (name.equals("testBigDecimal")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getText(), FixtureObject.VALUE_BIGDEC.toString()); [EOL]         } else if (name.equals("testCharacter")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(String.valueOf(FixtureObject.VALUE_CHAR), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testShort")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_SHORT); [EOL]         } else if (name.equals("testByte")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_BYTE); [EOL]         } else if (name.equals("testFloat")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDecimalValue().floatValue(), FixtureObject.VALUE_FLOAT); [EOL]         } else if (name.equals("testDouble")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDoubleValue(), FixtureObject.VALUE_DBL); [EOL]         } else if (name.equals("testStringBuffer")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testError")) { [EOL]             assertToken(JsonToken.START_OBJECT, t); [EOL]             while (jp.nextToken() == JsonToken.FIELD_NAME) { [EOL]                 name = jp.getCurrentName(); [EOL]                 if (name.equals("cause")) { [EOL]                     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]                 } else if (name.equals("message")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                     assertEquals(FixtureObject.VALUE_ERRTXT, getAndVerifyText(jp)); [EOL]                 } else if (name.equals("localizedMessage")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                 } else if (name.equals("stackTrace")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     int i = 0; [EOL]                     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                         if (i >= 100000) { [EOL]                             assertTrue("Probably run away loop in test. StackTrack Array was not properly closed.", false); [EOL]                         } [EOL]                     } [EOL]                 } else if (name.equals("suppressed")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]                 } else { [EOL]                     fail("Unexpected field name '" + name + "'"); [EOL]                 } [EOL]             } [EOL]             assertEquals(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]         } else { [EOL]             fail("Unexpected field, name '" + name + "'"); [EOL]         } [EOL]     } [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testComplexObject() throws Exception { [EOL]     FixtureObject aTestObj = new FixtureObject(); [EOL]     ObjectMapper aMapper = new ObjectMapper(); [EOL]     StringWriter aWriter = new StringWriter(); [EOL]     JsonGenerator aGen = new JsonFactory().createGenerator(aWriter); [EOL]     aMapper.writeValue(aGen, aTestObj); [EOL]     aGen.close(); [EOL]     JsonParser jp = new JsonFactory().createParser(new StringReader(aWriter.toString())); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         assertEquals(JsonToken.FIELD_NAME, jp.getCurrentToken()); [EOL]         String name = jp.getCurrentName(); [EOL]         JsonToken t = jp.nextToken(); [EOL]         if (name.equals("uri")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("url")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testNull")) { [EOL]             assertToken(JsonToken.VALUE_NULL, t); [EOL]         } else if (name.equals("testString")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testBoolean")) { [EOL]             assertToken(JsonToken.VALUE_TRUE, t); [EOL]         } else if (name.equals("testEnum")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_ENUM.toString(), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_INT); [EOL]         } else if (name.equals("testLong")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_LONG); [EOL]         } else if (name.equals("testBigInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_BIGINT.longValue()); [EOL]         } else if (name.equals("testBigDecimal")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getText(), FixtureObject.VALUE_BIGDEC.toString()); [EOL]         } else if (name.equals("testCharacter")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(String.valueOf(FixtureObject.VALUE_CHAR), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testShort")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_SHORT); [EOL]         } else if (name.equals("testByte")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_BYTE); [EOL]         } else if (name.equals("testFloat")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDecimalValue().floatValue(), FixtureObject.VALUE_FLOAT); [EOL]         } else if (name.equals("testDouble")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDoubleValue(), FixtureObject.VALUE_DBL); [EOL]         } else if (name.equals("testStringBuffer")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testError")) { [EOL]             assertToken(JsonToken.START_OBJECT, t); [EOL]             while (jp.nextToken() == JsonToken.FIELD_NAME) { [EOL]                 name = jp.getCurrentName(); [EOL]                 if (name.equals("cause")) { [EOL]                     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]                 } else if (name.equals("message")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                     assertEquals(FixtureObject.VALUE_ERRTXT, getAndVerifyText(jp)); [EOL]                 } else if (name.equals("localizedMessage")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                 } else if (name.equals("stackTrace")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     int i = 0; [EOL]                     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                         if (i >= 100000) { [EOL]                             assertTrue("Probably run away loop in test. StackTrack Array was not properly closed.", false); [EOL]                         } [EOL]                     } [EOL]                 } else if (name.equals("suppressed")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]                 } else { [EOL]                     fail("Unexpected field name '" + name + "'"); [EOL]                 } [EOL]             } [EOL]             assertEquals(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]         } else { [EOL]             fail("Unexpected field, name '" + name + "'"); [EOL]         } [EOL]     } [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testComplexObject() throws Exception { [EOL]     FixtureObject aTestObj = new FixtureObject(); [EOL]     ObjectMapper aMapper = new ObjectMapper(); [EOL]     StringWriter aWriter = new StringWriter(); [EOL]     JsonGenerator aGen = new JsonFactory().createGenerator(aWriter); [EOL]     aMapper.writeValue(aGen, aTestObj); [EOL]     aGen.close(); [EOL]     JsonParser jp = new JsonFactory().createParser(new StringReader(aWriter.toString())); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         assertEquals(JsonToken.FIELD_NAME, jp.getCurrentToken()); [EOL]         String name = jp.getCurrentName(); [EOL]         JsonToken t = jp.nextToken(); [EOL]         if (name.equals("uri")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("url")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testNull")) { [EOL]             assertToken(JsonToken.VALUE_NULL, t); [EOL]         } else if (name.equals("testString")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testBoolean")) { [EOL]             assertToken(JsonToken.VALUE_TRUE, t); [EOL]         } else if (name.equals("testEnum")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_ENUM.toString(), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_INT); [EOL]         } else if (name.equals("testLong")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_LONG); [EOL]         } else if (name.equals("testBigInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_BIGINT.longValue()); [EOL]         } else if (name.equals("testBigDecimal")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getText(), FixtureObject.VALUE_BIGDEC.toString()); [EOL]         } else if (name.equals("testCharacter")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(String.valueOf(FixtureObject.VALUE_CHAR), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testShort")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_SHORT); [EOL]         } else if (name.equals("testByte")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_BYTE); [EOL]         } else if (name.equals("testFloat")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDecimalValue().floatValue(), FixtureObject.VALUE_FLOAT); [EOL]         } else if (name.equals("testDouble")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDoubleValue(), FixtureObject.VALUE_DBL); [EOL]         } else if (name.equals("testStringBuffer")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testError")) { [EOL]             assertToken(JsonToken.START_OBJECT, t); [EOL]             while (jp.nextToken() == JsonToken.FIELD_NAME) { [EOL]                 name = jp.getCurrentName(); [EOL]                 if (name.equals("cause")) { [EOL]                     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]                 } else if (name.equals("message")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                     assertEquals(FixtureObject.VALUE_ERRTXT, getAndVerifyText(jp)); [EOL]                 } else if (name.equals("localizedMessage")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                 } else if (name.equals("stackTrace")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     int i = 0; [EOL]                     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                         if (i >= 100000) { [EOL]                             assertTrue("Probably run away loop in test. StackTrack Array was not properly closed.", false); [EOL]                         } [EOL]                     } [EOL]                 } else if (name.equals("suppressed")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]                 } else { [EOL]                     fail("Unexpected field name '" + name + "'"); [EOL]                 } [EOL]             } [EOL]             assertEquals(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]         } else { [EOL]             fail("Unexpected field, name '" + name + "'"); [EOL]         } [EOL]     } [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testText() { [EOL]     assertNull(TextNode.valueOf(null)); [EOL]     TextNode empty = TextNode.valueOf(""); [EOL]     assertStandardEquals(empty); [EOL]     assertSame(TextNode.EMPTY_STRING_NODE, empty); [EOL]     assertNodeNumbers(TextNode.valueOf("-3"), -3, -3.0); [EOL]     assertNodeNumbers(TextNode.valueOf("17.75"), 17, 17.75); [EOL]     long value = 127353264013893L; [EOL]     TextNode n = TextNode.valueOf(String.valueOf(value)); [EOL]     assertEquals(value, n.asLong()); [EOL]     assertNodeNumbersForNonNumeric(TextNode.valueOf("foobar")); [EOL] }
public void testText() { [EOL]     assertNull(TextNode.valueOf(null)); [EOL]     TextNode empty = TextNode.valueOf(""); [EOL]     assertStandardEquals(empty); [EOL]     assertSame(TextNode.EMPTY_STRING_NODE, empty); [EOL]     assertNodeNumbers(TextNode.valueOf("-3"), -3, -3.0); [EOL]     assertNodeNumbers(TextNode.valueOf("17.75"), 17, 17.75); [EOL]     long value = 127353264013893L; [EOL]     TextNode n = TextNode.valueOf(String.valueOf(value)); [EOL]     assertEquals(value, n.asLong()); [EOL]     assertNodeNumbersForNonNumeric(TextNode.valueOf("foobar")); [EOL] }
public void testText() { [EOL]     assertNull(TextNode.valueOf(null)); [EOL]     TextNode empty = TextNode.valueOf(""); [EOL]     assertStandardEquals(empty); [EOL]     assertSame(TextNode.EMPTY_STRING_NODE, empty); [EOL]     assertNodeNumbers(TextNode.valueOf("-3"), -3, -3.0); [EOL]     assertNodeNumbers(TextNode.valueOf("17.75"), 17, 17.75); [EOL]     long value = 127353264013893L; [EOL]     TextNode n = TextNode.valueOf(String.valueOf(value)); [EOL]     assertEquals(value, n.asLong()); [EOL]     assertNodeNumbersForNonNumeric(TextNode.valueOf("foobar")); [EOL] }
public void testDataBind() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     JsonNode tree = m.readTree("{ \"name\" : \"Tatu\", \n" + "\"magicNumber\" : 42," + "\"kids\" : [ \"Leo\", \"Lila\", \"Leia\" ] \n" + "}"); [EOL]     Person tatu = m.treeToValue(tree, Person.class); [EOL]     assertNotNull(tatu); [EOL]     assertEquals(42, tatu.magicNumber); [EOL]     assertEquals("Tatu", tatu.name); [EOL]     assertNotNull(tatu.kids); [EOL]     assertEquals(3, tatu.kids.size()); [EOL]     assertEquals("Leo", tatu.kids.get(0)); [EOL]     assertEquals("Lila", tatu.kids.get(1)); [EOL]     assertEquals("Leia", tatu.kids.get(2)); [EOL] }
public void testText() { [EOL]     assertNull(TextNode.valueOf(null)); [EOL]     TextNode empty = TextNode.valueOf(""); [EOL]     assertStandardEquals(empty); [EOL]     assertSame(TextNode.EMPTY_STRING_NODE, empty); [EOL]     assertNodeNumbers(TextNode.valueOf("-3"), -3, -3.0); [EOL]     assertNodeNumbers(TextNode.valueOf("17.75"), 17, 17.75); [EOL]     long value = 127353264013893L; [EOL]     TextNode n = TextNode.valueOf(String.valueOf(value)); [EOL]     assertEquals(value, n.asLong()); [EOL]     assertNodeNumbersForNonNumeric(TextNode.valueOf("foobar")); [EOL] }
public void testText() { [EOL]     assertNull(TextNode.valueOf(null)); [EOL]     TextNode empty = TextNode.valueOf(""); [EOL]     assertStandardEquals(empty); [EOL]     assertSame(TextNode.EMPTY_STRING_NODE, empty); [EOL]     assertNodeNumbers(TextNode.valueOf("-3"), -3, -3.0); [EOL]     assertNodeNumbers(TextNode.valueOf("17.75"), 17, 17.75); [EOL]     long value = 127353264013893L; [EOL]     TextNode n = TextNode.valueOf(String.valueOf(value)); [EOL]     assertEquals(value, n.asLong()); [EOL]     assertNodeNumbersForNonNumeric(TextNode.valueOf("foobar")); [EOL] }
public void testText() { [EOL]     assertNull(TextNode.valueOf(null)); [EOL]     TextNode empty = TextNode.valueOf(""); [EOL]     assertStandardEquals(empty); [EOL]     assertSame(TextNode.EMPTY_STRING_NODE, empty); [EOL]     assertNodeNumbers(TextNode.valueOf("-3"), -3, -3.0); [EOL]     assertNodeNumbers(TextNode.valueOf("17.75"), 17, 17.75); [EOL]     long value = 127353264013893L; [EOL]     TextNode n = TextNode.valueOf(String.valueOf(value)); [EOL]     assertEquals(value, n.asLong()); [EOL]     assertNodeNumbersForNonNumeric(TextNode.valueOf("foobar")); [EOL] }
public void testText() { [EOL]     assertNull(TextNode.valueOf(null)); [EOL]     TextNode empty = TextNode.valueOf(""); [EOL]     assertStandardEquals(empty); [EOL]     assertSame(TextNode.EMPTY_STRING_NODE, empty); [EOL]     assertNodeNumbers(TextNode.valueOf("-3"), -3, -3.0); [EOL]     assertNodeNumbers(TextNode.valueOf("17.75"), 17, 17.75); [EOL]     long value = 127353264013893L; [EOL]     TextNode n = TextNode.valueOf(String.valueOf(value)); [EOL]     assertEquals(value, n.asLong()); [EOL]     assertNodeNumbersForNonNumeric(TextNode.valueOf("foobar")); [EOL] }
public void testText() { [EOL]     assertNull(TextNode.valueOf(null)); [EOL]     TextNode empty = TextNode.valueOf(""); [EOL]     assertStandardEquals(empty); [EOL]     assertSame(TextNode.EMPTY_STRING_NODE, empty); [EOL]     assertNodeNumbers(TextNode.valueOf("-3"), -3, -3.0); [EOL]     assertNodeNumbers(TextNode.valueOf("17.75"), 17, 17.75); [EOL]     long value = 127353264013893L; [EOL]     TextNode n = TextNode.valueOf(String.valueOf(value)); [EOL]     assertEquals(value, n.asLong()); [EOL]     assertNodeNumbersForNonNumeric(TextNode.valueOf("foobar")); [EOL] }
public void testText() { [EOL]     assertNull(TextNode.valueOf(null)); [EOL]     TextNode empty = TextNode.valueOf(""); [EOL]     assertStandardEquals(empty); [EOL]     assertSame(TextNode.EMPTY_STRING_NODE, empty); [EOL]     assertNodeNumbers(TextNode.valueOf("-3"), -3, -3.0); [EOL]     assertNodeNumbers(TextNode.valueOf("17.75"), 17, 17.75); [EOL]     long value = 127353264013893L; [EOL]     TextNode n = TextNode.valueOf(String.valueOf(value)); [EOL]     assertEquals(value, n.asLong()); [EOL]     assertNodeNumbersForNonNumeric(TextNode.valueOf("foobar")); [EOL] }
public void testText() { [EOL]     assertNull(TextNode.valueOf(null)); [EOL]     TextNode empty = TextNode.valueOf(""); [EOL]     assertStandardEquals(empty); [EOL]     assertSame(TextNode.EMPTY_STRING_NODE, empty); [EOL]     assertNodeNumbers(TextNode.valueOf("-3"), -3, -3.0); [EOL]     assertNodeNumbers(TextNode.valueOf("17.75"), 17, 17.75); [EOL]     long value = 127353264013893L; [EOL]     TextNode n = TextNode.valueOf(String.valueOf(value)); [EOL]     assertEquals(value, n.asLong()); [EOL]     assertNodeNumbersForNonNumeric(TextNode.valueOf("foobar")); [EOL] }
public void testText() { [EOL]     assertNull(TextNode.valueOf(null)); [EOL]     TextNode empty = TextNode.valueOf(""); [EOL]     assertStandardEquals(empty); [EOL]     assertSame(TextNode.EMPTY_STRING_NODE, empty); [EOL]     assertNodeNumbers(TextNode.valueOf("-3"), -3, -3.0); [EOL]     assertNodeNumbers(TextNode.valueOf("17.75"), 17, 17.75); [EOL]     long value = 127353264013893L; [EOL]     TextNode n = TextNode.valueOf(String.valueOf(value)); [EOL]     assertEquals(value, n.asLong()); [EOL]     assertNodeNumbersForNonNumeric(TextNode.valueOf("foobar")); [EOL] }
public void testText() { [EOL]     assertNull(TextNode.valueOf(null)); [EOL]     TextNode empty = TextNode.valueOf(""); [EOL]     assertStandardEquals(empty); [EOL]     assertSame(TextNode.EMPTY_STRING_NODE, empty); [EOL]     assertNodeNumbers(TextNode.valueOf("-3"), -3, -3.0); [EOL]     assertNodeNumbers(TextNode.valueOf("17.75"), 17, 17.75); [EOL]     long value = 127353264013893L; [EOL]     TextNode n = TextNode.valueOf(String.valueOf(value)); [EOL]     assertEquals(value, n.asLong()); [EOL]     assertNodeNumbersForNonNumeric(TextNode.valueOf("foobar")); [EOL] }
public void testText() { [EOL]     assertNull(TextNode.valueOf(null)); [EOL]     TextNode empty = TextNode.valueOf(""); [EOL]     assertStandardEquals(empty); [EOL]     assertSame(TextNode.EMPTY_STRING_NODE, empty); [EOL]     assertNodeNumbers(TextNode.valueOf("-3"), -3, -3.0); [EOL]     assertNodeNumbers(TextNode.valueOf("17.75"), 17, 17.75); [EOL]     long value = 127353264013893L; [EOL]     TextNode n = TextNode.valueOf(String.valueOf(value)); [EOL]     assertEquals(value, n.asLong()); [EOL]     assertNodeNumbersForNonNumeric(TextNode.valueOf("foobar")); [EOL] }
public void testText() { [EOL]     assertNull(TextNode.valueOf(null)); [EOL]     TextNode empty = TextNode.valueOf(""); [EOL]     assertStandardEquals(empty); [EOL]     assertSame(TextNode.EMPTY_STRING_NODE, empty); [EOL]     assertNodeNumbers(TextNode.valueOf("-3"), -3, -3.0); [EOL]     assertNodeNumbers(TextNode.valueOf("17.75"), 17, 17.75); [EOL]     long value = 127353264013893L; [EOL]     TextNode n = TextNode.valueOf(String.valueOf(value)); [EOL]     assertEquals(value, n.asLong()); [EOL]     assertNodeNumbersForNonNumeric(TextNode.valueOf("foobar")); [EOL] }
public void testText() { [EOL]     assertNull(TextNode.valueOf(null)); [EOL]     TextNode empty = TextNode.valueOf(""); [EOL]     assertStandardEquals(empty); [EOL]     assertSame(TextNode.EMPTY_STRING_NODE, empty); [EOL]     assertNodeNumbers(TextNode.valueOf("-3"), -3, -3.0); [EOL]     assertNodeNumbers(TextNode.valueOf("17.75"), 17, 17.75); [EOL]     long value = 127353264013893L; [EOL]     TextNode n = TextNode.valueOf(String.valueOf(value)); [EOL]     assertEquals(value, n.asLong()); [EOL]     assertNodeNumbersForNonNumeric(TextNode.valueOf("foobar")); [EOL] }
public void testFromArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ArrayNode root = mapper.createArrayNode(); [EOL]     root.add(TEXT1); [EOL]     root.add(3); [EOL]     ObjectNode obj = root.addObject(); [EOL]     obj.put(FIELD1, true); [EOL]     obj.putArray(FIELD2); [EOL]     root.add(false); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         StringWriter sw = new StringWriter(); [EOL]         if (i == 0) { [EOL]             JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]             root.serialize(gen, null); [EOL]             gen.close(); [EOL]         } else { [EOL]             mapper.writeValue(sw, root); [EOL]         } [EOL]         verifyFromArray(sw.toString()); [EOL]     } [EOL]     verifyFromArray(root.toString()); [EOL] }
public void testFromArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ArrayNode root = mapper.createArrayNode(); [EOL]     root.add(TEXT1); [EOL]     root.add(3); [EOL]     ObjectNode obj = root.addObject(); [EOL]     obj.put(FIELD1, true); [EOL]     obj.putArray(FIELD2); [EOL]     root.add(false); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         StringWriter sw = new StringWriter(); [EOL]         if (i == 0) { [EOL]             JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]             root.serialize(gen, null); [EOL]             gen.close(); [EOL]         } else { [EOL]             mapper.writeValue(sw, root); [EOL]         } [EOL]         verifyFromArray(sw.toString()); [EOL]     } [EOL]     verifyFromArray(root.toString()); [EOL] }
public void testFromArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ArrayNode root = mapper.createArrayNode(); [EOL]     root.add(TEXT1); [EOL]     root.add(3); [EOL]     ObjectNode obj = root.addObject(); [EOL]     obj.put(FIELD1, true); [EOL]     obj.putArray(FIELD2); [EOL]     root.add(false); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         StringWriter sw = new StringWriter(); [EOL]         if (i == 0) { [EOL]             JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]             root.serialize(gen, null); [EOL]             gen.close(); [EOL]         } else { [EOL]             mapper.writeValue(sw, root); [EOL]         } [EOL]         verifyFromArray(sw.toString()); [EOL]     } [EOL]     verifyFromArray(root.toString()); [EOL] }
public void testFromArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ArrayNode root = mapper.createArrayNode(); [EOL]     root.add(TEXT1); [EOL]     root.add(3); [EOL]     ObjectNode obj = root.addObject(); [EOL]     obj.put(FIELD1, true); [EOL]     obj.putArray(FIELD2); [EOL]     root.add(false); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         StringWriter sw = new StringWriter(); [EOL]         if (i == 0) { [EOL]             JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]             root.serialize(gen, null); [EOL]             gen.close(); [EOL]         } else { [EOL]             mapper.writeValue(sw, root); [EOL]         } [EOL]         verifyFromArray(sw.toString()); [EOL]     } [EOL]     verifyFromArray(root.toString()); [EOL] }
public void testFromArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ArrayNode root = mapper.createArrayNode(); [EOL]     root.add(TEXT1); [EOL]     root.add(3); [EOL]     ObjectNode obj = root.addObject(); [EOL]     obj.put(FIELD1, true); [EOL]     obj.putArray(FIELD2); [EOL]     root.add(false); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         StringWriter sw = new StringWriter(); [EOL]         if (i == 0) { [EOL]             JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]             root.serialize(gen, null); [EOL]             gen.close(); [EOL]         } else { [EOL]             mapper.writeValue(sw, root); [EOL]         } [EOL]         verifyFromArray(sw.toString()); [EOL]     } [EOL]     verifyFromArray(root.toString()); [EOL] }
public void testFromArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ArrayNode root = mapper.createArrayNode(); [EOL]     root.add(TEXT1); [EOL]     root.add(3); [EOL]     ObjectNode obj = root.addObject(); [EOL]     obj.put(FIELD1, true); [EOL]     obj.putArray(FIELD2); [EOL]     root.add(false); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         StringWriter sw = new StringWriter(); [EOL]         if (i == 0) { [EOL]             JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]             root.serialize(gen, null); [EOL]             gen.close(); [EOL]         } else { [EOL]             mapper.writeValue(sw, root); [EOL]         } [EOL]         verifyFromArray(sw.toString()); [EOL]     } [EOL]     verifyFromArray(root.toString()); [EOL] }
public void testArrayTypingNested() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(DefaultTyping.NON_CONCRETE_AND_ARRAYS); [EOL]     ArrayBean bean = new ArrayBean(new String[0][0]); [EOL]     String json = m.writeValueAsString(bean); [EOL]     ArrayBean result = m.readValue(json, ArrayBean.class); [EOL]     assertNotNull(result.values); [EOL]     assertEquals(String[][].class, result.values.getClass()); [EOL] }
public void testArrayTypingNested() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(DefaultTyping.NON_CONCRETE_AND_ARRAYS); [EOL]     ArrayBean bean = new ArrayBean(new String[0][0]); [EOL]     String json = m.writeValueAsString(bean); [EOL]     ArrayBean result = m.readValue(json, ArrayBean.class); [EOL]     assertNotNull(result.values); [EOL]     assertEquals(String[][].class, result.values.getClass()); [EOL] }
public void testArrayTypingNested() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(DefaultTyping.NON_CONCRETE_AND_ARRAYS); [EOL]     ArrayBean bean = new ArrayBean(new String[0][0]); [EOL]     String json = m.writeValueAsString(bean); [EOL]     ArrayBean result = m.readValue(json, ArrayBean.class); [EOL]     assertNotNull(result.values); [EOL]     assertEquals(String[][].class, result.values.getClass()); [EOL] }
public void testMaps() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(new TypeReference<LongValuedMap<String>>() { [EOL]     }); [EOL]     MapType type = (MapType) t; [EOL]     assertSame(LongValuedMap.class, type.getRawClass()); [EOL]     assertEquals(tf.constructType(String.class), type.getKeyType()); [EOL]     assertEquals(tf.constructType(Long.class), type.getContentType()); [EOL] }
public void testMaps() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(new TypeReference<LongValuedMap<String>>() { [EOL]     }); [EOL]     MapType type = (MapType) t; [EOL]     assertSame(LongValuedMap.class, type.getRawClass()); [EOL]     assertEquals(tf.constructType(String.class), type.getKeyType()); [EOL]     assertEquals(tf.constructType(Long.class), type.getContentType()); [EOL] }
public void testMaps() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(new TypeReference<LongValuedMap<String>>() { [EOL]     }); [EOL]     MapType type = (MapType) t; [EOL]     assertSame(LongValuedMap.class, type.getRawClass()); [EOL]     assertEquals(tf.constructType(String.class), type.getKeyType()); [EOL]     assertEquals(tf.constructType(Long.class), type.getContentType()); [EOL] }
public void testInetAddress() throws IOException { [EOL]     assertEquals(quote("127.0.0.1"), MAPPER.writeValueAsString(InetAddress.getByName("127.0.0.1"))); [EOL]     assertEquals(quote("ning.com"), MAPPER.writeValueAsString(InetAddress.getByName("ning.com"))); [EOL] }
public void testInetAddress() throws IOException { [EOL]     assertEquals(quote("127.0.0.1"), MAPPER.writeValueAsString(InetAddress.getByName("127.0.0.1"))); [EOL]     assertEquals(quote("ning.com"), MAPPER.writeValueAsString(InetAddress.getByName("ning.com"))); [EOL] }
public void testInetAddress() throws IOException { [EOL]     assertEquals(quote("127.0.0.1"), MAPPER.writeValueAsString(InetAddress.getByName("127.0.0.1"))); [EOL]     assertEquals(quote("ning.com"), MAPPER.writeValueAsString(InetAddress.getByName("ning.com"))); [EOL] }
public void testInetAddress() throws IOException { [EOL]     assertEquals(quote("127.0.0.1"), MAPPER.writeValueAsString(InetAddress.getByName("127.0.0.1"))); [EOL]     assertEquals(quote("ning.com"), MAPPER.writeValueAsString(InetAddress.getByName("ning.com"))); [EOL] }
public void testSimpleEnumSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule mod = new SimpleModule("test", Version.unknownVersion()); [EOL]     mod.addSerializer(new SimpleEnumSerializer()); [EOL]     mapper.registerModule(mod); [EOL]     assertEquals(quote("b"), mapper.writeValueAsString(SimpleEnum.B)); [EOL] }
public void testSimpleEnumSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule mod = new SimpleModule("test", Version.unknownVersion()); [EOL]     mod.addSerializer(new SimpleEnumSerializer()); [EOL]     mapper.registerModule(mod); [EOL]     assertEquals(quote("b"), mapper.writeValueAsString(SimpleEnum.B)); [EOL] }
public void testSimpleKeySer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.addKeySerializer(String.class, new ContextualKeySerializer("prefix")); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> input = new HashMap<String, Object>(); [EOL]     input.put("a", Integer.valueOf(3)); [EOL]     String json = mapper.writerWithType(TypeFactory.defaultInstance().constructMapType(HashMap.class, String.class, Object.class)).writeValueAsString(input); [EOL]     assertEquals("{\"prefix:a\":3}", json); [EOL] }
public void testSimpleKeySer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.addKeySerializer(String.class, new ContextualKeySerializer("prefix")); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> input = new HashMap<String, Object>(); [EOL]     input.put("a", Integer.valueOf(3)); [EOL]     String json = mapper.writerWithType(TypeFactory.defaultInstance().constructMapType(HashMap.class, String.class, Object.class)).writeValueAsString(input); [EOL]     assertEquals("{\"prefix:a\":3}", json); [EOL] }
public void testCustomBeanInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyBean.class, new MyBeanInstantiator())); [EOL]     MyBean bean = mapper.readValue("{}", MyBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals("secret!", bean._secret); [EOL] }
public void testCustomBeanInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyBean.class, new MyBeanInstantiator())); [EOL]     MyBean bean = mapper.readValue("{}", MyBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals("secret!", bean._secret); [EOL] }
public void testSimpleKeySer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.addKeySerializer(String.class, new ContextualKeySerializer("prefix")); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> input = new HashMap<String, Object>(); [EOL]     input.put("a", Integer.valueOf(3)); [EOL]     String json = mapper.writerWithType(TypeFactory.defaultInstance().constructMapType(HashMap.class, String.class, Object.class)).writeValueAsString(input); [EOL]     assertEquals("{\"prefix:a\":3}", json); [EOL] }
public void testSimpleKeySer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.addKeySerializer(String.class, new ContextualKeySerializer("prefix")); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> input = new HashMap<String, Object>(); [EOL]     input.put("a", Integer.valueOf(3)); [EOL]     String json = mapper.writerWithType(TypeFactory.defaultInstance().constructMapType(HashMap.class, String.class, Object.class)).writeValueAsString(input); [EOL]     assertEquals("{\"prefix:a\":3}", json); [EOL] }
public void testSimpleKeySer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.addKeySerializer(String.class, new ContextualKeySerializer("prefix")); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> input = new HashMap<String, Object>(); [EOL]     input.put("a", Integer.valueOf(3)); [EOL]     String json = mapper.writerWithType(TypeFactory.defaultInstance().constructMapType(HashMap.class, String.class, Object.class)).writeValueAsString(input); [EOL]     assertEquals("{\"prefix:a\":3}", json); [EOL] }
public void testSimpleKeySer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.addKeySerializer(String.class, new ContextualKeySerializer("prefix")); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> input = new HashMap<String, Object>(); [EOL]     input.put("a", Integer.valueOf(3)); [EOL]     String json = mapper.writerWithType(TypeFactory.defaultInstance().constructMapType(HashMap.class, String.class, Object.class)).writeValueAsString(input); [EOL]     assertEquals("{\"prefix:a\":3}", json); [EOL] }
public void testBase64Variants() throws Exception { [EOL]     final byte[] INPUT = "abcdefghijklmnopqrstuvwxyz1234567890abcdefghijklmnopqrstuvwxyz1234567890X".getBytes("UTF-8"); [EOL]     Assert.assertArrayEquals(INPUT, MAPPER.readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="), byte[].class)); [EOL]     ObjectReader reader = MAPPER.reader(byte[].class); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MIME_NO_LINEFEEDS).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="))); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MIME).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1\\ndnd4eXoxMjM0NTY3ODkwWA=="))); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MODIFIED_FOR_URL).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA"))); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.PEM).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamts\\nbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="))); [EOL] }
public void testBase64Variants() throws Exception { [EOL]     final byte[] INPUT = "abcdefghijklmnopqrstuvwxyz1234567890abcdefghijklmnopqrstuvwxyz1234567890X".getBytes("UTF-8"); [EOL]     Assert.assertArrayEquals(INPUT, MAPPER.readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="), byte[].class)); [EOL]     ObjectReader reader = MAPPER.reader(byte[].class); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MIME_NO_LINEFEEDS).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="))); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MIME).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1\\ndnd4eXoxMjM0NTY3ODkwWA=="))); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MODIFIED_FOR_URL).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA"))); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.PEM).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamts\\nbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="))); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals("java.util.Calendar", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.ArrayList<java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] }
public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals("java.util.Calendar", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.ArrayList<java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] }
public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals("java.util.Calendar", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.ArrayList<java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals("java.util.Calendar", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.ArrayList<java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] }
public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals("java.util.Calendar", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.ArrayList<java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] }
public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals("java.util.Calendar", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.ArrayList<java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] }
public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals("java.util.Calendar", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.ArrayList<java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] }
public void testRawCollections() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructRawCollectionType(ArrayList.class); [EOL]     assertTrue(type.isContainerType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getContentType()); [EOL]     type = tf.constructRawCollectionLikeType(String.class); [EOL]     assertTrue(type.isCollectionLikeType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getContentType()); [EOL] }
public void testRawCollections() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructRawCollectionType(ArrayList.class); [EOL]     assertTrue(type.isContainerType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getContentType()); [EOL]     type = tf.constructRawCollectionLikeType(String.class); [EOL]     assertTrue(type.isCollectionLikeType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getContentType()); [EOL] }
public void testRawCollections() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructRawCollectionType(ArrayList.class); [EOL]     assertTrue(type.isContainerType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getContentType()); [EOL]     type = tf.constructRawCollectionLikeType(String.class); [EOL]     assertTrue(type.isCollectionLikeType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getContentType()); [EOL] }
public void testRawCollections() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructRawCollectionType(ArrayList.class); [EOL]     assertTrue(type.isContainerType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getContentType()); [EOL]     type = tf.constructRawCollectionLikeType(String.class); [EOL]     assertTrue(type.isCollectionLikeType()); [EOL]     assertEquals(TypeFactory.unknownType(), type.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals("java.util.Calendar", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.ArrayList<java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] }
public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals("java.util.Calendar", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.ArrayList<java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] }
public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals("java.util.Calendar", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.ArrayList<java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] }
public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals("java.util.Calendar", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.ArrayList<java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] }
public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals("java.util.Calendar", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.ArrayList<java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] }
public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals("java.util.Calendar", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.ArrayList<java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] }
public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals("java.util.Calendar", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.ArrayList<java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] }
public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals("java.util.Calendar", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.ArrayList<java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals("java.util.Calendar", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.ArrayList<java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] }
public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals("java.util.Calendar", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.ArrayList<java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] }
public void testCanonicalNames() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType t = tf.constructType(java.util.Calendar.class); [EOL]     String can = t.toCanonical(); [EOL]     assertEquals("java.util.Calendar", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.ArrayList.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.ArrayList<java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructType(java.util.TreeMap.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.TreeMap<java.lang.Object,java.lang.Object>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL]     t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class); [EOL]     can = t.toCanonical(); [EOL]     assertEquals("java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>", can); [EOL]     assertEquals(t, tf.constructFromCanonical(can)); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testIssue352() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE, JsonTypeInfo.As.PROPERTY); [EOL]     DiscussBean d1 = new DiscussBean(); [EOL]     d1.subject = "mouse"; [EOL]     d1.weight = 88; [EOL]     DomainBeanWrapper wrapper = new DomainBeanWrapper(); [EOL]     wrapper.name = "mickey"; [EOL]     wrapper.myBean = d1; [EOL]     String json = mapper.writeValueAsString(wrapper); [EOL]     DomainBeanWrapper result = mapper.readValue(json, DomainBeanWrapper.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(wrapper.myBean); [EOL]     assertSame(DiscussBean.class, wrapper.myBean.getClass()); [EOL] }
public void testIssue352() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE, JsonTypeInfo.As.PROPERTY); [EOL]     DiscussBean d1 = new DiscussBean(); [EOL]     d1.subject = "mouse"; [EOL]     d1.weight = 88; [EOL]     DomainBeanWrapper wrapper = new DomainBeanWrapper(); [EOL]     wrapper.name = "mickey"; [EOL]     wrapper.myBean = d1; [EOL]     String json = mapper.writeValueAsString(wrapper); [EOL]     DomainBeanWrapper result = mapper.readValue(json, DomainBeanWrapper.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(wrapper.myBean); [EOL]     assertSame(DiscussBean.class, wrapper.myBean.getClass()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = "{ \"petType\": \"dog\",\n" + "\"pet\": { \"name\": \"Pluto\" }\n}"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals("dog", result.petType); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = "{ \"petType\": \"dog\",\n" + "\"pet\": { \"name\": \"Pluto\" }\n}"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals("dog", result.petType); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = "{ \"petType\": \"dog\",\n" + "\"pet\": { \"name\": \"Pluto\" }\n}"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals("dog", result.petType); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = "{ \"petType\": \"dog\",\n" + "\"pet\": { \"name\": \"Pluto\" }\n}"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals("dog", result.petType); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = "{ \"petType\": \"dog\",\n" + "\"pet\": { \"name\": \"Pluto\" }\n}"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals("dog", result.petType); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = "{ \"petType\": \"dog\",\n" + "\"pet\": { \"name\": \"Pluto\" }\n}"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals("dog", result.petType); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = "{ \"petType\": \"dog\",\n" + "\"pet\": { \"name\": \"Pluto\" }\n}"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals("dog", result.petType); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = "{ \"petType\": \"dog\",\n" + "\"pet\": { \"name\": \"Pluto\" }\n}"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals("dog", result.petType); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = "{ \"petType\": \"dog\",\n" + "\"pet\": { \"name\": \"Pluto\" }\n}"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals("dog", result.petType); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = "{ \"petType\": \"dog\",\n" + "\"pet\": { \"name\": \"Pluto\" }\n}"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals("dog", result.petType); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = "{ \"petType\": \"dog\",\n" + "\"pet\": { \"name\": \"Pluto\" }\n}"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals("dog", result.petType); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = "{ \"petType\": \"dog\",\n" + "\"pet\": { \"name\": \"Pluto\" }\n}"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals("dog", result.petType); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = "{ \"petType\": \"dog\",\n" + "\"pet\": { \"name\": \"Pluto\" }\n}"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals("dog", result.petType); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = "{ \"petType\": \"dog\",\n" + "\"pet\": { \"name\": \"Pluto\" }\n}"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals("dog", result.petType); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = "{ \"petType\": \"dog\",\n" + "\"pet\": { \"name\": \"Pluto\" }\n}"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals("dog", result.petType); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = "{ \"petType\": \"dog\",\n" + "\"pet\": { \"name\": \"Pluto\" }\n}"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals("dog", result.petType); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = "{ \"petType\": \"dog\",\n" + "\"pet\": { \"name\": \"Pluto\" }\n}"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals("dog", result.petType); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = "{ \"petType\": \"dog\",\n" + "\"pet\": { \"name\": \"Pluto\" }\n}"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals("dog", result.petType); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = "{ \"petType\": \"dog\",\n" + "\"pet\": { \"name\": \"Pluto\" }\n}"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals("dog", result.petType); [EOL] }
public void testIssue352() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE, JsonTypeInfo.As.PROPERTY); [EOL]     DiscussBean d1 = new DiscussBean(); [EOL]     d1.subject = "mouse"; [EOL]     d1.weight = 88; [EOL]     DomainBeanWrapper wrapper = new DomainBeanWrapper(); [EOL]     wrapper.name = "mickey"; [EOL]     wrapper.myBean = d1; [EOL]     String json = mapper.writeValueAsString(wrapper); [EOL]     DomainBeanWrapper result = mapper.readValue(json, DomainBeanWrapper.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(wrapper.myBean); [EOL]     assertSame(DiscussBean.class, wrapper.myBean.getClass()); [EOL] }
public void testIssue352() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE, JsonTypeInfo.As.PROPERTY); [EOL]     DiscussBean d1 = new DiscussBean(); [EOL]     d1.subject = "mouse"; [EOL]     d1.weight = 88; [EOL]     DomainBeanWrapper wrapper = new DomainBeanWrapper(); [EOL]     wrapper.name = "mickey"; [EOL]     wrapper.myBean = d1; [EOL]     String json = mapper.writeValueAsString(wrapper); [EOL]     DomainBeanWrapper result = mapper.readValue(json, DomainBeanWrapper.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(wrapper.myBean); [EOL]     assertSame(DiscussBean.class, wrapper.myBean.getClass()); [EOL] }
public void testIssue352() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE, JsonTypeInfo.As.PROPERTY); [EOL]     DiscussBean d1 = new DiscussBean(); [EOL]     d1.subject = "mouse"; [EOL]     d1.weight = 88; [EOL]     DomainBeanWrapper wrapper = new DomainBeanWrapper(); [EOL]     wrapper.name = "mickey"; [EOL]     wrapper.myBean = d1; [EOL]     String json = mapper.writeValueAsString(wrapper); [EOL]     DomainBeanWrapper result = mapper.readValue(json, DomainBeanWrapper.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(wrapper.myBean); [EOL]     assertSame(DiscussBean.class, wrapper.myBean.getClass()); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testDateNumeric() throws IOException { [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)); [EOL]     String json = MAPPER.writeValueAsString(new Date(199L)); [EOL]     assertEquals("199", json); [EOL] }
public void testDateNumeric() throws IOException { [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)); [EOL]     String json = MAPPER.writeValueAsString(new Date(199L)); [EOL]     assertEquals("199", json); [EOL] }
public void testDateNumeric() throws IOException { [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)); [EOL]     String json = MAPPER.writeValueAsString(new Date(199L)); [EOL]     assertEquals("199", json); [EOL] }
public void testSerializedAsMapWithPropertyAnnotations() throws IOException { [EOL]     MapWrapperSimple input = new MapWrapperSimple("a", "b"); [EOL]     assertEquals("{\"values\":{\"toString:a\":{\"value\":\"b\"}}}", MAPPER.writeValueAsString(input)); [EOL] }
public void testSerializedAsMapWithPropertyAnnotations() throws IOException { [EOL]     MapWrapperSimple input = new MapWrapperSimple("a", "b"); [EOL]     assertEquals("{\"values\":{\"toString:a\":{\"value\":\"b\"}}}", MAPPER.writeValueAsString(input)); [EOL] }
public void testSerializedAsMapWithPropertyAnnotations() throws IOException { [EOL]     MapWrapperSimple input = new MapWrapperSimple("a", "b"); [EOL]     assertEquals("{\"values\":{\"toString:a\":{\"value\":\"b\"}}}", MAPPER.writeValueAsString(input)); [EOL] }
public void testSerializedAsMapWithPropertyAnnotations() throws IOException { [EOL]     MapWrapperSimple input = new MapWrapperSimple("a", "b"); [EOL]     assertEquals("{\"values\":{\"toString:a\":{\"value\":\"b\"}}}", MAPPER.writeValueAsString(input)); [EOL] }
public void testInnerClassWithType() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(DefaultTyping.NON_FINAL); [EOL]     String json = mapper.writeValueAsString(new BeanWithAnon()); [EOL]     BeanWithAnon result = mapper.readValue(json, BeanWithAnon.class); [EOL]     assertEquals(BeanWithAnon.class, result.getClass()); [EOL] }
public void testInnerClassWithType() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(DefaultTyping.NON_FINAL); [EOL]     String json = mapper.writeValueAsString(new BeanWithAnon()); [EOL]     BeanWithAnon result = mapper.readValue(json, BeanWithAnon.class); [EOL]     assertEquals(BeanWithAnon.class, result.getClass()); [EOL] }
public void testArrayTypingNested() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(DefaultTyping.NON_CONCRETE_AND_ARRAYS); [EOL]     ArrayBean bean = new ArrayBean(new String[0][0]); [EOL]     String json = m.writeValueAsString(bean); [EOL]     ArrayBean result = m.readValue(json, ArrayBean.class); [EOL]     assertNotNull(result.values); [EOL]     assertEquals(String[][].class, result.values.getClass()); [EOL] }
public void testSimpleKeySer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.addKeySerializer(String.class, new ContextualKeySerializer("prefix")); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> input = new HashMap<String, Object>(); [EOL]     input.put("a", Integer.valueOf(3)); [EOL]     String json = mapper.writerWithType(TypeFactory.defaultInstance().constructMapType(HashMap.class, String.class, Object.class)).writeValueAsString(input); [EOL]     assertEquals("{\"prefix:a\":3}", json); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testEnumAsObject() throws Exception { [EOL]     Object[] input = new Object[] { Choice.YES }; [EOL]     Object[] input2 = new Object[] { ComplexChoice.MAYBE }; [EOL]     assertEquals("[\"YES\"]", serializeAsString(input)); [EOL]     assertEquals("[\"MAYBE\"]", serializeAsString(input2)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(); [EOL]     String json = m.writeValueAsString(input); [EOL]     assertEquals("[[\"" + Choice.class.getName() + "\",\"YES\"]]", json); [EOL]     Object[] output = m.readValue(json, Object[].class); [EOL]     assertEquals(1, output.length); [EOL]     assertEquals(Choice.YES, output[0]); [EOL]     json = m.writeValueAsString(input2); [EOL]     assertEquals("[[\"" + ComplexChoice.class.getName() + "\",\"MAYBE\"]]", json); [EOL]     output = m.readValue(json, Object[].class); [EOL]     assertEquals(1, output.length); [EOL]     assertEquals(ComplexChoice.MAYBE, output[0]); [EOL] }
public void testInnerClassWithType() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(DefaultTyping.NON_FINAL); [EOL]     String json = mapper.writeValueAsString(new BeanWithAnon()); [EOL]     BeanWithAnon result = mapper.readValue(json, BeanWithAnon.class); [EOL]     assertEquals(BeanWithAnon.class, result.getClass()); [EOL] }
public void testInnerClassWithType() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(DefaultTyping.NON_FINAL); [EOL]     String json = mapper.writeValueAsString(new BeanWithAnon()); [EOL]     BeanWithAnon result = mapper.readValue(json, BeanWithAnon.class); [EOL]     assertEquals(BeanWithAnon.class, result.getClass()); [EOL] }
public void testInnerClassWithType() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(DefaultTyping.NON_FINAL); [EOL]     String json = mapper.writeValueAsString(new BeanWithAnon()); [EOL]     BeanWithAnon result = mapper.readValue(json, BeanWithAnon.class); [EOL]     assertEquals(BeanWithAnon.class, result.getClass()); [EOL] }
public void testInnerClassWithType() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(DefaultTyping.NON_FINAL); [EOL]     String json = mapper.writeValueAsString(new BeanWithAnon()); [EOL]     BeanWithAnon result = mapper.readValue(json, BeanWithAnon.class); [EOL]     assertEquals(BeanWithAnon.class, result.getClass()); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testSkipChildrenWrt370() throws Exception { [EOL]     ObjectMapper o = new ObjectMapper(); [EOL]     ObjectNode n = o.createObjectNode(); [EOL]     n.putObject("inner").put("value", "test"); [EOL]     n.putObject("unknown").putNull("inner"); [EOL]     Jackson370Bean obj = o.readValue(n.traverse(), Jackson370Bean.class); [EOL]     assertNotNull(obj.inner); [EOL]     assertEquals("test", obj.inner.value); [EOL] }
public void testReadingArrayAsTree() throws IOException { [EOL]     JsonFactory jf = new MappingJsonFactory(); [EOL]     final String JSON = "[ 1, 2, false ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = jf.createParser(new StringReader(JSON)); [EOL]         if (i == 0) { [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         } [EOL]         JsonNode root = (JsonNode) jp.readValueAsTree(); [EOL]         jp.close(); [EOL]         assertTrue(root.isArray()); [EOL]         assertEquals(3, root.size()); [EOL]         assertEquals(1, root.get(0).intValue()); [EOL]         assertEquals(2, root.get(1).intValue()); [EOL]         assertFalse(root.get(2).booleanValue()); [EOL]     } [EOL] }
public void testReadingArrayAsTree() throws IOException { [EOL]     JsonFactory jf = new MappingJsonFactory(); [EOL]     final String JSON = "[ 1, 2, false ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = jf.createParser(new StringReader(JSON)); [EOL]         if (i == 0) { [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         } [EOL]         JsonNode root = (JsonNode) jp.readValueAsTree(); [EOL]         jp.close(); [EOL]         assertTrue(root.isArray()); [EOL]         assertEquals(3, root.size()); [EOL]         assertEquals(1, root.get(0).intValue()); [EOL]         assertEquals(2, root.get(1).intValue()); [EOL]         assertFalse(root.get(2).booleanValue()); [EOL]     } [EOL] }
public void testReadingArrayAsTree() throws IOException { [EOL]     JsonFactory jf = new MappingJsonFactory(); [EOL]     final String JSON = "[ 1, 2, false ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = jf.createParser(new StringReader(JSON)); [EOL]         if (i == 0) { [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         } [EOL]         JsonNode root = (JsonNode) jp.readValueAsTree(); [EOL]         jp.close(); [EOL]         assertTrue(root.isArray()); [EOL]         assertEquals(3, root.size()); [EOL]         assertEquals(1, root.get(0).intValue()); [EOL]         assertEquals(2, root.get(1).intValue()); [EOL]         assertFalse(root.get(2).booleanValue()); [EOL]     } [EOL] }
public void testReadingArrayAsTree() throws IOException { [EOL]     JsonFactory jf = new MappingJsonFactory(); [EOL]     final String JSON = "[ 1, 2, false ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = jf.createParser(new StringReader(JSON)); [EOL]         if (i == 0) { [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         } [EOL]         JsonNode root = (JsonNode) jp.readValueAsTree(); [EOL]         jp.close(); [EOL]         assertTrue(root.isArray()); [EOL]         assertEquals(3, root.size()); [EOL]         assertEquals(1, root.get(0).intValue()); [EOL]         assertEquals(2, root.get(1).intValue()); [EOL]         assertFalse(root.get(2).booleanValue()); [EOL]     } [EOL] }
public void testComplexObject() throws Exception { [EOL]     FixtureObject aTestObj = new FixtureObject(); [EOL]     ObjectMapper aMapper = new ObjectMapper(); [EOL]     StringWriter aWriter = new StringWriter(); [EOL]     JsonGenerator aGen = new JsonFactory().createGenerator(aWriter); [EOL]     aMapper.writeValue(aGen, aTestObj); [EOL]     aGen.close(); [EOL]     JsonParser jp = new JsonFactory().createParser(new StringReader(aWriter.toString())); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         assertEquals(JsonToken.FIELD_NAME, jp.getCurrentToken()); [EOL]         String name = jp.getCurrentName(); [EOL]         JsonToken t = jp.nextToken(); [EOL]         if (name.equals("uri")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("url")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testNull")) { [EOL]             assertToken(JsonToken.VALUE_NULL, t); [EOL]         } else if (name.equals("testString")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testBoolean")) { [EOL]             assertToken(JsonToken.VALUE_TRUE, t); [EOL]         } else if (name.equals("testEnum")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_ENUM.toString(), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_INT); [EOL]         } else if (name.equals("testLong")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_LONG); [EOL]         } else if (name.equals("testBigInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_BIGINT.longValue()); [EOL]         } else if (name.equals("testBigDecimal")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getText(), FixtureObject.VALUE_BIGDEC.toString()); [EOL]         } else if (name.equals("testCharacter")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(String.valueOf(FixtureObject.VALUE_CHAR), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testShort")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_SHORT); [EOL]         } else if (name.equals("testByte")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_BYTE); [EOL]         } else if (name.equals("testFloat")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDecimalValue().floatValue(), FixtureObject.VALUE_FLOAT); [EOL]         } else if (name.equals("testDouble")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDoubleValue(), FixtureObject.VALUE_DBL); [EOL]         } else if (name.equals("testStringBuffer")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testError")) { [EOL]             assertToken(JsonToken.START_OBJECT, t); [EOL]             while (jp.nextToken() == JsonToken.FIELD_NAME) { [EOL]                 name = jp.getCurrentName(); [EOL]                 if (name.equals("cause")) { [EOL]                     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]                 } else if (name.equals("message")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                     assertEquals(FixtureObject.VALUE_ERRTXT, getAndVerifyText(jp)); [EOL]                 } else if (name.equals("localizedMessage")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                 } else if (name.equals("stackTrace")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     int i = 0; [EOL]                     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                         if (i >= 100000) { [EOL]                             assertTrue("Probably run away loop in test. StackTrack Array was not properly closed.", false); [EOL]                         } [EOL]                     } [EOL]                 } else if (name.equals("suppressed")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]                 } else { [EOL]                     fail("Unexpected field name '" + name + "'"); [EOL]                 } [EOL]             } [EOL]             assertEquals(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]         } else { [EOL]             fail("Unexpected field, name '" + name + "'"); [EOL]         } [EOL]     } [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testComplexObject() throws Exception { [EOL]     FixtureObject aTestObj = new FixtureObject(); [EOL]     ObjectMapper aMapper = new ObjectMapper(); [EOL]     StringWriter aWriter = new StringWriter(); [EOL]     JsonGenerator aGen = new JsonFactory().createGenerator(aWriter); [EOL]     aMapper.writeValue(aGen, aTestObj); [EOL]     aGen.close(); [EOL]     JsonParser jp = new JsonFactory().createParser(new StringReader(aWriter.toString())); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         assertEquals(JsonToken.FIELD_NAME, jp.getCurrentToken()); [EOL]         String name = jp.getCurrentName(); [EOL]         JsonToken t = jp.nextToken(); [EOL]         if (name.equals("uri")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("url")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testNull")) { [EOL]             assertToken(JsonToken.VALUE_NULL, t); [EOL]         } else if (name.equals("testString")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testBoolean")) { [EOL]             assertToken(JsonToken.VALUE_TRUE, t); [EOL]         } else if (name.equals("testEnum")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_ENUM.toString(), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_INT); [EOL]         } else if (name.equals("testLong")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_LONG); [EOL]         } else if (name.equals("testBigInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_BIGINT.longValue()); [EOL]         } else if (name.equals("testBigDecimal")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getText(), FixtureObject.VALUE_BIGDEC.toString()); [EOL]         } else if (name.equals("testCharacter")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(String.valueOf(FixtureObject.VALUE_CHAR), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testShort")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_SHORT); [EOL]         } else if (name.equals("testByte")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_BYTE); [EOL]         } else if (name.equals("testFloat")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDecimalValue().floatValue(), FixtureObject.VALUE_FLOAT); [EOL]         } else if (name.equals("testDouble")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDoubleValue(), FixtureObject.VALUE_DBL); [EOL]         } else if (name.equals("testStringBuffer")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testError")) { [EOL]             assertToken(JsonToken.START_OBJECT, t); [EOL]             while (jp.nextToken() == JsonToken.FIELD_NAME) { [EOL]                 name = jp.getCurrentName(); [EOL]                 if (name.equals("cause")) { [EOL]                     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]                 } else if (name.equals("message")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                     assertEquals(FixtureObject.VALUE_ERRTXT, getAndVerifyText(jp)); [EOL]                 } else if (name.equals("localizedMessage")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                 } else if (name.equals("stackTrace")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     int i = 0; [EOL]                     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                         if (i >= 100000) { [EOL]                             assertTrue("Probably run away loop in test. StackTrack Array was not properly closed.", false); [EOL]                         } [EOL]                     } [EOL]                 } else if (name.equals("suppressed")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]                 } else { [EOL]                     fail("Unexpected field name '" + name + "'"); [EOL]                 } [EOL]             } [EOL]             assertEquals(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]         } else { [EOL]             fail("Unexpected field, name '" + name + "'"); [EOL]         } [EOL]     } [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testComplexObject() throws Exception { [EOL]     FixtureObject aTestObj = new FixtureObject(); [EOL]     ObjectMapper aMapper = new ObjectMapper(); [EOL]     StringWriter aWriter = new StringWriter(); [EOL]     JsonGenerator aGen = new JsonFactory().createGenerator(aWriter); [EOL]     aMapper.writeValue(aGen, aTestObj); [EOL]     aGen.close(); [EOL]     JsonParser jp = new JsonFactory().createParser(new StringReader(aWriter.toString())); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         assertEquals(JsonToken.FIELD_NAME, jp.getCurrentToken()); [EOL]         String name = jp.getCurrentName(); [EOL]         JsonToken t = jp.nextToken(); [EOL]         if (name.equals("uri")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("url")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testNull")) { [EOL]             assertToken(JsonToken.VALUE_NULL, t); [EOL]         } else if (name.equals("testString")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testBoolean")) { [EOL]             assertToken(JsonToken.VALUE_TRUE, t); [EOL]         } else if (name.equals("testEnum")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_ENUM.toString(), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_INT); [EOL]         } else if (name.equals("testLong")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_LONG); [EOL]         } else if (name.equals("testBigInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_BIGINT.longValue()); [EOL]         } else if (name.equals("testBigDecimal")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getText(), FixtureObject.VALUE_BIGDEC.toString()); [EOL]         } else if (name.equals("testCharacter")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(String.valueOf(FixtureObject.VALUE_CHAR), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testShort")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_SHORT); [EOL]         } else if (name.equals("testByte")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_BYTE); [EOL]         } else if (name.equals("testFloat")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDecimalValue().floatValue(), FixtureObject.VALUE_FLOAT); [EOL]         } else if (name.equals("testDouble")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDoubleValue(), FixtureObject.VALUE_DBL); [EOL]         } else if (name.equals("testStringBuffer")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testError")) { [EOL]             assertToken(JsonToken.START_OBJECT, t); [EOL]             while (jp.nextToken() == JsonToken.FIELD_NAME) { [EOL]                 name = jp.getCurrentName(); [EOL]                 if (name.equals("cause")) { [EOL]                     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]                 } else if (name.equals("message")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                     assertEquals(FixtureObject.VALUE_ERRTXT, getAndVerifyText(jp)); [EOL]                 } else if (name.equals("localizedMessage")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                 } else if (name.equals("stackTrace")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     int i = 0; [EOL]                     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                         if (i >= 100000) { [EOL]                             assertTrue("Probably run away loop in test. StackTrack Array was not properly closed.", false); [EOL]                         } [EOL]                     } [EOL]                 } else if (name.equals("suppressed")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]                 } else { [EOL]                     fail("Unexpected field name '" + name + "'"); [EOL]                 } [EOL]             } [EOL]             assertEquals(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]         } else { [EOL]             fail("Unexpected field, name '" + name + "'"); [EOL]         } [EOL]     } [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testComplexObject() throws Exception { [EOL]     FixtureObject aTestObj = new FixtureObject(); [EOL]     ObjectMapper aMapper = new ObjectMapper(); [EOL]     StringWriter aWriter = new StringWriter(); [EOL]     JsonGenerator aGen = new JsonFactory().createGenerator(aWriter); [EOL]     aMapper.writeValue(aGen, aTestObj); [EOL]     aGen.close(); [EOL]     JsonParser jp = new JsonFactory().createParser(new StringReader(aWriter.toString())); [EOL]     assertEquals(JsonToken.START_OBJECT, jp.nextToken()); [EOL]     while (jp.nextToken() != JsonToken.END_OBJECT) { [EOL]         assertEquals(JsonToken.FIELD_NAME, jp.getCurrentToken()); [EOL]         String name = jp.getCurrentName(); [EOL]         JsonToken t = jp.nextToken(); [EOL]         if (name.equals("uri")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("url")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testNull")) { [EOL]             assertToken(JsonToken.VALUE_NULL, t); [EOL]         } else if (name.equals("testString")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testBoolean")) { [EOL]             assertToken(JsonToken.VALUE_TRUE, t); [EOL]         } else if (name.equals("testEnum")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_ENUM.toString(), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_INT); [EOL]         } else if (name.equals("testLong")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_LONG); [EOL]         } else if (name.equals("testBigInteger")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getLongValue(), FixtureObject.VALUE_BIGINT.longValue()); [EOL]         } else if (name.equals("testBigDecimal")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getText(), FixtureObject.VALUE_BIGDEC.toString()); [EOL]         } else if (name.equals("testCharacter")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(String.valueOf(FixtureObject.VALUE_CHAR), getAndVerifyText(jp)); [EOL]         } else if (name.equals("testShort")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_SHORT); [EOL]         } else if (name.equals("testByte")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, t); [EOL]             assertEquals(jp.getIntValue(), FixtureObject.VALUE_BYTE); [EOL]         } else if (name.equals("testFloat")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDecimalValue().floatValue(), FixtureObject.VALUE_FLOAT); [EOL]         } else if (name.equals("testDouble")) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_FLOAT, t); [EOL]             assertEquals(jp.getDoubleValue(), FixtureObject.VALUE_DBL); [EOL]         } else if (name.equals("testStringBuffer")) { [EOL]             assertToken(JsonToken.VALUE_STRING, t); [EOL]             assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp)); [EOL]         } else if (name.equals("testError")) { [EOL]             assertToken(JsonToken.START_OBJECT, t); [EOL]             while (jp.nextToken() == JsonToken.FIELD_NAME) { [EOL]                 name = jp.getCurrentName(); [EOL]                 if (name.equals("cause")) { [EOL]                     assertEquals(JsonToken.VALUE_NULL, jp.nextToken()); [EOL]                 } else if (name.equals("message")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                     assertEquals(FixtureObject.VALUE_ERRTXT, getAndVerifyText(jp)); [EOL]                 } else if (name.equals("localizedMessage")) { [EOL]                     assertEquals(JsonToken.VALUE_STRING, jp.nextToken()); [EOL]                 } else if (name.equals("stackTrace")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     int i = 0; [EOL]                     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]                         if (i >= 100000) { [EOL]                             assertTrue("Probably run away loop in test. StackTrack Array was not properly closed.", false); [EOL]                         } [EOL]                     } [EOL]                 } else if (name.equals("suppressed")) { [EOL]                     assertEquals(JsonToken.START_ARRAY, jp.nextToken()); [EOL]                     assertEquals(JsonToken.END_ARRAY, jp.nextToken()); [EOL]                 } else { [EOL]                     fail("Unexpected field name '" + name + "'"); [EOL]                 } [EOL]             } [EOL]             assertEquals(JsonToken.END_OBJECT, jp.getCurrentToken()); [EOL]         } else { [EOL]             fail("Unexpected field, name '" + name + "'"); [EOL]         } [EOL]     } [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testInvalidWith() throws Exception { [EOL]     JsonNode root = MAPPER.createArrayNode(); [EOL]     try { [EOL]         root.with("prop"); [EOL]         fail("Expected exception"); [EOL]     } catch (UnsupportedOperationException e) { [EOL]         verifyException(e, "not of type ObjectNode"); [EOL]     } [EOL]     ObjectNode root2 = MAPPER.createObjectNode(); [EOL]     root2.put("prop", 13); [EOL]     try { [EOL]         root2.with("prop"); [EOL]         fail("Expected exception"); [EOL]     } catch (UnsupportedOperationException e) { [EOL]         verifyException(e, "has value that is not"); [EOL]     } [EOL] }
public void testDataBind() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     JsonNode tree = m.readTree("{ \"name\" : \"Tatu\", \n" + "\"magicNumber\" : 42," + "\"kids\" : [ \"Leo\", \"Lila\", \"Leia\" ] \n" + "}"); [EOL]     Person tatu = m.treeToValue(tree, Person.class); [EOL]     assertNotNull(tatu); [EOL]     assertEquals(42, tatu.magicNumber); [EOL]     assertEquals("Tatu", tatu.name); [EOL]     assertNotNull(tatu.kids); [EOL]     assertEquals(3, tatu.kids.size()); [EOL]     assertEquals("Leo", tatu.kids.get(0)); [EOL]     assertEquals("Lila", tatu.kids.get(1)); [EOL]     assertEquals("Leia", tatu.kids.get(2)); [EOL] }
public void testDataBind() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     JsonNode tree = m.readTree("{ \"name\" : \"Tatu\", \n" + "\"magicNumber\" : 42," + "\"kids\" : [ \"Leo\", \"Lila\", \"Leia\" ] \n" + "}"); [EOL]     Person tatu = m.treeToValue(tree, Person.class); [EOL]     assertNotNull(tatu); [EOL]     assertEquals(42, tatu.magicNumber); [EOL]     assertEquals("Tatu", tatu.name); [EOL]     assertNotNull(tatu.kids); [EOL]     assertEquals(3, tatu.kids.size()); [EOL]     assertEquals("Leo", tatu.kids.get(0)); [EOL]     assertEquals("Lila", tatu.kids.get(1)); [EOL]     assertEquals("Leia", tatu.kids.get(2)); [EOL] }
public void testDataBind() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     JsonNode tree = m.readTree("{ \"name\" : \"Tatu\", \n" + "\"magicNumber\" : 42," + "\"kids\" : [ \"Leo\", \"Lila\", \"Leia\" ] \n" + "}"); [EOL]     Person tatu = m.treeToValue(tree, Person.class); [EOL]     assertNotNull(tatu); [EOL]     assertEquals(42, tatu.magicNumber); [EOL]     assertEquals("Tatu", tatu.name); [EOL]     assertNotNull(tatu.kids); [EOL]     assertEquals(3, tatu.kids.size()); [EOL]     assertEquals("Leo", tatu.kids.get(0)); [EOL]     assertEquals("Lila", tatu.kids.get(1)); [EOL]     assertEquals("Leia", tatu.kids.get(2)); [EOL] }
public void testDataBind() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     JsonNode tree = m.readTree("{ \"name\" : \"Tatu\", \n" + "\"magicNumber\" : 42," + "\"kids\" : [ \"Leo\", \"Lila\", \"Leia\" ] \n" + "}"); [EOL]     Person tatu = m.treeToValue(tree, Person.class); [EOL]     assertNotNull(tatu); [EOL]     assertEquals(42, tatu.magicNumber); [EOL]     assertEquals("Tatu", tatu.name); [EOL]     assertNotNull(tatu.kids); [EOL]     assertEquals(3, tatu.kids.size()); [EOL]     assertEquals("Leo", tatu.kids.get(0)); [EOL]     assertEquals("Lila", tatu.kids.get(1)); [EOL]     assertEquals("Leia", tatu.kids.get(2)); [EOL] }
public void testIssue693() throws Exception { [EOL]     Parent parent = new Parent(); [EOL]     parent.addChild(new Child("foo")); [EOL]     parent.addChild(new Child("bar")); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     byte[] bytes = mapper.writeValueAsBytes(parent); [EOL]     Parent value = mapper.readValue(bytes, Parent.class); [EOL]     for (Child child : value.children) { [EOL]         assertEquals(value, child.getParent()); [EOL]     } [EOL] }
public void testIssue693() throws Exception { [EOL]     Parent parent = new Parent(); [EOL]     parent.addChild(new Child("foo")); [EOL]     parent.addChild(new Child("bar")); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     byte[] bytes = mapper.writeValueAsBytes(parent); [EOL]     Parent value = mapper.readValue(bytes, Parent.class); [EOL]     for (Child child : value.children) { [EOL]         assertEquals(value, child.getParent()); [EOL]     } [EOL] }
public void testIssue693() throws Exception { [EOL]     Parent parent = new Parent(); [EOL]     parent.addChild(new Child("foo")); [EOL]     parent.addChild(new Child("bar")); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     byte[] bytes = mapper.writeValueAsBytes(parent); [EOL]     Parent value = mapper.readValue(bytes, Parent.class); [EOL]     for (Child child : value.children) { [EOL]         assertEquals(value, child.getParent()); [EOL]     } [EOL] }
public void testIssue693() throws Exception { [EOL]     Parent parent = new Parent(); [EOL]     parent.addChild(new Child("foo")); [EOL]     parent.addChild(new Child("bar")); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     byte[] bytes = mapper.writeValueAsBytes(parent); [EOL]     Parent value = mapper.readValue(bytes, Parent.class); [EOL]     for (Child child : value.children) { [EOL]         assertEquals(value, child.getParent()); [EOL]     } [EOL] }
@SuppressWarnings("unused") [EOL] public void testSerializeAsExternalizable() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     ObjectOutputStream obs = new ObjectOutputStream(bytes); [EOL]     final MyPojo input = new MyPojo(13, "Foobar", new int[] { 1, 2, 3 }); [EOL]     obs.writeObject(input); [EOL]     obs.close(); [EOL]     byte[] ser = bytes.toByteArray(); [EOL]     byte[] json = MapperHolder.mapper().writeValueAsBytes(input); [EOL]     int ix = indexOf(ser, json); [EOL]     if (ix < 0) { [EOL]         fail("Serialization (" + ser.length + ") does NOT contain JSON (of " + json.length + ")"); [EOL]     } [EOL]     if (false) { [EOL]         bytes = new ByteArrayOutputStream(); [EOL]         obs = new ObjectOutputStream(bytes); [EOL]         MyPojoNative p = new MyPojoNative(13, "Foobar", new int[] { 1, 2, 3 }); [EOL]         obs.writeObject(p); [EOL]         obs.close(); [EOL]         System.out.println("Native size: " + bytes.size() + ", vs JSON: " + ser.length); [EOL]     } [EOL]     ObjectInputStream ins = new ObjectInputStream(new ByteArrayInputStream(ser)); [EOL]     MyPojo output = (MyPojo) ins.readObject(); [EOL]     ins.close(); [EOL]     assertNotNull(output); [EOL]     assertEquals(input, output); [EOL] }
@SuppressWarnings("unused") [EOL] public void testSerializeAsExternalizable() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     ObjectOutputStream obs = new ObjectOutputStream(bytes); [EOL]     final MyPojo input = new MyPojo(13, "Foobar", new int[] { 1, 2, 3 }); [EOL]     obs.writeObject(input); [EOL]     obs.close(); [EOL]     byte[] ser = bytes.toByteArray(); [EOL]     byte[] json = MapperHolder.mapper().writeValueAsBytes(input); [EOL]     int ix = indexOf(ser, json); [EOL]     if (ix < 0) { [EOL]         fail("Serialization (" + ser.length + ") does NOT contain JSON (of " + json.length + ")"); [EOL]     } [EOL]     if (false) { [EOL]         bytes = new ByteArrayOutputStream(); [EOL]         obs = new ObjectOutputStream(bytes); [EOL]         MyPojoNative p = new MyPojoNative(13, "Foobar", new int[] { 1, 2, 3 }); [EOL]         obs.writeObject(p); [EOL]         obs.close(); [EOL]         System.out.println("Native size: " + bytes.size() + ", vs JSON: " + ser.length); [EOL]     } [EOL]     ObjectInputStream ins = new ObjectInputStream(new ByteArrayInputStream(ser)); [EOL]     MyPojo output = (MyPojo) ins.readObject(); [EOL]     ins.close(); [EOL]     assertNotNull(output); [EOL]     assertEquals(input, output); [EOL] }
public void testIssue693() throws Exception { [EOL]     Parent parent = new Parent(); [EOL]     parent.addChild(new Child("foo")); [EOL]     parent.addChild(new Child("bar")); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     byte[] bytes = mapper.writeValueAsBytes(parent); [EOL]     Parent value = mapper.readValue(bytes, Parent.class); [EOL]     for (Child child : value.children) { [EOL]         assertEquals(value, child.getParent()); [EOL]     } [EOL] }
public void testIssue693() throws Exception { [EOL]     Parent parent = new Parent(); [EOL]     parent.addChild(new Child("foo")); [EOL]     parent.addChild(new Child("bar")); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     byte[] bytes = mapper.writeValueAsBytes(parent); [EOL]     Parent value = mapper.readValue(bytes, Parent.class); [EOL]     for (Child child : value.children) { [EOL]         assertEquals(value, child.getParent()); [EOL]     } [EOL] }
public void testIssue693() throws Exception { [EOL]     Parent parent = new Parent(); [EOL]     parent.addChild(new Child("foo")); [EOL]     parent.addChild(new Child("bar")); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     byte[] bytes = mapper.writeValueAsBytes(parent); [EOL]     Parent value = mapper.readValue(bytes, Parent.class); [EOL]     for (Child child : value.children) { [EOL]         assertEquals(value, child.getParent()); [EOL]     } [EOL] }
public void testOrderByKey() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertFalse(m.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)); [EOL]     LinkedHashMap<String, Integer> map = new LinkedHashMap<String, Integer>(); [EOL]     map.put("b", 3); [EOL]     map.put("a", 6); [EOL]     assertEquals("{\"b\":3,\"a\":6}", m.writeValueAsString(map)); [EOL]     assertEquals("{\"a\":6,\"b\":3}", m.writer(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS).writeValueAsString(map)); [EOL] }
public void testOrderByKey() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertFalse(m.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)); [EOL]     LinkedHashMap<String, Integer> map = new LinkedHashMap<String, Integer>(); [EOL]     map.put("b", 3); [EOL]     map.put("a", 6); [EOL]     assertEquals("{\"b\":3,\"a\":6}", m.writeValueAsString(map)); [EOL]     assertEquals("{\"a\":6,\"b\":3}", m.writer(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS).writeValueAsString(map)); [EOL] }
public void testDateUsingObjectWriter() throws IOException { [EOL]     DateFormat df = new SimpleDateFormat("yyyy-MM-dd'X'HH:mm:ss"); [EOL]     df.setTimeZone(TimeZone.getTimeZone("PST")); [EOL]     assertEquals(quote("1969-12-31X16:00:00"), MAPPER.writer(df).writeValueAsString(new Date(0L))); [EOL]     ObjectWriter w = MAPPER.writer((DateFormat) null); [EOL]     assertEquals("0", w.writeValueAsString(new Date(0L))); [EOL]     w = w.with(df); [EOL]     assertEquals(quote("1969-12-31X16:00:00"), w.writeValueAsString(new Date(0L))); [EOL]     w = w.with((DateFormat) null); [EOL]     assertEquals("0", w.writeValueAsString(new Date(0L))); [EOL] }
public void testDateUsingObjectWriter() throws IOException { [EOL]     DateFormat df = new SimpleDateFormat("yyyy-MM-dd'X'HH:mm:ss"); [EOL]     df.setTimeZone(TimeZone.getTimeZone("PST")); [EOL]     assertEquals(quote("1969-12-31X16:00:00"), MAPPER.writer(df).writeValueAsString(new Date(0L))); [EOL]     ObjectWriter w = MAPPER.writer((DateFormat) null); [EOL]     assertEquals("0", w.writeValueAsString(new Date(0L))); [EOL]     w = w.with(df); [EOL]     assertEquals(quote("1969-12-31X16:00:00"), w.writeValueAsString(new Date(0L))); [EOL]     w = w.with((DateFormat) null); [EOL]     assertEquals("0", w.writeValueAsString(new Date(0L))); [EOL] }
public void testIssue877() throws Exception { [EOL]     BaseInterfaceImpl one = new BaseInterfaceImpl(); [EOL]     BaseInterfaceImpl two = new BaseInterfaceImpl(); [EOL]     one.addInstance(two); [EOL]     two.addInstance(one); [EOL]     ListWrapper<BaseInterfaceImpl> myList = new ListWrapper<BaseInterfaceImpl>(); [EOL]     myList.add(one); [EOL]     myList.add(two); [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTypingAsProperty(ObjectMapper.DefaultTyping.NON_FINAL, "@class"); [EOL]     String json = om.writerWithDefaultPrettyPrinter().writeValueAsString(myList); [EOL]     ListWrapper<BaseInterfaceImpl> result; [EOL]     result = om.readValue(json, new TypeReference<ListWrapper<BaseInterfaceImpl>>() { [EOL]     }); [EOL]     assertNotNull(result); [EOL]     System.out.println("deserialised list size = " + result.size()); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testSchemaId() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class); [EOL]     String json = jsonSchema.toString().replaceAll("\"", "'"); [EOL]     assertEquals("{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}", json); [EOL] }
public void testSchemaId() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class); [EOL]     String json = jsonSchema.toString().replaceAll("\"", "'"); [EOL]     assertEquals("{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}", json); [EOL] }
public void testSchemaId() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class); [EOL]     String json = jsonSchema.toString().replaceAll("\"", "'"); [EOL]     assertEquals("{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}", json); [EOL] }
public void testIssue877() throws Exception { [EOL]     BaseInterfaceImpl one = new BaseInterfaceImpl(); [EOL]     BaseInterfaceImpl two = new BaseInterfaceImpl(); [EOL]     one.addInstance(two); [EOL]     two.addInstance(one); [EOL]     ListWrapper<BaseInterfaceImpl> myList = new ListWrapper<BaseInterfaceImpl>(); [EOL]     myList.add(one); [EOL]     myList.add(two); [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTypingAsProperty(ObjectMapper.DefaultTyping.NON_FINAL, "@class"); [EOL]     String json = om.writerWithDefaultPrettyPrinter().writeValueAsString(myList); [EOL]     ListWrapper<BaseInterfaceImpl> result; [EOL]     result = om.readValue(json, new TypeReference<ListWrapper<BaseInterfaceImpl>>() { [EOL]     }); [EOL]     assertNotNull(result); [EOL]     System.out.println("deserialised list size = " + result.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testCloseCloseable() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     CloseableBean bean = new CloseableBean(); [EOL]     m.writeValueAsString(bean); [EOL]     assertFalse(bean.wasClosed); [EOL]     m.configure(SerializationFeature.CLOSE_CLOSEABLE, true); [EOL]     bean = new CloseableBean(); [EOL]     m.writeValueAsString(bean); [EOL]     assertTrue(bean.wasClosed); [EOL]     bean = new CloseableBean(); [EOL]     m.writerWithType(CloseableBean.class).writeValueAsString(bean); [EOL]     assertTrue(bean.wasClosed); [EOL] }
public void testCloseCloseable() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     CloseableBean bean = new CloseableBean(); [EOL]     m.writeValueAsString(bean); [EOL]     assertFalse(bean.wasClosed); [EOL]     m.configure(SerializationFeature.CLOSE_CLOSEABLE, true); [EOL]     bean = new CloseableBean(); [EOL]     m.writeValueAsString(bean); [EOL]     assertTrue(bean.wasClosed); [EOL]     bean = new CloseableBean(); [EOL]     m.writerWithType(CloseableBean.class).writeValueAsString(bean); [EOL]     assertTrue(bean.wasClosed); [EOL] }
public void testCloseCloseable() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     CloseableBean bean = new CloseableBean(); [EOL]     m.writeValueAsString(bean); [EOL]     assertFalse(bean.wasClosed); [EOL]     m.configure(SerializationFeature.CLOSE_CLOSEABLE, true); [EOL]     bean = new CloseableBean(); [EOL]     m.writeValueAsString(bean); [EOL]     assertTrue(bean.wasClosed); [EOL]     bean = new CloseableBean(); [EOL]     m.writerWithType(CloseableBean.class).writeValueAsString(bean); [EOL]     assertTrue(bean.wasClosed); [EOL] }
public void testCloseCloseable() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     CloseableBean bean = new CloseableBean(); [EOL]     m.writeValueAsString(bean); [EOL]     assertFalse(bean.wasClosed); [EOL]     m.configure(SerializationFeature.CLOSE_CLOSEABLE, true); [EOL]     bean = new CloseableBean(); [EOL]     m.writeValueAsString(bean); [EOL]     assertTrue(bean.wasClosed); [EOL]     bean = new CloseableBean(); [EOL]     m.writerWithType(CloseableBean.class).writeValueAsString(bean); [EOL]     assertTrue(bean.wasClosed); [EOL] }
public void testSkipChildrenWrt370() throws Exception { [EOL]     ObjectMapper o = new ObjectMapper(); [EOL]     ObjectNode n = o.createObjectNode(); [EOL]     n.putObject("inner").put("value", "test"); [EOL]     n.putObject("unknown").putNull("inner"); [EOL]     Jackson370Bean obj = o.readValue(n.traverse(), Jackson370Bean.class); [EOL]     assertNotNull(obj.inner); [EOL]     assertEquals("test", obj.inner.value); [EOL] }
public void testSkipChildrenWrt370() throws Exception { [EOL]     ObjectMapper o = new ObjectMapper(); [EOL]     ObjectNode n = o.createObjectNode(); [EOL]     n.putObject("inner").put("value", "test"); [EOL]     n.putObject("unknown").putNull("inner"); [EOL]     Jackson370Bean obj = o.readValue(n.traverse(), Jackson370Bean.class); [EOL]     assertNotNull(obj.inner); [EOL]     assertEquals("test", obj.inner.value); [EOL] }
public void testSkipChildrenWrt370() throws Exception { [EOL]     ObjectMapper o = new ObjectMapper(); [EOL]     ObjectNode n = o.createObjectNode(); [EOL]     n.putObject("inner").put("value", "test"); [EOL]     n.putObject("unknown").putNull("inner"); [EOL]     Jackson370Bean obj = o.readValue(n.traverse(), Jackson370Bean.class); [EOL]     assertNotNull(obj.inner); [EOL]     assertEquals("test", obj.inner.value); [EOL] }
public void testSkipChildrenWrt370() throws Exception { [EOL]     ObjectMapper o = new ObjectMapper(); [EOL]     ObjectNode n = o.createObjectNode(); [EOL]     n.putObject("inner").put("value", "test"); [EOL]     n.putObject("unknown").putNull("inner"); [EOL]     Jackson370Bean obj = o.readValue(n.traverse(), Jackson370Bean.class); [EOL]     assertNotNull(obj.inner); [EOL]     assertEquals("test", obj.inner.value); [EOL] }
public void testNullHandling() throws Exception { [EOL]     JsonNode n = objectReader().readTree("null"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     n = objectMapper().readTree("null"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     ObjectNode root = (ObjectNode) objectReader().readTree("{\"x\":null}"); [EOL]     assertEquals(1, root.size()); [EOL]     n = root.get("x"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL] }
public void testCustomBeanInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyBean.class, new MyBeanInstantiator())); [EOL]     MyBean bean = mapper.readValue("{}", MyBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals("secret!", bean._secret); [EOL] }
public void testCustomBeanInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyBean.class, new MyBeanInstantiator())); [EOL]     MyBean bean = mapper.readValue("{}", MyBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals("secret!", bean._secret); [EOL] }
public void testCustomBeanInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyBean.class, new MyBeanInstantiator())); [EOL]     MyBean bean = mapper.readValue("{}", MyBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals("secret!", bean._secret); [EOL] }
public void testCustomBeanInstantiator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new MyModule(MyBean.class, new MyBeanInstantiator())); [EOL]     MyBean bean = mapper.readValue("{}", MyBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals("secret!", bean._secret); [EOL] }
public void testBoolean() { [EOL]     BooleanNode f = BooleanNode.getFalse(); [EOL]     assertNotNull(f); [EOL]     assertTrue(f.isBoolean()); [EOL]     assertSame(f, BooleanNode.valueOf(false)); [EOL]     assertStandardEquals(f); [EOL]     assertFalse(f.booleanValue()); [EOL]     assertFalse(f.asBoolean()); [EOL]     assertEquals("false", f.asText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, f.asToken()); [EOL]     BooleanNode t = BooleanNode.getTrue(); [EOL]     assertNotNull(t); [EOL]     assertTrue(t.isBoolean()); [EOL]     assertSame(t, BooleanNode.valueOf(true)); [EOL]     assertStandardEquals(t); [EOL]     assertTrue(t.booleanValue()); [EOL]     assertTrue(t.asBoolean()); [EOL]     assertEquals("true", t.asText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, t.asToken()); [EOL]     assertNodeNumbers(f, 0, 0.0); [EOL]     assertNodeNumbers(t, 1, 1.0); [EOL] }
public void testBoolean() { [EOL]     BooleanNode f = BooleanNode.getFalse(); [EOL]     assertNotNull(f); [EOL]     assertTrue(f.isBoolean()); [EOL]     assertSame(f, BooleanNode.valueOf(false)); [EOL]     assertStandardEquals(f); [EOL]     assertFalse(f.booleanValue()); [EOL]     assertFalse(f.asBoolean()); [EOL]     assertEquals("false", f.asText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, f.asToken()); [EOL]     BooleanNode t = BooleanNode.getTrue(); [EOL]     assertNotNull(t); [EOL]     assertTrue(t.isBoolean()); [EOL]     assertSame(t, BooleanNode.valueOf(true)); [EOL]     assertStandardEquals(t); [EOL]     assertTrue(t.booleanValue()); [EOL]     assertTrue(t.asBoolean()); [EOL]     assertEquals("true", t.asText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, t.asToken()); [EOL]     assertNodeNumbers(f, 0, 0.0); [EOL]     assertNodeNumbers(t, 1, 1.0); [EOL] }
public void testBoolean() { [EOL]     BooleanNode f = BooleanNode.getFalse(); [EOL]     assertNotNull(f); [EOL]     assertTrue(f.isBoolean()); [EOL]     assertSame(f, BooleanNode.valueOf(false)); [EOL]     assertStandardEquals(f); [EOL]     assertFalse(f.booleanValue()); [EOL]     assertFalse(f.asBoolean()); [EOL]     assertEquals("false", f.asText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, f.asToken()); [EOL]     BooleanNode t = BooleanNode.getTrue(); [EOL]     assertNotNull(t); [EOL]     assertTrue(t.isBoolean()); [EOL]     assertSame(t, BooleanNode.valueOf(true)); [EOL]     assertStandardEquals(t); [EOL]     assertTrue(t.booleanValue()); [EOL]     assertTrue(t.asBoolean()); [EOL]     assertEquals("true", t.asText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, t.asToken()); [EOL]     assertNodeNumbers(f, 0, 0.0); [EOL]     assertNodeNumbers(t, 1, 1.0); [EOL] }
public void testBoolean() { [EOL]     BooleanNode f = BooleanNode.getFalse(); [EOL]     assertNotNull(f); [EOL]     assertTrue(f.isBoolean()); [EOL]     assertSame(f, BooleanNode.valueOf(false)); [EOL]     assertStandardEquals(f); [EOL]     assertFalse(f.booleanValue()); [EOL]     assertFalse(f.asBoolean()); [EOL]     assertEquals("false", f.asText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, f.asToken()); [EOL]     BooleanNode t = BooleanNode.getTrue(); [EOL]     assertNotNull(t); [EOL]     assertTrue(t.isBoolean()); [EOL]     assertSame(t, BooleanNode.valueOf(true)); [EOL]     assertStandardEquals(t); [EOL]     assertTrue(t.booleanValue()); [EOL]     assertTrue(t.asBoolean()); [EOL]     assertEquals("true", t.asText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, t.asToken()); [EOL]     assertNodeNumbers(f, 0, 0.0); [EOL]     assertNodeNumbers(t, 1, 1.0); [EOL] }
public void testBoolean() { [EOL]     BooleanNode f = BooleanNode.getFalse(); [EOL]     assertNotNull(f); [EOL]     assertTrue(f.isBoolean()); [EOL]     assertSame(f, BooleanNode.valueOf(false)); [EOL]     assertStandardEquals(f); [EOL]     assertFalse(f.booleanValue()); [EOL]     assertFalse(f.asBoolean()); [EOL]     assertEquals("false", f.asText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, f.asToken()); [EOL]     BooleanNode t = BooleanNode.getTrue(); [EOL]     assertNotNull(t); [EOL]     assertTrue(t.isBoolean()); [EOL]     assertSame(t, BooleanNode.valueOf(true)); [EOL]     assertStandardEquals(t); [EOL]     assertTrue(t.booleanValue()); [EOL]     assertTrue(t.asBoolean()); [EOL]     assertEquals("true", t.asText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, t.asToken()); [EOL]     assertNodeNumbers(f, 0, 0.0); [EOL]     assertNodeNumbers(t, 1, 1.0); [EOL] }
public void testBoolean() { [EOL]     BooleanNode f = BooleanNode.getFalse(); [EOL]     assertNotNull(f); [EOL]     assertTrue(f.isBoolean()); [EOL]     assertSame(f, BooleanNode.valueOf(false)); [EOL]     assertStandardEquals(f); [EOL]     assertFalse(f.booleanValue()); [EOL]     assertFalse(f.asBoolean()); [EOL]     assertEquals("false", f.asText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, f.asToken()); [EOL]     BooleanNode t = BooleanNode.getTrue(); [EOL]     assertNotNull(t); [EOL]     assertTrue(t.isBoolean()); [EOL]     assertSame(t, BooleanNode.valueOf(true)); [EOL]     assertStandardEquals(t); [EOL]     assertTrue(t.booleanValue()); [EOL]     assertTrue(t.asBoolean()); [EOL]     assertEquals("true", t.asText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, t.asToken()); [EOL]     assertNodeNumbers(f, 0, 0.0); [EOL]     assertNodeNumbers(t, 1, 1.0); [EOL] }
public void testBoolean() { [EOL]     BooleanNode f = BooleanNode.getFalse(); [EOL]     assertNotNull(f); [EOL]     assertTrue(f.isBoolean()); [EOL]     assertSame(f, BooleanNode.valueOf(false)); [EOL]     assertStandardEquals(f); [EOL]     assertFalse(f.booleanValue()); [EOL]     assertFalse(f.asBoolean()); [EOL]     assertEquals("false", f.asText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, f.asToken()); [EOL]     BooleanNode t = BooleanNode.getTrue(); [EOL]     assertNotNull(t); [EOL]     assertTrue(t.isBoolean()); [EOL]     assertSame(t, BooleanNode.valueOf(true)); [EOL]     assertStandardEquals(t); [EOL]     assertTrue(t.booleanValue()); [EOL]     assertTrue(t.asBoolean()); [EOL]     assertEquals("true", t.asText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, t.asToken()); [EOL]     assertNodeNumbers(f, 0, 0.0); [EOL]     assertNodeNumbers(t, 1, 1.0); [EOL] }
public void testBoolean() { [EOL]     BooleanNode f = BooleanNode.getFalse(); [EOL]     assertNotNull(f); [EOL]     assertTrue(f.isBoolean()); [EOL]     assertSame(f, BooleanNode.valueOf(false)); [EOL]     assertStandardEquals(f); [EOL]     assertFalse(f.booleanValue()); [EOL]     assertFalse(f.asBoolean()); [EOL]     assertEquals("false", f.asText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, f.asToken()); [EOL]     BooleanNode t = BooleanNode.getTrue(); [EOL]     assertNotNull(t); [EOL]     assertTrue(t.isBoolean()); [EOL]     assertSame(t, BooleanNode.valueOf(true)); [EOL]     assertStandardEquals(t); [EOL]     assertTrue(t.booleanValue()); [EOL]     assertTrue(t.asBoolean()); [EOL]     assertEquals("true", t.asText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, t.asToken()); [EOL]     assertNodeNumbers(f, 0, 0.0); [EOL]     assertNodeNumbers(t, 1, 1.0); [EOL] }
public void testBoolean() { [EOL]     BooleanNode f = BooleanNode.getFalse(); [EOL]     assertNotNull(f); [EOL]     assertTrue(f.isBoolean()); [EOL]     assertSame(f, BooleanNode.valueOf(false)); [EOL]     assertStandardEquals(f); [EOL]     assertFalse(f.booleanValue()); [EOL]     assertFalse(f.asBoolean()); [EOL]     assertEquals("false", f.asText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, f.asToken()); [EOL]     BooleanNode t = BooleanNode.getTrue(); [EOL]     assertNotNull(t); [EOL]     assertTrue(t.isBoolean()); [EOL]     assertSame(t, BooleanNode.valueOf(true)); [EOL]     assertStandardEquals(t); [EOL]     assertTrue(t.booleanValue()); [EOL]     assertTrue(t.asBoolean()); [EOL]     assertEquals("true", t.asText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, t.asToken()); [EOL]     assertNodeNumbers(f, 0, 0.0); [EOL]     assertNodeNumbers(t, 1, 1.0); [EOL] }
public void testBoolean() { [EOL]     BooleanNode f = BooleanNode.getFalse(); [EOL]     assertNotNull(f); [EOL]     assertTrue(f.isBoolean()); [EOL]     assertSame(f, BooleanNode.valueOf(false)); [EOL]     assertStandardEquals(f); [EOL]     assertFalse(f.booleanValue()); [EOL]     assertFalse(f.asBoolean()); [EOL]     assertEquals("false", f.asText()); [EOL]     assertEquals(JsonToken.VALUE_FALSE, f.asToken()); [EOL]     BooleanNode t = BooleanNode.getTrue(); [EOL]     assertNotNull(t); [EOL]     assertTrue(t.isBoolean()); [EOL]     assertSame(t, BooleanNode.valueOf(true)); [EOL]     assertStandardEquals(t); [EOL]     assertTrue(t.booleanValue()); [EOL]     assertTrue(t.asBoolean()); [EOL]     assertEquals("true", t.asText()); [EOL]     assertEquals(JsonToken.VALUE_TRUE, t.asToken()); [EOL]     assertNodeNumbers(f, 0, 0.0); [EOL]     assertNodeNumbers(t, 1, 1.0); [EOL] }
public void testDeepUnwrappingSerialize() throws Exception { [EOL]     assertEquals("{\"name\":\"Tatu\",\"x\":1,\"y\":2}", mapper.writeValueAsString(new DeepUnwrapping("Tatu", 1, 2))); [EOL] }
public void testDeepUnwrappingSerialize() throws Exception { [EOL]     assertEquals("{\"name\":\"Tatu\",\"x\":1,\"y\":2}", mapper.writeValueAsString(new DeepUnwrapping("Tatu", 1, 2))); [EOL] }
public void testDeepUnwrappingSerialize() throws Exception { [EOL]     assertEquals("{\"name\":\"Tatu\",\"x\":1,\"y\":2}", mapper.writeValueAsString(new DeepUnwrapping("Tatu", 1, 2))); [EOL] }
public void testDeepUnwrappingSerialize() throws Exception { [EOL]     assertEquals("{\"name\":\"Tatu\",\"x\":1,\"y\":2}", mapper.writeValueAsString(new DeepUnwrapping("Tatu", 1, 2))); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testBooleanWrapper() throws Exception { [EOL]     Boolean result = MAPPER.readValue(new StringReader("true"), Boolean.class); [EOL]     assertEquals(Boolean.TRUE, result); [EOL]     result = MAPPER.readValue(new StringReader("false"), Boolean.class); [EOL]     assertEquals(Boolean.FALSE, result); [EOL]     result = MAPPER.readValue(new StringReader("0"), Boolean.class); [EOL]     assertEquals(Boolean.FALSE, result); [EOL]     result = MAPPER.readValue(new StringReader("1"), Boolean.class); [EOL]     assertEquals(Boolean.TRUE, result); [EOL] }
public void testBooleanWrapper() throws Exception { [EOL]     Boolean result = MAPPER.readValue(new StringReader("true"), Boolean.class); [EOL]     assertEquals(Boolean.TRUE, result); [EOL]     result = MAPPER.readValue(new StringReader("false"), Boolean.class); [EOL]     assertEquals(Boolean.FALSE, result); [EOL]     result = MAPPER.readValue(new StringReader("0"), Boolean.class); [EOL]     assertEquals(Boolean.FALSE, result); [EOL]     result = MAPPER.readValue(new StringReader("1"), Boolean.class); [EOL]     assertEquals(Boolean.TRUE, result); [EOL] }
public void testBooleanWrapper() throws Exception { [EOL]     Boolean result = MAPPER.readValue(new StringReader("true"), Boolean.class); [EOL]     assertEquals(Boolean.TRUE, result); [EOL]     result = MAPPER.readValue(new StringReader("false"), Boolean.class); [EOL]     assertEquals(Boolean.FALSE, result); [EOL]     result = MAPPER.readValue(new StringReader("0"), Boolean.class); [EOL]     assertEquals(Boolean.FALSE, result); [EOL]     result = MAPPER.readValue(new StringReader("1"), Boolean.class); [EOL]     assertEquals(Boolean.TRUE, result); [EOL] }
public void testBooleanWrapper() throws Exception { [EOL]     Boolean result = MAPPER.readValue(new StringReader("true"), Boolean.class); [EOL]     assertEquals(Boolean.TRUE, result); [EOL]     result = MAPPER.readValue(new StringReader("false"), Boolean.class); [EOL]     assertEquals(Boolean.FALSE, result); [EOL]     result = MAPPER.readValue(new StringReader("0"), Boolean.class); [EOL]     assertEquals(Boolean.FALSE, result); [EOL]     result = MAPPER.readValue(new StringReader("1"), Boolean.class); [EOL]     assertEquals(Boolean.TRUE, result); [EOL] }
public void testBooleanWrapper() throws Exception { [EOL]     Boolean result = MAPPER.readValue(new StringReader("true"), Boolean.class); [EOL]     assertEquals(Boolean.TRUE, result); [EOL]     result = MAPPER.readValue(new StringReader("false"), Boolean.class); [EOL]     assertEquals(Boolean.FALSE, result); [EOL]     result = MAPPER.readValue(new StringReader("0"), Boolean.class); [EOL]     assertEquals(Boolean.FALSE, result); [EOL]     result = MAPPER.readValue(new StringReader("1"), Boolean.class); [EOL]     assertEquals(Boolean.TRUE, result); [EOL] }
public void testBooleanWrapper() throws Exception { [EOL]     Boolean result = MAPPER.readValue(new StringReader("true"), Boolean.class); [EOL]     assertEquals(Boolean.TRUE, result); [EOL]     result = MAPPER.readValue(new StringReader("false"), Boolean.class); [EOL]     assertEquals(Boolean.FALSE, result); [EOL]     result = MAPPER.readValue(new StringReader("0"), Boolean.class); [EOL]     assertEquals(Boolean.FALSE, result); [EOL]     result = MAPPER.readValue(new StringReader("1"), Boolean.class); [EOL]     assertEquals(Boolean.TRUE, result); [EOL] }
public void testBooleanWrapper() throws Exception { [EOL]     Boolean result = MAPPER.readValue(new StringReader("true"), Boolean.class); [EOL]     assertEquals(Boolean.TRUE, result); [EOL]     result = MAPPER.readValue(new StringReader("false"), Boolean.class); [EOL]     assertEquals(Boolean.FALSE, result); [EOL]     result = MAPPER.readValue(new StringReader("0"), Boolean.class); [EOL]     assertEquals(Boolean.FALSE, result); [EOL]     result = MAPPER.readValue(new StringReader("1"), Boolean.class); [EOL]     assertEquals(Boolean.TRUE, result); [EOL] }
public void testBooleanWrapper() throws Exception { [EOL]     Boolean result = MAPPER.readValue(new StringReader("true"), Boolean.class); [EOL]     assertEquals(Boolean.TRUE, result); [EOL]     result = MAPPER.readValue(new StringReader("false"), Boolean.class); [EOL]     assertEquals(Boolean.FALSE, result); [EOL]     result = MAPPER.readValue(new StringReader("0"), Boolean.class); [EOL]     assertEquals(Boolean.FALSE, result); [EOL]     result = MAPPER.readValue(new StringReader("1"), Boolean.class); [EOL]     assertEquals(Boolean.TRUE, result); [EOL] }
public void testBooleanWrapper() throws Exception { [EOL]     Boolean result = MAPPER.readValue(new StringReader("true"), Boolean.class); [EOL]     assertEquals(Boolean.TRUE, result); [EOL]     result = MAPPER.readValue(new StringReader("false"), Boolean.class); [EOL]     assertEquals(Boolean.FALSE, result); [EOL]     result = MAPPER.readValue(new StringReader("0"), Boolean.class); [EOL]     assertEquals(Boolean.FALSE, result); [EOL]     result = MAPPER.readValue(new StringReader("1"), Boolean.class); [EOL]     assertEquals(Boolean.TRUE, result); [EOL] }
public void testBooleanWrapper() throws Exception { [EOL]     Boolean result = MAPPER.readValue(new StringReader("true"), Boolean.class); [EOL]     assertEquals(Boolean.TRUE, result); [EOL]     result = MAPPER.readValue(new StringReader("false"), Boolean.class); [EOL]     assertEquals(Boolean.FALSE, result); [EOL]     result = MAPPER.readValue(new StringReader("0"), Boolean.class); [EOL]     assertEquals(Boolean.FALSE, result); [EOL]     result = MAPPER.readValue(new StringReader("1"), Boolean.class); [EOL]     assertEquals(Boolean.TRUE, result); [EOL] }
public void testBooleanWrapper() throws Exception { [EOL]     Boolean result = MAPPER.readValue(new StringReader("true"), Boolean.class); [EOL]     assertEquals(Boolean.TRUE, result); [EOL]     result = MAPPER.readValue(new StringReader("false"), Boolean.class); [EOL]     assertEquals(Boolean.FALSE, result); [EOL]     result = MAPPER.readValue(new StringReader("0"), Boolean.class); [EOL]     assertEquals(Boolean.FALSE, result); [EOL]     result = MAPPER.readValue(new StringReader("1"), Boolean.class); [EOL]     assertEquals(Boolean.TRUE, result); [EOL] }
public void testByteWrapper() throws Exception { [EOL]     Byte result = MAPPER.readValue(new StringReader("   -42\t"), Byte.class); [EOL]     assertEquals(Byte.valueOf((byte) -42), result); [EOL]     result = MAPPER.readValue(new StringReader(" \"-12\""), Byte.class); [EOL]     assertEquals(Byte.valueOf((byte) -12), result); [EOL]     result = MAPPER.readValue(new StringReader(" 39.07"), Byte.class); [EOL]     assertEquals(Byte.valueOf((byte) 39), result); [EOL] }
public void testByteWrapper() throws Exception { [EOL]     Byte result = MAPPER.readValue(new StringReader("   -42\t"), Byte.class); [EOL]     assertEquals(Byte.valueOf((byte) -42), result); [EOL]     result = MAPPER.readValue(new StringReader(" \"-12\""), Byte.class); [EOL]     assertEquals(Byte.valueOf((byte) -12), result); [EOL]     result = MAPPER.readValue(new StringReader(" 39.07"), Byte.class); [EOL]     assertEquals(Byte.valueOf((byte) 39), result); [EOL] }
public void testByteWrapper() throws Exception { [EOL]     Byte result = MAPPER.readValue(new StringReader("   -42\t"), Byte.class); [EOL]     assertEquals(Byte.valueOf((byte) -42), result); [EOL]     result = MAPPER.readValue(new StringReader(" \"-12\""), Byte.class); [EOL]     assertEquals(Byte.valueOf((byte) -12), result); [EOL]     result = MAPPER.readValue(new StringReader(" 39.07"), Byte.class); [EOL]     assertEquals(Byte.valueOf((byte) 39), result); [EOL] }
public void testByteWrapper() throws Exception { [EOL]     Byte result = MAPPER.readValue(new StringReader("   -42\t"), Byte.class); [EOL]     assertEquals(Byte.valueOf((byte) -42), result); [EOL]     result = MAPPER.readValue(new StringReader(" \"-12\""), Byte.class); [EOL]     assertEquals(Byte.valueOf((byte) -12), result); [EOL]     result = MAPPER.readValue(new StringReader(" 39.07"), Byte.class); [EOL]     assertEquals(Byte.valueOf((byte) 39), result); [EOL] }
public void testByteWrapper() throws Exception { [EOL]     Byte result = MAPPER.readValue(new StringReader("   -42\t"), Byte.class); [EOL]     assertEquals(Byte.valueOf((byte) -42), result); [EOL]     result = MAPPER.readValue(new StringReader(" \"-12\""), Byte.class); [EOL]     assertEquals(Byte.valueOf((byte) -12), result); [EOL]     result = MAPPER.readValue(new StringReader(" 39.07"), Byte.class); [EOL]     assertEquals(Byte.valueOf((byte) 39), result); [EOL] }
public void testByteWrapper() throws Exception { [EOL]     Byte result = MAPPER.readValue(new StringReader("   -42\t"), Byte.class); [EOL]     assertEquals(Byte.valueOf((byte) -42), result); [EOL]     result = MAPPER.readValue(new StringReader(" \"-12\""), Byte.class); [EOL]     assertEquals(Byte.valueOf((byte) -12), result); [EOL]     result = MAPPER.readValue(new StringReader(" 39.07"), Byte.class); [EOL]     assertEquals(Byte.valueOf((byte) 39), result); [EOL] }
public void testByteWrapper() throws Exception { [EOL]     Byte result = MAPPER.readValue(new StringReader("   -42\t"), Byte.class); [EOL]     assertEquals(Byte.valueOf((byte) -42), result); [EOL]     result = MAPPER.readValue(new StringReader(" \"-12\""), Byte.class); [EOL]     assertEquals(Byte.valueOf((byte) -12), result); [EOL]     result = MAPPER.readValue(new StringReader(" 39.07"), Byte.class); [EOL]     assertEquals(Byte.valueOf((byte) 39), result); [EOL] }
public void testByteWrapper() throws Exception { [EOL]     Byte result = MAPPER.readValue(new StringReader("   -42\t"), Byte.class); [EOL]     assertEquals(Byte.valueOf((byte) -42), result); [EOL]     result = MAPPER.readValue(new StringReader(" \"-12\""), Byte.class); [EOL]     assertEquals(Byte.valueOf((byte) -12), result); [EOL]     result = MAPPER.readValue(new StringReader(" 39.07"), Byte.class); [EOL]     assertEquals(Byte.valueOf((byte) 39), result); [EOL] }
public void testTypeAsArray() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(Animal.class, TypeWithArray.class); [EOL]     String JSON = "[\"" + Dog.class.getName() + "\", " + asJSONObjectValueString(m, "name", "Martti", "boneCount", "11") + " ]"; [EOL]     Animal a = m.readValue(JSON, Animal.class); [EOL]     assertEquals(Dog.class, a.getClass()); [EOL]     Dog d = (Dog) a; [EOL]     assertEquals("Martti", d.name); [EOL]     assertEquals(11, d.boneCount); [EOL] }
public void testFloatWrapper() throws Exception { [EOL]     String[] STRS = new String[] { "1.0", "0.0", "-0.3", "0.7", "42.012", "-999.0", NAN_STRING }; [EOL]     for (String str : STRS) { [EOL]         Float exp = Float.valueOf(str); [EOL]         Float result; [EOL]         if (NAN_STRING != str) { [EOL]             result = MAPPER.readValue(new StringReader(str), Float.class); [EOL]             assertEquals(exp, result); [EOL]         } [EOL]         result = MAPPER.readValue(new StringReader(" \"" + str + "\""), Float.class); [EOL]         assertEquals(exp, result); [EOL]     } [EOL] }
public void testFloatWrapper() throws Exception { [EOL]     String[] STRS = new String[] { "1.0", "0.0", "-0.3", "0.7", "42.012", "-999.0", NAN_STRING }; [EOL]     for (String str : STRS) { [EOL]         Float exp = Float.valueOf(str); [EOL]         Float result; [EOL]         if (NAN_STRING != str) { [EOL]             result = MAPPER.readValue(new StringReader(str), Float.class); [EOL]             assertEquals(exp, result); [EOL]         } [EOL]         result = MAPPER.readValue(new StringReader(" \"" + str + "\""), Float.class); [EOL]         assertEquals(exp, result); [EOL]     } [EOL] }
public void testFloatWrapper() throws Exception { [EOL]     String[] STRS = new String[] { "1.0", "0.0", "-0.3", "0.7", "42.012", "-999.0", NAN_STRING }; [EOL]     for (String str : STRS) { [EOL]         Float exp = Float.valueOf(str); [EOL]         Float result; [EOL]         if (NAN_STRING != str) { [EOL]             result = MAPPER.readValue(new StringReader(str), Float.class); [EOL]             assertEquals(exp, result); [EOL]         } [EOL]         result = MAPPER.readValue(new StringReader(" \"" + str + "\""), Float.class); [EOL]         assertEquals(exp, result); [EOL]     } [EOL] }
public void testFloatWrapper() throws Exception { [EOL]     String[] STRS = new String[] { "1.0", "0.0", "-0.3", "0.7", "42.012", "-999.0", NAN_STRING }; [EOL]     for (String str : STRS) { [EOL]         Float exp = Float.valueOf(str); [EOL]         Float result; [EOL]         if (NAN_STRING != str) { [EOL]             result = MAPPER.readValue(new StringReader(str), Float.class); [EOL]             assertEquals(exp, result); [EOL]         } [EOL]         result = MAPPER.readValue(new StringReader(" \"" + str + "\""), Float.class); [EOL]         assertEquals(exp, result); [EOL]     } [EOL] }
public void testFloatWrapper() throws Exception { [EOL]     String[] STRS = new String[] { "1.0", "0.0", "-0.3", "0.7", "42.012", "-999.0", NAN_STRING }; [EOL]     for (String str : STRS) { [EOL]         Float exp = Float.valueOf(str); [EOL]         Float result; [EOL]         if (NAN_STRING != str) { [EOL]             result = MAPPER.readValue(new StringReader(str), Float.class); [EOL]             assertEquals(exp, result); [EOL]         } [EOL]         result = MAPPER.readValue(new StringReader(" \"" + str + "\""), Float.class); [EOL]         assertEquals(exp, result); [EOL]     } [EOL] }
public void testFloatWrapper() throws Exception { [EOL]     String[] STRS = new String[] { "1.0", "0.0", "-0.3", "0.7", "42.012", "-999.0", NAN_STRING }; [EOL]     for (String str : STRS) { [EOL]         Float exp = Float.valueOf(str); [EOL]         Float result; [EOL]         if (NAN_STRING != str) { [EOL]             result = MAPPER.readValue(new StringReader(str), Float.class); [EOL]             assertEquals(exp, result); [EOL]         } [EOL]         result = MAPPER.readValue(new StringReader(" \"" + str + "\""), Float.class); [EOL]         assertEquals(exp, result); [EOL]     } [EOL] }
public void testFloatWrapper() throws Exception { [EOL]     String[] STRS = new String[] { "1.0", "0.0", "-0.3", "0.7", "42.012", "-999.0", NAN_STRING }; [EOL]     for (String str : STRS) { [EOL]         Float exp = Float.valueOf(str); [EOL]         Float result; [EOL]         if (NAN_STRING != str) { [EOL]             result = MAPPER.readValue(new StringReader(str), Float.class); [EOL]             assertEquals(exp, result); [EOL]         } [EOL]         result = MAPPER.readValue(new StringReader(" \"" + str + "\""), Float.class); [EOL]         assertEquals(exp, result); [EOL]     } [EOL] }
public void testFloatWrapper() throws Exception { [EOL]     String[] STRS = new String[] { "1.0", "0.0", "-0.3", "0.7", "42.012", "-999.0", NAN_STRING }; [EOL]     for (String str : STRS) { [EOL]         Float exp = Float.valueOf(str); [EOL]         Float result; [EOL]         if (NAN_STRING != str) { [EOL]             result = MAPPER.readValue(new StringReader(str), Float.class); [EOL]             assertEquals(exp, result); [EOL]         } [EOL]         result = MAPPER.readValue(new StringReader(" \"" + str + "\""), Float.class); [EOL]         assertEquals(exp, result); [EOL]     } [EOL] }
public void testFloatWrapper() throws Exception { [EOL]     String[] STRS = new String[] { "1.0", "0.0", "-0.3", "0.7", "42.012", "-999.0", NAN_STRING }; [EOL]     for (String str : STRS) { [EOL]         Float exp = Float.valueOf(str); [EOL]         Float result; [EOL]         if (NAN_STRING != str) { [EOL]             result = MAPPER.readValue(new StringReader(str), Float.class); [EOL]             assertEquals(exp, result); [EOL]         } [EOL]         result = MAPPER.readValue(new StringReader(" \"" + str + "\""), Float.class); [EOL]         assertEquals(exp, result); [EOL]     } [EOL] }
public void testFloatWrapper() throws Exception { [EOL]     String[] STRS = new String[] { "1.0", "0.0", "-0.3", "0.7", "42.012", "-999.0", NAN_STRING }; [EOL]     for (String str : STRS) { [EOL]         Float exp = Float.valueOf(str); [EOL]         Float result; [EOL]         if (NAN_STRING != str) { [EOL]             result = MAPPER.readValue(new StringReader(str), Float.class); [EOL]             assertEquals(exp, result); [EOL]         } [EOL]         result = MAPPER.readValue(new StringReader(" \"" + str + "\""), Float.class); [EOL]         assertEquals(exp, result); [EOL]     } [EOL] }
public void testDoublePrimitiveNonNumeric() throws Exception { [EOL]     double value = Double.POSITIVE_INFINITY; [EOL]     DoubleBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), DoubleBean.class); [EOL]     assertEquals(value, result._v); [EOL]     double[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), double[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Double.POSITIVE_INFINITY, array[0]); [EOL] }
public void testDoublePrimitiveNonNumeric() throws Exception { [EOL]     double value = Double.POSITIVE_INFINITY; [EOL]     DoubleBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), DoubleBean.class); [EOL]     assertEquals(value, result._v); [EOL]     double[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), double[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Double.POSITIVE_INFINITY, array[0]); [EOL] }
public void testDoublePrimitiveNonNumeric() throws Exception { [EOL]     double value = Double.POSITIVE_INFINITY; [EOL]     DoubleBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), DoubleBean.class); [EOL]     assertEquals(value, result._v); [EOL]     double[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), double[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Double.POSITIVE_INFINITY, array[0]); [EOL] }
public void testDoublePrimitiveNonNumeric() throws Exception { [EOL]     double value = Double.POSITIVE_INFINITY; [EOL]     DoubleBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), DoubleBean.class); [EOL]     assertEquals(value, result._v); [EOL]     double[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), double[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Double.POSITIVE_INFINITY, array[0]); [EOL] }
public void testDoublePrimitiveNonNumeric() throws Exception { [EOL]     double value = Double.POSITIVE_INFINITY; [EOL]     DoubleBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), DoubleBean.class); [EOL]     assertEquals(value, result._v); [EOL]     double[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), double[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Double.POSITIVE_INFINITY, array[0]); [EOL] }
public void testDoublePrimitiveNonNumeric() throws Exception { [EOL]     double value = Double.POSITIVE_INFINITY; [EOL]     DoubleBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), DoubleBean.class); [EOL]     assertEquals(value, result._v); [EOL]     double[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), double[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Double.POSITIVE_INFINITY, array[0]); [EOL] }
public void testDoublePrimitiveNonNumeric() throws Exception { [EOL]     double value = Double.POSITIVE_INFINITY; [EOL]     DoubleBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), DoubleBean.class); [EOL]     assertEquals(value, result._v); [EOL]     double[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), double[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Double.POSITIVE_INFINITY, array[0]); [EOL] }
public void testDoublePrimitiveNonNumeric() throws Exception { [EOL]     double value = Double.POSITIVE_INFINITY; [EOL]     DoubleBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), DoubleBean.class); [EOL]     assertEquals(value, result._v); [EOL]     double[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), double[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Double.POSITIVE_INFINITY, array[0]); [EOL] }
public void testDoublePrimitiveNonNumeric() throws Exception { [EOL]     double value = Double.POSITIVE_INFINITY; [EOL]     DoubleBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), DoubleBean.class); [EOL]     assertEquals(value, result._v); [EOL]     double[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), double[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Double.POSITIVE_INFINITY, array[0]); [EOL] }
public void testDoublePrimitiveNonNumeric() throws Exception { [EOL]     double value = Double.POSITIVE_INFINITY; [EOL]     DoubleBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), DoubleBean.class); [EOL]     assertEquals(value, result._v); [EOL]     double[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), double[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Double.POSITIVE_INFINITY, array[0]); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testPropertyAnnotationForArrays() throws Exception { [EOL]     PointListWrapperArray array = objectReader(PointListWrapperArray.class).readValue("{\"values\":[[4,5],[5,4]]}"); [EOL]     assertNotNull(array); [EOL]     assertNotNull(array.values); [EOL]     assertEquals(2, array.values.length); [EOL]     assertEquals(5, array.values[1].x); [EOL] }
public void testPropertyAnnotationForArrays() throws Exception { [EOL]     PointListWrapperArray array = objectReader(PointListWrapperArray.class).readValue("{\"values\":[[4,5],[5,4]]}"); [EOL]     assertNotNull(array); [EOL]     assertNotNull(array.values); [EOL]     assertEquals(2, array.values.length); [EOL]     assertEquals(5, array.values[1].x); [EOL] }
public void testPropertyAnnotationForArrays() throws Exception { [EOL]     PointListWrapperArray array = objectReader(PointListWrapperArray.class).readValue("{\"values\":[[4,5],[5,4]]}"); [EOL]     assertNotNull(array); [EOL]     assertNotNull(array.values); [EOL]     assertEquals(2, array.values.length); [EOL]     assertEquals(5, array.values[1].x); [EOL] }
public void testPropertyAnnotationForArrays() throws Exception { [EOL]     PointListWrapperArray array = objectReader(PointListWrapperArray.class).readValue("{\"values\":[[4,5],[5,4]]}"); [EOL]     assertNotNull(array); [EOL]     assertNotNull(array.values); [EOL]     assertEquals(2, array.values.length); [EOL]     assertEquals(5, array.values[1].x); [EOL] }
public void testPropertyAnnotationForArrays() throws Exception { [EOL]     PointListWrapperArray array = objectReader(PointListWrapperArray.class).readValue("{\"values\":[[4,5],[5,4]]}"); [EOL]     assertNotNull(array); [EOL]     assertNotNull(array.values); [EOL]     assertEquals(2, array.values.length); [EOL]     assertEquals(5, array.values[1].x); [EOL] }
public void testDataBind() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     JsonNode tree = m.readTree("{ \"name\" : \"Tatu\", \n" + "\"magicNumber\" : 42," + "\"kids\" : [ \"Leo\", \"Lila\", \"Leia\" ] \n" + "}"); [EOL]     Person tatu = m.treeToValue(tree, Person.class); [EOL]     assertNotNull(tatu); [EOL]     assertEquals(42, tatu.magicNumber); [EOL]     assertEquals("Tatu", tatu.name); [EOL]     assertNotNull(tatu.kids); [EOL]     assertEquals(3, tatu.kids.size()); [EOL]     assertEquals("Leo", tatu.kids.get(0)); [EOL]     assertEquals("Lila", tatu.kids.get(1)); [EOL]     assertEquals("Leia", tatu.kids.get(2)); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testStaticTypingWithArrayList() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(MapperFeature.USE_STATIC_TYPING, true); [EOL]     ValueList list = new ValueList(); [EOL]     list.add(new ValueClass()); [EOL]     assertEquals("[{\"x\":3}]", m.writeValueAsString(list)); [EOL] }
public void testStaticTypingWithArrayList() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(MapperFeature.USE_STATIC_TYPING, true); [EOL]     ValueList list = new ValueList(); [EOL]     list.add(new ValueClass()); [EOL]     assertEquals("[{\"x\":3}]", m.writeValueAsString(list)); [EOL] }
public void testStaticTypingWithArrayList() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.configure(MapperFeature.USE_STATIC_TYPING, true); [EOL]     ValueList list = new ValueList(); [EOL]     list.add(new ValueClass()); [EOL]     assertEquals("[{\"x\":3}]", m.writeValueAsString(list)); [EOL] }
public void testDateUsingObjectWriter() throws IOException { [EOL]     DateFormat df = new SimpleDateFormat("yyyy-MM-dd'X'HH:mm:ss"); [EOL]     df.setTimeZone(TimeZone.getTimeZone("PST")); [EOL]     assertEquals(quote("1969-12-31X16:00:00"), MAPPER.writer(df).writeValueAsString(new Date(0L))); [EOL]     ObjectWriter w = MAPPER.writer((DateFormat) null); [EOL]     assertEquals("0", w.writeValueAsString(new Date(0L))); [EOL]     w = w.with(df); [EOL]     assertEquals(quote("1969-12-31X16:00:00"), w.writeValueAsString(new Date(0L))); [EOL]     w = w.with((DateFormat) null); [EOL]     assertEquals("0", w.writeValueAsString(new Date(0L))); [EOL] }
public void testDateUsingObjectWriter() throws IOException { [EOL]     DateFormat df = new SimpleDateFormat("yyyy-MM-dd'X'HH:mm:ss"); [EOL]     df.setTimeZone(TimeZone.getTimeZone("PST")); [EOL]     assertEquals(quote("1969-12-31X16:00:00"), MAPPER.writer(df).writeValueAsString(new Date(0L))); [EOL]     ObjectWriter w = MAPPER.writer((DateFormat) null); [EOL]     assertEquals("0", w.writeValueAsString(new Date(0L))); [EOL]     w = w.with(df); [EOL]     assertEquals(quote("1969-12-31X16:00:00"), w.writeValueAsString(new Date(0L))); [EOL]     w = w.with((DateFormat) null); [EOL]     assertEquals("0", w.writeValueAsString(new Date(0L))); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testAtomicReference() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     AtomicReference<long[]> value = mapper.readValue("[1,2]", new com.fasterxml.jackson.core.type.TypeReference<AtomicReference<long[]>>() { [EOL]     }); [EOL]     Object ob = value.get(); [EOL]     assertNotNull(ob); [EOL]     assertEquals(long[].class, ob.getClass()); [EOL]     long[] longs = (long[]) ob; [EOL]     assertNotNull(longs); [EOL]     assertEquals(2, longs.length); [EOL]     assertEquals(1, longs[0]); [EOL]     assertEquals(2, longs[1]); [EOL] }
public void testAtomicReference() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     AtomicReference<long[]> value = mapper.readValue("[1,2]", new com.fasterxml.jackson.core.type.TypeReference<AtomicReference<long[]>>() { [EOL]     }); [EOL]     Object ob = value.get(); [EOL]     assertNotNull(ob); [EOL]     assertEquals(long[].class, ob.getClass()); [EOL]     long[] longs = (long[]) ob; [EOL]     assertNotNull(longs); [EOL]     assertEquals(2, longs.length); [EOL]     assertEquals(1, longs[0]); [EOL]     assertEquals(2, longs[1]); [EOL] }
public void testAtomicReference() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     AtomicReference<long[]> value = mapper.readValue("[1,2]", new com.fasterxml.jackson.core.type.TypeReference<AtomicReference<long[]>>() { [EOL]     }); [EOL]     Object ob = value.get(); [EOL]     assertNotNull(ob); [EOL]     assertEquals(long[].class, ob.getClass()); [EOL]     long[] longs = (long[]) ob; [EOL]     assertNotNull(longs); [EOL]     assertEquals(2, longs.length); [EOL]     assertEquals(1, longs[0]); [EOL]     assertEquals(2, longs[1]); [EOL] }
public void testAtomicReference() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     AtomicReference<long[]> value = mapper.readValue("[1,2]", new com.fasterxml.jackson.core.type.TypeReference<AtomicReference<long[]>>() { [EOL]     }); [EOL]     Object ob = value.get(); [EOL]     assertNotNull(ob); [EOL]     assertEquals(long[].class, ob.getClass()); [EOL]     long[] longs = (long[]) ob; [EOL]     assertNotNull(longs); [EOL]     assertEquals(2, longs.length); [EOL]     assertEquals(1, longs[0]); [EOL]     assertEquals(2, longs[1]); [EOL] }
public void testAtomicReference() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     AtomicReference<long[]> value = mapper.readValue("[1,2]", new com.fasterxml.jackson.core.type.TypeReference<AtomicReference<long[]>>() { [EOL]     }); [EOL]     Object ob = value.get(); [EOL]     assertNotNull(ob); [EOL]     assertEquals(long[].class, ob.getClass()); [EOL]     long[] longs = (long[]) ob; [EOL]     assertNotNull(longs); [EOL]     assertEquals(2, longs.length); [EOL]     assertEquals(1, longs[0]); [EOL]     assertEquals(2, longs[1]); [EOL] }
public void testAtomicReference() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     AtomicReference<long[]> value = mapper.readValue("[1,2]", new com.fasterxml.jackson.core.type.TypeReference<AtomicReference<long[]>>() { [EOL]     }); [EOL]     Object ob = value.get(); [EOL]     assertNotNull(ob); [EOL]     assertEquals(long[].class, ob.getClass()); [EOL]     long[] longs = (long[]) ob; [EOL]     assertNotNull(longs); [EOL]     assertEquals(2, longs.length); [EOL]     assertEquals(1, longs[0]); [EOL]     assertEquals(2, longs[1]); [EOL] }
public void testAtomicReference() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     AtomicReference<long[]> value = mapper.readValue("[1,2]", new com.fasterxml.jackson.core.type.TypeReference<AtomicReference<long[]>>() { [EOL]     }); [EOL]     Object ob = value.get(); [EOL]     assertNotNull(ob); [EOL]     assertEquals(long[].class, ob.getClass()); [EOL]     long[] longs = (long[]) ob; [EOL]     assertNotNull(longs); [EOL]     assertEquals(2, longs.length); [EOL]     assertEquals(1, longs[0]); [EOL]     assertEquals(2, longs[1]); [EOL] }
public void testWithNullMessage() throws IOException { [EOL]     final ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     String json = mapper.writeValueAsString(new IOException((String) null)); [EOL]     IOException result = mapper.readValue(json, IOException.class); [EOL]     assertNotNull(result); [EOL]     assertNull(result.getMessage()); [EOL] }
public void testIssue877() throws Exception { [EOL]     BaseInterfaceImpl one = new BaseInterfaceImpl(); [EOL]     BaseInterfaceImpl two = new BaseInterfaceImpl(); [EOL]     one.addInstance(two); [EOL]     two.addInstance(one); [EOL]     ListWrapper<BaseInterfaceImpl> myList = new ListWrapper<BaseInterfaceImpl>(); [EOL]     myList.add(one); [EOL]     myList.add(two); [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTypingAsProperty(ObjectMapper.DefaultTyping.NON_FINAL, "@class"); [EOL]     String json = om.writerWithDefaultPrettyPrinter().writeValueAsString(myList); [EOL]     ListWrapper<BaseInterfaceImpl> result; [EOL]     result = om.readValue(json, new TypeReference<ListWrapper<BaseInterfaceImpl>>() { [EOL]     }); [EOL]     assertNotNull(result); [EOL]     System.out.println("deserialised list size = " + result.size()); [EOL] }
public void testIssue877() throws Exception { [EOL]     BaseInterfaceImpl one = new BaseInterfaceImpl(); [EOL]     BaseInterfaceImpl two = new BaseInterfaceImpl(); [EOL]     one.addInstance(two); [EOL]     two.addInstance(one); [EOL]     ListWrapper<BaseInterfaceImpl> myList = new ListWrapper<BaseInterfaceImpl>(); [EOL]     myList.add(one); [EOL]     myList.add(two); [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTypingAsProperty(ObjectMapper.DefaultTyping.NON_FINAL, "@class"); [EOL]     String json = om.writerWithDefaultPrettyPrinter().writeValueAsString(myList); [EOL]     ListWrapper<BaseInterfaceImpl> result; [EOL]     result = om.readValue(json, new TypeReference<ListWrapper<BaseInterfaceImpl>>() { [EOL]     }); [EOL]     assertNotNull(result); [EOL]     System.out.println("deserialised list size = " + result.size()); [EOL] }
public void testTypeIdFromProperty() throws Exception { [EOL]     assertEquals("{\"type\":\"SomeType\",\"a\":3}", mapper.writeValueAsString(new TypeIdFromFieldProperty())); [EOL] }
public void testTypeIdFromProperty() throws Exception { [EOL]     assertEquals("{\"type\":\"SomeType\",\"a\":3}", mapper.writeValueAsString(new TypeIdFromFieldProperty())); [EOL] }
public void testDateNumeric() throws IOException { [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)); [EOL]     String json = MAPPER.writeValueAsString(new Date(199L)); [EOL]     assertEquals("199", json); [EOL] }
public void testDateNumeric() throws IOException { [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)); [EOL]     String json = MAPPER.writeValueAsString(new Date(199L)); [EOL]     assertEquals("199", json); [EOL] }
public void testDateNumeric() throws IOException { [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)); [EOL]     String json = MAPPER.writeValueAsString(new Date(199L)); [EOL]     assertEquals("199", json); [EOL] }
public void testDateNumeric() throws IOException { [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)); [EOL]     String json = MAPPER.writeValueAsString(new Date(199L)); [EOL]     assertEquals("199", json); [EOL] }
public void testDateNumeric() throws IOException { [EOL]     assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)); [EOL]     String json = MAPPER.writeValueAsString(new Date(199L)); [EOL]     assertEquals("199", json); [EOL] }
public void testMultiAccess() throws Exception { [EOL]     String json = "{\"c\":3,\"a\":2,\"b\":-9}"; [EOL]     ValueClassABC value = mapper.readValue(json, ValueClassABC.class); [EOL]     assertNotNull(value); [EOL]     assertEquals(value.a, 2); [EOL]     assertEquals(value.b, -9); [EOL]     assertEquals(value.c, 3); [EOL] }
public void testMultiAccess() throws Exception { [EOL]     String json = "{\"c\":3,\"a\":2,\"b\":-9}"; [EOL]     ValueClassABC value = mapper.readValue(json, ValueClassABC.class); [EOL]     assertNotNull(value); [EOL]     assertEquals(value.a, 2); [EOL]     assertEquals(value.b, -9); [EOL]     assertEquals(value.c, 3); [EOL] }
public void testMultiAccess() throws Exception { [EOL]     String json = "{\"c\":3,\"a\":2,\"b\":-9}"; [EOL]     ValueClassABC value = mapper.readValue(json, ValueClassABC.class); [EOL]     assertNotNull(value); [EOL]     assertEquals(value.a, 2); [EOL]     assertEquals(value.b, -9); [EOL]     assertEquals(value.c, 3); [EOL] }
public void testSimpleUnwrappedDeserialize() throws Exception { [EOL]     Unwrapping bean = mapper.readValue("{\"name\":\"Tatu\",\"y\":7,\"x\":-13}", Unwrapping.class); [EOL]     assertEquals("Tatu", bean.name); [EOL]     Location loc = bean.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(-13, loc.x); [EOL]     assertEquals(7, loc.y); [EOL] }
public void testSimpleUnwrappedDeserialize() throws Exception { [EOL]     Unwrapping bean = mapper.readValue("{\"name\":\"Tatu\",\"y\":7,\"x\":-13}", Unwrapping.class); [EOL]     assertEquals("Tatu", bean.name); [EOL]     Location loc = bean.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(-13, loc.x); [EOL]     assertEquals(7, loc.y); [EOL] }
public void testSimpleDeserWithForwardRefs() throws Exception { [EOL]     IdWrapper result = mapper.readValue("{\"node\":{\"value\":7,\"next\":{\"node\":1}, \"@id\":1}}", IdWrapper.class); [EOL]     assertEquals(7, result.node.value); [EOL]     assertSame(result.node, result.node.next.node); [EOL] }
public void testSimpleDeserWithForwardRefs() throws Exception { [EOL]     IdWrapper result = mapper.readValue("{\"node\":{\"value\":7,\"next\":{\"node\":1}, \"@id\":1}}", IdWrapper.class); [EOL]     assertEquals(7, result.node.value); [EOL]     assertSame(result.node, result.node.next.node); [EOL] }
public void testPropertyIgnoral() throws Exception { [EOL]     XYZWrapper1 result = MAPPER.readValue("{\"value\":{\"y\":2,\"x\":1,\"z\":3}}", XYZWrapper1.class); [EOL]     assertEquals(2, result.value.y); [EOL]     assertEquals(3, result.value.z); [EOL] }
public void testPropertyIgnoral() throws Exception { [EOL]     XYZWrapper1 result = MAPPER.readValue("{\"value\":{\"y\":2,\"x\":1,\"z\":3}}", XYZWrapper1.class); [EOL]     assertEquals(2, result.value.y); [EOL]     assertEquals(3, result.value.z); [EOL] }
public void testAnnotatedContextual() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     AnnotatedContextualClassBean bean = mapper.readValue("{\"value\":\"a\"}", AnnotatedContextualClassBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals("xyz=a", bean.value.value); [EOL] }
public void testAnnotatedContextual() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     AnnotatedContextualClassBean bean = mapper.readValue("{\"value\":\"a\"}", AnnotatedContextualClassBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals("xyz=a", bean.value.value); [EOL] }
public void testAnnotatedContextual() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     AnnotatedContextualClassBean bean = mapper.readValue("{\"value\":\"a\"}", AnnotatedContextualClassBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals("xyz=a", bean.value.value); [EOL] }
public void testAnnotatedContextual() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     AnnotatedContextualClassBean bean = mapper.readValue("{\"value\":\"a\"}", AnnotatedContextualClassBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals("xyz=a", bean.value.value); [EOL] }
public void testAnnotatedContextual() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     AnnotatedContextualClassBean bean = mapper.readValue("{\"value\":\"a\"}", AnnotatedContextualClassBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals("xyz=a", bean.value.value); [EOL] }
public void testAnnotatedContextual() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     AnnotatedContextualClassBean bean = mapper.readValue("{\"value\":\"a\"}", AnnotatedContextualClassBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals("xyz=a", bean.value.value); [EOL] }
public void testSimpleDeserWithForwardRefs() throws Exception { [EOL]     IdWrapper result = mapper.readValue("{\"node\":{\"value\":7,\"next\":{\"node\":1}, \"@id\":1}}", IdWrapper.class); [EOL]     assertEquals(7, result.node.value); [EOL]     assertSame(result.node, result.node.next.node); [EOL] }
public void testSimpleDeserWithForwardRefs() throws Exception { [EOL]     IdWrapper result = mapper.readValue("{\"node\":{\"value\":7,\"next\":{\"node\":1}, \"@id\":1}}", IdWrapper.class); [EOL]     assertEquals(7, result.node.value); [EOL]     assertSame(result.node, result.node.next.node); [EOL] }
public void testAbstract368() throws Exception { [EOL]     AbstractNode parent = new ConcreteNode("p"); [EOL]     AbstractNode child = new ConcreteNode("c"); [EOL]     parent.next = child; [EOL]     child.prev = parent; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(parent); [EOL]     AbstractNode root = mapper.readValue(json, AbstractNode.class); [EOL]     assertEquals(ConcreteNode.class, root.getClass()); [EOL]     assertEquals("p", root.id); [EOL]     assertNull(root.prev); [EOL]     AbstractNode leaf = root.next; [EOL]     assertNotNull(leaf); [EOL]     assertEquals("c", leaf.id); [EOL]     assertSame(root, leaf.prev); [EOL] }
public void testSimpleUnwrappedDeserialize() throws Exception { [EOL]     Unwrapping bean = mapper.readValue("{\"name\":\"Tatu\",\"y\":7,\"x\":-13}", Unwrapping.class); [EOL]     assertEquals("Tatu", bean.name); [EOL]     Location loc = bean.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(-13, loc.x); [EOL]     assertEquals(7, loc.y); [EOL] }
public void testSimpleUnwrappedDeserialize() throws Exception { [EOL]     Unwrapping bean = mapper.readValue("{\"name\":\"Tatu\",\"y\":7,\"x\":-13}", Unwrapping.class); [EOL]     assertEquals("Tatu", bean.name); [EOL]     Location loc = bean.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(-13, loc.x); [EOL]     assertEquals(7, loc.y); [EOL] }
public void testSimpleUnwrappedDeserialize() throws Exception { [EOL]     Unwrapping bean = mapper.readValue("{\"name\":\"Tatu\",\"y\":7,\"x\":-13}", Unwrapping.class); [EOL]     assertEquals("Tatu", bean.name); [EOL]     Location loc = bean.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(-13, loc.x); [EOL]     assertEquals(7, loc.y); [EOL] }
public void testSimpleUnwrappedDeserialize() throws Exception { [EOL]     Unwrapping bean = mapper.readValue("{\"name\":\"Tatu\",\"y\":7,\"x\":-13}", Unwrapping.class); [EOL]     assertEquals("Tatu", bean.name); [EOL]     Location loc = bean.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(-13, loc.x); [EOL]     assertEquals(7, loc.y); [EOL] }
public void testInnerClassWithType() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(DefaultTyping.NON_FINAL); [EOL]     String json = mapper.writeValueAsString(new BeanWithAnon()); [EOL]     BeanWithAnon result = mapper.readValue(json, BeanWithAnon.class); [EOL]     assertEquals(BeanWithAnon.class, result.getClass()); [EOL] }
public void testInnerClassWithType() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(DefaultTyping.NON_FINAL); [EOL]     String json = mapper.writeValueAsString(new BeanWithAnon()); [EOL]     BeanWithAnon result = mapper.readValue(json, BeanWithAnon.class); [EOL]     assertEquals(BeanWithAnon.class, result.getClass()); [EOL] }
public void testInnerClassWithType() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(DefaultTyping.NON_FINAL); [EOL]     String json = mapper.writeValueAsString(new BeanWithAnon()); [EOL]     BeanWithAnon result = mapper.readValue(json, BeanWithAnon.class); [EOL]     assertEquals(BeanWithAnon.class, result.getClass()); [EOL] }
public void testSimpleDeserWithForwardRefs() throws Exception { [EOL]     IdWrapper result = mapper.readValue("{\"node\":{\"value\":7,\"next\":{\"node\":1}, \"@id\":1}}", IdWrapper.class); [EOL]     assertEquals(7, result.node.value); [EOL]     assertSame(result.node, result.node.next.node); [EOL] }
public void testSimpleDeserWithForwardRefs() throws Exception { [EOL]     IdWrapper result = mapper.readValue("{\"node\":{\"value\":7,\"next\":{\"node\":1}, \"@id\":1}}", IdWrapper.class); [EOL]     assertEquals(7, result.node.value); [EOL]     assertSame(result.node, result.node.next.node); [EOL] }
public void testSimpleDeserWithForwardRefs() throws Exception { [EOL]     IdWrapper result = mapper.readValue("{\"node\":{\"value\":7,\"next\":{\"node\":1}, \"@id\":1}}", IdWrapper.class); [EOL]     assertEquals(7, result.node.value); [EOL]     assertSame(result.node, result.node.next.node); [EOL] }
public void testManualPolymorphicCatWithReorder() throws Exception { [EOL]     Animal animal = MAPPER.readValue("{ \"likesCream\":true, \"name\" : \"Venla\", \"type\":\"cat\" }", Animal.class); [EOL]     assertEquals(Cat.class, animal.getClass()); [EOL]     assertEquals("Venla", animal.name); [EOL]     assertTrue(((Cat) animal).likesCream); [EOL] }
public void testManualPolymorphicCatWithReorder() throws Exception { [EOL]     Animal animal = MAPPER.readValue("{ \"likesCream\":true, \"name\" : \"Venla\", \"type\":\"cat\" }", Animal.class); [EOL]     assertEquals(Cat.class, animal.getClass()); [EOL]     assertEquals("Venla", animal.name); [EOL]     assertTrue(((Cat) animal).likesCream); [EOL] }
public void testManualPolymorphicCatWithReorder() throws Exception { [EOL]     Animal animal = MAPPER.readValue("{ \"likesCream\":true, \"name\" : \"Venla\", \"type\":\"cat\" }", Animal.class); [EOL]     assertEquals(Cat.class, animal.getClass()); [EOL]     assertEquals("Venla", animal.name); [EOL]     assertTrue(((Cat) animal).likesCream); [EOL] }
public void testManualPolymorphicCatWithReorder() throws Exception { [EOL]     Animal animal = MAPPER.readValue("{ \"likesCream\":true, \"name\" : \"Venla\", \"type\":\"cat\" }", Animal.class); [EOL]     assertEquals(Cat.class, animal.getClass()); [EOL]     assertEquals("Venla", animal.name); [EOL]     assertTrue(((Cat) animal).likesCream); [EOL] }
public void testManualPolymorphicCatWithReorder() throws Exception { [EOL]     Animal animal = MAPPER.readValue("{ \"likesCream\":true, \"name\" : \"Venla\", \"type\":\"cat\" }", Animal.class); [EOL]     assertEquals(Cat.class, animal.getClass()); [EOL]     assertEquals("Venla", animal.name); [EOL]     assertTrue(((Cat) animal).likesCream); [EOL] }
public void testDataBind() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     JsonNode tree = m.readTree("{ \"name\" : \"Tatu\", \n" + "\"magicNumber\" : 42," + "\"kids\" : [ \"Leo\", \"Lila\", \"Leia\" ] \n" + "}"); [EOL]     Person tatu = m.treeToValue(tree, Person.class); [EOL]     assertNotNull(tatu); [EOL]     assertEquals(42, tatu.magicNumber); [EOL]     assertEquals("Tatu", tatu.name); [EOL]     assertNotNull(tatu.kids); [EOL]     assertEquals(3, tatu.kids.size()); [EOL]     assertEquals("Leo", tatu.kids.get(0)); [EOL]     assertEquals("Lila", tatu.kids.get(1)); [EOL]     assertEquals("Leia", tatu.kids.get(2)); [EOL] }
public void testEmbeddedObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeObject(new byte[3]); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isBinary()); [EOL]     byte[] data = node.binaryValue(); [EOL]     assertNotNull(data); [EOL]     assertEquals(3, data.length); [EOL] }
public void testEmbeddedObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeObject(new byte[3]); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isBinary()); [EOL]     byte[] data = node.binaryValue(); [EOL]     assertNotNull(data); [EOL]     assertEquals(3, data.length); [EOL] }
public void testEmbeddedObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeObject(new byte[3]); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isBinary()); [EOL]     byte[] data = node.binaryValue(); [EOL]     assertNotNull(data); [EOL]     assertEquals(3, data.length); [EOL] }
public void testEmbeddedObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeObject(new byte[3]); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isBinary()); [EOL]     byte[] data = node.binaryValue(); [EOL]     assertNotNull(data); [EOL]     assertEquals(3, data.length); [EOL] }
public void testEmbeddedObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeObject(new byte[3]); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isBinary()); [EOL]     byte[] data = node.binaryValue(); [EOL]     assertNotNull(data); [EOL]     assertEquals(3, data.length); [EOL] }
public void testEmbeddedObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeObject(new byte[3]); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isBinary()); [EOL]     byte[] data = node.binaryValue(); [EOL]     assertNotNull(data); [EOL]     assertEquals(3, data.length); [EOL] }
public void testEmbeddedObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeObject(new byte[3]); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isBinary()); [EOL]     byte[] data = node.binaryValue(); [EOL]     assertNotNull(data); [EOL]     assertEquals(3, data.length); [EOL] }
public void testEmbeddedObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeObject(new byte[3]); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isBinary()); [EOL]     byte[] data = node.binaryValue(); [EOL]     assertNotNull(data); [EOL]     assertEquals(3, data.length); [EOL] }
public void testEmbeddedObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeObject(new byte[3]); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isBinary()); [EOL]     byte[] data = node.binaryValue(); [EOL]     assertNotNull(data); [EOL]     assertEquals(3, data.length); [EOL] }
public void testEmbeddedObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeObject(new byte[3]); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isBinary()); [EOL]     byte[] data = node.binaryValue(); [EOL]     assertNotNull(data); [EOL]     assertEquals(3, data.length); [EOL] }
public void testEmbeddedObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeObject(new byte[3]); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isBinary()); [EOL]     byte[] data = node.binaryValue(); [EOL]     assertNotNull(data); [EOL]     assertEquals(3, data.length); [EOL] }
public void testEmbeddedObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeObject(new byte[3]); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isBinary()); [EOL]     byte[] data = node.binaryValue(); [EOL]     assertNotNull(data); [EOL]     assertEquals(3, data.length); [EOL] }
public void testEmbeddedObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeObject(new byte[3]); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isBinary()); [EOL]     byte[] data = node.binaryValue(); [EOL]     assertNotNull(data); [EOL]     assertEquals(3, data.length); [EOL] }
public void testEmbeddedObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeObject(new byte[3]); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isBinary()); [EOL]     byte[] data = node.binaryValue(); [EOL]     assertNotNull(data); [EOL]     assertEquals(3, data.length); [EOL] }
public void testEmbeddedObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeObject(new byte[3]); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isBinary()); [EOL]     byte[] data = node.binaryValue(); [EOL]     assertNotNull(data); [EOL]     assertEquals(3, data.length); [EOL] }
public void testEmbeddedObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeObject(new byte[3]); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isBinary()); [EOL]     byte[] data = node.binaryValue(); [EOL]     assertNotNull(data); [EOL]     assertEquals(3, data.length); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testAtomicReference() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     AtomicReference<long[]> value = mapper.readValue("[1,2]", new com.fasterxml.jackson.core.type.TypeReference<AtomicReference<long[]>>() { [EOL]     }); [EOL]     Object ob = value.get(); [EOL]     assertNotNull(ob); [EOL]     assertEquals(long[].class, ob.getClass()); [EOL]     long[] longs = (long[]) ob; [EOL]     assertNotNull(longs); [EOL]     assertEquals(2, longs.length); [EOL]     assertEquals(1, longs[0]); [EOL]     assertEquals(2, longs[1]); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testIssue877() throws Exception { [EOL]     BaseInterfaceImpl one = new BaseInterfaceImpl(); [EOL]     BaseInterfaceImpl two = new BaseInterfaceImpl(); [EOL]     one.addInstance(two); [EOL]     two.addInstance(one); [EOL]     ListWrapper<BaseInterfaceImpl> myList = new ListWrapper<BaseInterfaceImpl>(); [EOL]     myList.add(one); [EOL]     myList.add(two); [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTypingAsProperty(ObjectMapper.DefaultTyping.NON_FINAL, "@class"); [EOL]     String json = om.writerWithDefaultPrettyPrinter().writeValueAsString(myList); [EOL]     ListWrapper<BaseInterfaceImpl> result; [EOL]     result = om.readValue(json, new TypeReference<ListWrapper<BaseInterfaceImpl>>() { [EOL]     }); [EOL]     assertNotNull(result); [EOL]     System.out.println("deserialised list size = " + result.size()); [EOL] }
public void testIssue877() throws Exception { [EOL]     BaseInterfaceImpl one = new BaseInterfaceImpl(); [EOL]     BaseInterfaceImpl two = new BaseInterfaceImpl(); [EOL]     one.addInstance(two); [EOL]     two.addInstance(one); [EOL]     ListWrapper<BaseInterfaceImpl> myList = new ListWrapper<BaseInterfaceImpl>(); [EOL]     myList.add(one); [EOL]     myList.add(two); [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTypingAsProperty(ObjectMapper.DefaultTyping.NON_FINAL, "@class"); [EOL]     String json = om.writerWithDefaultPrettyPrinter().writeValueAsString(myList); [EOL]     ListWrapper<BaseInterfaceImpl> result; [EOL]     result = om.readValue(json, new TypeReference<ListWrapper<BaseInterfaceImpl>>() { [EOL]     }); [EOL]     assertNotNull(result); [EOL]     System.out.println("deserialised list size = " + result.size()); [EOL] }
public void testIssue877() throws Exception { [EOL]     BaseInterfaceImpl one = new BaseInterfaceImpl(); [EOL]     BaseInterfaceImpl two = new BaseInterfaceImpl(); [EOL]     one.addInstance(two); [EOL]     two.addInstance(one); [EOL]     ListWrapper<BaseInterfaceImpl> myList = new ListWrapper<BaseInterfaceImpl>(); [EOL]     myList.add(one); [EOL]     myList.add(two); [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTypingAsProperty(ObjectMapper.DefaultTyping.NON_FINAL, "@class"); [EOL]     String json = om.writerWithDefaultPrettyPrinter().writeValueAsString(myList); [EOL]     ListWrapper<BaseInterfaceImpl> result; [EOL]     result = om.readValue(json, new TypeReference<ListWrapper<BaseInterfaceImpl>>() { [EOL]     }); [EOL]     assertNotNull(result); [EOL]     System.out.println("deserialised list size = " + result.size()); [EOL] }
public void testIssue877() throws Exception { [EOL]     BaseInterfaceImpl one = new BaseInterfaceImpl(); [EOL]     BaseInterfaceImpl two = new BaseInterfaceImpl(); [EOL]     one.addInstance(two); [EOL]     two.addInstance(one); [EOL]     ListWrapper<BaseInterfaceImpl> myList = new ListWrapper<BaseInterfaceImpl>(); [EOL]     myList.add(one); [EOL]     myList.add(two); [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTypingAsProperty(ObjectMapper.DefaultTyping.NON_FINAL, "@class"); [EOL]     String json = om.writerWithDefaultPrettyPrinter().writeValueAsString(myList); [EOL]     ListWrapper<BaseInterfaceImpl> result; [EOL]     result = om.readValue(json, new TypeReference<ListWrapper<BaseInterfaceImpl>>() { [EOL]     }); [EOL]     assertNotNull(result); [EOL]     System.out.println("deserialised list size = " + result.size()); [EOL] }
public void testIssue693() throws Exception { [EOL]     Parent parent = new Parent(); [EOL]     parent.addChild(new Child("foo")); [EOL]     parent.addChild(new Child("bar")); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     byte[] bytes = mapper.writeValueAsBytes(parent); [EOL]     Parent value = mapper.readValue(bytes, Parent.class); [EOL]     for (Child child : value.children) { [EOL]         assertEquals(value, child.getParent()); [EOL]     } [EOL] }
public void testDefaultFilter() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     FilterProvider prov = new SimpleFilterProvider().setDefaultFilter(SimpleBeanPropertyFilter.filterOutAllExcept("b")); [EOL]     assertEquals("{\"b\":\"b\"}", mapper.writer(prov).writeValueAsString(new Bean())); [EOL] }
public void testDefaultFilter() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     FilterProvider prov = new SimpleFilterProvider().setDefaultFilter(SimpleBeanPropertyFilter.filterOutAllExcept("b")); [EOL]     assertEquals("{\"b\":\"b\"}", mapper.writer(prov).writeValueAsString(new Bean())); [EOL] }
public void testDefaultFilter() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     FilterProvider prov = new SimpleFilterProvider().setDefaultFilter(SimpleBeanPropertyFilter.filterOutAllExcept("b")); [EOL]     assertEquals("{\"b\":\"b\"}", mapper.writer(prov).writeValueAsString(new Bean())); [EOL] }
public void testDefaultFilter() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     FilterProvider prov = new SimpleFilterProvider().setDefaultFilter(SimpleBeanPropertyFilter.filterOutAllExcept("b")); [EOL]     assertEquals("{\"b\":\"b\"}", mapper.writer(prov).writeValueAsString(new Bean())); [EOL] }
public void testDefaultFilter() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     FilterProvider prov = new SimpleFilterProvider().setDefaultFilter(SimpleBeanPropertyFilter.filterOutAllExcept("b")); [EOL]     assertEquals("{\"b\":\"b\"}", mapper.writer(prov).writeValueAsString(new Bean())); [EOL] }
public void testSimpleKeySer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.addKeySerializer(String.class, new ContextualKeySerializer("prefix")); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> input = new HashMap<String, Object>(); [EOL]     input.put("a", Integer.valueOf(3)); [EOL]     String json = mapper.writerWithType(TypeFactory.defaultInstance().constructMapType(HashMap.class, String.class, Object.class)).writeValueAsString(input); [EOL]     assertEquals("{\"prefix:a\":3}", json); [EOL] }
public void testSimpleKeySer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.addKeySerializer(String.class, new ContextualKeySerializer("prefix")); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> input = new HashMap<String, Object>(); [EOL]     input.put("a", Integer.valueOf(3)); [EOL]     String json = mapper.writerWithType(TypeFactory.defaultInstance().constructMapType(HashMap.class, String.class, Object.class)).writeValueAsString(input); [EOL]     assertEquals("{\"prefix:a\":3}", json); [EOL] }
public void testSimpleKeySer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.addKeySerializer(String.class, new ContextualKeySerializer("prefix")); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> input = new HashMap<String, Object>(); [EOL]     input.put("a", Integer.valueOf(3)); [EOL]     String json = mapper.writerWithType(TypeFactory.defaultInstance().constructMapType(HashMap.class, String.class, Object.class)).writeValueAsString(input); [EOL]     assertEquals("{\"prefix:a\":3}", json); [EOL] }
public void testSimpleKeySer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.addKeySerializer(String.class, new ContextualKeySerializer("prefix")); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> input = new HashMap<String, Object>(); [EOL]     input.put("a", Integer.valueOf(3)); [EOL]     String json = mapper.writerWithType(TypeFactory.defaultInstance().constructMapType(HashMap.class, String.class, Object.class)).writeValueAsString(input); [EOL]     assertEquals("{\"prefix:a\":3}", json); [EOL] }
public void testSimpleKeySer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.addKeySerializer(String.class, new ContextualKeySerializer("prefix")); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> input = new HashMap<String, Object>(); [EOL]     input.put("a", Integer.valueOf(3)); [EOL]     String json = mapper.writerWithType(TypeFactory.defaultInstance().constructMapType(HashMap.class, String.class, Object.class)).writeValueAsString(input); [EOL]     assertEquals("{\"prefix:a\":3}", json); [EOL] }
public void testSimpleKeySer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule module = new SimpleModule("test", Version.unknownVersion()); [EOL]     module.addKeySerializer(String.class, new ContextualKeySerializer("prefix")); [EOL]     mapper.registerModule(module); [EOL]     Map<String, Object> input = new HashMap<String, Object>(); [EOL]     input.put("a", Integer.valueOf(3)); [EOL]     String json = mapper.writerWithType(TypeFactory.defaultInstance().constructMapType(HashMap.class, String.class, Object.class)).writeValueAsString(input); [EOL]     assertEquals("{\"prefix:a\":3}", json); [EOL] }
public void testTypeIdFromArray() throws Exception { [EOL]     assertEquals("[\"SomeType\",{\"a\":3}]", mapper.writeValueAsString(new TypeIdFromFieldArray())); [EOL] }
public void testTypeIdFromArray() throws Exception { [EOL]     assertEquals("[\"SomeType\",{\"a\":3}]", mapper.writeValueAsString(new TypeIdFromFieldArray())); [EOL] }
public void testTypeIdFromArray() throws Exception { [EOL]     assertEquals("[\"SomeType\",{\"a\":3}]", mapper.writeValueAsString(new TypeIdFromFieldArray())); [EOL] }
public void testInetAddress() throws IOException { [EOL]     assertEquals(quote("127.0.0.1"), MAPPER.writeValueAsString(InetAddress.getByName("127.0.0.1"))); [EOL]     assertEquals(quote("ning.com"), MAPPER.writeValueAsString(InetAddress.getByName("ning.com"))); [EOL] }
public void testInetAddress() throws IOException { [EOL]     assertEquals(quote("127.0.0.1"), MAPPER.writeValueAsString(InetAddress.getByName("127.0.0.1"))); [EOL]     assertEquals(quote("ning.com"), MAPPER.writeValueAsString(InetAddress.getByName("ning.com"))); [EOL] }
public void testInetAddress() throws IOException { [EOL]     assertEquals(quote("127.0.0.1"), MAPPER.writeValueAsString(InetAddress.getByName("127.0.0.1"))); [EOL]     assertEquals(quote("ning.com"), MAPPER.writeValueAsString(InetAddress.getByName("ning.com"))); [EOL] }
public void testInetAddress() throws IOException { [EOL]     assertEquals(quote("127.0.0.1"), MAPPER.writeValueAsString(InetAddress.getByName("127.0.0.1"))); [EOL]     assertEquals(quote("ning.com"), MAPPER.writeValueAsString(InetAddress.getByName("ning.com"))); [EOL] }
public void testInetAddress() throws IOException { [EOL]     assertEquals(quote("127.0.0.1"), MAPPER.writeValueAsString(InetAddress.getByName("127.0.0.1"))); [EOL]     assertEquals(quote("ning.com"), MAPPER.writeValueAsString(InetAddress.getByName("ning.com"))); [EOL] }
public void testInetAddress() throws IOException { [EOL]     assertEquals(quote("127.0.0.1"), MAPPER.writeValueAsString(InetAddress.getByName("127.0.0.1"))); [EOL]     assertEquals(quote("ning.com"), MAPPER.writeValueAsString(InetAddress.getByName("ning.com"))); [EOL] }
public void testInetAddress() throws IOException { [EOL]     assertEquals(quote("127.0.0.1"), MAPPER.writeValueAsString(InetAddress.getByName("127.0.0.1"))); [EOL]     assertEquals(quote("ning.com"), MAPPER.writeValueAsString(InetAddress.getByName("ning.com"))); [EOL] }
public void testInetAddress() throws IOException { [EOL]     assertEquals(quote("127.0.0.1"), MAPPER.writeValueAsString(InetAddress.getByName("127.0.0.1"))); [EOL]     assertEquals(quote("ning.com"), MAPPER.writeValueAsString(InetAddress.getByName("ning.com"))); [EOL] }
public void testInetAddress() throws IOException { [EOL]     assertEquals(quote("127.0.0.1"), MAPPER.writeValueAsString(InetAddress.getByName("127.0.0.1"))); [EOL]     assertEquals(quote("ning.com"), MAPPER.writeValueAsString(InetAddress.getByName("ning.com"))); [EOL] }
public void testEnumAsObject() throws Exception { [EOL]     Object[] input = new Object[] { Choice.YES }; [EOL]     Object[] input2 = new Object[] { ComplexChoice.MAYBE }; [EOL]     assertEquals("[\"YES\"]", serializeAsString(input)); [EOL]     assertEquals("[\"MAYBE\"]", serializeAsString(input2)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(); [EOL]     String json = m.writeValueAsString(input); [EOL]     assertEquals("[[\"" + Choice.class.getName() + "\",\"YES\"]]", json); [EOL]     Object[] output = m.readValue(json, Object[].class); [EOL]     assertEquals(1, output.length); [EOL]     assertEquals(Choice.YES, output[0]); [EOL]     json = m.writeValueAsString(input2); [EOL]     assertEquals("[[\"" + ComplexChoice.class.getName() + "\",\"MAYBE\"]]", json); [EOL]     output = m.readValue(json, Object[].class); [EOL]     assertEquals(1, output.length); [EOL]     assertEquals(ComplexChoice.MAYBE, output[0]); [EOL] }
public void testEnumAsObject() throws Exception { [EOL]     Object[] input = new Object[] { Choice.YES }; [EOL]     Object[] input2 = new Object[] { ComplexChoice.MAYBE }; [EOL]     assertEquals("[\"YES\"]", serializeAsString(input)); [EOL]     assertEquals("[\"MAYBE\"]", serializeAsString(input2)); [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(); [EOL]     String json = m.writeValueAsString(input); [EOL]     assertEquals("[[\"" + Choice.class.getName() + "\",\"YES\"]]", json); [EOL]     Object[] output = m.readValue(json, Object[].class); [EOL]     assertEquals(1, output.length); [EOL]     assertEquals(Choice.YES, output[0]); [EOL]     json = m.writeValueAsString(input2); [EOL]     assertEquals("[[\"" + ComplexChoice.class.getName() + "\",\"MAYBE\"]]", json); [EOL]     output = m.readValue(json, Object[].class); [EOL]     assertEquals(1, output.length); [EOL]     assertEquals(ComplexChoice.MAYBE, output[0]); [EOL] }
public void testModifyEnumSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setSerializerModifier(new EnumSerializerModifier())); [EOL]     assertEquals("123", mapper.writeValueAsString(EnumABC.C)); [EOL] }
public void testModifyEnumSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setSerializerModifier(new EnumSerializerModifier())); [EOL]     assertEquals("123", mapper.writeValueAsString(EnumABC.C)); [EOL] }
public void testModifyEnumSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setSerializerModifier(new EnumSerializerModifier())); [EOL]     assertEquals("123", mapper.writeValueAsString(EnumABC.C)); [EOL] }
public void testEmptyWithAnnotations() throws Exception { [EOL]     try { [EOL]         serializeAsString(mapper, new Empty()); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "No serializer found for class"); [EOL]     } [EOL]     assertEquals("{}", serializeAsString(mapper, new EmptyWithAnno())); [EOL]     ObjectMapper m2 = new ObjectMapper(); [EOL]     m2.addMixInAnnotations(Empty.class, EmptyWithAnno.class); [EOL]     assertEquals("{}", m2.writeValueAsString(new Empty())); [EOL] }
public void testEmptyWithAnnotations() throws Exception { [EOL]     try { [EOL]         serializeAsString(mapper, new Empty()); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "No serializer found for class"); [EOL]     } [EOL]     assertEquals("{}", serializeAsString(mapper, new EmptyWithAnno())); [EOL]     ObjectMapper m2 = new ObjectMapper(); [EOL]     m2.addMixInAnnotations(Empty.class, EmptyWithAnno.class); [EOL]     assertEquals("{}", m2.writeValueAsString(new Empty())); [EOL] }
public void testEmptyWithAnnotations() throws Exception { [EOL]     try { [EOL]         serializeAsString(mapper, new Empty()); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "No serializer found for class"); [EOL]     } [EOL]     assertEquals("{}", serializeAsString(mapper, new EmptyWithAnno())); [EOL]     ObjectMapper m2 = new ObjectMapper(); [EOL]     m2.addMixInAnnotations(Empty.class, EmptyWithAnno.class); [EOL]     assertEquals("{}", m2.writeValueAsString(new Empty())); [EOL] }
public void testEmptyWithAnnotations() throws Exception { [EOL]     try { [EOL]         serializeAsString(mapper, new Empty()); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "No serializer found for class"); [EOL]     } [EOL]     assertEquals("{}", serializeAsString(mapper, new EmptyWithAnno())); [EOL]     ObjectMapper m2 = new ObjectMapper(); [EOL]     m2.addMixInAnnotations(Empty.class, EmptyWithAnno.class); [EOL]     assertEquals("{}", m2.writeValueAsString(new Empty())); [EOL] }
public void testEnumsWhenDisabled() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL]     m = new ObjectMapper(); [EOL]     m.configure(MapperFeature.USE_ANNOTATIONS, false); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL] }
public void testEnumsWhenDisabled() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL]     m = new ObjectMapper(); [EOL]     m.configure(MapperFeature.USE_ANNOTATIONS, false); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testEnumsWhenDisabled() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL]     m = new ObjectMapper(); [EOL]     m.configure(MapperFeature.USE_ANNOTATIONS, false); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL] }
public void testEnumsWhenDisabled() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL]     m = new ObjectMapper(); [EOL]     m.configure(MapperFeature.USE_ANNOTATIONS, false); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL] }
public void testEnumsWhenDisabled() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL]     m = new ObjectMapper(); [EOL]     m.configure(MapperFeature.USE_ANNOTATIONS, false); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL] }
public void testEnumsWhenDisabled() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL]     m = new ObjectMapper(); [EOL]     m.configure(MapperFeature.USE_ANNOTATIONS, false); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL] }
public void testEnumsWhenDisabled() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL]     m = new ObjectMapper(); [EOL]     m.configure(MapperFeature.USE_ANNOTATIONS, false); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL] }
public void testEnumsWhenDisabled() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL]     m = new ObjectMapper(); [EOL]     m.configure(MapperFeature.USE_ANNOTATIONS, false); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL] }
public void testEnumsWhenDisabled() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL]     m = new ObjectMapper(); [EOL]     m.configure(MapperFeature.USE_ANNOTATIONS, false); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL] }
public void testEnumsWhenDisabled() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL]     m = new ObjectMapper(); [EOL]     m.configure(MapperFeature.USE_ANNOTATIONS, false); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL] }
public void testEnumsWhenDisabled() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL]     m = new ObjectMapper(); [EOL]     m.configure(MapperFeature.USE_ANNOTATIONS, false); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL] }
public void testEnumsWhenDisabled() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL]     m = new ObjectMapper(); [EOL]     m.configure(MapperFeature.USE_ANNOTATIONS, false); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL] }
public void testEnumsWhenDisabled() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL]     m = new ObjectMapper(); [EOL]     m.configure(MapperFeature.USE_ANNOTATIONS, false); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL] }
public void testEnumsWhenDisabled() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL]     m = new ObjectMapper(); [EOL]     m.configure(MapperFeature.USE_ANNOTATIONS, false); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL] }
public void testEnumsWhenDisabled() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL]     m = new ObjectMapper(); [EOL]     m.configure(MapperFeature.USE_ANNOTATIONS, false); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL] }
public void testEnumsWhenDisabled() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL]     m = new ObjectMapper(); [EOL]     m.configure(MapperFeature.USE_ANNOTATIONS, false); [EOL]     assertEquals(Alpha.B, m.readValue(quote("B"), Alpha.class)); [EOL] }
public void testBadTypeAsNull() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.disable(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE); [EOL]     Object ob = mapper.readValue("{}", MysteryPolymorphic.class); [EOL]     assertNull(ob); [EOL]     ob = mapper.readValue("{ \"whatever\":13}", MysteryPolymorphic.class); [EOL]     assertNull(ob); [EOL] }
public void testBadTypeAsNull() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.disable(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE); [EOL]     Object ob = mapper.readValue("{}", MysteryPolymorphic.class); [EOL]     assertNull(ob); [EOL]     ob = mapper.readValue("{ \"whatever\":13}", MysteryPolymorphic.class); [EOL]     assertNull(ob); [EOL] }
public void testBadTypeAsNull() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.disable(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE); [EOL]     Object ob = mapper.readValue("{}", MysteryPolymorphic.class); [EOL]     assertNull(ob); [EOL]     ob = mapper.readValue("{ \"whatever\":13}", MysteryPolymorphic.class); [EOL]     assertNull(ob); [EOL] }
public void testBadTypeAsNull() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.disable(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE); [EOL]     Object ob = mapper.readValue("{}", MysteryPolymorphic.class); [EOL]     assertNull(ob); [EOL]     ob = mapper.readValue("{ \"whatever\":13}", MysteryPolymorphic.class); [EOL]     assertNull(ob); [EOL] }
public void testInterfaceDefaulting() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule mod = new SimpleModule("test", Version.unknownVersion()); [EOL]     mod.addAbstractTypeMapping(CharSequence.class, MyString.class); [EOL]     mapper.registerModule(mod); [EOL]     Object result = mapper.readValue(quote("abc"), CharSequence.class); [EOL]     assertEquals(MyString.class, result.getClass()); [EOL]     assertEquals("abc", ((MyString) result).value); [EOL] }
public void testInterfaceDefaulting() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule mod = new SimpleModule("test", Version.unknownVersion()); [EOL]     mod.addAbstractTypeMapping(CharSequence.class, MyString.class); [EOL]     mapper.registerModule(mod); [EOL]     Object result = mapper.readValue(quote("abc"), CharSequence.class); [EOL]     assertEquals(MyString.class, result.getClass()); [EOL]     assertEquals("abc", ((MyString) result).value); [EOL] }
public void testInterfaceDefaulting() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule mod = new SimpleModule("test", Version.unknownVersion()); [EOL]     mod.addAbstractTypeMapping(CharSequence.class, MyString.class); [EOL]     mapper.registerModule(mod); [EOL]     Object result = mapper.readValue(quote("abc"), CharSequence.class); [EOL]     assertEquals(MyString.class, result.getClass()); [EOL]     assertEquals("abc", ((MyString) result).value); [EOL] }
public void testInterfaceDefaulting() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule mod = new SimpleModule("test", Version.unknownVersion()); [EOL]     mod.addAbstractTypeMapping(CharSequence.class, MyString.class); [EOL]     mapper.registerModule(mod); [EOL]     Object result = mapper.readValue(quote("abc"), CharSequence.class); [EOL]     assertEquals(MyString.class, result.getClass()); [EOL]     assertEquals("abc", ((MyString) result).value); [EOL] }
public void testInterfaceDefaulting() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule mod = new SimpleModule("test", Version.unknownVersion()); [EOL]     mod.addAbstractTypeMapping(CharSequence.class, MyString.class); [EOL]     mapper.registerModule(mod); [EOL]     Object result = mapper.readValue(quote("abc"), CharSequence.class); [EOL]     assertEquals(MyString.class, result.getClass()); [EOL]     assertEquals("abc", ((MyString) result).value); [EOL] }
public void testInterfaceDefaulting() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SimpleModule mod = new SimpleModule("test", Version.unknownVersion()); [EOL]     mod.addAbstractTypeMapping(CharSequence.class, MyString.class); [EOL]     mapper.registerModule(mod); [EOL]     Object result = mapper.readValue(quote("abc"), CharSequence.class); [EOL]     assertEquals(MyString.class, result.getClass()); [EOL]     assertEquals("abc", ((MyString) result).value); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testNullForPrimitives() throws IOException { [EOL]     PrimitivesBean bean = mapper.readValue("{\"intValue\":null, \"booleanValue\":null, \"doubleValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals(0, bean.intValue); [EOL]     assertEquals(false, bean.booleanValue); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL]     bean = mapper.readValue("{\"byteValue\":null, \"longValue\":null, \"floatValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     assertEquals(0L, bean.longValue); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     final ObjectMapper mapper2 = new ObjectMapper(); [EOL]     mapper2.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true); [EOL]     try { [EOL]         mapper2.readValue("{\"booleanValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for boolean + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type boolean"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"byteValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for byte + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type byte"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"charValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for char + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type char"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"shortValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for short + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type short"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"intValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for int + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type int"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"longValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for long + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type long"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"floatValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for float + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type float"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"doubleValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for double + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type double"); [EOL]     } [EOL] }
public void testNullForPrimitives() throws IOException { [EOL]     PrimitivesBean bean = mapper.readValue("{\"intValue\":null, \"booleanValue\":null, \"doubleValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals(0, bean.intValue); [EOL]     assertEquals(false, bean.booleanValue); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL]     bean = mapper.readValue("{\"byteValue\":null, \"longValue\":null, \"floatValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     assertEquals(0L, bean.longValue); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     final ObjectMapper mapper2 = new ObjectMapper(); [EOL]     mapper2.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true); [EOL]     try { [EOL]         mapper2.readValue("{\"booleanValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for boolean + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type boolean"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"byteValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for byte + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type byte"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"charValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for char + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type char"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"shortValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for short + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type short"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"intValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for int + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type int"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"longValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for long + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type long"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"floatValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for float + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type float"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"doubleValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for double + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type double"); [EOL]     } [EOL] }
public void testNullForPrimitives() throws IOException { [EOL]     PrimitivesBean bean = mapper.readValue("{\"intValue\":null, \"booleanValue\":null, \"doubleValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals(0, bean.intValue); [EOL]     assertEquals(false, bean.booleanValue); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL]     bean = mapper.readValue("{\"byteValue\":null, \"longValue\":null, \"floatValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     assertEquals(0L, bean.longValue); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     final ObjectMapper mapper2 = new ObjectMapper(); [EOL]     mapper2.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true); [EOL]     try { [EOL]         mapper2.readValue("{\"booleanValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for boolean + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type boolean"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"byteValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for byte + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type byte"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"charValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for char + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type char"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"shortValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for short + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type short"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"intValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for int + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type int"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"longValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for long + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type long"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"floatValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for float + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type float"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"doubleValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for double + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type double"); [EOL]     } [EOL] }
public void testNullForPrimitives() throws IOException { [EOL]     PrimitivesBean bean = mapper.readValue("{\"intValue\":null, \"booleanValue\":null, \"doubleValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals(0, bean.intValue); [EOL]     assertEquals(false, bean.booleanValue); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL]     bean = mapper.readValue("{\"byteValue\":null, \"longValue\":null, \"floatValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     assertEquals(0L, bean.longValue); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     final ObjectMapper mapper2 = new ObjectMapper(); [EOL]     mapper2.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true); [EOL]     try { [EOL]         mapper2.readValue("{\"booleanValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for boolean + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type boolean"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"byteValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for byte + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type byte"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"charValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for char + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type char"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"shortValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for short + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type short"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"intValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for int + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type int"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"longValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for long + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type long"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"floatValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for float + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type float"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"doubleValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for double + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type double"); [EOL]     } [EOL] }
public void testNullForPrimitives() throws IOException { [EOL]     PrimitivesBean bean = mapper.readValue("{\"intValue\":null, \"booleanValue\":null, \"doubleValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals(0, bean.intValue); [EOL]     assertEquals(false, bean.booleanValue); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL]     bean = mapper.readValue("{\"byteValue\":null, \"longValue\":null, \"floatValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     assertEquals(0L, bean.longValue); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     final ObjectMapper mapper2 = new ObjectMapper(); [EOL]     mapper2.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true); [EOL]     try { [EOL]         mapper2.readValue("{\"booleanValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for boolean + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type boolean"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"byteValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for byte + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type byte"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"charValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for char + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type char"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"shortValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for short + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type short"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"intValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for int + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type int"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"longValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for long + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type long"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"floatValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for float + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type float"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"doubleValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for double + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type double"); [EOL]     } [EOL] }
public void testArrayBlockingQueue() throws Exception { [EOL]     ArrayBlockingQueue<?> q = MAPPER.readValue("[1, 2, 3]", ArrayBlockingQueue.class); [EOL]     assertNotNull(q); [EOL]     assertEquals(3, q.size()); [EOL]     assertEquals(Integer.valueOf(1), q.take()); [EOL]     assertEquals(Integer.valueOf(2), q.take()); [EOL]     assertEquals(Integer.valueOf(3), q.take()); [EOL] }
public void testArrayBlockingQueue() throws Exception { [EOL]     ArrayBlockingQueue<?> q = MAPPER.readValue("[1, 2, 3]", ArrayBlockingQueue.class); [EOL]     assertNotNull(q); [EOL]     assertEquals(3, q.size()); [EOL]     assertEquals(Integer.valueOf(1), q.take()); [EOL]     assertEquals(Integer.valueOf(2), q.take()); [EOL]     assertEquals(Integer.valueOf(3), q.take()); [EOL] }
public void testArrayBlockingQueue() throws Exception { [EOL]     ArrayBlockingQueue<?> q = MAPPER.readValue("[1, 2, 3]", ArrayBlockingQueue.class); [EOL]     assertNotNull(q); [EOL]     assertEquals(3, q.size()); [EOL]     assertEquals(Integer.valueOf(1), q.take()); [EOL]     assertEquals(Integer.valueOf(2), q.take()); [EOL]     assertEquals(Integer.valueOf(3), q.take()); [EOL] }
public void testArrayBlockingQueue() throws Exception { [EOL]     ArrayBlockingQueue<?> q = MAPPER.readValue("[1, 2, 3]", ArrayBlockingQueue.class); [EOL]     assertNotNull(q); [EOL]     assertEquals(3, q.size()); [EOL]     assertEquals(Integer.valueOf(1), q.take()); [EOL]     assertEquals(Integer.valueOf(2), q.take()); [EOL]     assertEquals(Integer.valueOf(3), q.take()); [EOL] }
public void testArrayBlockingQueue() throws Exception { [EOL]     ArrayBlockingQueue<?> q = MAPPER.readValue("[1, 2, 3]", ArrayBlockingQueue.class); [EOL]     assertNotNull(q); [EOL]     assertEquals(3, q.size()); [EOL]     assertEquals(Integer.valueOf(1), q.take()); [EOL]     assertEquals(Integer.valueOf(2), q.take()); [EOL]     assertEquals(Integer.valueOf(3), q.take()); [EOL] }
public void testArrayBlockingQueue() throws Exception { [EOL]     ArrayBlockingQueue<?> q = MAPPER.readValue("[1, 2, 3]", ArrayBlockingQueue.class); [EOL]     assertNotNull(q); [EOL]     assertEquals(3, q.size()); [EOL]     assertEquals(Integer.valueOf(1), q.take()); [EOL]     assertEquals(Integer.valueOf(2), q.take()); [EOL]     assertEquals(Integer.valueOf(3), q.take()); [EOL] }
public void testArrayBlockingQueue() throws Exception { [EOL]     ArrayBlockingQueue<?> q = MAPPER.readValue("[1, 2, 3]", ArrayBlockingQueue.class); [EOL]     assertNotNull(q); [EOL]     assertEquals(3, q.size()); [EOL]     assertEquals(Integer.valueOf(1), q.take()); [EOL]     assertEquals(Integer.valueOf(2), q.take()); [EOL]     assertEquals(Integer.valueOf(3), q.take()); [EOL] }
public void testArrayBlockingQueue() throws Exception { [EOL]     ArrayBlockingQueue<?> q = MAPPER.readValue("[1, 2, 3]", ArrayBlockingQueue.class); [EOL]     assertNotNull(q); [EOL]     assertEquals(3, q.size()); [EOL]     assertEquals(Integer.valueOf(1), q.take()); [EOL]     assertEquals(Integer.valueOf(2), q.take()); [EOL]     assertEquals(Integer.valueOf(3), q.take()); [EOL] }
public void testArrayBlockingQueue() throws Exception { [EOL]     ArrayBlockingQueue<?> q = MAPPER.readValue("[1, 2, 3]", ArrayBlockingQueue.class); [EOL]     assertNotNull(q); [EOL]     assertEquals(3, q.size()); [EOL]     assertEquals(Integer.valueOf(1), q.take()); [EOL]     assertEquals(Integer.valueOf(2), q.take()); [EOL]     assertEquals(Integer.valueOf(3), q.take()); [EOL] }
public void testArrayBlockingQueue() throws Exception { [EOL]     ArrayBlockingQueue<?> q = MAPPER.readValue("[1, 2, 3]", ArrayBlockingQueue.class); [EOL]     assertNotNull(q); [EOL]     assertEquals(3, q.size()); [EOL]     assertEquals(Integer.valueOf(1), q.take()); [EOL]     assertEquals(Integer.valueOf(2), q.take()); [EOL]     assertEquals(Integer.valueOf(3), q.take()); [EOL] }
public void testArrayBlockingQueue() throws Exception { [EOL]     ArrayBlockingQueue<?> q = MAPPER.readValue("[1, 2, 3]", ArrayBlockingQueue.class); [EOL]     assertNotNull(q); [EOL]     assertEquals(3, q.size()); [EOL]     assertEquals(Integer.valueOf(1), q.take()); [EOL]     assertEquals(Integer.valueOf(2), q.take()); [EOL]     assertEquals(Integer.valueOf(3), q.take()); [EOL] }
public void testArrayBlockingQueue() throws Exception { [EOL]     ArrayBlockingQueue<?> q = MAPPER.readValue("[1, 2, 3]", ArrayBlockingQueue.class); [EOL]     assertNotNull(q); [EOL]     assertEquals(3, q.size()); [EOL]     assertEquals(Integer.valueOf(1), q.take()); [EOL]     assertEquals(Integer.valueOf(2), q.take()); [EOL]     assertEquals(Integer.valueOf(3), q.take()); [EOL] }
public void testArrayBlockingQueue() throws Exception { [EOL]     ArrayBlockingQueue<?> q = MAPPER.readValue("[1, 2, 3]", ArrayBlockingQueue.class); [EOL]     assertNotNull(q); [EOL]     assertEquals(3, q.size()); [EOL]     assertEquals(Integer.valueOf(1), q.take()); [EOL]     assertEquals(Integer.valueOf(2), q.take()); [EOL]     assertEquals(Integer.valueOf(3), q.take()); [EOL] }
public void testInnerClassWithType() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(DefaultTyping.NON_FINAL); [EOL]     String json = mapper.writeValueAsString(new BeanWithAnon()); [EOL]     BeanWithAnon result = mapper.readValue(json, BeanWithAnon.class); [EOL]     assertEquals(BeanWithAnon.class, result.getClass()); [EOL] }
public void testInnerClassWithType() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(DefaultTyping.NON_FINAL); [EOL]     String json = mapper.writeValueAsString(new BeanWithAnon()); [EOL]     BeanWithAnon result = mapper.readValue(json, BeanWithAnon.class); [EOL]     assertEquals(BeanWithAnon.class, result.getClass()); [EOL] }
public void testInnerClassWithType() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(DefaultTyping.NON_FINAL); [EOL]     String json = mapper.writeValueAsString(new BeanWithAnon()); [EOL]     BeanWithAnon result = mapper.readValue(json, BeanWithAnon.class); [EOL]     assertEquals(BeanWithAnon.class, result.getClass()); [EOL] }
public void testInnerClassWithType() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(DefaultTyping.NON_FINAL); [EOL]     String json = mapper.writeValueAsString(new BeanWithAnon()); [EOL]     BeanWithAnon result = mapper.readValue(json, BeanWithAnon.class); [EOL]     assertEquals(BeanWithAnon.class, result.getClass()); [EOL] }
public void testInnerClassWithType() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(DefaultTyping.NON_FINAL); [EOL]     String json = mapper.writeValueAsString(new BeanWithAnon()); [EOL]     BeanWithAnon result = mapper.readValue(json, BeanWithAnon.class); [EOL]     assertEquals(BeanWithAnon.class, result.getClass()); [EOL] }
public void testInnerClassWithType() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(DefaultTyping.NON_FINAL); [EOL]     String json = mapper.writeValueAsString(new BeanWithAnon()); [EOL]     BeanWithAnon result = mapper.readValue(json, BeanWithAnon.class); [EOL]     assertEquals(BeanWithAnon.class, result.getClass()); [EOL] }
public void testInnerClassWithType() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.enableDefaultTyping(DefaultTyping.NON_FINAL); [EOL]     String json = mapper.writeValueAsString(new BeanWithAnon()); [EOL]     BeanWithAnon result = mapper.readValue(json, BeanWithAnon.class); [EOL]     assertEquals(BeanWithAnon.class, result.getClass()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testBrokenAnnotation() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     try { [EOL]         serializeAsString(m, new BrokenClass()); [EOL]     } catch (Exception e) { [EOL]         verifyException(e, "not a super-type of"); [EOL]     } [EOL] }
public void testSchemaId() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class); [EOL]     String json = jsonSchema.toString().replaceAll("\"", "'"); [EOL]     assertEquals("{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}", json); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testBase64Variants() throws Exception { [EOL]     final byte[] INPUT = "abcdefghijklmnopqrstuvwxyz1234567890abcdefghijklmnopqrstuvwxyz1234567890X".getBytes("UTF-8"); [EOL]     Assert.assertArrayEquals(INPUT, MAPPER.readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="), byte[].class)); [EOL]     ObjectReader reader = MAPPER.reader(byte[].class); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MIME_NO_LINEFEEDS).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="))); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MIME).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1\\ndnd4eXoxMjM0NTY3ODkwWA=="))); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MODIFIED_FOR_URL).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA"))); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.PEM).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamts\\nbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="))); [EOL] }
public void testBase64Variants() throws Exception { [EOL]     final byte[] INPUT = "abcdefghijklmnopqrstuvwxyz1234567890abcdefghijklmnopqrstuvwxyz1234567890X".getBytes("UTF-8"); [EOL]     Assert.assertArrayEquals(INPUT, MAPPER.readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="), byte[].class)); [EOL]     ObjectReader reader = MAPPER.reader(byte[].class); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MIME_NO_LINEFEEDS).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="))); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MIME).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1\\ndnd4eXoxMjM0NTY3ODkwWA=="))); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MODIFIED_FOR_URL).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA"))); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.PEM).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamts\\nbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="))); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayAsNumbers() throws Exception { [EOL]     final int LEN = 37000; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append('['); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         int value = i - 128; [EOL]         sb.append((value < 256) ? value : (value & 0x7F)); [EOL]         sb.append(','); [EOL]     } [EOL]     sb.append("0]"); [EOL]     byte[] result = MAPPER.readValue(sb.toString(), byte[].class); [EOL]     assertNotNull(result); [EOL]     assertEquals(LEN + 1, result.length); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         int value = i - 128; [EOL]         byte exp = (byte) ((value < 256) ? value : (value & 0x7F)); [EOL]         if (exp != result[i]) { [EOL]             fail("At offset #" + i + " (" + result.length + "), expected " + exp + ", got " + result[i]); [EOL]         } [EOL]         assertEquals(exp, result[i]); [EOL]     } [EOL]     assertEquals(0, result[LEN]); [EOL] }
public void testByteArrayAsNumbers() throws Exception { [EOL]     final int LEN = 37000; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append('['); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         int value = i - 128; [EOL]         sb.append((value < 256) ? value : (value & 0x7F)); [EOL]         sb.append(','); [EOL]     } [EOL]     sb.append("0]"); [EOL]     byte[] result = MAPPER.readValue(sb.toString(), byte[].class); [EOL]     assertNotNull(result); [EOL]     assertEquals(LEN + 1, result.length); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         int value = i - 128; [EOL]         byte exp = (byte) ((value < 256) ? value : (value & 0x7F)); [EOL]         if (exp != result[i]) { [EOL]             fail("At offset #" + i + " (" + result.length + "), expected " + exp + ", got " + result[i]); [EOL]         } [EOL]         assertEquals(exp, result[i]); [EOL]     } [EOL]     assertEquals(0, result[LEN]); [EOL] }
public void testByteArrayAsNumbers() throws Exception { [EOL]     final int LEN = 37000; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append('['); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         int value = i - 128; [EOL]         sb.append((value < 256) ? value : (value & 0x7F)); [EOL]         sb.append(','); [EOL]     } [EOL]     sb.append("0]"); [EOL]     byte[] result = MAPPER.readValue(sb.toString(), byte[].class); [EOL]     assertNotNull(result); [EOL]     assertEquals(LEN + 1, result.length); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         int value = i - 128; [EOL]         byte exp = (byte) ((value < 256) ? value : (value & 0x7F)); [EOL]         if (exp != result[i]) { [EOL]             fail("At offset #" + i + " (" + result.length + "), expected " + exp + ", got " + result[i]); [EOL]         } [EOL]         assertEquals(exp, result[i]); [EOL]     } [EOL]     assertEquals(0, result[LEN]); [EOL] }
public void testByteArrayAsNumbers() throws Exception { [EOL]     final int LEN = 37000; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append('['); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         int value = i - 128; [EOL]         sb.append((value < 256) ? value : (value & 0x7F)); [EOL]         sb.append(','); [EOL]     } [EOL]     sb.append("0]"); [EOL]     byte[] result = MAPPER.readValue(sb.toString(), byte[].class); [EOL]     assertNotNull(result); [EOL]     assertEquals(LEN + 1, result.length); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         int value = i - 128; [EOL]         byte exp = (byte) ((value < 256) ? value : (value & 0x7F)); [EOL]         if (exp != result[i]) { [EOL]             fail("At offset #" + i + " (" + result.length + "), expected " + exp + ", got " + result[i]); [EOL]         } [EOL]         assertEquals(exp, result[i]); [EOL]     } [EOL]     assertEquals(0, result[LEN]); [EOL] }
public void testByteArrayAsNumbers() throws Exception { [EOL]     final int LEN = 37000; [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append('['); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         int value = i - 128; [EOL]         sb.append((value < 256) ? value : (value & 0x7F)); [EOL]         sb.append(','); [EOL]     } [EOL]     sb.append("0]"); [EOL]     byte[] result = MAPPER.readValue(sb.toString(), byte[].class); [EOL]     assertNotNull(result); [EOL]     assertEquals(LEN + 1, result.length); [EOL]     for (int i = 0; i < LEN; ++i) { [EOL]         int value = i - 128; [EOL]         byte exp = (byte) ((value < 256) ? value : (value & 0x7F)); [EOL]         if (exp != result[i]) { [EOL]             fail("At offset #" + i + " (" + result.length + "), expected " + exp + ", got " + result[i]); [EOL]         } [EOL]         assertEquals(exp, result[i]); [EOL]     } [EOL]     assertEquals(0, result[LEN]); [EOL] }
public void testSkipChildrenWrt370() throws Exception { [EOL]     ObjectMapper o = new ObjectMapper(); [EOL]     ObjectNode n = o.createObjectNode(); [EOL]     n.putObject("inner").put("value", "test"); [EOL]     n.putObject("unknown").putNull("inner"); [EOL]     Jackson370Bean obj = o.readValue(n.traverse(), Jackson370Bean.class); [EOL]     assertNotNull(obj.inner); [EOL]     assertEquals("test", obj.inner.value); [EOL] }
public void testSkipChildrenWrt370() throws Exception { [EOL]     ObjectMapper o = new ObjectMapper(); [EOL]     ObjectNode n = o.createObjectNode(); [EOL]     n.putObject("inner").put("value", "test"); [EOL]     n.putObject("unknown").putNull("inner"); [EOL]     Jackson370Bean obj = o.readValue(n.traverse(), Jackson370Bean.class); [EOL]     assertNotNull(obj.inner); [EOL]     assertEquals("test", obj.inner.value); [EOL] }
public void testSkipChildrenWrt370() throws Exception { [EOL]     ObjectMapper o = new ObjectMapper(); [EOL]     ObjectNode n = o.createObjectNode(); [EOL]     n.putObject("inner").put("value", "test"); [EOL]     n.putObject("unknown").putNull("inner"); [EOL]     Jackson370Bean obj = o.readValue(n.traverse(), Jackson370Bean.class); [EOL]     assertNotNull(obj.inner); [EOL]     assertEquals("test", obj.inner.value); [EOL] }
public void testSkipChildrenWrt370() throws Exception { [EOL]     ObjectMapper o = new ObjectMapper(); [EOL]     ObjectNode n = o.createObjectNode(); [EOL]     n.putObject("inner").put("value", "test"); [EOL]     n.putObject("unknown").putNull("inner"); [EOL]     Jackson370Bean obj = o.readValue(n.traverse(), Jackson370Bean.class); [EOL]     assertNotNull(obj.inner); [EOL]     assertEquals("test", obj.inner.value); [EOL] }
public void testInsertInListNoDup() { [EOL]     String[] arr = new String[] { "me", "you", "him" }; [EOL]     String[] newarr; [EOL]     newarr = ArrayBuilders.insertInListNoDup(arr, "you"); [EOL]     Assert.assertArrayEquals(new String[] { "you", "me", "him" }, newarr); [EOL]     newarr = ArrayBuilders.insertInListNoDup(arr, "me"); [EOL]     Assert.assertArrayEquals(new String[] { "me", "you", "him" }, newarr); [EOL]     newarr = ArrayBuilders.insertInListNoDup(arr, "him"); [EOL]     Assert.assertArrayEquals(new String[] { "him", "me", "you" }, newarr); [EOL]     newarr = ArrayBuilders.insertInListNoDup(arr, "foobar"); [EOL]     Assert.assertArrayEquals(new String[] { "foobar", "me", "you", "him" }, newarr); [EOL] }
public void testInsertInListNoDup() { [EOL]     String[] arr = new String[] { "me", "you", "him" }; [EOL]     String[] newarr; [EOL]     newarr = ArrayBuilders.insertInListNoDup(arr, "you"); [EOL]     Assert.assertArrayEquals(new String[] { "you", "me", "him" }, newarr); [EOL]     newarr = ArrayBuilders.insertInListNoDup(arr, "me"); [EOL]     Assert.assertArrayEquals(new String[] { "me", "you", "him" }, newarr); [EOL]     newarr = ArrayBuilders.insertInListNoDup(arr, "him"); [EOL]     Assert.assertArrayEquals(new String[] { "him", "me", "you" }, newarr); [EOL]     newarr = ArrayBuilders.insertInListNoDup(arr, "foobar"); [EOL]     Assert.assertArrayEquals(new String[] { "foobar", "me", "you", "him" }, newarr); [EOL] }
public void testInsertInListNoDup() { [EOL]     String[] arr = new String[] { "me", "you", "him" }; [EOL]     String[] newarr; [EOL]     newarr = ArrayBuilders.insertInListNoDup(arr, "you"); [EOL]     Assert.assertArrayEquals(new String[] { "you", "me", "him" }, newarr); [EOL]     newarr = ArrayBuilders.insertInListNoDup(arr, "me"); [EOL]     Assert.assertArrayEquals(new String[] { "me", "you", "him" }, newarr); [EOL]     newarr = ArrayBuilders.insertInListNoDup(arr, "him"); [EOL]     Assert.assertArrayEquals(new String[] { "him", "me", "you" }, newarr); [EOL]     newarr = ArrayBuilders.insertInListNoDup(arr, "foobar"); [EOL]     Assert.assertArrayEquals(new String[] { "foobar", "me", "you", "him" }, newarr); [EOL] }
public void testInsertInListNoDup() { [EOL]     String[] arr = new String[] { "me", "you", "him" }; [EOL]     String[] newarr; [EOL]     newarr = ArrayBuilders.insertInListNoDup(arr, "you"); [EOL]     Assert.assertArrayEquals(new String[] { "you", "me", "him" }, newarr); [EOL]     newarr = ArrayBuilders.insertInListNoDup(arr, "me"); [EOL]     Assert.assertArrayEquals(new String[] { "me", "you", "him" }, newarr); [EOL]     newarr = ArrayBuilders.insertInListNoDup(arr, "him"); [EOL]     Assert.assertArrayEquals(new String[] { "him", "me", "you" }, newarr); [EOL]     newarr = ArrayBuilders.insertInListNoDup(arr, "foobar"); [EOL]     Assert.assertArrayEquals(new String[] { "foobar", "me", "you", "him" }, newarr); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testDeepUnwrappingSerialize() throws Exception { [EOL]     assertEquals("{\"name\":\"Tatu\",\"x\":1,\"y\":2}", mapper.writeValueAsString(new DeepUnwrapping("Tatu", 1, 2))); [EOL] }
public void testDeepUnwrappingSerialize() throws Exception { [EOL]     assertEquals("{\"name\":\"Tatu\",\"x\":1,\"y\":2}", mapper.writeValueAsString(new DeepUnwrapping("Tatu", 1, 2))); [EOL] }
public void testDeepUnwrappingSerialize() throws Exception { [EOL]     assertEquals("{\"name\":\"Tatu\",\"x\":1,\"y\":2}", mapper.writeValueAsString(new DeepUnwrapping("Tatu", 1, 2))); [EOL] }
public void testDeepUnwrappingSerialize() throws Exception { [EOL]     assertEquals("{\"name\":\"Tatu\",\"x\":1,\"y\":2}", mapper.writeValueAsString(new DeepUnwrapping("Tatu", 1, 2))); [EOL] }
public void testDeepUnwrappingSerialize() throws Exception { [EOL]     assertEquals("{\"name\":\"Tatu\",\"x\":1,\"y\":2}", mapper.writeValueAsString(new DeepUnwrapping("Tatu", 1, 2))); [EOL] }
public void testDeepUnwrappingSerialize() throws Exception { [EOL]     assertEquals("{\"name\":\"Tatu\",\"x\":1,\"y\":2}", mapper.writeValueAsString(new DeepUnwrapping("Tatu", 1, 2))); [EOL] }
public void testEmptyWithAnnotations() throws Exception { [EOL]     try { [EOL]         serializeAsString(mapper, new Empty()); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "No serializer found for class"); [EOL]     } [EOL]     assertEquals("{}", serializeAsString(mapper, new EmptyWithAnno())); [EOL]     ObjectMapper m2 = new ObjectMapper(); [EOL]     m2.addMixInAnnotations(Empty.class, EmptyWithAnno.class); [EOL]     assertEquals("{}", m2.writeValueAsString(new Empty())); [EOL] }
public void testEmptyWithAnnotations() throws Exception { [EOL]     try { [EOL]         serializeAsString(mapper, new Empty()); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "No serializer found for class"); [EOL]     } [EOL]     assertEquals("{}", serializeAsString(mapper, new EmptyWithAnno())); [EOL]     ObjectMapper m2 = new ObjectMapper(); [EOL]     m2.addMixInAnnotations(Empty.class, EmptyWithAnno.class); [EOL]     assertEquals("{}", m2.writeValueAsString(new Empty())); [EOL] }
public void testDeepUnwrappingSerialize() throws Exception { [EOL]     assertEquals("{\"name\":\"Tatu\",\"x\":1,\"y\":2}", mapper.writeValueAsString(new DeepUnwrapping("Tatu", 1, 2))); [EOL] }
public void testDeepUnwrappingSerialize() throws Exception { [EOL]     assertEquals("{\"name\":\"Tatu\",\"x\":1,\"y\":2}", mapper.writeValueAsString(new DeepUnwrapping("Tatu", 1, 2))); [EOL] }
public void testDeepUnwrappingSerialize() throws Exception { [EOL]     assertEquals("{\"name\":\"Tatu\",\"x\":1,\"y\":2}", mapper.writeValueAsString(new DeepUnwrapping("Tatu", 1, 2))); [EOL] }
public void testDeepUnwrappingSerialize() throws Exception { [EOL]     assertEquals("{\"name\":\"Tatu\",\"x\":1,\"y\":2}", mapper.writeValueAsString(new DeepUnwrapping("Tatu", 1, 2))); [EOL] }
public void testDeepUnwrappingSerialize() throws Exception { [EOL]     assertEquals("{\"name\":\"Tatu\",\"x\":1,\"y\":2}", mapper.writeValueAsString(new DeepUnwrapping("Tatu", 1, 2))); [EOL] }
public void testDeepUnwrappingSerialize() throws Exception { [EOL]     assertEquals("{\"name\":\"Tatu\",\"x\":1,\"y\":2}", mapper.writeValueAsString(new DeepUnwrapping("Tatu", 1, 2))); [EOL] }
public void testDeepUnwrappingSerialize() throws Exception { [EOL]     assertEquals("{\"name\":\"Tatu\",\"x\":1,\"y\":2}", mapper.writeValueAsString(new DeepUnwrapping("Tatu", 1, 2))); [EOL] }
public void testTypeIdFromArray() throws Exception { [EOL]     assertEquals("[\"SomeType\",{\"a\":3}]", mapper.writeValueAsString(new TypeIdFromFieldArray())); [EOL] }
public void testTypeIdFromArray() throws Exception { [EOL]     assertEquals("[\"SomeType\",{\"a\":3}]", mapper.writeValueAsString(new TypeIdFromFieldArray())); [EOL] }
public void testTypeIdFromArray() throws Exception { [EOL]     assertEquals("[\"SomeType\",{\"a\":3}]", mapper.writeValueAsString(new TypeIdFromFieldArray())); [EOL] }
public void testTypeIdFromArray() throws Exception { [EOL]     assertEquals("[\"SomeType\",{\"a\":3}]", mapper.writeValueAsString(new TypeIdFromFieldArray())); [EOL] }
public void testTypeIdFromArray() throws Exception { [EOL]     assertEquals("[\"SomeType\",{\"a\":3}]", mapper.writeValueAsString(new TypeIdFromFieldArray())); [EOL] }
public void testTypeIdFromArray() throws Exception { [EOL]     assertEquals("[\"SomeType\",{\"a\":3}]", mapper.writeValueAsString(new TypeIdFromFieldArray())); [EOL] }
public void testTypeIdFromArray() throws Exception { [EOL]     assertEquals("[\"SomeType\",{\"a\":3}]", mapper.writeValueAsString(new TypeIdFromFieldArray())); [EOL] }
public void testSchemaId() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class); [EOL]     String json = jsonSchema.toString().replaceAll("\"", "'"); [EOL]     assertEquals("{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}", json); [EOL] }
public void testSchemaId() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class); [EOL]     String json = jsonSchema.toString().replaceAll("\"", "'"); [EOL]     assertEquals("{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}", json); [EOL] }
public void testPropertyReorder() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new ModuleImpl(new ReorderingModifier())); [EOL]     Bean bean = new Bean(); [EOL]     assertEquals("{\"a\":\"a\",\"b\":\"b\"}", mapper.writeValueAsString(bean)); [EOL] }
public void testModifyEnumSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setSerializerModifier(new EnumSerializerModifier())); [EOL]     assertEquals("123", mapper.writeValueAsString(EnumABC.C)); [EOL] }
public void testSimpleOrderingForDeserialization() { [EOL]     POJOPropertiesCollector coll = collector(mapper, SortedProperties.class, false); [EOL]     List<BeanPropertyDefinition> props = coll.getProperties(); [EOL]     assertEquals(4, props.size()); [EOL]     assertEquals("a", props.get(0).getName()); [EOL]     assertEquals("b", props.get(1).getName()); [EOL]     assertEquals("c", props.get(2).getName()); [EOL]     assertEquals("d", props.get(3).getName()); [EOL] }
public void testSimpleOrderingForDeserialization() { [EOL]     POJOPropertiesCollector coll = collector(mapper, SortedProperties.class, false); [EOL]     List<BeanPropertyDefinition> props = coll.getProperties(); [EOL]     assertEquals(4, props.size()); [EOL]     assertEquals("a", props.get(0).getName()); [EOL]     assertEquals("b", props.get(1).getName()); [EOL]     assertEquals("c", props.get(2).getName()); [EOL]     assertEquals("d", props.get(3).getName()); [EOL] }
public void testSimpleOrderingForDeserialization() { [EOL]     POJOPropertiesCollector coll = collector(mapper, SortedProperties.class, false); [EOL]     List<BeanPropertyDefinition> props = coll.getProperties(); [EOL]     assertEquals(4, props.size()); [EOL]     assertEquals("a", props.get(0).getName()); [EOL]     assertEquals("b", props.get(1).getName()); [EOL]     assertEquals("c", props.get(2).getName()); [EOL]     assertEquals("d", props.get(3).getName()); [EOL] }
public void testSimpleOrderingForDeserialization() { [EOL]     POJOPropertiesCollector coll = collector(mapper, SortedProperties.class, false); [EOL]     List<BeanPropertyDefinition> props = coll.getProperties(); [EOL]     assertEquals(4, props.size()); [EOL]     assertEquals("a", props.get(0).getName()); [EOL]     assertEquals("b", props.get(1).getName()); [EOL]     assertEquals("c", props.get(2).getName()); [EOL]     assertEquals("d", props.get(3).getName()); [EOL] }
public void testSimpleOrderingForDeserialization() { [EOL]     POJOPropertiesCollector coll = collector(mapper, SortedProperties.class, false); [EOL]     List<BeanPropertyDefinition> props = coll.getProperties(); [EOL]     assertEquals(4, props.size()); [EOL]     assertEquals("a", props.get(0).getName()); [EOL]     assertEquals("b", props.get(1).getName()); [EOL]     assertEquals("c", props.get(2).getName()); [EOL]     assertEquals("d", props.get(3).getName()); [EOL] }
public void testSimpleFieldVisibility() { [EOL]     POJOPropertiesCollector coll = collector(mapper, SimpleFieldDeser.class, false); [EOL]     Map<String, POJOPropertyBuilder> props = coll.getPropertyMap(); [EOL]     assertEquals(1, props.size()); [EOL]     POJOPropertyBuilder prop = props.get("values"); [EOL]     assertNotNull(prop); [EOL]     assertFalse(prop.hasSetter()); [EOL]     assertFalse(prop.hasGetter()); [EOL]     assertTrue(prop.hasField()); [EOL] }
public void testSimpleFieldVisibility() { [EOL]     POJOPropertiesCollector coll = collector(mapper, SimpleFieldDeser.class, false); [EOL]     Map<String, POJOPropertyBuilder> props = coll.getPropertyMap(); [EOL]     assertEquals(1, props.size()); [EOL]     POJOPropertyBuilder prop = props.get("values"); [EOL]     assertNotNull(prop); [EOL]     assertFalse(prop.hasSetter()); [EOL]     assertFalse(prop.hasGetter()); [EOL]     assertTrue(prop.hasField()); [EOL] }
public void testSimpleFieldVisibility() { [EOL]     POJOPropertiesCollector coll = collector(mapper, SimpleFieldDeser.class, false); [EOL]     Map<String, POJOPropertyBuilder> props = coll.getPropertyMap(); [EOL]     assertEquals(1, props.size()); [EOL]     POJOPropertyBuilder prop = props.get("values"); [EOL]     assertNotNull(prop); [EOL]     assertFalse(prop.hasSetter()); [EOL]     assertFalse(prop.hasGetter()); [EOL]     assertTrue(prop.hasField()); [EOL] }
public void testSimpleFieldVisibility() { [EOL]     POJOPropertiesCollector coll = collector(mapper, SimpleFieldDeser.class, false); [EOL]     Map<String, POJOPropertyBuilder> props = coll.getPropertyMap(); [EOL]     assertEquals(1, props.size()); [EOL]     POJOPropertyBuilder prop = props.get("values"); [EOL]     assertNotNull(prop); [EOL]     assertFalse(prop.hasSetter()); [EOL]     assertFalse(prop.hasGetter()); [EOL]     assertTrue(prop.hasField()); [EOL] }
public void testSimpleFieldVisibility() { [EOL]     POJOPropertiesCollector coll = collector(mapper, SimpleFieldDeser.class, false); [EOL]     Map<String, POJOPropertyBuilder> props = coll.getPropertyMap(); [EOL]     assertEquals(1, props.size()); [EOL]     POJOPropertyBuilder prop = props.get("values"); [EOL]     assertNotNull(prop); [EOL]     assertFalse(prop.hasSetter()); [EOL]     assertFalse(prop.hasGetter()); [EOL]     assertTrue(prop.hasField()); [EOL] }
public void testSimpleFieldVisibility() { [EOL]     POJOPropertiesCollector coll = collector(mapper, SimpleFieldDeser.class, false); [EOL]     Map<String, POJOPropertyBuilder> props = coll.getPropertyMap(); [EOL]     assertEquals(1, props.size()); [EOL]     POJOPropertyBuilder prop = props.get("values"); [EOL]     assertNotNull(prop); [EOL]     assertFalse(prop.hasSetter()); [EOL]     assertFalse(prop.hasGetter()); [EOL]     assertTrue(prop.hasField()); [EOL] }
public void testSimpleSetters() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setPropertyNamingStrategy(new PrefixStrategy()); [EOL]     SetterBean bean = mapper.readValue("{\"Set-key\":13}", SetterBean.class); [EOL]     assertEquals(13, bean.value); [EOL] }
public void testSimpleSetters() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setPropertyNamingStrategy(new PrefixStrategy()); [EOL]     SetterBean bean = mapper.readValue("{\"Set-key\":13}", SetterBean.class); [EOL]     assertEquals(13, bean.value); [EOL] }
public void testSimpleSetters() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setPropertyNamingStrategy(new PrefixStrategy()); [EOL]     SetterBean bean = mapper.readValue("{\"Set-key\":13}", SetterBean.class); [EOL]     assertEquals(13, bean.value); [EOL] }
public void testSimpleSetters() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setPropertyNamingStrategy(new PrefixStrategy()); [EOL]     SetterBean bean = mapper.readValue("{\"Set-key\":13}", SetterBean.class); [EOL]     assertEquals(13, bean.value); [EOL] }
public void testSimpleSetters() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setPropertyNamingStrategy(new PrefixStrategy()); [EOL]     SetterBean bean = mapper.readValue("{\"Set-key\":13}", SetterBean.class); [EOL]     assertEquals(13, bean.value); [EOL] }
public void testSimpleSetters() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setPropertyNamingStrategy(new PrefixStrategy()); [EOL]     SetterBean bean = mapper.readValue("{\"Set-key\":13}", SetterBean.class); [EOL]     assertEquals(13, bean.value); [EOL] }
public void testAbstract368() throws Exception { [EOL]     AbstractNode parent = new ConcreteNode("p"); [EOL]     AbstractNode child = new ConcreteNode("c"); [EOL]     parent.next = child; [EOL]     child.prev = parent; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(parent); [EOL]     AbstractNode root = mapper.readValue(json, AbstractNode.class); [EOL]     assertEquals(ConcreteNode.class, root.getClass()); [EOL]     assertEquals("p", root.id); [EOL]     assertNull(root.prev); [EOL]     AbstractNode leaf = root.next; [EOL]     assertNotNull(leaf); [EOL]     assertEquals("c", leaf.id); [EOL]     assertSame(root, leaf.prev); [EOL] }
public void testAbstract368() throws Exception { [EOL]     AbstractNode parent = new ConcreteNode("p"); [EOL]     AbstractNode child = new ConcreteNode("c"); [EOL]     parent.next = child; [EOL]     child.prev = parent; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(parent); [EOL]     AbstractNode root = mapper.readValue(json, AbstractNode.class); [EOL]     assertEquals(ConcreteNode.class, root.getClass()); [EOL]     assertEquals("p", root.id); [EOL]     assertNull(root.prev); [EOL]     AbstractNode leaf = root.next; [EOL]     assertNotNull(leaf); [EOL]     assertEquals("c", leaf.id); [EOL]     assertSame(root, leaf.prev); [EOL] }
public void testAbstract368() throws Exception { [EOL]     AbstractNode parent = new ConcreteNode("p"); [EOL]     AbstractNode child = new ConcreteNode("c"); [EOL]     parent.next = child; [EOL]     child.prev = parent; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(parent); [EOL]     AbstractNode root = mapper.readValue(json, AbstractNode.class); [EOL]     assertEquals(ConcreteNode.class, root.getClass()); [EOL]     assertEquals("p", root.id); [EOL]     assertNull(root.prev); [EOL]     AbstractNode leaf = root.next; [EOL]     assertNotNull(leaf); [EOL]     assertEquals("c", leaf.id); [EOL]     assertSame(root, leaf.prev); [EOL] }
public void testBase64Variants() throws Exception { [EOL]     final byte[] INPUT = "abcdefghijklmnopqrstuvwxyz1234567890abcdefghijklmnopqrstuvwxyz1234567890X".getBytes("UTF-8"); [EOL]     Assert.assertArrayEquals(INPUT, MAPPER.readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="), byte[].class)); [EOL]     ObjectReader reader = MAPPER.reader(byte[].class); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MIME_NO_LINEFEEDS).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="))); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MIME).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1\\ndnd4eXoxMjM0NTY3ODkwWA=="))); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MODIFIED_FOR_URL).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA"))); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.PEM).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamts\\nbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="))); [EOL] }
public void testBase64Variants() throws Exception { [EOL]     final byte[] INPUT = "abcdefghijklmnopqrstuvwxyz1234567890abcdefghijklmnopqrstuvwxyz1234567890X".getBytes("UTF-8"); [EOL]     Assert.assertArrayEquals(INPUT, MAPPER.readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="), byte[].class)); [EOL]     ObjectReader reader = MAPPER.reader(byte[].class); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MIME_NO_LINEFEEDS).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="))); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MIME).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1\\ndnd4eXoxMjM0NTY3ODkwWA=="))); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MODIFIED_FOR_URL).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA"))); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.PEM).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamts\\nbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="))); [EOL] }
@SuppressWarnings("unused") [EOL] public void testSerializeAsExternalizable() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     ObjectOutputStream obs = new ObjectOutputStream(bytes); [EOL]     final MyPojo input = new MyPojo(13, "Foobar", new int[] { 1, 2, 3 }); [EOL]     obs.writeObject(input); [EOL]     obs.close(); [EOL]     byte[] ser = bytes.toByteArray(); [EOL]     byte[] json = MapperHolder.mapper().writeValueAsBytes(input); [EOL]     int ix = indexOf(ser, json); [EOL]     if (ix < 0) { [EOL]         fail("Serialization (" + ser.length + ") does NOT contain JSON (of " + json.length + ")"); [EOL]     } [EOL]     if (false) { [EOL]         bytes = new ByteArrayOutputStream(); [EOL]         obs = new ObjectOutputStream(bytes); [EOL]         MyPojoNative p = new MyPojoNative(13, "Foobar", new int[] { 1, 2, 3 }); [EOL]         obs.writeObject(p); [EOL]         obs.close(); [EOL]         System.out.println("Native size: " + bytes.size() + ", vs JSON: " + ser.length); [EOL]     } [EOL]     ObjectInputStream ins = new ObjectInputStream(new ByteArrayInputStream(ser)); [EOL]     MyPojo output = (MyPojo) ins.readObject(); [EOL]     ins.close(); [EOL]     assertNotNull(output); [EOL]     assertEquals(input, output); [EOL] }
@SuppressWarnings("unused") [EOL] public void testSerializeAsExternalizable() throws Exception { [EOL]     ByteArrayOutputStream bytes = new ByteArrayOutputStream(); [EOL]     ObjectOutputStream obs = new ObjectOutputStream(bytes); [EOL]     final MyPojo input = new MyPojo(13, "Foobar", new int[] { 1, 2, 3 }); [EOL]     obs.writeObject(input); [EOL]     obs.close(); [EOL]     byte[] ser = bytes.toByteArray(); [EOL]     byte[] json = MapperHolder.mapper().writeValueAsBytes(input); [EOL]     int ix = indexOf(ser, json); [EOL]     if (ix < 0) { [EOL]         fail("Serialization (" + ser.length + ") does NOT contain JSON (of " + json.length + ")"); [EOL]     } [EOL]     if (false) { [EOL]         bytes = new ByteArrayOutputStream(); [EOL]         obs = new ObjectOutputStream(bytes); [EOL]         MyPojoNative p = new MyPojoNative(13, "Foobar", new int[] { 1, 2, 3 }); [EOL]         obs.writeObject(p); [EOL]         obs.close(); [EOL]         System.out.println("Native size: " + bytes.size() + ", vs JSON: " + ser.length); [EOL]     } [EOL]     ObjectInputStream ins = new ObjectInputStream(new ByteArrayInputStream(ser)); [EOL]     MyPojo output = (MyPojo) ins.readObject(); [EOL]     ins.close(); [EOL]     assertNotNull(output); [EOL]     assertEquals(input, output); [EOL] }
public void testNullHandling() throws Exception { [EOL]     JsonNode n = objectReader().readTree("null"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     n = objectMapper().readTree("null"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     ObjectNode root = (ObjectNode) objectReader().readTree("{\"x\":null}"); [EOL]     assertEquals(1, root.size()); [EOL]     n = root.get("x"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL] }
public void testNullHandling() throws Exception { [EOL]     JsonNode n = objectReader().readTree("null"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     n = objectMapper().readTree("null"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     ObjectNode root = (ObjectNode) objectReader().readTree("{\"x\":null}"); [EOL]     assertEquals(1, root.size()); [EOL]     n = root.get("x"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL] }
public void testRootArraysWithParser() throws Exception { [EOL]     final String JSON = "[1][3]"; [EOL]     JsonParser jp = MAPPER.getFactory().createParser(JSON); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     Iterator<int[]> it = MAPPER.reader(int[].class).readValues(jp); [EOL]     assertTrue(it.hasNext()); [EOL]     int[] array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(1, array[0]); [EOL]     assertTrue(it.hasNext()); [EOL]     array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(3, array[0]); [EOL]     assertFalse(it.hasNext()); [EOL] }
public void testRootArraysWithParser() throws Exception { [EOL]     final String JSON = "[1][3]"; [EOL]     JsonParser jp = MAPPER.getFactory().createParser(JSON); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     Iterator<int[]> it = MAPPER.reader(int[].class).readValues(jp); [EOL]     assertTrue(it.hasNext()); [EOL]     int[] array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(1, array[0]); [EOL]     assertTrue(it.hasNext()); [EOL]     array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(3, array[0]); [EOL]     assertFalse(it.hasNext()); [EOL] }
public void testRootArraysWithParser() throws Exception { [EOL]     final String JSON = "[1][3]"; [EOL]     JsonParser jp = MAPPER.getFactory().createParser(JSON); [EOL]     assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]     Iterator<int[]> it = MAPPER.reader(int[].class).readValues(jp); [EOL]     assertTrue(it.hasNext()); [EOL]     int[] array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(1, array[0]); [EOL]     assertTrue(it.hasNext()); [EOL]     array = it.next(); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(3, array[0]); [EOL]     assertFalse(it.hasNext()); [EOL] }
public void testNullHandling() throws Exception { [EOL]     JsonNode n = objectReader().readTree("null"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     n = objectMapper().readTree("null"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     ObjectNode root = (ObjectNode) objectReader().readTree("{\"x\":null}"); [EOL]     assertEquals(1, root.size()); [EOL]     n = root.get("x"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL] }
public void testNullHandling() throws Exception { [EOL]     JsonNode n = objectReader().readTree("null"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     n = objectMapper().readTree("null"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     ObjectNode root = (ObjectNode) objectReader().readTree("{\"x\":null}"); [EOL]     assertEquals(1, root.size()); [EOL]     n = root.get("x"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL] }
public void testNullHandling() throws Exception { [EOL]     JsonNode n = objectReader().readTree("null"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     n = objectMapper().readTree("null"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     ObjectNode root = (ObjectNode) objectReader().readTree("{\"x\":null}"); [EOL]     assertEquals(1, root.size()); [EOL]     n = root.get("x"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL] }
public void testNullHandling() throws Exception { [EOL]     JsonNode n = objectReader().readTree("null"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     n = objectMapper().readTree("null"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     ObjectNode root = (ObjectNode) objectReader().readTree("{\"x\":null}"); [EOL]     assertEquals(1, root.size()); [EOL]     n = root.get("x"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL] }
public void testNullHandling() throws Exception { [EOL]     JsonNode n = objectReader().readTree("null"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     n = objectMapper().readTree("null"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     ObjectNode root = (ObjectNode) objectReader().readTree("{\"x\":null}"); [EOL]     assertEquals(1, root.size()); [EOL]     n = root.get("x"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL] }
public void testNullHandling() throws Exception { [EOL]     JsonNode n = objectReader().readTree("null"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     n = objectMapper().readTree("null"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     ObjectNode root = (ObjectNode) objectReader().readTree("{\"x\":null}"); [EOL]     assertEquals(1, root.size()); [EOL]     n = root.get("x"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL] }
public void testNullHandling() throws Exception { [EOL]     JsonNode n = objectReader().readTree("null"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     n = objectMapper().readTree("null"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     ObjectNode root = (ObjectNode) objectReader().readTree("{\"x\":null}"); [EOL]     assertEquals(1, root.size()); [EOL]     n = root.get("x"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL] }
public void testNullHandling() throws Exception { [EOL]     JsonNode n = objectReader().readTree("null"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     n = objectMapper().readTree("null"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     ObjectNode root = (ObjectNode) objectReader().readTree("{\"x\":null}"); [EOL]     assertEquals(1, root.size()); [EOL]     n = root.get("x"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL] }
public void testNullHandling() throws Exception { [EOL]     JsonNode n = objectReader().readTree("null"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     n = objectMapper().readTree("null"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     ObjectNode root = (ObjectNode) objectReader().readTree("{\"x\":null}"); [EOL]     assertEquals(1, root.size()); [EOL]     n = root.get("x"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL] }
public void testNullHandling() throws Exception { [EOL]     JsonNode n = objectReader().readTree("null"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     n = objectMapper().readTree("null"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     ObjectNode root = (ObjectNode) objectReader().readTree("{\"x\":null}"); [EOL]     assertEquals(1, root.size()); [EOL]     n = root.get("x"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL] }
public void testBase64Variants() throws Exception { [EOL]     final byte[] INPUT = "abcdefghijklmnopqrstuvwxyz1234567890abcdefghijklmnopqrstuvwxyz1234567890X".getBytes("UTF-8"); [EOL]     Assert.assertArrayEquals(INPUT, MAPPER.readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="), byte[].class)); [EOL]     ObjectReader reader = MAPPER.reader(byte[].class); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MIME_NO_LINEFEEDS).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="))); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MIME).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1\\ndnd4eXoxMjM0NTY3ODkwWA=="))); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MODIFIED_FOR_URL).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA"))); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.PEM).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamts\\nbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="))); [EOL] }
public void testBase64Variants() throws Exception { [EOL]     final byte[] INPUT = "abcdefghijklmnopqrstuvwxyz1234567890abcdefghijklmnopqrstuvwxyz1234567890X".getBytes("UTF-8"); [EOL]     Assert.assertArrayEquals(INPUT, MAPPER.readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="), byte[].class)); [EOL]     ObjectReader reader = MAPPER.reader(byte[].class); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MIME_NO_LINEFEEDS).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="))); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MIME).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1\\ndnd4eXoxMjM0NTY3ODkwWA=="))); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MODIFIED_FOR_URL).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA"))); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.PEM).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamts\\nbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="))); [EOL] }
public void testBase64Variants() throws Exception { [EOL]     final byte[] INPUT = "abcdefghijklmnopqrstuvwxyz1234567890abcdefghijklmnopqrstuvwxyz1234567890X".getBytes("UTF-8"); [EOL]     Assert.assertArrayEquals(INPUT, MAPPER.readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="), byte[].class)); [EOL]     ObjectReader reader = MAPPER.reader(byte[].class); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MIME_NO_LINEFEEDS).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="))); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MIME).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1\\ndnd4eXoxMjM0NTY3ODkwWA=="))); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MODIFIED_FOR_URL).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA"))); [EOL]     Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.PEM).readValue(quote("YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamts\\nbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA=="))); [EOL] }
public void testIssue508() throws Exception { [EOL]     List<List<Issue508A>> l = new ArrayList<List<Issue508A>>(); [EOL]     List<Issue508A> l2 = new ArrayList<Issue508A>(); [EOL]     l2.add(new Issue508A()); [EOL]     l.add(l2); [EOL]     TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() { [EOL]     }; [EOL]     String json = mapper.writerWithType(typeRef).writeValueAsString(l); [EOL]     List<?> output = mapper.readValue(json, typeRef); [EOL]     assertEquals(1, output.size()); [EOL]     Object ob = output.get(0); [EOL]     assertTrue(ob instanceof List<?>); [EOL]     List<?> list2 = (List<?>) ob; [EOL]     assertEquals(1, list2.size()); [EOL]     ob = list2.get(0); [EOL]     assertSame(Issue508A.class, ob.getClass()); [EOL] }
public void testIssue508() throws Exception { [EOL]     List<List<Issue508A>> l = new ArrayList<List<Issue508A>>(); [EOL]     List<Issue508A> l2 = new ArrayList<Issue508A>(); [EOL]     l2.add(new Issue508A()); [EOL]     l.add(l2); [EOL]     TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() { [EOL]     }; [EOL]     String json = mapper.writerWithType(typeRef).writeValueAsString(l); [EOL]     List<?> output = mapper.readValue(json, typeRef); [EOL]     assertEquals(1, output.size()); [EOL]     Object ob = output.get(0); [EOL]     assertTrue(ob instanceof List<?>); [EOL]     List<?> list2 = (List<?>) ob; [EOL]     assertEquals(1, list2.size()); [EOL]     ob = list2.get(0); [EOL]     assertSame(Issue508A.class, ob.getClass()); [EOL] }
public void testIssue508() throws Exception { [EOL]     List<List<Issue508A>> l = new ArrayList<List<Issue508A>>(); [EOL]     List<Issue508A> l2 = new ArrayList<Issue508A>(); [EOL]     l2.add(new Issue508A()); [EOL]     l.add(l2); [EOL]     TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() { [EOL]     }; [EOL]     String json = mapper.writerWithType(typeRef).writeValueAsString(l); [EOL]     List<?> output = mapper.readValue(json, typeRef); [EOL]     assertEquals(1, output.size()); [EOL]     Object ob = output.get(0); [EOL]     assertTrue(ob instanceof List<?>); [EOL]     List<?> list2 = (List<?>) ob; [EOL]     assertEquals(1, list2.size()); [EOL]     ob = list2.get(0); [EOL]     assertSame(Issue508A.class, ob.getClass()); [EOL] }
public void testIssue508() throws Exception { [EOL]     List<List<Issue508A>> l = new ArrayList<List<Issue508A>>(); [EOL]     List<Issue508A> l2 = new ArrayList<Issue508A>(); [EOL]     l2.add(new Issue508A()); [EOL]     l.add(l2); [EOL]     TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() { [EOL]     }; [EOL]     String json = mapper.writerWithType(typeRef).writeValueAsString(l); [EOL]     List<?> output = mapper.readValue(json, typeRef); [EOL]     assertEquals(1, output.size()); [EOL]     Object ob = output.get(0); [EOL]     assertTrue(ob instanceof List<?>); [EOL]     List<?> list2 = (List<?>) ob; [EOL]     assertEquals(1, list2.size()); [EOL]     ob = list2.get(0); [EOL]     assertSame(Issue508A.class, ob.getClass()); [EOL] }
public void testIssue508() throws Exception { [EOL]     List<List<Issue508A>> l = new ArrayList<List<Issue508A>>(); [EOL]     List<Issue508A> l2 = new ArrayList<Issue508A>(); [EOL]     l2.add(new Issue508A()); [EOL]     l.add(l2); [EOL]     TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() { [EOL]     }; [EOL]     String json = mapper.writerWithType(typeRef).writeValueAsString(l); [EOL]     List<?> output = mapper.readValue(json, typeRef); [EOL]     assertEquals(1, output.size()); [EOL]     Object ob = output.get(0); [EOL]     assertTrue(ob instanceof List<?>); [EOL]     List<?> list2 = (List<?>) ob; [EOL]     assertEquals(1, list2.size()); [EOL]     ob = list2.get(0); [EOL]     assertSame(Issue508A.class, ob.getClass()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testPrettyPrinter() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectWriter writer = mapper.writer(); [EOL]     HashMap<String, Integer> data = new HashMap<String, Integer>(); [EOL]     data.put("a", 1); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL]     writer = writer.withDefaultPrettyPrinter(); [EOL]     String lf = System.getProperty("line.separator"); [EOL]     assertEquals("{" + lf + "  \"a\" : 1" + lf + "}", writer.writeValueAsString(data)); [EOL]     writer = writer.with((PrettyPrinter) null); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL] }
public void testPrettyPrinter() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectWriter writer = mapper.writer(); [EOL]     HashMap<String, Integer> data = new HashMap<String, Integer>(); [EOL]     data.put("a", 1); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL]     writer = writer.withDefaultPrettyPrinter(); [EOL]     String lf = System.getProperty("line.separator"); [EOL]     assertEquals("{" + lf + "  \"a\" : 1" + lf + "}", writer.writeValueAsString(data)); [EOL]     writer = writer.with((PrettyPrinter) null); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL] }
public void testDateUsingObjectWriter() throws IOException { [EOL]     DateFormat df = new SimpleDateFormat("yyyy-MM-dd'X'HH:mm:ss"); [EOL]     df.setTimeZone(TimeZone.getTimeZone("PST")); [EOL]     assertEquals(quote("1969-12-31X16:00:00"), MAPPER.writer(df).writeValueAsString(new Date(0L))); [EOL]     ObjectWriter w = MAPPER.writer((DateFormat) null); [EOL]     assertEquals("0", w.writeValueAsString(new Date(0L))); [EOL]     w = w.with(df); [EOL]     assertEquals(quote("1969-12-31X16:00:00"), w.writeValueAsString(new Date(0L))); [EOL]     w = w.with((DateFormat) null); [EOL]     assertEquals("0", w.writeValueAsString(new Date(0L))); [EOL] }
public void testDateUsingObjectWriter() throws IOException { [EOL]     DateFormat df = new SimpleDateFormat("yyyy-MM-dd'X'HH:mm:ss"); [EOL]     df.setTimeZone(TimeZone.getTimeZone("PST")); [EOL]     assertEquals(quote("1969-12-31X16:00:00"), MAPPER.writer(df).writeValueAsString(new Date(0L))); [EOL]     ObjectWriter w = MAPPER.writer((DateFormat) null); [EOL]     assertEquals("0", w.writeValueAsString(new Date(0L))); [EOL]     w = w.with(df); [EOL]     assertEquals(quote("1969-12-31X16:00:00"), w.writeValueAsString(new Date(0L))); [EOL]     w = w.with((DateFormat) null); [EOL]     assertEquals("0", w.writeValueAsString(new Date(0L))); [EOL] }
public void testDateUsingObjectWriter() throws IOException { [EOL]     DateFormat df = new SimpleDateFormat("yyyy-MM-dd'X'HH:mm:ss"); [EOL]     df.setTimeZone(TimeZone.getTimeZone("PST")); [EOL]     assertEquals(quote("1969-12-31X16:00:00"), MAPPER.writer(df).writeValueAsString(new Date(0L))); [EOL]     ObjectWriter w = MAPPER.writer((DateFormat) null); [EOL]     assertEquals("0", w.writeValueAsString(new Date(0L))); [EOL]     w = w.with(df); [EOL]     assertEquals(quote("1969-12-31X16:00:00"), w.writeValueAsString(new Date(0L))); [EOL]     w = w.with((DateFormat) null); [EOL]     assertEquals("0", w.writeValueAsString(new Date(0L))); [EOL] }
public void testPrettyPrinter() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectWriter writer = mapper.writer(); [EOL]     HashMap<String, Integer> data = new HashMap<String, Integer>(); [EOL]     data.put("a", 1); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL]     writer = writer.withDefaultPrettyPrinter(); [EOL]     String lf = System.getProperty("line.separator"); [EOL]     assertEquals("{" + lf + "  \"a\" : 1" + lf + "}", writer.writeValueAsString(data)); [EOL]     writer = writer.with((PrettyPrinter) null); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL] }
public void testPrettyPrinter() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectWriter writer = mapper.writer(); [EOL]     HashMap<String, Integer> data = new HashMap<String, Integer>(); [EOL]     data.put("a", 1); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL]     writer = writer.withDefaultPrettyPrinter(); [EOL]     String lf = System.getProperty("line.separator"); [EOL]     assertEquals("{" + lf + "  \"a\" : 1" + lf + "}", writer.writeValueAsString(data)); [EOL]     writer = writer.with((PrettyPrinter) null); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL] }
public void testPrettyPrinter() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectWriter writer = mapper.writer(); [EOL]     HashMap<String, Integer> data = new HashMap<String, Integer>(); [EOL]     data.put("a", 1); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL]     writer = writer.withDefaultPrettyPrinter(); [EOL]     String lf = System.getProperty("line.separator"); [EOL]     assertEquals("{" + lf + "  \"a\" : 1" + lf + "}", writer.writeValueAsString(data)); [EOL]     writer = writer.with((PrettyPrinter) null); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL] }
public void testPrettyPrinter() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectWriter writer = mapper.writer(); [EOL]     HashMap<String, Integer> data = new HashMap<String, Integer>(); [EOL]     data.put("a", 1); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL]     writer = writer.withDefaultPrettyPrinter(); [EOL]     String lf = System.getProperty("line.separator"); [EOL]     assertEquals("{" + lf + "  \"a\" : 1" + lf + "}", writer.writeValueAsString(data)); [EOL]     writer = writer.with((PrettyPrinter) null); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL] }
public void testPrefetch() throws Exception { [EOL]     ObjectWriter writer = objectWriter(); [EOL]     assertFalse(writer.hasPrefetchedSerializer()); [EOL]     writer = objectWriter().withType(String.class); [EOL]     assertTrue(writer.hasPrefetchedSerializer()); [EOL] }
public void testPrefetch() throws Exception { [EOL]     ObjectWriter writer = objectWriter(); [EOL]     assertFalse(writer.hasPrefetchedSerializer()); [EOL]     writer = objectWriter().withType(String.class); [EOL]     assertTrue(writer.hasPrefetchedSerializer()); [EOL] }
public void testPrefetch() throws Exception { [EOL]     ObjectWriter writer = objectWriter(); [EOL]     assertFalse(writer.hasPrefetchedSerializer()); [EOL]     writer = objectWriter().withType(String.class); [EOL]     assertTrue(writer.hasPrefetchedSerializer()); [EOL] }
public void testPrefetch() throws Exception { [EOL]     ObjectWriter writer = objectWriter(); [EOL]     assertFalse(writer.hasPrefetchedSerializer()); [EOL]     writer = objectWriter().withType(String.class); [EOL]     assertTrue(writer.hasPrefetchedSerializer()); [EOL] }
public void testPrefetch() throws Exception { [EOL]     ObjectWriter writer = objectWriter(); [EOL]     assertFalse(writer.hasPrefetchedSerializer()); [EOL]     writer = objectWriter().withType(String.class); [EOL]     assertTrue(writer.hasPrefetchedSerializer()); [EOL] }
public void testPrefetch() throws Exception { [EOL]     ObjectWriter writer = objectWriter(); [EOL]     assertFalse(writer.hasPrefetchedSerializer()); [EOL]     writer = objectWriter().withType(String.class); [EOL]     assertTrue(writer.hasPrefetchedSerializer()); [EOL] }
public void testPrettyPrinter() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectWriter writer = mapper.writer(); [EOL]     HashMap<String, Integer> data = new HashMap<String, Integer>(); [EOL]     data.put("a", 1); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL]     writer = writer.withDefaultPrettyPrinter(); [EOL]     String lf = System.getProperty("line.separator"); [EOL]     assertEquals("{" + lf + "  \"a\" : 1" + lf + "}", writer.writeValueAsString(data)); [EOL]     writer = writer.with((PrettyPrinter) null); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL] }
public void testPrettyPrinter() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectWriter writer = mapper.writer(); [EOL]     HashMap<String, Integer> data = new HashMap<String, Integer>(); [EOL]     data.put("a", 1); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL]     writer = writer.withDefaultPrettyPrinter(); [EOL]     String lf = System.getProperty("line.separator"); [EOL]     assertEquals("{" + lf + "  \"a\" : 1" + lf + "}", writer.writeValueAsString(data)); [EOL]     writer = writer.with((PrettyPrinter) null); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL] }
public void testPrettyPrinter() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectWriter writer = mapper.writer(); [EOL]     HashMap<String, Integer> data = new HashMap<String, Integer>(); [EOL]     data.put("a", 1); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL]     writer = writer.withDefaultPrettyPrinter(); [EOL]     String lf = System.getProperty("line.separator"); [EOL]     assertEquals("{" + lf + "  \"a\" : 1" + lf + "}", writer.writeValueAsString(data)); [EOL]     writer = writer.with((PrettyPrinter) null); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL] }
public void testPrettyPrinter() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectWriter writer = mapper.writer(); [EOL]     HashMap<String, Integer> data = new HashMap<String, Integer>(); [EOL]     data.put("a", 1); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL]     writer = writer.withDefaultPrettyPrinter(); [EOL]     String lf = System.getProperty("line.separator"); [EOL]     assertEquals("{" + lf + "  \"a\" : 1" + lf + "}", writer.writeValueAsString(data)); [EOL]     writer = writer.with((PrettyPrinter) null); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL] }
public void testPrettyPrinter() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectWriter writer = mapper.writer(); [EOL]     HashMap<String, Integer> data = new HashMap<String, Integer>(); [EOL]     data.put("a", 1); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL]     writer = writer.withDefaultPrettyPrinter(); [EOL]     String lf = System.getProperty("line.separator"); [EOL]     assertEquals("{" + lf + "  \"a\" : 1" + lf + "}", writer.writeValueAsString(data)); [EOL]     writer = writer.with((PrettyPrinter) null); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL] }
public void testPrettyPrinter() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectWriter writer = mapper.writer(); [EOL]     HashMap<String, Integer> data = new HashMap<String, Integer>(); [EOL]     data.put("a", 1); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL]     writer = writer.withDefaultPrettyPrinter(); [EOL]     String lf = System.getProperty("line.separator"); [EOL]     assertEquals("{" + lf + "  \"a\" : 1" + lf + "}", writer.writeValueAsString(data)); [EOL]     writer = writer.with((PrettyPrinter) null); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL] }
public void testPrettyPrinter() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectWriter writer = mapper.writer(); [EOL]     HashMap<String, Integer> data = new HashMap<String, Integer>(); [EOL]     data.put("a", 1); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL]     writer = writer.withDefaultPrettyPrinter(); [EOL]     String lf = System.getProperty("line.separator"); [EOL]     assertEquals("{" + lf + "  \"a\" : 1" + lf + "}", writer.writeValueAsString(data)); [EOL]     writer = writer.with((PrettyPrinter) null); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL] }
public void testCloseCloseable() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     CloseableBean bean = new CloseableBean(); [EOL]     m.writeValueAsString(bean); [EOL]     assertFalse(bean.wasClosed); [EOL]     m.configure(SerializationFeature.CLOSE_CLOSEABLE, true); [EOL]     bean = new CloseableBean(); [EOL]     m.writeValueAsString(bean); [EOL]     assertTrue(bean.wasClosed); [EOL]     bean = new CloseableBean(); [EOL]     m.writerWithType(CloseableBean.class).writeValueAsString(bean); [EOL]     assertTrue(bean.wasClosed); [EOL] }
public void testCloseCloseable() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     CloseableBean bean = new CloseableBean(); [EOL]     m.writeValueAsString(bean); [EOL]     assertFalse(bean.wasClosed); [EOL]     m.configure(SerializationFeature.CLOSE_CLOSEABLE, true); [EOL]     bean = new CloseableBean(); [EOL]     m.writeValueAsString(bean); [EOL]     assertTrue(bean.wasClosed); [EOL]     bean = new CloseableBean(); [EOL]     m.writerWithType(CloseableBean.class).writeValueAsString(bean); [EOL]     assertTrue(bean.wasClosed); [EOL] }
public void testPrefetch() throws Exception { [EOL]     ObjectWriter writer = objectWriter(); [EOL]     assertFalse(writer.hasPrefetchedSerializer()); [EOL]     writer = objectWriter().withType(String.class); [EOL]     assertTrue(writer.hasPrefetchedSerializer()); [EOL] }
public void testPrefetch() throws Exception { [EOL]     ObjectWriter writer = objectWriter(); [EOL]     assertFalse(writer.hasPrefetchedSerializer()); [EOL]     writer = objectWriter().withType(String.class); [EOL]     assertTrue(writer.hasPrefetchedSerializer()); [EOL] }
public void testPrefetch() throws Exception { [EOL]     ObjectWriter writer = objectWriter(); [EOL]     assertFalse(writer.hasPrefetchedSerializer()); [EOL]     writer = objectWriter().withType(String.class); [EOL]     assertTrue(writer.hasPrefetchedSerializer()); [EOL] }
public void testPrefetch() throws Exception { [EOL]     ObjectWriter writer = objectWriter(); [EOL]     assertFalse(writer.hasPrefetchedSerializer()); [EOL]     writer = objectWriter().withType(String.class); [EOL]     assertTrue(writer.hasPrefetchedSerializer()); [EOL] }
public void testPrettyPrinter() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectWriter writer = mapper.writer(); [EOL]     HashMap<String, Integer> data = new HashMap<String, Integer>(); [EOL]     data.put("a", 1); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL]     writer = writer.withDefaultPrettyPrinter(); [EOL]     String lf = System.getProperty("line.separator"); [EOL]     assertEquals("{" + lf + "  \"a\" : 1" + lf + "}", writer.writeValueAsString(data)); [EOL]     writer = writer.with((PrettyPrinter) null); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL] }
public void testPrettyPrinter() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectWriter writer = mapper.writer(); [EOL]     HashMap<String, Integer> data = new HashMap<String, Integer>(); [EOL]     data.put("a", 1); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL]     writer = writer.withDefaultPrettyPrinter(); [EOL]     String lf = System.getProperty("line.separator"); [EOL]     assertEquals("{" + lf + "  \"a\" : 1" + lf + "}", writer.writeValueAsString(data)); [EOL]     writer = writer.with((PrettyPrinter) null); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL] }
public void testPrettyPrinter() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectWriter writer = mapper.writer(); [EOL]     HashMap<String, Integer> data = new HashMap<String, Integer>(); [EOL]     data.put("a", 1); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL]     writer = writer.withDefaultPrettyPrinter(); [EOL]     String lf = System.getProperty("line.separator"); [EOL]     assertEquals("{" + lf + "  \"a\" : 1" + lf + "}", writer.writeValueAsString(data)); [EOL]     writer = writer.with((PrettyPrinter) null); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL] }
public void testPrettyPrinter() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectWriter writer = mapper.writer(); [EOL]     HashMap<String, Integer> data = new HashMap<String, Integer>(); [EOL]     data.put("a", 1); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL]     writer = writer.withDefaultPrettyPrinter(); [EOL]     String lf = System.getProperty("line.separator"); [EOL]     assertEquals("{" + lf + "  \"a\" : 1" + lf + "}", writer.writeValueAsString(data)); [EOL]     writer = writer.with((PrettyPrinter) null); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL] }
public void testPrettyPrinter() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ObjectWriter writer = mapper.writer(); [EOL]     HashMap<String, Integer> data = new HashMap<String, Integer>(); [EOL]     data.put("a", 1); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL]     writer = writer.withDefaultPrettyPrinter(); [EOL]     String lf = System.getProperty("line.separator"); [EOL]     assertEquals("{" + lf + "  \"a\" : 1" + lf + "}", writer.writeValueAsString(data)); [EOL]     writer = writer.with((PrettyPrinter) null); [EOL]     assertEquals("{\"a\":1}", writer.writeValueAsString(data)); [EOL] }
public void testDataBind() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     JsonNode tree = m.readTree("{ \"name\" : \"Tatu\", \n" + "\"magicNumber\" : 42," + "\"kids\" : [ \"Leo\", \"Lila\", \"Leia\" ] \n" + "}"); [EOL]     Person tatu = m.treeToValue(tree, Person.class); [EOL]     assertNotNull(tatu); [EOL]     assertEquals(42, tatu.magicNumber); [EOL]     assertEquals("Tatu", tatu.name); [EOL]     assertNotNull(tatu.kids); [EOL]     assertEquals(3, tatu.kids.size()); [EOL]     assertEquals("Leo", tatu.kids.get(0)); [EOL]     assertEquals("Lila", tatu.kids.get(1)); [EOL]     assertEquals("Leia", tatu.kids.get(2)); [EOL] }
public void testMatchingSingle() throws Exception { [EOL]     JsonNode root = _buildTree(); [EOL]     JsonNode node = root.findValue("b"); [EOL]     assertNotNull(node); [EOL]     assertEquals(3, node.intValue()); [EOL]     node = root.findParent("b"); [EOL]     assertNotNull(node); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, ((ObjectNode) node).size()); [EOL]     assertEquals(3, node.path("b").intValue()); [EOL] }
public void testMatchingSingle() throws Exception { [EOL]     JsonNode root = _buildTree(); [EOL]     JsonNode node = root.findValue("b"); [EOL]     assertNotNull(node); [EOL]     assertEquals(3, node.intValue()); [EOL]     node = root.findParent("b"); [EOL]     assertNotNull(node); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, ((ObjectNode) node).size()); [EOL]     assertEquals(3, node.path("b").intValue()); [EOL] }
public void testMatchingSingle() throws Exception { [EOL]     JsonNode root = _buildTree(); [EOL]     JsonNode node = root.findValue("b"); [EOL]     assertNotNull(node); [EOL]     assertEquals(3, node.intValue()); [EOL]     node = root.findParent("b"); [EOL]     assertNotNull(node); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, ((ObjectNode) node).size()); [EOL]     assertEquals(3, node.path("b").intValue()); [EOL] }
public void testMatchingSingle() throws Exception { [EOL]     JsonNode root = _buildTree(); [EOL]     JsonNode node = root.findValue("b"); [EOL]     assertNotNull(node); [EOL]     assertEquals(3, node.intValue()); [EOL]     node = root.findParent("b"); [EOL]     assertNotNull(node); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, ((ObjectNode) node).size()); [EOL]     assertEquals(3, node.path("b").intValue()); [EOL] }
public void testMatchingSingle() throws Exception { [EOL]     JsonNode root = _buildTree(); [EOL]     JsonNode node = root.findValue("b"); [EOL]     assertNotNull(node); [EOL]     assertEquals(3, node.intValue()); [EOL]     node = root.findParent("b"); [EOL]     assertNotNull(node); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, ((ObjectNode) node).size()); [EOL]     assertEquals(3, node.path("b").intValue()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testFromArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ArrayNode root = mapper.createArrayNode(); [EOL]     root.add(TEXT1); [EOL]     root.add(3); [EOL]     ObjectNode obj = root.addObject(); [EOL]     obj.put(FIELD1, true); [EOL]     obj.putArray(FIELD2); [EOL]     root.add(false); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         StringWriter sw = new StringWriter(); [EOL]         if (i == 0) { [EOL]             JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]             root.serialize(gen, null); [EOL]             gen.close(); [EOL]         } else { [EOL]             mapper.writeValue(sw, root); [EOL]         } [EOL]         verifyFromArray(sw.toString()); [EOL]     } [EOL]     verifyFromArray(root.toString()); [EOL] }
public void testFromArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ArrayNode root = mapper.createArrayNode(); [EOL]     root.add(TEXT1); [EOL]     root.add(3); [EOL]     ObjectNode obj = root.addObject(); [EOL]     obj.put(FIELD1, true); [EOL]     obj.putArray(FIELD2); [EOL]     root.add(false); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         StringWriter sw = new StringWriter(); [EOL]         if (i == 0) { [EOL]             JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]             root.serialize(gen, null); [EOL]             gen.close(); [EOL]         } else { [EOL]             mapper.writeValue(sw, root); [EOL]         } [EOL]         verifyFromArray(sw.toString()); [EOL]     } [EOL]     verifyFromArray(root.toString()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testFromArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ArrayNode root = mapper.createArrayNode(); [EOL]     root.add(TEXT1); [EOL]     root.add(3); [EOL]     ObjectNode obj = root.addObject(); [EOL]     obj.put(FIELD1, true); [EOL]     obj.putArray(FIELD2); [EOL]     root.add(false); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         StringWriter sw = new StringWriter(); [EOL]         if (i == 0) { [EOL]             JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]             root.serialize(gen, null); [EOL]             gen.close(); [EOL]         } else { [EOL]             mapper.writeValue(sw, root); [EOL]         } [EOL]         verifyFromArray(sw.toString()); [EOL]     } [EOL]     verifyFromArray(root.toString()); [EOL] }
public void testFromArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ArrayNode root = mapper.createArrayNode(); [EOL]     root.add(TEXT1); [EOL]     root.add(3); [EOL]     ObjectNode obj = root.addObject(); [EOL]     obj.put(FIELD1, true); [EOL]     obj.putArray(FIELD2); [EOL]     root.add(false); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         StringWriter sw = new StringWriter(); [EOL]         if (i == 0) { [EOL]             JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]             root.serialize(gen, null); [EOL]             gen.close(); [EOL]         } else { [EOL]             mapper.writeValue(sw, root); [EOL]         } [EOL]         verifyFromArray(sw.toString()); [EOL]     } [EOL]     verifyFromArray(root.toString()); [EOL] }
public void testFromArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ArrayNode root = mapper.createArrayNode(); [EOL]     root.add(TEXT1); [EOL]     root.add(3); [EOL]     ObjectNode obj = root.addObject(); [EOL]     obj.put(FIELD1, true); [EOL]     obj.putArray(FIELD2); [EOL]     root.add(false); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         StringWriter sw = new StringWriter(); [EOL]         if (i == 0) { [EOL]             JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]             root.serialize(gen, null); [EOL]             gen.close(); [EOL]         } else { [EOL]             mapper.writeValue(sw, root); [EOL]         } [EOL]         verifyFromArray(sw.toString()); [EOL]     } [EOL]     verifyFromArray(root.toString()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testProviderConfig() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals(0, m._deserializationContext._cache.cachedDeserializersCount()); [EOL]     Bean bean = m.readValue("{ \"x\" : 3 }", Bean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals(1, m._deserializationContext._cache.cachedDeserializersCount()); [EOL]     m._deserializationContext._cache.flushCachedDeserializers(); [EOL]     assertEquals(0, m._deserializationContext._cache.cachedDeserializersCount()); [EOL] }
public void testProviderConfig() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals(0, m._deserializationContext._cache.cachedDeserializersCount()); [EOL]     Bean bean = m.readValue("{ \"x\" : 3 }", Bean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals(1, m._deserializationContext._cache.cachedDeserializersCount()); [EOL]     m._deserializationContext._cache.flushCachedDeserializers(); [EOL]     assertEquals(0, m._deserializationContext._cache.cachedDeserializersCount()); [EOL] }
public void testProviderConfig() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals(0, m._deserializationContext._cache.cachedDeserializersCount()); [EOL]     Bean bean = m.readValue("{ \"x\" : 3 }", Bean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals(1, m._deserializationContext._cache.cachedDeserializersCount()); [EOL]     m._deserializationContext._cache.flushCachedDeserializers(); [EOL]     assertEquals(0, m._deserializationContext._cache.cachedDeserializersCount()); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testHasNextWithEndArrayManagedParser() throws Exception { [EOL]     final String JSON = "[1,3]"; [EOL]     Iterator<Integer> it = MAPPER.reader(Integer.class).readValues(JSON); [EOL]     assertTrue(it.hasNext()); [EOL]     int value = it.next(); [EOL]     assertEquals(1, value); [EOL]     assertTrue(it.hasNext()); [EOL]     value = it.next(); [EOL]     assertEquals(3, value); [EOL]     assertFalse(it.hasNext()); [EOL]     assertFalse(it.hasNext()); [EOL] }
public void testHasNextWithEndArrayManagedParser() throws Exception { [EOL]     final String JSON = "[1,3]"; [EOL]     Iterator<Integer> it = MAPPER.reader(Integer.class).readValues(JSON); [EOL]     assertTrue(it.hasNext()); [EOL]     int value = it.next(); [EOL]     assertEquals(1, value); [EOL]     assertTrue(it.hasNext()); [EOL]     value = it.next(); [EOL]     assertEquals(3, value); [EOL]     assertFalse(it.hasNext()); [EOL]     assertFalse(it.hasNext()); [EOL] }
public void testHasNextWithEndArrayManagedParser() throws Exception { [EOL]     final String JSON = "[1,3]"; [EOL]     Iterator<Integer> it = MAPPER.reader(Integer.class).readValues(JSON); [EOL]     assertTrue(it.hasNext()); [EOL]     int value = it.next(); [EOL]     assertEquals(1, value); [EOL]     assertTrue(it.hasNext()); [EOL]     value = it.next(); [EOL]     assertEquals(3, value); [EOL]     assertFalse(it.hasNext()); [EOL]     assertFalse(it.hasNext()); [EOL] }
public void testHasNextWithEndArrayManagedParser() throws Exception { [EOL]     final String JSON = "[1,3]"; [EOL]     Iterator<Integer> it = MAPPER.reader(Integer.class).readValues(JSON); [EOL]     assertTrue(it.hasNext()); [EOL]     int value = it.next(); [EOL]     assertEquals(1, value); [EOL]     assertTrue(it.hasNext()); [EOL]     value = it.next(); [EOL]     assertEquals(3, value); [EOL]     assertFalse(it.hasNext()); [EOL]     assertFalse(it.hasNext()); [EOL] }
public void testHasNextWithEndArrayManagedParser() throws Exception { [EOL]     final String JSON = "[1,3]"; [EOL]     Iterator<Integer> it = MAPPER.reader(Integer.class).readValues(JSON); [EOL]     assertTrue(it.hasNext()); [EOL]     int value = it.next(); [EOL]     assertEquals(1, value); [EOL]     assertTrue(it.hasNext()); [EOL]     value = it.next(); [EOL]     assertEquals(3, value); [EOL]     assertFalse(it.hasNext()); [EOL]     assertFalse(it.hasNext()); [EOL] }
public void testHasNextWithEndArrayManagedParser() throws Exception { [EOL]     final String JSON = "[1,3]"; [EOL]     Iterator<Integer> it = MAPPER.reader(Integer.class).readValues(JSON); [EOL]     assertTrue(it.hasNext()); [EOL]     int value = it.next(); [EOL]     assertEquals(1, value); [EOL]     assertTrue(it.hasNext()); [EOL]     value = it.next(); [EOL]     assertEquals(3, value); [EOL]     assertFalse(it.hasNext()); [EOL]     assertFalse(it.hasNext()); [EOL] }
public void testHasNextWithEndArrayManagedParser() throws Exception { [EOL]     final String JSON = "[1,3]"; [EOL]     Iterator<Integer> it = MAPPER.reader(Integer.class).readValues(JSON); [EOL]     assertTrue(it.hasNext()); [EOL]     int value = it.next(); [EOL]     assertEquals(1, value); [EOL]     assertTrue(it.hasNext()); [EOL]     value = it.next(); [EOL]     assertEquals(3, value); [EOL]     assertFalse(it.hasNext()); [EOL]     assertFalse(it.hasNext()); [EOL] }
public void testHasNextWithEndArrayManagedParser() throws Exception { [EOL]     final String JSON = "[1,3]"; [EOL]     Iterator<Integer> it = MAPPER.reader(Integer.class).readValues(JSON); [EOL]     assertTrue(it.hasNext()); [EOL]     int value = it.next(); [EOL]     assertEquals(1, value); [EOL]     assertTrue(it.hasNext()); [EOL]     value = it.next(); [EOL]     assertEquals(3, value); [EOL]     assertFalse(it.hasNext()); [EOL]     assertFalse(it.hasNext()); [EOL] }
public void testHasNextWithEndArrayManagedParser() throws Exception { [EOL]     final String JSON = "[1,3]"; [EOL]     Iterator<Integer> it = MAPPER.reader(Integer.class).readValues(JSON); [EOL]     assertTrue(it.hasNext()); [EOL]     int value = it.next(); [EOL]     assertEquals(1, value); [EOL]     assertTrue(it.hasNext()); [EOL]     value = it.next(); [EOL]     assertEquals(3, value); [EOL]     assertFalse(it.hasNext()); [EOL]     assertFalse(it.hasNext()); [EOL] }
public void testHasNextWithEndArrayManagedParser() throws Exception { [EOL]     final String JSON = "[1,3]"; [EOL]     Iterator<Integer> it = MAPPER.reader(Integer.class).readValues(JSON); [EOL]     assertTrue(it.hasNext()); [EOL]     int value = it.next(); [EOL]     assertEquals(1, value); [EOL]     assertTrue(it.hasNext()); [EOL]     value = it.next(); [EOL]     assertEquals(3, value); [EOL]     assertFalse(it.hasNext()); [EOL]     assertFalse(it.hasNext()); [EOL] }
public void testHasNextWithEndArrayManagedParser() throws Exception { [EOL]     final String JSON = "[1,3]"; [EOL]     Iterator<Integer> it = MAPPER.reader(Integer.class).readValues(JSON); [EOL]     assertTrue(it.hasNext()); [EOL]     int value = it.next(); [EOL]     assertEquals(1, value); [EOL]     assertTrue(it.hasNext()); [EOL]     value = it.next(); [EOL]     assertEquals(3, value); [EOL]     assertFalse(it.hasNext()); [EOL]     assertFalse(it.hasNext()); [EOL] }
public void testHasNextWithEndArrayManagedParser() throws Exception { [EOL]     final String JSON = "[1,3]"; [EOL]     Iterator<Integer> it = MAPPER.reader(Integer.class).readValues(JSON); [EOL]     assertTrue(it.hasNext()); [EOL]     int value = it.next(); [EOL]     assertEquals(1, value); [EOL]     assertTrue(it.hasNext()); [EOL]     value = it.next(); [EOL]     assertEquals(3, value); [EOL]     assertFalse(it.hasNext()); [EOL]     assertFalse(it.hasNext()); [EOL] }
public void testHasNextWithEndArrayManagedParser() throws Exception { [EOL]     final String JSON = "[1,3]"; [EOL]     Iterator<Integer> it = MAPPER.reader(Integer.class).readValues(JSON); [EOL]     assertTrue(it.hasNext()); [EOL]     int value = it.next(); [EOL]     assertEquals(1, value); [EOL]     assertTrue(it.hasNext()); [EOL]     value = it.next(); [EOL]     assertEquals(3, value); [EOL]     assertFalse(it.hasNext()); [EOL]     assertFalse(it.hasNext()); [EOL] }
public void testBinaryNode() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 0, -5 }; [EOL]     BinaryNode n = new BinaryNode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     assertEquals("APs=", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testBinaryNode() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 0, -5 }; [EOL]     BinaryNode n = new BinaryNode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     assertEquals("APs=", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testEmbeddedObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeObject(new byte[3]); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isBinary()); [EOL]     byte[] data = node.binaryValue(); [EOL]     assertNotNull(data); [EOL]     assertEquals(3, data.length); [EOL] }
public void testEmbeddedObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeObject(new byte[3]); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isBinary()); [EOL]     byte[] data = node.binaryValue(); [EOL]     assertNotNull(data); [EOL]     assertEquals(3, data.length); [EOL] }
public void testEmbeddedObject() throws Exception { [EOL]     TokenBuffer buf = new TokenBuffer(MAPPER); [EOL]     buf.writeObject(new byte[3]); [EOL]     JsonNode node = MAPPER.readTree(buf.asParser()); [EOL]     buf.close(); [EOL]     assertTrue(node.isBinary()); [EOL]     byte[] data = node.binaryValue(); [EOL]     assertNotNull(data); [EOL]     assertEquals(3, data.length); [EOL] }
public void testBinaryNode() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 0, -5 }; [EOL]     BinaryNode n = new BinaryNode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     assertEquals("APs=", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testBinaryNode() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 0, -5 }; [EOL]     BinaryNode n = new BinaryNode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     assertEquals("APs=", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testBinaryNode() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 0, -5 }; [EOL]     BinaryNode n = new BinaryNode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     assertEquals("APs=", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testBinaryNode() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 0, -5 }; [EOL]     BinaryNode n = new BinaryNode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     assertEquals("APs=", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testBinaryNode() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 0, -5 }; [EOL]     BinaryNode n = new BinaryNode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     assertEquals("APs=", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testUntyped() { [EOL]     _testObjectBuffer(null); [EOL] }
public void testUntyped() { [EOL]     _testObjectBuffer(null); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testStaticTypingForClass() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     Map<String, Object> result = writeAndMap(m, new WrapperClassForStaticTyping()); [EOL]     assertEquals(1, result.size()); [EOL]     Object ob = result.get("value"); [EOL]     result = (Map<String, Object>) ob; [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(3), result.get("x")); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testStaticTypingForClass() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     Map<String, Object> result = writeAndMap(m, new WrapperClassForStaticTyping()); [EOL]     assertEquals(1, result.size()); [EOL]     Object ob = result.get("value"); [EOL]     result = (Map<String, Object>) ob; [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(3), result.get("x")); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testStaticTypingForClass() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     Map<String, Object> result = writeAndMap(m, new WrapperClassForStaticTyping()); [EOL]     assertEquals(1, result.size()); [EOL]     Object ob = result.get("value"); [EOL]     result = (Map<String, Object>) ob; [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(3), result.get("x")); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testStaticTypingForClass() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     Map<String, Object> result = writeAndMap(m, new WrapperClassForStaticTyping()); [EOL]     assertEquals(1, result.size()); [EOL]     Object ob = result.get("value"); [EOL]     result = (Map<String, Object>) ob; [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(3), result.get("x")); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testStaticTypingForClass() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     Map<String, Object> result = writeAndMap(m, new WrapperClassForStaticTyping()); [EOL]     assertEquals(1, result.size()); [EOL]     Object ob = result.get("value"); [EOL]     result = (Map<String, Object>) ob; [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(3), result.get("x")); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testStaticTypingForClass() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     Map<String, Object> result = writeAndMap(m, new WrapperClassForStaticTyping()); [EOL]     assertEquals(1, result.size()); [EOL]     Object ob = result.get("value"); [EOL]     result = (Map<String, Object>) ob; [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(3), result.get("x")); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testStaticTypingForClass() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     Map<String, Object> result = writeAndMap(m, new WrapperClassForStaticTyping()); [EOL]     assertEquals(1, result.size()); [EOL]     Object ob = result.get("value"); [EOL]     result = (Map<String, Object>) ob; [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(3), result.get("x")); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testStaticTypingForClass() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     Map<String, Object> result = writeAndMap(m, new WrapperClassForStaticTyping()); [EOL]     assertEquals(1, result.size()); [EOL]     Object ob = result.get("value"); [EOL]     result = (Map<String, Object>) ob; [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(3), result.get("x")); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testStaticTypingForClass() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     Map<String, Object> result = writeAndMap(m, new WrapperClassForStaticTyping()); [EOL]     assertEquals(1, result.size()); [EOL]     Object ob = result.get("value"); [EOL]     result = (Map<String, Object>) ob; [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(3), result.get("x")); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testStaticTypingForClass() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     Map<String, Object> result = writeAndMap(m, new WrapperClassForStaticTyping()); [EOL]     assertEquals(1, result.size()); [EOL]     Object ob = result.get("value"); [EOL]     result = (Map<String, Object>) ob; [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(3), result.get("x")); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testStaticTypingForClass() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     Map<String, Object> result = writeAndMap(m, new WrapperClassForStaticTyping()); [EOL]     assertEquals(1, result.size()); [EOL]     Object ob = result.get("value"); [EOL]     result = (Map<String, Object>) ob; [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(3), result.get("x")); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testStaticTypingForClass() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     Map<String, Object> result = writeAndMap(m, new WrapperClassForStaticTyping()); [EOL]     assertEquals(1, result.size()); [EOL]     Object ob = result.get("value"); [EOL]     result = (Map<String, Object>) ob; [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(3), result.get("x")); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testStaticTypingForClass() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     Map<String, Object> result = writeAndMap(m, new WrapperClassForStaticTyping()); [EOL]     assertEquals(1, result.size()); [EOL]     Object ob = result.get("value"); [EOL]     result = (Map<String, Object>) ob; [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(3), result.get("x")); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testStaticTypingForClass() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     Map<String, Object> result = writeAndMap(m, new WrapperClassForStaticTyping()); [EOL]     assertEquals(1, result.size()); [EOL]     Object ob = result.get("value"); [EOL]     result = (Map<String, Object>) ob; [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(3), result.get("x")); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testStaticTypingForClass() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     Map<String, Object> result = writeAndMap(m, new WrapperClassForStaticTyping()); [EOL]     assertEquals(1, result.size()); [EOL]     Object ob = result.get("value"); [EOL]     result = (Map<String, Object>) ob; [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(3), result.get("x")); [EOL] }
public void testSimpleListField() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     FieldWrapperBeanList list = new FieldWrapperBeanList(); [EOL]     list.add(new FieldWrapperBean(new OtherBean())); [EOL]     String json = mapper.writeValueAsString(list); [EOL]     FieldWrapperBeanList result = mapper.readValue(json, FieldWrapperBeanList.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     FieldWrapperBean bean = list.get(0); [EOL]     assertEquals(OtherBean.class, bean.value.getClass()); [EOL]     assertEquals(((OtherBean) bean.value).x, 1); [EOL]     assertEquals(((OtherBean) bean.value).y, 1); [EOL] }
public void testSimpleListField() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     FieldWrapperBeanList list = new FieldWrapperBeanList(); [EOL]     list.add(new FieldWrapperBean(new OtherBean())); [EOL]     String json = mapper.writeValueAsString(list); [EOL]     FieldWrapperBeanList result = mapper.readValue(json, FieldWrapperBeanList.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     FieldWrapperBean bean = list.get(0); [EOL]     assertEquals(OtherBean.class, bean.value.getClass()); [EOL]     assertEquals(((OtherBean) bean.value).x, 1); [EOL]     assertEquals(((OtherBean) bean.value).y, 1); [EOL] }
public void testSimpleListField() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     FieldWrapperBeanList list = new FieldWrapperBeanList(); [EOL]     list.add(new FieldWrapperBean(new OtherBean())); [EOL]     String json = mapper.writeValueAsString(list); [EOL]     FieldWrapperBeanList result = mapper.readValue(json, FieldWrapperBeanList.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     FieldWrapperBean bean = list.get(0); [EOL]     assertEquals(OtherBean.class, bean.value.getClass()); [EOL]     assertEquals(((OtherBean) bean.value).x, 1); [EOL]     assertEquals(((OtherBean) bean.value).y, 1); [EOL] }
public void testSimpleListField() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     FieldWrapperBeanList list = new FieldWrapperBeanList(); [EOL]     list.add(new FieldWrapperBean(new OtherBean())); [EOL]     String json = mapper.writeValueAsString(list); [EOL]     FieldWrapperBeanList result = mapper.readValue(json, FieldWrapperBeanList.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     FieldWrapperBean bean = list.get(0); [EOL]     assertEquals(OtherBean.class, bean.value.getClass()); [EOL]     assertEquals(((OtherBean) bean.value).x, 1); [EOL]     assertEquals(((OtherBean) bean.value).y, 1); [EOL] }
public void testSimpleListField() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     FieldWrapperBeanList list = new FieldWrapperBeanList(); [EOL]     list.add(new FieldWrapperBean(new OtherBean())); [EOL]     String json = mapper.writeValueAsString(list); [EOL]     FieldWrapperBeanList result = mapper.readValue(json, FieldWrapperBeanList.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     FieldWrapperBean bean = list.get(0); [EOL]     assertEquals(OtherBean.class, bean.value.getClass()); [EOL]     assertEquals(((OtherBean) bean.value).x, 1); [EOL]     assertEquals(((OtherBean) bean.value).y, 1); [EOL] }
public void testSimpleListField() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     FieldWrapperBeanList list = new FieldWrapperBeanList(); [EOL]     list.add(new FieldWrapperBean(new OtherBean())); [EOL]     String json = mapper.writeValueAsString(list); [EOL]     FieldWrapperBeanList result = mapper.readValue(json, FieldWrapperBeanList.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     FieldWrapperBean bean = list.get(0); [EOL]     assertEquals(OtherBean.class, bean.value.getClass()); [EOL]     assertEquals(((OtherBean) bean.value).x, 1); [EOL]     assertEquals(((OtherBean) bean.value).y, 1); [EOL] }
public void testSimpleListField() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     FieldWrapperBeanList list = new FieldWrapperBeanList(); [EOL]     list.add(new FieldWrapperBean(new OtherBean())); [EOL]     String json = mapper.writeValueAsString(list); [EOL]     FieldWrapperBeanList result = mapper.readValue(json, FieldWrapperBeanList.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     FieldWrapperBean bean = list.get(0); [EOL]     assertEquals(OtherBean.class, bean.value.getClass()); [EOL]     assertEquals(((OtherBean) bean.value).x, 1); [EOL]     assertEquals(((OtherBean) bean.value).y, 1); [EOL] }
public void testSimpleListField() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     FieldWrapperBeanList list = new FieldWrapperBeanList(); [EOL]     list.add(new FieldWrapperBean(new OtherBean())); [EOL]     String json = mapper.writeValueAsString(list); [EOL]     FieldWrapperBeanList result = mapper.readValue(json, FieldWrapperBeanList.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     FieldWrapperBean bean = list.get(0); [EOL]     assertEquals(OtherBean.class, bean.value.getClass()); [EOL]     assertEquals(((OtherBean) bean.value).x, 1); [EOL]     assertEquals(((OtherBean) bean.value).y, 1); [EOL] }
public void testSimpleListField() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     FieldWrapperBeanList list = new FieldWrapperBeanList(); [EOL]     list.add(new FieldWrapperBean(new OtherBean())); [EOL]     String json = mapper.writeValueAsString(list); [EOL]     FieldWrapperBeanList result = mapper.readValue(json, FieldWrapperBeanList.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     FieldWrapperBean bean = list.get(0); [EOL]     assertEquals(OtherBean.class, bean.value.getClass()); [EOL]     assertEquals(((OtherBean) bean.value).x, 1); [EOL]     assertEquals(((OtherBean) bean.value).y, 1); [EOL] }
public void testSimpleListField() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     FieldWrapperBeanList list = new FieldWrapperBeanList(); [EOL]     list.add(new FieldWrapperBean(new OtherBean())); [EOL]     String json = mapper.writeValueAsString(list); [EOL]     FieldWrapperBeanList result = mapper.readValue(json, FieldWrapperBeanList.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     FieldWrapperBean bean = list.get(0); [EOL]     assertEquals(OtherBean.class, bean.value.getClass()); [EOL]     assertEquals(((OtherBean) bean.value).x, 1); [EOL]     assertEquals(((OtherBean) bean.value).y, 1); [EOL] }
public void testSimpleListField() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     FieldWrapperBeanList list = new FieldWrapperBeanList(); [EOL]     list.add(new FieldWrapperBean(new OtherBean())); [EOL]     String json = mapper.writeValueAsString(list); [EOL]     FieldWrapperBeanList result = mapper.readValue(json, FieldWrapperBeanList.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     FieldWrapperBean bean = list.get(0); [EOL]     assertEquals(OtherBean.class, bean.value.getClass()); [EOL]     assertEquals(((OtherBean) bean.value).x, 1); [EOL]     assertEquals(((OtherBean) bean.value).y, 1); [EOL] }
public void testSimpleListField() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     FieldWrapperBeanList list = new FieldWrapperBeanList(); [EOL]     list.add(new FieldWrapperBean(new OtherBean())); [EOL]     String json = mapper.writeValueAsString(list); [EOL]     FieldWrapperBeanList result = mapper.readValue(json, FieldWrapperBeanList.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     FieldWrapperBean bean = list.get(0); [EOL]     assertEquals(OtherBean.class, bean.value.getClass()); [EOL]     assertEquals(((OtherBean) bean.value).x, 1); [EOL]     assertEquals(((OtherBean) bean.value).y, 1); [EOL] }
public void testSimpleListField() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     FieldWrapperBeanList list = new FieldWrapperBeanList(); [EOL]     list.add(new FieldWrapperBean(new OtherBean())); [EOL]     String json = mapper.writeValueAsString(list); [EOL]     FieldWrapperBeanList result = mapper.readValue(json, FieldWrapperBeanList.class); [EOL]     assertNotNull(result); [EOL]     assertEquals(1, result.size()); [EOL]     FieldWrapperBean bean = list.get(0); [EOL]     assertEquals(OtherBean.class, bean.value.getClass()); [EOL]     assertEquals(((OtherBean) bean.value).x, 1); [EOL]     assertEquals(((OtherBean) bean.value).y, 1); [EOL] }
public void testTypeAsArray() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(Animal.class, TypeWithArray.class); [EOL]     Map<String, Object> result = writeAndMap(m, new AnimalWrapper(new Dog("Amadeus", 7))); [EOL]     assertEquals(1, result.size()); [EOL]     List<?> l = (List<?>) result.get("animal"); [EOL]     assertNotNull(l); [EOL]     assertEquals(2, l.size()); [EOL]     assertEquals(Dog.class.getName(), l.get(0)); [EOL]     Map<?, ?> doggie = (Map<?, ?>) l.get(1); [EOL]     assertNotNull(doggie); [EOL]     assertEquals(2, doggie.size()); [EOL]     assertEquals("Amadeus", doggie.get("name")); [EOL]     assertEquals(Integer.valueOf(7), doggie.get("boneCount")); [EOL] }
public void testTypeAsArray() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(Animal.class, TypeWithArray.class); [EOL]     Map<String, Object> result = writeAndMap(m, new AnimalWrapper(new Dog("Amadeus", 7))); [EOL]     assertEquals(1, result.size()); [EOL]     List<?> l = (List<?>) result.get("animal"); [EOL]     assertNotNull(l); [EOL]     assertEquals(2, l.size()); [EOL]     assertEquals(Dog.class.getName(), l.get(0)); [EOL]     Map<?, ?> doggie = (Map<?, ?>) l.get(1); [EOL]     assertNotNull(doggie); [EOL]     assertEquals(2, doggie.size()); [EOL]     assertEquals("Amadeus", doggie.get("name")); [EOL]     assertEquals(Integer.valueOf(7), doggie.get("boneCount")); [EOL] }
public void testTypeAsArray() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(Animal.class, TypeWithArray.class); [EOL]     Map<String, Object> result = writeAndMap(m, new AnimalWrapper(new Dog("Amadeus", 7))); [EOL]     assertEquals(1, result.size()); [EOL]     List<?> l = (List<?>) result.get("animal"); [EOL]     assertNotNull(l); [EOL]     assertEquals(2, l.size()); [EOL]     assertEquals(Dog.class.getName(), l.get(0)); [EOL]     Map<?, ?> doggie = (Map<?, ?>) l.get(1); [EOL]     assertNotNull(doggie); [EOL]     assertEquals(2, doggie.size()); [EOL]     assertEquals("Amadeus", doggie.get("name")); [EOL]     assertEquals(Integer.valueOf(7), doggie.get("boneCount")); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testStaticTypingForClass() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     Map<String, Object> result = writeAndMap(m, new WrapperClassForStaticTyping()); [EOL]     assertEquals(1, result.size()); [EOL]     Object ob = result.get("value"); [EOL]     result = (Map<String, Object>) ob; [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(3), result.get("x")); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testStaticTypingForClass() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     Map<String, Object> result = writeAndMap(m, new WrapperClassForStaticTyping()); [EOL]     assertEquals(1, result.size()); [EOL]     Object ob = result.get("value"); [EOL]     result = (Map<String, Object>) ob; [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(3), result.get("x")); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testStaticTypingForClass() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     Map<String, Object> result = writeAndMap(m, new WrapperClassForStaticTyping()); [EOL]     assertEquals(1, result.size()); [EOL]     Object ob = result.get("value"); [EOL]     result = (Map<String, Object>) ob; [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(3), result.get("x")); [EOL] }
@SuppressWarnings("unchecked") [EOL] public void testStaticTypingForClass() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     Map<String, Object> result = writeAndMap(m, new WrapperClassForStaticTyping()); [EOL]     assertEquals(1, result.size()); [EOL]     Object ob = result.get("value"); [EOL]     result = (Map<String, Object>) ob; [EOL]     assertEquals(1, result.size()); [EOL]     assertEquals(Integer.valueOf(3), result.get("x")); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
@SuppressWarnings("deprecation") [EOL] public void testDateSql() throws Exception { [EOL]     java.sql.Date value = new java.sql.Date(0L); [EOL]     value.setYear(99); [EOL]     value.setDate(19); [EOL]     value.setMonth(Calendar.APRIL); [EOL]     long now = value.getTime(); [EOL]     assertEquals(value, MAPPER.readValue(String.valueOf(now), java.sql.Date.class)); [EOL]     java.sql.Date result = MAPPER.readValue(quote(value.toString()), java.sql.Date.class); [EOL]     Calendar c = gmtCalendar(result.getTime()); [EOL]     assertEquals(1999, c.get(Calendar.YEAR)); [EOL]     assertEquals(Calendar.APRIL, c.get(Calendar.MONTH)); [EOL]     assertEquals(19, c.get(Calendar.DAY_OF_MONTH)); [EOL]     String expStr = "1981-07-13"; [EOL]     result = MAPPER.readValue(quote(expStr), java.sql.Date.class); [EOL]     c.setTimeInMillis(result.getTime()); [EOL]     assertEquals(1981, c.get(Calendar.YEAR)); [EOL]     assertEquals(Calendar.JULY, c.get(Calendar.MONTH)); [EOL]     assertEquals(13, c.get(Calendar.DAY_OF_MONTH)); [EOL] }
@SuppressWarnings("deprecation") [EOL] public void testDateSql() throws Exception { [EOL]     java.sql.Date value = new java.sql.Date(0L); [EOL]     value.setYear(99); [EOL]     value.setDate(19); [EOL]     value.setMonth(Calendar.APRIL); [EOL]     long now = value.getTime(); [EOL]     assertEquals(value, MAPPER.readValue(String.valueOf(now), java.sql.Date.class)); [EOL]     java.sql.Date result = MAPPER.readValue(quote(value.toString()), java.sql.Date.class); [EOL]     Calendar c = gmtCalendar(result.getTime()); [EOL]     assertEquals(1999, c.get(Calendar.YEAR)); [EOL]     assertEquals(Calendar.APRIL, c.get(Calendar.MONTH)); [EOL]     assertEquals(19, c.get(Calendar.DAY_OF_MONTH)); [EOL]     String expStr = "1981-07-13"; [EOL]     result = MAPPER.readValue(quote(expStr), java.sql.Date.class); [EOL]     c.setTimeInMillis(result.getTime()); [EOL]     assertEquals(1981, c.get(Calendar.YEAR)); [EOL]     assertEquals(Calendar.JULY, c.get(Calendar.MONTH)); [EOL]     assertEquals(13, c.get(Calendar.DAY_OF_MONTH)); [EOL] }
@SuppressWarnings("deprecation") [EOL] public void testDateSql() throws Exception { [EOL]     java.sql.Date value = new java.sql.Date(0L); [EOL]     value.setYear(99); [EOL]     value.setDate(19); [EOL]     value.setMonth(Calendar.APRIL); [EOL]     long now = value.getTime(); [EOL]     assertEquals(value, MAPPER.readValue(String.valueOf(now), java.sql.Date.class)); [EOL]     java.sql.Date result = MAPPER.readValue(quote(value.toString()), java.sql.Date.class); [EOL]     Calendar c = gmtCalendar(result.getTime()); [EOL]     assertEquals(1999, c.get(Calendar.YEAR)); [EOL]     assertEquals(Calendar.APRIL, c.get(Calendar.MONTH)); [EOL]     assertEquals(19, c.get(Calendar.DAY_OF_MONTH)); [EOL]     String expStr = "1981-07-13"; [EOL]     result = MAPPER.readValue(quote(expStr), java.sql.Date.class); [EOL]     c.setTimeInMillis(result.getTime()); [EOL]     assertEquals(1981, c.get(Calendar.YEAR)); [EOL]     assertEquals(Calendar.JULY, c.get(Calendar.MONTH)); [EOL]     assertEquals(13, c.get(Calendar.DAY_OF_MONTH)); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testManualPolymorphicCatWithReorder() throws Exception { [EOL]     Animal animal = MAPPER.readValue("{ \"likesCream\":true, \"name\" : \"Venla\", \"type\":\"cat\" }", Animal.class); [EOL]     assertEquals(Cat.class, animal.getClass()); [EOL]     assertEquals("Venla", animal.name); [EOL]     assertTrue(((Cat) animal).likesCream); [EOL] }
public void testManualPolymorphicCatWithReorder() throws Exception { [EOL]     Animal animal = MAPPER.readValue("{ \"likesCream\":true, \"name\" : \"Venla\", \"type\":\"cat\" }", Animal.class); [EOL]     assertEquals(Cat.class, animal.getClass()); [EOL]     assertEquals("Venla", animal.name); [EOL]     assertTrue(((Cat) animal).likesCream); [EOL] }
public void testManualPolymorphicCatWithReorder() throws Exception { [EOL]     Animal animal = MAPPER.readValue("{ \"likesCream\":true, \"name\" : \"Venla\", \"type\":\"cat\" }", Animal.class); [EOL]     assertEquals(Cat.class, animal.getClass()); [EOL]     assertEquals("Venla", animal.name); [EOL]     assertTrue(((Cat) animal).likesCream); [EOL] }
public void testSkipChildrenWrt370() throws Exception { [EOL]     ObjectMapper o = new ObjectMapper(); [EOL]     ObjectNode n = o.createObjectNode(); [EOL]     n.putObject("inner").put("value", "test"); [EOL]     n.putObject("unknown").putNull("inner"); [EOL]     Jackson370Bean obj = o.readValue(n.traverse(), Jackson370Bean.class); [EOL]     assertNotNull(obj.inner); [EOL]     assertEquals("test", obj.inner.value); [EOL] }
public void testSkipChildrenWrt370() throws Exception { [EOL]     ObjectMapper o = new ObjectMapper(); [EOL]     ObjectNode n = o.createObjectNode(); [EOL]     n.putObject("inner").put("value", "test"); [EOL]     n.putObject("unknown").putNull("inner"); [EOL]     Jackson370Bean obj = o.readValue(n.traverse(), Jackson370Bean.class); [EOL]     assertNotNull(obj.inner); [EOL]     assertEquals("test", obj.inner.value); [EOL] }
public void testSkipChildrenWrt370() throws Exception { [EOL]     ObjectMapper o = new ObjectMapper(); [EOL]     ObjectNode n = o.createObjectNode(); [EOL]     n.putObject("inner").put("value", "test"); [EOL]     n.putObject("unknown").putNull("inner"); [EOL]     Jackson370Bean obj = o.readValue(n.traverse(), Jackson370Bean.class); [EOL]     assertNotNull(obj.inner); [EOL]     assertEquals("test", obj.inner.value); [EOL] }
public void testDataBind() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     JsonNode tree = m.readTree("{ \"name\" : \"Tatu\", \n" + "\"magicNumber\" : 42," + "\"kids\" : [ \"Leo\", \"Lila\", \"Leia\" ] \n" + "}"); [EOL]     Person tatu = m.treeToValue(tree, Person.class); [EOL]     assertNotNull(tatu); [EOL]     assertEquals(42, tatu.magicNumber); [EOL]     assertEquals("Tatu", tatu.name); [EOL]     assertNotNull(tatu.kids); [EOL]     assertEquals(3, tatu.kids.size()); [EOL]     assertEquals("Leo", tatu.kids.get(0)); [EOL]     assertEquals("Lila", tatu.kids.get(1)); [EOL]     assertEquals("Leia", tatu.kids.get(2)); [EOL] }
public void testDataBind() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     JsonNode tree = m.readTree("{ \"name\" : \"Tatu\", \n" + "\"magicNumber\" : 42," + "\"kids\" : [ \"Leo\", \"Lila\", \"Leia\" ] \n" + "}"); [EOL]     Person tatu = m.treeToValue(tree, Person.class); [EOL]     assertNotNull(tatu); [EOL]     assertEquals(42, tatu.magicNumber); [EOL]     assertEquals("Tatu", tatu.name); [EOL]     assertNotNull(tatu.kids); [EOL]     assertEquals(3, tatu.kids.size()); [EOL]     assertEquals("Leo", tatu.kids.get(0)); [EOL]     assertEquals("Lila", tatu.kids.get(1)); [EOL]     assertEquals("Leia", tatu.kids.get(2)); [EOL] }
public void testBinaryNode() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 0, -5 }; [EOL]     BinaryNode n = new BinaryNode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     assertEquals("APs=", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testBinaryNode() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 0, -5 }; [EOL]     BinaryNode n = new BinaryNode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     assertEquals("APs=", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testBinaryNode() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 0, -5 }; [EOL]     BinaryNode n = new BinaryNode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     assertEquals("APs=", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testBinaryNode() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 0, -5 }; [EOL]     BinaryNode n = new BinaryNode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     assertEquals("APs=", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testBinaryNode() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 0, -5 }; [EOL]     BinaryNode n = new BinaryNode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     assertEquals("APs=", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testBinaryNode() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 0, -5 }; [EOL]     BinaryNode n = new BinaryNode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     assertEquals("APs=", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testBinaryNode() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 0, -5 }; [EOL]     BinaryNode n = new BinaryNode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     assertEquals("APs=", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testBinaryNode() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 0, -5 }; [EOL]     BinaryNode n = new BinaryNode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     assertEquals("APs=", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testBinaryNode() throws Exception { [EOL]     byte[] inputBinary = new byte[] { 0, -5 }; [EOL]     BinaryNode n = new BinaryNode(inputBinary); [EOL]     JsonParser jp = n.traverse(); [EOL]     assertNull(jp.getCurrentToken()); [EOL]     assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken()); [EOL]     byte[] data = jp.getBinaryValue(); [EOL]     assertNotNull(data); [EOL]     assertArrayEquals(inputBinary, data); [EOL]     assertEquals("APs=", jp.getText()); [EOL]     assertNull(jp.nextToken()); [EOL] }
public void testDataBind() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     JsonNode tree = m.readTree("{ \"name\" : \"Tatu\", \n" + "\"magicNumber\" : 42," + "\"kids\" : [ \"Leo\", \"Lila\", \"Leia\" ] \n" + "}"); [EOL]     Person tatu = m.treeToValue(tree, Person.class); [EOL]     assertNotNull(tatu); [EOL]     assertEquals(42, tatu.magicNumber); [EOL]     assertEquals("Tatu", tatu.name); [EOL]     assertNotNull(tatu.kids); [EOL]     assertEquals(3, tatu.kids.size()); [EOL]     assertEquals("Leo", tatu.kids.get(0)); [EOL]     assertEquals("Lila", tatu.kids.get(1)); [EOL]     assertEquals("Leia", tatu.kids.get(2)); [EOL] }
public void testDataBind() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     JsonNode tree = m.readTree("{ \"name\" : \"Tatu\", \n" + "\"magicNumber\" : 42," + "\"kids\" : [ \"Leo\", \"Lila\", \"Leia\" ] \n" + "}"); [EOL]     Person tatu = m.treeToValue(tree, Person.class); [EOL]     assertNotNull(tatu); [EOL]     assertEquals(42, tatu.magicNumber); [EOL]     assertEquals("Tatu", tatu.name); [EOL]     assertNotNull(tatu.kids); [EOL]     assertEquals(3, tatu.kids.size()); [EOL]     assertEquals("Leo", tatu.kids.get(0)); [EOL]     assertEquals("Lila", tatu.kids.get(1)); [EOL]     assertEquals("Leia", tatu.kids.get(2)); [EOL] }
public void testDataBind() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     JsonNode tree = m.readTree("{ \"name\" : \"Tatu\", \n" + "\"magicNumber\" : 42," + "\"kids\" : [ \"Leo\", \"Lila\", \"Leia\" ] \n" + "}"); [EOL]     Person tatu = m.treeToValue(tree, Person.class); [EOL]     assertNotNull(tatu); [EOL]     assertEquals(42, tatu.magicNumber); [EOL]     assertEquals("Tatu", tatu.name); [EOL]     assertNotNull(tatu.kids); [EOL]     assertEquals(3, tatu.kids.size()); [EOL]     assertEquals("Leo", tatu.kids.get(0)); [EOL]     assertEquals("Lila", tatu.kids.get(1)); [EOL]     assertEquals("Leia", tatu.kids.get(2)); [EOL] }
public void testDataBind() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     JsonNode tree = m.readTree("{ \"name\" : \"Tatu\", \n" + "\"magicNumber\" : 42," + "\"kids\" : [ \"Leo\", \"Lila\", \"Leia\" ] \n" + "}"); [EOL]     Person tatu = m.treeToValue(tree, Person.class); [EOL]     assertNotNull(tatu); [EOL]     assertEquals(42, tatu.magicNumber); [EOL]     assertEquals("Tatu", tatu.name); [EOL]     assertNotNull(tatu.kids); [EOL]     assertEquals(3, tatu.kids.size()); [EOL]     assertEquals("Leo", tatu.kids.get(0)); [EOL]     assertEquals("Lila", tatu.kids.get(1)); [EOL]     assertEquals("Leia", tatu.kids.get(2)); [EOL] }
public void testDataBind() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     JsonNode tree = m.readTree("{ \"name\" : \"Tatu\", \n" + "\"magicNumber\" : 42," + "\"kids\" : [ \"Leo\", \"Lila\", \"Leia\" ] \n" + "}"); [EOL]     Person tatu = m.treeToValue(tree, Person.class); [EOL]     assertNotNull(tatu); [EOL]     assertEquals(42, tatu.magicNumber); [EOL]     assertEquals("Tatu", tatu.name); [EOL]     assertNotNull(tatu.kids); [EOL]     assertEquals(3, tatu.kids.size()); [EOL]     assertEquals("Leo", tatu.kids.get(0)); [EOL]     assertEquals("Lila", tatu.kids.get(1)); [EOL]     assertEquals("Leia", tatu.kids.get(2)); [EOL] }
public void testArrayTypingNested() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(DefaultTyping.NON_CONCRETE_AND_ARRAYS); [EOL]     ArrayBean bean = new ArrayBean(new String[0][0]); [EOL]     String json = m.writeValueAsString(bean); [EOL]     ArrayBean result = m.readValue(json, ArrayBean.class); [EOL]     assertNotNull(result.values); [EOL]     assertEquals(String[][].class, result.values.getClass()); [EOL] }
public void testArrayTypingNested() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enableDefaultTyping(DefaultTyping.NON_CONCRETE_AND_ARRAYS); [EOL]     ArrayBean bean = new ArrayBean(new String[0][0]); [EOL]     String json = m.writeValueAsString(bean); [EOL]     ArrayBean result = m.readValue(json, ArrayBean.class); [EOL]     assertNotNull(result.values); [EOL]     assertEquals(String[][].class, result.values.getClass()); [EOL] }
public void testTimeZoneInBean() throws IOException { [EOL]     String json = MAPPER.writeValueAsString(new TimeZoneBean("PST")); [EOL]     assertEquals("{\"tz\":\"PST\"}", json); [EOL] }
public void testEmptyWithAnnotations() throws Exception { [EOL]     try { [EOL]         serializeAsString(mapper, new Empty()); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "No serializer found for class"); [EOL]     } [EOL]     assertEquals("{}", serializeAsString(mapper, new EmptyWithAnno())); [EOL]     ObjectMapper m2 = new ObjectMapper(); [EOL]     m2.addMixInAnnotations(Empty.class, EmptyWithAnno.class); [EOL]     assertEquals("{}", m2.writeValueAsString(new Empty())); [EOL] }
public void testEmptyWithAnnotations() throws Exception { [EOL]     try { [EOL]         serializeAsString(mapper, new Empty()); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "No serializer found for class"); [EOL]     } [EOL]     assertEquals("{}", serializeAsString(mapper, new EmptyWithAnno())); [EOL]     ObjectMapper m2 = new ObjectMapper(); [EOL]     m2.addMixInAnnotations(Empty.class, EmptyWithAnno.class); [EOL]     assertEquals("{}", m2.writeValueAsString(new Empty())); [EOL] }
public void testEmptyWithAnnotations() throws Exception { [EOL]     try { [EOL]         serializeAsString(mapper, new Empty()); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "No serializer found for class"); [EOL]     } [EOL]     assertEquals("{}", serializeAsString(mapper, new EmptyWithAnno())); [EOL]     ObjectMapper m2 = new ObjectMapper(); [EOL]     m2.addMixInAnnotations(Empty.class, EmptyWithAnno.class); [EOL]     assertEquals("{}", m2.writeValueAsString(new Empty())); [EOL] }
public void testEmptyWithAnnotations() throws Exception { [EOL]     try { [EOL]         serializeAsString(mapper, new Empty()); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "No serializer found for class"); [EOL]     } [EOL]     assertEquals("{}", serializeAsString(mapper, new EmptyWithAnno())); [EOL]     ObjectMapper m2 = new ObjectMapper(); [EOL]     m2.addMixInAnnotations(Empty.class, EmptyWithAnno.class); [EOL]     assertEquals("{}", m2.writeValueAsString(new Empty())); [EOL] }
public void testEmptyWithAnnotations() throws Exception { [EOL]     try { [EOL]         serializeAsString(mapper, new Empty()); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "No serializer found for class"); [EOL]     } [EOL]     assertEquals("{}", serializeAsString(mapper, new EmptyWithAnno())); [EOL]     ObjectMapper m2 = new ObjectMapper(); [EOL]     m2.addMixInAnnotations(Empty.class, EmptyWithAnno.class); [EOL]     assertEquals("{}", m2.writeValueAsString(new Empty())); [EOL] }
public void testSimple() { [EOL]     POJOPropertiesCollector coll = collector(mapper, Simple.class, true); [EOL]     Map<String, POJOPropertyBuilder> props = coll.getPropertyMap(); [EOL]     assertEquals(1, props.size()); [EOL]     POJOPropertyBuilder prop = props.get("value"); [EOL]     assertNotNull(prop); [EOL]     assertTrue(prop.hasSetter()); [EOL]     assertTrue(prop.hasGetter()); [EOL]     assertTrue(prop.hasField()); [EOL] }
public void testIntList() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String JSON = "{\"" + TypedListAsWrapper.class.getName() + "\":[4,5, 6]}"; [EOL]     JavaType type = TypeFactory.defaultInstance().constructCollectionType(TypedListAsWrapper.class, Integer.class); [EOL]     TypedListAsWrapper<Integer> result = m.readValue(JSON, type); [EOL]     assertNotNull(result); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals(Integer.valueOf(4), result.get(0)); [EOL]     assertEquals(Integer.valueOf(5), result.get(1)); [EOL]     assertEquals(Integer.valueOf(6), result.get(2)); [EOL] }
public void testIntList() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String JSON = "{\"" + TypedListAsWrapper.class.getName() + "\":[4,5, 6]}"; [EOL]     JavaType type = TypeFactory.defaultInstance().constructCollectionType(TypedListAsWrapper.class, Integer.class); [EOL]     TypedListAsWrapper<Integer> result = m.readValue(JSON, type); [EOL]     assertNotNull(result); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals(Integer.valueOf(4), result.get(0)); [EOL]     assertEquals(Integer.valueOf(5), result.get(1)); [EOL]     assertEquals(Integer.valueOf(6), result.get(2)); [EOL] }
public void testIntList() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     String JSON = "{\"" + TypedListAsWrapper.class.getName() + "\":[4,5, 6]}"; [EOL]     JavaType type = TypeFactory.defaultInstance().constructCollectionType(TypedListAsWrapper.class, Integer.class); [EOL]     TypedListAsWrapper<Integer> result = m.readValue(JSON, type); [EOL]     assertNotNull(result); [EOL]     assertEquals(3, result.size()); [EOL]     assertEquals(Integer.valueOf(4), result.get(0)); [EOL]     assertEquals(Integer.valueOf(5), result.get(1)); [EOL]     assertEquals(Integer.valueOf(6), result.get(2)); [EOL] }
public void testNullHandling() throws Exception { [EOL]     JsonNode n = objectReader().readTree("null"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     n = objectMapper().readTree("null"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL]     ObjectNode root = (ObjectNode) objectReader().readTree("{\"x\":null}"); [EOL]     assertEquals(1, root.size()); [EOL]     n = root.get("x"); [EOL]     assertNotNull(n); [EOL]     assertTrue(n.isNull()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testAbstract368() throws Exception { [EOL]     AbstractNode parent = new ConcreteNode("p"); [EOL]     AbstractNode child = new ConcreteNode("c"); [EOL]     parent.next = child; [EOL]     child.prev = parent; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(parent); [EOL]     AbstractNode root = mapper.readValue(json, AbstractNode.class); [EOL]     assertEquals(ConcreteNode.class, root.getClass()); [EOL]     assertEquals("p", root.id); [EOL]     assertNull(root.prev); [EOL]     AbstractNode leaf = root.next; [EOL]     assertNotNull(leaf); [EOL]     assertEquals("c", leaf.id); [EOL]     assertSame(root, leaf.prev); [EOL] }
public void testAbstract368() throws Exception { [EOL]     AbstractNode parent = new ConcreteNode("p"); [EOL]     AbstractNode child = new ConcreteNode("c"); [EOL]     parent.next = child; [EOL]     child.prev = parent; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(parent); [EOL]     AbstractNode root = mapper.readValue(json, AbstractNode.class); [EOL]     assertEquals(ConcreteNode.class, root.getClass()); [EOL]     assertEquals("p", root.id); [EOL]     assertNull(root.prev); [EOL]     AbstractNode leaf = root.next; [EOL]     assertNotNull(leaf); [EOL]     assertEquals("c", leaf.id); [EOL]     assertSame(root, leaf.prev); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testAbstract368() throws Exception { [EOL]     AbstractNode parent = new ConcreteNode("p"); [EOL]     AbstractNode child = new ConcreteNode("c"); [EOL]     parent.next = child; [EOL]     child.prev = parent; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(parent); [EOL]     AbstractNode root = mapper.readValue(json, AbstractNode.class); [EOL]     assertEquals(ConcreteNode.class, root.getClass()); [EOL]     assertEquals("p", root.id); [EOL]     assertNull(root.prev); [EOL]     AbstractNode leaf = root.next; [EOL]     assertNotNull(leaf); [EOL]     assertEquals("c", leaf.id); [EOL]     assertSame(root, leaf.prev); [EOL] }
public void testAbstract368() throws Exception { [EOL]     AbstractNode parent = new ConcreteNode("p"); [EOL]     AbstractNode child = new ConcreteNode("c"); [EOL]     parent.next = child; [EOL]     child.prev = parent; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(parent); [EOL]     AbstractNode root = mapper.readValue(json, AbstractNode.class); [EOL]     assertEquals(ConcreteNode.class, root.getClass()); [EOL]     assertEquals("p", root.id); [EOL]     assertNull(root.prev); [EOL]     AbstractNode leaf = root.next; [EOL]     assertNotNull(leaf); [EOL]     assertEquals("c", leaf.id); [EOL]     assertSame(root, leaf.prev); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testSchemaId() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class); [EOL]     String json = jsonSchema.toString().replaceAll("\"", "'"); [EOL]     assertEquals("{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}", json); [EOL] }
public void testSchemaId() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class); [EOL]     String json = jsonSchema.toString().replaceAll("\"", "'"); [EOL]     assertEquals("{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}", json); [EOL] }
public void testSchemaId() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class); [EOL]     String json = jsonSchema.toString().replaceAll("\"", "'"); [EOL]     assertEquals("{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}", json); [EOL] }
public void testSchemaId() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class); [EOL]     String json = jsonSchema.toString().replaceAll("\"", "'"); [EOL]     assertEquals("{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}", json); [EOL] }
public void testSchemaId() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class); [EOL]     String json = jsonSchema.toString().replaceAll("\"", "'"); [EOL]     assertEquals("{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}", json); [EOL] }
public void testSchemaId() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class); [EOL]     String json = jsonSchema.toString().replaceAll("\"", "'"); [EOL]     assertEquals("{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}", json); [EOL] }
public void testSchemaId() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class); [EOL]     String json = jsonSchema.toString().replaceAll("\"", "'"); [EOL]     assertEquals("{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}", json); [EOL] }
public void testExceptionWithMapperAndGenerator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     JsonFactory f = new MappingJsonFactory(); [EOL]     BrokenStringWriter sw = new BrokenStringWriter("TEST"); [EOL]     JsonGenerator jg = f.createGenerator(sw); [EOL]     try { [EOL]         mapper.writeValue(jg, createLongObject()); [EOL]         fail("Should have gotten an exception"); [EOL]     } catch (IOException e) { [EOL]         verifyException(e, IOException.class, "TEST"); [EOL]     } [EOL] }
public void testExceptionWithMapperAndGenerator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     JsonFactory f = new MappingJsonFactory(); [EOL]     BrokenStringWriter sw = new BrokenStringWriter("TEST"); [EOL]     JsonGenerator jg = f.createGenerator(sw); [EOL]     try { [EOL]         mapper.writeValue(jg, createLongObject()); [EOL]         fail("Should have gotten an exception"); [EOL]     } catch (IOException e) { [EOL]         verifyException(e, IOException.class, "TEST"); [EOL]     } [EOL] }
public void testExceptionWithMapperAndGenerator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     JsonFactory f = new MappingJsonFactory(); [EOL]     BrokenStringWriter sw = new BrokenStringWriter("TEST"); [EOL]     JsonGenerator jg = f.createGenerator(sw); [EOL]     try { [EOL]         mapper.writeValue(jg, createLongObject()); [EOL]         fail("Should have gotten an exception"); [EOL]     } catch (IOException e) { [EOL]         verifyException(e, IOException.class, "TEST"); [EOL]     } [EOL] }
public void testExceptionWithMapperAndGenerator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     JsonFactory f = new MappingJsonFactory(); [EOL]     BrokenStringWriter sw = new BrokenStringWriter("TEST"); [EOL]     JsonGenerator jg = f.createGenerator(sw); [EOL]     try { [EOL]         mapper.writeValue(jg, createLongObject()); [EOL]         fail("Should have gotten an exception"); [EOL]     } catch (IOException e) { [EOL]         verifyException(e, IOException.class, "TEST"); [EOL]     } [EOL] }
public void testExceptionWithMapperAndGenerator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     JsonFactory f = new MappingJsonFactory(); [EOL]     BrokenStringWriter sw = new BrokenStringWriter("TEST"); [EOL]     JsonGenerator jg = f.createGenerator(sw); [EOL]     try { [EOL]         mapper.writeValue(jg, createLongObject()); [EOL]         fail("Should have gotten an exception"); [EOL]     } catch (IOException e) { [EOL]         verifyException(e, IOException.class, "TEST"); [EOL]     } [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testManualPolymorphicCatWithReorder() throws Exception { [EOL]     Animal animal = MAPPER.readValue("{ \"likesCream\":true, \"name\" : \"Venla\", \"type\":\"cat\" }", Animal.class); [EOL]     assertEquals(Cat.class, animal.getClass()); [EOL]     assertEquals("Venla", animal.name); [EOL]     assertTrue(((Cat) animal).likesCream); [EOL] }
public void testManualPolymorphicCatWithReorder() throws Exception { [EOL]     Animal animal = MAPPER.readValue("{ \"likesCream\":true, \"name\" : \"Venla\", \"type\":\"cat\" }", Animal.class); [EOL]     assertEquals(Cat.class, animal.getClass()); [EOL]     assertEquals("Venla", animal.name); [EOL]     assertTrue(((Cat) animal).likesCream); [EOL] }
public void testManualPolymorphicCatWithReorder() throws Exception { [EOL]     Animal animal = MAPPER.readValue("{ \"likesCream\":true, \"name\" : \"Venla\", \"type\":\"cat\" }", Animal.class); [EOL]     assertEquals(Cat.class, animal.getClass()); [EOL]     assertEquals("Venla", animal.name); [EOL]     assertTrue(((Cat) animal).likesCream); [EOL] }
public void testManualPolymorphicCatWithReorder() throws Exception { [EOL]     Animal animal = MAPPER.readValue("{ \"likesCream\":true, \"name\" : \"Venla\", \"type\":\"cat\" }", Animal.class); [EOL]     assertEquals(Cat.class, animal.getClass()); [EOL]     assertEquals("Venla", animal.name); [EOL]     assertTrue(((Cat) animal).likesCream); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testArrayBlockingQueue() throws Exception { [EOL]     ArrayBlockingQueue<?> q = MAPPER.readValue("[1, 2, 3]", ArrayBlockingQueue.class); [EOL]     assertNotNull(q); [EOL]     assertEquals(3, q.size()); [EOL]     assertEquals(Integer.valueOf(1), q.take()); [EOL]     assertEquals(Integer.valueOf(2), q.take()); [EOL]     assertEquals(Integer.valueOf(3), q.take()); [EOL] }
public void testArrayBlockingQueue() throws Exception { [EOL]     ArrayBlockingQueue<?> q = MAPPER.readValue("[1, 2, 3]", ArrayBlockingQueue.class); [EOL]     assertNotNull(q); [EOL]     assertEquals(3, q.size()); [EOL]     assertEquals(Integer.valueOf(1), q.take()); [EOL]     assertEquals(Integer.valueOf(2), q.take()); [EOL]     assertEquals(Integer.valueOf(3), q.take()); [EOL] }
public void testArrayBlockingQueue() throws Exception { [EOL]     ArrayBlockingQueue<?> q = MAPPER.readValue("[1, 2, 3]", ArrayBlockingQueue.class); [EOL]     assertNotNull(q); [EOL]     assertEquals(3, q.size()); [EOL]     assertEquals(Integer.valueOf(1), q.take()); [EOL]     assertEquals(Integer.valueOf(2), q.take()); [EOL]     assertEquals(Integer.valueOf(3), q.take()); [EOL] }
public void testArrayBlockingQueue() throws Exception { [EOL]     ArrayBlockingQueue<?> q = MAPPER.readValue("[1, 2, 3]", ArrayBlockingQueue.class); [EOL]     assertNotNull(q); [EOL]     assertEquals(3, q.size()); [EOL]     assertEquals(Integer.valueOf(1), q.take()); [EOL]     assertEquals(Integer.valueOf(2), q.take()); [EOL]     assertEquals(Integer.valueOf(3), q.take()); [EOL] }
public void testArrayBlockingQueue() throws Exception { [EOL]     ArrayBlockingQueue<?> q = MAPPER.readValue("[1, 2, 3]", ArrayBlockingQueue.class); [EOL]     assertNotNull(q); [EOL]     assertEquals(3, q.size()); [EOL]     assertEquals(Integer.valueOf(1), q.take()); [EOL]     assertEquals(Integer.valueOf(2), q.take()); [EOL]     assertEquals(Integer.valueOf(3), q.take()); [EOL] }
public void testArrayBlockingQueue() throws Exception { [EOL]     ArrayBlockingQueue<?> q = MAPPER.readValue("[1, 2, 3]", ArrayBlockingQueue.class); [EOL]     assertNotNull(q); [EOL]     assertEquals(3, q.size()); [EOL]     assertEquals(Integer.valueOf(1), q.take()); [EOL]     assertEquals(Integer.valueOf(2), q.take()); [EOL]     assertEquals(Integer.valueOf(3), q.take()); [EOL] }
public void testAnnotatedList() throws Exception { [EOL]     ObjectMapper mapper = _mapperWithAnnotatedContextual(); [EOL]     ContextualListBean bean = mapper.readValue("{\"beans\":[\"x\"]}", ContextualListBean.class); [EOL]     assertEquals(1, bean.beans.size()); [EOL]     assertEquals("list=x", bean.beans.get(0).value); [EOL]     bean = mapper.readValue("{\"beans\":[\"x\",\"y\",\"z\"]}", ContextualListBean.class); [EOL]     assertEquals(3, bean.beans.size()); [EOL]     assertEquals("list=x", bean.beans.get(0).value); [EOL]     assertEquals("list=y", bean.beans.get(1).value); [EOL]     assertEquals("list=z", bean.beans.get(2).value); [EOL] }
public void testAnnotatedList() throws Exception { [EOL]     ObjectMapper mapper = _mapperWithAnnotatedContextual(); [EOL]     ContextualListBean bean = mapper.readValue("{\"beans\":[\"x\"]}", ContextualListBean.class); [EOL]     assertEquals(1, bean.beans.size()); [EOL]     assertEquals("list=x", bean.beans.get(0).value); [EOL]     bean = mapper.readValue("{\"beans\":[\"x\",\"y\",\"z\"]}", ContextualListBean.class); [EOL]     assertEquals(3, bean.beans.size()); [EOL]     assertEquals("list=x", bean.beans.get(0).value); [EOL]     assertEquals("list=y", bean.beans.get(1).value); [EOL]     assertEquals("list=z", bean.beans.get(2).value); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testMapWrapper() throws Exception { [EOL]     StringMap value = new ObjectMapper().readValue("{\"entries\":{\"a\":9} }", StringMap.class); [EOL]     assertNotNull(value.getEntries()); [EOL]     assertEquals(1, value.getEntries().size()); [EOL]     assertEquals(Long.valueOf(9), value.getEntries().get("a")); [EOL] }
public void testMapWrapper() throws Exception { [EOL]     StringMap value = new ObjectMapper().readValue("{\"entries\":{\"a\":9} }", StringMap.class); [EOL]     assertNotNull(value.getEntries()); [EOL]     assertEquals(1, value.getEntries().size()); [EOL]     assertEquals(Long.valueOf(9), value.getEntries().get("a")); [EOL] }
public void testMapWrapper() throws Exception { [EOL]     StringMap value = new ObjectMapper().readValue("{\"entries\":{\"a\":9} }", StringMap.class); [EOL]     assertNotNull(value.getEntries()); [EOL]     assertEquals(1, value.getEntries().size()); [EOL]     assertEquals(Long.valueOf(9), value.getEntries().get("a")); [EOL] }
public void testMapWrapper() throws Exception { [EOL]     StringMap value = new ObjectMapper().readValue("{\"entries\":{\"a\":9} }", StringMap.class); [EOL]     assertNotNull(value.getEntries()); [EOL]     assertEquals(1, value.getEntries().size()); [EOL]     assertEquals(Long.valueOf(9), value.getEntries().get("a")); [EOL] }
public void testMapWrapper() throws Exception { [EOL]     StringMap value = new ObjectMapper().readValue("{\"entries\":{\"a\":9} }", StringMap.class); [EOL]     assertNotNull(value.getEntries()); [EOL]     assertEquals(1, value.getEntries().size()); [EOL]     assertEquals(Long.valueOf(9), value.getEntries().get("a")); [EOL] }
public void testMapWrapper() throws Exception { [EOL]     StringMap value = new ObjectMapper().readValue("{\"entries\":{\"a\":9} }", StringMap.class); [EOL]     assertNotNull(value.getEntries()); [EOL]     assertEquals(1, value.getEntries().size()); [EOL]     assertEquals(Long.valueOf(9), value.getEntries().get("a")); [EOL] }
public void testMapWrapper() throws Exception { [EOL]     StringMap value = new ObjectMapper().readValue("{\"entries\":{\"a\":9} }", StringMap.class); [EOL]     assertNotNull(value.getEntries()); [EOL]     assertEquals(1, value.getEntries().size()); [EOL]     assertEquals(Long.valueOf(9), value.getEntries().get("a")); [EOL] }
public void testSchemaId() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class); [EOL]     String json = jsonSchema.toString().replaceAll("\"", "'"); [EOL]     assertEquals("{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}", json); [EOL] }
public void testSchemaId() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class); [EOL]     String json = jsonSchema.toString().replaceAll("\"", "'"); [EOL]     assertEquals("{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}", json); [EOL] }
public void testSchemaId() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class); [EOL]     String json = jsonSchema.toString().replaceAll("\"", "'"); [EOL]     assertEquals("{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}", json); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testProviderConfig() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     DefaultSerializerProvider prov = (DefaultSerializerProvider) mapper.getSerializerProvider(); [EOL]     assertEquals(0, prov.cachedSerializersCount()); [EOL]     Map<String, Object> result = this.writeAndMap(mapper, new AnnoBean()); [EOL]     assertEquals(2, result.size()); [EOL]     assertEquals(Integer.valueOf(1), result.get("x")); [EOL]     assertEquals(Integer.valueOf(2), result.get("y")); [EOL]     int count = prov.cachedSerializersCount(); [EOL]     if (count < 2) { [EOL]         fail("Should have at least 2 cached serializers, got " + count); [EOL]     } [EOL]     prov.flushCachedSerializers(); [EOL]     assertEquals(0, prov.cachedSerializersCount()); [EOL] }
public void testProviderConfig() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     DefaultSerializerProvider prov = (DefaultSerializerProvider) mapper.getSerializerProvider(); [EOL]     assertEquals(0, prov.cachedSerializersCount()); [EOL]     Map<String, Object> result = this.writeAndMap(mapper, new AnnoBean()); [EOL]     assertEquals(2, result.size()); [EOL]     assertEquals(Integer.valueOf(1), result.get("x")); [EOL]     assertEquals(Integer.valueOf(2), result.get("y")); [EOL]     int count = prov.cachedSerializersCount(); [EOL]     if (count < 2) { [EOL]         fail("Should have at least 2 cached serializers, got " + count); [EOL]     } [EOL]     prov.flushCachedSerializers(); [EOL]     assertEquals(0, prov.cachedSerializersCount()); [EOL] }
public void testEnumUsingToString() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     mapper.writeValue(sw, AnnotatedTestEnum.C2); [EOL]     assertEquals("\"c2\"", sw.toString()); [EOL] }
public void testEnumUsingToString() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     mapper.writeValue(sw, AnnotatedTestEnum.C2); [EOL]     assertEquals("\"c2\"", sw.toString()); [EOL] }
public void testEnumUsingToString() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     mapper.writeValue(sw, AnnotatedTestEnum.C2); [EOL]     assertEquals("\"c2\"", sw.toString()); [EOL] }
public void testEnumUsingToString() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     mapper.writeValue(sw, AnnotatedTestEnum.C2); [EOL]     assertEquals("\"c2\"", sw.toString()); [EOL] }
public void testEnumUsingToString() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     mapper.writeValue(sw, AnnotatedTestEnum.C2); [EOL]     assertEquals("\"c2\"", sw.toString()); [EOL] }
public void testEnumUsingToString() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     mapper.writeValue(sw, AnnotatedTestEnum.C2); [EOL]     assertEquals("\"c2\"", sw.toString()); [EOL] }
public void testEnumUsingToString() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     mapper.writeValue(sw, AnnotatedTestEnum.C2); [EOL]     assertEquals("\"c2\"", sw.toString()); [EOL] }
public void testEnumUsingToString() throws Exception { [EOL]     StringWriter sw = new StringWriter(); [EOL]     mapper.writeValue(sw, AnnotatedTestEnum.C2); [EOL]     assertEquals("\"c2\"", sw.toString()); [EOL] }
public void testSimpleUnwrappedDeserialize() throws Exception { [EOL]     Unwrapping bean = mapper.readValue("{\"name\":\"Tatu\",\"y\":7,\"x\":-13}", Unwrapping.class); [EOL]     assertEquals("Tatu", bean.name); [EOL]     Location loc = bean.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(-13, loc.x); [EOL]     assertEquals(7, loc.y); [EOL] }
public void testSimpleDeserWithForwardRefs() throws Exception { [EOL]     IdWrapper result = mapper.readValue("{\"node\":{\"value\":7,\"next\":{\"node\":1}, \"@id\":1}}", IdWrapper.class); [EOL]     assertEquals(7, result.node.value); [EOL]     assertSame(result.node, result.node.next.node); [EOL] }
public void testSimpleDeserWithForwardRefs() throws Exception { [EOL]     IdWrapper result = mapper.readValue("{\"node\":{\"value\":7,\"next\":{\"node\":1}, \"@id\":1}}", IdWrapper.class); [EOL]     assertEquals(7, result.node.value); [EOL]     assertSame(result.node, result.node.next.node); [EOL] }
public void testPropertyIgnoral() throws Exception { [EOL]     XYZWrapper1 result = MAPPER.readValue("{\"value\":{\"y\":2,\"x\":1,\"z\":3}}", XYZWrapper1.class); [EOL]     assertEquals(2, result.value.y); [EOL]     assertEquals(3, result.value.z); [EOL] }
public void testPropertyIgnoral() throws Exception { [EOL]     XYZWrapper1 result = MAPPER.readValue("{\"value\":{\"y\":2,\"x\":1,\"z\":3}}", XYZWrapper1.class); [EOL]     assertEquals(2, result.value.y); [EOL]     assertEquals(3, result.value.z); [EOL] }
public void testPropertyIgnoral() throws Exception { [EOL]     XYZWrapper1 result = MAPPER.readValue("{\"value\":{\"y\":2,\"x\":1,\"z\":3}}", XYZWrapper1.class); [EOL]     assertEquals(2, result.value.y); [EOL]     assertEquals(3, result.value.z); [EOL] }
public void testSimpleUnwrappedDeserialize() throws Exception { [EOL]     Unwrapping bean = mapper.readValue("{\"name\":\"Tatu\",\"y\":7,\"x\":-13}", Unwrapping.class); [EOL]     assertEquals("Tatu", bean.name); [EOL]     Location loc = bean.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(-13, loc.x); [EOL]     assertEquals(7, loc.y); [EOL] }
public void testSimpleUnwrappedDeserialize() throws Exception { [EOL]     Unwrapping bean = mapper.readValue("{\"name\":\"Tatu\",\"y\":7,\"x\":-13}", Unwrapping.class); [EOL]     assertEquals("Tatu", bean.name); [EOL]     Location loc = bean.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(-13, loc.x); [EOL]     assertEquals(7, loc.y); [EOL] }
public void testSimpleDeserWithForwardRefs() throws Exception { [EOL]     IdWrapper result = mapper.readValue("{\"node\":{\"value\":7,\"next\":{\"node\":1}, \"@id\":1}}", IdWrapper.class); [EOL]     assertEquals(7, result.node.value); [EOL]     assertSame(result.node, result.node.next.node); [EOL] }
public void testSimpleDeserWithForwardRefs() throws Exception { [EOL]     IdWrapper result = mapper.readValue("{\"node\":{\"value\":7,\"next\":{\"node\":1}, \"@id\":1}}", IdWrapper.class); [EOL]     assertEquals(7, result.node.value); [EOL]     assertSame(result.node, result.node.next.node); [EOL] }
public void testPropertyIgnoral() throws Exception { [EOL]     XYZWrapper1 result = MAPPER.readValue("{\"value\":{\"y\":2,\"x\":1,\"z\":3}}", XYZWrapper1.class); [EOL]     assertEquals(2, result.value.y); [EOL]     assertEquals(3, result.value.z); [EOL] }
public void testPropertyIgnoral() throws Exception { [EOL]     XYZWrapper1 result = MAPPER.readValue("{\"value\":{\"y\":2,\"x\":1,\"z\":3}}", XYZWrapper1.class); [EOL]     assertEquals(2, result.value.y); [EOL]     assertEquals(3, result.value.z); [EOL] }
public void testSimpleDeserWithForwardRefs() throws Exception { [EOL]     IdWrapper result = mapper.readValue("{\"node\":{\"value\":7,\"next\":{\"node\":1}, \"@id\":1}}", IdWrapper.class); [EOL]     assertEquals(7, result.node.value); [EOL]     assertSame(result.node, result.node.next.node); [EOL] }
public void testSimpleDeserWithForwardRefs() throws Exception { [EOL]     IdWrapper result = mapper.readValue("{\"node\":{\"value\":7,\"next\":{\"node\":1}, \"@id\":1}}", IdWrapper.class); [EOL]     assertEquals(7, result.node.value); [EOL]     assertSame(result.node, result.node.next.node); [EOL] }
public void testSimpleDeserWithForwardRefs() throws Exception { [EOL]     IdWrapper result = mapper.readValue("{\"node\":{\"value\":7,\"next\":{\"node\":1}, \"@id\":1}}", IdWrapper.class); [EOL]     assertEquals(7, result.node.value); [EOL]     assertSame(result.node, result.node.next.node); [EOL] }
public void testSimpleDeserWithForwardRefs() throws Exception { [EOL]     IdWrapper result = mapper.readValue("{\"node\":{\"value\":7,\"next\":{\"node\":1}, \"@id\":1}}", IdWrapper.class); [EOL]     assertEquals(7, result.node.value); [EOL]     assertSame(result.node, result.node.next.node); [EOL] }
public void testIssue508() throws Exception { [EOL]     List<List<Issue508A>> l = new ArrayList<List<Issue508A>>(); [EOL]     List<Issue508A> l2 = new ArrayList<Issue508A>(); [EOL]     l2.add(new Issue508A()); [EOL]     l.add(l2); [EOL]     TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() { [EOL]     }; [EOL]     String json = mapper.writerWithType(typeRef).writeValueAsString(l); [EOL]     List<?> output = mapper.readValue(json, typeRef); [EOL]     assertEquals(1, output.size()); [EOL]     Object ob = output.get(0); [EOL]     assertTrue(ob instanceof List<?>); [EOL]     List<?> list2 = (List<?>) ob; [EOL]     assertEquals(1, list2.size()); [EOL]     ob = list2.get(0); [EOL]     assertSame(Issue508A.class, ob.getClass()); [EOL] }
public void testIssue508() throws Exception { [EOL]     List<List<Issue508A>> l = new ArrayList<List<Issue508A>>(); [EOL]     List<Issue508A> l2 = new ArrayList<Issue508A>(); [EOL]     l2.add(new Issue508A()); [EOL]     l.add(l2); [EOL]     TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() { [EOL]     }; [EOL]     String json = mapper.writerWithType(typeRef).writeValueAsString(l); [EOL]     List<?> output = mapper.readValue(json, typeRef); [EOL]     assertEquals(1, output.size()); [EOL]     Object ob = output.get(0); [EOL]     assertTrue(ob instanceof List<?>); [EOL]     List<?> list2 = (List<?>) ob; [EOL]     assertEquals(1, list2.size()); [EOL]     ob = list2.get(0); [EOL]     assertSame(Issue508A.class, ob.getClass()); [EOL] }
public void testIssue508() throws Exception { [EOL]     List<List<Issue508A>> l = new ArrayList<List<Issue508A>>(); [EOL]     List<Issue508A> l2 = new ArrayList<Issue508A>(); [EOL]     l2.add(new Issue508A()); [EOL]     l.add(l2); [EOL]     TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() { [EOL]     }; [EOL]     String json = mapper.writerWithType(typeRef).writeValueAsString(l); [EOL]     List<?> output = mapper.readValue(json, typeRef); [EOL]     assertEquals(1, output.size()); [EOL]     Object ob = output.get(0); [EOL]     assertTrue(ob instanceof List<?>); [EOL]     List<?> list2 = (List<?>) ob; [EOL]     assertEquals(1, list2.size()); [EOL]     ob = list2.get(0); [EOL]     assertSame(Issue508A.class, ob.getClass()); [EOL] }
public void testIssue508() throws Exception { [EOL]     List<List<Issue508A>> l = new ArrayList<List<Issue508A>>(); [EOL]     List<Issue508A> l2 = new ArrayList<Issue508A>(); [EOL]     l2.add(new Issue508A()); [EOL]     l.add(l2); [EOL]     TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() { [EOL]     }; [EOL]     String json = mapper.writerWithType(typeRef).writeValueAsString(l); [EOL]     List<?> output = mapper.readValue(json, typeRef); [EOL]     assertEquals(1, output.size()); [EOL]     Object ob = output.get(0); [EOL]     assertTrue(ob instanceof List<?>); [EOL]     List<?> list2 = (List<?>) ob; [EOL]     assertEquals(1, list2.size()); [EOL]     ob = list2.get(0); [EOL]     assertSame(Issue508A.class, ob.getClass()); [EOL] }
public void testIssue508() throws Exception { [EOL]     List<List<Issue508A>> l = new ArrayList<List<Issue508A>>(); [EOL]     List<Issue508A> l2 = new ArrayList<Issue508A>(); [EOL]     l2.add(new Issue508A()); [EOL]     l.add(l2); [EOL]     TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() { [EOL]     }; [EOL]     String json = mapper.writerWithType(typeRef).writeValueAsString(l); [EOL]     List<?> output = mapper.readValue(json, typeRef); [EOL]     assertEquals(1, output.size()); [EOL]     Object ob = output.get(0); [EOL]     assertTrue(ob instanceof List<?>); [EOL]     List<?> list2 = (List<?>) ob; [EOL]     assertEquals(1, list2.size()); [EOL]     ob = list2.get(0); [EOL]     assertSame(Issue508A.class, ob.getClass()); [EOL] }
public void testIssue508() throws Exception { [EOL]     List<List<Issue508A>> l = new ArrayList<List<Issue508A>>(); [EOL]     List<Issue508A> l2 = new ArrayList<Issue508A>(); [EOL]     l2.add(new Issue508A()); [EOL]     l.add(l2); [EOL]     TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() { [EOL]     }; [EOL]     String json = mapper.writerWithType(typeRef).writeValueAsString(l); [EOL]     List<?> output = mapper.readValue(json, typeRef); [EOL]     assertEquals(1, output.size()); [EOL]     Object ob = output.get(0); [EOL]     assertTrue(ob instanceof List<?>); [EOL]     List<?> list2 = (List<?>) ob; [EOL]     assertEquals(1, list2.size()); [EOL]     ob = list2.get(0); [EOL]     assertSame(Issue508A.class, ob.getClass()); [EOL] }
public void testIssue508() throws Exception { [EOL]     List<List<Issue508A>> l = new ArrayList<List<Issue508A>>(); [EOL]     List<Issue508A> l2 = new ArrayList<Issue508A>(); [EOL]     l2.add(new Issue508A()); [EOL]     l.add(l2); [EOL]     TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() { [EOL]     }; [EOL]     String json = mapper.writerWithType(typeRef).writeValueAsString(l); [EOL]     List<?> output = mapper.readValue(json, typeRef); [EOL]     assertEquals(1, output.size()); [EOL]     Object ob = output.get(0); [EOL]     assertTrue(ob instanceof List<?>); [EOL]     List<?> list2 = (List<?>) ob; [EOL]     assertEquals(1, list2.size()); [EOL]     ob = list2.get(0); [EOL]     assertSame(Issue508A.class, ob.getClass()); [EOL] }
public void testIssue508() throws Exception { [EOL]     List<List<Issue508A>> l = new ArrayList<List<Issue508A>>(); [EOL]     List<Issue508A> l2 = new ArrayList<Issue508A>(); [EOL]     l2.add(new Issue508A()); [EOL]     l.add(l2); [EOL]     TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() { [EOL]     }; [EOL]     String json = mapper.writerWithType(typeRef).writeValueAsString(l); [EOL]     List<?> output = mapper.readValue(json, typeRef); [EOL]     assertEquals(1, output.size()); [EOL]     Object ob = output.get(0); [EOL]     assertTrue(ob instanceof List<?>); [EOL]     List<?> list2 = (List<?>) ob; [EOL]     assertEquals(1, list2.size()); [EOL]     ob = list2.get(0); [EOL]     assertSame(Issue508A.class, ob.getClass()); [EOL] }
public void testIssue508() throws Exception { [EOL]     List<List<Issue508A>> l = new ArrayList<List<Issue508A>>(); [EOL]     List<Issue508A> l2 = new ArrayList<Issue508A>(); [EOL]     l2.add(new Issue508A()); [EOL]     l.add(l2); [EOL]     TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() { [EOL]     }; [EOL]     String json = mapper.writerWithType(typeRef).writeValueAsString(l); [EOL]     List<?> output = mapper.readValue(json, typeRef); [EOL]     assertEquals(1, output.size()); [EOL]     Object ob = output.get(0); [EOL]     assertTrue(ob instanceof List<?>); [EOL]     List<?> list2 = (List<?>) ob; [EOL]     assertEquals(1, list2.size()); [EOL]     ob = list2.get(0); [EOL]     assertSame(Issue508A.class, ob.getClass()); [EOL] }
public void testIssue508() throws Exception { [EOL]     List<List<Issue508A>> l = new ArrayList<List<Issue508A>>(); [EOL]     List<Issue508A> l2 = new ArrayList<Issue508A>(); [EOL]     l2.add(new Issue508A()); [EOL]     l.add(l2); [EOL]     TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() { [EOL]     }; [EOL]     String json = mapper.writerWithType(typeRef).writeValueAsString(l); [EOL]     List<?> output = mapper.readValue(json, typeRef); [EOL]     assertEquals(1, output.size()); [EOL]     Object ob = output.get(0); [EOL]     assertTrue(ob instanceof List<?>); [EOL]     List<?> list2 = (List<?>) ob; [EOL]     assertEquals(1, list2.size()); [EOL]     ob = list2.get(0); [EOL]     assertSame(Issue508A.class, ob.getClass()); [EOL] }
public void testSimpleUnwrappedDeserialize() throws Exception { [EOL]     Unwrapping bean = mapper.readValue("{\"name\":\"Tatu\",\"y\":7,\"x\":-13}", Unwrapping.class); [EOL]     assertEquals("Tatu", bean.name); [EOL]     Location loc = bean.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(-13, loc.x); [EOL]     assertEquals(7, loc.y); [EOL] }
public void testSimpleUnwrappedDeserialize() throws Exception { [EOL]     Unwrapping bean = mapper.readValue("{\"name\":\"Tatu\",\"y\":7,\"x\":-13}", Unwrapping.class); [EOL]     assertEquals("Tatu", bean.name); [EOL]     Location loc = bean.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(-13, loc.x); [EOL]     assertEquals(7, loc.y); [EOL] }
public void testSimpleUnwrappedDeserialize() throws Exception { [EOL]     Unwrapping bean = mapper.readValue("{\"name\":\"Tatu\",\"y\":7,\"x\":-13}", Unwrapping.class); [EOL]     assertEquals("Tatu", bean.name); [EOL]     Location loc = bean.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(-13, loc.x); [EOL]     assertEquals(7, loc.y); [EOL] }
public void testSimpleUnwrappedDeserialize() throws Exception { [EOL]     Unwrapping bean = mapper.readValue("{\"name\":\"Tatu\",\"y\":7,\"x\":-13}", Unwrapping.class); [EOL]     assertEquals("Tatu", bean.name); [EOL]     Location loc = bean.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(-13, loc.x); [EOL]     assertEquals(7, loc.y); [EOL] }
public void testSimpleUnwrappedDeserialize() throws Exception { [EOL]     Unwrapping bean = mapper.readValue("{\"name\":\"Tatu\",\"y\":7,\"x\":-13}", Unwrapping.class); [EOL]     assertEquals("Tatu", bean.name); [EOL]     Location loc = bean.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(-13, loc.x); [EOL]     assertEquals(7, loc.y); [EOL] }
public void testSimpleUnwrappedDeserialize() throws Exception { [EOL]     Unwrapping bean = mapper.readValue("{\"name\":\"Tatu\",\"y\":7,\"x\":-13}", Unwrapping.class); [EOL]     assertEquals("Tatu", bean.name); [EOL]     Location loc = bean.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(-13, loc.x); [EOL]     assertEquals(7, loc.y); [EOL] }
public void testManualPolymorphicCatWithReorder() throws Exception { [EOL]     Animal animal = MAPPER.readValue("{ \"likesCream\":true, \"name\" : \"Venla\", \"type\":\"cat\" }", Animal.class); [EOL]     assertEquals(Cat.class, animal.getClass()); [EOL]     assertEquals("Venla", animal.name); [EOL]     assertTrue(((Cat) animal).likesCream); [EOL] }
public void testSimpleUnwrappedDeserialize() throws Exception { [EOL]     Unwrapping bean = mapper.readValue("{\"name\":\"Tatu\",\"y\":7,\"x\":-13}", Unwrapping.class); [EOL]     assertEquals("Tatu", bean.name); [EOL]     Location loc = bean.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(-13, loc.x); [EOL]     assertEquals(7, loc.y); [EOL] }
public void testSimpleUnwrappedDeserialize() throws Exception { [EOL]     Unwrapping bean = mapper.readValue("{\"name\":\"Tatu\",\"y\":7,\"x\":-13}", Unwrapping.class); [EOL]     assertEquals("Tatu", bean.name); [EOL]     Location loc = bean.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(-13, loc.x); [EOL]     assertEquals(7, loc.y); [EOL] }
public void testSimpleUnwrappedDeserialize() throws Exception { [EOL]     Unwrapping bean = mapper.readValue("{\"name\":\"Tatu\",\"y\":7,\"x\":-13}", Unwrapping.class); [EOL]     assertEquals("Tatu", bean.name); [EOL]     Location loc = bean.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(-13, loc.x); [EOL]     assertEquals(7, loc.y); [EOL] }
public void testSimpleUnwrappedDeserialize() throws Exception { [EOL]     Unwrapping bean = mapper.readValue("{\"name\":\"Tatu\",\"y\":7,\"x\":-13}", Unwrapping.class); [EOL]     assertEquals("Tatu", bean.name); [EOL]     Location loc = bean.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(-13, loc.x); [EOL]     assertEquals(7, loc.y); [EOL] }
public void testSimpleUnwrappedDeserialize() throws Exception { [EOL]     Unwrapping bean = mapper.readValue("{\"name\":\"Tatu\",\"y\":7,\"x\":-13}", Unwrapping.class); [EOL]     assertEquals("Tatu", bean.name); [EOL]     Location loc = bean.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(-13, loc.x); [EOL]     assertEquals(7, loc.y); [EOL] }
public void testSimpleUnwrappedDeserialize() throws Exception { [EOL]     Unwrapping bean = mapper.readValue("{\"name\":\"Tatu\",\"y\":7,\"x\":-13}", Unwrapping.class); [EOL]     assertEquals("Tatu", bean.name); [EOL]     Location loc = bean.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(-13, loc.x); [EOL]     assertEquals(7, loc.y); [EOL] }
public void testSimpleUnwrappedDeserialize() throws Exception { [EOL]     Unwrapping bean = mapper.readValue("{\"name\":\"Tatu\",\"y\":7,\"x\":-13}", Unwrapping.class); [EOL]     assertEquals("Tatu", bean.name); [EOL]     Location loc = bean.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(-13, loc.x); [EOL]     assertEquals(7, loc.y); [EOL] }
public void testSimpleUnwrappedDeserialize() throws Exception { [EOL]     Unwrapping bean = mapper.readValue("{\"name\":\"Tatu\",\"y\":7,\"x\":-13}", Unwrapping.class); [EOL]     assertEquals("Tatu", bean.name); [EOL]     Location loc = bean.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(-13, loc.x); [EOL]     assertEquals(7, loc.y); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = "{ \"petType\": \"dog\",\n" + "\"pet\": { \"name\": \"Pluto\" }\n}"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals("dog", result.petType); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = "{ \"petType\": \"dog\",\n" + "\"pet\": { \"name\": \"Pluto\" }\n}"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals("dog", result.petType); [EOL] }
public void testIssue831() throws Exception { [EOL]     final String JSON = "{ \"petType\": \"dog\",\n" + "\"pet\": { \"name\": \"Pluto\" }\n}"; [EOL]     House831 result = MAPPER.readValue(JSON, House831.class); [EOL]     assertNotNull(result); [EOL]     assertNotNull(result.pet); [EOL]     assertSame(Dog.class, result.pet.getClass()); [EOL]     assertEquals("dog", result.petType); [EOL] }
public void testModifyEnumSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setSerializerModifier(new EnumSerializerModifier())); [EOL]     assertEquals("123", mapper.writeValueAsString(EnumABC.C)); [EOL] }
public void testModifyEnumSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setSerializerModifier(new EnumSerializerModifier())); [EOL]     assertEquals("123", mapper.writeValueAsString(EnumABC.C)); [EOL] }
public void testModifyEnumSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setSerializerModifier(new EnumSerializerModifier())); [EOL]     assertEquals("123", mapper.writeValueAsString(EnumABC.C)); [EOL] }
public void testModifyEnumSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setSerializerModifier(new EnumSerializerModifier())); [EOL]     assertEquals("123", mapper.writeValueAsString(EnumABC.C)); [EOL] }
public void testModifyEnumSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setSerializerModifier(new EnumSerializerModifier())); [EOL]     assertEquals("123", mapper.writeValueAsString(EnumABC.C)); [EOL] }
public void testModifyEnumSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setSerializerModifier(new EnumSerializerModifier())); [EOL]     assertEquals("123", mapper.writeValueAsString(EnumABC.C)); [EOL] }
public void testModifyEnumSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setSerializerModifier(new EnumSerializerModifier())); [EOL]     assertEquals("123", mapper.writeValueAsString(EnumABC.C)); [EOL] }
public void testAsIndex() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     assertFalse(mapper.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX)); [EOL]     assertEquals(quote("B"), mapper.writeValueAsString(TestEnum.B)); [EOL]     mapper.enable(SerializationFeature.WRITE_ENUMS_USING_INDEX); [EOL]     assertEquals("1", mapper.writeValueAsString(TestEnum.B)); [EOL] }
public void testAsIndex() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     assertFalse(mapper.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX)); [EOL]     assertEquals(quote("B"), mapper.writeValueAsString(TestEnum.B)); [EOL]     mapper.enable(SerializationFeature.WRITE_ENUMS_USING_INDEX); [EOL]     assertEquals("1", mapper.writeValueAsString(TestEnum.B)); [EOL] }
public void testModifyEnumSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setSerializerModifier(new EnumSerializerModifier())); [EOL]     assertEquals("123", mapper.writeValueAsString(EnumABC.C)); [EOL] }
public void testModifyEnumSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setSerializerModifier(new EnumSerializerModifier())); [EOL]     assertEquals("123", mapper.writeValueAsString(EnumABC.C)); [EOL] }
public void testModifyEnumSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setSerializerModifier(new EnumSerializerModifier())); [EOL]     assertEquals("123", mapper.writeValueAsString(EnumABC.C)); [EOL] }
public void testModifyEnumSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setSerializerModifier(new EnumSerializerModifier())); [EOL]     assertEquals("123", mapper.writeValueAsString(EnumABC.C)); [EOL] }
public void testModifyEnumSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setSerializerModifier(new EnumSerializerModifier())); [EOL]     assertEquals("123", mapper.writeValueAsString(EnumABC.C)); [EOL] }
public void testModifyEnumSerializer() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new SimpleModule("test").setSerializerModifier(new EnumSerializerModifier())); [EOL]     assertEquals("123", mapper.writeValueAsString(EnumABC.C)); [EOL] }
public void testProviderConfig() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     DefaultSerializerProvider prov = (DefaultSerializerProvider) mapper.getSerializerProvider(); [EOL]     assertEquals(0, prov.cachedSerializersCount()); [EOL]     Map<String, Object> result = this.writeAndMap(mapper, new AnnoBean()); [EOL]     assertEquals(2, result.size()); [EOL]     assertEquals(Integer.valueOf(1), result.get("x")); [EOL]     assertEquals(Integer.valueOf(2), result.get("y")); [EOL]     int count = prov.cachedSerializersCount(); [EOL]     if (count < 2) { [EOL]         fail("Should have at least 2 cached serializers, got " + count); [EOL]     } [EOL]     prov.flushCachedSerializers(); [EOL]     assertEquals(0, prov.cachedSerializersCount()); [EOL] }
public void testProviderConfig() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     DefaultSerializerProvider prov = (DefaultSerializerProvider) mapper.getSerializerProvider(); [EOL]     assertEquals(0, prov.cachedSerializersCount()); [EOL]     Map<String, Object> result = this.writeAndMap(mapper, new AnnoBean()); [EOL]     assertEquals(2, result.size()); [EOL]     assertEquals(Integer.valueOf(1), result.get("x")); [EOL]     assertEquals(Integer.valueOf(2), result.get("y")); [EOL]     int count = prov.cachedSerializersCount(); [EOL]     if (count < 2) { [EOL]         fail("Should have at least 2 cached serializers, got " + count); [EOL]     } [EOL]     prov.flushCachedSerializers(); [EOL]     assertEquals(0, prov.cachedSerializersCount()); [EOL] }
public void testProviderConfig() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     DefaultSerializerProvider prov = (DefaultSerializerProvider) mapper.getSerializerProvider(); [EOL]     assertEquals(0, prov.cachedSerializersCount()); [EOL]     Map<String, Object> result = this.writeAndMap(mapper, new AnnoBean()); [EOL]     assertEquals(2, result.size()); [EOL]     assertEquals(Integer.valueOf(1), result.get("x")); [EOL]     assertEquals(Integer.valueOf(2), result.get("y")); [EOL]     int count = prov.cachedSerializersCount(); [EOL]     if (count < 2) { [EOL]         fail("Should have at least 2 cached serializers, got " + count); [EOL]     } [EOL]     prov.flushCachedSerializers(); [EOL]     assertEquals(0, prov.cachedSerializersCount()); [EOL] }
public void testForConstructor() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(BaseClassWithPrivateCtor.class, MixInForPrivate.class); [EOL]     BaseClassWithPrivateCtor result = m.readValue("\"?\"", BaseClassWithPrivateCtor.class); [EOL]     assertEquals("?...", result._a); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testSimpleUnwrappedDeserialize() throws Exception { [EOL]     Unwrapping bean = mapper.readValue("{\"name\":\"Tatu\",\"y\":7,\"x\":-13}", Unwrapping.class); [EOL]     assertEquals("Tatu", bean.name); [EOL]     Location loc = bean.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(-13, loc.x); [EOL]     assertEquals(7, loc.y); [EOL] }
public void testSimpleUnwrappedDeserialize() throws Exception { [EOL]     Unwrapping bean = mapper.readValue("{\"name\":\"Tatu\",\"y\":7,\"x\":-13}", Unwrapping.class); [EOL]     assertEquals("Tatu", bean.name); [EOL]     Location loc = bean.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(-13, loc.x); [EOL]     assertEquals(7, loc.y); [EOL] }
public void testSimpleUnwrappedDeserialize() throws Exception { [EOL]     Unwrapping bean = mapper.readValue("{\"name\":\"Tatu\",\"y\":7,\"x\":-13}", Unwrapping.class); [EOL]     assertEquals("Tatu", bean.name); [EOL]     Location loc = bean.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(-13, loc.x); [EOL]     assertEquals(7, loc.y); [EOL] }
public void testSimpleUnwrappedDeserialize() throws Exception { [EOL]     Unwrapping bean = mapper.readValue("{\"name\":\"Tatu\",\"y\":7,\"x\":-13}", Unwrapping.class); [EOL]     assertEquals("Tatu", bean.name); [EOL]     Location loc = bean.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(-13, loc.x); [EOL]     assertEquals(7, loc.y); [EOL] }
public void testSimpleUnwrappedDeserialize() throws Exception { [EOL]     Unwrapping bean = mapper.readValue("{\"name\":\"Tatu\",\"y\":7,\"x\":-13}", Unwrapping.class); [EOL]     assertEquals("Tatu", bean.name); [EOL]     Location loc = bean.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(-13, loc.x); [EOL]     assertEquals(7, loc.y); [EOL] }
public void testSimpleUnwrappedDeserialize() throws Exception { [EOL]     Unwrapping bean = mapper.readValue("{\"name\":\"Tatu\",\"y\":7,\"x\":-13}", Unwrapping.class); [EOL]     assertEquals("Tatu", bean.name); [EOL]     Location loc = bean.location; [EOL]     assertNotNull(loc); [EOL]     assertEquals(-13, loc.x); [EOL]     assertEquals(7, loc.y); [EOL] }
public void testIntArrayToX() throws Exception { [EOL]     int[] data = ints(); [EOL]     verifyIntArrayConversion(data, byte[].class); [EOL]     verifyIntArrayConversion(data, short[].class); [EOL]     verifyIntArrayConversion(data, long[].class); [EOL]     List<Number> expNums = _numberList(data, data.length); [EOL]     List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() { [EOL]     }); [EOL]     assertEquals(expNums, actNums); [EOL] }
public void testIntArrayToX() throws Exception { [EOL]     int[] data = ints(); [EOL]     verifyIntArrayConversion(data, byte[].class); [EOL]     verifyIntArrayConversion(data, short[].class); [EOL]     verifyIntArrayConversion(data, long[].class); [EOL]     List<Number> expNums = _numberList(data, data.length); [EOL]     List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() { [EOL]     }); [EOL]     assertEquals(expNums, actNums); [EOL] }
public void testIntArrayToX() throws Exception { [EOL]     int[] data = ints(); [EOL]     verifyIntArrayConversion(data, byte[].class); [EOL]     verifyIntArrayConversion(data, short[].class); [EOL]     verifyIntArrayConversion(data, long[].class); [EOL]     List<Number> expNums = _numberList(data, data.length); [EOL]     List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() { [EOL]     }); [EOL]     assertEquals(expNums, actNums); [EOL] }
public void testIntArrayToX() throws Exception { [EOL]     int[] data = ints(); [EOL]     verifyIntArrayConversion(data, byte[].class); [EOL]     verifyIntArrayConversion(data, short[].class); [EOL]     verifyIntArrayConversion(data, long[].class); [EOL]     List<Number> expNums = _numberList(data, data.length); [EOL]     List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() { [EOL]     }); [EOL]     assertEquals(expNums, actNums); [EOL] }
public void testIntArrayToX() throws Exception { [EOL]     int[] data = ints(); [EOL]     verifyIntArrayConversion(data, byte[].class); [EOL]     verifyIntArrayConversion(data, short[].class); [EOL]     verifyIntArrayConversion(data, long[].class); [EOL]     List<Number> expNums = _numberList(data, data.length); [EOL]     List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() { [EOL]     }); [EOL]     assertEquals(expNums, actNums); [EOL] }
public void testIntArrayToX() throws Exception { [EOL]     int[] data = ints(); [EOL]     verifyIntArrayConversion(data, byte[].class); [EOL]     verifyIntArrayConversion(data, short[].class); [EOL]     verifyIntArrayConversion(data, long[].class); [EOL]     List<Number> expNums = _numberList(data, data.length); [EOL]     List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() { [EOL]     }); [EOL]     assertEquals(expNums, actNums); [EOL] }
public void testIntArrayToX() throws Exception { [EOL]     int[] data = ints(); [EOL]     verifyIntArrayConversion(data, byte[].class); [EOL]     verifyIntArrayConversion(data, short[].class); [EOL]     verifyIntArrayConversion(data, long[].class); [EOL]     List<Number> expNums = _numberList(data, data.length); [EOL]     List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() { [EOL]     }); [EOL]     assertEquals(expNums, actNums); [EOL] }
public void testIntArrayToX() throws Exception { [EOL]     int[] data = ints(); [EOL]     verifyIntArrayConversion(data, byte[].class); [EOL]     verifyIntArrayConversion(data, short[].class); [EOL]     verifyIntArrayConversion(data, long[].class); [EOL]     List<Number> expNums = _numberList(data, data.length); [EOL]     List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() { [EOL]     }); [EOL]     assertEquals(expNums, actNums); [EOL] }
public void testIntArrayToX() throws Exception { [EOL]     int[] data = ints(); [EOL]     verifyIntArrayConversion(data, byte[].class); [EOL]     verifyIntArrayConversion(data, short[].class); [EOL]     verifyIntArrayConversion(data, long[].class); [EOL]     List<Number> expNums = _numberList(data, data.length); [EOL]     List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() { [EOL]     }); [EOL]     assertEquals(expNums, actNums); [EOL] }
public void testCharArray() throws Exception { [EOL]     final String TEST_STR = "Let's just test it? Ok!"; [EOL]     char[] result = MAPPER.readValue("\"" + TEST_STR + "\"", char[].class); [EOL]     assertEquals(TEST_STR, new String(result)); [EOL]     result = MAPPER.readValue("[\"a\",\"b\",\"c\"]", char[].class); [EOL]     assertEquals("abc", new String(result)); [EOL] }
public void testCharArray() throws Exception { [EOL]     final String TEST_STR = "Let's just test it? Ok!"; [EOL]     char[] result = MAPPER.readValue("\"" + TEST_STR + "\"", char[].class); [EOL]     assertEquals(TEST_STR, new String(result)); [EOL]     result = MAPPER.readValue("[\"a\",\"b\",\"c\"]", char[].class); [EOL]     assertEquals("abc", new String(result)); [EOL] }
public void testCharArray() throws Exception { [EOL]     final String TEST_STR = "Let's just test it? Ok!"; [EOL]     char[] result = MAPPER.readValue("\"" + TEST_STR + "\"", char[].class); [EOL]     assertEquals(TEST_STR, new String(result)); [EOL]     result = MAPPER.readValue("[\"a\",\"b\",\"c\"]", char[].class); [EOL]     assertEquals("abc", new String(result)); [EOL] }
public void testCharArray() throws Exception { [EOL]     final String TEST_STR = "Let's just test it? Ok!"; [EOL]     char[] result = MAPPER.readValue("\"" + TEST_STR + "\"", char[].class); [EOL]     assertEquals(TEST_STR, new String(result)); [EOL]     result = MAPPER.readValue("[\"a\",\"b\",\"c\"]", char[].class); [EOL]     assertEquals("abc", new String(result)); [EOL] }
public void testCharArray() throws Exception { [EOL]     final String TEST_STR = "Let's just test it? Ok!"; [EOL]     char[] result = MAPPER.readValue("\"" + TEST_STR + "\"", char[].class); [EOL]     assertEquals(TEST_STR, new String(result)); [EOL]     result = MAPPER.readValue("[\"a\",\"b\",\"c\"]", char[].class); [EOL]     assertEquals("abc", new String(result)); [EOL] }
public void testCharArray() throws Exception { [EOL]     final String TEST_STR = "Let's just test it? Ok!"; [EOL]     char[] result = MAPPER.readValue("\"" + TEST_STR + "\"", char[].class); [EOL]     assertEquals(TEST_STR, new String(result)); [EOL]     result = MAPPER.readValue("[\"a\",\"b\",\"c\"]", char[].class); [EOL]     assertEquals("abc", new String(result)); [EOL] }
public void testCharArray() throws Exception { [EOL]     final String TEST_STR = "Let's just test it? Ok!"; [EOL]     char[] result = MAPPER.readValue("\"" + TEST_STR + "\"", char[].class); [EOL]     assertEquals(TEST_STR, new String(result)); [EOL]     result = MAPPER.readValue("[\"a\",\"b\",\"c\"]", char[].class); [EOL]     assertEquals("abc", new String(result)); [EOL] }
public void testCharArray() throws Exception { [EOL]     final String TEST_STR = "Let's just test it? Ok!"; [EOL]     char[] result = MAPPER.readValue("\"" + TEST_STR + "\"", char[].class); [EOL]     assertEquals(TEST_STR, new String(result)); [EOL]     result = MAPPER.readValue("[\"a\",\"b\",\"c\"]", char[].class); [EOL]     assertEquals("abc", new String(result)); [EOL] }
public void testCharArray() throws Exception { [EOL]     final String TEST_STR = "Let's just test it? Ok!"; [EOL]     char[] result = MAPPER.readValue("\"" + TEST_STR + "\"", char[].class); [EOL]     assertEquals(TEST_STR, new String(result)); [EOL]     result = MAPPER.readValue("[\"a\",\"b\",\"c\"]", char[].class); [EOL]     assertEquals("abc", new String(result)); [EOL] }
public void testCharArray() throws Exception { [EOL]     final String TEST_STR = "Let's just test it? Ok!"; [EOL]     char[] result = MAPPER.readValue("\"" + TEST_STR + "\"", char[].class); [EOL]     assertEquals(TEST_STR, new String(result)); [EOL]     result = MAPPER.readValue("[\"a\",\"b\",\"c\"]", char[].class); [EOL]     assertEquals("abc", new String(result)); [EOL] }
public void testIntArrayToX() throws Exception { [EOL]     int[] data = ints(); [EOL]     verifyIntArrayConversion(data, byte[].class); [EOL]     verifyIntArrayConversion(data, short[].class); [EOL]     verifyIntArrayConversion(data, long[].class); [EOL]     List<Number> expNums = _numberList(data, data.length); [EOL]     List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() { [EOL]     }); [EOL]     assertEquals(expNums, actNums); [EOL] }
public void testIntArrayToX() throws Exception { [EOL]     int[] data = ints(); [EOL]     verifyIntArrayConversion(data, byte[].class); [EOL]     verifyIntArrayConversion(data, short[].class); [EOL]     verifyIntArrayConversion(data, long[].class); [EOL]     List<Number> expNums = _numberList(data, data.length); [EOL]     List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() { [EOL]     }); [EOL]     assertEquals(expNums, actNums); [EOL] }
public void testIntArrayToX() throws Exception { [EOL]     int[] data = ints(); [EOL]     verifyIntArrayConversion(data, byte[].class); [EOL]     verifyIntArrayConversion(data, short[].class); [EOL]     verifyIntArrayConversion(data, long[].class); [EOL]     List<Number> expNums = _numberList(data, data.length); [EOL]     List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() { [EOL]     }); [EOL]     assertEquals(expNums, actNums); [EOL] }
public void testIntArrayToX() throws Exception { [EOL]     int[] data = ints(); [EOL]     verifyIntArrayConversion(data, byte[].class); [EOL]     verifyIntArrayConversion(data, short[].class); [EOL]     verifyIntArrayConversion(data, long[].class); [EOL]     List<Number> expNums = _numberList(data, data.length); [EOL]     List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() { [EOL]     }); [EOL]     assertEquals(expNums, actNums); [EOL] }
public void testIntArrayToX() throws Exception { [EOL]     int[] data = ints(); [EOL]     verifyIntArrayConversion(data, byte[].class); [EOL]     verifyIntArrayConversion(data, short[].class); [EOL]     verifyIntArrayConversion(data, long[].class); [EOL]     List<Number> expNums = _numberList(data, data.length); [EOL]     List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() { [EOL]     }); [EOL]     assertEquals(expNums, actNums); [EOL] }
public void testIntArrayToX() throws Exception { [EOL]     int[] data = ints(); [EOL]     verifyIntArrayConversion(data, byte[].class); [EOL]     verifyIntArrayConversion(data, short[].class); [EOL]     verifyIntArrayConversion(data, long[].class); [EOL]     List<Number> expNums = _numberList(data, data.length); [EOL]     List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() { [EOL]     }); [EOL]     assertEquals(expNums, actNums); [EOL] }
public void testIntArrayToX() throws Exception { [EOL]     int[] data = ints(); [EOL]     verifyIntArrayConversion(data, byte[].class); [EOL]     verifyIntArrayConversion(data, short[].class); [EOL]     verifyIntArrayConversion(data, long[].class); [EOL]     List<Number> expNums = _numberList(data, data.length); [EOL]     List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() { [EOL]     }); [EOL]     assertEquals(expNums, actNums); [EOL] }
public void testIntArrayToX() throws Exception { [EOL]     int[] data = ints(); [EOL]     verifyIntArrayConversion(data, byte[].class); [EOL]     verifyIntArrayConversion(data, short[].class); [EOL]     verifyIntArrayConversion(data, long[].class); [EOL]     List<Number> expNums = _numberList(data, data.length); [EOL]     List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() { [EOL]     }); [EOL]     assertEquals(expNums, actNums); [EOL] }
public void testIntArrayToX() throws Exception { [EOL]     int[] data = ints(); [EOL]     verifyIntArrayConversion(data, byte[].class); [EOL]     verifyIntArrayConversion(data, short[].class); [EOL]     verifyIntArrayConversion(data, long[].class); [EOL]     List<Number> expNums = _numberList(data, data.length); [EOL]     List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() { [EOL]     }); [EOL]     assertEquals(expNums, actNums); [EOL] }
public void testIntArrayToX() throws Exception { [EOL]     int[] data = ints(); [EOL]     verifyIntArrayConversion(data, byte[].class); [EOL]     verifyIntArrayConversion(data, short[].class); [EOL]     verifyIntArrayConversion(data, long[].class); [EOL]     List<Number> expNums = _numberList(data, data.length); [EOL]     List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() { [EOL]     }); [EOL]     assertEquals(expNums, actNums); [EOL] }
public void testIntArrayToX() throws Exception { [EOL]     int[] data = ints(); [EOL]     verifyIntArrayConversion(data, byte[].class); [EOL]     verifyIntArrayConversion(data, short[].class); [EOL]     verifyIntArrayConversion(data, long[].class); [EOL]     List<Number> expNums = _numberList(data, data.length); [EOL]     List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() { [EOL]     }); [EOL]     assertEquals(expNums, actNums); [EOL] }
public void testIntArrayToX() throws Exception { [EOL]     int[] data = ints(); [EOL]     verifyIntArrayConversion(data, byte[].class); [EOL]     verifyIntArrayConversion(data, short[].class); [EOL]     verifyIntArrayConversion(data, long[].class); [EOL]     List<Number> expNums = _numberList(data, data.length); [EOL]     List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() { [EOL]     }); [EOL]     assertEquals(expNums, actNums); [EOL] }
public void testIntArrayToX() throws Exception { [EOL]     int[] data = ints(); [EOL]     verifyIntArrayConversion(data, byte[].class); [EOL]     verifyIntArrayConversion(data, short[].class); [EOL]     verifyIntArrayConversion(data, long[].class); [EOL]     List<Number> expNums = _numberList(data, data.length); [EOL]     List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() { [EOL]     }); [EOL]     assertEquals(expNums, actNums); [EOL] }
public void testIntArrayToX() throws Exception { [EOL]     int[] data = ints(); [EOL]     verifyIntArrayConversion(data, byte[].class); [EOL]     verifyIntArrayConversion(data, short[].class); [EOL]     verifyIntArrayConversion(data, long[].class); [EOL]     List<Number> expNums = _numberList(data, data.length); [EOL]     List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() { [EOL]     }); [EOL]     assertEquals(expNums, actNums); [EOL] }
public void testIntArrayToX() throws Exception { [EOL]     int[] data = ints(); [EOL]     verifyIntArrayConversion(data, byte[].class); [EOL]     verifyIntArrayConversion(data, short[].class); [EOL]     verifyIntArrayConversion(data, long[].class); [EOL]     List<Number> expNums = _numberList(data, data.length); [EOL]     List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() { [EOL]     }); [EOL]     assertEquals(expNums, actNums); [EOL] }
public void testIntArrayToX() throws Exception { [EOL]     int[] data = ints(); [EOL]     verifyIntArrayConversion(data, byte[].class); [EOL]     verifyIntArrayConversion(data, short[].class); [EOL]     verifyIntArrayConversion(data, long[].class); [EOL]     List<Number> expNums = _numberList(data, data.length); [EOL]     List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() { [EOL]     }); [EOL]     assertEquals(expNums, actNums); [EOL] }
public void testIntArrayToX() throws Exception { [EOL]     int[] data = ints(); [EOL]     verifyIntArrayConversion(data, byte[].class); [EOL]     verifyIntArrayConversion(data, short[].class); [EOL]     verifyIntArrayConversion(data, long[].class); [EOL]     List<Number> expNums = _numberList(data, data.length); [EOL]     List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() { [EOL]     }); [EOL]     assertEquals(expNums, actNums); [EOL] }
public void testDoublePrimitiveNonNumeric() throws Exception { [EOL]     double value = Double.POSITIVE_INFINITY; [EOL]     DoubleBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), DoubleBean.class); [EOL]     assertEquals(value, result._v); [EOL]     double[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), double[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Double.POSITIVE_INFINITY, array[0]); [EOL] }
public void testDoublePrimitiveNonNumeric() throws Exception { [EOL]     double value = Double.POSITIVE_INFINITY; [EOL]     DoubleBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), DoubleBean.class); [EOL]     assertEquals(value, result._v); [EOL]     double[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), double[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Double.POSITIVE_INFINITY, array[0]); [EOL] }
public void testDoublePrimitiveNonNumeric() throws Exception { [EOL]     double value = Double.POSITIVE_INFINITY; [EOL]     DoubleBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), DoubleBean.class); [EOL]     assertEquals(value, result._v); [EOL]     double[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), double[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Double.POSITIVE_INFINITY, array[0]); [EOL] }
public void testDoublePrimitiveNonNumeric() throws Exception { [EOL]     double value = Double.POSITIVE_INFINITY; [EOL]     DoubleBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), DoubleBean.class); [EOL]     assertEquals(value, result._v); [EOL]     double[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), double[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Double.POSITIVE_INFINITY, array[0]); [EOL] }
public void testDoublePrimitiveNonNumeric() throws Exception { [EOL]     double value = Double.POSITIVE_INFINITY; [EOL]     DoubleBean result = MAPPER.readValue(new StringReader("{\"v\":\"" + value + "\"}"), DoubleBean.class); [EOL]     assertEquals(value, result._v); [EOL]     double[] array = MAPPER.readValue(new StringReader("[ \"Infinity\" ]"), double[].class); [EOL]     assertNotNull(array); [EOL]     assertEquals(1, array.length); [EOL]     assertEquals(Double.POSITIVE_INFINITY, array[0]); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testUsesDeserializersNullValue() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new TestModule()); [EOL]     Container container = mapper.readValue("{}", Container.class); [EOL]     assertEquals(NULL_CONTAINED, container.contained); [EOL] }
public void testUsesDeserializersNullValue() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new TestModule()); [EOL]     Container container = mapper.readValue("{}", Container.class); [EOL]     assertEquals(NULL_CONTAINED, container.contained); [EOL] }
public void testUsesDeserializersNullValue() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new TestModule()); [EOL]     Container container = mapper.readValue("{}", Container.class); [EOL]     assertEquals(NULL_CONTAINED, container.contained); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testJackson387() throws Exception { [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY); [EOL]     om.setSerializationInclusion(JsonInclude.Include.NON_NULL); [EOL]     om.enable(SerializationFeature.INDENT_OUTPUT); [EOL]     MyClass mc = new MyClass(); [EOL]     MyParam<Integer> moc1 = new MyParam<Integer>(1); [EOL]     MyParam<String> moc2 = new MyParam<String>("valueX"); [EOL]     SomeObject so = new SomeObject(); [EOL]     so.someValue = "xxxxxx"; [EOL]     MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so); [EOL]     List<SomeObject> colist = new ArrayList<SomeObject>(); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     colist.add(new SomeObject()); [EOL]     MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist); [EOL]     mc.params.add(moc1); [EOL]     mc.params.add(moc2); [EOL]     mc.params.add(moc3); [EOL]     mc.params.add(moc4); [EOL]     String json = om.writeValueAsString(mc); [EOL]     MyClass mc2 = om.readValue(json, MyClass.class); [EOL]     assertNotNull(mc2); [EOL]     assertNotNull(mc2.params); [EOL]     assertEquals(4, mc2.params.size()); [EOL] }
public void testTypeIdFromArray() throws Exception { [EOL]     assertEquals("[\"SomeType\",{\"a\":3}]", mapper.writeValueAsString(new TypeIdFromFieldArray())); [EOL] }
public void testTypeIdFromArray() throws Exception { [EOL]     assertEquals("[\"SomeType\",{\"a\":3}]", mapper.writeValueAsString(new TypeIdFromFieldArray())); [EOL] }
public void testGeneratingJsonSchema() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class); [EOL]     assertNotNull(jsonSchema); [EOL]     assertTrue(jsonSchema.equals(jsonSchema)); [EOL]     assertFalse(jsonSchema.equals(null)); [EOL]     assertFalse(jsonSchema.equals("foo")); [EOL]     assertNotNull(jsonSchema.toString()); [EOL]     assertNotNull(JsonSchema.getDefaultSchemaNode()); [EOL]     ObjectNode root = jsonSchema.getSchemaNode(); [EOL]     assertEquals("object", root.get("type").asText()); [EOL]     assertEquals(false, root.path("required").booleanValue()); [EOL]     JsonNode propertiesSchema = root.get("properties"); [EOL]     assertNotNull(propertiesSchema); [EOL]     JsonNode property1Schema = propertiesSchema.get("property1"); [EOL]     assertNotNull(property1Schema); [EOL]     assertEquals("integer", property1Schema.get("type").asText()); [EOL]     assertEquals(false, property1Schema.path("required").booleanValue()); [EOL]     JsonNode property2Schema = propertiesSchema.get("property2"); [EOL]     assertNotNull(property2Schema); [EOL]     assertEquals("string", property2Schema.get("type").asText()); [EOL]     assertEquals(false, property2Schema.path("required").booleanValue()); [EOL]     JsonNode property3Schema = propertiesSchema.get("property3"); [EOL]     assertNotNull(property3Schema); [EOL]     assertEquals("array", property3Schema.get("type").asText()); [EOL]     assertEquals(false, property3Schema.path("required").booleanValue()); [EOL]     assertEquals("string", property3Schema.get("items").get("type").asText()); [EOL]     JsonNode property4Schema = propertiesSchema.get("property4"); [EOL]     assertNotNull(property4Schema); [EOL]     assertEquals("array", property4Schema.get("type").asText()); [EOL]     assertEquals(false, property4Schema.path("required").booleanValue()); [EOL]     assertEquals("number", property4Schema.get("items").get("type").asText()); [EOL] }
public void testGeneratingJsonSchema() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class); [EOL]     assertNotNull(jsonSchema); [EOL]     assertTrue(jsonSchema.equals(jsonSchema)); [EOL]     assertFalse(jsonSchema.equals(null)); [EOL]     assertFalse(jsonSchema.equals("foo")); [EOL]     assertNotNull(jsonSchema.toString()); [EOL]     assertNotNull(JsonSchema.getDefaultSchemaNode()); [EOL]     ObjectNode root = jsonSchema.getSchemaNode(); [EOL]     assertEquals("object", root.get("type").asText()); [EOL]     assertEquals(false, root.path("required").booleanValue()); [EOL]     JsonNode propertiesSchema = root.get("properties"); [EOL]     assertNotNull(propertiesSchema); [EOL]     JsonNode property1Schema = propertiesSchema.get("property1"); [EOL]     assertNotNull(property1Schema); [EOL]     assertEquals("integer", property1Schema.get("type").asText()); [EOL]     assertEquals(false, property1Schema.path("required").booleanValue()); [EOL]     JsonNode property2Schema = propertiesSchema.get("property2"); [EOL]     assertNotNull(property2Schema); [EOL]     assertEquals("string", property2Schema.get("type").asText()); [EOL]     assertEquals(false, property2Schema.path("required").booleanValue()); [EOL]     JsonNode property3Schema = propertiesSchema.get("property3"); [EOL]     assertNotNull(property3Schema); [EOL]     assertEquals("array", property3Schema.get("type").asText()); [EOL]     assertEquals(false, property3Schema.path("required").booleanValue()); [EOL]     assertEquals("string", property3Schema.get("items").get("type").asText()); [EOL]     JsonNode property4Schema = propertiesSchema.get("property4"); [EOL]     assertNotNull(property4Schema); [EOL]     assertEquals("array", property4Schema.get("type").asText()); [EOL]     assertEquals(false, property4Schema.path("required").booleanValue()); [EOL]     assertEquals("number", property4Schema.get("items").get("type").asText()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testListContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     ListBean result = m.readValue(" { \"values\" : [ 1, 2, 3 ] } ", ListBean.class); [EOL]     assertNotNull(result); [EOL]     List<Object> obs = result.values; [EOL]     assertNotNull(obs); [EOL]     assertEquals(3, obs.size()); [EOL]     assertEquals(ValueClass.class, obs.get(0).getClass()); [EOL]     assertEquals(1, ((ValueClass) obs.get(0))._a); [EOL]     assertEquals(ValueClass.class, obs.get(1).getClass()); [EOL]     assertEquals(2, ((ValueClass) obs.get(1))._a); [EOL]     assertEquals(ValueClass.class, obs.get(2).getClass()); [EOL]     assertEquals(3, ((ValueClass) obs.get(2))._a); [EOL] }
public void testListContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     ListBean result = m.readValue(" { \"values\" : [ 1, 2, 3 ] } ", ListBean.class); [EOL]     assertNotNull(result); [EOL]     List<Object> obs = result.values; [EOL]     assertNotNull(obs); [EOL]     assertEquals(3, obs.size()); [EOL]     assertEquals(ValueClass.class, obs.get(0).getClass()); [EOL]     assertEquals(1, ((ValueClass) obs.get(0))._a); [EOL]     assertEquals(ValueClass.class, obs.get(1).getClass()); [EOL]     assertEquals(2, ((ValueClass) obs.get(1))._a); [EOL]     assertEquals(ValueClass.class, obs.get(2).getClass()); [EOL]     assertEquals(3, ((ValueClass) obs.get(2))._a); [EOL] }
public void testAbstract368() throws Exception { [EOL]     AbstractNode parent = new ConcreteNode("p"); [EOL]     AbstractNode child = new ConcreteNode("c"); [EOL]     parent.next = child; [EOL]     child.prev = parent; [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(parent); [EOL]     AbstractNode root = mapper.readValue(json, AbstractNode.class); [EOL]     assertEquals(ConcreteNode.class, root.getClass()); [EOL]     assertEquals("p", root.id); [EOL]     assertNull(root.prev); [EOL]     AbstractNode leaf = root.next; [EOL]     assertNotNull(leaf); [EOL]     assertEquals("c", leaf.id); [EOL]     assertSame(root, leaf.prev); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testWithCreatorsShuffled() throws Exception { [EOL]     CreatorAsArrayShuffled input = new CreatorAsArrayShuffled(3, 4); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     String json = MAPPER.writeValueAsString(input); [EOL]     assertEquals("[1,2,3,4]", json); [EOL]     CreatorAsArrayShuffled output = MAPPER.readValue(json, CreatorAsArrayShuffled.class); [EOL]     assertEquals(1, output.a); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(3, output.x); [EOL]     assertEquals(4, output.y); [EOL] }
public void testWithCreatorsShuffled() throws Exception { [EOL]     CreatorAsArrayShuffled input = new CreatorAsArrayShuffled(3, 4); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     String json = MAPPER.writeValueAsString(input); [EOL]     assertEquals("[1,2,3,4]", json); [EOL]     CreatorAsArrayShuffled output = MAPPER.readValue(json, CreatorAsArrayShuffled.class); [EOL]     assertEquals(1, output.a); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(3, output.x); [EOL]     assertEquals(4, output.y); [EOL] }
public void testWithCreatorsShuffled() throws Exception { [EOL]     CreatorAsArrayShuffled input = new CreatorAsArrayShuffled(3, 4); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     String json = MAPPER.writeValueAsString(input); [EOL]     assertEquals("[1,2,3,4]", json); [EOL]     CreatorAsArrayShuffled output = MAPPER.readValue(json, CreatorAsArrayShuffled.class); [EOL]     assertEquals(1, output.a); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(3, output.x); [EOL]     assertEquals(4, output.y); [EOL] }
public void testWithCreatorsShuffled() throws Exception { [EOL]     CreatorAsArrayShuffled input = new CreatorAsArrayShuffled(3, 4); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     String json = MAPPER.writeValueAsString(input); [EOL]     assertEquals("[1,2,3,4]", json); [EOL]     CreatorAsArrayShuffled output = MAPPER.readValue(json, CreatorAsArrayShuffled.class); [EOL]     assertEquals(1, output.a); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(3, output.x); [EOL]     assertEquals(4, output.y); [EOL] }
public void testWithCreatorsShuffled() throws Exception { [EOL]     CreatorAsArrayShuffled input = new CreatorAsArrayShuffled(3, 4); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     String json = MAPPER.writeValueAsString(input); [EOL]     assertEquals("[1,2,3,4]", json); [EOL]     CreatorAsArrayShuffled output = MAPPER.readValue(json, CreatorAsArrayShuffled.class); [EOL]     assertEquals(1, output.a); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(3, output.x); [EOL]     assertEquals(4, output.y); [EOL] }
public void testWithCreatorsShuffled() throws Exception { [EOL]     CreatorAsArrayShuffled input = new CreatorAsArrayShuffled(3, 4); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     String json = MAPPER.writeValueAsString(input); [EOL]     assertEquals("[1,2,3,4]", json); [EOL]     CreatorAsArrayShuffled output = MAPPER.readValue(json, CreatorAsArrayShuffled.class); [EOL]     assertEquals(1, output.a); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(3, output.x); [EOL]     assertEquals(4, output.y); [EOL] }
public void testWithCreatorsShuffled() throws Exception { [EOL]     CreatorAsArrayShuffled input = new CreatorAsArrayShuffled(3, 4); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     String json = MAPPER.writeValueAsString(input); [EOL]     assertEquals("[1,2,3,4]", json); [EOL]     CreatorAsArrayShuffled output = MAPPER.readValue(json, CreatorAsArrayShuffled.class); [EOL]     assertEquals(1, output.a); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(3, output.x); [EOL]     assertEquals(4, output.y); [EOL] }
public void testWithCreatorsShuffled() throws Exception { [EOL]     CreatorAsArrayShuffled input = new CreatorAsArrayShuffled(3, 4); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     String json = MAPPER.writeValueAsString(input); [EOL]     assertEquals("[1,2,3,4]", json); [EOL]     CreatorAsArrayShuffled output = MAPPER.readValue(json, CreatorAsArrayShuffled.class); [EOL]     assertEquals(1, output.a); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(3, output.x); [EOL]     assertEquals(4, output.y); [EOL] }
public void testWithCreatorsShuffled() throws Exception { [EOL]     CreatorAsArrayShuffled input = new CreatorAsArrayShuffled(3, 4); [EOL]     input.a = 1; [EOL]     input.b = 2; [EOL]     String json = MAPPER.writeValueAsString(input); [EOL]     assertEquals("[1,2,3,4]", json); [EOL]     CreatorAsArrayShuffled output = MAPPER.readValue(json, CreatorAsArrayShuffled.class); [EOL]     assertEquals(1, output.a); [EOL]     assertEquals(2, output.b); [EOL]     assertEquals(3, output.x); [EOL]     assertEquals(4, output.y); [EOL] }
public void testSchemaId() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class); [EOL]     String json = jsonSchema.toString().replaceAll("\"", "'"); [EOL]     assertEquals("{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}", json); [EOL] }
public void testSchemaId() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class); [EOL]     String json = jsonSchema.toString().replaceAll("\"", "'"); [EOL]     assertEquals("{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}", json); [EOL] }
public void testSimpleScalars() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals("callback(\"abc\")", serializeAsString(m, new JSONPObject("callback", "abc"))); [EOL]     assertEquals("calc(123)", serializeAsString(m, new JSONPObject("calc", Integer.valueOf(123)))); [EOL]     assertEquals("dummy(null)", serializeAsString(m, new JSONPObject("dummy", null))); [EOL] }
public void testSimpleScalars() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals("callback(\"abc\")", serializeAsString(m, new JSONPObject("callback", "abc"))); [EOL]     assertEquals("calc(123)", serializeAsString(m, new JSONPObject("calc", Integer.valueOf(123)))); [EOL]     assertEquals("dummy(null)", serializeAsString(m, new JSONPObject("dummy", null))); [EOL] }
public void testSimpleScalars() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals("callback(\"abc\")", serializeAsString(m, new JSONPObject("callback", "abc"))); [EOL]     assertEquals("calc(123)", serializeAsString(m, new JSONPObject("calc", Integer.valueOf(123)))); [EOL]     assertEquals("dummy(null)", serializeAsString(m, new JSONPObject("dummy", null))); [EOL] }
public void testSimpleScalars() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals("callback(\"abc\")", serializeAsString(m, new JSONPObject("callback", "abc"))); [EOL]     assertEquals("calc(123)", serializeAsString(m, new JSONPObject("calc", Integer.valueOf(123)))); [EOL]     assertEquals("dummy(null)", serializeAsString(m, new JSONPObject("dummy", null))); [EOL] }
public void testSimpleScalars() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertEquals("callback(\"abc\")", serializeAsString(m, new JSONPObject("callback", "abc"))); [EOL]     assertEquals("calc(123)", serializeAsString(m, new JSONPObject("calc", Integer.valueOf(123)))); [EOL]     assertEquals("dummy(null)", serializeAsString(m, new JSONPObject("dummy", null))); [EOL] }
public void testTypeIdFromArray() throws Exception { [EOL]     assertEquals("[\"SomeType\",{\"a\":3}]", mapper.writeValueAsString(new TypeIdFromFieldArray())); [EOL] }
public void testTypeIdFromArray() throws Exception { [EOL]     assertEquals("[\"SomeType\",{\"a\":3}]", mapper.writeValueAsString(new TypeIdFromFieldArray())); [EOL] }
public void testTypeIdFromArray() throws Exception { [EOL]     assertEquals("[\"SomeType\",{\"a\":3}]", mapper.writeValueAsString(new TypeIdFromFieldArray())); [EOL] }
public void testTypeIdFromArray() throws Exception { [EOL]     assertEquals("[\"SomeType\",{\"a\":3}]", mapper.writeValueAsString(new TypeIdFromFieldArray())); [EOL] }
public void testTypeIdFromArray() throws Exception { [EOL]     assertEquals("[\"SomeType\",{\"a\":3}]", mapper.writeValueAsString(new TypeIdFromFieldArray())); [EOL] }
public void testTypeIdFromArray() throws Exception { [EOL]     assertEquals("[\"SomeType\",{\"a\":3}]", mapper.writeValueAsString(new TypeIdFromFieldArray())); [EOL] }
public void testEmptyStringForPrimitives() throws IOException { [EOL]     PrimitivesBean bean; [EOL]     bean = mapper.readValue("{\"booleanValue\":\"\"}", PrimitivesBean.class); [EOL]     assertFalse(bean.booleanValue); [EOL]     bean = mapper.readValue("{\"byteValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     bean = mapper.readValue("{\"charValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((char) 0, bean.charValue); [EOL]     bean = mapper.readValue("{\"shortValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((short) 0, bean.shortValue); [EOL]     bean = mapper.readValue("{\"intValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0, bean.intValue); [EOL]     bean = mapper.readValue("{\"longValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0L, bean.longValue); [EOL]     bean = mapper.readValue("{\"floatValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     bean = mapper.readValue("{\"doubleValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL] }
public void testEmptyStringForPrimitives() throws IOException { [EOL]     PrimitivesBean bean; [EOL]     bean = mapper.readValue("{\"booleanValue\":\"\"}", PrimitivesBean.class); [EOL]     assertFalse(bean.booleanValue); [EOL]     bean = mapper.readValue("{\"byteValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     bean = mapper.readValue("{\"charValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((char) 0, bean.charValue); [EOL]     bean = mapper.readValue("{\"shortValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((short) 0, bean.shortValue); [EOL]     bean = mapper.readValue("{\"intValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0, bean.intValue); [EOL]     bean = mapper.readValue("{\"longValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0L, bean.longValue); [EOL]     bean = mapper.readValue("{\"floatValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     bean = mapper.readValue("{\"doubleValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL] }
public void testEmptyStringForPrimitives() throws IOException { [EOL]     PrimitivesBean bean; [EOL]     bean = mapper.readValue("{\"booleanValue\":\"\"}", PrimitivesBean.class); [EOL]     assertFalse(bean.booleanValue); [EOL]     bean = mapper.readValue("{\"byteValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     bean = mapper.readValue("{\"charValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((char) 0, bean.charValue); [EOL]     bean = mapper.readValue("{\"shortValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((short) 0, bean.shortValue); [EOL]     bean = mapper.readValue("{\"intValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0, bean.intValue); [EOL]     bean = mapper.readValue("{\"longValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0L, bean.longValue); [EOL]     bean = mapper.readValue("{\"floatValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     bean = mapper.readValue("{\"doubleValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL] }
public void testEmptyStringForPrimitives() throws IOException { [EOL]     PrimitivesBean bean; [EOL]     bean = mapper.readValue("{\"booleanValue\":\"\"}", PrimitivesBean.class); [EOL]     assertFalse(bean.booleanValue); [EOL]     bean = mapper.readValue("{\"byteValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     bean = mapper.readValue("{\"charValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((char) 0, bean.charValue); [EOL]     bean = mapper.readValue("{\"shortValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((short) 0, bean.shortValue); [EOL]     bean = mapper.readValue("{\"intValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0, bean.intValue); [EOL]     bean = mapper.readValue("{\"longValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0L, bean.longValue); [EOL]     bean = mapper.readValue("{\"floatValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     bean = mapper.readValue("{\"doubleValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL] }
public void testEmptyStringForPrimitives() throws IOException { [EOL]     PrimitivesBean bean; [EOL]     bean = mapper.readValue("{\"booleanValue\":\"\"}", PrimitivesBean.class); [EOL]     assertFalse(bean.booleanValue); [EOL]     bean = mapper.readValue("{\"byteValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     bean = mapper.readValue("{\"charValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((char) 0, bean.charValue); [EOL]     bean = mapper.readValue("{\"shortValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((short) 0, bean.shortValue); [EOL]     bean = mapper.readValue("{\"intValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0, bean.intValue); [EOL]     bean = mapper.readValue("{\"longValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0L, bean.longValue); [EOL]     bean = mapper.readValue("{\"floatValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     bean = mapper.readValue("{\"doubleValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL] }
public void testEmptyStringForPrimitives() throws IOException { [EOL]     PrimitivesBean bean; [EOL]     bean = mapper.readValue("{\"booleanValue\":\"\"}", PrimitivesBean.class); [EOL]     assertFalse(bean.booleanValue); [EOL]     bean = mapper.readValue("{\"byteValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     bean = mapper.readValue("{\"charValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((char) 0, bean.charValue); [EOL]     bean = mapper.readValue("{\"shortValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((short) 0, bean.shortValue); [EOL]     bean = mapper.readValue("{\"intValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0, bean.intValue); [EOL]     bean = mapper.readValue("{\"longValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0L, bean.longValue); [EOL]     bean = mapper.readValue("{\"floatValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     bean = mapper.readValue("{\"doubleValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL] }
public void testEmptyStringForPrimitives() throws IOException { [EOL]     PrimitivesBean bean; [EOL]     bean = mapper.readValue("{\"booleanValue\":\"\"}", PrimitivesBean.class); [EOL]     assertFalse(bean.booleanValue); [EOL]     bean = mapper.readValue("{\"byteValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     bean = mapper.readValue("{\"charValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((char) 0, bean.charValue); [EOL]     bean = mapper.readValue("{\"shortValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((short) 0, bean.shortValue); [EOL]     bean = mapper.readValue("{\"intValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0, bean.intValue); [EOL]     bean = mapper.readValue("{\"longValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0L, bean.longValue); [EOL]     bean = mapper.readValue("{\"floatValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     bean = mapper.readValue("{\"doubleValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL] }
public void testEmptyStringForPrimitives() throws IOException { [EOL]     PrimitivesBean bean; [EOL]     bean = mapper.readValue("{\"booleanValue\":\"\"}", PrimitivesBean.class); [EOL]     assertFalse(bean.booleanValue); [EOL]     bean = mapper.readValue("{\"byteValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     bean = mapper.readValue("{\"charValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((char) 0, bean.charValue); [EOL]     bean = mapper.readValue("{\"shortValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((short) 0, bean.shortValue); [EOL]     bean = mapper.readValue("{\"intValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0, bean.intValue); [EOL]     bean = mapper.readValue("{\"longValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0L, bean.longValue); [EOL]     bean = mapper.readValue("{\"floatValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     bean = mapper.readValue("{\"doubleValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL] }
public void testEmptyStringForPrimitives() throws IOException { [EOL]     PrimitivesBean bean; [EOL]     bean = mapper.readValue("{\"booleanValue\":\"\"}", PrimitivesBean.class); [EOL]     assertFalse(bean.booleanValue); [EOL]     bean = mapper.readValue("{\"byteValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     bean = mapper.readValue("{\"charValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((char) 0, bean.charValue); [EOL]     bean = mapper.readValue("{\"shortValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((short) 0, bean.shortValue); [EOL]     bean = mapper.readValue("{\"intValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0, bean.intValue); [EOL]     bean = mapper.readValue("{\"longValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0L, bean.longValue); [EOL]     bean = mapper.readValue("{\"floatValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     bean = mapper.readValue("{\"doubleValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL] }
public void testEmptyStringForPrimitives() throws IOException { [EOL]     PrimitivesBean bean; [EOL]     bean = mapper.readValue("{\"booleanValue\":\"\"}", PrimitivesBean.class); [EOL]     assertFalse(bean.booleanValue); [EOL]     bean = mapper.readValue("{\"byteValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     bean = mapper.readValue("{\"charValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((char) 0, bean.charValue); [EOL]     bean = mapper.readValue("{\"shortValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((short) 0, bean.shortValue); [EOL]     bean = mapper.readValue("{\"intValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0, bean.intValue); [EOL]     bean = mapper.readValue("{\"longValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0L, bean.longValue); [EOL]     bean = mapper.readValue("{\"floatValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     bean = mapper.readValue("{\"doubleValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL] }
public void testEmptyStringForPrimitives() throws IOException { [EOL]     PrimitivesBean bean; [EOL]     bean = mapper.readValue("{\"booleanValue\":\"\"}", PrimitivesBean.class); [EOL]     assertFalse(bean.booleanValue); [EOL]     bean = mapper.readValue("{\"byteValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     bean = mapper.readValue("{\"charValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((char) 0, bean.charValue); [EOL]     bean = mapper.readValue("{\"shortValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((short) 0, bean.shortValue); [EOL]     bean = mapper.readValue("{\"intValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0, bean.intValue); [EOL]     bean = mapper.readValue("{\"longValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0L, bean.longValue); [EOL]     bean = mapper.readValue("{\"floatValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     bean = mapper.readValue("{\"doubleValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL] }
public void testEmptyStringForPrimitives() throws IOException { [EOL]     PrimitivesBean bean; [EOL]     bean = mapper.readValue("{\"booleanValue\":\"\"}", PrimitivesBean.class); [EOL]     assertFalse(bean.booleanValue); [EOL]     bean = mapper.readValue("{\"byteValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     bean = mapper.readValue("{\"charValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((char) 0, bean.charValue); [EOL]     bean = mapper.readValue("{\"shortValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((short) 0, bean.shortValue); [EOL]     bean = mapper.readValue("{\"intValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0, bean.intValue); [EOL]     bean = mapper.readValue("{\"longValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0L, bean.longValue); [EOL]     bean = mapper.readValue("{\"floatValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     bean = mapper.readValue("{\"doubleValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL] }
public void testEmptyStringForPrimitives() throws IOException { [EOL]     PrimitivesBean bean; [EOL]     bean = mapper.readValue("{\"booleanValue\":\"\"}", PrimitivesBean.class); [EOL]     assertFalse(bean.booleanValue); [EOL]     bean = mapper.readValue("{\"byteValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     bean = mapper.readValue("{\"charValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((char) 0, bean.charValue); [EOL]     bean = mapper.readValue("{\"shortValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((short) 0, bean.shortValue); [EOL]     bean = mapper.readValue("{\"intValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0, bean.intValue); [EOL]     bean = mapper.readValue("{\"longValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0L, bean.longValue); [EOL]     bean = mapper.readValue("{\"floatValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     bean = mapper.readValue("{\"doubleValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL] }
public void testEmptyStringForPrimitives() throws IOException { [EOL]     PrimitivesBean bean; [EOL]     bean = mapper.readValue("{\"booleanValue\":\"\"}", PrimitivesBean.class); [EOL]     assertFalse(bean.booleanValue); [EOL]     bean = mapper.readValue("{\"byteValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     bean = mapper.readValue("{\"charValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((char) 0, bean.charValue); [EOL]     bean = mapper.readValue("{\"shortValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((short) 0, bean.shortValue); [EOL]     bean = mapper.readValue("{\"intValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0, bean.intValue); [EOL]     bean = mapper.readValue("{\"longValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0L, bean.longValue); [EOL]     bean = mapper.readValue("{\"floatValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     bean = mapper.readValue("{\"doubleValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL] }
public void testEmptyStringForPrimitives() throws IOException { [EOL]     PrimitivesBean bean; [EOL]     bean = mapper.readValue("{\"booleanValue\":\"\"}", PrimitivesBean.class); [EOL]     assertFalse(bean.booleanValue); [EOL]     bean = mapper.readValue("{\"byteValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     bean = mapper.readValue("{\"charValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((char) 0, bean.charValue); [EOL]     bean = mapper.readValue("{\"shortValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((short) 0, bean.shortValue); [EOL]     bean = mapper.readValue("{\"intValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0, bean.intValue); [EOL]     bean = mapper.readValue("{\"longValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0L, bean.longValue); [EOL]     bean = mapper.readValue("{\"floatValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     bean = mapper.readValue("{\"doubleValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL] }
public void testEmptyStringForPrimitives() throws IOException { [EOL]     PrimitivesBean bean; [EOL]     bean = mapper.readValue("{\"booleanValue\":\"\"}", PrimitivesBean.class); [EOL]     assertFalse(bean.booleanValue); [EOL]     bean = mapper.readValue("{\"byteValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     bean = mapper.readValue("{\"charValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((char) 0, bean.charValue); [EOL]     bean = mapper.readValue("{\"shortValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((short) 0, bean.shortValue); [EOL]     bean = mapper.readValue("{\"intValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0, bean.intValue); [EOL]     bean = mapper.readValue("{\"longValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0L, bean.longValue); [EOL]     bean = mapper.readValue("{\"floatValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     bean = mapper.readValue("{\"doubleValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL] }
public void testEmptyStringForPrimitives() throws IOException { [EOL]     PrimitivesBean bean; [EOL]     bean = mapper.readValue("{\"booleanValue\":\"\"}", PrimitivesBean.class); [EOL]     assertFalse(bean.booleanValue); [EOL]     bean = mapper.readValue("{\"byteValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     bean = mapper.readValue("{\"charValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((char) 0, bean.charValue); [EOL]     bean = mapper.readValue("{\"shortValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((short) 0, bean.shortValue); [EOL]     bean = mapper.readValue("{\"intValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0, bean.intValue); [EOL]     bean = mapper.readValue("{\"longValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0L, bean.longValue); [EOL]     bean = mapper.readValue("{\"floatValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     bean = mapper.readValue("{\"doubleValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL] }
public void testEmptyStringForPrimitives() throws IOException { [EOL]     PrimitivesBean bean; [EOL]     bean = mapper.readValue("{\"booleanValue\":\"\"}", PrimitivesBean.class); [EOL]     assertFalse(bean.booleanValue); [EOL]     bean = mapper.readValue("{\"byteValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     bean = mapper.readValue("{\"charValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((char) 0, bean.charValue); [EOL]     bean = mapper.readValue("{\"shortValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((short) 0, bean.shortValue); [EOL]     bean = mapper.readValue("{\"intValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0, bean.intValue); [EOL]     bean = mapper.readValue("{\"longValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0L, bean.longValue); [EOL]     bean = mapper.readValue("{\"floatValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     bean = mapper.readValue("{\"doubleValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL] }
public void testEmptyStringForPrimitives() throws IOException { [EOL]     PrimitivesBean bean; [EOL]     bean = mapper.readValue("{\"booleanValue\":\"\"}", PrimitivesBean.class); [EOL]     assertFalse(bean.booleanValue); [EOL]     bean = mapper.readValue("{\"byteValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     bean = mapper.readValue("{\"charValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((char) 0, bean.charValue); [EOL]     bean = mapper.readValue("{\"shortValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((short) 0, bean.shortValue); [EOL]     bean = mapper.readValue("{\"intValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0, bean.intValue); [EOL]     bean = mapper.readValue("{\"longValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0L, bean.longValue); [EOL]     bean = mapper.readValue("{\"floatValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     bean = mapper.readValue("{\"doubleValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL] }
public void testEmptyStringForPrimitives() throws IOException { [EOL]     PrimitivesBean bean; [EOL]     bean = mapper.readValue("{\"booleanValue\":\"\"}", PrimitivesBean.class); [EOL]     assertFalse(bean.booleanValue); [EOL]     bean = mapper.readValue("{\"byteValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     bean = mapper.readValue("{\"charValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((char) 0, bean.charValue); [EOL]     bean = mapper.readValue("{\"shortValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((short) 0, bean.shortValue); [EOL]     bean = mapper.readValue("{\"intValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0, bean.intValue); [EOL]     bean = mapper.readValue("{\"longValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0L, bean.longValue); [EOL]     bean = mapper.readValue("{\"floatValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     bean = mapper.readValue("{\"doubleValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL] }
public void testEmptyStringForPrimitives() throws IOException { [EOL]     PrimitivesBean bean; [EOL]     bean = mapper.readValue("{\"booleanValue\":\"\"}", PrimitivesBean.class); [EOL]     assertFalse(bean.booleanValue); [EOL]     bean = mapper.readValue("{\"byteValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     bean = mapper.readValue("{\"charValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((char) 0, bean.charValue); [EOL]     bean = mapper.readValue("{\"shortValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals((short) 0, bean.shortValue); [EOL]     bean = mapper.readValue("{\"intValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0, bean.intValue); [EOL]     bean = mapper.readValue("{\"longValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0L, bean.longValue); [EOL]     bean = mapper.readValue("{\"floatValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     bean = mapper.readValue("{\"doubleValue\":\"\"}", PrimitivesBean.class); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL] }
public void testIntTypeOverride() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enable(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS); [EOL]     BigInteger exp = BigInteger.valueOf(123L); [EOL]     Number result = m.readValue(new StringReader(" 123 "), Number.class); [EOL]     assertEquals(BigInteger.class, result.getClass()); [EOL]     assertEquals(exp, result); [EOL]     m.readValue(new StringReader("123"), Object.class); [EOL]     assertEquals(BigInteger.class, result.getClass()); [EOL]     assertEquals(exp, result); [EOL] }
public void testIntTypeOverride() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enable(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS); [EOL]     BigInteger exp = BigInteger.valueOf(123L); [EOL]     Number result = m.readValue(new StringReader(" 123 "), Number.class); [EOL]     assertEquals(BigInteger.class, result.getClass()); [EOL]     assertEquals(exp, result); [EOL]     m.readValue(new StringReader("123"), Object.class); [EOL]     assertEquals(BigInteger.class, result.getClass()); [EOL]     assertEquals(exp, result); [EOL] }
public void testIntTypeOverride() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enable(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS); [EOL]     BigInteger exp = BigInteger.valueOf(123L); [EOL]     Number result = m.readValue(new StringReader(" 123 "), Number.class); [EOL]     assertEquals(BigInteger.class, result.getClass()); [EOL]     assertEquals(exp, result); [EOL]     m.readValue(new StringReader("123"), Object.class); [EOL]     assertEquals(BigInteger.class, result.getClass()); [EOL]     assertEquals(exp, result); [EOL] }
public void testIntTypeOverride() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enable(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS); [EOL]     BigInteger exp = BigInteger.valueOf(123L); [EOL]     Number result = m.readValue(new StringReader(" 123 "), Number.class); [EOL]     assertEquals(BigInteger.class, result.getClass()); [EOL]     assertEquals(exp, result); [EOL]     m.readValue(new StringReader("123"), Object.class); [EOL]     assertEquals(BigInteger.class, result.getClass()); [EOL]     assertEquals(exp, result); [EOL] }
public void testIntTypeOverride() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enable(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS); [EOL]     BigInteger exp = BigInteger.valueOf(123L); [EOL]     Number result = m.readValue(new StringReader(" 123 "), Number.class); [EOL]     assertEquals(BigInteger.class, result.getClass()); [EOL]     assertEquals(exp, result); [EOL]     m.readValue(new StringReader("123"), Object.class); [EOL]     assertEquals(BigInteger.class, result.getClass()); [EOL]     assertEquals(exp, result); [EOL] }
public void testIntTypeOverride() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enable(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS); [EOL]     BigInteger exp = BigInteger.valueOf(123L); [EOL]     Number result = m.readValue(new StringReader(" 123 "), Number.class); [EOL]     assertEquals(BigInteger.class, result.getClass()); [EOL]     assertEquals(exp, result); [EOL]     m.readValue(new StringReader("123"), Object.class); [EOL]     assertEquals(BigInteger.class, result.getClass()); [EOL]     assertEquals(exp, result); [EOL] }
public void testIntTypeOverride() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enable(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS); [EOL]     BigInteger exp = BigInteger.valueOf(123L); [EOL]     Number result = m.readValue(new StringReader(" 123 "), Number.class); [EOL]     assertEquals(BigInteger.class, result.getClass()); [EOL]     assertEquals(exp, result); [EOL]     m.readValue(new StringReader("123"), Object.class); [EOL]     assertEquals(BigInteger.class, result.getClass()); [EOL]     assertEquals(exp, result); [EOL] }
public void testIntTypeOverride() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enable(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS); [EOL]     BigInteger exp = BigInteger.valueOf(123L); [EOL]     Number result = m.readValue(new StringReader(" 123 "), Number.class); [EOL]     assertEquals(BigInteger.class, result.getClass()); [EOL]     assertEquals(exp, result); [EOL]     m.readValue(new StringReader("123"), Object.class); [EOL]     assertEquals(BigInteger.class, result.getClass()); [EOL]     assertEquals(exp, result); [EOL] }
public void testIntTypeOverride() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enable(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS); [EOL]     BigInteger exp = BigInteger.valueOf(123L); [EOL]     Number result = m.readValue(new StringReader(" 123 "), Number.class); [EOL]     assertEquals(BigInteger.class, result.getClass()); [EOL]     assertEquals(exp, result); [EOL]     m.readValue(new StringReader("123"), Object.class); [EOL]     assertEquals(BigInteger.class, result.getClass()); [EOL]     assertEquals(exp, result); [EOL] }
public void testIntTypeOverride() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     m.enable(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS); [EOL]     BigInteger exp = BigInteger.valueOf(123L); [EOL]     Number result = m.readValue(new StringReader(" 123 "), Number.class); [EOL]     assertEquals(BigInteger.class, result.getClass()); [EOL]     assertEquals(exp, result); [EOL]     m.readValue(new StringReader("123"), Object.class); [EOL]     assertEquals(BigInteger.class, result.getClass()); [EOL]     assertEquals(exp, result); [EOL] }
public void testIssue506WithNumber() throws Exception { [EOL]     Issue506NumberBean input = new Issue506NumberBean(); [EOL]     input.number = Long.valueOf(4567L); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(input); [EOL]     Issue506NumberBean output = mapper.readValue(json, Issue506NumberBean.class); [EOL]     assertEquals(input.number, output.number); [EOL] }
public void testIssue506WithNumber() throws Exception { [EOL]     Issue506NumberBean input = new Issue506NumberBean(); [EOL]     input.number = Long.valueOf(4567L); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(input); [EOL]     Issue506NumberBean output = mapper.readValue(json, Issue506NumberBean.class); [EOL]     assertEquals(input.number, output.number); [EOL] }
public void testIssue506WithNumber() throws Exception { [EOL]     Issue506NumberBean input = new Issue506NumberBean(); [EOL]     input.number = Long.valueOf(4567L); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(input); [EOL]     Issue506NumberBean output = mapper.readValue(json, Issue506NumberBean.class); [EOL]     assertEquals(input.number, output.number); [EOL] }
public void testIssue506WithNumber() throws Exception { [EOL]     Issue506NumberBean input = new Issue506NumberBean(); [EOL]     input.number = Long.valueOf(4567L); [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     String json = mapper.writeValueAsString(input); [EOL]     Issue506NumberBean output = mapper.readValue(json, Issue506NumberBean.class); [EOL]     assertEquals(input.number, output.number); [EOL] }
public void testBigInteger() throws Exception { [EOL]     BigInteger value = new BigInteger("-1234567890123456789012345567809"); [EOL]     BigInteger result = MAPPER.readValue(new StringReader(value.toString()), BigInteger.class); [EOL]     assertEquals(value, result); [EOL] }
public void testBigInteger() throws Exception { [EOL]     BigInteger value = new BigInteger("-1234567890123456789012345567809"); [EOL]     BigInteger result = MAPPER.readValue(new StringReader(value.toString()), BigInteger.class); [EOL]     assertEquals(value, result); [EOL] }
public void testBigInteger() throws Exception { [EOL]     BigInteger value = new BigInteger("-1234567890123456789012345567809"); [EOL]     BigInteger result = MAPPER.readValue(new StringReader(value.toString()), BigInteger.class); [EOL]     assertEquals(value, result); [EOL] }
public void testBigInteger() throws Exception { [EOL]     BigInteger value = new BigInteger("-1234567890123456789012345567809"); [EOL]     BigInteger result = MAPPER.readValue(new StringReader(value.toString()), BigInteger.class); [EOL]     assertEquals(value, result); [EOL] }
public void testBigInteger() throws Exception { [EOL]     BigInteger value = new BigInteger("-1234567890123456789012345567809"); [EOL]     BigInteger result = MAPPER.readValue(new StringReader(value.toString()), BigInteger.class); [EOL]     assertEquals(value, result); [EOL] }
public void testBigInteger() throws Exception { [EOL]     BigInteger value = new BigInteger("-1234567890123456789012345567809"); [EOL]     BigInteger result = MAPPER.readValue(new StringReader(value.toString()), BigInteger.class); [EOL]     assertEquals(value, result); [EOL] }
public void testBigInteger() throws Exception { [EOL]     BigInteger value = new BigInteger("-1234567890123456789012345567809"); [EOL]     BigInteger result = MAPPER.readValue(new StringReader(value.toString()), BigInteger.class); [EOL]     assertEquals(value, result); [EOL] }
public void testBigInteger() throws Exception { [EOL]     BigInteger value = new BigInteger("-1234567890123456789012345567809"); [EOL]     BigInteger result = MAPPER.readValue(new StringReader(value.toString()), BigInteger.class); [EOL]     assertEquals(value, result); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testDataBind() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     JsonNode tree = m.readTree("{ \"name\" : \"Tatu\", \n" + "\"magicNumber\" : 42," + "\"kids\" : [ \"Leo\", \"Lila\", \"Leia\" ] \n" + "}"); [EOL]     Person tatu = m.treeToValue(tree, Person.class); [EOL]     assertNotNull(tatu); [EOL]     assertEquals(42, tatu.magicNumber); [EOL]     assertEquals("Tatu", tatu.name); [EOL]     assertNotNull(tatu.kids); [EOL]     assertEquals(3, tatu.kids.size()); [EOL]     assertEquals("Leo", tatu.kids.get(0)); [EOL]     assertEquals("Lila", tatu.kids.get(1)); [EOL]     assertEquals("Leia", tatu.kids.get(2)); [EOL] }
public void testDataBind() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     JsonNode tree = m.readTree("{ \"name\" : \"Tatu\", \n" + "\"magicNumber\" : 42," + "\"kids\" : [ \"Leo\", \"Lila\", \"Leia\" ] \n" + "}"); [EOL]     Person tatu = m.treeToValue(tree, Person.class); [EOL]     assertNotNull(tatu); [EOL]     assertEquals(42, tatu.magicNumber); [EOL]     assertEquals("Tatu", tatu.name); [EOL]     assertNotNull(tatu.kids); [EOL]     assertEquals(3, tatu.kids.size()); [EOL]     assertEquals("Leo", tatu.kids.get(0)); [EOL]     assertEquals("Lila", tatu.kids.get(1)); [EOL]     assertEquals("Leia", tatu.kids.get(2)); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testIssue877() throws Exception { [EOL]     BaseInterfaceImpl one = new BaseInterfaceImpl(); [EOL]     BaseInterfaceImpl two = new BaseInterfaceImpl(); [EOL]     one.addInstance(two); [EOL]     two.addInstance(one); [EOL]     ListWrapper<BaseInterfaceImpl> myList = new ListWrapper<BaseInterfaceImpl>(); [EOL]     myList.add(one); [EOL]     myList.add(two); [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTypingAsProperty(ObjectMapper.DefaultTyping.NON_FINAL, "@class"); [EOL]     String json = om.writerWithDefaultPrettyPrinter().writeValueAsString(myList); [EOL]     ListWrapper<BaseInterfaceImpl> result; [EOL]     result = om.readValue(json, new TypeReference<ListWrapper<BaseInterfaceImpl>>() { [EOL]     }); [EOL]     assertNotNull(result); [EOL]     System.out.println("deserialised list size = " + result.size()); [EOL] }
public void testIssue877() throws Exception { [EOL]     BaseInterfaceImpl one = new BaseInterfaceImpl(); [EOL]     BaseInterfaceImpl two = new BaseInterfaceImpl(); [EOL]     one.addInstance(two); [EOL]     two.addInstance(one); [EOL]     ListWrapper<BaseInterfaceImpl> myList = new ListWrapper<BaseInterfaceImpl>(); [EOL]     myList.add(one); [EOL]     myList.add(two); [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTypingAsProperty(ObjectMapper.DefaultTyping.NON_FINAL, "@class"); [EOL]     String json = om.writerWithDefaultPrettyPrinter().writeValueAsString(myList); [EOL]     ListWrapper<BaseInterfaceImpl> result; [EOL]     result = om.readValue(json, new TypeReference<ListWrapper<BaseInterfaceImpl>>() { [EOL]     }); [EOL]     assertNotNull(result); [EOL]     System.out.println("deserialised list size = " + result.size()); [EOL] }
public void testIssue877() throws Exception { [EOL]     BaseInterfaceImpl one = new BaseInterfaceImpl(); [EOL]     BaseInterfaceImpl two = new BaseInterfaceImpl(); [EOL]     one.addInstance(two); [EOL]     two.addInstance(one); [EOL]     ListWrapper<BaseInterfaceImpl> myList = new ListWrapper<BaseInterfaceImpl>(); [EOL]     myList.add(one); [EOL]     myList.add(two); [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTypingAsProperty(ObjectMapper.DefaultTyping.NON_FINAL, "@class"); [EOL]     String json = om.writerWithDefaultPrettyPrinter().writeValueAsString(myList); [EOL]     ListWrapper<BaseInterfaceImpl> result; [EOL]     result = om.readValue(json, new TypeReference<ListWrapper<BaseInterfaceImpl>>() { [EOL]     }); [EOL]     assertNotNull(result); [EOL]     System.out.println("deserialised list size = " + result.size()); [EOL] }
public void testIssue877() throws Exception { [EOL]     BaseInterfaceImpl one = new BaseInterfaceImpl(); [EOL]     BaseInterfaceImpl two = new BaseInterfaceImpl(); [EOL]     one.addInstance(two); [EOL]     two.addInstance(one); [EOL]     ListWrapper<BaseInterfaceImpl> myList = new ListWrapper<BaseInterfaceImpl>(); [EOL]     myList.add(one); [EOL]     myList.add(two); [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTypingAsProperty(ObjectMapper.DefaultTyping.NON_FINAL, "@class"); [EOL]     String json = om.writerWithDefaultPrettyPrinter().writeValueAsString(myList); [EOL]     ListWrapper<BaseInterfaceImpl> result; [EOL]     result = om.readValue(json, new TypeReference<ListWrapper<BaseInterfaceImpl>>() { [EOL]     }); [EOL]     assertNotNull(result); [EOL]     System.out.println("deserialised list size = " + result.size()); [EOL] }
public void testIssue877() throws Exception { [EOL]     BaseInterfaceImpl one = new BaseInterfaceImpl(); [EOL]     BaseInterfaceImpl two = new BaseInterfaceImpl(); [EOL]     one.addInstance(two); [EOL]     two.addInstance(one); [EOL]     ListWrapper<BaseInterfaceImpl> myList = new ListWrapper<BaseInterfaceImpl>(); [EOL]     myList.add(one); [EOL]     myList.add(two); [EOL]     ObjectMapper om = new ObjectMapper(); [EOL]     om.enableDefaultTypingAsProperty(ObjectMapper.DefaultTyping.NON_FINAL, "@class"); [EOL]     String json = om.writerWithDefaultPrettyPrinter().writeValueAsString(myList); [EOL]     ListWrapper<BaseInterfaceImpl> result; [EOL]     result = om.readValue(json, new TypeReference<ListWrapper<BaseInterfaceImpl>>() { [EOL]     }); [EOL]     assertNotNull(result); [EOL]     System.out.println("deserialised list size = " + result.size()); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testAtomicBoolean() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     assertEquals("true", serializeAsString(mapper, new AtomicBoolean(true))); [EOL]     assertEquals("false", serializeAsString(mapper, new AtomicBoolean(false))); [EOL] }
public void testAtomicBoolean() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     assertEquals("true", serializeAsString(mapper, new AtomicBoolean(true))); [EOL]     assertEquals("false", serializeAsString(mapper, new AtomicBoolean(false))); [EOL] }
public void testAtomicBoolean() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     assertEquals("true", serializeAsString(mapper, new AtomicBoolean(true))); [EOL]     assertEquals("false", serializeAsString(mapper, new AtomicBoolean(false))); [EOL] }
public void testAtomicInteger() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     assertEquals("1", serializeAsString(mapper, new AtomicInteger(1))); [EOL]     assertEquals("-9", serializeAsString(mapper, new AtomicInteger(-9))); [EOL] }
public void testAtomicInteger() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     assertEquals("1", serializeAsString(mapper, new AtomicInteger(1))); [EOL]     assertEquals("-9", serializeAsString(mapper, new AtomicInteger(-9))); [EOL] }
public void testSkipChildrenWrt370() throws Exception { [EOL]     ObjectMapper o = new ObjectMapper(); [EOL]     ObjectNode n = o.createObjectNode(); [EOL]     n.putObject("inner").put("value", "test"); [EOL]     n.putObject("unknown").putNull("inner"); [EOL]     Jackson370Bean obj = o.readValue(n.traverse(), Jackson370Bean.class); [EOL]     assertNotNull(obj.inner); [EOL]     assertEquals("test", obj.inner.value); [EOL] }
public void testBasics() { [EOL]     ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [EOL]     assertStandardEquals(n); [EOL]     assertFalse(n.elements().hasNext()); [EOL]     assertFalse(n.fields().hasNext()); [EOL]     assertFalse(n.fieldNames().hasNext()); [EOL]     assertNull(n.get("a")); [EOL]     assertTrue(n.path("a").isMissingNode()); [EOL]     TextNode text = TextNode.valueOf("x"); [EOL]     n.set("a", text); [EOL]     assertEquals(1, n.size()); [EOL]     assertTrue(n.elements().hasNext()); [EOL]     assertTrue(n.fields().hasNext()); [EOL]     assertTrue(n.fieldNames().hasNext()); [EOL]     assertSame(text, n.get("a")); [EOL]     assertSame(text, n.path("a")); [EOL]     assertNull(n.get("b")); [EOL]     assertNull(n.get(0)); [EOL]     assertFalse(n.has(0)); [EOL]     assertFalse(n.hasNonNull(0)); [EOL]     assertTrue(n.has("a")); [EOL]     assertTrue(n.hasNonNull("a")); [EOL]     assertFalse(n.has("b")); [EOL]     assertFalse(n.hasNonNull("b")); [EOL]     ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance); [EOL]     n2.put("b", 13); [EOL]     assertFalse(n.equals(n2)); [EOL]     n.setAll(n2); [EOL]     assertEquals(2, n.size()); [EOL]     n.set("null", (JsonNode) null); [EOL]     assertEquals(3, n.size()); [EOL]     assertTrue(n.has("null")); [EOL]     assertFalse(n.hasNonNull("null")); [EOL]     n.put("null", "notReallNull"); [EOL]     assertEquals(3, n.size()); [EOL]     assertNotNull(n.remove("null")); [EOL]     assertEquals(2, n.size()); [EOL]     Map<String, JsonNode> nodes = new HashMap<String, JsonNode>(); [EOL]     nodes.put("d", text); [EOL]     n.setAll(nodes); [EOL]     assertEquals(3, n.size()); [EOL]     n.removeAll(); [EOL]     assertEquals(0, n.size()); [EOL] }
public void testBasics() { [EOL]     ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [EOL]     assertStandardEquals(n); [EOL]     assertFalse(n.elements().hasNext()); [EOL]     assertFalse(n.fields().hasNext()); [EOL]     assertFalse(n.fieldNames().hasNext()); [EOL]     assertNull(n.get("a")); [EOL]     assertTrue(n.path("a").isMissingNode()); [EOL]     TextNode text = TextNode.valueOf("x"); [EOL]     n.set("a", text); [EOL]     assertEquals(1, n.size()); [EOL]     assertTrue(n.elements().hasNext()); [EOL]     assertTrue(n.fields().hasNext()); [EOL]     assertTrue(n.fieldNames().hasNext()); [EOL]     assertSame(text, n.get("a")); [EOL]     assertSame(text, n.path("a")); [EOL]     assertNull(n.get("b")); [EOL]     assertNull(n.get(0)); [EOL]     assertFalse(n.has(0)); [EOL]     assertFalse(n.hasNonNull(0)); [EOL]     assertTrue(n.has("a")); [EOL]     assertTrue(n.hasNonNull("a")); [EOL]     assertFalse(n.has("b")); [EOL]     assertFalse(n.hasNonNull("b")); [EOL]     ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance); [EOL]     n2.put("b", 13); [EOL]     assertFalse(n.equals(n2)); [EOL]     n.setAll(n2); [EOL]     assertEquals(2, n.size()); [EOL]     n.set("null", (JsonNode) null); [EOL]     assertEquals(3, n.size()); [EOL]     assertTrue(n.has("null")); [EOL]     assertFalse(n.hasNonNull("null")); [EOL]     n.put("null", "notReallNull"); [EOL]     assertEquals(3, n.size()); [EOL]     assertNotNull(n.remove("null")); [EOL]     assertEquals(2, n.size()); [EOL]     Map<String, JsonNode> nodes = new HashMap<String, JsonNode>(); [EOL]     nodes.put("d", text); [EOL]     n.setAll(nodes); [EOL]     assertEquals(3, n.size()); [EOL]     n.removeAll(); [EOL]     assertEquals(0, n.size()); [EOL] }
public void testBasics() { [EOL]     ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [EOL]     assertStandardEquals(n); [EOL]     assertFalse(n.elements().hasNext()); [EOL]     assertFalse(n.fields().hasNext()); [EOL]     assertFalse(n.fieldNames().hasNext()); [EOL]     assertNull(n.get("a")); [EOL]     assertTrue(n.path("a").isMissingNode()); [EOL]     TextNode text = TextNode.valueOf("x"); [EOL]     n.set("a", text); [EOL]     assertEquals(1, n.size()); [EOL]     assertTrue(n.elements().hasNext()); [EOL]     assertTrue(n.fields().hasNext()); [EOL]     assertTrue(n.fieldNames().hasNext()); [EOL]     assertSame(text, n.get("a")); [EOL]     assertSame(text, n.path("a")); [EOL]     assertNull(n.get("b")); [EOL]     assertNull(n.get(0)); [EOL]     assertFalse(n.has(0)); [EOL]     assertFalse(n.hasNonNull(0)); [EOL]     assertTrue(n.has("a")); [EOL]     assertTrue(n.hasNonNull("a")); [EOL]     assertFalse(n.has("b")); [EOL]     assertFalse(n.hasNonNull("b")); [EOL]     ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance); [EOL]     n2.put("b", 13); [EOL]     assertFalse(n.equals(n2)); [EOL]     n.setAll(n2); [EOL]     assertEquals(2, n.size()); [EOL]     n.set("null", (JsonNode) null); [EOL]     assertEquals(3, n.size()); [EOL]     assertTrue(n.has("null")); [EOL]     assertFalse(n.hasNonNull("null")); [EOL]     n.put("null", "notReallNull"); [EOL]     assertEquals(3, n.size()); [EOL]     assertNotNull(n.remove("null")); [EOL]     assertEquals(2, n.size()); [EOL]     Map<String, JsonNode> nodes = new HashMap<String, JsonNode>(); [EOL]     nodes.put("d", text); [EOL]     n.setAll(nodes); [EOL]     assertEquals(3, n.size()); [EOL]     n.removeAll(); [EOL]     assertEquals(0, n.size()); [EOL] }
public void testBasics() { [EOL]     ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [EOL]     assertStandardEquals(n); [EOL]     assertFalse(n.elements().hasNext()); [EOL]     assertFalse(n.fields().hasNext()); [EOL]     assertFalse(n.fieldNames().hasNext()); [EOL]     assertNull(n.get("a")); [EOL]     assertTrue(n.path("a").isMissingNode()); [EOL]     TextNode text = TextNode.valueOf("x"); [EOL]     n.set("a", text); [EOL]     assertEquals(1, n.size()); [EOL]     assertTrue(n.elements().hasNext()); [EOL]     assertTrue(n.fields().hasNext()); [EOL]     assertTrue(n.fieldNames().hasNext()); [EOL]     assertSame(text, n.get("a")); [EOL]     assertSame(text, n.path("a")); [EOL]     assertNull(n.get("b")); [EOL]     assertNull(n.get(0)); [EOL]     assertFalse(n.has(0)); [EOL]     assertFalse(n.hasNonNull(0)); [EOL]     assertTrue(n.has("a")); [EOL]     assertTrue(n.hasNonNull("a")); [EOL]     assertFalse(n.has("b")); [EOL]     assertFalse(n.hasNonNull("b")); [EOL]     ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance); [EOL]     n2.put("b", 13); [EOL]     assertFalse(n.equals(n2)); [EOL]     n.setAll(n2); [EOL]     assertEquals(2, n.size()); [EOL]     n.set("null", (JsonNode) null); [EOL]     assertEquals(3, n.size()); [EOL]     assertTrue(n.has("null")); [EOL]     assertFalse(n.hasNonNull("null")); [EOL]     n.put("null", "notReallNull"); [EOL]     assertEquals(3, n.size()); [EOL]     assertNotNull(n.remove("null")); [EOL]     assertEquals(2, n.size()); [EOL]     Map<String, JsonNode> nodes = new HashMap<String, JsonNode>(); [EOL]     nodes.put("d", text); [EOL]     n.setAll(nodes); [EOL]     assertEquals(3, n.size()); [EOL]     n.removeAll(); [EOL]     assertEquals(0, n.size()); [EOL] }
public void testBasics() { [EOL]     ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [EOL]     assertStandardEquals(n); [EOL]     assertFalse(n.elements().hasNext()); [EOL]     assertFalse(n.fields().hasNext()); [EOL]     assertFalse(n.fieldNames().hasNext()); [EOL]     assertNull(n.get("a")); [EOL]     assertTrue(n.path("a").isMissingNode()); [EOL]     TextNode text = TextNode.valueOf("x"); [EOL]     n.set("a", text); [EOL]     assertEquals(1, n.size()); [EOL]     assertTrue(n.elements().hasNext()); [EOL]     assertTrue(n.fields().hasNext()); [EOL]     assertTrue(n.fieldNames().hasNext()); [EOL]     assertSame(text, n.get("a")); [EOL]     assertSame(text, n.path("a")); [EOL]     assertNull(n.get("b")); [EOL]     assertNull(n.get(0)); [EOL]     assertFalse(n.has(0)); [EOL]     assertFalse(n.hasNonNull(0)); [EOL]     assertTrue(n.has("a")); [EOL]     assertTrue(n.hasNonNull("a")); [EOL]     assertFalse(n.has("b")); [EOL]     assertFalse(n.hasNonNull("b")); [EOL]     ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance); [EOL]     n2.put("b", 13); [EOL]     assertFalse(n.equals(n2)); [EOL]     n.setAll(n2); [EOL]     assertEquals(2, n.size()); [EOL]     n.set("null", (JsonNode) null); [EOL]     assertEquals(3, n.size()); [EOL]     assertTrue(n.has("null")); [EOL]     assertFalse(n.hasNonNull("null")); [EOL]     n.put("null", "notReallNull"); [EOL]     assertEquals(3, n.size()); [EOL]     assertNotNull(n.remove("null")); [EOL]     assertEquals(2, n.size()); [EOL]     Map<String, JsonNode> nodes = new HashMap<String, JsonNode>(); [EOL]     nodes.put("d", text); [EOL]     n.setAll(nodes); [EOL]     assertEquals(3, n.size()); [EOL]     n.removeAll(); [EOL]     assertEquals(0, n.size()); [EOL] }
public void testBasics() { [EOL]     ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [EOL]     assertStandardEquals(n); [EOL]     assertFalse(n.elements().hasNext()); [EOL]     assertFalse(n.fields().hasNext()); [EOL]     assertFalse(n.fieldNames().hasNext()); [EOL]     assertNull(n.get("a")); [EOL]     assertTrue(n.path("a").isMissingNode()); [EOL]     TextNode text = TextNode.valueOf("x"); [EOL]     n.set("a", text); [EOL]     assertEquals(1, n.size()); [EOL]     assertTrue(n.elements().hasNext()); [EOL]     assertTrue(n.fields().hasNext()); [EOL]     assertTrue(n.fieldNames().hasNext()); [EOL]     assertSame(text, n.get("a")); [EOL]     assertSame(text, n.path("a")); [EOL]     assertNull(n.get("b")); [EOL]     assertNull(n.get(0)); [EOL]     assertFalse(n.has(0)); [EOL]     assertFalse(n.hasNonNull(0)); [EOL]     assertTrue(n.has("a")); [EOL]     assertTrue(n.hasNonNull("a")); [EOL]     assertFalse(n.has("b")); [EOL]     assertFalse(n.hasNonNull("b")); [EOL]     ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance); [EOL]     n2.put("b", 13); [EOL]     assertFalse(n.equals(n2)); [EOL]     n.setAll(n2); [EOL]     assertEquals(2, n.size()); [EOL]     n.set("null", (JsonNode) null); [EOL]     assertEquals(3, n.size()); [EOL]     assertTrue(n.has("null")); [EOL]     assertFalse(n.hasNonNull("null")); [EOL]     n.put("null", "notReallNull"); [EOL]     assertEquals(3, n.size()); [EOL]     assertNotNull(n.remove("null")); [EOL]     assertEquals(2, n.size()); [EOL]     Map<String, JsonNode> nodes = new HashMap<String, JsonNode>(); [EOL]     nodes.put("d", text); [EOL]     n.setAll(nodes); [EOL]     assertEquals(3, n.size()); [EOL]     n.removeAll(); [EOL]     assertEquals(0, n.size()); [EOL] }
public void testBasics() { [EOL]     ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [EOL]     assertStandardEquals(n); [EOL]     assertFalse(n.elements().hasNext()); [EOL]     assertFalse(n.fields().hasNext()); [EOL]     assertFalse(n.fieldNames().hasNext()); [EOL]     assertNull(n.get("a")); [EOL]     assertTrue(n.path("a").isMissingNode()); [EOL]     TextNode text = TextNode.valueOf("x"); [EOL]     n.set("a", text); [EOL]     assertEquals(1, n.size()); [EOL]     assertTrue(n.elements().hasNext()); [EOL]     assertTrue(n.fields().hasNext()); [EOL]     assertTrue(n.fieldNames().hasNext()); [EOL]     assertSame(text, n.get("a")); [EOL]     assertSame(text, n.path("a")); [EOL]     assertNull(n.get("b")); [EOL]     assertNull(n.get(0)); [EOL]     assertFalse(n.has(0)); [EOL]     assertFalse(n.hasNonNull(0)); [EOL]     assertTrue(n.has("a")); [EOL]     assertTrue(n.hasNonNull("a")); [EOL]     assertFalse(n.has("b")); [EOL]     assertFalse(n.hasNonNull("b")); [EOL]     ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance); [EOL]     n2.put("b", 13); [EOL]     assertFalse(n.equals(n2)); [EOL]     n.setAll(n2); [EOL]     assertEquals(2, n.size()); [EOL]     n.set("null", (JsonNode) null); [EOL]     assertEquals(3, n.size()); [EOL]     assertTrue(n.has("null")); [EOL]     assertFalse(n.hasNonNull("null")); [EOL]     n.put("null", "notReallNull"); [EOL]     assertEquals(3, n.size()); [EOL]     assertNotNull(n.remove("null")); [EOL]     assertEquals(2, n.size()); [EOL]     Map<String, JsonNode> nodes = new HashMap<String, JsonNode>(); [EOL]     nodes.put("d", text); [EOL]     n.setAll(nodes); [EOL]     assertEquals(3, n.size()); [EOL]     n.removeAll(); [EOL]     assertEquals(0, n.size()); [EOL] }
public void testBasics() { [EOL]     ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [EOL]     assertStandardEquals(n); [EOL]     assertFalse(n.elements().hasNext()); [EOL]     assertFalse(n.fields().hasNext()); [EOL]     assertFalse(n.fieldNames().hasNext()); [EOL]     assertNull(n.get("a")); [EOL]     assertTrue(n.path("a").isMissingNode()); [EOL]     TextNode text = TextNode.valueOf("x"); [EOL]     n.set("a", text); [EOL]     assertEquals(1, n.size()); [EOL]     assertTrue(n.elements().hasNext()); [EOL]     assertTrue(n.fields().hasNext()); [EOL]     assertTrue(n.fieldNames().hasNext()); [EOL]     assertSame(text, n.get("a")); [EOL]     assertSame(text, n.path("a")); [EOL]     assertNull(n.get("b")); [EOL]     assertNull(n.get(0)); [EOL]     assertFalse(n.has(0)); [EOL]     assertFalse(n.hasNonNull(0)); [EOL]     assertTrue(n.has("a")); [EOL]     assertTrue(n.hasNonNull("a")); [EOL]     assertFalse(n.has("b")); [EOL]     assertFalse(n.hasNonNull("b")); [EOL]     ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance); [EOL]     n2.put("b", 13); [EOL]     assertFalse(n.equals(n2)); [EOL]     n.setAll(n2); [EOL]     assertEquals(2, n.size()); [EOL]     n.set("null", (JsonNode) null); [EOL]     assertEquals(3, n.size()); [EOL]     assertTrue(n.has("null")); [EOL]     assertFalse(n.hasNonNull("null")); [EOL]     n.put("null", "notReallNull"); [EOL]     assertEquals(3, n.size()); [EOL]     assertNotNull(n.remove("null")); [EOL]     assertEquals(2, n.size()); [EOL]     Map<String, JsonNode> nodes = new HashMap<String, JsonNode>(); [EOL]     nodes.put("d", text); [EOL]     n.setAll(nodes); [EOL]     assertEquals(3, n.size()); [EOL]     n.removeAll(); [EOL]     assertEquals(0, n.size()); [EOL] }
public void testBasics() { [EOL]     ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [EOL]     assertStandardEquals(n); [EOL]     assertFalse(n.elements().hasNext()); [EOL]     assertFalse(n.fields().hasNext()); [EOL]     assertFalse(n.fieldNames().hasNext()); [EOL]     assertNull(n.get("a")); [EOL]     assertTrue(n.path("a").isMissingNode()); [EOL]     TextNode text = TextNode.valueOf("x"); [EOL]     n.set("a", text); [EOL]     assertEquals(1, n.size()); [EOL]     assertTrue(n.elements().hasNext()); [EOL]     assertTrue(n.fields().hasNext()); [EOL]     assertTrue(n.fieldNames().hasNext()); [EOL]     assertSame(text, n.get("a")); [EOL]     assertSame(text, n.path("a")); [EOL]     assertNull(n.get("b")); [EOL]     assertNull(n.get(0)); [EOL]     assertFalse(n.has(0)); [EOL]     assertFalse(n.hasNonNull(0)); [EOL]     assertTrue(n.has("a")); [EOL]     assertTrue(n.hasNonNull("a")); [EOL]     assertFalse(n.has("b")); [EOL]     assertFalse(n.hasNonNull("b")); [EOL]     ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance); [EOL]     n2.put("b", 13); [EOL]     assertFalse(n.equals(n2)); [EOL]     n.setAll(n2); [EOL]     assertEquals(2, n.size()); [EOL]     n.set("null", (JsonNode) null); [EOL]     assertEquals(3, n.size()); [EOL]     assertTrue(n.has("null")); [EOL]     assertFalse(n.hasNonNull("null")); [EOL]     n.put("null", "notReallNull"); [EOL]     assertEquals(3, n.size()); [EOL]     assertNotNull(n.remove("null")); [EOL]     assertEquals(2, n.size()); [EOL]     Map<String, JsonNode> nodes = new HashMap<String, JsonNode>(); [EOL]     nodes.put("d", text); [EOL]     n.setAll(nodes); [EOL]     assertEquals(3, n.size()); [EOL]     n.removeAll(); [EOL]     assertEquals(0, n.size()); [EOL] }
public void testInvalidWith() throws Exception { [EOL]     JsonNode root = MAPPER.createArrayNode(); [EOL]     try { [EOL]         root.with("prop"); [EOL]         fail("Expected exception"); [EOL]     } catch (UnsupportedOperationException e) { [EOL]         verifyException(e, "not of type ObjectNode"); [EOL]     } [EOL]     ObjectNode root2 = MAPPER.createObjectNode(); [EOL]     root2.put("prop", 13); [EOL]     try { [EOL]         root2.with("prop"); [EOL]         fail("Expected exception"); [EOL]     } catch (UnsupportedOperationException e) { [EOL]         verifyException(e, "has value that is not"); [EOL]     } [EOL] }
public void testInvalidWith() throws Exception { [EOL]     JsonNode root = MAPPER.createArrayNode(); [EOL]     try { [EOL]         root.with("prop"); [EOL]         fail("Expected exception"); [EOL]     } catch (UnsupportedOperationException e) { [EOL]         verifyException(e, "not of type ObjectNode"); [EOL]     } [EOL]     ObjectNode root2 = MAPPER.createObjectNode(); [EOL]     root2.put("prop", 13); [EOL]     try { [EOL]         root2.with("prop"); [EOL]         fail("Expected exception"); [EOL]     } catch (UnsupportedOperationException e) { [EOL]         verifyException(e, "has value that is not"); [EOL]     } [EOL] }
public void testInvalidWith() throws Exception { [EOL]     JsonNode root = MAPPER.createArrayNode(); [EOL]     try { [EOL]         root.with("prop"); [EOL]         fail("Expected exception"); [EOL]     } catch (UnsupportedOperationException e) { [EOL]         verifyException(e, "not of type ObjectNode"); [EOL]     } [EOL]     ObjectNode root2 = MAPPER.createObjectNode(); [EOL]     root2.put("prop", 13); [EOL]     try { [EOL]         root2.with("prop"); [EOL]         fail("Expected exception"); [EOL]     } catch (UnsupportedOperationException e) { [EOL]         verifyException(e, "has value that is not"); [EOL]     } [EOL] }
public void testInvalidWithArray() throws Exception { [EOL]     JsonNode root = MAPPER.createArrayNode(); [EOL]     try { [EOL]         root.withArray("prop"); [EOL]         fail("Expected exception"); [EOL]     } catch (UnsupportedOperationException e) { [EOL]         verifyException(e, "not of type ObjectNode"); [EOL]     } [EOL]     ObjectNode root2 = MAPPER.createObjectNode(); [EOL]     root2.put("prop", 13); [EOL]     try { [EOL]         root2.withArray("prop"); [EOL]         fail("Expected exception"); [EOL]     } catch (UnsupportedOperationException e) { [EOL]         verifyException(e, "has value that is not"); [EOL]     } [EOL] }
public void testInvalidWithArray() throws Exception { [EOL]     JsonNode root = MAPPER.createArrayNode(); [EOL]     try { [EOL]         root.withArray("prop"); [EOL]         fail("Expected exception"); [EOL]     } catch (UnsupportedOperationException e) { [EOL]         verifyException(e, "not of type ObjectNode"); [EOL]     } [EOL]     ObjectNode root2 = MAPPER.createObjectNode(); [EOL]     root2.put("prop", 13); [EOL]     try { [EOL]         root2.withArray("prop"); [EOL]         fail("Expected exception"); [EOL]     } catch (UnsupportedOperationException e) { [EOL]         verifyException(e, "has value that is not"); [EOL]     } [EOL] }
public void testInvalidWithArray() throws Exception { [EOL]     JsonNode root = MAPPER.createArrayNode(); [EOL]     try { [EOL]         root.withArray("prop"); [EOL]         fail("Expected exception"); [EOL]     } catch (UnsupportedOperationException e) { [EOL]         verifyException(e, "not of type ObjectNode"); [EOL]     } [EOL]     ObjectNode root2 = MAPPER.createObjectNode(); [EOL]     root2.put("prop", 13); [EOL]     try { [EOL]         root2.withArray("prop"); [EOL]         fail("Expected exception"); [EOL]     } catch (UnsupportedOperationException e) { [EOL]         verifyException(e, "has value that is not"); [EOL]     } [EOL] }
public void testMatchingSingle() throws Exception { [EOL]     JsonNode root = _buildTree(); [EOL]     JsonNode node = root.findValue("b"); [EOL]     assertNotNull(node); [EOL]     assertEquals(3, node.intValue()); [EOL]     node = root.findParent("b"); [EOL]     assertNotNull(node); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, ((ObjectNode) node).size()); [EOL]     assertEquals(3, node.path("b").intValue()); [EOL] }
public void testMatchingSingle() throws Exception { [EOL]     JsonNode root = _buildTree(); [EOL]     JsonNode node = root.findValue("b"); [EOL]     assertNotNull(node); [EOL]     assertEquals(3, node.intValue()); [EOL]     node = root.findParent("b"); [EOL]     assertNotNull(node); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, ((ObjectNode) node).size()); [EOL]     assertEquals(3, node.path("b").intValue()); [EOL] }
public void testMatchingSingle() throws Exception { [EOL]     JsonNode root = _buildTree(); [EOL]     JsonNode node = root.findValue("b"); [EOL]     assertNotNull(node); [EOL]     assertEquals(3, node.intValue()); [EOL]     node = root.findParent("b"); [EOL]     assertNotNull(node); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, ((ObjectNode) node).size()); [EOL]     assertEquals(3, node.path("b").intValue()); [EOL] }
public void testMatchingSingle() throws Exception { [EOL]     JsonNode root = _buildTree(); [EOL]     JsonNode node = root.findValue("b"); [EOL]     assertNotNull(node); [EOL]     assertEquals(3, node.intValue()); [EOL]     node = root.findParent("b"); [EOL]     assertNotNull(node); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, ((ObjectNode) node).size()); [EOL]     assertEquals(3, node.path("b").intValue()); [EOL] }
public void testMatchingSingle() throws Exception { [EOL]     JsonNode root = _buildTree(); [EOL]     JsonNode node = root.findValue("b"); [EOL]     assertNotNull(node); [EOL]     assertEquals(3, node.intValue()); [EOL]     node = root.findParent("b"); [EOL]     assertNotNull(node); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, ((ObjectNode) node).size()); [EOL]     assertEquals(3, node.path("b").intValue()); [EOL] }
public void testMatchingSingle() throws Exception { [EOL]     JsonNode root = _buildTree(); [EOL]     JsonNode node = root.findValue("b"); [EOL]     assertNotNull(node); [EOL]     assertEquals(3, node.intValue()); [EOL]     node = root.findParent("b"); [EOL]     assertNotNull(node); [EOL]     assertTrue(node.isObject()); [EOL]     assertEquals(1, ((ObjectNode) node).size()); [EOL]     assertEquals(3, node.path("b").intValue()); [EOL] }
public void testRemove() { [EOL]     ObjectNode ob = MAPPER.createObjectNode(); [EOL]     ob.put("a", "a"); [EOL]     ob.put("b", "b"); [EOL]     ob.put("c", "c"); [EOL]     assertEquals(3, ob.size()); [EOL]     assertSame(ob, ob.without(Arrays.asList("a", "c"))); [EOL]     assertEquals(1, ob.size()); [EOL]     assertEquals("b", ob.get("b").textValue()); [EOL] }
public void testRemove() { [EOL]     ObjectNode ob = MAPPER.createObjectNode(); [EOL]     ob.put("a", "a"); [EOL]     ob.put("b", "b"); [EOL]     ob.put("c", "c"); [EOL]     assertEquals(3, ob.size()); [EOL]     assertSame(ob, ob.without(Arrays.asList("a", "c"))); [EOL]     assertEquals(1, ob.size()); [EOL]     assertEquals("b", ob.get("b").textValue()); [EOL] }
public void testBasics() { [EOL]     ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [EOL]     assertStandardEquals(n); [EOL]     assertFalse(n.elements().hasNext()); [EOL]     assertFalse(n.fields().hasNext()); [EOL]     assertFalse(n.fieldNames().hasNext()); [EOL]     assertNull(n.get("a")); [EOL]     assertTrue(n.path("a").isMissingNode()); [EOL]     TextNode text = TextNode.valueOf("x"); [EOL]     n.set("a", text); [EOL]     assertEquals(1, n.size()); [EOL]     assertTrue(n.elements().hasNext()); [EOL]     assertTrue(n.fields().hasNext()); [EOL]     assertTrue(n.fieldNames().hasNext()); [EOL]     assertSame(text, n.get("a")); [EOL]     assertSame(text, n.path("a")); [EOL]     assertNull(n.get("b")); [EOL]     assertNull(n.get(0)); [EOL]     assertFalse(n.has(0)); [EOL]     assertFalse(n.hasNonNull(0)); [EOL]     assertTrue(n.has("a")); [EOL]     assertTrue(n.hasNonNull("a")); [EOL]     assertFalse(n.has("b")); [EOL]     assertFalse(n.hasNonNull("b")); [EOL]     ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance); [EOL]     n2.put("b", 13); [EOL]     assertFalse(n.equals(n2)); [EOL]     n.setAll(n2); [EOL]     assertEquals(2, n.size()); [EOL]     n.set("null", (JsonNode) null); [EOL]     assertEquals(3, n.size()); [EOL]     assertTrue(n.has("null")); [EOL]     assertFalse(n.hasNonNull("null")); [EOL]     n.put("null", "notReallNull"); [EOL]     assertEquals(3, n.size()); [EOL]     assertNotNull(n.remove("null")); [EOL]     assertEquals(2, n.size()); [EOL]     Map<String, JsonNode> nodes = new HashMap<String, JsonNode>(); [EOL]     nodes.put("d", text); [EOL]     n.setAll(nodes); [EOL]     assertEquals(3, n.size()); [EOL]     n.removeAll(); [EOL]     assertEquals(0, n.size()); [EOL] }
public void testBasics() { [EOL]     ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [EOL]     assertStandardEquals(n); [EOL]     assertFalse(n.elements().hasNext()); [EOL]     assertFalse(n.fields().hasNext()); [EOL]     assertFalse(n.fieldNames().hasNext()); [EOL]     assertNull(n.get("a")); [EOL]     assertTrue(n.path("a").isMissingNode()); [EOL]     TextNode text = TextNode.valueOf("x"); [EOL]     n.set("a", text); [EOL]     assertEquals(1, n.size()); [EOL]     assertTrue(n.elements().hasNext()); [EOL]     assertTrue(n.fields().hasNext()); [EOL]     assertTrue(n.fieldNames().hasNext()); [EOL]     assertSame(text, n.get("a")); [EOL]     assertSame(text, n.path("a")); [EOL]     assertNull(n.get("b")); [EOL]     assertNull(n.get(0)); [EOL]     assertFalse(n.has(0)); [EOL]     assertFalse(n.hasNonNull(0)); [EOL]     assertTrue(n.has("a")); [EOL]     assertTrue(n.hasNonNull("a")); [EOL]     assertFalse(n.has("b")); [EOL]     assertFalse(n.hasNonNull("b")); [EOL]     ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance); [EOL]     n2.put("b", 13); [EOL]     assertFalse(n.equals(n2)); [EOL]     n.setAll(n2); [EOL]     assertEquals(2, n.size()); [EOL]     n.set("null", (JsonNode) null); [EOL]     assertEquals(3, n.size()); [EOL]     assertTrue(n.has("null")); [EOL]     assertFalse(n.hasNonNull("null")); [EOL]     n.put("null", "notReallNull"); [EOL]     assertEquals(3, n.size()); [EOL]     assertNotNull(n.remove("null")); [EOL]     assertEquals(2, n.size()); [EOL]     Map<String, JsonNode> nodes = new HashMap<String, JsonNode>(); [EOL]     nodes.put("d", text); [EOL]     n.setAll(nodes); [EOL]     assertEquals(3, n.size()); [EOL]     n.removeAll(); [EOL]     assertEquals(0, n.size()); [EOL] }
public void testBasics() { [EOL]     ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [EOL]     assertStandardEquals(n); [EOL]     assertFalse(n.elements().hasNext()); [EOL]     assertFalse(n.fields().hasNext()); [EOL]     assertFalse(n.fieldNames().hasNext()); [EOL]     assertNull(n.get("a")); [EOL]     assertTrue(n.path("a").isMissingNode()); [EOL]     TextNode text = TextNode.valueOf("x"); [EOL]     n.set("a", text); [EOL]     assertEquals(1, n.size()); [EOL]     assertTrue(n.elements().hasNext()); [EOL]     assertTrue(n.fields().hasNext()); [EOL]     assertTrue(n.fieldNames().hasNext()); [EOL]     assertSame(text, n.get("a")); [EOL]     assertSame(text, n.path("a")); [EOL]     assertNull(n.get("b")); [EOL]     assertNull(n.get(0)); [EOL]     assertFalse(n.has(0)); [EOL]     assertFalse(n.hasNonNull(0)); [EOL]     assertTrue(n.has("a")); [EOL]     assertTrue(n.hasNonNull("a")); [EOL]     assertFalse(n.has("b")); [EOL]     assertFalse(n.hasNonNull("b")); [EOL]     ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance); [EOL]     n2.put("b", 13); [EOL]     assertFalse(n.equals(n2)); [EOL]     n.setAll(n2); [EOL]     assertEquals(2, n.size()); [EOL]     n.set("null", (JsonNode) null); [EOL]     assertEquals(3, n.size()); [EOL]     assertTrue(n.has("null")); [EOL]     assertFalse(n.hasNonNull("null")); [EOL]     n.put("null", "notReallNull"); [EOL]     assertEquals(3, n.size()); [EOL]     assertNotNull(n.remove("null")); [EOL]     assertEquals(2, n.size()); [EOL]     Map<String, JsonNode> nodes = new HashMap<String, JsonNode>(); [EOL]     nodes.put("d", text); [EOL]     n.setAll(nodes); [EOL]     assertEquals(3, n.size()); [EOL]     n.removeAll(); [EOL]     assertEquals(0, n.size()); [EOL] }
public void testBasics() { [EOL]     ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [EOL]     assertStandardEquals(n); [EOL]     assertFalse(n.elements().hasNext()); [EOL]     assertFalse(n.fields().hasNext()); [EOL]     assertFalse(n.fieldNames().hasNext()); [EOL]     assertNull(n.get("a")); [EOL]     assertTrue(n.path("a").isMissingNode()); [EOL]     TextNode text = TextNode.valueOf("x"); [EOL]     n.set("a", text); [EOL]     assertEquals(1, n.size()); [EOL]     assertTrue(n.elements().hasNext()); [EOL]     assertTrue(n.fields().hasNext()); [EOL]     assertTrue(n.fieldNames().hasNext()); [EOL]     assertSame(text, n.get("a")); [EOL]     assertSame(text, n.path("a")); [EOL]     assertNull(n.get("b")); [EOL]     assertNull(n.get(0)); [EOL]     assertFalse(n.has(0)); [EOL]     assertFalse(n.hasNonNull(0)); [EOL]     assertTrue(n.has("a")); [EOL]     assertTrue(n.hasNonNull("a")); [EOL]     assertFalse(n.has("b")); [EOL]     assertFalse(n.hasNonNull("b")); [EOL]     ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance); [EOL]     n2.put("b", 13); [EOL]     assertFalse(n.equals(n2)); [EOL]     n.setAll(n2); [EOL]     assertEquals(2, n.size()); [EOL]     n.set("null", (JsonNode) null); [EOL]     assertEquals(3, n.size()); [EOL]     assertTrue(n.has("null")); [EOL]     assertFalse(n.hasNonNull("null")); [EOL]     n.put("null", "notReallNull"); [EOL]     assertEquals(3, n.size()); [EOL]     assertNotNull(n.remove("null")); [EOL]     assertEquals(2, n.size()); [EOL]     Map<String, JsonNode> nodes = new HashMap<String, JsonNode>(); [EOL]     nodes.put("d", text); [EOL]     n.setAll(nodes); [EOL]     assertEquals(3, n.size()); [EOL]     n.removeAll(); [EOL]     assertEquals(0, n.size()); [EOL] }
public void testInvalidWith() throws Exception { [EOL]     JsonNode root = MAPPER.createArrayNode(); [EOL]     try { [EOL]         root.with("prop"); [EOL]         fail("Expected exception"); [EOL]     } catch (UnsupportedOperationException e) { [EOL]         verifyException(e, "not of type ObjectNode"); [EOL]     } [EOL]     ObjectNode root2 = MAPPER.createObjectNode(); [EOL]     root2.put("prop", 13); [EOL]     try { [EOL]         root2.with("prop"); [EOL]         fail("Expected exception"); [EOL]     } catch (UnsupportedOperationException e) { [EOL]         verifyException(e, "has value that is not"); [EOL]     } [EOL] }
public void testGeneratingJsonSchema() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class); [EOL]     assertNotNull(jsonSchema); [EOL]     assertTrue(jsonSchema.equals(jsonSchema)); [EOL]     assertFalse(jsonSchema.equals(null)); [EOL]     assertFalse(jsonSchema.equals("foo")); [EOL]     assertNotNull(jsonSchema.toString()); [EOL]     assertNotNull(JsonSchema.getDefaultSchemaNode()); [EOL]     ObjectNode root = jsonSchema.getSchemaNode(); [EOL]     assertEquals("object", root.get("type").asText()); [EOL]     assertEquals(false, root.path("required").booleanValue()); [EOL]     JsonNode propertiesSchema = root.get("properties"); [EOL]     assertNotNull(propertiesSchema); [EOL]     JsonNode property1Schema = propertiesSchema.get("property1"); [EOL]     assertNotNull(property1Schema); [EOL]     assertEquals("integer", property1Schema.get("type").asText()); [EOL]     assertEquals(false, property1Schema.path("required").booleanValue()); [EOL]     JsonNode property2Schema = propertiesSchema.get("property2"); [EOL]     assertNotNull(property2Schema); [EOL]     assertEquals("string", property2Schema.get("type").asText()); [EOL]     assertEquals(false, property2Schema.path("required").booleanValue()); [EOL]     JsonNode property3Schema = propertiesSchema.get("property3"); [EOL]     assertNotNull(property3Schema); [EOL]     assertEquals("array", property3Schema.get("type").asText()); [EOL]     assertEquals(false, property3Schema.path("required").booleanValue()); [EOL]     assertEquals("string", property3Schema.get("items").get("type").asText()); [EOL]     JsonNode property4Schema = propertiesSchema.get("property4"); [EOL]     assertNotNull(property4Schema); [EOL]     assertEquals("array", property4Schema.get("type").asText()); [EOL]     assertEquals(false, property4Schema.path("required").booleanValue()); [EOL]     assertEquals("number", property4Schema.get("items").get("type").asText()); [EOL] }
public void testGeneratingJsonSchema() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class); [EOL]     assertNotNull(jsonSchema); [EOL]     assertTrue(jsonSchema.equals(jsonSchema)); [EOL]     assertFalse(jsonSchema.equals(null)); [EOL]     assertFalse(jsonSchema.equals("foo")); [EOL]     assertNotNull(jsonSchema.toString()); [EOL]     assertNotNull(JsonSchema.getDefaultSchemaNode()); [EOL]     ObjectNode root = jsonSchema.getSchemaNode(); [EOL]     assertEquals("object", root.get("type").asText()); [EOL]     assertEquals(false, root.path("required").booleanValue()); [EOL]     JsonNode propertiesSchema = root.get("properties"); [EOL]     assertNotNull(propertiesSchema); [EOL]     JsonNode property1Schema = propertiesSchema.get("property1"); [EOL]     assertNotNull(property1Schema); [EOL]     assertEquals("integer", property1Schema.get("type").asText()); [EOL]     assertEquals(false, property1Schema.path("required").booleanValue()); [EOL]     JsonNode property2Schema = propertiesSchema.get("property2"); [EOL]     assertNotNull(property2Schema); [EOL]     assertEquals("string", property2Schema.get("type").asText()); [EOL]     assertEquals(false, property2Schema.path("required").booleanValue()); [EOL]     JsonNode property3Schema = propertiesSchema.get("property3"); [EOL]     assertNotNull(property3Schema); [EOL]     assertEquals("array", property3Schema.get("type").asText()); [EOL]     assertEquals(false, property3Schema.path("required").booleanValue()); [EOL]     assertEquals("string", property3Schema.get("items").get("type").asText()); [EOL]     JsonNode property4Schema = propertiesSchema.get("property4"); [EOL]     assertNotNull(property4Schema); [EOL]     assertEquals("array", property4Schema.get("type").asText()); [EOL]     assertEquals(false, property4Schema.path("required").booleanValue()); [EOL]     assertEquals("number", property4Schema.get("items").get("type").asText()); [EOL] }
public void testBasics() { [EOL]     ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [EOL]     assertStandardEquals(n); [EOL]     assertFalse(n.elements().hasNext()); [EOL]     assertFalse(n.fields().hasNext()); [EOL]     assertFalse(n.fieldNames().hasNext()); [EOL]     assertNull(n.get("a")); [EOL]     assertTrue(n.path("a").isMissingNode()); [EOL]     TextNode text = TextNode.valueOf("x"); [EOL]     n.set("a", text); [EOL]     assertEquals(1, n.size()); [EOL]     assertTrue(n.elements().hasNext()); [EOL]     assertTrue(n.fields().hasNext()); [EOL]     assertTrue(n.fieldNames().hasNext()); [EOL]     assertSame(text, n.get("a")); [EOL]     assertSame(text, n.path("a")); [EOL]     assertNull(n.get("b")); [EOL]     assertNull(n.get(0)); [EOL]     assertFalse(n.has(0)); [EOL]     assertFalse(n.hasNonNull(0)); [EOL]     assertTrue(n.has("a")); [EOL]     assertTrue(n.hasNonNull("a")); [EOL]     assertFalse(n.has("b")); [EOL]     assertFalse(n.hasNonNull("b")); [EOL]     ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance); [EOL]     n2.put("b", 13); [EOL]     assertFalse(n.equals(n2)); [EOL]     n.setAll(n2); [EOL]     assertEquals(2, n.size()); [EOL]     n.set("null", (JsonNode) null); [EOL]     assertEquals(3, n.size()); [EOL]     assertTrue(n.has("null")); [EOL]     assertFalse(n.hasNonNull("null")); [EOL]     n.put("null", "notReallNull"); [EOL]     assertEquals(3, n.size()); [EOL]     assertNotNull(n.remove("null")); [EOL]     assertEquals(2, n.size()); [EOL]     Map<String, JsonNode> nodes = new HashMap<String, JsonNode>(); [EOL]     nodes.put("d", text); [EOL]     n.setAll(nodes); [EOL]     assertEquals(3, n.size()); [EOL]     n.removeAll(); [EOL]     assertEquals(0, n.size()); [EOL] }
public void testBasics() { [EOL]     ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [EOL]     assertStandardEquals(n); [EOL]     assertFalse(n.elements().hasNext()); [EOL]     assertFalse(n.fields().hasNext()); [EOL]     assertFalse(n.fieldNames().hasNext()); [EOL]     assertNull(n.get("a")); [EOL]     assertTrue(n.path("a").isMissingNode()); [EOL]     TextNode text = TextNode.valueOf("x"); [EOL]     n.set("a", text); [EOL]     assertEquals(1, n.size()); [EOL]     assertTrue(n.elements().hasNext()); [EOL]     assertTrue(n.fields().hasNext()); [EOL]     assertTrue(n.fieldNames().hasNext()); [EOL]     assertSame(text, n.get("a")); [EOL]     assertSame(text, n.path("a")); [EOL]     assertNull(n.get("b")); [EOL]     assertNull(n.get(0)); [EOL]     assertFalse(n.has(0)); [EOL]     assertFalse(n.hasNonNull(0)); [EOL]     assertTrue(n.has("a")); [EOL]     assertTrue(n.hasNonNull("a")); [EOL]     assertFalse(n.has("b")); [EOL]     assertFalse(n.hasNonNull("b")); [EOL]     ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance); [EOL]     n2.put("b", 13); [EOL]     assertFalse(n.equals(n2)); [EOL]     n.setAll(n2); [EOL]     assertEquals(2, n.size()); [EOL]     n.set("null", (JsonNode) null); [EOL]     assertEquals(3, n.size()); [EOL]     assertTrue(n.has("null")); [EOL]     assertFalse(n.hasNonNull("null")); [EOL]     n.put("null", "notReallNull"); [EOL]     assertEquals(3, n.size()); [EOL]     assertNotNull(n.remove("null")); [EOL]     assertEquals(2, n.size()); [EOL]     Map<String, JsonNode> nodes = new HashMap<String, JsonNode>(); [EOL]     nodes.put("d", text); [EOL]     n.setAll(nodes); [EOL]     assertEquals(3, n.size()); [EOL]     n.removeAll(); [EOL]     assertEquals(0, n.size()); [EOL] }
public void testBasics() { [EOL]     ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [EOL]     assertStandardEquals(n); [EOL]     assertFalse(n.elements().hasNext()); [EOL]     assertFalse(n.fields().hasNext()); [EOL]     assertFalse(n.fieldNames().hasNext()); [EOL]     assertNull(n.get("a")); [EOL]     assertTrue(n.path("a").isMissingNode()); [EOL]     TextNode text = TextNode.valueOf("x"); [EOL]     n.set("a", text); [EOL]     assertEquals(1, n.size()); [EOL]     assertTrue(n.elements().hasNext()); [EOL]     assertTrue(n.fields().hasNext()); [EOL]     assertTrue(n.fieldNames().hasNext()); [EOL]     assertSame(text, n.get("a")); [EOL]     assertSame(text, n.path("a")); [EOL]     assertNull(n.get("b")); [EOL]     assertNull(n.get(0)); [EOL]     assertFalse(n.has(0)); [EOL]     assertFalse(n.hasNonNull(0)); [EOL]     assertTrue(n.has("a")); [EOL]     assertTrue(n.hasNonNull("a")); [EOL]     assertFalse(n.has("b")); [EOL]     assertFalse(n.hasNonNull("b")); [EOL]     ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance); [EOL]     n2.put("b", 13); [EOL]     assertFalse(n.equals(n2)); [EOL]     n.setAll(n2); [EOL]     assertEquals(2, n.size()); [EOL]     n.set("null", (JsonNode) null); [EOL]     assertEquals(3, n.size()); [EOL]     assertTrue(n.has("null")); [EOL]     assertFalse(n.hasNonNull("null")); [EOL]     n.put("null", "notReallNull"); [EOL]     assertEquals(3, n.size()); [EOL]     assertNotNull(n.remove("null")); [EOL]     assertEquals(2, n.size()); [EOL]     Map<String, JsonNode> nodes = new HashMap<String, JsonNode>(); [EOL]     nodes.put("d", text); [EOL]     n.setAll(nodes); [EOL]     assertEquals(3, n.size()); [EOL]     n.removeAll(); [EOL]     assertEquals(0, n.size()); [EOL] }
public void testBasics() { [EOL]     ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [EOL]     assertStandardEquals(n); [EOL]     assertFalse(n.elements().hasNext()); [EOL]     assertFalse(n.fields().hasNext()); [EOL]     assertFalse(n.fieldNames().hasNext()); [EOL]     assertNull(n.get("a")); [EOL]     assertTrue(n.path("a").isMissingNode()); [EOL]     TextNode text = TextNode.valueOf("x"); [EOL]     n.set("a", text); [EOL]     assertEquals(1, n.size()); [EOL]     assertTrue(n.elements().hasNext()); [EOL]     assertTrue(n.fields().hasNext()); [EOL]     assertTrue(n.fieldNames().hasNext()); [EOL]     assertSame(text, n.get("a")); [EOL]     assertSame(text, n.path("a")); [EOL]     assertNull(n.get("b")); [EOL]     assertNull(n.get(0)); [EOL]     assertFalse(n.has(0)); [EOL]     assertFalse(n.hasNonNull(0)); [EOL]     assertTrue(n.has("a")); [EOL]     assertTrue(n.hasNonNull("a")); [EOL]     assertFalse(n.has("b")); [EOL]     assertFalse(n.hasNonNull("b")); [EOL]     ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance); [EOL]     n2.put("b", 13); [EOL]     assertFalse(n.equals(n2)); [EOL]     n.setAll(n2); [EOL]     assertEquals(2, n.size()); [EOL]     n.set("null", (JsonNode) null); [EOL]     assertEquals(3, n.size()); [EOL]     assertTrue(n.has("null")); [EOL]     assertFalse(n.hasNonNull("null")); [EOL]     n.put("null", "notReallNull"); [EOL]     assertEquals(3, n.size()); [EOL]     assertNotNull(n.remove("null")); [EOL]     assertEquals(2, n.size()); [EOL]     Map<String, JsonNode> nodes = new HashMap<String, JsonNode>(); [EOL]     nodes.put("d", text); [EOL]     n.setAll(nodes); [EOL]     assertEquals(3, n.size()); [EOL]     n.removeAll(); [EOL]     assertEquals(0, n.size()); [EOL] }
public void testBasics() { [EOL]     ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [EOL]     assertStandardEquals(n); [EOL]     assertFalse(n.elements().hasNext()); [EOL]     assertFalse(n.fields().hasNext()); [EOL]     assertFalse(n.fieldNames().hasNext()); [EOL]     assertNull(n.get("a")); [EOL]     assertTrue(n.path("a").isMissingNode()); [EOL]     TextNode text = TextNode.valueOf("x"); [EOL]     n.set("a", text); [EOL]     assertEquals(1, n.size()); [EOL]     assertTrue(n.elements().hasNext()); [EOL]     assertTrue(n.fields().hasNext()); [EOL]     assertTrue(n.fieldNames().hasNext()); [EOL]     assertSame(text, n.get("a")); [EOL]     assertSame(text, n.path("a")); [EOL]     assertNull(n.get("b")); [EOL]     assertNull(n.get(0)); [EOL]     assertFalse(n.has(0)); [EOL]     assertFalse(n.hasNonNull(0)); [EOL]     assertTrue(n.has("a")); [EOL]     assertTrue(n.hasNonNull("a")); [EOL]     assertFalse(n.has("b")); [EOL]     assertFalse(n.hasNonNull("b")); [EOL]     ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance); [EOL]     n2.put("b", 13); [EOL]     assertFalse(n.equals(n2)); [EOL]     n.setAll(n2); [EOL]     assertEquals(2, n.size()); [EOL]     n.set("null", (JsonNode) null); [EOL]     assertEquals(3, n.size()); [EOL]     assertTrue(n.has("null")); [EOL]     assertFalse(n.hasNonNull("null")); [EOL]     n.put("null", "notReallNull"); [EOL]     assertEquals(3, n.size()); [EOL]     assertNotNull(n.remove("null")); [EOL]     assertEquals(2, n.size()); [EOL]     Map<String, JsonNode> nodes = new HashMap<String, JsonNode>(); [EOL]     nodes.put("d", text); [EOL]     n.setAll(nodes); [EOL]     assertEquals(3, n.size()); [EOL]     n.removeAll(); [EOL]     assertEquals(0, n.size()); [EOL] }
public void testBasics() { [EOL]     ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [EOL]     assertStandardEquals(n); [EOL]     assertFalse(n.elements().hasNext()); [EOL]     assertFalse(n.fields().hasNext()); [EOL]     assertFalse(n.fieldNames().hasNext()); [EOL]     assertNull(n.get("a")); [EOL]     assertTrue(n.path("a").isMissingNode()); [EOL]     TextNode text = TextNode.valueOf("x"); [EOL]     n.set("a", text); [EOL]     assertEquals(1, n.size()); [EOL]     assertTrue(n.elements().hasNext()); [EOL]     assertTrue(n.fields().hasNext()); [EOL]     assertTrue(n.fieldNames().hasNext()); [EOL]     assertSame(text, n.get("a")); [EOL]     assertSame(text, n.path("a")); [EOL]     assertNull(n.get("b")); [EOL]     assertNull(n.get(0)); [EOL]     assertFalse(n.has(0)); [EOL]     assertFalse(n.hasNonNull(0)); [EOL]     assertTrue(n.has("a")); [EOL]     assertTrue(n.hasNonNull("a")); [EOL]     assertFalse(n.has("b")); [EOL]     assertFalse(n.hasNonNull("b")); [EOL]     ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance); [EOL]     n2.put("b", 13); [EOL]     assertFalse(n.equals(n2)); [EOL]     n.setAll(n2); [EOL]     assertEquals(2, n.size()); [EOL]     n.set("null", (JsonNode) null); [EOL]     assertEquals(3, n.size()); [EOL]     assertTrue(n.has("null")); [EOL]     assertFalse(n.hasNonNull("null")); [EOL]     n.put("null", "notReallNull"); [EOL]     assertEquals(3, n.size()); [EOL]     assertNotNull(n.remove("null")); [EOL]     assertEquals(2, n.size()); [EOL]     Map<String, JsonNode> nodes = new HashMap<String, JsonNode>(); [EOL]     nodes.put("d", text); [EOL]     n.setAll(nodes); [EOL]     assertEquals(3, n.size()); [EOL]     n.removeAll(); [EOL]     assertEquals(0, n.size()); [EOL] }
public void testBasics() { [EOL]     ObjectNode n = new ObjectNode(JsonNodeFactory.instance); [EOL]     assertStandardEquals(n); [EOL]     assertFalse(n.elements().hasNext()); [EOL]     assertFalse(n.fields().hasNext()); [EOL]     assertFalse(n.fieldNames().hasNext()); [EOL]     assertNull(n.get("a")); [EOL]     assertTrue(n.path("a").isMissingNode()); [EOL]     TextNode text = TextNode.valueOf("x"); [EOL]     n.set("a", text); [EOL]     assertEquals(1, n.size()); [EOL]     assertTrue(n.elements().hasNext()); [EOL]     assertTrue(n.fields().hasNext()); [EOL]     assertTrue(n.fieldNames().hasNext()); [EOL]     assertSame(text, n.get("a")); [EOL]     assertSame(text, n.path("a")); [EOL]     assertNull(n.get("b")); [EOL]     assertNull(n.get(0)); [EOL]     assertFalse(n.has(0)); [EOL]     assertFalse(n.hasNonNull(0)); [EOL]     assertTrue(n.has("a")); [EOL]     assertTrue(n.hasNonNull("a")); [EOL]     assertFalse(n.has("b")); [EOL]     assertFalse(n.hasNonNull("b")); [EOL]     ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance); [EOL]     n2.put("b", 13); [EOL]     assertFalse(n.equals(n2)); [EOL]     n.setAll(n2); [EOL]     assertEquals(2, n.size()); [EOL]     n.set("null", (JsonNode) null); [EOL]     assertEquals(3, n.size()); [EOL]     assertTrue(n.has("null")); [EOL]     assertFalse(n.hasNonNull("null")); [EOL]     n.put("null", "notReallNull"); [EOL]     assertEquals(3, n.size()); [EOL]     assertNotNull(n.remove("null")); [EOL]     assertEquals(2, n.size()); [EOL]     Map<String, JsonNode> nodes = new HashMap<String, JsonNode>(); [EOL]     nodes.put("d", text); [EOL]     n.setAll(nodes); [EOL]     assertEquals(3, n.size()); [EOL]     n.removeAll(); [EOL]     assertEquals(0, n.size()); [EOL] }
public void testGeneratingJsonSchema() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class); [EOL]     assertNotNull(jsonSchema); [EOL]     assertTrue(jsonSchema.equals(jsonSchema)); [EOL]     assertFalse(jsonSchema.equals(null)); [EOL]     assertFalse(jsonSchema.equals("foo")); [EOL]     assertNotNull(jsonSchema.toString()); [EOL]     assertNotNull(JsonSchema.getDefaultSchemaNode()); [EOL]     ObjectNode root = jsonSchema.getSchemaNode(); [EOL]     assertEquals("object", root.get("type").asText()); [EOL]     assertEquals(false, root.path("required").booleanValue()); [EOL]     JsonNode propertiesSchema = root.get("properties"); [EOL]     assertNotNull(propertiesSchema); [EOL]     JsonNode property1Schema = propertiesSchema.get("property1"); [EOL]     assertNotNull(property1Schema); [EOL]     assertEquals("integer", property1Schema.get("type").asText()); [EOL]     assertEquals(false, property1Schema.path("required").booleanValue()); [EOL]     JsonNode property2Schema = propertiesSchema.get("property2"); [EOL]     assertNotNull(property2Schema); [EOL]     assertEquals("string", property2Schema.get("type").asText()); [EOL]     assertEquals(false, property2Schema.path("required").booleanValue()); [EOL]     JsonNode property3Schema = propertiesSchema.get("property3"); [EOL]     assertNotNull(property3Schema); [EOL]     assertEquals("array", property3Schema.get("type").asText()); [EOL]     assertEquals(false, property3Schema.path("required").booleanValue()); [EOL]     assertEquals("string", property3Schema.get("items").get("type").asText()); [EOL]     JsonNode property4Schema = propertiesSchema.get("property4"); [EOL]     assertNotNull(property4Schema); [EOL]     assertEquals("array", property4Schema.get("type").asText()); [EOL]     assertEquals(false, property4Schema.path("required").booleanValue()); [EOL]     assertEquals("number", property4Schema.get("items").get("type").asText()); [EOL] }
public void testGeneratingJsonSchema() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class); [EOL]     assertNotNull(jsonSchema); [EOL]     assertTrue(jsonSchema.equals(jsonSchema)); [EOL]     assertFalse(jsonSchema.equals(null)); [EOL]     assertFalse(jsonSchema.equals("foo")); [EOL]     assertNotNull(jsonSchema.toString()); [EOL]     assertNotNull(JsonSchema.getDefaultSchemaNode()); [EOL]     ObjectNode root = jsonSchema.getSchemaNode(); [EOL]     assertEquals("object", root.get("type").asText()); [EOL]     assertEquals(false, root.path("required").booleanValue()); [EOL]     JsonNode propertiesSchema = root.get("properties"); [EOL]     assertNotNull(propertiesSchema); [EOL]     JsonNode property1Schema = propertiesSchema.get("property1"); [EOL]     assertNotNull(property1Schema); [EOL]     assertEquals("integer", property1Schema.get("type").asText()); [EOL]     assertEquals(false, property1Schema.path("required").booleanValue()); [EOL]     JsonNode property2Schema = propertiesSchema.get("property2"); [EOL]     assertNotNull(property2Schema); [EOL]     assertEquals("string", property2Schema.get("type").asText()); [EOL]     assertEquals(false, property2Schema.path("required").booleanValue()); [EOL]     JsonNode property3Schema = propertiesSchema.get("property3"); [EOL]     assertNotNull(property3Schema); [EOL]     assertEquals("array", property3Schema.get("type").asText()); [EOL]     assertEquals(false, property3Schema.path("required").booleanValue()); [EOL]     assertEquals("string", property3Schema.get("items").get("type").asText()); [EOL]     JsonNode property4Schema = propertiesSchema.get("property4"); [EOL]     assertNotNull(property4Schema); [EOL]     assertEquals("array", property4Schema.get("type").asText()); [EOL]     assertEquals(false, property4Schema.path("required").booleanValue()); [EOL]     assertEquals("number", property4Schema.get("items").get("type").asText()); [EOL] }
public void testGeneratingJsonSchema() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class); [EOL]     assertNotNull(jsonSchema); [EOL]     assertTrue(jsonSchema.equals(jsonSchema)); [EOL]     assertFalse(jsonSchema.equals(null)); [EOL]     assertFalse(jsonSchema.equals("foo")); [EOL]     assertNotNull(jsonSchema.toString()); [EOL]     assertNotNull(JsonSchema.getDefaultSchemaNode()); [EOL]     ObjectNode root = jsonSchema.getSchemaNode(); [EOL]     assertEquals("object", root.get("type").asText()); [EOL]     assertEquals(false, root.path("required").booleanValue()); [EOL]     JsonNode propertiesSchema = root.get("properties"); [EOL]     assertNotNull(propertiesSchema); [EOL]     JsonNode property1Schema = propertiesSchema.get("property1"); [EOL]     assertNotNull(property1Schema); [EOL]     assertEquals("integer", property1Schema.get("type").asText()); [EOL]     assertEquals(false, property1Schema.path("required").booleanValue()); [EOL]     JsonNode property2Schema = propertiesSchema.get("property2"); [EOL]     assertNotNull(property2Schema); [EOL]     assertEquals("string", property2Schema.get("type").asText()); [EOL]     assertEquals(false, property2Schema.path("required").booleanValue()); [EOL]     JsonNode property3Schema = propertiesSchema.get("property3"); [EOL]     assertNotNull(property3Schema); [EOL]     assertEquals("array", property3Schema.get("type").asText()); [EOL]     assertEquals(false, property3Schema.path("required").booleanValue()); [EOL]     assertEquals("string", property3Schema.get("items").get("type").asText()); [EOL]     JsonNode property4Schema = propertiesSchema.get("property4"); [EOL]     assertNotNull(property4Schema); [EOL]     assertEquals("array", property4Schema.get("type").asText()); [EOL]     assertEquals(false, property4Schema.path("required").booleanValue()); [EOL]     assertEquals("number", property4Schema.get("items").get("type").asText()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testCalendar() throws Exception { [EOL]     java.util.Calendar value = Calendar.getInstance(); [EOL]     long l = 12345678L; [EOL]     value.setTimeInMillis(l); [EOL]     Calendar result = MAPPER.readValue("" + l, Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL]     String dateStr = dateToString(new Date(l)); [EOL]     result = MAPPER.readValue(quote(dateStr), Calendar.class); [EOL]     assertEquals(l, result.getTimeInMillis()); [EOL] }
public void testReadingArrayAsTree() throws IOException { [EOL]     JsonFactory jf = new MappingJsonFactory(); [EOL]     final String JSON = "[ 1, 2, false ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = jf.createParser(new StringReader(JSON)); [EOL]         if (i == 0) { [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         } [EOL]         JsonNode root = (JsonNode) jp.readValueAsTree(); [EOL]         jp.close(); [EOL]         assertTrue(root.isArray()); [EOL]         assertEquals(3, root.size()); [EOL]         assertEquals(1, root.get(0).intValue()); [EOL]         assertEquals(2, root.get(1).intValue()); [EOL]         assertFalse(root.get(2).booleanValue()); [EOL]     } [EOL] }
public void testReadingArrayAsTree() throws IOException { [EOL]     JsonFactory jf = new MappingJsonFactory(); [EOL]     final String JSON = "[ 1, 2, false ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = jf.createParser(new StringReader(JSON)); [EOL]         if (i == 0) { [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         } [EOL]         JsonNode root = (JsonNode) jp.readValueAsTree(); [EOL]         jp.close(); [EOL]         assertTrue(root.isArray()); [EOL]         assertEquals(3, root.size()); [EOL]         assertEquals(1, root.get(0).intValue()); [EOL]         assertEquals(2, root.get(1).intValue()); [EOL]         assertFalse(root.get(2).booleanValue()); [EOL]     } [EOL] }
public void testReadingArrayAsTree() throws IOException { [EOL]     JsonFactory jf = new MappingJsonFactory(); [EOL]     final String JSON = "[ 1, 2, false ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = jf.createParser(new StringReader(JSON)); [EOL]         if (i == 0) { [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         } [EOL]         JsonNode root = (JsonNode) jp.readValueAsTree(); [EOL]         jp.close(); [EOL]         assertTrue(root.isArray()); [EOL]         assertEquals(3, root.size()); [EOL]         assertEquals(1, root.get(0).intValue()); [EOL]         assertEquals(2, root.get(1).intValue()); [EOL]         assertFalse(root.get(2).booleanValue()); [EOL]     } [EOL] }
public void testReadingArrayAsTree() throws IOException { [EOL]     JsonFactory jf = new MappingJsonFactory(); [EOL]     final String JSON = "[ 1, 2, false ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = jf.createParser(new StringReader(JSON)); [EOL]         if (i == 0) { [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         } [EOL]         JsonNode root = (JsonNode) jp.readValueAsTree(); [EOL]         jp.close(); [EOL]         assertTrue(root.isArray()); [EOL]         assertEquals(3, root.size()); [EOL]         assertEquals(1, root.get(0).intValue()); [EOL]         assertEquals(2, root.get(1).intValue()); [EOL]         assertFalse(root.get(2).booleanValue()); [EOL]     } [EOL] }
public void testReadingArrayAsTree() throws IOException { [EOL]     JsonFactory jf = new MappingJsonFactory(); [EOL]     final String JSON = "[ 1, 2, false ]"; [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         JsonParser jp = jf.createParser(new StringReader(JSON)); [EOL]         if (i == 0) { [EOL]             assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         } [EOL]         JsonNode root = (JsonNode) jp.readValueAsTree(); [EOL]         jp.close(); [EOL]         assertTrue(root.isArray()); [EOL]         assertEquals(3, root.size()); [EOL]         assertEquals(1, root.get(0).intValue()); [EOL]         assertEquals(2, root.get(1).intValue()); [EOL]         assertFalse(root.get(2).booleanValue()); [EOL]     } [EOL] }
public void testDataBind() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     JsonNode tree = m.readTree("{ \"name\" : \"Tatu\", \n" + "\"magicNumber\" : 42," + "\"kids\" : [ \"Leo\", \"Lila\", \"Leia\" ] \n" + "}"); [EOL]     Person tatu = m.treeToValue(tree, Person.class); [EOL]     assertNotNull(tatu); [EOL]     assertEquals(42, tatu.magicNumber); [EOL]     assertEquals("Tatu", tatu.name); [EOL]     assertNotNull(tatu.kids); [EOL]     assertEquals(3, tatu.kids.size()); [EOL]     assertEquals("Leo", tatu.kids.get(0)); [EOL]     assertEquals("Lila", tatu.kids.get(1)); [EOL]     assertEquals("Leia", tatu.kids.get(2)); [EOL] }
public void testFromArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ArrayNode root = mapper.createArrayNode(); [EOL]     root.add(TEXT1); [EOL]     root.add(3); [EOL]     ObjectNode obj = root.addObject(); [EOL]     obj.put(FIELD1, true); [EOL]     obj.putArray(FIELD2); [EOL]     root.add(false); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         StringWriter sw = new StringWriter(); [EOL]         if (i == 0) { [EOL]             JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]             root.serialize(gen, null); [EOL]             gen.close(); [EOL]         } else { [EOL]             mapper.writeValue(sw, root); [EOL]         } [EOL]         verifyFromArray(sw.toString()); [EOL]     } [EOL]     verifyFromArray(root.toString()); [EOL] }
public void testFromArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ArrayNode root = mapper.createArrayNode(); [EOL]     root.add(TEXT1); [EOL]     root.add(3); [EOL]     ObjectNode obj = root.addObject(); [EOL]     obj.put(FIELD1, true); [EOL]     obj.putArray(FIELD2); [EOL]     root.add(false); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         StringWriter sw = new StringWriter(); [EOL]         if (i == 0) { [EOL]             JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]             root.serialize(gen, null); [EOL]             gen.close(); [EOL]         } else { [EOL]             mapper.writeValue(sw, root); [EOL]         } [EOL]         verifyFromArray(sw.toString()); [EOL]     } [EOL]     verifyFromArray(root.toString()); [EOL] }
public void testFromArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ArrayNode root = mapper.createArrayNode(); [EOL]     root.add(TEXT1); [EOL]     root.add(3); [EOL]     ObjectNode obj = root.addObject(); [EOL]     obj.put(FIELD1, true); [EOL]     obj.putArray(FIELD2); [EOL]     root.add(false); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         StringWriter sw = new StringWriter(); [EOL]         if (i == 0) { [EOL]             JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]             root.serialize(gen, null); [EOL]             gen.close(); [EOL]         } else { [EOL]             mapper.writeValue(sw, root); [EOL]         } [EOL]         verifyFromArray(sw.toString()); [EOL]     } [EOL]     verifyFromArray(root.toString()); [EOL] }
public void testFromArray() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     ArrayNode root = mapper.createArrayNode(); [EOL]     root.add(TEXT1); [EOL]     root.add(3); [EOL]     ObjectNode obj = root.addObject(); [EOL]     obj.put(FIELD1, true); [EOL]     obj.putArray(FIELD2); [EOL]     root.add(false); [EOL]     for (int i = 0; i < 2; ++i) { [EOL]         StringWriter sw = new StringWriter(); [EOL]         if (i == 0) { [EOL]             JsonGenerator gen = new JsonFactory().createGenerator(sw); [EOL]             root.serialize(gen, null); [EOL]             gen.close(); [EOL]         } else { [EOL]             mapper.writeValue(sw, root); [EOL]         } [EOL]         verifyFromArray(sw.toString()); [EOL]     } [EOL]     verifyFromArray(root.toString()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testAdds() { [EOL]     ArrayNode n = new ArrayNode(JsonNodeFactory.instance); [EOL]     assertNotNull(n.addArray()); [EOL]     assertNotNull(n.addObject()); [EOL]     n.addPOJO("foobar"); [EOL]     n.add(1); [EOL]     n.add(1L); [EOL]     n.add(0.5); [EOL]     n.add(0.5f); [EOL]     assertEquals(7, n.size()); [EOL]     assertNotNull(n.insertArray(0)); [EOL]     assertNotNull(n.insertObject(0)); [EOL]     n.insertPOJO(2, "xxx"); [EOL]     assertEquals(10, n.size()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testFloat() { [EOL]     FloatNode n = FloatNode.valueOf(0.25f); [EOL]     assertStandardEquals(n); [EOL]     assertTrue(0 != n.hashCode()); [EOL]     assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken()); [EOL]     assertEquals(JsonParser.NumberType.FLOAT, n.numberType()); [EOL]     assertEquals(0, n.intValue()); [EOL]     assertEquals(0.25, n.doubleValue()); [EOL]     assertEquals(0.25f, n.floatValue()); [EOL]     assertNotNull(n.decimalValue()); [EOL]     assertEquals(BigInteger.ZERO, n.bigIntegerValue()); [EOL]     assertEquals("0.25", n.asText()); [EOL]     assertNodeNumbers(FloatNode.valueOf(4.5f), 4, 4.5f); [EOL]     assertTrue(FloatNode.valueOf(0).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(1000L + Integer.MAX_VALUE).canConvertToInt()); [EOL]     assertFalse(FloatNode.valueOf(-1000L + Integer.MIN_VALUE).canConvertToInt()); [EOL]     assertTrue(FloatNode.valueOf(0L).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MAX_VALUE).canConvertToLong()); [EOL]     assertTrue(FloatNode.valueOf(Integer.MIN_VALUE).canConvertToLong()); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testTwoInjectablesViaCreator() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.setInjectableValues(new InjectableValues.Std().addValue(String.class, "Bob").addValue("number", Integer.valueOf(13))); [EOL]     CtorBean2 bean = mapper.readValue("{ }", CtorBean2.class); [EOL]     assertEquals(Integer.valueOf(13), bean.age); [EOL]     assertEquals("Bob", bean.name); [EOL] }
public void testAnnotatedList() throws Exception { [EOL]     ObjectMapper mapper = _mapperWithAnnotatedContextual(); [EOL]     ContextualListBean bean = mapper.readValue("{\"beans\":[\"x\"]}", ContextualListBean.class); [EOL]     assertEquals(1, bean.beans.size()); [EOL]     assertEquals("list=x", bean.beans.get(0).value); [EOL]     bean = mapper.readValue("{\"beans\":[\"x\",\"y\",\"z\"]}", ContextualListBean.class); [EOL]     assertEquals(3, bean.beans.size()); [EOL]     assertEquals("list=x", bean.beans.get(0).value); [EOL]     assertEquals("list=y", bean.beans.get(1).value); [EOL]     assertEquals("list=z", bean.beans.get(2).value); [EOL] }
public void testAnnotatedList() throws Exception { [EOL]     ObjectMapper mapper = _mapperWithAnnotatedContextual(); [EOL]     ContextualListBean bean = mapper.readValue("{\"beans\":[\"x\"]}", ContextualListBean.class); [EOL]     assertEquals(1, bean.beans.size()); [EOL]     assertEquals("list=x", bean.beans.get(0).value); [EOL]     bean = mapper.readValue("{\"beans\":[\"x\",\"y\",\"z\"]}", ContextualListBean.class); [EOL]     assertEquals(3, bean.beans.size()); [EOL]     assertEquals("list=x", bean.beans.get(0).value); [EOL]     assertEquals("list=y", bean.beans.get(1).value); [EOL]     assertEquals("list=z", bean.beans.get(2).value); [EOL] }
public void testDecimalNode() throws Exception { [EOL]     BigDecimal value = new BigDecimal("0.1"); [EOL]     JsonNode result = DecimalNode.valueOf(value); [EOL]     assertFalse(result.isArray()); [EOL]     assertFalse(result.isObject()); [EOL]     assertTrue(result.isNumber()); [EOL]     assertFalse(result.isIntegralNumber()); [EOL]     assertFalse(result.isLong()); [EOL]     assertType(result, DecimalNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertTrue(result.isFloatingPointNumber()); [EOL]     assertTrue(result.isBigDecimal()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue()); [EOL]     assertEquals(value.toString(), result.asText()); [EOL]     assertEquals(result, DecimalNode.valueOf(value)); [EOL] }
public void testDecimalNode() throws Exception { [EOL]     BigDecimal value = new BigDecimal("0.1"); [EOL]     JsonNode result = DecimalNode.valueOf(value); [EOL]     assertFalse(result.isArray()); [EOL]     assertFalse(result.isObject()); [EOL]     assertTrue(result.isNumber()); [EOL]     assertFalse(result.isIntegralNumber()); [EOL]     assertFalse(result.isLong()); [EOL]     assertType(result, DecimalNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertTrue(result.isFloatingPointNumber()); [EOL]     assertTrue(result.isBigDecimal()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue()); [EOL]     assertEquals(value.toString(), result.asText()); [EOL]     assertEquals(result, DecimalNode.valueOf(value)); [EOL] }
public void testDecimalNode() throws Exception { [EOL]     BigDecimal value = new BigDecimal("0.1"); [EOL]     JsonNode result = DecimalNode.valueOf(value); [EOL]     assertFalse(result.isArray()); [EOL]     assertFalse(result.isObject()); [EOL]     assertTrue(result.isNumber()); [EOL]     assertFalse(result.isIntegralNumber()); [EOL]     assertFalse(result.isLong()); [EOL]     assertType(result, DecimalNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertTrue(result.isFloatingPointNumber()); [EOL]     assertTrue(result.isBigDecimal()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue()); [EOL]     assertEquals(value.toString(), result.asText()); [EOL]     assertEquals(result, DecimalNode.valueOf(value)); [EOL] }
public void testDecimalNode() throws Exception { [EOL]     BigDecimal value = new BigDecimal("0.1"); [EOL]     JsonNode result = DecimalNode.valueOf(value); [EOL]     assertFalse(result.isArray()); [EOL]     assertFalse(result.isObject()); [EOL]     assertTrue(result.isNumber()); [EOL]     assertFalse(result.isIntegralNumber()); [EOL]     assertFalse(result.isLong()); [EOL]     assertType(result, DecimalNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertTrue(result.isFloatingPointNumber()); [EOL]     assertTrue(result.isBigDecimal()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue()); [EOL]     assertEquals(value.toString(), result.asText()); [EOL]     assertEquals(result, DecimalNode.valueOf(value)); [EOL] }
public void testDecimalNode() throws Exception { [EOL]     BigDecimal value = new BigDecimal("0.1"); [EOL]     JsonNode result = DecimalNode.valueOf(value); [EOL]     assertFalse(result.isArray()); [EOL]     assertFalse(result.isObject()); [EOL]     assertTrue(result.isNumber()); [EOL]     assertFalse(result.isIntegralNumber()); [EOL]     assertFalse(result.isLong()); [EOL]     assertType(result, DecimalNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertTrue(result.isFloatingPointNumber()); [EOL]     assertTrue(result.isBigDecimal()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue()); [EOL]     assertEquals(value.toString(), result.asText()); [EOL]     assertEquals(result, DecimalNode.valueOf(value)); [EOL] }
public void testDecimalNode() throws Exception { [EOL]     BigDecimal value = new BigDecimal("0.1"); [EOL]     JsonNode result = DecimalNode.valueOf(value); [EOL]     assertFalse(result.isArray()); [EOL]     assertFalse(result.isObject()); [EOL]     assertTrue(result.isNumber()); [EOL]     assertFalse(result.isIntegralNumber()); [EOL]     assertFalse(result.isLong()); [EOL]     assertType(result, DecimalNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertTrue(result.isFloatingPointNumber()); [EOL]     assertTrue(result.isBigDecimal()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue()); [EOL]     assertEquals(value.toString(), result.asText()); [EOL]     assertEquals(result, DecimalNode.valueOf(value)); [EOL] }
public void testDecimalNode() throws Exception { [EOL]     BigDecimal value = new BigDecimal("0.1"); [EOL]     JsonNode result = DecimalNode.valueOf(value); [EOL]     assertFalse(result.isArray()); [EOL]     assertFalse(result.isObject()); [EOL]     assertTrue(result.isNumber()); [EOL]     assertFalse(result.isIntegralNumber()); [EOL]     assertFalse(result.isLong()); [EOL]     assertType(result, DecimalNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertTrue(result.isFloatingPointNumber()); [EOL]     assertTrue(result.isBigDecimal()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue()); [EOL]     assertEquals(value.toString(), result.asText()); [EOL]     assertEquals(result, DecimalNode.valueOf(value)); [EOL] }
public void testDecimalNode() throws Exception { [EOL]     BigDecimal value = new BigDecimal("0.1"); [EOL]     JsonNode result = DecimalNode.valueOf(value); [EOL]     assertFalse(result.isArray()); [EOL]     assertFalse(result.isObject()); [EOL]     assertTrue(result.isNumber()); [EOL]     assertFalse(result.isIntegralNumber()); [EOL]     assertFalse(result.isLong()); [EOL]     assertType(result, DecimalNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertTrue(result.isFloatingPointNumber()); [EOL]     assertTrue(result.isBigDecimal()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue()); [EOL]     assertEquals(value.toString(), result.asText()); [EOL]     assertEquals(result, DecimalNode.valueOf(value)); [EOL] }
public void testDecimalNode() throws Exception { [EOL]     BigDecimal value = new BigDecimal("0.1"); [EOL]     JsonNode result = DecimalNode.valueOf(value); [EOL]     assertFalse(result.isArray()); [EOL]     assertFalse(result.isObject()); [EOL]     assertTrue(result.isNumber()); [EOL]     assertFalse(result.isIntegralNumber()); [EOL]     assertFalse(result.isLong()); [EOL]     assertType(result, DecimalNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertTrue(result.isFloatingPointNumber()); [EOL]     assertTrue(result.isBigDecimal()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue()); [EOL]     assertEquals(value.toString(), result.asText()); [EOL]     assertEquals(result, DecimalNode.valueOf(value)); [EOL] }
public void testDecimalNode() throws Exception { [EOL]     BigDecimal value = new BigDecimal("0.1"); [EOL]     JsonNode result = DecimalNode.valueOf(value); [EOL]     assertFalse(result.isArray()); [EOL]     assertFalse(result.isObject()); [EOL]     assertTrue(result.isNumber()); [EOL]     assertFalse(result.isIntegralNumber()); [EOL]     assertFalse(result.isLong()); [EOL]     assertType(result, DecimalNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertTrue(result.isFloatingPointNumber()); [EOL]     assertTrue(result.isBigDecimal()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue()); [EOL]     assertEquals(value.toString(), result.asText()); [EOL]     assertEquals(result, DecimalNode.valueOf(value)); [EOL] }
public void testDecimalNode() throws Exception { [EOL]     BigDecimal value = new BigDecimal("0.1"); [EOL]     JsonNode result = DecimalNode.valueOf(value); [EOL]     assertFalse(result.isArray()); [EOL]     assertFalse(result.isObject()); [EOL]     assertTrue(result.isNumber()); [EOL]     assertFalse(result.isIntegralNumber()); [EOL]     assertFalse(result.isLong()); [EOL]     assertType(result, DecimalNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertTrue(result.isFloatingPointNumber()); [EOL]     assertTrue(result.isBigDecimal()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue()); [EOL]     assertEquals(value.toString(), result.asText()); [EOL]     assertEquals(result, DecimalNode.valueOf(value)); [EOL] }
public void testDecimalNode() throws Exception { [EOL]     BigDecimal value = new BigDecimal("0.1"); [EOL]     JsonNode result = DecimalNode.valueOf(value); [EOL]     assertFalse(result.isArray()); [EOL]     assertFalse(result.isObject()); [EOL]     assertTrue(result.isNumber()); [EOL]     assertFalse(result.isIntegralNumber()); [EOL]     assertFalse(result.isLong()); [EOL]     assertType(result, DecimalNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertTrue(result.isFloatingPointNumber()); [EOL]     assertTrue(result.isBigDecimal()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue()); [EOL]     assertEquals(value.toString(), result.asText()); [EOL]     assertEquals(result, DecimalNode.valueOf(value)); [EOL] }
public void testDecimalNode() throws Exception { [EOL]     BigDecimal value = new BigDecimal("0.1"); [EOL]     JsonNode result = DecimalNode.valueOf(value); [EOL]     assertFalse(result.isArray()); [EOL]     assertFalse(result.isObject()); [EOL]     assertTrue(result.isNumber()); [EOL]     assertFalse(result.isIntegralNumber()); [EOL]     assertFalse(result.isLong()); [EOL]     assertType(result, DecimalNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertTrue(result.isFloatingPointNumber()); [EOL]     assertTrue(result.isBigDecimal()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue()); [EOL]     assertEquals(value.toString(), result.asText()); [EOL]     assertEquals(result, DecimalNode.valueOf(value)); [EOL] }
public void testDecimalNode() throws Exception { [EOL]     BigDecimal value = new BigDecimal("0.1"); [EOL]     JsonNode result = DecimalNode.valueOf(value); [EOL]     assertFalse(result.isArray()); [EOL]     assertFalse(result.isObject()); [EOL]     assertTrue(result.isNumber()); [EOL]     assertFalse(result.isIntegralNumber()); [EOL]     assertFalse(result.isLong()); [EOL]     assertType(result, DecimalNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertTrue(result.isFloatingPointNumber()); [EOL]     assertTrue(result.isBigDecimal()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue()); [EOL]     assertEquals(value.toString(), result.asText()); [EOL]     assertEquals(result, DecimalNode.valueOf(value)); [EOL] }
public void testDecimalNode() throws Exception { [EOL]     BigDecimal value = new BigDecimal("0.1"); [EOL]     JsonNode result = DecimalNode.valueOf(value); [EOL]     assertFalse(result.isArray()); [EOL]     assertFalse(result.isObject()); [EOL]     assertTrue(result.isNumber()); [EOL]     assertFalse(result.isIntegralNumber()); [EOL]     assertFalse(result.isLong()); [EOL]     assertType(result, DecimalNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertTrue(result.isFloatingPointNumber()); [EOL]     assertTrue(result.isBigDecimal()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue()); [EOL]     assertEquals(value.toString(), result.asText()); [EOL]     assertEquals(result, DecimalNode.valueOf(value)); [EOL] }
public void testDecimalNode() throws Exception { [EOL]     BigDecimal value = new BigDecimal("0.1"); [EOL]     JsonNode result = DecimalNode.valueOf(value); [EOL]     assertFalse(result.isArray()); [EOL]     assertFalse(result.isObject()); [EOL]     assertTrue(result.isNumber()); [EOL]     assertFalse(result.isIntegralNumber()); [EOL]     assertFalse(result.isLong()); [EOL]     assertType(result, DecimalNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertTrue(result.isFloatingPointNumber()); [EOL]     assertTrue(result.isBigDecimal()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue()); [EOL]     assertEquals(value.toString(), result.asText()); [EOL]     assertEquals(result, DecimalNode.valueOf(value)); [EOL] }
public void testDecimalNode() throws Exception { [EOL]     BigDecimal value = new BigDecimal("0.1"); [EOL]     JsonNode result = DecimalNode.valueOf(value); [EOL]     assertFalse(result.isArray()); [EOL]     assertFalse(result.isObject()); [EOL]     assertTrue(result.isNumber()); [EOL]     assertFalse(result.isIntegralNumber()); [EOL]     assertFalse(result.isLong()); [EOL]     assertType(result, DecimalNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertTrue(result.isFloatingPointNumber()); [EOL]     assertTrue(result.isBigDecimal()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue()); [EOL]     assertEquals(value.toString(), result.asText()); [EOL]     assertEquals(result, DecimalNode.valueOf(value)); [EOL] }
public void testDecimalNode() throws Exception { [EOL]     BigDecimal value = new BigDecimal("0.1"); [EOL]     JsonNode result = DecimalNode.valueOf(value); [EOL]     assertFalse(result.isArray()); [EOL]     assertFalse(result.isObject()); [EOL]     assertTrue(result.isNumber()); [EOL]     assertFalse(result.isIntegralNumber()); [EOL]     assertFalse(result.isLong()); [EOL]     assertType(result, DecimalNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertTrue(result.isFloatingPointNumber()); [EOL]     assertTrue(result.isBigDecimal()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue()); [EOL]     assertEquals(value.toString(), result.asText()); [EOL]     assertEquals(result, DecimalNode.valueOf(value)); [EOL] }
public void testDecimalNode() throws Exception { [EOL]     BigDecimal value = new BigDecimal("0.1"); [EOL]     JsonNode result = DecimalNode.valueOf(value); [EOL]     assertFalse(result.isArray()); [EOL]     assertFalse(result.isObject()); [EOL]     assertTrue(result.isNumber()); [EOL]     assertFalse(result.isIntegralNumber()); [EOL]     assertFalse(result.isLong()); [EOL]     assertType(result, DecimalNode.class); [EOL]     assertFalse(result.isInt()); [EOL]     assertTrue(result.isFloatingPointNumber()); [EOL]     assertTrue(result.isBigDecimal()); [EOL]     assertFalse(result.isDouble()); [EOL]     assertFalse(result.isNull()); [EOL]     assertFalse(result.isTextual()); [EOL]     assertFalse(result.isMissingNode()); [EOL]     assertEquals(value, result.numberValue()); [EOL]     assertEquals(value.toString(), result.asText()); [EOL]     assertEquals(result, DecimalNode.valueOf(value)); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testByteArrayFrom() throws Exception { [EOL]     byte[] data = _convert("c3VyZS4=", byte[].class); [EOL]     byte[] exp = "sure.".getBytes("Ascii"); [EOL]     verifyIntegralArrays(exp, data, exp.length); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testBooleanArray() throws Exception { [EOL]     assertEquals("[true,false]", serializeAsString(MAPPER, new boolean[] { true, false })); [EOL]     assertEquals("[true,false]", serializeAsString(MAPPER, new Boolean[] { Boolean.TRUE, Boolean.FALSE })); [EOL] }
public void testBooleanArray() throws Exception { [EOL]     assertEquals("[true,false]", serializeAsString(MAPPER, new boolean[] { true, false })); [EOL]     assertEquals("[true,false]", serializeAsString(MAPPER, new Boolean[] { Boolean.TRUE, Boolean.FALSE })); [EOL] }
public void testBooleanArray() throws Exception { [EOL]     assertEquals("[true,false]", serializeAsString(MAPPER, new boolean[] { true, false })); [EOL]     assertEquals("[true,false]", serializeAsString(MAPPER, new Boolean[] { Boolean.TRUE, Boolean.FALSE })); [EOL] }
public void testShortArrayToX() throws Exception { [EOL]     short[] data = shorts(); [EOL]     verifyShortArrayConversion(data, byte[].class); [EOL]     verifyShortArrayConversion(data, int[].class); [EOL]     verifyShortArrayConversion(data, long[].class); [EOL] }
public void testShortArrayToX() throws Exception { [EOL]     short[] data = shorts(); [EOL]     verifyShortArrayConversion(data, byte[].class); [EOL]     verifyShortArrayConversion(data, int[].class); [EOL]     verifyShortArrayConversion(data, long[].class); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testSingleElementCollections() throws IOException { [EOL]     final ObjectWriter writer = objectWriter().with(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED); [EOL]     ArrayList<String> strs = new ArrayList<String>(); [EOL]     strs.add("xyz"); [EOL]     assertEquals(quote("xyz"), writer.writeValueAsString(strs)); [EOL]     ArrayList<Integer> ints = new ArrayList<Integer>(); [EOL]     ints.add(13); [EOL]     assertEquals("13", writer.writeValueAsString(ints)); [EOL]     HashSet<Long> longs = new HashSet<Long>(); [EOL]     longs.add(42L); [EOL]     assertEquals("42", writer.writeValueAsString(longs)); [EOL]     final String EXP_STRINGS = "{\"values\":\"foo\"}"; [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(Collections.singletonList("foo")))); [EOL]     final Set<String> SET = new HashSet<String>(); [EOL]     SET.add("foo"); [EOL]     assertEquals(EXP_STRINGS, writer.writeValueAsString(new StringListBean(SET))); [EOL]     assertEquals("true", writer.writeValueAsString(new boolean[] { true })); [EOL]     assertEquals("true", writer.writeValueAsString(new Boolean[] { Boolean.TRUE })); [EOL]     assertEquals("3", writer.writeValueAsString(new int[] { 3 })); [EOL]     assertEquals(quote("foo"), writer.writeValueAsString(new String[] { "foo" })); [EOL] }
public void testBigIntArray() throws Exception { [EOL]     final int SIZE = 99999; [EOL]     int[] ints = new int[SIZE]; [EOL]     for (int i = 0; i < ints.length; ++i) { [EOL]         ints[i] = i; [EOL]     } [EOL]     JsonFactory f = MAPPER.getFactory(); [EOL]     for (int round = 0; round < 3; ++round) { [EOL]         byte[] data = MAPPER.writeValueAsBytes(ints); [EOL]         JsonParser jp = f.createParser(data); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < SIZE; ++i) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertEquals(i, jp.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     } [EOL] }
public void testBigIntArray() throws Exception { [EOL]     final int SIZE = 99999; [EOL]     int[] ints = new int[SIZE]; [EOL]     for (int i = 0; i < ints.length; ++i) { [EOL]         ints[i] = i; [EOL]     } [EOL]     JsonFactory f = MAPPER.getFactory(); [EOL]     for (int round = 0; round < 3; ++round) { [EOL]         byte[] data = MAPPER.writeValueAsBytes(ints); [EOL]         JsonParser jp = f.createParser(data); [EOL]         assertToken(JsonToken.START_ARRAY, jp.nextToken()); [EOL]         for (int i = 0; i < SIZE; ++i) { [EOL]             assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken()); [EOL]             assertEquals(i, jp.getIntValue()); [EOL]         } [EOL]         assertToken(JsonToken.END_ARRAY, jp.nextToken()); [EOL]     } [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testMapTypesRaw() { [EOL]     TypeFactory tf = TypeFactory.defaultInstance(); [EOL]     JavaType type = tf.constructType(HashMap.class); [EOL]     MapType mapType = (MapType) type; [EOL]     assertEquals(tf.constructType(Object.class), mapType.getKeyType()); [EOL]     assertEquals(tf.constructType(Object.class), mapType.getContentType()); [EOL] }
public void testAnnotatedMap() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     AnnotatedMap result = mapper.readValue("{\"a\":true }", AnnotatedMap.class); [EOL]     assertEquals(1, result.size()); [EOL]     Map.Entry<Object, Object> en = result.entrySet().iterator().next(); [EOL]     assertEquals(StringWrapper.class, en.getKey().getClass()); [EOL]     assertEquals(BooleanWrapper.class, en.getValue().getClass()); [EOL]     assertEquals("a", ((StringWrapper) en.getKey()).str); [EOL]     assertEquals(Boolean.TRUE, ((BooleanWrapper) en.getValue()).b); [EOL] }
public void testAnnotatedMap() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     AnnotatedMap result = mapper.readValue("{\"a\":true }", AnnotatedMap.class); [EOL]     assertEquals(1, result.size()); [EOL]     Map.Entry<Object, Object> en = result.entrySet().iterator().next(); [EOL]     assertEquals(StringWrapper.class, en.getKey().getClass()); [EOL]     assertEquals(BooleanWrapper.class, en.getValue().getClass()); [EOL]     assertEquals("a", ((StringWrapper) en.getKey()).str); [EOL]     assertEquals(Boolean.TRUE, ((BooleanWrapper) en.getValue()).b); [EOL] }
public void testSerializedAsMapWithPropertyAnnotations() throws IOException { [EOL]     MapWrapperSimple input = new MapWrapperSimple("a", "b"); [EOL]     assertEquals("{\"values\":{\"toString:a\":{\"value\":\"b\"}}}", MAPPER.writeValueAsString(input)); [EOL] }
public void testSerializedAsMapWithPropertyAnnotations() throws IOException { [EOL]     MapWrapperSimple input = new MapWrapperSimple("a", "b"); [EOL]     assertEquals("{\"values\":{\"toString:a\":{\"value\":\"b\"}}}", MAPPER.writeValueAsString(input)); [EOL] }
public void testAnnotatedMap() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     AnnotatedMap result = mapper.readValue("{\"a\":true }", AnnotatedMap.class); [EOL]     assertEquals(1, result.size()); [EOL]     Map.Entry<Object, Object> en = result.entrySet().iterator().next(); [EOL]     assertEquals(StringWrapper.class, en.getKey().getClass()); [EOL]     assertEquals(BooleanWrapper.class, en.getValue().getClass()); [EOL]     assertEquals("a", ((StringWrapper) en.getKey()).str); [EOL]     assertEquals(Boolean.TRUE, ((BooleanWrapper) en.getValue()).b); [EOL] }
public void testAnnotatedMap() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     AnnotatedMap result = mapper.readValue("{\"a\":true }", AnnotatedMap.class); [EOL]     assertEquals(1, result.size()); [EOL]     Map.Entry<Object, Object> en = result.entrySet().iterator().next(); [EOL]     assertEquals(StringWrapper.class, en.getKey().getClass()); [EOL]     assertEquals(BooleanWrapper.class, en.getValue().getClass()); [EOL]     assertEquals("a", ((StringWrapper) en.getKey()).str); [EOL]     assertEquals(Boolean.TRUE, ((BooleanWrapper) en.getValue()).b); [EOL] }
public void testCalendarDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     String exp = cal.toXMLFormat(); [EOL]     assertEquals("Should deserialize to equal XMLGregorianCalendar ('" + exp + "')", cal, new ObjectMapper().readValue(quote(exp), XMLGregorianCalendar.class)); [EOL] }
public void testCalendarDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     String exp = cal.toXMLFormat(); [EOL]     assertEquals("Should deserialize to equal XMLGregorianCalendar ('" + exp + "')", cal, new ObjectMapper().readValue(quote(exp), XMLGregorianCalendar.class)); [EOL] }
public void testCalendarDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     String exp = cal.toXMLFormat(); [EOL]     assertEquals("Should deserialize to equal XMLGregorianCalendar ('" + exp + "')", cal, new ObjectMapper().readValue(quote(exp), XMLGregorianCalendar.class)); [EOL] }
public void testCalendarDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     String exp = cal.toXMLFormat(); [EOL]     assertEquals("Should deserialize to equal XMLGregorianCalendar ('" + exp + "')", cal, new ObjectMapper().readValue(quote(exp), XMLGregorianCalendar.class)); [EOL] }
public void testCalendarDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     String exp = cal.toXMLFormat(); [EOL]     assertEquals("Should deserialize to equal XMLGregorianCalendar ('" + exp + "')", cal, new ObjectMapper().readValue(quote(exp), XMLGregorianCalendar.class)); [EOL] }
public void testCalendarDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     String exp = cal.toXMLFormat(); [EOL]     assertEquals("Should deserialize to equal XMLGregorianCalendar ('" + exp + "')", cal, new ObjectMapper().readValue(quote(exp), XMLGregorianCalendar.class)); [EOL] }
public void testCalendarDeser() throws Exception { [EOL]     DatatypeFactory dtf = DatatypeFactory.newInstance(); [EOL]     XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar(1974, 10, 10, 18, 15, 17, 123, 0); [EOL]     String exp = cal.toXMLFormat(); [EOL]     assertEquals("Should deserialize to equal XMLGregorianCalendar ('" + exp + "')", cal, new ObjectMapper().readValue(quote(exp), XMLGregorianCalendar.class)); [EOL] }
public void testDeepUnwrappingSerialize() throws Exception { [EOL]     assertEquals("{\"name\":\"Tatu\",\"x\":1,\"y\":2}", mapper.writeValueAsString(new DeepUnwrapping("Tatu", 1, 2))); [EOL] }
public void testDeepUnwrappingSerialize() throws Exception { [EOL]     assertEquals("{\"name\":\"Tatu\",\"x\":1,\"y\":2}", mapper.writeValueAsString(new DeepUnwrapping("Tatu", 1, 2))); [EOL] }
public void testPropertyReorder() throws Exception { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     mapper.registerModule(new ModuleImpl(new ReorderingModifier())); [EOL]     Bean bean = new Bean(); [EOL]     assertEquals("{\"a\":\"a\",\"b\":\"b\"}", mapper.writeValueAsString(bean)); [EOL] }
public void testSchemaId() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class); [EOL]     String json = jsonSchema.toString().replaceAll("\"", "'"); [EOL]     assertEquals("{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}", json); [EOL] }
public void testSchemaId() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class); [EOL]     String json = jsonSchema.toString().replaceAll("\"", "'"); [EOL]     assertEquals("{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}", json); [EOL] }
public void testSchemaId() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class); [EOL]     String json = jsonSchema.toString().replaceAll("\"", "'"); [EOL]     assertEquals("{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}", json); [EOL] }
public void testGeneratingJsonSchema() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class); [EOL]     assertNotNull(jsonSchema); [EOL]     assertTrue(jsonSchema.equals(jsonSchema)); [EOL]     assertFalse(jsonSchema.equals(null)); [EOL]     assertFalse(jsonSchema.equals("foo")); [EOL]     assertNotNull(jsonSchema.toString()); [EOL]     assertNotNull(JsonSchema.getDefaultSchemaNode()); [EOL]     ObjectNode root = jsonSchema.getSchemaNode(); [EOL]     assertEquals("object", root.get("type").asText()); [EOL]     assertEquals(false, root.path("required").booleanValue()); [EOL]     JsonNode propertiesSchema = root.get("properties"); [EOL]     assertNotNull(propertiesSchema); [EOL]     JsonNode property1Schema = propertiesSchema.get("property1"); [EOL]     assertNotNull(property1Schema); [EOL]     assertEquals("integer", property1Schema.get("type").asText()); [EOL]     assertEquals(false, property1Schema.path("required").booleanValue()); [EOL]     JsonNode property2Schema = propertiesSchema.get("property2"); [EOL]     assertNotNull(property2Schema); [EOL]     assertEquals("string", property2Schema.get("type").asText()); [EOL]     assertEquals(false, property2Schema.path("required").booleanValue()); [EOL]     JsonNode property3Schema = propertiesSchema.get("property3"); [EOL]     assertNotNull(property3Schema); [EOL]     assertEquals("array", property3Schema.get("type").asText()); [EOL]     assertEquals(false, property3Schema.path("required").booleanValue()); [EOL]     assertEquals("string", property3Schema.get("items").get("type").asText()); [EOL]     JsonNode property4Schema = propertiesSchema.get("property4"); [EOL]     assertNotNull(property4Schema); [EOL]     assertEquals("array", property4Schema.get("type").asText()); [EOL]     assertEquals(false, property4Schema.path("required").booleanValue()); [EOL]     assertEquals("number", property4Schema.get("items").get("type").asText()); [EOL] }
public void testGeneratingJsonSchema() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class); [EOL]     assertNotNull(jsonSchema); [EOL]     assertTrue(jsonSchema.equals(jsonSchema)); [EOL]     assertFalse(jsonSchema.equals(null)); [EOL]     assertFalse(jsonSchema.equals("foo")); [EOL]     assertNotNull(jsonSchema.toString()); [EOL]     assertNotNull(JsonSchema.getDefaultSchemaNode()); [EOL]     ObjectNode root = jsonSchema.getSchemaNode(); [EOL]     assertEquals("object", root.get("type").asText()); [EOL]     assertEquals(false, root.path("required").booleanValue()); [EOL]     JsonNode propertiesSchema = root.get("properties"); [EOL]     assertNotNull(propertiesSchema); [EOL]     JsonNode property1Schema = propertiesSchema.get("property1"); [EOL]     assertNotNull(property1Schema); [EOL]     assertEquals("integer", property1Schema.get("type").asText()); [EOL]     assertEquals(false, property1Schema.path("required").booleanValue()); [EOL]     JsonNode property2Schema = propertiesSchema.get("property2"); [EOL]     assertNotNull(property2Schema); [EOL]     assertEquals("string", property2Schema.get("type").asText()); [EOL]     assertEquals(false, property2Schema.path("required").booleanValue()); [EOL]     JsonNode property3Schema = propertiesSchema.get("property3"); [EOL]     assertNotNull(property3Schema); [EOL]     assertEquals("array", property3Schema.get("type").asText()); [EOL]     assertEquals(false, property3Schema.path("required").booleanValue()); [EOL]     assertEquals("string", property3Schema.get("items").get("type").asText()); [EOL]     JsonNode property4Schema = propertiesSchema.get("property4"); [EOL]     assertNotNull(property4Schema); [EOL]     assertEquals("array", property4Schema.get("type").asText()); [EOL]     assertEquals(false, property4Schema.path("required").booleanValue()); [EOL]     assertEquals("number", property4Schema.get("items").get("type").asText()); [EOL] }
public void testGeneratingJsonSchema() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class); [EOL]     assertNotNull(jsonSchema); [EOL]     assertTrue(jsonSchema.equals(jsonSchema)); [EOL]     assertFalse(jsonSchema.equals(null)); [EOL]     assertFalse(jsonSchema.equals("foo")); [EOL]     assertNotNull(jsonSchema.toString()); [EOL]     assertNotNull(JsonSchema.getDefaultSchemaNode()); [EOL]     ObjectNode root = jsonSchema.getSchemaNode(); [EOL]     assertEquals("object", root.get("type").asText()); [EOL]     assertEquals(false, root.path("required").booleanValue()); [EOL]     JsonNode propertiesSchema = root.get("properties"); [EOL]     assertNotNull(propertiesSchema); [EOL]     JsonNode property1Schema = propertiesSchema.get("property1"); [EOL]     assertNotNull(property1Schema); [EOL]     assertEquals("integer", property1Schema.get("type").asText()); [EOL]     assertEquals(false, property1Schema.path("required").booleanValue()); [EOL]     JsonNode property2Schema = propertiesSchema.get("property2"); [EOL]     assertNotNull(property2Schema); [EOL]     assertEquals("string", property2Schema.get("type").asText()); [EOL]     assertEquals(false, property2Schema.path("required").booleanValue()); [EOL]     JsonNode property3Schema = propertiesSchema.get("property3"); [EOL]     assertNotNull(property3Schema); [EOL]     assertEquals("array", property3Schema.get("type").asText()); [EOL]     assertEquals(false, property3Schema.path("required").booleanValue()); [EOL]     assertEquals("string", property3Schema.get("items").get("type").asText()); [EOL]     JsonNode property4Schema = propertiesSchema.get("property4"); [EOL]     assertNotNull(property4Schema); [EOL]     assertEquals("array", property4Schema.get("type").asText()); [EOL]     assertEquals(false, property4Schema.path("required").booleanValue()); [EOL]     assertEquals("number", property4Schema.get("items").get("type").asText()); [EOL] }
public void testGeneratingJsonSchema() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class); [EOL]     assertNotNull(jsonSchema); [EOL]     assertTrue(jsonSchema.equals(jsonSchema)); [EOL]     assertFalse(jsonSchema.equals(null)); [EOL]     assertFalse(jsonSchema.equals("foo")); [EOL]     assertNotNull(jsonSchema.toString()); [EOL]     assertNotNull(JsonSchema.getDefaultSchemaNode()); [EOL]     ObjectNode root = jsonSchema.getSchemaNode(); [EOL]     assertEquals("object", root.get("type").asText()); [EOL]     assertEquals(false, root.path("required").booleanValue()); [EOL]     JsonNode propertiesSchema = root.get("properties"); [EOL]     assertNotNull(propertiesSchema); [EOL]     JsonNode property1Schema = propertiesSchema.get("property1"); [EOL]     assertNotNull(property1Schema); [EOL]     assertEquals("integer", property1Schema.get("type").asText()); [EOL]     assertEquals(false, property1Schema.path("required").booleanValue()); [EOL]     JsonNode property2Schema = propertiesSchema.get("property2"); [EOL]     assertNotNull(property2Schema); [EOL]     assertEquals("string", property2Schema.get("type").asText()); [EOL]     assertEquals(false, property2Schema.path("required").booleanValue()); [EOL]     JsonNode property3Schema = propertiesSchema.get("property3"); [EOL]     assertNotNull(property3Schema); [EOL]     assertEquals("array", property3Schema.get("type").asText()); [EOL]     assertEquals(false, property3Schema.path("required").booleanValue()); [EOL]     assertEquals("string", property3Schema.get("items").get("type").asText()); [EOL]     JsonNode property4Schema = propertiesSchema.get("property4"); [EOL]     assertNotNull(property4Schema); [EOL]     assertEquals("array", property4Schema.get("type").asText()); [EOL]     assertEquals(false, property4Schema.path("required").booleanValue()); [EOL]     assertEquals("number", property4Schema.get("items").get("type").asText()); [EOL] }
public void testSchemaId() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class); [EOL]     String json = jsonSchema.toString().replaceAll("\"", "'"); [EOL]     assertEquals("{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}", json); [EOL] }
public void testSchemaId() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class); [EOL]     String json = jsonSchema.toString().replaceAll("\"", "'"); [EOL]     assertEquals("{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}", json); [EOL] }
public void testSchemaId() throws Exception { [EOL]     JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class); [EOL]     String json = jsonSchema.toString().replaceAll("\"", "'"); [EOL]     assertEquals("{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}", json); [EOL] }
public void testNullColumn() throws Exception { [EOL]     assertEquals("[null,\"bar\"]", MAPPER.writeValueAsString(new TwoStringsBean())); [EOL] }
public void testNullColumn() throws Exception { [EOL]     assertEquals("[null,\"bar\"]", MAPPER.writeValueAsString(new TwoStringsBean())); [EOL] }
public void testNullColumn() throws Exception { [EOL]     assertEquals("[null,\"bar\"]", MAPPER.writeValueAsString(new TwoStringsBean())); [EOL] }
public void testNullColumn() throws Exception { [EOL]     assertEquals("[null,\"bar\"]", MAPPER.writeValueAsString(new TwoStringsBean())); [EOL] }
public void testNullColumn() throws Exception { [EOL]     assertEquals("[null,\"bar\"]", MAPPER.writeValueAsString(new TwoStringsBean())); [EOL] }
public void testNullColumn() throws Exception { [EOL]     assertEquals("[null,\"bar\"]", MAPPER.writeValueAsString(new TwoStringsBean())); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testJDK7SuppressionProperty() throws IOException { [EOL]     Exception exc = MAPPER.readValue("{\"suppressed\":[]}", IOException.class); [EOL]     assertNotNull(exc); [EOL] }
public void testIgnoreWithMapProperty() throws Exception { [EOL]     assertEquals("{\"value\":{\"b\":2}}", MAPPER.writeValueAsString(new MapWrapper())); [EOL] }
public void testIgnoreWithMapProperty() throws Exception { [EOL]     assertEquals("{\"value\":{\"b\":2}}", MAPPER.writeValueAsString(new MapWrapper())); [EOL] }
public void testIgnoreWithMapProperty() throws Exception { [EOL]     assertEquals("{\"value\":{\"b\":2}}", MAPPER.writeValueAsString(new MapWrapper())); [EOL] }
public void testIgnoreWithMapProperty() throws Exception { [EOL]     assertEquals("{\"value\":{\"b\":2}}", MAPPER.writeValueAsString(new MapWrapper())); [EOL] }
public void testIgnoreWithMapProperty() throws Exception { [EOL]     assertEquals("{\"value\":{\"b\":2}}", MAPPER.writeValueAsString(new MapWrapper())); [EOL] }
public void testIgnoreWithMapProperty() throws Exception { [EOL]     assertEquals("{\"value\":{\"b\":2}}", MAPPER.writeValueAsString(new MapWrapper())); [EOL] }
public void testIgnoreWithMapProperty() throws Exception { [EOL]     assertEquals("{\"value\":{\"b\":2}}", MAPPER.writeValueAsString(new MapWrapper())); [EOL] }
public void testOrderByKey() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertFalse(m.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)); [EOL]     LinkedHashMap<String, Integer> map = new LinkedHashMap<String, Integer>(); [EOL]     map.put("b", 3); [EOL]     map.put("a", 6); [EOL]     assertEquals("{\"b\":3,\"a\":6}", m.writeValueAsString(map)); [EOL]     assertEquals("{\"a\":6,\"b\":3}", m.writer(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS).writeValueAsString(map)); [EOL] }
public void testOrderByKey() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertFalse(m.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)); [EOL]     LinkedHashMap<String, Integer> map = new LinkedHashMap<String, Integer>(); [EOL]     map.put("b", 3); [EOL]     map.put("a", 6); [EOL]     assertEquals("{\"b\":3,\"a\":6}", m.writeValueAsString(map)); [EOL]     assertEquals("{\"a\":6,\"b\":3}", m.writer(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS).writeValueAsString(map)); [EOL] }
public void testOrderByKey() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertFalse(m.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)); [EOL]     LinkedHashMap<String, Integer> map = new LinkedHashMap<String, Integer>(); [EOL]     map.put("b", 3); [EOL]     map.put("a", 6); [EOL]     assertEquals("{\"b\":3,\"a\":6}", m.writeValueAsString(map)); [EOL]     assertEquals("{\"a\":6,\"b\":3}", m.writer(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS).writeValueAsString(map)); [EOL] }
public void testOrderByKey() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertFalse(m.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)); [EOL]     LinkedHashMap<String, Integer> map = new LinkedHashMap<String, Integer>(); [EOL]     map.put("b", 3); [EOL]     map.put("a", 6); [EOL]     assertEquals("{\"b\":3,\"a\":6}", m.writeValueAsString(map)); [EOL]     assertEquals("{\"a\":6,\"b\":3}", m.writer(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS).writeValueAsString(map)); [EOL] }
public void testOrderByKey() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertFalse(m.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)); [EOL]     LinkedHashMap<String, Integer> map = new LinkedHashMap<String, Integer>(); [EOL]     map.put("b", 3); [EOL]     map.put("a", 6); [EOL]     assertEquals("{\"b\":3,\"a\":6}", m.writeValueAsString(map)); [EOL]     assertEquals("{\"a\":6,\"b\":3}", m.writer(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS).writeValueAsString(map)); [EOL] }
public void testOrderByKey() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     assertFalse(m.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)); [EOL]     LinkedHashMap<String, Integer> map = new LinkedHashMap<String, Integer>(); [EOL]     map.put("b", 3); [EOL]     map.put("a", 6); [EOL]     assertEquals("{\"b\":3,\"a\":6}", m.writeValueAsString(map)); [EOL]     assertEquals("{\"a\":6,\"b\":3}", m.writer(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS).writeValueAsString(map)); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testMapContentUsing() throws Exception { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     MapBean result = m.readValue(" { \"values\" : { \"a\": 1, \"b\":2 } } ", MapBean.class); [EOL]     assertNotNull(result); [EOL]     Map<String, Object> map = result.values; [EOL]     assertNotNull(map); [EOL]     assertEquals(2, map.size()); [EOL]     assertEquals(ValueClass.class, map.get("a").getClass()); [EOL]     assertEquals(1, ((ValueClass) map.get("a"))._a); [EOL]     assertEquals(ValueClass.class, map.get("b").getClass()); [EOL]     assertEquals(2, ((ValueClass) map.get("b"))._a); [EOL] }
public void testFormat() { [EOL]     String result = ISO8601Utils.format(date); [EOL]     assertEquals("2007-08-13T19:51:23Z", result); [EOL] }
public void testFormat() { [EOL]     String result = ISO8601Utils.format(date); [EOL]     assertEquals("2007-08-13T19:51:23Z", result); [EOL] }
public void testFormat() { [EOL]     String result = ISO8601Utils.format(date); [EOL]     assertEquals("2007-08-13T19:51:23Z", result); [EOL] }
public void testFormat() { [EOL]     String result = ISO8601Utils.format(date); [EOL]     assertEquals("2007-08-13T19:51:23Z", result); [EOL] }
public void testFormat() { [EOL]     String result = ISO8601Utils.format(date); [EOL]     assertEquals("2007-08-13T19:51:23Z", result); [EOL] }
public void testFormat() { [EOL]     String result = ISO8601Utils.format(date); [EOL]     assertEquals("2007-08-13T19:51:23Z", result); [EOL] }
public void testFormat() { [EOL]     String result = ISO8601Utils.format(date); [EOL]     assertEquals("2007-08-13T19:51:23Z", result); [EOL] }
public void testFormat() { [EOL]     String result = ISO8601Utils.format(date); [EOL]     assertEquals("2007-08-13T19:51:23Z", result); [EOL] }
public void testFormat() { [EOL]     String result = ISO8601Utils.format(date); [EOL]     assertEquals("2007-08-13T19:51:23Z", result); [EOL] }
public void testFormat() { [EOL]     String result = ISO8601Utils.format(date); [EOL]     assertEquals("2007-08-13T19:51:23Z", result); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testClassMixInsTopLevel() throws IOException { [EOL]     ObjectMapper m = new ObjectMapper(); [EOL]     LeafClass result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("XXXvalue", result.a); [EOL]     m = new ObjectMapper(); [EOL]     m.addMixInAnnotations(LeafClass.class, MixIn.class); [EOL]     result = m.readValue("{\"a\":\"value\"}", LeafClass.class); [EOL]     assertEquals("value", result.a); [EOL] }
public void testNullForPrimitives() throws IOException { [EOL]     PrimitivesBean bean = mapper.readValue("{\"intValue\":null, \"booleanValue\":null, \"doubleValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals(0, bean.intValue); [EOL]     assertEquals(false, bean.booleanValue); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL]     bean = mapper.readValue("{\"byteValue\":null, \"longValue\":null, \"floatValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     assertEquals(0L, bean.longValue); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     final ObjectMapper mapper2 = new ObjectMapper(); [EOL]     mapper2.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true); [EOL]     try { [EOL]         mapper2.readValue("{\"booleanValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for boolean + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type boolean"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"byteValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for byte + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type byte"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"charValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for char + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type char"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"shortValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for short + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type short"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"intValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for int + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type int"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"longValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for long + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type long"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"floatValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for float + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type float"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"doubleValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for double + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type double"); [EOL]     } [EOL] }
public void testNullForPrimitives() throws IOException { [EOL]     PrimitivesBean bean = mapper.readValue("{\"intValue\":null, \"booleanValue\":null, \"doubleValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals(0, bean.intValue); [EOL]     assertEquals(false, bean.booleanValue); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL]     bean = mapper.readValue("{\"byteValue\":null, \"longValue\":null, \"floatValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     assertEquals(0L, bean.longValue); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     final ObjectMapper mapper2 = new ObjectMapper(); [EOL]     mapper2.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true); [EOL]     try { [EOL]         mapper2.readValue("{\"booleanValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for boolean + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type boolean"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"byteValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for byte + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type byte"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"charValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for char + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type char"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"shortValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for short + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type short"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"intValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for int + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type int"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"longValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for long + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type long"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"floatValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for float + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type float"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"doubleValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for double + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type double"); [EOL]     } [EOL] }
public void testNullForPrimitives() throws IOException { [EOL]     PrimitivesBean bean = mapper.readValue("{\"intValue\":null, \"booleanValue\":null, \"doubleValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals(0, bean.intValue); [EOL]     assertEquals(false, bean.booleanValue); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL]     bean = mapper.readValue("{\"byteValue\":null, \"longValue\":null, \"floatValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     assertEquals(0L, bean.longValue); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     final ObjectMapper mapper2 = new ObjectMapper(); [EOL]     mapper2.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true); [EOL]     try { [EOL]         mapper2.readValue("{\"booleanValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for boolean + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type boolean"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"byteValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for byte + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type byte"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"charValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for char + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type char"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"shortValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for short + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type short"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"intValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for int + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type int"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"longValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for long + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type long"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"floatValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for float + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type float"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"doubleValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for double + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type double"); [EOL]     } [EOL] }
public void testNullForPrimitives() throws IOException { [EOL]     PrimitivesBean bean = mapper.readValue("{\"intValue\":null, \"booleanValue\":null, \"doubleValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals(0, bean.intValue); [EOL]     assertEquals(false, bean.booleanValue); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL]     bean = mapper.readValue("{\"byteValue\":null, \"longValue\":null, \"floatValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     assertEquals(0L, bean.longValue); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     final ObjectMapper mapper2 = new ObjectMapper(); [EOL]     mapper2.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true); [EOL]     try { [EOL]         mapper2.readValue("{\"booleanValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for boolean + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type boolean"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"byteValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for byte + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type byte"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"charValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for char + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type char"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"shortValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for short + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type short"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"intValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for int + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type int"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"longValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for long + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type long"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"floatValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for float + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type float"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"doubleValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for double + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type double"); [EOL]     } [EOL] }
public void testNullForPrimitives() throws IOException { [EOL]     PrimitivesBean bean = mapper.readValue("{\"intValue\":null, \"booleanValue\":null, \"doubleValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals(0, bean.intValue); [EOL]     assertEquals(false, bean.booleanValue); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL]     bean = mapper.readValue("{\"byteValue\":null, \"longValue\":null, \"floatValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     assertEquals(0L, bean.longValue); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     final ObjectMapper mapper2 = new ObjectMapper(); [EOL]     mapper2.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true); [EOL]     try { [EOL]         mapper2.readValue("{\"booleanValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for boolean + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type boolean"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"byteValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for byte + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type byte"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"charValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for char + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type char"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"shortValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for short + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type short"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"intValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for int + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type int"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"longValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for long + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type long"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"floatValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for float + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type float"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"doubleValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for double + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type double"); [EOL]     } [EOL] }
public void testNullForPrimitives() throws IOException { [EOL]     PrimitivesBean bean = mapper.readValue("{\"intValue\":null, \"booleanValue\":null, \"doubleValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals(0, bean.intValue); [EOL]     assertEquals(false, bean.booleanValue); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL]     bean = mapper.readValue("{\"byteValue\":null, \"longValue\":null, \"floatValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     assertEquals(0L, bean.longValue); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     final ObjectMapper mapper2 = new ObjectMapper(); [EOL]     mapper2.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true); [EOL]     try { [EOL]         mapper2.readValue("{\"booleanValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for boolean + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type boolean"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"byteValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for byte + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type byte"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"charValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for char + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type char"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"shortValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for short + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type short"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"intValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for int + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type int"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"longValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for long + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type long"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"floatValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for float + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type float"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"doubleValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for double + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type double"); [EOL]     } [EOL] }
public void testNullForPrimitives() throws IOException { [EOL]     PrimitivesBean bean = mapper.readValue("{\"intValue\":null, \"booleanValue\":null, \"doubleValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals(0, bean.intValue); [EOL]     assertEquals(false, bean.booleanValue); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL]     bean = mapper.readValue("{\"byteValue\":null, \"longValue\":null, \"floatValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     assertEquals(0L, bean.longValue); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     final ObjectMapper mapper2 = new ObjectMapper(); [EOL]     mapper2.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true); [EOL]     try { [EOL]         mapper2.readValue("{\"booleanValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for boolean + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type boolean"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"byteValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for byte + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type byte"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"charValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for char + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type char"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"shortValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for short + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type short"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"intValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for int + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type int"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"longValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for long + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type long"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"floatValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for float + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type float"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"doubleValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for double + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type double"); [EOL]     } [EOL] }
public void testNullForPrimitives() throws IOException { [EOL]     PrimitivesBean bean = mapper.readValue("{\"intValue\":null, \"booleanValue\":null, \"doubleValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals(0, bean.intValue); [EOL]     assertEquals(false, bean.booleanValue); [EOL]     assertEquals(0.0, bean.doubleValue); [EOL]     bean = mapper.readValue("{\"byteValue\":null, \"longValue\":null, \"floatValue\":null}", PrimitivesBean.class); [EOL]     assertNotNull(bean); [EOL]     assertEquals((byte) 0, bean.byteValue); [EOL]     assertEquals(0L, bean.longValue); [EOL]     assertEquals(0.0f, bean.floatValue); [EOL]     final ObjectMapper mapper2 = new ObjectMapper(); [EOL]     mapper2.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true); [EOL]     try { [EOL]         mapper2.readValue("{\"booleanValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for boolean + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type boolean"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"byteValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for byte + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type byte"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"charValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for char + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type char"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"shortValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for short + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type short"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"intValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for int + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type int"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"longValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for long + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type long"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"floatValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for float + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type float"); [EOL]     } [EOL]     try { [EOL]         mapper2.readValue("{\"doubleValue\":null}", PrimitivesBean.class); [EOL]         fail("Expected failure for double + null"); [EOL]     } catch (JsonMappingException e) { [EOL]         verifyException(e, "Can not map JSON null into type double"); [EOL]     } [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
public void testFindExplicit() throws JsonMappingException { [EOL]     ObjectMapper mapper = new ObjectMapper(); [EOL]     SerializationConfig config = mapper.getSerializationConfig(); [EOL]     SerializerFactory f = new BeanSerializerFactory(null); [EOL]     DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f); [EOL]     assertNotNull(prov.findKeySerializer(mapper.constructType(String.class), null)); [EOL]     assertNotNull(prov.getDefaultNullKeySerializer()); [EOL]     assertNotNull(prov.getDefaultNullValueSerializer()); [EOL]     assertNotNull(prov.getUnknownTypeSerializer(getClass())); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL]     assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class)); [EOL] }
