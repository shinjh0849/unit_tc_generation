@Override [EOL] public boolean isAnnotationBundle(Annotation ann) { [EOL]     return ann.annotationType().getAnnotation(JacksonAnnotationsInside.class) != null; [EOL] }
@Override [EOL] public String[] findPropertiesToIgnore(Annotated ac) { [EOL]     JsonIgnoreProperties ignore = ac.getAnnotation(JsonIgnoreProperties.class); [EOL]     return (ignore == null) ? null : ignore.value(); [EOL] }
@Override [EOL] public String[] findPropertiesToIgnore(Annotated ac) { [EOL]     JsonIgnoreProperties ignore = ac.getAnnotation(JsonIgnoreProperties.class); [EOL]     return (ignore == null) ? null : ignore.value(); [EOL] }
@Override [EOL] public Boolean findIgnoreUnknownProperties(AnnotatedClass ac) { [EOL]     JsonIgnoreProperties ignore = ac.getAnnotation(JsonIgnoreProperties.class); [EOL]     return (ignore == null) ? null : ignore.ignoreUnknown(); [EOL] }
@Override [EOL] public Boolean findIgnoreUnknownProperties(AnnotatedClass ac) { [EOL]     JsonIgnoreProperties ignore = ac.getAnnotation(JsonIgnoreProperties.class); [EOL]     return (ignore == null) ? null : ignore.ignoreUnknown(); [EOL] }
@Override [EOL] public Boolean findIgnoreUnknownProperties(AnnotatedClass ac) { [EOL]     JsonIgnoreProperties ignore = ac.getAnnotation(JsonIgnoreProperties.class); [EOL]     return (ignore == null) ? null : ignore.ignoreUnknown(); [EOL] }
@Override [EOL] public Boolean isIgnorableType(AnnotatedClass ac) { [EOL]     JsonIgnoreType ignore = ac.getAnnotation(JsonIgnoreType.class); [EOL]     return (ignore == null) ? null : ignore.value(); [EOL] }
@Override [EOL] public Boolean isIgnorableType(AnnotatedClass ac) { [EOL]     JsonIgnoreType ignore = ac.getAnnotation(JsonIgnoreType.class); [EOL]     return (ignore == null) ? null : ignore.value(); [EOL] }
@Override [EOL] public Boolean isIgnorableType(AnnotatedClass ac) { [EOL]     JsonIgnoreType ignore = ac.getAnnotation(JsonIgnoreType.class); [EOL]     return (ignore == null) ? null : ignore.value(); [EOL] }
@Override [EOL] public Object findFilterId(AnnotatedClass ac) { [EOL]     JsonFilter ann = ac.getAnnotation(JsonFilter.class); [EOL]     if (ann != null) { [EOL]         String id = ann.value(); [EOL]         if (id.length() > 0) { [EOL]             return id; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findFilterId(AnnotatedClass ac) { [EOL]     JsonFilter ann = ac.getAnnotation(JsonFilter.class); [EOL]     if (ann != null) { [EOL]         String id = ann.value(); [EOL]         if (id.length() > 0) { [EOL]             return id; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findFilterId(AnnotatedClass ac) { [EOL]     JsonFilter ann = ac.getAnnotation(JsonFilter.class); [EOL]     if (ann != null) { [EOL]         String id = ann.value(); [EOL]         if (id.length() > 0) { [EOL]             return id; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public ReferenceProperty findReferenceType(AnnotatedMember member) { [EOL]     JsonManagedReference ref1 = member.getAnnotation(JsonManagedReference.class); [EOL]     if (ref1 != null) { [EOL]         return AnnotationIntrospector.ReferenceProperty.managed(ref1.value()); [EOL]     } [EOL]     JsonBackReference ref2 = member.getAnnotation(JsonBackReference.class); [EOL]     if (ref2 != null) { [EOL]         return AnnotationIntrospector.ReferenceProperty.back(ref2.value()); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public ReferenceProperty findReferenceType(AnnotatedMember member) { [EOL]     JsonManagedReference ref1 = member.getAnnotation(JsonManagedReference.class); [EOL]     if (ref1 != null) { [EOL]         return AnnotationIntrospector.ReferenceProperty.managed(ref1.value()); [EOL]     } [EOL]     JsonBackReference ref2 = member.getAnnotation(JsonBackReference.class); [EOL]     if (ref2 != null) { [EOL]         return AnnotationIntrospector.ReferenceProperty.back(ref2.value()); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public ReferenceProperty findReferenceType(AnnotatedMember member) { [EOL]     JsonManagedReference ref1 = member.getAnnotation(JsonManagedReference.class); [EOL]     if (ref1 != null) { [EOL]         return AnnotationIntrospector.ReferenceProperty.managed(ref1.value()); [EOL]     } [EOL]     JsonBackReference ref2 = member.getAnnotation(JsonBackReference.class); [EOL]     if (ref2 != null) { [EOL]         return AnnotationIntrospector.ReferenceProperty.back(ref2.value()); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member) { [EOL]     JsonUnwrapped ann = member.getAnnotation(JsonUnwrapped.class); [EOL]     if (ann == null || !ann.enabled()) { [EOL]         return null; [EOL]     } [EOL]     String prefix = ann.prefix(); [EOL]     String suffix = ann.suffix(); [EOL]     return NameTransformer.simpleTransformer(prefix, suffix); [EOL] }
@Override [EOL] public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member) { [EOL]     JsonUnwrapped ann = member.getAnnotation(JsonUnwrapped.class); [EOL]     if (ann == null || !ann.enabled()) { [EOL]         return null; [EOL]     } [EOL]     String prefix = ann.prefix(); [EOL]     String suffix = ann.suffix(); [EOL]     return NameTransformer.simpleTransformer(prefix, suffix); [EOL] }
@Override [EOL] public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member) { [EOL]     JsonUnwrapped ann = member.getAnnotation(JsonUnwrapped.class); [EOL]     if (ann == null || !ann.enabled()) { [EOL]         return null; [EOL]     } [EOL]     String prefix = ann.prefix(); [EOL]     String suffix = ann.suffix(); [EOL]     return NameTransformer.simpleTransformer(prefix, suffix); [EOL] }
@Override [EOL] public Boolean hasRequiredMarker(AnnotatedMember m) { [EOL]     JsonProperty ann = m.getAnnotation(JsonProperty.class); [EOL]     if (ann != null) { [EOL]         return ann.required(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Boolean hasRequiredMarker(AnnotatedMember m) { [EOL]     JsonProperty ann = m.getAnnotation(JsonProperty.class); [EOL]     if (ann != null) { [EOL]         return ann.required(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Boolean hasRequiredMarker(AnnotatedMember m) { [EOL]     JsonProperty ann = m.getAnnotation(JsonProperty.class); [EOL]     if (ann != null) { [EOL]         return ann.required(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType baseType) { [EOL]     if (baseType.isContainerType()) [EOL]         return null; [EOL]     return _findTypeResolver(config, am, baseType); [EOL] }
@Override [EOL] public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType baseType) { [EOL]     if (baseType.isContainerType()) [EOL]         return null; [EOL]     return _findTypeResolver(config, am, baseType); [EOL] }
@Override [EOL] public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType containerType) { [EOL]     if (!containerType.isContainerType()) { [EOL]         throw new IllegalArgumentException("Must call method with a container type (got " + containerType + ")"); [EOL]     } [EOL]     return _findTypeResolver(config, am, containerType); [EOL] }
@Override [EOL] public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config, AnnotatedMember am, JavaType containerType) { [EOL]     if (!containerType.isContainerType()) { [EOL]         throw new IllegalArgumentException("Must call method with a container type (got " + containerType + ")"); [EOL]     } [EOL]     return _findTypeResolver(config, am, containerType); [EOL] }
@Override [EOL] public List<NamedType> findSubtypes(Annotated a) { [EOL]     JsonSubTypes t = a.getAnnotation(JsonSubTypes.class); [EOL]     if (t == null) [EOL]         return null; [EOL]     JsonSubTypes.Type[] types = t.value(); [EOL]     ArrayList<NamedType> result = new ArrayList<NamedType>(types.length); [EOL]     for (JsonSubTypes.Type type : types) { [EOL]         result.add(new NamedType(type.value(), type.name())); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public List<NamedType> findSubtypes(Annotated a) { [EOL]     JsonSubTypes t = a.getAnnotation(JsonSubTypes.class); [EOL]     if (t == null) [EOL]         return null; [EOL]     JsonSubTypes.Type[] types = t.value(); [EOL]     ArrayList<NamedType> result = new ArrayList<NamedType>(types.length); [EOL]     for (JsonSubTypes.Type type : types) { [EOL]         result.add(new NamedType(type.value(), type.name())); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public List<NamedType> findSubtypes(Annotated a) { [EOL]     JsonSubTypes t = a.getAnnotation(JsonSubTypes.class); [EOL]     if (t == null) [EOL]         return null; [EOL]     JsonSubTypes.Type[] types = t.value(); [EOL]     ArrayList<NamedType> result = new ArrayList<NamedType>(types.length); [EOL]     for (JsonSubTypes.Type type : types) { [EOL]         result.add(new NamedType(type.value(), type.name())); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public String findTypeName(AnnotatedClass ac) { [EOL]     JsonTypeName tn = ac.getAnnotation(JsonTypeName.class); [EOL]     return (tn == null) ? null : tn.value(); [EOL] }
@Override [EOL] public String findTypeName(AnnotatedClass ac) { [EOL]     JsonTypeName tn = ac.getAnnotation(JsonTypeName.class); [EOL]     return (tn == null) ? null : tn.value(); [EOL] }
@Override [EOL] public Object findSerializer(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = ann.using(); [EOL]         if (serClass != JsonSerializer.None.class) { [EOL]             return serClass; [EOL]         } [EOL]     } [EOL]     JsonRawValue annRaw = a.getAnnotation(JsonRawValue.class); [EOL]     if ((annRaw != null) && annRaw.value()) { [EOL]         Class<?> cls = a.getRawType(); [EOL]         return new RawSerializer<Object>(cls); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findSerializer(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = ann.using(); [EOL]         if (serClass != JsonSerializer.None.class) { [EOL]             return serClass; [EOL]         } [EOL]     } [EOL]     JsonRawValue annRaw = a.getAnnotation(JsonRawValue.class); [EOL]     if ((annRaw != null) && annRaw.value()) { [EOL]         Class<?> cls = a.getRawType(); [EOL]         return new RawSerializer<Object>(cls); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findSerializer(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = ann.using(); [EOL]         if (serClass != JsonSerializer.None.class) { [EOL]             return serClass; [EOL]         } [EOL]     } [EOL]     JsonRawValue annRaw = a.getAnnotation(JsonRawValue.class); [EOL]     if ((annRaw != null) && annRaw.value()) { [EOL]         Class<?> cls = a.getRawType(); [EOL]         return new RawSerializer<Object>(cls); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findSerializer(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = ann.using(); [EOL]         if (serClass != JsonSerializer.None.class) { [EOL]             return serClass; [EOL]         } [EOL]     } [EOL]     JsonRawValue annRaw = a.getAnnotation(JsonRawValue.class); [EOL]     if ((annRaw != null) && annRaw.value()) { [EOL]         Class<?> cls = a.getRawType(); [EOL]         return new RawSerializer<Object>(cls); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findSerializer(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = ann.using(); [EOL]         if (serClass != JsonSerializer.None.class) { [EOL]             return serClass; [EOL]         } [EOL]     } [EOL]     JsonRawValue annRaw = a.getAnnotation(JsonRawValue.class); [EOL]     if ((annRaw != null) && annRaw.value()) { [EOL]         Class<?> cls = a.getRawType(); [EOL]         return new RawSerializer<Object>(cls); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends JsonSerializer<?>> findContentSerializer(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = ann.contentUsing(); [EOL]         if (serClass != JsonSerializer.None.class) { [EOL]             return serClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends JsonSerializer<?>> findContentSerializer(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = ann.contentUsing(); [EOL]         if (serClass != JsonSerializer.None.class) { [EOL]             return serClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends JsonSerializer<?>> findContentSerializer(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonSerializer<?>> serClass = ann.contentUsing(); [EOL]         if (serClass != JsonSerializer.None.class) { [EOL]             return serClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) { [EOL]     JsonInclude inc = a.getAnnotation(JsonInclude.class); [EOL]     if (inc != null) { [EOL]         return inc.value(); [EOL]     } [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         @SuppressWarnings("deprecation") [EOL]         JsonSerialize.Inclusion i2 = ann.include(); [EOL]         switch(i2) { [EOL]             case ALWAYS: [EOL]                 return JsonInclude.Include.ALWAYS; [EOL]             case NON_NULL: [EOL]                 return JsonInclude.Include.NON_NULL; [EOL]             case NON_DEFAULT: [EOL]                 return JsonInclude.Include.NON_DEFAULT; [EOL]             case NON_EMPTY: [EOL]                 return JsonInclude.Include.NON_EMPTY; [EOL]         } [EOL]     } [EOL]     return defValue; [EOL] }
@Override [EOL] public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) { [EOL]     JsonInclude inc = a.getAnnotation(JsonInclude.class); [EOL]     if (inc != null) { [EOL]         return inc.value(); [EOL]     } [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         @SuppressWarnings("deprecation") [EOL]         JsonSerialize.Inclusion i2 = ann.include(); [EOL]         switch(i2) { [EOL]             case ALWAYS: [EOL]                 return JsonInclude.Include.ALWAYS; [EOL]             case NON_NULL: [EOL]                 return JsonInclude.Include.NON_NULL; [EOL]             case NON_DEFAULT: [EOL]                 return JsonInclude.Include.NON_DEFAULT; [EOL]             case NON_EMPTY: [EOL]                 return JsonInclude.Include.NON_EMPTY; [EOL]         } [EOL]     } [EOL]     return defValue; [EOL] }
@Override [EOL] public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) { [EOL]     JsonInclude inc = a.getAnnotation(JsonInclude.class); [EOL]     if (inc != null) { [EOL]         return inc.value(); [EOL]     } [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         @SuppressWarnings("deprecation") [EOL]         JsonSerialize.Inclusion i2 = ann.include(); [EOL]         switch(i2) { [EOL]             case ALWAYS: [EOL]                 return JsonInclude.Include.ALWAYS; [EOL]             case NON_NULL: [EOL]                 return JsonInclude.Include.NON_NULL; [EOL]             case NON_DEFAULT: [EOL]                 return JsonInclude.Include.NON_DEFAULT; [EOL]             case NON_EMPTY: [EOL]                 return JsonInclude.Include.NON_EMPTY; [EOL]         } [EOL]     } [EOL]     return defValue; [EOL] }
@Override [EOL] public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) { [EOL]     JsonInclude inc = a.getAnnotation(JsonInclude.class); [EOL]     if (inc != null) { [EOL]         return inc.value(); [EOL]     } [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         @SuppressWarnings("deprecation") [EOL]         JsonSerialize.Inclusion i2 = ann.include(); [EOL]         switch(i2) { [EOL]             case ALWAYS: [EOL]                 return JsonInclude.Include.ALWAYS; [EOL]             case NON_NULL: [EOL]                 return JsonInclude.Include.NON_NULL; [EOL]             case NON_DEFAULT: [EOL]                 return JsonInclude.Include.NON_DEFAULT; [EOL]             case NON_EMPTY: [EOL]                 return JsonInclude.Include.NON_EMPTY; [EOL]         } [EOL]     } [EOL]     return defValue; [EOL] }
@Override [EOL] public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) { [EOL]     JsonInclude inc = a.getAnnotation(JsonInclude.class); [EOL]     if (inc != null) { [EOL]         return inc.value(); [EOL]     } [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         @SuppressWarnings("deprecation") [EOL]         JsonSerialize.Inclusion i2 = ann.include(); [EOL]         switch(i2) { [EOL]             case ALWAYS: [EOL]                 return JsonInclude.Include.ALWAYS; [EOL]             case NON_NULL: [EOL]                 return JsonInclude.Include.NON_NULL; [EOL]             case NON_DEFAULT: [EOL]                 return JsonInclude.Include.NON_DEFAULT; [EOL]             case NON_EMPTY: [EOL]                 return JsonInclude.Include.NON_EMPTY; [EOL]         } [EOL]     } [EOL]     return defValue; [EOL] }
@Override [EOL] public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) { [EOL]     JsonInclude inc = a.getAnnotation(JsonInclude.class); [EOL]     if (inc != null) { [EOL]         return inc.value(); [EOL]     } [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         @SuppressWarnings("deprecation") [EOL]         JsonSerialize.Inclusion i2 = ann.include(); [EOL]         switch(i2) { [EOL]             case ALWAYS: [EOL]                 return JsonInclude.Include.ALWAYS; [EOL]             case NON_NULL: [EOL]                 return JsonInclude.Include.NON_NULL; [EOL]             case NON_DEFAULT: [EOL]                 return JsonInclude.Include.NON_DEFAULT; [EOL]             case NON_EMPTY: [EOL]                 return JsonInclude.Include.NON_EMPTY; [EOL]         } [EOL]     } [EOL]     return defValue; [EOL] }
@Override [EOL] public Class<?> findSerializationType(Annotated am) { [EOL]     JsonSerialize ann = am.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.as(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findSerializationType(Annotated am) { [EOL]     JsonSerialize ann = am.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.as(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findSerializationType(Annotated am) { [EOL]     JsonSerialize ann = am.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.as(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findSerializationKeyType(Annotated am, JavaType baseType) { [EOL]     JsonSerialize ann = am.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.keyAs(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findSerializationKeyType(Annotated am, JavaType baseType) { [EOL]     JsonSerialize ann = am.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.keyAs(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findSerializationKeyType(Annotated am, JavaType baseType) { [EOL]     JsonSerialize ann = am.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.keyAs(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findSerializationContentType(Annotated am, JavaType baseType) { [EOL]     JsonSerialize ann = am.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.contentAs(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findSerializationContentType(Annotated am, JavaType baseType) { [EOL]     JsonSerialize ann = am.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.contentAs(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonSerialize.Typing findSerializationTyping(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     return (ann == null) ? null : ann.typing(); [EOL] }
@Override [EOL] public JsonSerialize.Typing findSerializationTyping(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     return (ann == null) ? null : ann.typing(); [EOL] }
@Override [EOL] public Object findSerializationConverter(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.converter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findSerializationConverter(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.converter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findSerializationConverter(Annotated a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.converter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findSerializationContentConverter(AnnotatedMember a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.contentConverter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findSerializationContentConverter(AnnotatedMember a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.contentConverter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findSerializationContentConverter(AnnotatedMember a) { [EOL]     JsonSerialize ann = a.getAnnotation(JsonSerialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.contentConverter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?>[] findViews(Annotated a) { [EOL]     JsonView ann = a.getAnnotation(JsonView.class); [EOL]     return (ann == null) ? null : ann.value(); [EOL] }
@Override [EOL] public Class<?>[] findViews(Annotated a) { [EOL]     JsonView ann = a.getAnnotation(JsonView.class); [EOL]     return (ann == null) ? null : ann.value(); [EOL] }
@Override [EOL] public Boolean isTypeId(AnnotatedMember member) { [EOL]     return member.hasAnnotation(JsonTypeId.class); [EOL] }
@Override [EOL] public Boolean isTypeId(AnnotatedMember member) { [EOL]     return member.hasAnnotation(JsonTypeId.class); [EOL] }
@Override [EOL] public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) { [EOL]     JsonIdentityReference ref = ann.getAnnotation(JsonIdentityReference.class); [EOL]     if (ref != null) { [EOL]         objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId()); [EOL]     } [EOL]     return objectIdInfo; [EOL] }
@Override [EOL] public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) { [EOL]     JsonIdentityReference ref = ann.getAnnotation(JsonIdentityReference.class); [EOL]     if (ref != null) { [EOL]         objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId()); [EOL]     } [EOL]     return objectIdInfo; [EOL] }
@Override [EOL] public PropertyName findNameForSerialization(Annotated a) { [EOL]     String name; [EOL]     if (a instanceof AnnotatedField) { [EOL]         name = findSerializationName((AnnotatedField) a); [EOL]     } else if (a instanceof AnnotatedMethod) { [EOL]         name = findSerializationName((AnnotatedMethod) a); [EOL]     } else { [EOL]         name = null; [EOL]     } [EOL]     if (name != null) { [EOL]         if (name.length() == 0) { [EOL]             return PropertyName.USE_DEFAULT; [EOL]         } [EOL]         return new PropertyName(name); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public PropertyName findNameForSerialization(Annotated a) { [EOL]     String name; [EOL]     if (a instanceof AnnotatedField) { [EOL]         name = findSerializationName((AnnotatedField) a); [EOL]     } else if (a instanceof AnnotatedMethod) { [EOL]         name = findSerializationName((AnnotatedMethod) a); [EOL]     } else { [EOL]         name = null; [EOL]     } [EOL]     if (name != null) { [EOL]         if (name.length() == 0) { [EOL]             return PropertyName.USE_DEFAULT; [EOL]         } [EOL]         return new PropertyName(name); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findSerializationName(AnnotatedMethod am) { [EOL]     JsonGetter ann = am.getAnnotation(JsonGetter.class); [EOL]     if (ann != null) { [EOL]         return ann.value(); [EOL]     } [EOL]     JsonProperty pann = am.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (am.hasAnnotation(JsonSerialize.class) || am.hasAnnotation(JsonView.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findSerializationName(AnnotatedMethod am) { [EOL]     JsonGetter ann = am.getAnnotation(JsonGetter.class); [EOL]     if (ann != null) { [EOL]         return ann.value(); [EOL]     } [EOL]     JsonProperty pann = am.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (am.hasAnnotation(JsonSerialize.class) || am.hasAnnotation(JsonView.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findSerializationName(AnnotatedMethod am) { [EOL]     JsonGetter ann = am.getAnnotation(JsonGetter.class); [EOL]     if (ann != null) { [EOL]         return ann.value(); [EOL]     } [EOL]     JsonProperty pann = am.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (am.hasAnnotation(JsonSerialize.class) || am.hasAnnotation(JsonView.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findSerializationName(AnnotatedMethod am) { [EOL]     JsonGetter ann = am.getAnnotation(JsonGetter.class); [EOL]     if (ann != null) { [EOL]         return ann.value(); [EOL]     } [EOL]     JsonProperty pann = am.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (am.hasAnnotation(JsonSerialize.class) || am.hasAnnotation(JsonView.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends JsonDeserializer<?>> findDeserializer(Annotated a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonDeserializer<?>> deserClass = ann.using(); [EOL]         if (deserClass != JsonDeserializer.None.class) { [EOL]             return deserClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends JsonDeserializer<?>> findDeserializer(Annotated a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonDeserializer<?>> deserClass = ann.using(); [EOL]         if (deserClass != JsonDeserializer.None.class) { [EOL]             return deserClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends JsonDeserializer<?>> findDeserializer(Annotated a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonDeserializer<?>> deserClass = ann.using(); [EOL]         if (deserClass != JsonDeserializer.None.class) { [EOL]             return deserClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends JsonDeserializer<?>> findContentDeserializer(Annotated a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonDeserializer<?>> deserClass = ann.contentUsing(); [EOL]         if (deserClass != JsonDeserializer.None.class) { [EOL]             return deserClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends JsonDeserializer<?>> findContentDeserializer(Annotated a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonDeserializer<?>> deserClass = ann.contentUsing(); [EOL]         if (deserClass != JsonDeserializer.None.class) { [EOL]             return deserClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<? extends JsonDeserializer<?>> findContentDeserializer(Annotated a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<? extends JsonDeserializer<?>> deserClass = ann.contentUsing(); [EOL]         if (deserClass != JsonDeserializer.None.class) { [EOL]             return deserClass; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findDeserializationType(Annotated am, JavaType baseType) { [EOL]     JsonDeserialize ann = am.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.as(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findDeserializationType(Annotated am, JavaType baseType) { [EOL]     JsonDeserialize ann = am.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.as(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findDeserializationType(Annotated am, JavaType baseType) { [EOL]     JsonDeserialize ann = am.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.as(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) { [EOL]     JsonDeserialize ann = am.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.keyAs(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) { [EOL]     JsonDeserialize ann = am.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.keyAs(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) { [EOL]     JsonDeserialize ann = am.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.keyAs(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType) { [EOL]     JsonDeserialize ann = am.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.contentAs(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType) { [EOL]     JsonDeserialize ann = am.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.contentAs(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType) { [EOL]     JsonDeserialize ann = am.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> cls = ann.contentAs(); [EOL]         if (cls != NoClass.class) { [EOL]             return cls; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findDeserializationConverter(Annotated a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.converter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findDeserializationConverter(Annotated a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.converter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findDeserializationConverter(Annotated a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.converter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findDeserializationContentConverter(AnnotatedMember a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.contentConverter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findDeserializationContentConverter(AnnotatedMember a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.contentConverter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findDeserializationContentConverter(AnnotatedMember a) { [EOL]     JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class); [EOL]     if (ann != null) { [EOL]         Class<?> def = ann.contentConverter(); [EOL]         if (def != Converter.None.class) { [EOL]             return def; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public Object findValueInstantiator(AnnotatedClass ac) { [EOL]     JsonValueInstantiator ann = ac.getAnnotation(JsonValueInstantiator.class); [EOL]     return (ann == null) ? null : ann.value(); [EOL] }
@Override [EOL] public Object findValueInstantiator(AnnotatedClass ac) { [EOL]     JsonValueInstantiator ann = ac.getAnnotation(JsonValueInstantiator.class); [EOL]     return (ann == null) ? null : ann.value(); [EOL] }
@Override [EOL] public PropertyName findNameForDeserialization(Annotated a) { [EOL]     String name; [EOL]     if (a instanceof AnnotatedField) { [EOL]         name = findDeserializationName((AnnotatedField) a); [EOL]     } else if (a instanceof AnnotatedMethod) { [EOL]         name = findDeserializationName((AnnotatedMethod) a); [EOL]     } else if (a instanceof AnnotatedParameter) { [EOL]         name = findDeserializationName((AnnotatedParameter) a); [EOL]     } else { [EOL]         name = null; [EOL]     } [EOL]     if (name != null) { [EOL]         if (name.length() == 0) { [EOL]             return PropertyName.USE_DEFAULT; [EOL]         } [EOL]         return new PropertyName(name); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public PropertyName findNameForDeserialization(Annotated a) { [EOL]     String name; [EOL]     if (a instanceof AnnotatedField) { [EOL]         name = findDeserializationName((AnnotatedField) a); [EOL]     } else if (a instanceof AnnotatedMethod) { [EOL]         name = findDeserializationName((AnnotatedMethod) a); [EOL]     } else if (a instanceof AnnotatedParameter) { [EOL]         name = findDeserializationName((AnnotatedParameter) a); [EOL]     } else { [EOL]         name = null; [EOL]     } [EOL]     if (name != null) { [EOL]         if (name.length() == 0) { [EOL]             return PropertyName.USE_DEFAULT; [EOL]         } [EOL]         return new PropertyName(name); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findDeserializationName(AnnotatedMethod am) { [EOL]     JsonSetter ann = am.getAnnotation(JsonSetter.class); [EOL]     if (ann != null) { [EOL]         return ann.value(); [EOL]     } [EOL]     JsonProperty pann = am.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (am.hasAnnotation(JsonDeserialize.class) || am.hasAnnotation(JsonView.class) || am.hasAnnotation(JsonBackReference.class) || am.hasAnnotation(JsonManagedReference.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findDeserializationName(AnnotatedMethod am) { [EOL]     JsonSetter ann = am.getAnnotation(JsonSetter.class); [EOL]     if (ann != null) { [EOL]         return ann.value(); [EOL]     } [EOL]     JsonProperty pann = am.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (am.hasAnnotation(JsonDeserialize.class) || am.hasAnnotation(JsonView.class) || am.hasAnnotation(JsonBackReference.class) || am.hasAnnotation(JsonManagedReference.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findDeserializationName(AnnotatedMethod am) { [EOL]     JsonSetter ann = am.getAnnotation(JsonSetter.class); [EOL]     if (ann != null) { [EOL]         return ann.value(); [EOL]     } [EOL]     JsonProperty pann = am.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (am.hasAnnotation(JsonDeserialize.class) || am.hasAnnotation(JsonView.class) || am.hasAnnotation(JsonBackReference.class) || am.hasAnnotation(JsonManagedReference.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public String findDeserializationName(AnnotatedMethod am) { [EOL]     JsonSetter ann = am.getAnnotation(JsonSetter.class); [EOL]     if (ann != null) { [EOL]         return ann.value(); [EOL]     } [EOL]     JsonProperty pann = am.getAnnotation(JsonProperty.class); [EOL]     if (pann != null) { [EOL]         return pann.value(); [EOL]     } [EOL]     if (am.hasAnnotation(JsonDeserialize.class) || am.hasAnnotation(JsonView.class) || am.hasAnnotation(JsonBackReference.class) || am.hasAnnotation(JsonManagedReference.class)) { [EOL]         return ""; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public boolean hasAnySetterAnnotation(AnnotatedMethod am) { [EOL]     return am.hasAnnotation(JsonAnySetter.class); [EOL] }
@Override [EOL] public boolean hasAnySetterAnnotation(AnnotatedMethod am) { [EOL]     return am.hasAnnotation(JsonAnySetter.class); [EOL] }
protected TypeResolverBuilder<?> _findTypeResolver(MapperConfig<?> config, Annotated ann, JavaType baseType) { [EOL]     TypeResolverBuilder<?> b; [EOL]     JsonTypeInfo info = ann.getAnnotation(JsonTypeInfo.class); [EOL]     JsonTypeResolver resAnn = ann.getAnnotation(JsonTypeResolver.class); [EOL]     if (resAnn != null) { [EOL]         if (info == null) { [EOL]             return null; [EOL]         } [EOL]         b = config.typeResolverBuilderInstance(ann, resAnn.value()); [EOL]     } else { [EOL]         if (info == null) { [EOL]             return null; [EOL]         } [EOL]         if (info.use() == JsonTypeInfo.Id.NONE) { [EOL]             return _constructNoTypeResolverBuilder(); [EOL]         } [EOL]         b = _constructStdTypeResolverBuilder(); [EOL]     } [EOL]     JsonTypeIdResolver idResInfo = ann.getAnnotation(JsonTypeIdResolver.class); [EOL]     TypeIdResolver idRes = (idResInfo == null) ? null : config.typeIdResolverInstance(ann, idResInfo.value()); [EOL]     if (idRes != null) { [EOL]         idRes.init(baseType); [EOL]     } [EOL]     b = b.init(info.use(), idRes); [EOL]     JsonTypeInfo.As inclusion = info.include(); [EOL]     if (inclusion == JsonTypeInfo.As.EXTERNAL_PROPERTY && (ann instanceof AnnotatedClass)) { [EOL]         inclusion = JsonTypeInfo.As.PROPERTY; [EOL]     } [EOL]     b = b.inclusion(inclusion); [EOL]     b = b.typeProperty(info.property()); [EOL]     Class<?> defaultImpl = info.defaultImpl(); [EOL]     if (defaultImpl != JsonTypeInfo.None.class) { [EOL]         b = b.defaultImpl(defaultImpl); [EOL]     } [EOL]     b = b.typeIdVisibility(info.visible()); [EOL]     return b; [EOL] }
protected StdTypeResolverBuilder _constructStdTypeResolverBuilder() { [EOL]     return new StdTypeResolverBuilder(); [EOL] }
protected StdScalarSerializer(Class<T> t) { [EOL]     super(t); [EOL] }
protected DeserializationContext(DeserializationContext src, DeserializerFactory factory) { [EOL]     _cache = src._cache; [EOL]     _factory = factory; [EOL]     _config = src._config; [EOL]     _featureFlags = src._featureFlags; [EOL]     _view = src._view; [EOL]     _parser = src._parser; [EOL]     _injectableValues = src._injectableValues; [EOL] }
@Override [EOL] public final TypeFactory getTypeFactory() { [EOL]     return _config.getTypeFactory(); [EOL] }
public final JsonNodeFactory getNodeFactory() { [EOL]     return _config.getNodeFactory(); [EOL] }
public Locale getLocale() { [EOL]     return _config.getLocale(); [EOL] }
public Locale getLocale() { [EOL]     return _config.getLocale(); [EOL] }
public Class<?> findClass(String className) throws ClassNotFoundException { [EOL]     return ClassUtil.findClass(className); [EOL] }
public Class<?> findClass(String className) throws ClassNotFoundException { [EOL]     return ClassUtil.findClass(className); [EOL] }
public Calendar constructCalendar(Date d) { [EOL]     Calendar c = Calendar.getInstance(getTimeZone()); [EOL]     c.setTime(d); [EOL]     return c; [EOL] }
public Calendar constructCalendar(Date d) { [EOL]     Calendar c = Calendar.getInstance(getTimeZone()); [EOL]     c.setTime(d); [EOL]     return c; [EOL] }
public boolean handleUnknownProperty(JsonParser jp, JsonDeserializer<?> deser, Object instanceOrClass, String propName) throws IOException, JsonProcessingException { [EOL]     LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers(); [EOL]     if (h != null) { [EOL]         while (h != null) { [EOL]             if (h.value().handleUnknownProperty(this, jp, deser, instanceOrClass, propName)) { [EOL]                 return true; [EOL]             } [EOL]             h = h.next(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean handleUnknownProperty(JsonParser jp, JsonDeserializer<?> deser, Object instanceOrClass, String propName) throws IOException, JsonProcessingException { [EOL]     LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers(); [EOL]     if (h != null) { [EOL]         while (h != null) { [EOL]             if (h.value().handleUnknownProperty(this, jp, deser, instanceOrClass, propName)) { [EOL]                 return true; [EOL]             } [EOL]             h = h.next(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public boolean handleUnknownProperty(JsonParser jp, JsonDeserializer<?> deser, Object instanceOrClass, String propName) throws IOException, JsonProcessingException { [EOL]     LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers(); [EOL]     if (h != null) { [EOL]         while (h != null) { [EOL]             if (h.value().handleUnknownProperty(this, jp, deser, instanceOrClass, propName)) { [EOL]                 return true; [EOL]             } [EOL]             h = h.next(); [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
public void reportUnknownProperty(Object instanceOrClass, String fieldName, JsonDeserializer<?> deser) throws JsonMappingException { [EOL]     if (!isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) { [EOL]         return; [EOL]     } [EOL]     Collection<Object> propIds = (deser == null) ? null : deser.getKnownPropertyNames(); [EOL]     throw UnrecognizedPropertyException.from(_parser, instanceOrClass, fieldName, propIds); [EOL] }
public void reportUnknownProperty(Object instanceOrClass, String fieldName, JsonDeserializer<?> deser) throws JsonMappingException { [EOL]     if (!isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) { [EOL]         return; [EOL]     } [EOL]     Collection<Object> propIds = (deser == null) ? null : deser.getKnownPropertyNames(); [EOL]     throw UnrecognizedPropertyException.from(_parser, instanceOrClass, fieldName, propIds); [EOL] }
public void reportUnknownProperty(Object instanceOrClass, String fieldName, JsonDeserializer<?> deser) throws JsonMappingException { [EOL]     if (!isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) { [EOL]         return; [EOL]     } [EOL]     Collection<Object> propIds = (deser == null) ? null : deser.getKnownPropertyNames(); [EOL]     throw UnrecognizedPropertyException.from(_parser, instanceOrClass, fieldName, propIds); [EOL] }
public JsonMappingException weirdKeyException(Class<?> keyClass, String keyValue, String msg) { [EOL]     return InvalidFormatException.from(_parser, "Can not construct Map key of type " + keyClass.getName() + " from String \"" + _desc(keyValue) + "\": " + msg, keyValue, keyClass); [EOL] }
public JsonMappingException weirdKeyException(Class<?> keyClass, String keyValue, String msg) { [EOL]     return InvalidFormatException.from(_parser, "Can not construct Map key of type " + keyClass.getName() + " from String \"" + _desc(keyValue) + "\": " + msg, keyValue, keyClass); [EOL] }
public JsonMappingException weirdKeyException(Class<?> keyClass, String keyValue, String msg) { [EOL]     return InvalidFormatException.from(_parser, "Can not construct Map key of type " + keyClass.getName() + " from String \"" + _desc(keyValue) + "\": " + msg, keyValue, keyClass); [EOL] }
public JsonMappingException wrongTokenException(JsonParser jp, JsonToken expToken, String msg) { [EOL]     return JsonMappingException.from(jp, "Unexpected token (" + jp.getCurrentToken() + "), expected " + expToken + ": " + msg); [EOL] }
public JsonMappingException wrongTokenException(JsonParser jp, JsonToken expToken, String msg) { [EOL]     return JsonMappingException.from(jp, "Unexpected token (" + jp.getCurrentToken() + "), expected " + expToken + ": " + msg); [EOL] }
public JsonMappingException wrongTokenException(JsonParser jp, JsonToken expToken, String msg) { [EOL]     return JsonMappingException.from(jp, "Unexpected token (" + jp.getCurrentToken() + "), expected " + expToken + ": " + msg); [EOL] }
protected DateFormat getDateFormat() { [EOL]     if (_dateFormat != null) { [EOL]         return _dateFormat; [EOL]     } [EOL]     DateFormat df = _config.getDateFormat(); [EOL]     _dateFormat = df = (DateFormat) df.clone(); [EOL]     return df; [EOL] }
protected DateFormat getDateFormat() { [EOL]     if (_dateFormat != null) { [EOL]         return _dateFormat; [EOL]     } [EOL]     DateFormat df = _config.getDateFormat(); [EOL]     _dateFormat = df = (DateFormat) df.clone(); [EOL]     return df; [EOL] }
@Override [EOL] public Date parse(String source, ParsePosition pos) { [EOL]     pos.setIndex(source.length()); [EOL]     return ISO8601Utils.parse(source); [EOL] }
@Override [EOL] public Date parse(String source, ParsePosition pos) { [EOL]     pos.setIndex(source.length()); [EOL]     return ISO8601Utils.parse(source); [EOL] }
protected DefaultDeserializationContext(DefaultDeserializationContext src, DeserializerFactory factory) { [EOL]     super(src, factory); [EOL] }
@Override [EOL] public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     KeyDeserializer deser; [EOL]     if (deserDef instanceof KeyDeserializer) { [EOL]         deser = (KeyDeserializer) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + deserDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == KeyDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!KeyDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<KeyDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (KeyDeserializer) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     KeyDeserializer deser; [EOL]     if (deserDef instanceof KeyDeserializer) { [EOL]         deser = (KeyDeserializer) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + deserDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == KeyDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!KeyDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<KeyDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (KeyDeserializer) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     KeyDeserializer deser; [EOL]     if (deserDef instanceof KeyDeserializer) { [EOL]         deser = (KeyDeserializer) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + deserDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == KeyDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!KeyDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<KeyDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (KeyDeserializer) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     KeyDeserializer deser; [EOL]     if (deserDef instanceof KeyDeserializer) { [EOL]         deser = (KeyDeserializer) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + deserDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == KeyDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!KeyDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<KeyDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (KeyDeserializer) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     KeyDeserializer deser; [EOL]     if (deserDef instanceof KeyDeserializer) { [EOL]         deser = (KeyDeserializer) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + deserDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == KeyDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!KeyDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<KeyDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (KeyDeserializer) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     KeyDeserializer deser; [EOL]     if (deserDef instanceof KeyDeserializer) { [EOL]         deser = (KeyDeserializer) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + deserDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == KeyDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!KeyDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<KeyDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (KeyDeserializer) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     KeyDeserializer deser; [EOL]     if (deserDef instanceof KeyDeserializer) { [EOL]         deser = (KeyDeserializer) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + deserDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == KeyDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!KeyDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<KeyDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (KeyDeserializer) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public final KeyDeserializer keyDeserializerInstance(Annotated annotated, Object deserDef) throws JsonMappingException { [EOL]     if (deserDef == null) { [EOL]         return null; [EOL]     } [EOL]     KeyDeserializer deser; [EOL]     if (deserDef instanceof KeyDeserializer) { [EOL]         deser = (KeyDeserializer) deserDef; [EOL]     } else { [EOL]         if (!(deserDef instanceof Class)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + deserDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]         } [EOL]         Class<?> deserClass = (Class<?>) deserDef; [EOL]         if (deserClass == KeyDeserializer.None.class || deserClass == NoClass.class) { [EOL]             return null; [EOL]         } [EOL]         if (!KeyDeserializer.class.isAssignableFrom(deserClass)) { [EOL]             throw new IllegalStateException("AnnotationIntrospector returned Class " + deserClass.getName() + "; expected Class<KeyDeserializer>"); [EOL]         } [EOL]         HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]         deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, annotated, deserClass); [EOL]         if (deser == null) { [EOL]             deser = (KeyDeserializer) ClassUtil.createInstance(deserClass, _config.canOverrideAccessModifiers()); [EOL]         } [EOL]     } [EOL]     if (deser instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) deser).resolve(this); [EOL]     } [EOL]     return deser; [EOL] }
protected Impl(Impl src, DeserializerFactory factory) { [EOL]     super(src, factory); [EOL] }
@Override [EOL] public DefaultDeserializationContext with(DeserializerFactory factory) { [EOL]     return new Impl(this, factory); [EOL] }
@Override [EOL] public DefaultDeserializationContext with(DeserializerFactory factory) { [EOL]     return new Impl(this, factory); [EOL] }
public JsonValueSerializer(Method valueMethod, JsonSerializer<Object> ser) { [EOL]     super(Object.class); [EOL]     _accessorMethod = valueMethod; [EOL]     _valueSerializer = ser; [EOL]     _property = null; [EOL]     _forceTypeInformation = true; [EOL] }
public JsonValueSerializer(Method valueMethod, JsonSerializer<Object> ser) { [EOL]     super(Object.class); [EOL]     _accessorMethod = valueMethod; [EOL]     _valueSerializer = ser; [EOL]     _property = null; [EOL]     _forceTypeInformation = true; [EOL] }
public JsonValueSerializer(Method valueMethod, JsonSerializer<Object> ser) { [EOL]     super(Object.class); [EOL]     _accessorMethod = valueMethod; [EOL]     _valueSerializer = ser; [EOL]     _property = null; [EOL]     _forceTypeInformation = true; [EOL] }
@SuppressWarnings("unchecked") [EOL] public JsonValueSerializer(JsonValueSerializer src, BeanProperty property, JsonSerializer<?> ser, boolean forceTypeInfo) { [EOL]     super(_notNullClass(src.handledType())); [EOL]     _accessorMethod = src._accessorMethod; [EOL]     _valueSerializer = (JsonSerializer<Object>) ser; [EOL]     _property = property; [EOL]     _forceTypeInformation = forceTypeInfo; [EOL] }
@SuppressWarnings("unchecked") [EOL] public JsonValueSerializer(JsonValueSerializer src, BeanProperty property, JsonSerializer<?> ser, boolean forceTypeInfo) { [EOL]     super(_notNullClass(src.handledType())); [EOL]     _accessorMethod = src._accessorMethod; [EOL]     _valueSerializer = (JsonSerializer<Object>) ser; [EOL]     _property = property; [EOL]     _forceTypeInformation = forceTypeInfo; [EOL] }
@SuppressWarnings("unchecked") [EOL] private final static Class<Object> _notNullClass(Class<?> cls) { [EOL]     return (cls == null) ? Object.class : (Class<Object>) cls; [EOL] }
@SuppressWarnings("unchecked") [EOL] private final static Class<Object> _notNullClass(Class<?> cls) { [EOL]     return (cls == null) ? Object.class : (Class<Object>) cls; [EOL] }
public JsonValueSerializer withResolved(BeanProperty property, JsonSerializer<?> ser, boolean forceTypeInfo) { [EOL]     if (_property == property && _valueSerializer == ser && forceTypeInfo == _forceTypeInformation) { [EOL]         return this; [EOL]     } [EOL]     return new JsonValueSerializer(this, property, ser, forceTypeInfo); [EOL] }
public JsonValueSerializer withResolved(BeanProperty property, JsonSerializer<?> ser, boolean forceTypeInfo) { [EOL]     if (_property == property && _valueSerializer == ser && forceTypeInfo == _forceTypeInformation) { [EOL]         return this; [EOL]     } [EOL]     return new JsonValueSerializer(this, property, ser, forceTypeInfo); [EOL] }
public JsonValueSerializer withResolved(BeanProperty property, JsonSerializer<?> ser, boolean forceTypeInfo) { [EOL]     if (_property == property && _valueSerializer == ser && forceTypeInfo == _forceTypeInformation) { [EOL]         return this; [EOL]     } [EOL]     return new JsonValueSerializer(this, property, ser, forceTypeInfo); [EOL] }
public JsonValueSerializer withResolved(BeanProperty property, JsonSerializer<?> ser, boolean forceTypeInfo) { [EOL]     if (_property == property && _valueSerializer == ser && forceTypeInfo == _forceTypeInformation) { [EOL]         return this; [EOL]     } [EOL]     return new JsonValueSerializer(this, property, ser, forceTypeInfo); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = _valueSerializer; [EOL]     if (ser == null) { [EOL]         if (provider.isEnabled(MapperFeature.USE_STATIC_TYPING) || Modifier.isFinal(_accessorMethod.getReturnType().getModifiers())) { [EOL]             JavaType t = provider.constructType(_accessorMethod.getGenericReturnType()); [EOL]             ser = provider.findTypedValueSerializer(t, false, _property); [EOL]             boolean forceTypeInformation = isNaturalTypeWithStdHandling(t.getRawClass(), ser); [EOL]             return withResolved(property, ser, forceTypeInformation); [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         return withResolved(property, ser, _forceTypeInformation); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = _valueSerializer; [EOL]     if (ser == null) { [EOL]         if (provider.isEnabled(MapperFeature.USE_STATIC_TYPING) || Modifier.isFinal(_accessorMethod.getReturnType().getModifiers())) { [EOL]             JavaType t = provider.constructType(_accessorMethod.getGenericReturnType()); [EOL]             ser = provider.findTypedValueSerializer(t, false, _property); [EOL]             boolean forceTypeInformation = isNaturalTypeWithStdHandling(t.getRawClass(), ser); [EOL]             return withResolved(property, ser, forceTypeInformation); [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         return withResolved(property, ser, _forceTypeInformation); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = _valueSerializer; [EOL]     if (ser == null) { [EOL]         if (provider.isEnabled(MapperFeature.USE_STATIC_TYPING) || Modifier.isFinal(_accessorMethod.getReturnType().getModifiers())) { [EOL]             JavaType t = provider.constructType(_accessorMethod.getGenericReturnType()); [EOL]             ser = provider.findTypedValueSerializer(t, false, _property); [EOL]             boolean forceTypeInformation = isNaturalTypeWithStdHandling(t.getRawClass(), ser); [EOL]             return withResolved(property, ser, forceTypeInformation); [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         return withResolved(property, ser, _forceTypeInformation); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = _valueSerializer; [EOL]     if (ser == null) { [EOL]         if (provider.isEnabled(MapperFeature.USE_STATIC_TYPING) || Modifier.isFinal(_accessorMethod.getReturnType().getModifiers())) { [EOL]             JavaType t = provider.constructType(_accessorMethod.getGenericReturnType()); [EOL]             ser = provider.findTypedValueSerializer(t, false, _property); [EOL]             boolean forceTypeInformation = isNaturalTypeWithStdHandling(t.getRawClass(), ser); [EOL]             return withResolved(property, ser, forceTypeInformation); [EOL]         } [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]         return withResolved(property, ser, _forceTypeInformation); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public void serialize(Object bean, JsonGenerator jgen, SerializerProvider prov) throws IOException, JsonGenerationException { [EOL]     try { [EOL]         Object value = _accessorMethod.invoke(bean); [EOL]         if (value == null) { [EOL]             prov.defaultSerializeNull(jgen); [EOL]             return; [EOL]         } [EOL]         JsonSerializer<Object> ser = _valueSerializer; [EOL]         if (ser == null) { [EOL]             Class<?> c = value.getClass(); [EOL]             ser = prov.findTypedValueSerializer(c, true, _property); [EOL]         } [EOL]         ser.serialize(value, jgen, prov); [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + "()"); [EOL]     } [EOL] }
@Override [EOL] public void serialize(Object bean, JsonGenerator jgen, SerializerProvider prov) throws IOException, JsonGenerationException { [EOL]     try { [EOL]         Object value = _accessorMethod.invoke(bean); [EOL]         if (value == null) { [EOL]             prov.defaultSerializeNull(jgen); [EOL]             return; [EOL]         } [EOL]         JsonSerializer<Object> ser = _valueSerializer; [EOL]         if (ser == null) { [EOL]             Class<?> c = value.getClass(); [EOL]             ser = prov.findTypedValueSerializer(c, true, _property); [EOL]         } [EOL]         ser.serialize(value, jgen, prov); [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + "()"); [EOL]     } [EOL] }
@Override [EOL] public void serialize(Object bean, JsonGenerator jgen, SerializerProvider prov) throws IOException, JsonGenerationException { [EOL]     try { [EOL]         Object value = _accessorMethod.invoke(bean); [EOL]         if (value == null) { [EOL]             prov.defaultSerializeNull(jgen); [EOL]             return; [EOL]         } [EOL]         JsonSerializer<Object> ser = _valueSerializer; [EOL]         if (ser == null) { [EOL]             Class<?> c = value.getClass(); [EOL]             ser = prov.findTypedValueSerializer(c, true, _property); [EOL]         } [EOL]         ser.serialize(value, jgen, prov); [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + "()"); [EOL]     } [EOL] }
@Override [EOL] public void serialize(Object bean, JsonGenerator jgen, SerializerProvider prov) throws IOException, JsonGenerationException { [EOL]     try { [EOL]         Object value = _accessorMethod.invoke(bean); [EOL]         if (value == null) { [EOL]             prov.defaultSerializeNull(jgen); [EOL]             return; [EOL]         } [EOL]         JsonSerializer<Object> ser = _valueSerializer; [EOL]         if (ser == null) { [EOL]             Class<?> c = value.getClass(); [EOL]             ser = prov.findTypedValueSerializer(c, true, _property); [EOL]         } [EOL]         ser.serialize(value, jgen, prov); [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + "()"); [EOL]     } [EOL] }
@Override [EOL] public void serialize(Object bean, JsonGenerator jgen, SerializerProvider prov) throws IOException, JsonGenerationException { [EOL]     try { [EOL]         Object value = _accessorMethod.invoke(bean); [EOL]         if (value == null) { [EOL]             prov.defaultSerializeNull(jgen); [EOL]             return; [EOL]         } [EOL]         JsonSerializer<Object> ser = _valueSerializer; [EOL]         if (ser == null) { [EOL]             Class<?> c = value.getClass(); [EOL]             ser = prov.findTypedValueSerializer(c, true, _property); [EOL]         } [EOL]         ser.serialize(value, jgen, prov); [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + "()"); [EOL]     } [EOL] }
@Override [EOL] public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer0) throws IOException, JsonProcessingException { [EOL]     Object value = null; [EOL]     try { [EOL]         value = _accessorMethod.invoke(bean); [EOL]         if (value == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]             return; [EOL]         } [EOL]         JsonSerializer<Object> ser = _valueSerializer; [EOL]         if (ser == null) { [EOL]             ser = provider.findValueSerializer(value.getClass(), _property); [EOL]         } else { [EOL]             if (_forceTypeInformation) { [EOL]                 typeSer0.writeTypePrefixForScalar(bean, jgen); [EOL]                 ser.serialize(value, jgen, provider); [EOL]                 typeSer0.writeTypeSuffixForScalar(bean, jgen); [EOL]                 return; [EOL]             } [EOL]         } [EOL]         ser.serializeWithType(value, jgen, provider, typeSer0); [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + "()"); [EOL]     } [EOL] }
@Override [EOL] public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer0) throws IOException, JsonProcessingException { [EOL]     Object value = null; [EOL]     try { [EOL]         value = _accessorMethod.invoke(bean); [EOL]         if (value == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]             return; [EOL]         } [EOL]         JsonSerializer<Object> ser = _valueSerializer; [EOL]         if (ser == null) { [EOL]             ser = provider.findValueSerializer(value.getClass(), _property); [EOL]         } else { [EOL]             if (_forceTypeInformation) { [EOL]                 typeSer0.writeTypePrefixForScalar(bean, jgen); [EOL]                 ser.serialize(value, jgen, provider); [EOL]                 typeSer0.writeTypeSuffixForScalar(bean, jgen); [EOL]                 return; [EOL]             } [EOL]         } [EOL]         ser.serializeWithType(value, jgen, provider, typeSer0); [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + "()"); [EOL]     } [EOL] }
@Override [EOL] public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer0) throws IOException, JsonProcessingException { [EOL]     Object value = null; [EOL]     try { [EOL]         value = _accessorMethod.invoke(bean); [EOL]         if (value == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]             return; [EOL]         } [EOL]         JsonSerializer<Object> ser = _valueSerializer; [EOL]         if (ser == null) { [EOL]             ser = provider.findValueSerializer(value.getClass(), _property); [EOL]         } else { [EOL]             if (_forceTypeInformation) { [EOL]                 typeSer0.writeTypePrefixForScalar(bean, jgen); [EOL]                 ser.serialize(value, jgen, provider); [EOL]                 typeSer0.writeTypeSuffixForScalar(bean, jgen); [EOL]                 return; [EOL]             } [EOL]         } [EOL]         ser.serializeWithType(value, jgen, provider, typeSer0); [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + "()"); [EOL]     } [EOL] }
@Override [EOL] public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer0) throws IOException, JsonProcessingException { [EOL]     Object value = null; [EOL]     try { [EOL]         value = _accessorMethod.invoke(bean); [EOL]         if (value == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]             return; [EOL]         } [EOL]         JsonSerializer<Object> ser = _valueSerializer; [EOL]         if (ser == null) { [EOL]             ser = provider.findValueSerializer(value.getClass(), _property); [EOL]         } else { [EOL]             if (_forceTypeInformation) { [EOL]                 typeSer0.writeTypePrefixForScalar(bean, jgen); [EOL]                 ser.serialize(value, jgen, provider); [EOL]                 typeSer0.writeTypeSuffixForScalar(bean, jgen); [EOL]                 return; [EOL]             } [EOL]         } [EOL]         ser.serializeWithType(value, jgen, provider, typeSer0); [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + "()"); [EOL]     } [EOL] }
@Override [EOL] public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer0) throws IOException, JsonProcessingException { [EOL]     Object value = null; [EOL]     try { [EOL]         value = _accessorMethod.invoke(bean); [EOL]         if (value == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]             return; [EOL]         } [EOL]         JsonSerializer<Object> ser = _valueSerializer; [EOL]         if (ser == null) { [EOL]             ser = provider.findValueSerializer(value.getClass(), _property); [EOL]         } else { [EOL]             if (_forceTypeInformation) { [EOL]                 typeSer0.writeTypePrefixForScalar(bean, jgen); [EOL]                 ser.serialize(value, jgen, provider); [EOL]                 typeSer0.writeTypeSuffixForScalar(bean, jgen); [EOL]                 return; [EOL]             } [EOL]         } [EOL]         ser.serializeWithType(value, jgen, provider, typeSer0); [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         Throwable t = e; [EOL]         while (t instanceof InvocationTargetException && t.getCause() != null) { [EOL]             t = t.getCause(); [EOL]         } [EOL]         if (t instanceof Error) { [EOL]             throw (Error) t; [EOL]         } [EOL]         throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + "()"); [EOL]     } [EOL] }
protected boolean isNaturalTypeWithStdHandling(Class<?> rawType, JsonSerializer<?> ser) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType != Integer.TYPE && rawType != Boolean.TYPE && rawType != Double.TYPE) { [EOL]             return false; [EOL]         } [EOL]     } else { [EOL]         if (rawType != String.class && rawType != Integer.class && rawType != Boolean.class && rawType != Double.class) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return isDefaultSerializer(ser); [EOL] }
@Override [EOL] public String getInternalName() { [EOL]     return _internalName; [EOL] }
@Override [EOL] public AnnotatedMethod getGetter() { [EOL]     if (_getters == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedMethod getter = _getters.value; [EOL]     Linked<AnnotatedMethod> next = _getters.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedMethod nextGetter = next.value; [EOL]         Class<?> getterClass = getter.getDeclaringClass(); [EOL]         Class<?> nextClass = nextGetter.getDeclaringClass(); [EOL]         if (getterClass != nextClass) { [EOL]             if (getterClass.isAssignableFrom(nextClass)) { [EOL]                 getter = nextGetter; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(getterClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Conflicting getter definitions for property \"" + getName() + "\": " + getter.getFullName() + " vs " + nextGetter.getFullName()); [EOL]     } [EOL]     return getter; [EOL] }
@Override [EOL] public AnnotatedMethod getGetter() { [EOL]     if (_getters == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedMethod getter = _getters.value; [EOL]     Linked<AnnotatedMethod> next = _getters.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedMethod nextGetter = next.value; [EOL]         Class<?> getterClass = getter.getDeclaringClass(); [EOL]         Class<?> nextClass = nextGetter.getDeclaringClass(); [EOL]         if (getterClass != nextClass) { [EOL]             if (getterClass.isAssignableFrom(nextClass)) { [EOL]                 getter = nextGetter; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(getterClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Conflicting getter definitions for property \"" + getName() + "\": " + getter.getFullName() + " vs " + nextGetter.getFullName()); [EOL]     } [EOL]     return getter; [EOL] }
@Override [EOL] public AnnotatedMethod getGetter() { [EOL]     if (_getters == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedMethod getter = _getters.value; [EOL]     Linked<AnnotatedMethod> next = _getters.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedMethod nextGetter = next.value; [EOL]         Class<?> getterClass = getter.getDeclaringClass(); [EOL]         Class<?> nextClass = nextGetter.getDeclaringClass(); [EOL]         if (getterClass != nextClass) { [EOL]             if (getterClass.isAssignableFrom(nextClass)) { [EOL]                 getter = nextGetter; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(getterClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Conflicting getter definitions for property \"" + getName() + "\": " + getter.getFullName() + " vs " + nextGetter.getFullName()); [EOL]     } [EOL]     return getter; [EOL] }
@Override [EOL] public AnnotatedMethod getGetter() { [EOL]     if (_getters == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedMethod getter = _getters.value; [EOL]     Linked<AnnotatedMethod> next = _getters.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedMethod nextGetter = next.value; [EOL]         Class<?> getterClass = getter.getDeclaringClass(); [EOL]         Class<?> nextClass = nextGetter.getDeclaringClass(); [EOL]         if (getterClass != nextClass) { [EOL]             if (getterClass.isAssignableFrom(nextClass)) { [EOL]                 getter = nextGetter; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(getterClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Conflicting getter definitions for property \"" + getName() + "\": " + getter.getFullName() + " vs " + nextGetter.getFullName()); [EOL]     } [EOL]     return getter; [EOL] }
@Override [EOL] public AnnotatedMethod getGetter() { [EOL]     if (_getters == null) { [EOL]         return null; [EOL]     } [EOL]     AnnotatedMethod getter = _getters.value; [EOL]     Linked<AnnotatedMethod> next = _getters.next; [EOL]     for (; next != null; next = next.next) { [EOL]         AnnotatedMethod nextGetter = next.value; [EOL]         Class<?> getterClass = getter.getDeclaringClass(); [EOL]         Class<?> nextClass = nextGetter.getDeclaringClass(); [EOL]         if (getterClass != nextClass) { [EOL]             if (getterClass.isAssignableFrom(nextClass)) { [EOL]                 getter = nextGetter; [EOL]                 continue; [EOL]             } [EOL]             if (nextClass.isAssignableFrom(getterClass)) { [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         throw new IllegalArgumentException("Conflicting getter definitions for property \"" + getName() + "\": " + getter.getFullName() + " vs " + nextGetter.getFullName()); [EOL]     } [EOL]     return getter; [EOL] }
@Override [EOL] public AnnotatedParameter getConstructorParameter() { [EOL]     if (_ctorParameters == null) { [EOL]         return null; [EOL]     } [EOL]     Linked<AnnotatedParameter> curr = _ctorParameters; [EOL]     do { [EOL]         if (curr.value.getOwner() instanceof AnnotatedConstructor) { [EOL]             return curr.value; [EOL]         } [EOL]         curr = curr.next; [EOL]     } while (curr != null); [EOL]     return _ctorParameters.value; [EOL] }
@Override [EOL] public AnnotatedParameter getConstructorParameter() { [EOL]     if (_ctorParameters == null) { [EOL]         return null; [EOL]     } [EOL]     Linked<AnnotatedParameter> curr = _ctorParameters; [EOL]     do { [EOL]         if (curr.value.getOwner() instanceof AnnotatedConstructor) { [EOL]             return curr.value; [EOL]         } [EOL]         curr = curr.next; [EOL]     } while (curr != null); [EOL]     return _ctorParameters.value; [EOL] }
@Override [EOL] public AnnotatedParameter getConstructorParameter() { [EOL]     if (_ctorParameters == null) { [EOL]         return null; [EOL]     } [EOL]     Linked<AnnotatedParameter> curr = _ctorParameters; [EOL]     do { [EOL]         if (curr.value.getOwner() instanceof AnnotatedConstructor) { [EOL]             return curr.value; [EOL]         } [EOL]         curr = curr.next; [EOL]     } while (curr != null); [EOL]     return _ctorParameters.value; [EOL] }
private Linked<? extends AnnotatedMember> findRenamed(Linked<? extends AnnotatedMember> node, Linked<? extends AnnotatedMember> renamed) { [EOL]     for (; node != null; node = node.next) { [EOL]         String explName = node.explicitName; [EOL]         if (explName == null) { [EOL]             continue; [EOL]         } [EOL]         if (explName.equals(_name)) { [EOL]             continue; [EOL]         } [EOL]         if (renamed == null) { [EOL]             renamed = node; [EOL]         } else { [EOL]             if (!explName.equals(renamed.explicitName)) { [EOL]                 throw new IllegalStateException("Conflicting property name definitions: '" + renamed.explicitName + "' (for " + renamed.value + ") vs '" + node.explicitName + "' (for " + node.value + ")"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return renamed; [EOL] }
public DoubleNode(double v) { [EOL]     _value = v; [EOL] }
public static DoubleNode valueOf(double v) { [EOL]     return new DoubleNode(v); [EOL] }
public static DoubleNode valueOf(double v) { [EOL]     return new DoubleNode(v); [EOL] }
public static DoubleNode valueOf(double v) { [EOL]     return new DoubleNode(v); [EOL] }
@Override [EOL] public JsonToken asToken() { [EOL]     return JsonToken.VALUE_NUMBER_FLOAT; [EOL] }
protected PropertyBasedCreator(ValueInstantiator valueInstantiator, SettableBeanProperty[] creatorProps, Object[] defaultValues) { [EOL]     _valueInstantiator = valueInstantiator; [EOL]     _properties = new HashMap<String, SettableBeanProperty>(); [EOL]     SettableBeanProperty[] propertiesWithInjectables = null; [EOL]     final int len = creatorProps.length; [EOL]     _propertyCount = len; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         SettableBeanProperty prop = creatorProps[i]; [EOL]         _properties.put(prop.getName(), prop); [EOL]         Object injectableValueId = prop.getInjectableValueId(); [EOL]         if (injectableValueId != null) { [EOL]             if (propertiesWithInjectables == null) { [EOL]                 propertiesWithInjectables = new SettableBeanProperty[len]; [EOL]             } [EOL]             propertiesWithInjectables[i] = prop; [EOL]         } [EOL]     } [EOL]     _defaultValues = defaultValues; [EOL]     _propertiesWithInjectables = propertiesWithInjectables; [EOL] }
public static PropertyBasedCreator construct(DeserializationContext ctxt, ValueInstantiator valueInstantiator, SettableBeanProperty[] srcProps) throws JsonMappingException { [EOL]     final int len = srcProps.length; [EOL]     SettableBeanProperty[] creatorProps = new SettableBeanProperty[len]; [EOL]     Object[] defaultValues = null; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         SettableBeanProperty prop = srcProps[i]; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             prop = prop.withValueDeserializer(ctxt.findContextualValueDeserializer(prop.getType(), prop)); [EOL]         } [EOL]         creatorProps[i] = prop; [EOL]         JsonDeserializer<?> deser = prop.getValueDeserializer(); [EOL]         Object nullValue = (deser == null) ? null : deser.getNullValue(); [EOL]         if ((nullValue == null) && prop.getType().isPrimitive()) { [EOL]             nullValue = ClassUtil.defaultValue(prop.getType().getRawClass()); [EOL]         } [EOL]         if (nullValue != null) { [EOL]             if (defaultValues == null) { [EOL]                 defaultValues = new Object[len]; [EOL]             } [EOL]             defaultValues[i] = nullValue; [EOL]         } [EOL]     } [EOL]     return new PropertyBasedCreator(valueInstantiator, creatorProps, defaultValues); [EOL] }
public static PropertyBasedCreator construct(DeserializationContext ctxt, ValueInstantiator valueInstantiator, SettableBeanProperty[] srcProps) throws JsonMappingException { [EOL]     final int len = srcProps.length; [EOL]     SettableBeanProperty[] creatorProps = new SettableBeanProperty[len]; [EOL]     Object[] defaultValues = null; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         SettableBeanProperty prop = srcProps[i]; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             prop = prop.withValueDeserializer(ctxt.findContextualValueDeserializer(prop.getType(), prop)); [EOL]         } [EOL]         creatorProps[i] = prop; [EOL]         JsonDeserializer<?> deser = prop.getValueDeserializer(); [EOL]         Object nullValue = (deser == null) ? null : deser.getNullValue(); [EOL]         if ((nullValue == null) && prop.getType().isPrimitive()) { [EOL]             nullValue = ClassUtil.defaultValue(prop.getType().getRawClass()); [EOL]         } [EOL]         if (nullValue != null) { [EOL]             if (defaultValues == null) { [EOL]                 defaultValues = new Object[len]; [EOL]             } [EOL]             defaultValues[i] = nullValue; [EOL]         } [EOL]     } [EOL]     return new PropertyBasedCreator(valueInstantiator, creatorProps, defaultValues); [EOL] }
public static PropertyBasedCreator construct(DeserializationContext ctxt, ValueInstantiator valueInstantiator, SettableBeanProperty[] srcProps) throws JsonMappingException { [EOL]     final int len = srcProps.length; [EOL]     SettableBeanProperty[] creatorProps = new SettableBeanProperty[len]; [EOL]     Object[] defaultValues = null; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         SettableBeanProperty prop = srcProps[i]; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             prop = prop.withValueDeserializer(ctxt.findContextualValueDeserializer(prop.getType(), prop)); [EOL]         } [EOL]         creatorProps[i] = prop; [EOL]         JsonDeserializer<?> deser = prop.getValueDeserializer(); [EOL]         Object nullValue = (deser == null) ? null : deser.getNullValue(); [EOL]         if ((nullValue == null) && prop.getType().isPrimitive()) { [EOL]             nullValue = ClassUtil.defaultValue(prop.getType().getRawClass()); [EOL]         } [EOL]         if (nullValue != null) { [EOL]             if (defaultValues == null) { [EOL]                 defaultValues = new Object[len]; [EOL]             } [EOL]             defaultValues[i] = nullValue; [EOL]         } [EOL]     } [EOL]     return new PropertyBasedCreator(valueInstantiator, creatorProps, defaultValues); [EOL] }
public static PropertyBasedCreator construct(DeserializationContext ctxt, ValueInstantiator valueInstantiator, SettableBeanProperty[] srcProps) throws JsonMappingException { [EOL]     final int len = srcProps.length; [EOL]     SettableBeanProperty[] creatorProps = new SettableBeanProperty[len]; [EOL]     Object[] defaultValues = null; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         SettableBeanProperty prop = srcProps[i]; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             prop = prop.withValueDeserializer(ctxt.findContextualValueDeserializer(prop.getType(), prop)); [EOL]         } [EOL]         creatorProps[i] = prop; [EOL]         JsonDeserializer<?> deser = prop.getValueDeserializer(); [EOL]         Object nullValue = (deser == null) ? null : deser.getNullValue(); [EOL]         if ((nullValue == null) && prop.getType().isPrimitive()) { [EOL]             nullValue = ClassUtil.defaultValue(prop.getType().getRawClass()); [EOL]         } [EOL]         if (nullValue != null) { [EOL]             if (defaultValues == null) { [EOL]                 defaultValues = new Object[len]; [EOL]             } [EOL]             defaultValues[i] = nullValue; [EOL]         } [EOL]     } [EOL]     return new PropertyBasedCreator(valueInstantiator, creatorProps, defaultValues); [EOL] }
public Collection<SettableBeanProperty> properties() { [EOL]     return _properties.values(); [EOL] }
public Collection<SettableBeanProperty> properties() { [EOL]     return _properties.values(); [EOL] }
public SettableBeanProperty findCreatorProperty(String name) { [EOL]     return _properties.get(name); [EOL] }
public SettableBeanProperty findCreatorProperty(String name) { [EOL]     return _properties.get(name); [EOL] }
public PropertyValueBuffer startBuilding(JsonParser jp, DeserializationContext ctxt, ObjectIdReader oir) { [EOL]     PropertyValueBuffer buffer = new PropertyValueBuffer(jp, ctxt, _propertyCount, oir); [EOL]     if (_propertiesWithInjectables != null) { [EOL]         buffer.inject(_propertiesWithInjectables); [EOL]     } [EOL]     return buffer; [EOL] }
public PropertyValueBuffer startBuilding(JsonParser jp, DeserializationContext ctxt, ObjectIdReader oir) { [EOL]     PropertyValueBuffer buffer = new PropertyValueBuffer(jp, ctxt, _propertyCount, oir); [EOL]     if (_propertiesWithInjectables != null) { [EOL]         buffer.inject(_propertiesWithInjectables); [EOL]     } [EOL]     return buffer; [EOL] }
public Object build(DeserializationContext ctxt, PropertyValueBuffer buffer) throws IOException { [EOL]     Object bean = _valueInstantiator.createFromObjectWith(ctxt, buffer.getParameters(_defaultValues)); [EOL]     bean = buffer.handleIdValue(ctxt, bean); [EOL]     for (PropertyValue pv = buffer.buffered(); pv != null; pv = pv.next) { [EOL]         pv.assign(bean); [EOL]     } [EOL]     return bean; [EOL] }
public Object build(DeserializationContext ctxt, PropertyValueBuffer buffer) throws IOException { [EOL]     Object bean = _valueInstantiator.createFromObjectWith(ctxt, buffer.getParameters(_defaultValues)); [EOL]     bean = buffer.handleIdValue(ctxt, bean); [EOL]     for (PropertyValue pv = buffer.buffered(); pv != null; pv = pv.next) { [EOL]         pv.assign(bean); [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public final boolean isArray() { [EOL]     return getNodeType() == JsonNodeType.ARRAY; [EOL] }
@Override [EOL] public final boolean isArray() { [EOL]     return getNodeType() == JsonNodeType.ARRAY; [EOL] }
@Override [EOL] public final boolean isObject() { [EOL]     return getNodeType() == JsonNodeType.OBJECT; [EOL] }
@Override [EOL] public final boolean isObject() { [EOL]     return getNodeType() == JsonNodeType.OBJECT; [EOL] }
public boolean isFloatingPointNumber() { [EOL]     return false; [EOL] }
public final boolean isTextual() { [EOL]     return getNodeType() == JsonNodeType.STRING; [EOL] }
public final boolean isTextual() { [EOL]     return getNodeType() == JsonNodeType.STRING; [EOL] }
public boolean has(String fieldName) { [EOL]     return get(fieldName) != null; [EOL] }
public boolean has(String fieldName) { [EOL]     return get(fieldName) != null; [EOL] }
@Override [EOL] public final Iterator<JsonNode> iterator() { [EOL]     return elements(); [EOL] }
public final List<JsonNode> findValues(String fieldName) { [EOL]     List<JsonNode> result = findValues(fieldName, null); [EOL]     if (result == null) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     return result; [EOL] }
public final List<JsonNode> findParents(String fieldName) { [EOL]     List<JsonNode> result = findParents(fieldName, null); [EOL]     if (result == null) { [EOL]         return Collections.emptyList(); [EOL]     } [EOL]     return result; [EOL] }
public static Class<?> findClass(String className) throws ClassNotFoundException { [EOL]     if (className.indexOf('.') < 0) { [EOL]         if ("int".equals(className)) [EOL]             return Integer.TYPE; [EOL]         if ("long".equals(className)) [EOL]             return Long.TYPE; [EOL]         if ("float".equals(className)) [EOL]             return Float.TYPE; [EOL]         if ("double".equals(className)) [EOL]             return Double.TYPE; [EOL]         if ("boolean".equals(className)) [EOL]             return Boolean.TYPE; [EOL]         if ("byte".equals(className)) [EOL]             return Byte.TYPE; [EOL]         if ("char".equals(className)) [EOL]             return Character.TYPE; [EOL]         if ("short".equals(className)) [EOL]             return Short.TYPE; [EOL]         if ("void".equals(className)) [EOL]             return Void.TYPE; [EOL]     } [EOL]     Throwable prob = null; [EOL]     ClassLoader loader = Thread.currentThread().getContextClassLoader(); [EOL]     if (loader != null) { [EOL]         try { [EOL]             return Class.forName(className, true, loader); [EOL]         } catch (Exception e) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return Class.forName(className); [EOL]     } catch (Exception e) { [EOL]         if (prob == null) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     if (prob instanceof RuntimeException) { [EOL]         throw (RuntimeException) prob; [EOL]     } [EOL]     throw new ClassNotFoundException(prob.getMessage(), prob); [EOL] }
public static Class<?> findClass(String className) throws ClassNotFoundException { [EOL]     if (className.indexOf('.') < 0) { [EOL]         if ("int".equals(className)) [EOL]             return Integer.TYPE; [EOL]         if ("long".equals(className)) [EOL]             return Long.TYPE; [EOL]         if ("float".equals(className)) [EOL]             return Float.TYPE; [EOL]         if ("double".equals(className)) [EOL]             return Double.TYPE; [EOL]         if ("boolean".equals(className)) [EOL]             return Boolean.TYPE; [EOL]         if ("byte".equals(className)) [EOL]             return Byte.TYPE; [EOL]         if ("char".equals(className)) [EOL]             return Character.TYPE; [EOL]         if ("short".equals(className)) [EOL]             return Short.TYPE; [EOL]         if ("void".equals(className)) [EOL]             return Void.TYPE; [EOL]     } [EOL]     Throwable prob = null; [EOL]     ClassLoader loader = Thread.currentThread().getContextClassLoader(); [EOL]     if (loader != null) { [EOL]         try { [EOL]             return Class.forName(className, true, loader); [EOL]         } catch (Exception e) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return Class.forName(className); [EOL]     } catch (Exception e) { [EOL]         if (prob == null) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     if (prob instanceof RuntimeException) { [EOL]         throw (RuntimeException) prob; [EOL]     } [EOL]     throw new ClassNotFoundException(prob.getMessage(), prob); [EOL] }
public static Class<?> findClass(String className) throws ClassNotFoundException { [EOL]     if (className.indexOf('.') < 0) { [EOL]         if ("int".equals(className)) [EOL]             return Integer.TYPE; [EOL]         if ("long".equals(className)) [EOL]             return Long.TYPE; [EOL]         if ("float".equals(className)) [EOL]             return Float.TYPE; [EOL]         if ("double".equals(className)) [EOL]             return Double.TYPE; [EOL]         if ("boolean".equals(className)) [EOL]             return Boolean.TYPE; [EOL]         if ("byte".equals(className)) [EOL]             return Byte.TYPE; [EOL]         if ("char".equals(className)) [EOL]             return Character.TYPE; [EOL]         if ("short".equals(className)) [EOL]             return Short.TYPE; [EOL]         if ("void".equals(className)) [EOL]             return Void.TYPE; [EOL]     } [EOL]     Throwable prob = null; [EOL]     ClassLoader loader = Thread.currentThread().getContextClassLoader(); [EOL]     if (loader != null) { [EOL]         try { [EOL]             return Class.forName(className, true, loader); [EOL]         } catch (Exception e) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return Class.forName(className); [EOL]     } catch (Exception e) { [EOL]         if (prob == null) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     if (prob instanceof RuntimeException) { [EOL]         throw (RuntimeException) prob; [EOL]     } [EOL]     throw new ClassNotFoundException(prob.getMessage(), prob); [EOL] }
public static Class<?> findClass(String className) throws ClassNotFoundException { [EOL]     if (className.indexOf('.') < 0) { [EOL]         if ("int".equals(className)) [EOL]             return Integer.TYPE; [EOL]         if ("long".equals(className)) [EOL]             return Long.TYPE; [EOL]         if ("float".equals(className)) [EOL]             return Float.TYPE; [EOL]         if ("double".equals(className)) [EOL]             return Double.TYPE; [EOL]         if ("boolean".equals(className)) [EOL]             return Boolean.TYPE; [EOL]         if ("byte".equals(className)) [EOL]             return Byte.TYPE; [EOL]         if ("char".equals(className)) [EOL]             return Character.TYPE; [EOL]         if ("short".equals(className)) [EOL]             return Short.TYPE; [EOL]         if ("void".equals(className)) [EOL]             return Void.TYPE; [EOL]     } [EOL]     Throwable prob = null; [EOL]     ClassLoader loader = Thread.currentThread().getContextClassLoader(); [EOL]     if (loader != null) { [EOL]         try { [EOL]             return Class.forName(className, true, loader); [EOL]         } catch (Exception e) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return Class.forName(className); [EOL]     } catch (Exception e) { [EOL]         if (prob == null) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     if (prob instanceof RuntimeException) { [EOL]         throw (RuntimeException) prob; [EOL]     } [EOL]     throw new ClassNotFoundException(prob.getMessage(), prob); [EOL] }
public static Class<?> findClass(String className) throws ClassNotFoundException { [EOL]     if (className.indexOf('.') < 0) { [EOL]         if ("int".equals(className)) [EOL]             return Integer.TYPE; [EOL]         if ("long".equals(className)) [EOL]             return Long.TYPE; [EOL]         if ("float".equals(className)) [EOL]             return Float.TYPE; [EOL]         if ("double".equals(className)) [EOL]             return Double.TYPE; [EOL]         if ("boolean".equals(className)) [EOL]             return Boolean.TYPE; [EOL]         if ("byte".equals(className)) [EOL]             return Byte.TYPE; [EOL]         if ("char".equals(className)) [EOL]             return Character.TYPE; [EOL]         if ("short".equals(className)) [EOL]             return Short.TYPE; [EOL]         if ("void".equals(className)) [EOL]             return Void.TYPE; [EOL]     } [EOL]     Throwable prob = null; [EOL]     ClassLoader loader = Thread.currentThread().getContextClassLoader(); [EOL]     if (loader != null) { [EOL]         try { [EOL]             return Class.forName(className, true, loader); [EOL]         } catch (Exception e) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return Class.forName(className); [EOL]     } catch (Exception e) { [EOL]         if (prob == null) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     if (prob instanceof RuntimeException) { [EOL]         throw (RuntimeException) prob; [EOL]     } [EOL]     throw new ClassNotFoundException(prob.getMessage(), prob); [EOL] }
public static Class<?> findClass(String className) throws ClassNotFoundException { [EOL]     if (className.indexOf('.') < 0) { [EOL]         if ("int".equals(className)) [EOL]             return Integer.TYPE; [EOL]         if ("long".equals(className)) [EOL]             return Long.TYPE; [EOL]         if ("float".equals(className)) [EOL]             return Float.TYPE; [EOL]         if ("double".equals(className)) [EOL]             return Double.TYPE; [EOL]         if ("boolean".equals(className)) [EOL]             return Boolean.TYPE; [EOL]         if ("byte".equals(className)) [EOL]             return Byte.TYPE; [EOL]         if ("char".equals(className)) [EOL]             return Character.TYPE; [EOL]         if ("short".equals(className)) [EOL]             return Short.TYPE; [EOL]         if ("void".equals(className)) [EOL]             return Void.TYPE; [EOL]     } [EOL]     Throwable prob = null; [EOL]     ClassLoader loader = Thread.currentThread().getContextClassLoader(); [EOL]     if (loader != null) { [EOL]         try { [EOL]             return Class.forName(className, true, loader); [EOL]         } catch (Exception e) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return Class.forName(className); [EOL]     } catch (Exception e) { [EOL]         if (prob == null) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     if (prob instanceof RuntimeException) { [EOL]         throw (RuntimeException) prob; [EOL]     } [EOL]     throw new ClassNotFoundException(prob.getMessage(), prob); [EOL] }
public static Class<?> findClass(String className) throws ClassNotFoundException { [EOL]     if (className.indexOf('.') < 0) { [EOL]         if ("int".equals(className)) [EOL]             return Integer.TYPE; [EOL]         if ("long".equals(className)) [EOL]             return Long.TYPE; [EOL]         if ("float".equals(className)) [EOL]             return Float.TYPE; [EOL]         if ("double".equals(className)) [EOL]             return Double.TYPE; [EOL]         if ("boolean".equals(className)) [EOL]             return Boolean.TYPE; [EOL]         if ("byte".equals(className)) [EOL]             return Byte.TYPE; [EOL]         if ("char".equals(className)) [EOL]             return Character.TYPE; [EOL]         if ("short".equals(className)) [EOL]             return Short.TYPE; [EOL]         if ("void".equals(className)) [EOL]             return Void.TYPE; [EOL]     } [EOL]     Throwable prob = null; [EOL]     ClassLoader loader = Thread.currentThread().getContextClassLoader(); [EOL]     if (loader != null) { [EOL]         try { [EOL]             return Class.forName(className, true, loader); [EOL]         } catch (Exception e) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return Class.forName(className); [EOL]     } catch (Exception e) { [EOL]         if (prob == null) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     if (prob instanceof RuntimeException) { [EOL]         throw (RuntimeException) prob; [EOL]     } [EOL]     throw new ClassNotFoundException(prob.getMessage(), prob); [EOL] }
public static Class<?> findClass(String className) throws ClassNotFoundException { [EOL]     if (className.indexOf('.') < 0) { [EOL]         if ("int".equals(className)) [EOL]             return Integer.TYPE; [EOL]         if ("long".equals(className)) [EOL]             return Long.TYPE; [EOL]         if ("float".equals(className)) [EOL]             return Float.TYPE; [EOL]         if ("double".equals(className)) [EOL]             return Double.TYPE; [EOL]         if ("boolean".equals(className)) [EOL]             return Boolean.TYPE; [EOL]         if ("byte".equals(className)) [EOL]             return Byte.TYPE; [EOL]         if ("char".equals(className)) [EOL]             return Character.TYPE; [EOL]         if ("short".equals(className)) [EOL]             return Short.TYPE; [EOL]         if ("void".equals(className)) [EOL]             return Void.TYPE; [EOL]     } [EOL]     Throwable prob = null; [EOL]     ClassLoader loader = Thread.currentThread().getContextClassLoader(); [EOL]     if (loader != null) { [EOL]         try { [EOL]             return Class.forName(className, true, loader); [EOL]         } catch (Exception e) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return Class.forName(className); [EOL]     } catch (Exception e) { [EOL]         if (prob == null) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     if (prob instanceof RuntimeException) { [EOL]         throw (RuntimeException) prob; [EOL]     } [EOL]     throw new ClassNotFoundException(prob.getMessage(), prob); [EOL] }
public static Class<?> findClass(String className) throws ClassNotFoundException { [EOL]     if (className.indexOf('.') < 0) { [EOL]         if ("int".equals(className)) [EOL]             return Integer.TYPE; [EOL]         if ("long".equals(className)) [EOL]             return Long.TYPE; [EOL]         if ("float".equals(className)) [EOL]             return Float.TYPE; [EOL]         if ("double".equals(className)) [EOL]             return Double.TYPE; [EOL]         if ("boolean".equals(className)) [EOL]             return Boolean.TYPE; [EOL]         if ("byte".equals(className)) [EOL]             return Byte.TYPE; [EOL]         if ("char".equals(className)) [EOL]             return Character.TYPE; [EOL]         if ("short".equals(className)) [EOL]             return Short.TYPE; [EOL]         if ("void".equals(className)) [EOL]             return Void.TYPE; [EOL]     } [EOL]     Throwable prob = null; [EOL]     ClassLoader loader = Thread.currentThread().getContextClassLoader(); [EOL]     if (loader != null) { [EOL]         try { [EOL]             return Class.forName(className, true, loader); [EOL]         } catch (Exception e) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return Class.forName(className); [EOL]     } catch (Exception e) { [EOL]         if (prob == null) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     if (prob instanceof RuntimeException) { [EOL]         throw (RuntimeException) prob; [EOL]     } [EOL]     throw new ClassNotFoundException(prob.getMessage(), prob); [EOL] }
public static Class<?> findClass(String className) throws ClassNotFoundException { [EOL]     if (className.indexOf('.') < 0) { [EOL]         if ("int".equals(className)) [EOL]             return Integer.TYPE; [EOL]         if ("long".equals(className)) [EOL]             return Long.TYPE; [EOL]         if ("float".equals(className)) [EOL]             return Float.TYPE; [EOL]         if ("double".equals(className)) [EOL]             return Double.TYPE; [EOL]         if ("boolean".equals(className)) [EOL]             return Boolean.TYPE; [EOL]         if ("byte".equals(className)) [EOL]             return Byte.TYPE; [EOL]         if ("char".equals(className)) [EOL]             return Character.TYPE; [EOL]         if ("short".equals(className)) [EOL]             return Short.TYPE; [EOL]         if ("void".equals(className)) [EOL]             return Void.TYPE; [EOL]     } [EOL]     Throwable prob = null; [EOL]     ClassLoader loader = Thread.currentThread().getContextClassLoader(); [EOL]     if (loader != null) { [EOL]         try { [EOL]             return Class.forName(className, true, loader); [EOL]         } catch (Exception e) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return Class.forName(className); [EOL]     } catch (Exception e) { [EOL]         if (prob == null) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     if (prob instanceof RuntimeException) { [EOL]         throw (RuntimeException) prob; [EOL]     } [EOL]     throw new ClassNotFoundException(prob.getMessage(), prob); [EOL] }
public static Class<?> findClass(String className) throws ClassNotFoundException { [EOL]     if (className.indexOf('.') < 0) { [EOL]         if ("int".equals(className)) [EOL]             return Integer.TYPE; [EOL]         if ("long".equals(className)) [EOL]             return Long.TYPE; [EOL]         if ("float".equals(className)) [EOL]             return Float.TYPE; [EOL]         if ("double".equals(className)) [EOL]             return Double.TYPE; [EOL]         if ("boolean".equals(className)) [EOL]             return Boolean.TYPE; [EOL]         if ("byte".equals(className)) [EOL]             return Byte.TYPE; [EOL]         if ("char".equals(className)) [EOL]             return Character.TYPE; [EOL]         if ("short".equals(className)) [EOL]             return Short.TYPE; [EOL]         if ("void".equals(className)) [EOL]             return Void.TYPE; [EOL]     } [EOL]     Throwable prob = null; [EOL]     ClassLoader loader = Thread.currentThread().getContextClassLoader(); [EOL]     if (loader != null) { [EOL]         try { [EOL]             return Class.forName(className, true, loader); [EOL]         } catch (Exception e) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return Class.forName(className); [EOL]     } catch (Exception e) { [EOL]         if (prob == null) { [EOL]             prob = getRootCause(e); [EOL]         } [EOL]     } [EOL]     if (prob instanceof RuntimeException) { [EOL]         throw (RuntimeException) prob; [EOL]     } [EOL]     throw new ClassNotFoundException(prob.getMessage(), prob); [EOL] }
public static Throwable getRootCause(Throwable t) { [EOL]     while (t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     return t; [EOL] }
public static Throwable getRootCause(Throwable t) { [EOL]     while (t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     return t; [EOL] }
public static Throwable getRootCause(Throwable t) { [EOL]     while (t.getCause() != null) { [EOL]         t = t.getCause(); [EOL]     } [EOL]     return t; [EOL] }
public static void throwAsIAE(Throwable t, String msg) { [EOL]     if (t instanceof RuntimeException) { [EOL]         throw (RuntimeException) t; [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     throw new IllegalArgumentException(msg, t); [EOL] }
public static void throwAsIAE(Throwable t, String msg) { [EOL]     if (t instanceof RuntimeException) { [EOL]         throw (RuntimeException) t; [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     throw new IllegalArgumentException(msg, t); [EOL] }
public static void throwAsIAE(Throwable t, String msg) { [EOL]     if (t instanceof RuntimeException) { [EOL]         throw (RuntimeException) t; [EOL]     } [EOL]     if (t instanceof Error) { [EOL]         throw (Error) t; [EOL]     } [EOL]     throw new IllegalArgumentException(msg, t); [EOL] }
public static void unwrapAndThrowAsIAE(Throwable t, String msg) { [EOL]     throwAsIAE(getRootCause(t), msg); [EOL] }
public static void unwrapAndThrowAsIAE(Throwable t, String msg) { [EOL]     throwAsIAE(getRootCause(t), msg); [EOL] }
public static <T> T createInstance(Class<T> cls, boolean canFixAccess) throws IllegalArgumentException { [EOL]     Constructor<T> ctor = findConstructor(cls, canFixAccess); [EOL]     if (ctor == null) { [EOL]         throw new IllegalArgumentException("Class " + cls.getName() + " has no default (no arg) constructor"); [EOL]     } [EOL]     try { [EOL]         return ctor.newInstance(); [EOL]     } catch (Exception e) { [EOL]         ClassUtil.unwrapAndThrowAsIAE(e, "Failed to instantiate class " + cls.getName() + ", problem: " + e.getMessage()); [EOL]         return null; [EOL]     } [EOL] }
public static <T> T createInstance(Class<T> cls, boolean canFixAccess) throws IllegalArgumentException { [EOL]     Constructor<T> ctor = findConstructor(cls, canFixAccess); [EOL]     if (ctor == null) { [EOL]         throw new IllegalArgumentException("Class " + cls.getName() + " has no default (no arg) constructor"); [EOL]     } [EOL]     try { [EOL]         return ctor.newInstance(); [EOL]     } catch (Exception e) { [EOL]         ClassUtil.unwrapAndThrowAsIAE(e, "Failed to instantiate class " + cls.getName() + ", problem: " + e.getMessage()); [EOL]         return null; [EOL]     } [EOL] }
public static <T> T createInstance(Class<T> cls, boolean canFixAccess) throws IllegalArgumentException { [EOL]     Constructor<T> ctor = findConstructor(cls, canFixAccess); [EOL]     if (ctor == null) { [EOL]         throw new IllegalArgumentException("Class " + cls.getName() + " has no default (no arg) constructor"); [EOL]     } [EOL]     try { [EOL]         return ctor.newInstance(); [EOL]     } catch (Exception e) { [EOL]         ClassUtil.unwrapAndThrowAsIAE(e, "Failed to instantiate class " + cls.getName() + ", problem: " + e.getMessage()); [EOL]         return null; [EOL]     } [EOL] }
public static <T> T createInstance(Class<T> cls, boolean canFixAccess) throws IllegalArgumentException { [EOL]     Constructor<T> ctor = findConstructor(cls, canFixAccess); [EOL]     if (ctor == null) { [EOL]         throw new IllegalArgumentException("Class " + cls.getName() + " has no default (no arg) constructor"); [EOL]     } [EOL]     try { [EOL]         return ctor.newInstance(); [EOL]     } catch (Exception e) { [EOL]         ClassUtil.unwrapAndThrowAsIAE(e, "Failed to instantiate class " + cls.getName() + ", problem: " + e.getMessage()); [EOL]         return null; [EOL]     } [EOL] }
public static <T> Constructor<T> findConstructor(Class<T> cls, boolean canFixAccess) throws IllegalArgumentException { [EOL]     try { [EOL]         Constructor<T> ctor = cls.getDeclaredConstructor(); [EOL]         if (canFixAccess) { [EOL]             checkAndFixAccess(ctor); [EOL]         } else { [EOL]             if (!Modifier.isPublic(ctor.getModifiers())) { [EOL]                 throw new IllegalArgumentException("Default constructor for " + cls.getName() + " is not accessible (non-public?): not allowed to try modify access via Reflection: can not instantiate type"); [EOL]             } [EOL]         } [EOL]         return ctor; [EOL]     } catch (NoSuchMethodException e) { [EOL]         ; [EOL]     } catch (Exception e) { [EOL]         ClassUtil.unwrapAndThrowAsIAE(e, "Failed to find default constructor of class " + cls.getName() + ", problem: " + e.getMessage()); [EOL]     } [EOL]     return null; [EOL] }
public static <T> Constructor<T> findConstructor(Class<T> cls, boolean canFixAccess) throws IllegalArgumentException { [EOL]     try { [EOL]         Constructor<T> ctor = cls.getDeclaredConstructor(); [EOL]         if (canFixAccess) { [EOL]             checkAndFixAccess(ctor); [EOL]         } else { [EOL]             if (!Modifier.isPublic(ctor.getModifiers())) { [EOL]                 throw new IllegalArgumentException("Default constructor for " + cls.getName() + " is not accessible (non-public?): not allowed to try modify access via Reflection: can not instantiate type"); [EOL]             } [EOL]         } [EOL]         return ctor; [EOL]     } catch (NoSuchMethodException e) { [EOL]         ; [EOL]     } catch (Exception e) { [EOL]         ClassUtil.unwrapAndThrowAsIAE(e, "Failed to find default constructor of class " + cls.getName() + ", problem: " + e.getMessage()); [EOL]     } [EOL]     return null; [EOL] }
public static <T> Constructor<T> findConstructor(Class<T> cls, boolean canFixAccess) throws IllegalArgumentException { [EOL]     try { [EOL]         Constructor<T> ctor = cls.getDeclaredConstructor(); [EOL]         if (canFixAccess) { [EOL]             checkAndFixAccess(ctor); [EOL]         } else { [EOL]             if (!Modifier.isPublic(ctor.getModifiers())) { [EOL]                 throw new IllegalArgumentException("Default constructor for " + cls.getName() + " is not accessible (non-public?): not allowed to try modify access via Reflection: can not instantiate type"); [EOL]             } [EOL]         } [EOL]         return ctor; [EOL]     } catch (NoSuchMethodException e) { [EOL]         ; [EOL]     } catch (Exception e) { [EOL]         ClassUtil.unwrapAndThrowAsIAE(e, "Failed to find default constructor of class " + cls.getName() + ", problem: " + e.getMessage()); [EOL]     } [EOL]     return null; [EOL] }
public static <T> Constructor<T> findConstructor(Class<T> cls, boolean canFixAccess) throws IllegalArgumentException { [EOL]     try { [EOL]         Constructor<T> ctor = cls.getDeclaredConstructor(); [EOL]         if (canFixAccess) { [EOL]             checkAndFixAccess(ctor); [EOL]         } else { [EOL]             if (!Modifier.isPublic(ctor.getModifiers())) { [EOL]                 throw new IllegalArgumentException("Default constructor for " + cls.getName() + " is not accessible (non-public?): not allowed to try modify access via Reflection: can not instantiate type"); [EOL]             } [EOL]         } [EOL]         return ctor; [EOL]     } catch (NoSuchMethodException e) { [EOL]         ; [EOL]     } catch (Exception e) { [EOL]         ClassUtil.unwrapAndThrowAsIAE(e, "Failed to find default constructor of class " + cls.getName() + ", problem: " + e.getMessage()); [EOL]     } [EOL]     return null; [EOL] }
public static <T> Constructor<T> findConstructor(Class<T> cls, boolean canFixAccess) throws IllegalArgumentException { [EOL]     try { [EOL]         Constructor<T> ctor = cls.getDeclaredConstructor(); [EOL]         if (canFixAccess) { [EOL]             checkAndFixAccess(ctor); [EOL]         } else { [EOL]             if (!Modifier.isPublic(ctor.getModifiers())) { [EOL]                 throw new IllegalArgumentException("Default constructor for " + cls.getName() + " is not accessible (non-public?): not allowed to try modify access via Reflection: can not instantiate type"); [EOL]             } [EOL]         } [EOL]         return ctor; [EOL]     } catch (NoSuchMethodException e) { [EOL]         ; [EOL]     } catch (Exception e) { [EOL]         ClassUtil.unwrapAndThrowAsIAE(e, "Failed to find default constructor of class " + cls.getName() + ", problem: " + e.getMessage()); [EOL]     } [EOL]     return null; [EOL] }
public static Class<?> wrapperType(Class<?> primitiveType) { [EOL]     if (primitiveType == Integer.TYPE) { [EOL]         return Integer.class; [EOL]     } [EOL]     if (primitiveType == Long.TYPE) { [EOL]         return Long.class; [EOL]     } [EOL]     if (primitiveType == Boolean.TYPE) { [EOL]         return Boolean.class; [EOL]     } [EOL]     if (primitiveType == Double.TYPE) { [EOL]         return Double.class; [EOL]     } [EOL]     if (primitiveType == Float.TYPE) { [EOL]         return Float.class; [EOL]     } [EOL]     if (primitiveType == Byte.TYPE) { [EOL]         return Byte.class; [EOL]     } [EOL]     if (primitiveType == Short.TYPE) { [EOL]         return Short.class; [EOL]     } [EOL]     if (primitiveType == Character.TYPE) { [EOL]         return Character.class; [EOL]     } [EOL]     throw new IllegalArgumentException("Class " + primitiveType.getName() + " is not a primitive type"); [EOL] }
public static Class<?> wrapperType(Class<?> primitiveType) { [EOL]     if (primitiveType == Integer.TYPE) { [EOL]         return Integer.class; [EOL]     } [EOL]     if (primitiveType == Long.TYPE) { [EOL]         return Long.class; [EOL]     } [EOL]     if (primitiveType == Boolean.TYPE) { [EOL]         return Boolean.class; [EOL]     } [EOL]     if (primitiveType == Double.TYPE) { [EOL]         return Double.class; [EOL]     } [EOL]     if (primitiveType == Float.TYPE) { [EOL]         return Float.class; [EOL]     } [EOL]     if (primitiveType == Byte.TYPE) { [EOL]         return Byte.class; [EOL]     } [EOL]     if (primitiveType == Short.TYPE) { [EOL]         return Short.class; [EOL]     } [EOL]     if (primitiveType == Character.TYPE) { [EOL]         return Character.class; [EOL]     } [EOL]     throw new IllegalArgumentException("Class " + primitiveType.getName() + " is not a primitive type"); [EOL] }
public static Class<?> wrapperType(Class<?> primitiveType) { [EOL]     if (primitiveType == Integer.TYPE) { [EOL]         return Integer.class; [EOL]     } [EOL]     if (primitiveType == Long.TYPE) { [EOL]         return Long.class; [EOL]     } [EOL]     if (primitiveType == Boolean.TYPE) { [EOL]         return Boolean.class; [EOL]     } [EOL]     if (primitiveType == Double.TYPE) { [EOL]         return Double.class; [EOL]     } [EOL]     if (primitiveType == Float.TYPE) { [EOL]         return Float.class; [EOL]     } [EOL]     if (primitiveType == Byte.TYPE) { [EOL]         return Byte.class; [EOL]     } [EOL]     if (primitiveType == Short.TYPE) { [EOL]         return Short.class; [EOL]     } [EOL]     if (primitiveType == Character.TYPE) { [EOL]         return Character.class; [EOL]     } [EOL]     throw new IllegalArgumentException("Class " + primitiveType.getName() + " is not a primitive type"); [EOL] }
public static Class<?> wrapperType(Class<?> primitiveType) { [EOL]     if (primitiveType == Integer.TYPE) { [EOL]         return Integer.class; [EOL]     } [EOL]     if (primitiveType == Long.TYPE) { [EOL]         return Long.class; [EOL]     } [EOL]     if (primitiveType == Boolean.TYPE) { [EOL]         return Boolean.class; [EOL]     } [EOL]     if (primitiveType == Double.TYPE) { [EOL]         return Double.class; [EOL]     } [EOL]     if (primitiveType == Float.TYPE) { [EOL]         return Float.class; [EOL]     } [EOL]     if (primitiveType == Byte.TYPE) { [EOL]         return Byte.class; [EOL]     } [EOL]     if (primitiveType == Short.TYPE) { [EOL]         return Short.class; [EOL]     } [EOL]     if (primitiveType == Character.TYPE) { [EOL]         return Character.class; [EOL]     } [EOL]     throw new IllegalArgumentException("Class " + primitiveType.getName() + " is not a primitive type"); [EOL] }
public static Class<?> wrapperType(Class<?> primitiveType) { [EOL]     if (primitiveType == Integer.TYPE) { [EOL]         return Integer.class; [EOL]     } [EOL]     if (primitiveType == Long.TYPE) { [EOL]         return Long.class; [EOL]     } [EOL]     if (primitiveType == Boolean.TYPE) { [EOL]         return Boolean.class; [EOL]     } [EOL]     if (primitiveType == Double.TYPE) { [EOL]         return Double.class; [EOL]     } [EOL]     if (primitiveType == Float.TYPE) { [EOL]         return Float.class; [EOL]     } [EOL]     if (primitiveType == Byte.TYPE) { [EOL]         return Byte.class; [EOL]     } [EOL]     if (primitiveType == Short.TYPE) { [EOL]         return Short.class; [EOL]     } [EOL]     if (primitiveType == Character.TYPE) { [EOL]         return Character.class; [EOL]     } [EOL]     throw new IllegalArgumentException("Class " + primitiveType.getName() + " is not a primitive type"); [EOL] }
public static Class<?> wrapperType(Class<?> primitiveType) { [EOL]     if (primitiveType == Integer.TYPE) { [EOL]         return Integer.class; [EOL]     } [EOL]     if (primitiveType == Long.TYPE) { [EOL]         return Long.class; [EOL]     } [EOL]     if (primitiveType == Boolean.TYPE) { [EOL]         return Boolean.class; [EOL]     } [EOL]     if (primitiveType == Double.TYPE) { [EOL]         return Double.class; [EOL]     } [EOL]     if (primitiveType == Float.TYPE) { [EOL]         return Float.class; [EOL]     } [EOL]     if (primitiveType == Byte.TYPE) { [EOL]         return Byte.class; [EOL]     } [EOL]     if (primitiveType == Short.TYPE) { [EOL]         return Short.class; [EOL]     } [EOL]     if (primitiveType == Character.TYPE) { [EOL]         return Character.class; [EOL]     } [EOL]     throw new IllegalArgumentException("Class " + primitiveType.getName() + " is not a primitive type"); [EOL] }
public static Class<?> wrapperType(Class<?> primitiveType) { [EOL]     if (primitiveType == Integer.TYPE) { [EOL]         return Integer.class; [EOL]     } [EOL]     if (primitiveType == Long.TYPE) { [EOL]         return Long.class; [EOL]     } [EOL]     if (primitiveType == Boolean.TYPE) { [EOL]         return Boolean.class; [EOL]     } [EOL]     if (primitiveType == Double.TYPE) { [EOL]         return Double.class; [EOL]     } [EOL]     if (primitiveType == Float.TYPE) { [EOL]         return Float.class; [EOL]     } [EOL]     if (primitiveType == Byte.TYPE) { [EOL]         return Byte.class; [EOL]     } [EOL]     if (primitiveType == Short.TYPE) { [EOL]         return Short.class; [EOL]     } [EOL]     if (primitiveType == Character.TYPE) { [EOL]         return Character.class; [EOL]     } [EOL]     throw new IllegalArgumentException("Class " + primitiveType.getName() + " is not a primitive type"); [EOL] }
public static Class<?> wrapperType(Class<?> primitiveType) { [EOL]     if (primitiveType == Integer.TYPE) { [EOL]         return Integer.class; [EOL]     } [EOL]     if (primitiveType == Long.TYPE) { [EOL]         return Long.class; [EOL]     } [EOL]     if (primitiveType == Boolean.TYPE) { [EOL]         return Boolean.class; [EOL]     } [EOL]     if (primitiveType == Double.TYPE) { [EOL]         return Double.class; [EOL]     } [EOL]     if (primitiveType == Float.TYPE) { [EOL]         return Float.class; [EOL]     } [EOL]     if (primitiveType == Byte.TYPE) { [EOL]         return Byte.class; [EOL]     } [EOL]     if (primitiveType == Short.TYPE) { [EOL]         return Short.class; [EOL]     } [EOL]     if (primitiveType == Character.TYPE) { [EOL]         return Character.class; [EOL]     } [EOL]     throw new IllegalArgumentException("Class " + primitiveType.getName() + " is not a primitive type"); [EOL] }
public static Class<?> wrapperType(Class<?> primitiveType) { [EOL]     if (primitiveType == Integer.TYPE) { [EOL]         return Integer.class; [EOL]     } [EOL]     if (primitiveType == Long.TYPE) { [EOL]         return Long.class; [EOL]     } [EOL]     if (primitiveType == Boolean.TYPE) { [EOL]         return Boolean.class; [EOL]     } [EOL]     if (primitiveType == Double.TYPE) { [EOL]         return Double.class; [EOL]     } [EOL]     if (primitiveType == Float.TYPE) { [EOL]         return Float.class; [EOL]     } [EOL]     if (primitiveType == Byte.TYPE) { [EOL]         return Byte.class; [EOL]     } [EOL]     if (primitiveType == Short.TYPE) { [EOL]         return Short.class; [EOL]     } [EOL]     if (primitiveType == Character.TYPE) { [EOL]         return Character.class; [EOL]     } [EOL]     throw new IllegalArgumentException("Class " + primitiveType.getName() + " is not a primitive type"); [EOL] }
public static void checkAndFixAccess(Member member) { [EOL]     AccessibleObject ao = (AccessibleObject) member; [EOL]     try { [EOL]         ao.setAccessible(true); [EOL]     } catch (SecurityException se) { [EOL]         if (!ao.isAccessible()) { [EOL]             Class<?> declClass = member.getDeclaringClass(); [EOL]             throw new IllegalArgumentException("Can not access " + member + " (from class " + declClass.getName() + "; failed to set access: " + se.getMessage()); [EOL]         } [EOL]     } [EOL] }
public static void checkAndFixAccess(Member member) { [EOL]     AccessibleObject ao = (AccessibleObject) member; [EOL]     try { [EOL]         ao.setAccessible(true); [EOL]     } catch (SecurityException se) { [EOL]         if (!ao.isAccessible()) { [EOL]             Class<?> declClass = member.getDeclaringClass(); [EOL]             throw new IllegalArgumentException("Can not access " + member + " (from class " + declClass.getName() + "; failed to set access: " + se.getMessage()); [EOL]         } [EOL]     } [EOL] }
public EnumSetSerializer(JavaType elemType, BeanProperty property) { [EOL]     super(EnumSet.class, elemType, true, null, property, null); [EOL] }
public EnumSetSerializer(JavaType elemType, BeanProperty property) { [EOL]     super(EnumSet.class, elemType, true, null, property, null); [EOL] }
public EnumSetSerializer(EnumSetSerializer src, BeanProperty property, TypeSerializer vts, JsonSerializer<?> valueSerializer) { [EOL]     super(src, property, vts, valueSerializer); [EOL] }
public EnumSetSerializer(EnumSetSerializer src, BeanProperty property, TypeSerializer vts, JsonSerializer<?> valueSerializer) { [EOL]     super(src, property, vts, valueSerializer); [EOL] }
@Override [EOL] public EnumSetSerializer withResolved(BeanProperty property, TypeSerializer vts, JsonSerializer<?> elementSerializer) { [EOL]     return new EnumSetSerializer(this, property, vts, elementSerializer); [EOL] }
@Override [EOL] public EnumSetSerializer withResolved(BeanProperty property, TypeSerializer vts, JsonSerializer<?> elementSerializer) { [EOL]     return new EnumSetSerializer(this, property, vts, elementSerializer); [EOL] }
@SuppressWarnings("unchecked") [EOL] public StdDelegatingDeserializer(Converter<Object, T> converter, JavaType delegateType, JsonDeserializer<?> delegateDeserializer) { [EOL]     super(delegateType); [EOL]     _converter = converter; [EOL]     _delegateType = delegateType; [EOL]     _delegateDeserializer = (JsonDeserializer<Object>) delegateDeserializer; [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     if (_delegateDeserializer != null && _delegateDeserializer instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) _delegateDeserializer).resolve(ctxt); [EOL]     } [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     if (_delegateDeserializer != null && _delegateDeserializer instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) _delegateDeserializer).resolve(ctxt); [EOL]     } [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     if (_delegateDeserializer != null && _delegateDeserializer instanceof ResolvableDeserializer) { [EOL]         ((ResolvableDeserializer) _delegateDeserializer).resolve(ctxt); [EOL]     } [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         if (_delegateDeserializer instanceof ContextualDeserializer) { [EOL]             JsonDeserializer<?> deser = ((ContextualDeserializer) _delegateDeserializer).createContextual(ctxt, property); [EOL]             if (deser != _delegateDeserializer) { [EOL]                 return withDelegate(_converter, _delegateType, deser); [EOL]             } [EOL]         } [EOL]         return this; [EOL]     } [EOL]     JavaType delegateType = _converter.getInputType(ctxt.getTypeFactory()); [EOL]     return withDelegate(_converter, delegateType, ctxt.findContextualValueDeserializer(delegateType, property)); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         if (_delegateDeserializer instanceof ContextualDeserializer) { [EOL]             JsonDeserializer<?> deser = ((ContextualDeserializer) _delegateDeserializer).createContextual(ctxt, property); [EOL]             if (deser != _delegateDeserializer) { [EOL]                 return withDelegate(_converter, _delegateType, deser); [EOL]             } [EOL]         } [EOL]         return this; [EOL]     } [EOL]     JavaType delegateType = _converter.getInputType(ctxt.getTypeFactory()); [EOL]     return withDelegate(_converter, delegateType, ctxt.findContextualValueDeserializer(delegateType, property)); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         if (_delegateDeserializer instanceof ContextualDeserializer) { [EOL]             JsonDeserializer<?> deser = ((ContextualDeserializer) _delegateDeserializer).createContextual(ctxt, property); [EOL]             if (deser != _delegateDeserializer) { [EOL]                 return withDelegate(_converter, _delegateType, deser); [EOL]             } [EOL]         } [EOL]         return this; [EOL]     } [EOL]     JavaType delegateType = _converter.getInputType(ctxt.getTypeFactory()); [EOL]     return withDelegate(_converter, delegateType, ctxt.findContextualValueDeserializer(delegateType, property)); [EOL] }
@Override [EOL] public T deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Object delegateValue = _delegateDeserializer.deserialize(jp, ctxt); [EOL]     if (delegateValue == null) { [EOL]         return null; [EOL]     } [EOL]     return convertValue(delegateValue); [EOL] }
@Override [EOL] public T deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     Object delegateValue = _delegateDeserializer.deserialize(jp, ctxt); [EOL]     if (delegateValue == null) { [EOL]         return null; [EOL]     } [EOL]     return convertValue(delegateValue); [EOL] }
protected T convertValue(Object delegateValue) { [EOL]     return _converter.convert(delegateValue); [EOL] }
@SuppressWarnings({ "unchecked", "deprecation" }) [EOL] @Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException { [EOL]     ObjectNode o = createSchemaNode("object", true); [EOL]     if (typeHint instanceof ParameterizedType) { [EOL]         Type[] typeArgs = ((ParameterizedType) typeHint).getActualTypeArguments(); [EOL]         if (typeArgs.length == 2) { [EOL]             JavaType enumType = provider.constructType(typeArgs[0]); [EOL]             JavaType valueType = provider.constructType(typeArgs[1]); [EOL]             ObjectNode propsNode = JsonNodeFactory.instance.objectNode(); [EOL]             Class<Enum<?>> enumClass = (Class<Enum<?>>) enumType.getRawClass(); [EOL]             for (Enum<?> enumValue : enumClass.getEnumConstants()) { [EOL]                 JsonSerializer<Object> ser = provider.findValueSerializer(valueType.getRawClass(), _property); [EOL]                 JsonNode schemaNode = (ser instanceof SchemaAware) ? ((SchemaAware) ser).getSchema(provider, null) : com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); [EOL]                 propsNode.put(provider.getConfig().getAnnotationIntrospector().findEnumValue((Enum<?>) enumValue), schemaNode); [EOL]             } [EOL]             o.put("properties", propsNode); [EOL]         } [EOL]     } [EOL]     return o; [EOL] }
@SuppressWarnings({ "unchecked", "deprecation" }) [EOL] @Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException { [EOL]     ObjectNode o = createSchemaNode("object", true); [EOL]     if (typeHint instanceof ParameterizedType) { [EOL]         Type[] typeArgs = ((ParameterizedType) typeHint).getActualTypeArguments(); [EOL]         if (typeArgs.length == 2) { [EOL]             JavaType enumType = provider.constructType(typeArgs[0]); [EOL]             JavaType valueType = provider.constructType(typeArgs[1]); [EOL]             ObjectNode propsNode = JsonNodeFactory.instance.objectNode(); [EOL]             Class<Enum<?>> enumClass = (Class<Enum<?>>) enumType.getRawClass(); [EOL]             for (Enum<?> enumValue : enumClass.getEnumConstants()) { [EOL]                 JsonSerializer<Object> ser = provider.findValueSerializer(valueType.getRawClass(), _property); [EOL]                 JsonNode schemaNode = (ser instanceof SchemaAware) ? ((SchemaAware) ser).getSchema(provider, null) : com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); [EOL]                 propsNode.put(provider.getConfig().getAnnotationIntrospector().findEnumValue((Enum<?>) enumValue), schemaNode); [EOL]             } [EOL]             o.put("properties", propsNode); [EOL]         } [EOL]     } [EOL]     return o; [EOL] }
@SuppressWarnings({ "unchecked", "deprecation" }) [EOL] @Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException { [EOL]     ObjectNode o = createSchemaNode("object", true); [EOL]     if (typeHint instanceof ParameterizedType) { [EOL]         Type[] typeArgs = ((ParameterizedType) typeHint).getActualTypeArguments(); [EOL]         if (typeArgs.length == 2) { [EOL]             JavaType enumType = provider.constructType(typeArgs[0]); [EOL]             JavaType valueType = provider.constructType(typeArgs[1]); [EOL]             ObjectNode propsNode = JsonNodeFactory.instance.objectNode(); [EOL]             Class<Enum<?>> enumClass = (Class<Enum<?>>) enumType.getRawClass(); [EOL]             for (Enum<?> enumValue : enumClass.getEnumConstants()) { [EOL]                 JsonSerializer<Object> ser = provider.findValueSerializer(valueType.getRawClass(), _property); [EOL]                 JsonNode schemaNode = (ser instanceof SchemaAware) ? ((SchemaAware) ser).getSchema(provider, null) : com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); [EOL]                 propsNode.put(provider.getConfig().getAnnotationIntrospector().findEnumValue((Enum<?>) enumValue), schemaNode); [EOL]             } [EOL]             o.put("properties", propsNode); [EOL]         } [EOL]     } [EOL]     return o; [EOL] }
protected SerializerFactoryConfig(Serializers[] allAdditionalSerializers, Serializers[] allAdditionalKeySerializers, BeanSerializerModifier[] modifiers) { [EOL]     _additionalSerializers = (allAdditionalSerializers == null) ? NO_SERIALIZERS : allAdditionalSerializers; [EOL]     _additionalKeySerializers = (allAdditionalKeySerializers == null) ? NO_SERIALIZERS : allAdditionalKeySerializers; [EOL]     _modifiers = (modifiers == null) ? NO_MODIFIERS : modifiers; [EOL] }
protected SerializerFactoryConfig(Serializers[] allAdditionalSerializers, Serializers[] allAdditionalKeySerializers, BeanSerializerModifier[] modifiers) { [EOL]     _additionalSerializers = (allAdditionalSerializers == null) ? NO_SERIALIZERS : allAdditionalSerializers; [EOL]     _additionalKeySerializers = (allAdditionalKeySerializers == null) ? NO_SERIALIZERS : allAdditionalKeySerializers; [EOL]     _modifiers = (modifiers == null) ? NO_MODIFIERS : modifiers; [EOL] }
public SerializerFactoryConfig withSerializerModifier(BeanSerializerModifier modifier) { [EOL]     if (modifier == null) { [EOL]         throw new IllegalArgumentException("Can not pass null modifier"); [EOL]     } [EOL]     BeanSerializerModifier[] modifiers = ArrayBuilders.insertInListNoDup(_modifiers, modifier); [EOL]     return new SerializerFactoryConfig(_additionalSerializers, _additionalKeySerializers, modifiers); [EOL] }
public SerializerFactoryConfig withSerializerModifier(BeanSerializerModifier modifier) { [EOL]     if (modifier == null) { [EOL]         throw new IllegalArgumentException("Can not pass null modifier"); [EOL]     } [EOL]     BeanSerializerModifier[] modifiers = ArrayBuilders.insertInListNoDup(_modifiers, modifier); [EOL]     return new SerializerFactoryConfig(_additionalSerializers, _additionalKeySerializers, modifiers); [EOL] }
public Iterable<BeanSerializerModifier> serializerModifiers() { [EOL]     return ArrayBuilders.arrayAsIterable(_modifiers); [EOL] }
public Iterable<BeanSerializerModifier> serializerModifiers() { [EOL]     return ArrayBuilders.arrayAsIterable(_modifiers); [EOL] }
public SimpleSerializers() { [EOL] }
public <T> void addSerializer(Class<? extends T> type, JsonSerializer<T> ser) { [EOL]     _addSerializer(type, ser); [EOL] }
public <T> void addSerializer(Class<? extends T> type, JsonSerializer<T> ser) { [EOL]     _addSerializer(type, ser); [EOL] }
public <T> void addSerializer(Class<? extends T> type, JsonSerializer<T> ser) { [EOL]     _addSerializer(type, ser); [EOL] }
private void _addSerializer(Class<?> cls, JsonSerializer<?> ser) { [EOL]     ClassKey key = new ClassKey(cls); [EOL]     if (cls.isInterface()) { [EOL]         if (_interfaceMappings == null) { [EOL]             _interfaceMappings = new HashMap<ClassKey, JsonSerializer<?>>(); [EOL]         } [EOL]         _interfaceMappings.put(key, ser); [EOL]     } else { [EOL]         if (_classMappings == null) { [EOL]             _classMappings = new HashMap<ClassKey, JsonSerializer<?>>(); [EOL]         } [EOL]         _classMappings.put(key, ser); [EOL]     } [EOL] }
private void _addSerializer(Class<?> cls, JsonSerializer<?> ser) { [EOL]     ClassKey key = new ClassKey(cls); [EOL]     if (cls.isInterface()) { [EOL]         if (_interfaceMappings == null) { [EOL]             _interfaceMappings = new HashMap<ClassKey, JsonSerializer<?>>(); [EOL]         } [EOL]         _interfaceMappings.put(key, ser); [EOL]     } else { [EOL]         if (_classMappings == null) { [EOL]             _classMappings = new HashMap<ClassKey, JsonSerializer<?>>(); [EOL]         } [EOL]         _classMappings.put(key, ser); [EOL]     } [EOL] }
@Override [EOL] public JsonSerializer<?> findSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) { [EOL]     Class<?> cls = type.getRawClass(); [EOL]     ClassKey key = new ClassKey(cls); [EOL]     JsonSerializer<?> ser = null; [EOL]     if (cls.isInterface()) { [EOL]         if (_interfaceMappings != null) { [EOL]             ser = _interfaceMappings.get(key); [EOL]             if (ser != null) { [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (_classMappings != null) { [EOL]             ser = _classMappings.get(key); [EOL]             if (ser != null) { [EOL]                 return ser; [EOL]             } [EOL]             for (Class<?> curr = cls; (curr != null); curr = curr.getSuperclass()) { [EOL]                 key.reset(curr); [EOL]                 ser = _classMappings.get(key); [EOL]                 if (ser != null) { [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_interfaceMappings != null) { [EOL]         ser = _findInterfaceMapping(cls, key); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]         if (!cls.isInterface()) { [EOL]             while ((cls = cls.getSuperclass()) != null) { [EOL]                 ser = _findInterfaceMapping(cls, key); [EOL]                 if (ser != null) { [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonSerializer<?> findSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) { [EOL]     Class<?> cls = type.getRawClass(); [EOL]     ClassKey key = new ClassKey(cls); [EOL]     JsonSerializer<?> ser = null; [EOL]     if (cls.isInterface()) { [EOL]         if (_interfaceMappings != null) { [EOL]             ser = _interfaceMappings.get(key); [EOL]             if (ser != null) { [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (_classMappings != null) { [EOL]             ser = _classMappings.get(key); [EOL]             if (ser != null) { [EOL]                 return ser; [EOL]             } [EOL]             for (Class<?> curr = cls; (curr != null); curr = curr.getSuperclass()) { [EOL]                 key.reset(curr); [EOL]                 ser = _classMappings.get(key); [EOL]                 if (ser != null) { [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_interfaceMappings != null) { [EOL]         ser = _findInterfaceMapping(cls, key); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]         if (!cls.isInterface()) { [EOL]             while ((cls = cls.getSuperclass()) != null) { [EOL]                 ser = _findInterfaceMapping(cls, key); [EOL]                 if (ser != null) { [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonSerializer<?> findSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) { [EOL]     Class<?> cls = type.getRawClass(); [EOL]     ClassKey key = new ClassKey(cls); [EOL]     JsonSerializer<?> ser = null; [EOL]     if (cls.isInterface()) { [EOL]         if (_interfaceMappings != null) { [EOL]             ser = _interfaceMappings.get(key); [EOL]             if (ser != null) { [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (_classMappings != null) { [EOL]             ser = _classMappings.get(key); [EOL]             if (ser != null) { [EOL]                 return ser; [EOL]             } [EOL]             for (Class<?> curr = cls; (curr != null); curr = curr.getSuperclass()) { [EOL]                 key.reset(curr); [EOL]                 ser = _classMappings.get(key); [EOL]                 if (ser != null) { [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_interfaceMappings != null) { [EOL]         ser = _findInterfaceMapping(cls, key); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]         if (!cls.isInterface()) { [EOL]             while ((cls = cls.getSuperclass()) != null) { [EOL]                 ser = _findInterfaceMapping(cls, key); [EOL]                 if (ser != null) { [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonSerializer<?> findSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc) { [EOL]     Class<?> cls = type.getRawClass(); [EOL]     ClassKey key = new ClassKey(cls); [EOL]     JsonSerializer<?> ser = null; [EOL]     if (cls.isInterface()) { [EOL]         if (_interfaceMappings != null) { [EOL]             ser = _interfaceMappings.get(key); [EOL]             if (ser != null) { [EOL]                 return ser; [EOL]             } [EOL]         } [EOL]     } else { [EOL]         if (_classMappings != null) { [EOL]             ser = _classMappings.get(key); [EOL]             if (ser != null) { [EOL]                 return ser; [EOL]             } [EOL]             for (Class<?> curr = cls; (curr != null); curr = curr.getSuperclass()) { [EOL]                 key.reset(curr); [EOL]                 ser = _classMappings.get(key); [EOL]                 if (ser != null) { [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_interfaceMappings != null) { [EOL]         ser = _findInterfaceMapping(cls, key); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]         if (!cls.isInterface()) { [EOL]             while ((cls = cls.getSuperclass()) != null) { [EOL]                 ser = _findInterfaceMapping(cls, key); [EOL]                 if (ser != null) { [EOL]                     return ser; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonSerializer<?> findArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) { [EOL]     return findSerializer(config, type, beanDesc); [EOL] }
@Override [EOL] public JsonSerializer<?> findArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) { [EOL]     return findSerializer(config, type, beanDesc); [EOL] }
@Override [EOL] public JsonSerializer<?> findMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) { [EOL]     return findSerializer(config, type, beanDesc); [EOL] }
@SuppressWarnings("deprecation") [EOL] @Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException { [EOL]     ObjectNode o = createSchemaNode("array", true); [EOL]     JavaType contentType = null; [EOL]     if (typeHint != null) { [EOL]         JavaType javaType = provider.constructType(typeHint); [EOL]         contentType = javaType.getContentType(); [EOL]         if (contentType == null) { [EOL]             if (typeHint instanceof ParameterizedType) { [EOL]                 Type[] typeArgs = ((ParameterizedType) typeHint).getActualTypeArguments(); [EOL]                 if (typeArgs.length == 1) { [EOL]                     contentType = provider.constructType(typeArgs[0]); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (contentType == null && _elementType != null) { [EOL]         contentType = _elementType; [EOL]     } [EOL]     if (contentType != null) { [EOL]         JsonNode schemaNode = null; [EOL]         if (contentType.getRawClass() != Object.class) { [EOL]             JsonSerializer<Object> ser = provider.findValueSerializer(contentType, _property); [EOL]             if (ser instanceof SchemaAware) { [EOL]                 schemaNode = ((SchemaAware) ser).getSchema(provider, null); [EOL]             } [EOL]         } [EOL]         if (schemaNode == null) { [EOL]             schemaNode = com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); [EOL]         } [EOL]         o.put("items", schemaNode); [EOL]     } [EOL]     return o; [EOL] }
@SuppressWarnings("deprecation") [EOL] @Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException { [EOL]     ObjectNode o = createSchemaNode("array", true); [EOL]     JavaType contentType = null; [EOL]     if (typeHint != null) { [EOL]         JavaType javaType = provider.constructType(typeHint); [EOL]         contentType = javaType.getContentType(); [EOL]         if (contentType == null) { [EOL]             if (typeHint instanceof ParameterizedType) { [EOL]                 Type[] typeArgs = ((ParameterizedType) typeHint).getActualTypeArguments(); [EOL]                 if (typeArgs.length == 1) { [EOL]                     contentType = provider.constructType(typeArgs[0]); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (contentType == null && _elementType != null) { [EOL]         contentType = _elementType; [EOL]     } [EOL]     if (contentType != null) { [EOL]         JsonNode schemaNode = null; [EOL]         if (contentType.getRawClass() != Object.class) { [EOL]             JsonSerializer<Object> ser = provider.findValueSerializer(contentType, _property); [EOL]             if (ser instanceof SchemaAware) { [EOL]                 schemaNode = ((SchemaAware) ser).getSchema(provider, null); [EOL]             } [EOL]         } [EOL]         if (schemaNode == null) { [EOL]             schemaNode = com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); [EOL]         } [EOL]         o.put("items", schemaNode); [EOL]     } [EOL]     return o; [EOL] }
@SuppressWarnings("deprecation") [EOL] @Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException { [EOL]     ObjectNode o = createSchemaNode("array", true); [EOL]     JavaType contentType = null; [EOL]     if (typeHint != null) { [EOL]         JavaType javaType = provider.constructType(typeHint); [EOL]         contentType = javaType.getContentType(); [EOL]         if (contentType == null) { [EOL]             if (typeHint instanceof ParameterizedType) { [EOL]                 Type[] typeArgs = ((ParameterizedType) typeHint).getActualTypeArguments(); [EOL]                 if (typeArgs.length == 1) { [EOL]                     contentType = provider.constructType(typeArgs[0]); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (contentType == null && _elementType != null) { [EOL]         contentType = _elementType; [EOL]     } [EOL]     if (contentType != null) { [EOL]         JsonNode schemaNode = null; [EOL]         if (contentType.getRawClass() != Object.class) { [EOL]             JsonSerializer<Object> ser = provider.findValueSerializer(contentType, _property); [EOL]             if (ser instanceof SchemaAware) { [EOL]                 schemaNode = ((SchemaAware) ser).getSchema(provider, null); [EOL]             } [EOL]         } [EOL]         if (schemaNode == null) { [EOL]             schemaNode = com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); [EOL]         } [EOL]         o.put("items", schemaNode); [EOL]     } [EOL]     return o; [EOL] }
@SuppressWarnings("deprecation") [EOL] @Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException { [EOL]     ObjectNode o = createSchemaNode("array", true); [EOL]     JavaType contentType = null; [EOL]     if (typeHint != null) { [EOL]         JavaType javaType = provider.constructType(typeHint); [EOL]         contentType = javaType.getContentType(); [EOL]         if (contentType == null) { [EOL]             if (typeHint instanceof ParameterizedType) { [EOL]                 Type[] typeArgs = ((ParameterizedType) typeHint).getActualTypeArguments(); [EOL]                 if (typeArgs.length == 1) { [EOL]                     contentType = provider.constructType(typeArgs[0]); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (contentType == null && _elementType != null) { [EOL]         contentType = _elementType; [EOL]     } [EOL]     if (contentType != null) { [EOL]         JsonNode schemaNode = null; [EOL]         if (contentType.getRawClass() != Object.class) { [EOL]             JsonSerializer<Object> ser = provider.findValueSerializer(contentType, _property); [EOL]             if (ser instanceof SchemaAware) { [EOL]                 schemaNode = ((SchemaAware) ser).getSchema(provider, null); [EOL]             } [EOL]         } [EOL]         if (schemaNode == null) { [EOL]             schemaNode = com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); [EOL]         } [EOL]         o.put("items", schemaNode); [EOL]     } [EOL]     return o; [EOL] }
@SuppressWarnings("deprecation") [EOL] @Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException { [EOL]     ObjectNode o = createSchemaNode("array", true); [EOL]     JavaType contentType = null; [EOL]     if (typeHint != null) { [EOL]         JavaType javaType = provider.constructType(typeHint); [EOL]         contentType = javaType.getContentType(); [EOL]         if (contentType == null) { [EOL]             if (typeHint instanceof ParameterizedType) { [EOL]                 Type[] typeArgs = ((ParameterizedType) typeHint).getActualTypeArguments(); [EOL]                 if (typeArgs.length == 1) { [EOL]                     contentType = provider.constructType(typeArgs[0]); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (contentType == null && _elementType != null) { [EOL]         contentType = _elementType; [EOL]     } [EOL]     if (contentType != null) { [EOL]         JsonNode schemaNode = null; [EOL]         if (contentType.getRawClass() != Object.class) { [EOL]             JsonSerializer<Object> ser = provider.findValueSerializer(contentType, _property); [EOL]             if (ser instanceof SchemaAware) { [EOL]                 schemaNode = ((SchemaAware) ser).getSchema(provider, null); [EOL]             } [EOL]         } [EOL]         if (schemaNode == null) { [EOL]             schemaNode = com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); [EOL]         } [EOL]         o.put("items", schemaNode); [EOL]     } [EOL]     return o; [EOL] }
@SuppressWarnings("deprecation") [EOL] @Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException { [EOL]     ObjectNode o = createSchemaNode("array", true); [EOL]     JavaType contentType = null; [EOL]     if (typeHint != null) { [EOL]         JavaType javaType = provider.constructType(typeHint); [EOL]         contentType = javaType.getContentType(); [EOL]         if (contentType == null) { [EOL]             if (typeHint instanceof ParameterizedType) { [EOL]                 Type[] typeArgs = ((ParameterizedType) typeHint).getActualTypeArguments(); [EOL]                 if (typeArgs.length == 1) { [EOL]                     contentType = provider.constructType(typeArgs[0]); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (contentType == null && _elementType != null) { [EOL]         contentType = _elementType; [EOL]     } [EOL]     if (contentType != null) { [EOL]         JsonNode schemaNode = null; [EOL]         if (contentType.getRawClass() != Object.class) { [EOL]             JsonSerializer<Object> ser = provider.findValueSerializer(contentType, _property); [EOL]             if (ser instanceof SchemaAware) { [EOL]                 schemaNode = ((SchemaAware) ser).getSchema(provider, null); [EOL]             } [EOL]         } [EOL]         if (schemaNode == null) { [EOL]             schemaNode = com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); [EOL]         } [EOL]         o.put("items", schemaNode); [EOL]     } [EOL]     return o; [EOL] }
@SuppressWarnings("deprecation") [EOL] @Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException { [EOL]     ObjectNode o = createSchemaNode("array", true); [EOL]     JavaType contentType = null; [EOL]     if (typeHint != null) { [EOL]         JavaType javaType = provider.constructType(typeHint); [EOL]         contentType = javaType.getContentType(); [EOL]         if (contentType == null) { [EOL]             if (typeHint instanceof ParameterizedType) { [EOL]                 Type[] typeArgs = ((ParameterizedType) typeHint).getActualTypeArguments(); [EOL]                 if (typeArgs.length == 1) { [EOL]                     contentType = provider.constructType(typeArgs[0]); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (contentType == null && _elementType != null) { [EOL]         contentType = _elementType; [EOL]     } [EOL]     if (contentType != null) { [EOL]         JsonNode schemaNode = null; [EOL]         if (contentType.getRawClass() != Object.class) { [EOL]             JsonSerializer<Object> ser = provider.findValueSerializer(contentType, _property); [EOL]             if (ser instanceof SchemaAware) { [EOL]                 schemaNode = ((SchemaAware) ser).getSchema(provider, null); [EOL]             } [EOL]         } [EOL]         if (schemaNode == null) { [EOL]             schemaNode = com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); [EOL]         } [EOL]         o.put("items", schemaNode); [EOL]     } [EOL]     return o; [EOL] }
protected BaseSettings getBaseSettings() { [EOL]     return _base; [EOL] }
public DeserializationConfig without(DeserializationFeature feature) { [EOL]     int newDeserFeatures = _deserFeatures & ~feature.getMask(); [EOL]     return (newDeserFeatures == _deserFeatures) ? this : new DeserializationConfig(this, _mapperFeatures, newDeserFeatures); [EOL] }
public DeserializationConfig without(DeserializationFeature feature) { [EOL]     int newDeserFeatures = _deserFeatures & ~feature.getMask(); [EOL]     return (newDeserFeatures == _deserFeatures) ? this : new DeserializationConfig(this, _mapperFeatures, newDeserFeatures); [EOL] }
public JavaType parse(String canonical) throws IllegalArgumentException { [EOL]     canonical = canonical.trim(); [EOL]     MyTokenizer tokens = new MyTokenizer(canonical); [EOL]     JavaType type = parseType(tokens); [EOL]     if (tokens.hasMoreTokens()) { [EOL]         throw _problem(tokens, "Unexpected tokens after complete type"); [EOL]     } [EOL]     return type; [EOL] }
protected JavaType parseType(MyTokenizer tokens) throws IllegalArgumentException { [EOL]     if (!tokens.hasMoreTokens()) { [EOL]         throw _problem(tokens, "Unexpected end-of-string"); [EOL]     } [EOL]     Class<?> base = findClass(tokens.nextToken(), tokens); [EOL]     if (tokens.hasMoreTokens()) { [EOL]         String token = tokens.nextToken(); [EOL]         if ("<".equals(token)) { [EOL]             return _factory._fromParameterizedClass(base, parseTypes(tokens)); [EOL]         } [EOL]         tokens.pushBack(token); [EOL]     } [EOL]     return _factory._fromClass(base, null); [EOL] }
protected JavaType parseType(MyTokenizer tokens) throws IllegalArgumentException { [EOL]     if (!tokens.hasMoreTokens()) { [EOL]         throw _problem(tokens, "Unexpected end-of-string"); [EOL]     } [EOL]     Class<?> base = findClass(tokens.nextToken(), tokens); [EOL]     if (tokens.hasMoreTokens()) { [EOL]         String token = tokens.nextToken(); [EOL]         if ("<".equals(token)) { [EOL]             return _factory._fromParameterizedClass(base, parseTypes(tokens)); [EOL]         } [EOL]         tokens.pushBack(token); [EOL]     } [EOL]     return _factory._fromClass(base, null); [EOL] }
protected JavaType parseType(MyTokenizer tokens) throws IllegalArgumentException { [EOL]     if (!tokens.hasMoreTokens()) { [EOL]         throw _problem(tokens, "Unexpected end-of-string"); [EOL]     } [EOL]     Class<?> base = findClass(tokens.nextToken(), tokens); [EOL]     if (tokens.hasMoreTokens()) { [EOL]         String token = tokens.nextToken(); [EOL]         if ("<".equals(token)) { [EOL]             return _factory._fromParameterizedClass(base, parseTypes(tokens)); [EOL]         } [EOL]         tokens.pushBack(token); [EOL]     } [EOL]     return _factory._fromClass(base, null); [EOL] }
protected JavaType parseType(MyTokenizer tokens) throws IllegalArgumentException { [EOL]     if (!tokens.hasMoreTokens()) { [EOL]         throw _problem(tokens, "Unexpected end-of-string"); [EOL]     } [EOL]     Class<?> base = findClass(tokens.nextToken(), tokens); [EOL]     if (tokens.hasMoreTokens()) { [EOL]         String token = tokens.nextToken(); [EOL]         if ("<".equals(token)) { [EOL]             return _factory._fromParameterizedClass(base, parseTypes(tokens)); [EOL]         } [EOL]         tokens.pushBack(token); [EOL]     } [EOL]     return _factory._fromClass(base, null); [EOL] }
protected Class<?> findClass(String className, MyTokenizer tokens) { [EOL]     try { [EOL]         return ClassUtil.findClass(className); [EOL]     } catch (Exception e) { [EOL]         if (e instanceof RuntimeException) { [EOL]             throw (RuntimeException) e; [EOL]         } [EOL]         throw _problem(tokens, "Can not locate class '" + className + "', problem: " + e.getMessage()); [EOL]     } [EOL] }
protected Class<?> findClass(String className, MyTokenizer tokens) { [EOL]     try { [EOL]         return ClassUtil.findClass(className); [EOL]     } catch (Exception e) { [EOL]         if (e instanceof RuntimeException) { [EOL]             throw (RuntimeException) e; [EOL]         } [EOL]         throw _problem(tokens, "Can not locate class '" + className + "', problem: " + e.getMessage()); [EOL]     } [EOL] }
public MyTokenizer(String str) { [EOL]     super(str, "<,>", true); [EOL]     _input = str; [EOL] }
public MyTokenizer(String str) { [EOL]     super(str, "<,>", true); [EOL]     _input = str; [EOL] }
@Override [EOL] public boolean hasMoreTokens() { [EOL]     return (_pushbackToken != null) || super.hasMoreTokens(); [EOL] }
@Override [EOL] public boolean hasMoreTokens() { [EOL]     return (_pushbackToken != null) || super.hasMoreTokens(); [EOL] }
@Override [EOL] public boolean hasMoreTokens() { [EOL]     return (_pushbackToken != null) || super.hasMoreTokens(); [EOL] }
@Override [EOL] public String nextToken() { [EOL]     String token; [EOL]     if (_pushbackToken != null) { [EOL]         token = _pushbackToken; [EOL]         _pushbackToken = null; [EOL]     } else { [EOL]         token = super.nextToken(); [EOL]     } [EOL]     _index += token.length(); [EOL]     return token; [EOL] }
@Override [EOL] public String nextToken() { [EOL]     String token; [EOL]     if (_pushbackToken != null) { [EOL]         token = _pushbackToken; [EOL]         _pushbackToken = null; [EOL]     } else { [EOL]         token = super.nextToken(); [EOL]     } [EOL]     _index += token.length(); [EOL]     return token; [EOL] }
public ReadableObjectId(Object id) { [EOL]     this.id = id; [EOL] }
public ReadableObjectId(Object id) { [EOL]     this.id = id; [EOL] }
public void bindItem(Object ob) throws IOException { [EOL]     if (item != null) { [EOL]         throw new IllegalStateException("Already had POJO for id (" + id.getClass().getName() + ") [" + id + "]"); [EOL]     } [EOL]     item = ob; [EOL] }
public void bindItem(Object ob) throws IOException { [EOL]     if (item != null) { [EOL]         throw new IllegalStateException("Already had POJO for id (" + id.getClass().getName() + ") [" + id + "]"); [EOL]     } [EOL]     item = ob; [EOL] }
public boolean isUnwrappingSerializer() { [EOL]     return false; [EOL] }
public StdDateFormat(TimeZone tz) { [EOL]     _timezone = tz; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat(TimeZone tz) { [EOL]     _timezone = tz; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat(TimeZone tz) { [EOL]     _timezone = tz; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat(TimeZone tz) { [EOL]     _timezone = tz; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat(TimeZone tz) { [EOL]     _timezone = tz; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat(TimeZone tz) { [EOL]     _timezone = tz; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat(TimeZone tz) { [EOL]     _timezone = tz; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat(TimeZone tz) { [EOL]     _timezone = tz; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat(TimeZone tz) { [EOL]     _timezone = tz; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat(TimeZone tz) { [EOL]     _timezone = tz; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat(TimeZone tz) { [EOL]     _timezone = tz; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat(TimeZone tz) { [EOL]     _timezone = tz; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat(TimeZone tz) { [EOL]     _timezone = tz; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat(TimeZone tz) { [EOL]     _timezone = tz; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat(TimeZone tz) { [EOL]     _timezone = tz; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat(TimeZone tz) { [EOL]     _timezone = tz; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat(TimeZone tz) { [EOL]     _timezone = tz; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat withTimeZone(TimeZone tz) { [EOL]     if (tz == null) { [EOL]         tz = DEFAULT_TIMEZONE; [EOL]     } [EOL]     return new StdDateFormat(tz); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
public StdDateFormat withTimeZone(TimeZone tz) { [EOL]     if (tz == null) { [EOL]         tz = DEFAULT_TIMEZONE; [EOL]     } [EOL]     return new StdDateFormat(tz); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public Date parse(String dateStr, ParsePosition pos) { [EOL]     if (looksLikeISO8601(dateStr)) { [EOL]         return parseAsISO8601(dateStr, pos); [EOL]     } [EOL]     int i = dateStr.length(); [EOL]     while (--i >= 0) { [EOL]         char ch = dateStr.charAt(i); [EOL]         if (ch < '0' || ch > '9') [EOL]             break; [EOL]     } [EOL]     if (i < 0) { [EOL]         if (NumberInput.inLongRange(dateStr, false)) { [EOL]             return new Date(Long.parseLong(dateStr)); [EOL]         } [EOL]     } [EOL]     return parseAsRFC1123(dateStr, pos); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public Date parse(String dateStr, ParsePosition pos) { [EOL]     if (looksLikeISO8601(dateStr)) { [EOL]         return parseAsISO8601(dateStr, pos); [EOL]     } [EOL]     int i = dateStr.length(); [EOL]     while (--i >= 0) { [EOL]         char ch = dateStr.charAt(i); [EOL]         if (ch < '0' || ch > '9') [EOL]             break; [EOL]     } [EOL]     if (i < 0) { [EOL]         if (NumberInput.inLongRange(dateStr, false)) { [EOL]             return new Date(Long.parseLong(dateStr)); [EOL]         } [EOL]     } [EOL]     return parseAsRFC1123(dateStr, pos); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public Date parse(String dateStr, ParsePosition pos) { [EOL]     if (looksLikeISO8601(dateStr)) { [EOL]         return parseAsISO8601(dateStr, pos); [EOL]     } [EOL]     int i = dateStr.length(); [EOL]     while (--i >= 0) { [EOL]         char ch = dateStr.charAt(i); [EOL]         if (ch < '0' || ch > '9') [EOL]             break; [EOL]     } [EOL]     if (i < 0) { [EOL]         if (NumberInput.inLongRange(dateStr, false)) { [EOL]             return new Date(Long.parseLong(dateStr)); [EOL]         } [EOL]     } [EOL]     return parseAsRFC1123(dateStr, pos); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
@Override [EOL] public Date parse(String dateStr, ParsePosition pos) { [EOL]     if (looksLikeISO8601(dateStr)) { [EOL]         return parseAsISO8601(dateStr, pos); [EOL]     } [EOL]     int i = dateStr.length(); [EOL]     while (--i >= 0) { [EOL]         char ch = dateStr.charAt(i); [EOL]         if (ch < '0' || ch > '9') [EOL]             break; [EOL]     } [EOL]     if (i < 0) { [EOL]         if (NumberInput.inLongRange(dateStr, false)) { [EOL]             return new Date(Long.parseLong(dateStr)); [EOL]         } [EOL]     } [EOL]     return parseAsRFC1123(dateStr, pos); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
protected Date parseAsISO8601(String dateStr, ParsePosition pos) { [EOL]     int len = dateStr.length(); [EOL]     char c = dateStr.charAt(len - 1); [EOL]     DateFormat df; [EOL]     if (len <= 10 && Character.isDigit(c)) { [EOL]         df = _formatPlain; [EOL]         if (df == null) { [EOL]             df = _formatPlain = _cloneFormat(DATE_FORMAT_PLAIN); [EOL]         } [EOL]     } else if (c == 'Z') { [EOL]         df = _formatISO8601_z; [EOL]         if (df == null) { [EOL]             df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z); [EOL]         } [EOL]         if (dateStr.charAt(len - 4) == ':') { [EOL]             StringBuilder sb = new StringBuilder(dateStr); [EOL]             sb.insert(len - 1, ".000"); [EOL]             dateStr = sb.toString(); [EOL]         } [EOL]     } else { [EOL]         if (hasTimeZone(dateStr)) { [EOL]             c = dateStr.charAt(len - 3); [EOL]             if (c == ':') { [EOL]                 StringBuilder sb = new StringBuilder(dateStr); [EOL]                 sb.delete(len - 3, len - 2); [EOL]                 dateStr = sb.toString(); [EOL]             } else if (c == '+' || c == '-') { [EOL]                 dateStr += "00"; [EOL]             } [EOL]             len = dateStr.length(); [EOL]             c = dateStr.charAt(len - 9); [EOL]             if (Character.isDigit(c)) { [EOL]                 StringBuilder sb = new StringBuilder(dateStr); [EOL]                 sb.insert(len - 5, ".000"); [EOL]                 dateStr = sb.toString(); [EOL]             } [EOL]             df = _formatISO8601; [EOL]             if (_formatISO8601 == null) { [EOL]                 df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601); [EOL]             } [EOL]         } else { [EOL]             StringBuilder sb = new StringBuilder(dateStr); [EOL]             int timeLen = len - dateStr.lastIndexOf('T') - 1; [EOL]             if (timeLen <= 8) { [EOL]                 sb.append(".000"); [EOL]             } [EOL]             sb.append('Z'); [EOL]             dateStr = sb.toString(); [EOL]             df = _formatISO8601_z; [EOL]             if (df == null) { [EOL]                 df = _formatISO8601_z = _cloneFormat(DATE_FORMAT_ISO8601_Z); [EOL]             } [EOL]         } [EOL]     } [EOL]     return df.parse(dateStr, pos); [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final static boolean hasTimeZone(String str) { [EOL]     int len = str.length(); [EOL]     if (len >= 6) { [EOL]         char c = str.charAt(len - 6); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]         c = str.charAt(len - 5); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]         c = str.charAt(len - 3); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final static boolean hasTimeZone(String str) { [EOL]     int len = str.length(); [EOL]     if (len >= 6) { [EOL]         char c = str.charAt(len - 6); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]         c = str.charAt(len - 5); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]         c = str.charAt(len - 3); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final static boolean hasTimeZone(String str) { [EOL]     int len = str.length(); [EOL]     if (len >= 6) { [EOL]         char c = str.charAt(len - 6); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]         c = str.charAt(len - 5); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]         c = str.charAt(len - 3); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final static boolean hasTimeZone(String str) { [EOL]     int len = str.length(); [EOL]     if (len >= 6) { [EOL]         char c = str.charAt(len - 6); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]         c = str.charAt(len - 5); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]         c = str.charAt(len - 3); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final static boolean hasTimeZone(String str) { [EOL]     int len = str.length(); [EOL]     if (len >= 6) { [EOL]         char c = str.charAt(len - 6); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]         c = str.charAt(len - 5); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]         c = str.charAt(len - 3); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final static boolean hasTimeZone(String str) { [EOL]     int len = str.length(); [EOL]     if (len >= 6) { [EOL]         char c = str.charAt(len - 6); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]         c = str.charAt(len - 5); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]         c = str.charAt(len - 3); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
private final static boolean hasTimeZone(String str) { [EOL]     int len = str.length(); [EOL]     if (len >= 6) { [EOL]         char c = str.charAt(len - 6); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]         c = str.charAt(len - 5); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]         c = str.charAt(len - 3); [EOL]         if (c == '+' || c == '-') [EOL]             return true; [EOL]     } [EOL]     return false; [EOL] } public StdDateFormat(); public StdDateFormat(TimeZone tz); public static TimeZone getDefaultTimeZone(); public StdDateFormat withTimeZone(TimeZone tz); public StdDateFormat clone(); public static DateFormat getBlueprintISO8601Format(); public static DateFormat getISO8601Format(TimeZone tz); public static DateFormat getBlueprintRFC1123Format(); public static DateFormat getRFC1123Format(TimeZone tz); public void setTimeZone(TimeZone tz); public Date parse(String dateStr) throws ParseException; public Date parse(String dateStr, ParsePosition pos); public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition); protected boolean looksLikeISO8601(String dateStr); protected Date parseAsISO8601(String dateStr, ParsePosition pos); protected Date parseAsRFC1123(String dateStr, ParsePosition pos); private static final boolean hasTimeZone(String str); private final DateFormat _cloneFormat(DateFormat df); private static final DateFormat _cloneFormat(DateFormat df, TimeZone tz); String DATE_FORMAT_STR_ISO8601=Optional["yyyy-MM-dd'T'HH:mm:ss.SSSZ"]; String DATE_FORMAT_STR_ISO8601_Z=Optional["yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]; String DATE_FORMAT_STR_PLAIN=Optional["yyyy-MM-dd"]; String DATE_FORMAT_STR_RFC1123=Optional["EEE, dd MMM yyyy HH:mm:ss zzz"]; String[] ALL_FORMATS=Optional[new String[] { DATE_FORMAT_STR_ISO8601, DATE_FORMAT_STR_ISO8601_Z, DATE_FORMAT_STR_RFC1123, DATE_FORMAT_STR_PLAIN }
protected SimpleBeanPropertyFilter() { [EOL] }
public static SimpleBeanPropertyFilter serializeAllExcept(String... propertyArray) { [EOL]     HashSet<String> properties = new HashSet<String>(propertyArray.length); [EOL]     Collections.addAll(properties, propertyArray); [EOL]     return new SerializeExceptFilter(properties); [EOL] }
public static SimpleBeanPropertyFilter serializeAllExcept(String... propertyArray) { [EOL]     HashSet<String> properties = new HashSet<String>(propertyArray.length); [EOL]     Collections.addAll(properties, propertyArray); [EOL]     return new SerializeExceptFilter(properties); [EOL] }
public static SimpleBeanPropertyFilter serializeAllExcept(String... propertyArray) { [EOL]     HashSet<String> properties = new HashSet<String>(propertyArray.length); [EOL]     Collections.addAll(properties, propertyArray); [EOL]     return new SerializeExceptFilter(properties); [EOL] }
@Override [EOL] public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider provider, BeanPropertyWriter writer) throws Exception { [EOL]     if (include(writer)) { [EOL]         writer.serializeAsField(bean, jgen, provider); [EOL]     } [EOL] }
@Override [EOL] public void depositSchemaProperty(BeanPropertyWriter writer, ObjectNode propertiesNode, SerializerProvider provider) throws JsonMappingException { [EOL]     if (include(writer)) { [EOL]         writer.depositSchemaProperty(propertiesNode, provider); [EOL]     } [EOL] }
@Override [EOL] public void depositSchemaProperty(BeanPropertyWriter writer, ObjectNode propertiesNode, SerializerProvider provider) throws JsonMappingException { [EOL]     if (include(writer)) { [EOL]         writer.depositSchemaProperty(propertiesNode, provider); [EOL]     } [EOL] }
@Override [EOL] protected boolean include(BeanPropertyWriter writer) { [EOL]     return _propertiesToInclude.contains(writer.getName()); [EOL] }
@Override [EOL] protected boolean include(BeanPropertyWriter writer) { [EOL]     return _propertiesToInclude.contains(writer.getName()); [EOL] }
public SerializeExceptFilter(Set<String> properties) { [EOL]     _propertiesToExclude = properties; [EOL] }
public SerializeExceptFilter(Set<String> properties) { [EOL]     _propertiesToExclude = properties; [EOL] }
public SerializeExceptFilter(Set<String> properties) { [EOL]     _propertiesToExclude = properties; [EOL] }
@Override [EOL] protected boolean include(BeanPropertyWriter writer) { [EOL]     return !_propertiesToExclude.contains(writer.getName()); [EOL] }
@Override [EOL] protected boolean include(BeanPropertyWriter writer) { [EOL]     return !_propertiesToExclude.contains(writer.getName()); [EOL] }
@Override [EOL] public <A extends Annotation> A getContextAnnotation(Class<A> acls) { [EOL]     return _contextAnnotations.get(acls); [EOL] }
@Override [EOL] public <A extends Annotation> A getContextAnnotation(Class<A> acls) { [EOL]     return _contextAnnotations.get(acls); [EOL] }
public MethodProperty(BeanPropertyDefinition propDef, JavaType type, TypeDeserializer typeDeser, Annotations contextAnnotations, AnnotatedMethod method) { [EOL]     super(propDef, type, typeDeser, contextAnnotations); [EOL]     _annotated = method; [EOL]     _setter = method.getAnnotated(); [EOL] }
public MethodProperty(BeanPropertyDefinition propDef, JavaType type, TypeDeserializer typeDeser, Annotations contextAnnotations, AnnotatedMethod method) { [EOL]     super(propDef, type, typeDeser, contextAnnotations); [EOL]     _annotated = method; [EOL]     _setter = method.getAnnotated(); [EOL] }
protected MethodProperty(MethodProperty src, JsonDeserializer<?> deser) { [EOL]     super(src, deser); [EOL]     _annotated = src._annotated; [EOL]     _setter = src._setter; [EOL] }
protected MethodProperty(MethodProperty src, JsonDeserializer<?> deser) { [EOL]     super(src, deser); [EOL]     _annotated = src._annotated; [EOL]     _setter = src._setter; [EOL] }
@Override [EOL] public MethodProperty withValueDeserializer(JsonDeserializer<?> deser) { [EOL]     return new MethodProperty(this, deser); [EOL] }
@Override [EOL] public MethodProperty withValueDeserializer(JsonDeserializer<?> deser) { [EOL]     return new MethodProperty(this, deser); [EOL] }
@Override [EOL] public AnnotatedMember getMember() { [EOL]     return _annotated; [EOL] }
@Override [EOL] public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException { [EOL]     set(instance, deserialize(jp, ctxt)); [EOL] }
@Override [EOL] public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException, JsonProcessingException { [EOL]     set(instance, deserialize(jp, ctxt)); [EOL] }
@Override [EOL] public final void set(Object instance, Object value) throws IOException { [EOL]     try { [EOL]         _setter.invoke(instance, value); [EOL]     } catch (Exception e) { [EOL]         _throwAsIOE(e, value); [EOL]     } [EOL] }
@Override [EOL] public final void set(Object instance, Object value) throws IOException { [EOL]     try { [EOL]         _setter.invoke(instance, value); [EOL]     } catch (Exception e) { [EOL]         _throwAsIOE(e, value); [EOL]     } [EOL] }
public void writeAsField(JsonGenerator jgen, SerializerProvider provider, ObjectIdWriter w) throws IOException, JsonGenerationException { [EOL]     SerializedString name = w.propertyName; [EOL]     idWritten = true; [EOL]     if (name != null) { [EOL]         jgen.writeFieldName(name); [EOL]         w.serializer.serialize(id, jgen, provider); [EOL]     } [EOL] }
public void writeAsField(JsonGenerator jgen, SerializerProvider provider, ObjectIdWriter w) throws IOException, JsonGenerationException { [EOL]     SerializedString name = w.propertyName; [EOL]     idWritten = true; [EOL]     if (name != null) { [EOL]         jgen.writeFieldName(name); [EOL]         w.serializer.serialize(id, jgen, provider); [EOL]     } [EOL] }
@Override [EOL] public Class<?> getDeclaringClass() { [EOL]     return _field.getDeclaringClass(); [EOL] }
public String getFullName() { [EOL]     return getDeclaringClass().getName() + "#" + getName(); [EOL] }
@Override [EOL] public String toString() { [EOL]     return "[field " + getFullName() + "]"; [EOL] }
@Override [EOL] public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_objectIdWriter != null) { [EOL]         _serializeWithObjectId(bean, jgen, provider, true); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartObject(); [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     jgen.writeEndObject(); [EOL] }
@Override [EOL] public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_objectIdWriter != null) { [EOL]         _serializeWithObjectId(bean, jgen, provider, true); [EOL]         return; [EOL]     } [EOL]     jgen.writeStartObject(); [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     jgen.writeEndObject(); [EOL] }
public AsExternalTypeSerializer(TypeIdResolver idRes, BeanProperty property, String propName) { [EOL]     super(idRes, property); [EOL]     _typePropertyName = propName; [EOL] }
public AsExternalTypeSerializer(TypeIdResolver idRes, BeanProperty property, String propName) { [EOL]     super(idRes, property); [EOL]     _typePropertyName = propName; [EOL] }
@Override [EOL] public void writeTypePrefixForObject(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     _writeObjectPrefix(value, jgen); [EOL] }
@Override [EOL] public void writeTypeSuffixForObject(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     _writeObjectSuffix(value, jgen, idFromValue(value)); [EOL] }
@Override [EOL] public void writeCustomTypePrefixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException, JsonProcessingException { [EOL]     _writeObjectPrefix(value, jgen); [EOL] }
@Override [EOL] public void writeCustomTypePrefixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException, JsonProcessingException { [EOL]     _writeObjectPrefix(value, jgen); [EOL] }
@Override [EOL] public void writeCustomTypeSuffixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException, JsonProcessingException { [EOL]     _writeObjectSuffix(value, jgen, typeId); [EOL] }
protected final void _writeObjectPrefix(Object value, JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     jgen.writeStartObject(); [EOL] }
protected final void _writeObjectSuffix(Object value, JsonGenerator jgen, String typeId) throws IOException, JsonProcessingException { [EOL]     jgen.writeEndObject(); [EOL]     jgen.writeStringField(_typePropertyName, typeId); [EOL] }
protected final void _writeObjectSuffix(Object value, JsonGenerator jgen, String typeId) throws IOException, JsonProcessingException { [EOL]     jgen.writeEndObject(); [EOL]     jgen.writeStringField(_typePropertyName, typeId); [EOL] }
protected ExternalTypeHandler(ExtTypedProperty[] properties, HashMap<String, Integer> nameToPropertyIndex, String[] typeIds, TokenBuffer[] tokens) { [EOL]     _properties = properties; [EOL]     _nameToPropertyIndex = nameToPropertyIndex; [EOL]     _typeIds = typeIds; [EOL]     _tokens = tokens; [EOL] }
protected ExternalTypeHandler(ExtTypedProperty[] properties, HashMap<String, Integer> nameToPropertyIndex, String[] typeIds, TokenBuffer[] tokens) { [EOL]     _properties = properties; [EOL]     _nameToPropertyIndex = nameToPropertyIndex; [EOL]     _typeIds = typeIds; [EOL]     _tokens = tokens; [EOL] }
protected ExternalTypeHandler(ExternalTypeHandler h) { [EOL]     _properties = h._properties; [EOL]     _nameToPropertyIndex = h._nameToPropertyIndex; [EOL]     int len = _properties.length; [EOL]     _typeIds = new String[len]; [EOL]     _tokens = new TokenBuffer[len]; [EOL] }
public ExternalTypeHandler start() { [EOL]     return new ExternalTypeHandler(this); [EOL] }
public boolean handleTypePropertyValue(JsonParser jp, DeserializationContext ctxt, String propName, Object bean) throws IOException, JsonProcessingException { [EOL]     Integer I = _nameToPropertyIndex.get(propName); [EOL]     if (I == null) { [EOL]         return false; [EOL]     } [EOL]     int index = I.intValue(); [EOL]     ExtTypedProperty prop = _properties[index]; [EOL]     if (!prop.hasTypePropertyName(propName)) { [EOL]         return false; [EOL]     } [EOL]     String typeId = jp.getText(); [EOL]     boolean canDeserialize = (bean != null) && (_tokens[index] != null); [EOL]     if (canDeserialize) { [EOL]         _deserializeAndSet(jp, ctxt, bean, index, typeId); [EOL]         _tokens[index] = null; [EOL]     } else { [EOL]         _typeIds[index] = typeId; [EOL]     } [EOL]     return true; [EOL] }
public boolean handleTypePropertyValue(JsonParser jp, DeserializationContext ctxt, String propName, Object bean) throws IOException, JsonProcessingException { [EOL]     Integer I = _nameToPropertyIndex.get(propName); [EOL]     if (I == null) { [EOL]         return false; [EOL]     } [EOL]     int index = I.intValue(); [EOL]     ExtTypedProperty prop = _properties[index]; [EOL]     if (!prop.hasTypePropertyName(propName)) { [EOL]         return false; [EOL]     } [EOL]     String typeId = jp.getText(); [EOL]     boolean canDeserialize = (bean != null) && (_tokens[index] != null); [EOL]     if (canDeserialize) { [EOL]         _deserializeAndSet(jp, ctxt, bean, index, typeId); [EOL]         _tokens[index] = null; [EOL]     } else { [EOL]         _typeIds[index] = typeId; [EOL]     } [EOL]     return true; [EOL] }
public boolean handleTypePropertyValue(JsonParser jp, DeserializationContext ctxt, String propName, Object bean) throws IOException, JsonProcessingException { [EOL]     Integer I = _nameToPropertyIndex.get(propName); [EOL]     if (I == null) { [EOL]         return false; [EOL]     } [EOL]     int index = I.intValue(); [EOL]     ExtTypedProperty prop = _properties[index]; [EOL]     if (!prop.hasTypePropertyName(propName)) { [EOL]         return false; [EOL]     } [EOL]     String typeId = jp.getText(); [EOL]     boolean canDeserialize = (bean != null) && (_tokens[index] != null); [EOL]     if (canDeserialize) { [EOL]         _deserializeAndSet(jp, ctxt, bean, index, typeId); [EOL]         _tokens[index] = null; [EOL]     } else { [EOL]         _typeIds[index] = typeId; [EOL]     } [EOL]     return true; [EOL] }
public boolean handlePropertyValue(JsonParser jp, DeserializationContext ctxt, String propName, Object bean) throws IOException, JsonProcessingException { [EOL]     Integer I = _nameToPropertyIndex.get(propName); [EOL]     if (I == null) { [EOL]         return false; [EOL]     } [EOL]     int index = I.intValue(); [EOL]     ExtTypedProperty prop = _properties[index]; [EOL]     boolean canDeserialize; [EOL]     if (prop.hasTypePropertyName(propName)) { [EOL]         _typeIds[index] = jp.getText(); [EOL]         jp.skipChildren(); [EOL]         canDeserialize = (bean != null) && (_tokens[index] != null); [EOL]     } else { [EOL]         @SuppressWarnings("resource") [EOL]         TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL]         tokens.copyCurrentStructure(jp); [EOL]         _tokens[index] = tokens; [EOL]         canDeserialize = (bean != null) && (_typeIds[index] != null); [EOL]     } [EOL]     if (canDeserialize) { [EOL]         String typeId = _typeIds[index]; [EOL]         _typeIds[index] = null; [EOL]         _deserializeAndSet(jp, ctxt, bean, index, typeId); [EOL]         _tokens[index] = null; [EOL]     } [EOL]     return true; [EOL] }
public boolean handlePropertyValue(JsonParser jp, DeserializationContext ctxt, String propName, Object bean) throws IOException, JsonProcessingException { [EOL]     Integer I = _nameToPropertyIndex.get(propName); [EOL]     if (I == null) { [EOL]         return false; [EOL]     } [EOL]     int index = I.intValue(); [EOL]     ExtTypedProperty prop = _properties[index]; [EOL]     boolean canDeserialize; [EOL]     if (prop.hasTypePropertyName(propName)) { [EOL]         _typeIds[index] = jp.getText(); [EOL]         jp.skipChildren(); [EOL]         canDeserialize = (bean != null) && (_tokens[index] != null); [EOL]     } else { [EOL]         @SuppressWarnings("resource") [EOL]         TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL]         tokens.copyCurrentStructure(jp); [EOL]         _tokens[index] = tokens; [EOL]         canDeserialize = (bean != null) && (_typeIds[index] != null); [EOL]     } [EOL]     if (canDeserialize) { [EOL]         String typeId = _typeIds[index]; [EOL]         _typeIds[index] = null; [EOL]         _deserializeAndSet(jp, ctxt, bean, index, typeId); [EOL]         _tokens[index] = null; [EOL]     } [EOL]     return true; [EOL] }
public boolean handlePropertyValue(JsonParser jp, DeserializationContext ctxt, String propName, Object bean) throws IOException, JsonProcessingException { [EOL]     Integer I = _nameToPropertyIndex.get(propName); [EOL]     if (I == null) { [EOL]         return false; [EOL]     } [EOL]     int index = I.intValue(); [EOL]     ExtTypedProperty prop = _properties[index]; [EOL]     boolean canDeserialize; [EOL]     if (prop.hasTypePropertyName(propName)) { [EOL]         _typeIds[index] = jp.getText(); [EOL]         jp.skipChildren(); [EOL]         canDeserialize = (bean != null) && (_tokens[index] != null); [EOL]     } else { [EOL]         @SuppressWarnings("resource") [EOL]         TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL]         tokens.copyCurrentStructure(jp); [EOL]         _tokens[index] = tokens; [EOL]         canDeserialize = (bean != null) && (_typeIds[index] != null); [EOL]     } [EOL]     if (canDeserialize) { [EOL]         String typeId = _typeIds[index]; [EOL]         _typeIds[index] = null; [EOL]         _deserializeAndSet(jp, ctxt, bean, index, typeId); [EOL]         _tokens[index] = null; [EOL]     } [EOL]     return true; [EOL] }
public boolean handlePropertyValue(JsonParser jp, DeserializationContext ctxt, String propName, Object bean) throws IOException, JsonProcessingException { [EOL]     Integer I = _nameToPropertyIndex.get(propName); [EOL]     if (I == null) { [EOL]         return false; [EOL]     } [EOL]     int index = I.intValue(); [EOL]     ExtTypedProperty prop = _properties[index]; [EOL]     boolean canDeserialize; [EOL]     if (prop.hasTypePropertyName(propName)) { [EOL]         _typeIds[index] = jp.getText(); [EOL]         jp.skipChildren(); [EOL]         canDeserialize = (bean != null) && (_tokens[index] != null); [EOL]     } else { [EOL]         @SuppressWarnings("resource") [EOL]         TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL]         tokens.copyCurrentStructure(jp); [EOL]         _tokens[index] = tokens; [EOL]         canDeserialize = (bean != null) && (_typeIds[index] != null); [EOL]     } [EOL]     if (canDeserialize) { [EOL]         String typeId = _typeIds[index]; [EOL]         _typeIds[index] = null; [EOL]         _deserializeAndSet(jp, ctxt, bean, index, typeId); [EOL]         _tokens[index] = null; [EOL]     } [EOL]     return true; [EOL] }
public Object complete(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     for (int i = 0, len = _properties.length; i < len; ++i) { [EOL]         String typeId = _typeIds[i]; [EOL]         if (typeId == null) { [EOL]             TokenBuffer tokens = _tokens[i]; [EOL]             if (tokens == null) { [EOL]                 continue; [EOL]             } [EOL]             JsonToken t = tokens.firstToken(); [EOL]             if (t != null && t.isScalarValue()) { [EOL]                 JsonParser buffered = tokens.asParser(jp); [EOL]                 buffered.nextToken(); [EOL]                 SettableBeanProperty extProp = _properties[i].getProperty(); [EOL]                 Object result = TypeDeserializer.deserializeIfNatural(buffered, ctxt, extProp.getType()); [EOL]                 if (result != null) { [EOL]                     extProp.set(bean, result); [EOL]                     continue; [EOL]                 } [EOL]                 if (!_properties[i].hasDefaultType()) { [EOL]                     throw ctxt.mappingException("Missing external type id property '" + _properties[i].getTypePropertyName() + "'"); [EOL]                 } [EOL]                 typeId = _properties[i].getDefaultTypeId(); [EOL]             } [EOL]         } else if (_tokens[i] == null) { [EOL]             SettableBeanProperty prop = _properties[i].getProperty(); [EOL]             throw ctxt.mappingException("Missing property '" + prop.getName() + "' for external type id '" + _properties[i].getTypePropertyName()); [EOL]         } [EOL]         _deserializeAndSet(jp, ctxt, bean, i, typeId); [EOL]     } [EOL]     return bean; [EOL] }
public Object complete(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     for (int i = 0, len = _properties.length; i < len; ++i) { [EOL]         String typeId = _typeIds[i]; [EOL]         if (typeId == null) { [EOL]             TokenBuffer tokens = _tokens[i]; [EOL]             if (tokens == null) { [EOL]                 continue; [EOL]             } [EOL]             JsonToken t = tokens.firstToken(); [EOL]             if (t != null && t.isScalarValue()) { [EOL]                 JsonParser buffered = tokens.asParser(jp); [EOL]                 buffered.nextToken(); [EOL]                 SettableBeanProperty extProp = _properties[i].getProperty(); [EOL]                 Object result = TypeDeserializer.deserializeIfNatural(buffered, ctxt, extProp.getType()); [EOL]                 if (result != null) { [EOL]                     extProp.set(bean, result); [EOL]                     continue; [EOL]                 } [EOL]                 if (!_properties[i].hasDefaultType()) { [EOL]                     throw ctxt.mappingException("Missing external type id property '" + _properties[i].getTypePropertyName() + "'"); [EOL]                 } [EOL]                 typeId = _properties[i].getDefaultTypeId(); [EOL]             } [EOL]         } else if (_tokens[i] == null) { [EOL]             SettableBeanProperty prop = _properties[i].getProperty(); [EOL]             throw ctxt.mappingException("Missing property '" + prop.getName() + "' for external type id '" + _properties[i].getTypePropertyName()); [EOL]         } [EOL]         _deserializeAndSet(jp, ctxt, bean, i, typeId); [EOL]     } [EOL]     return bean; [EOL] }
public Object complete(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     for (int i = 0, len = _properties.length; i < len; ++i) { [EOL]         String typeId = _typeIds[i]; [EOL]         if (typeId == null) { [EOL]             TokenBuffer tokens = _tokens[i]; [EOL]             if (tokens == null) { [EOL]                 continue; [EOL]             } [EOL]             JsonToken t = tokens.firstToken(); [EOL]             if (t != null && t.isScalarValue()) { [EOL]                 JsonParser buffered = tokens.asParser(jp); [EOL]                 buffered.nextToken(); [EOL]                 SettableBeanProperty extProp = _properties[i].getProperty(); [EOL]                 Object result = TypeDeserializer.deserializeIfNatural(buffered, ctxt, extProp.getType()); [EOL]                 if (result != null) { [EOL]                     extProp.set(bean, result); [EOL]                     continue; [EOL]                 } [EOL]                 if (!_properties[i].hasDefaultType()) { [EOL]                     throw ctxt.mappingException("Missing external type id property '" + _properties[i].getTypePropertyName() + "'"); [EOL]                 } [EOL]                 typeId = _properties[i].getDefaultTypeId(); [EOL]             } [EOL]         } else if (_tokens[i] == null) { [EOL]             SettableBeanProperty prop = _properties[i].getProperty(); [EOL]             throw ctxt.mappingException("Missing property '" + prop.getName() + "' for external type id '" + _properties[i].getTypePropertyName()); [EOL]         } [EOL]         _deserializeAndSet(jp, ctxt, bean, i, typeId); [EOL]     } [EOL]     return bean; [EOL] }
public Object complete(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     for (int i = 0, len = _properties.length; i < len; ++i) { [EOL]         String typeId = _typeIds[i]; [EOL]         if (typeId == null) { [EOL]             TokenBuffer tokens = _tokens[i]; [EOL]             if (tokens == null) { [EOL]                 continue; [EOL]             } [EOL]             JsonToken t = tokens.firstToken(); [EOL]             if (t != null && t.isScalarValue()) { [EOL]                 JsonParser buffered = tokens.asParser(jp); [EOL]                 buffered.nextToken(); [EOL]                 SettableBeanProperty extProp = _properties[i].getProperty(); [EOL]                 Object result = TypeDeserializer.deserializeIfNatural(buffered, ctxt, extProp.getType()); [EOL]                 if (result != null) { [EOL]                     extProp.set(bean, result); [EOL]                     continue; [EOL]                 } [EOL]                 if (!_properties[i].hasDefaultType()) { [EOL]                     throw ctxt.mappingException("Missing external type id property '" + _properties[i].getTypePropertyName() + "'"); [EOL]                 } [EOL]                 typeId = _properties[i].getDefaultTypeId(); [EOL]             } [EOL]         } else if (_tokens[i] == null) { [EOL]             SettableBeanProperty prop = _properties[i].getProperty(); [EOL]             throw ctxt.mappingException("Missing property '" + prop.getName() + "' for external type id '" + _properties[i].getTypePropertyName()); [EOL]         } [EOL]         _deserializeAndSet(jp, ctxt, bean, i, typeId); [EOL]     } [EOL]     return bean; [EOL] }
public Object complete(JsonParser jp, DeserializationContext ctxt, PropertyValueBuffer buffer, PropertyBasedCreator creator) throws IOException, JsonProcessingException { [EOL]     final int len = _properties.length; [EOL]     Object[] values = new Object[len]; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         String typeId = _typeIds[i]; [EOL]         if (typeId == null) { [EOL]             if (_tokens[i] == null) { [EOL]                 continue; [EOL]             } [EOL]             if (!_properties[i].hasDefaultType()) { [EOL]                 throw ctxt.mappingException("Missing external type id property '" + _properties[i].getTypePropertyName() + "'"); [EOL]             } [EOL]             typeId = _properties[i].getDefaultTypeId(); [EOL]         } else if (_tokens[i] == null) { [EOL]             SettableBeanProperty prop = _properties[i].getProperty(); [EOL]             throw ctxt.mappingException("Missing property '" + prop.getName() + "' for external type id '" + _properties[i].getTypePropertyName()); [EOL]         } [EOL]         values[i] = _deserialize(jp, ctxt, i, typeId); [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         SettableBeanProperty prop = _properties[i].getProperty(); [EOL]         if (creator.findCreatorProperty(prop.getName()) != null) { [EOL]             buffer.assignParameter(prop.getCreatorIndex(), values[i]); [EOL]         } [EOL]     } [EOL]     Object bean = creator.build(ctxt, buffer); [EOL]     for (int i = 0; i < len; ++i) { [EOL]         SettableBeanProperty prop = _properties[i].getProperty(); [EOL]         if (creator.findCreatorProperty(prop.getName()) == null) { [EOL]             prop.set(bean, values[i]); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
public Object complete(JsonParser jp, DeserializationContext ctxt, PropertyValueBuffer buffer, PropertyBasedCreator creator) throws IOException, JsonProcessingException { [EOL]     final int len = _properties.length; [EOL]     Object[] values = new Object[len]; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         String typeId = _typeIds[i]; [EOL]         if (typeId == null) { [EOL]             if (_tokens[i] == null) { [EOL]                 continue; [EOL]             } [EOL]             if (!_properties[i].hasDefaultType()) { [EOL]                 throw ctxt.mappingException("Missing external type id property '" + _properties[i].getTypePropertyName() + "'"); [EOL]             } [EOL]             typeId = _properties[i].getDefaultTypeId(); [EOL]         } else if (_tokens[i] == null) { [EOL]             SettableBeanProperty prop = _properties[i].getProperty(); [EOL]             throw ctxt.mappingException("Missing property '" + prop.getName() + "' for external type id '" + _properties[i].getTypePropertyName()); [EOL]         } [EOL]         values[i] = _deserialize(jp, ctxt, i, typeId); [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         SettableBeanProperty prop = _properties[i].getProperty(); [EOL]         if (creator.findCreatorProperty(prop.getName()) != null) { [EOL]             buffer.assignParameter(prop.getCreatorIndex(), values[i]); [EOL]         } [EOL]     } [EOL]     Object bean = creator.build(ctxt, buffer); [EOL]     for (int i = 0; i < len; ++i) { [EOL]         SettableBeanProperty prop = _properties[i].getProperty(); [EOL]         if (creator.findCreatorProperty(prop.getName()) == null) { [EOL]             prop.set(bean, values[i]); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
public Object complete(JsonParser jp, DeserializationContext ctxt, PropertyValueBuffer buffer, PropertyBasedCreator creator) throws IOException, JsonProcessingException { [EOL]     final int len = _properties.length; [EOL]     Object[] values = new Object[len]; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         String typeId = _typeIds[i]; [EOL]         if (typeId == null) { [EOL]             if (_tokens[i] == null) { [EOL]                 continue; [EOL]             } [EOL]             if (!_properties[i].hasDefaultType()) { [EOL]                 throw ctxt.mappingException("Missing external type id property '" + _properties[i].getTypePropertyName() + "'"); [EOL]             } [EOL]             typeId = _properties[i].getDefaultTypeId(); [EOL]         } else if (_tokens[i] == null) { [EOL]             SettableBeanProperty prop = _properties[i].getProperty(); [EOL]             throw ctxt.mappingException("Missing property '" + prop.getName() + "' for external type id '" + _properties[i].getTypePropertyName()); [EOL]         } [EOL]         values[i] = _deserialize(jp, ctxt, i, typeId); [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         SettableBeanProperty prop = _properties[i].getProperty(); [EOL]         if (creator.findCreatorProperty(prop.getName()) != null) { [EOL]             buffer.assignParameter(prop.getCreatorIndex(), values[i]); [EOL]         } [EOL]     } [EOL]     Object bean = creator.build(ctxt, buffer); [EOL]     for (int i = 0; i < len; ++i) { [EOL]         SettableBeanProperty prop = _properties[i].getProperty(); [EOL]         if (creator.findCreatorProperty(prop.getName()) == null) { [EOL]             prop.set(bean, values[i]); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
protected final Object _deserialize(JsonParser jp, DeserializationContext ctxt, int index, String typeId) throws IOException, JsonProcessingException { [EOL]     @SuppressWarnings("resource") [EOL]     TokenBuffer merged = new TokenBuffer(jp.getCodec()); [EOL]     merged.writeStartArray(); [EOL]     merged.writeString(typeId); [EOL]     JsonParser p2 = _tokens[index].asParser(jp); [EOL]     p2.nextToken(); [EOL]     merged.copyCurrentStructure(p2); [EOL]     merged.writeEndArray(); [EOL]     p2 = merged.asParser(jp); [EOL]     p2.nextToken(); [EOL]     return _properties[index].getProperty().deserialize(p2, ctxt); [EOL] }
protected final Object _deserialize(JsonParser jp, DeserializationContext ctxt, int index, String typeId) throws IOException, JsonProcessingException { [EOL]     @SuppressWarnings("resource") [EOL]     TokenBuffer merged = new TokenBuffer(jp.getCodec()); [EOL]     merged.writeStartArray(); [EOL]     merged.writeString(typeId); [EOL]     JsonParser p2 = _tokens[index].asParser(jp); [EOL]     p2.nextToken(); [EOL]     merged.copyCurrentStructure(p2); [EOL]     merged.writeEndArray(); [EOL]     p2 = merged.asParser(jp); [EOL]     p2.nextToken(); [EOL]     return _properties[index].getProperty().deserialize(p2, ctxt); [EOL] }
protected final void _deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object bean, int index, String typeId) throws IOException, JsonProcessingException { [EOL]     @SuppressWarnings("resource") [EOL]     TokenBuffer merged = new TokenBuffer(jp.getCodec()); [EOL]     merged.writeStartArray(); [EOL]     merged.writeString(typeId); [EOL]     JsonParser p2 = _tokens[index].asParser(jp); [EOL]     p2.nextToken(); [EOL]     merged.copyCurrentStructure(p2); [EOL]     merged.writeEndArray(); [EOL]     p2 = merged.asParser(jp); [EOL]     p2.nextToken(); [EOL]     _properties[index].getProperty().deserializeAndSet(p2, ctxt, bean); [EOL] }
protected final void _deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object bean, int index, String typeId) throws IOException, JsonProcessingException { [EOL]     @SuppressWarnings("resource") [EOL]     TokenBuffer merged = new TokenBuffer(jp.getCodec()); [EOL]     merged.writeStartArray(); [EOL]     merged.writeString(typeId); [EOL]     JsonParser p2 = _tokens[index].asParser(jp); [EOL]     p2.nextToken(); [EOL]     merged.copyCurrentStructure(p2); [EOL]     merged.writeEndArray(); [EOL]     p2 = merged.asParser(jp); [EOL]     p2.nextToken(); [EOL]     _properties[index].getProperty().deserializeAndSet(p2, ctxt, bean); [EOL] }
public void addExternal(SettableBeanProperty property, TypeDeserializer typeDeser) { [EOL]     Integer index = _properties.size(); [EOL]     _properties.add(new ExtTypedProperty(property, typeDeser)); [EOL]     _nameToPropertyIndex.put(property.getName(), index); [EOL]     _nameToPropertyIndex.put(typeDeser.getPropertyName(), index); [EOL] }
public void addExternal(SettableBeanProperty property, TypeDeserializer typeDeser) { [EOL]     Integer index = _properties.size(); [EOL]     _properties.add(new ExtTypedProperty(property, typeDeser)); [EOL]     _nameToPropertyIndex.put(property.getName(), index); [EOL]     _nameToPropertyIndex.put(typeDeser.getPropertyName(), index); [EOL] }
public ExternalTypeHandler build() { [EOL]     return new ExternalTypeHandler(_properties.toArray(new ExtTypedProperty[_properties.size()]), _nameToPropertyIndex, null, null); [EOL] }
public ExternalTypeHandler build() { [EOL]     return new ExternalTypeHandler(_properties.toArray(new ExtTypedProperty[_properties.size()]), _nameToPropertyIndex, null, null); [EOL] }
public ExtTypedProperty(SettableBeanProperty property, TypeDeserializer typeDeser) { [EOL]     _property = property; [EOL]     _typeDeserializer = typeDeser; [EOL]     _typePropertyName = typeDeser.getPropertyName(); [EOL] }
public ExtTypedProperty(SettableBeanProperty property, TypeDeserializer typeDeser) { [EOL]     _property = property; [EOL]     _typeDeserializer = typeDeser; [EOL]     _typePropertyName = typeDeser.getPropertyName(); [EOL] }
public boolean hasTypePropertyName(String n) { [EOL]     return n.equals(_typePropertyName); [EOL] }
public boolean hasTypePropertyName(String n) { [EOL]     return n.equals(_typePropertyName); [EOL] }
public SettableBeanProperty getProperty() { [EOL]     return _property; [EOL] }
public final Locale getLocale() { [EOL]     return _base.getLocale(); [EOL] }
public TypeResolverBuilder<?> typeResolverBuilderInstance(Annotated annotated, Class<? extends TypeResolverBuilder<?>> builderClass) { [EOL]     HandlerInstantiator hi = getHandlerInstantiator(); [EOL]     if (hi != null) { [EOL]         TypeResolverBuilder<?> builder = hi.typeResolverBuilderInstance(this, annotated, builderClass); [EOL]         if (builder != null) { [EOL]             return builder; [EOL]         } [EOL]     } [EOL]     return (TypeResolverBuilder<?>) ClassUtil.createInstance(builderClass, canOverrideAccessModifiers()); [EOL] }
public TypeResolverBuilder<?> typeResolverBuilderInstance(Annotated annotated, Class<? extends TypeResolverBuilder<?>> builderClass) { [EOL]     HandlerInstantiator hi = getHandlerInstantiator(); [EOL]     if (hi != null) { [EOL]         TypeResolverBuilder<?> builder = hi.typeResolverBuilderInstance(this, annotated, builderClass); [EOL]         if (builder != null) { [EOL]             return builder; [EOL]         } [EOL]     } [EOL]     return (TypeResolverBuilder<?>) ClassUtil.createInstance(builderClass, canOverrideAccessModifiers()); [EOL] }
public TypeResolverBuilder<?> typeResolverBuilderInstance(Annotated annotated, Class<? extends TypeResolverBuilder<?>> builderClass) { [EOL]     HandlerInstantiator hi = getHandlerInstantiator(); [EOL]     if (hi != null) { [EOL]         TypeResolverBuilder<?> builder = hi.typeResolverBuilderInstance(this, annotated, builderClass); [EOL]         if (builder != null) { [EOL]             return builder; [EOL]         } [EOL]     } [EOL]     return (TypeResolverBuilder<?>) ClassUtil.createInstance(builderClass, canOverrideAccessModifiers()); [EOL] }
public NullProvider(JavaType type, Object nullValue) { [EOL]     _nullValue = nullValue; [EOL]     _isPrimitive = type.isPrimitive(); [EOL]     _rawType = type.getRawClass(); [EOL] }
public NullProvider(JavaType type, Object nullValue) { [EOL]     _nullValue = nullValue; [EOL]     _isPrimitive = type.isPrimitive(); [EOL]     _rawType = type.getRawClass(); [EOL] }
protected ValueNode() { [EOL] }
@Override [EOL] public final List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar) { [EOL]     return foundSoFar; [EOL] }
@Override [EOL] public final List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar) { [EOL]     return foundSoFar; [EOL] }
@Override [EOL] public final List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar) { [EOL]     return foundSoFar; [EOL] }
@Override [EOL] public final List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar) { [EOL]     return foundSoFar; [EOL] }
@Override [EOL] public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeSerializer(idRes, null); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeSerializer(idRes, null, _typeProperty); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeSerializer(idRes, null); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeSerializer(idRes, null, _typeProperty); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeSerializer(idRes, null); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeSerializer(idRes, null, _typeProperty); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeSerializer(idRes, null); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeSerializer(idRes, null, _typeProperty); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeSerializer(idRes, null); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeSerializer(idRes, null, _typeProperty); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeSerializer(idRes, null); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeSerializer(idRes, null, _typeProperty); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeSerializer(idRes, null); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeSerializer(idRes, null, _typeProperty); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeSerializer(idRes, null); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeSerializer(idRes, null, _typeProperty); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeSerializer(idRes, null); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeSerializer(idRes, null, _typeProperty); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeSerializer(idRes, null); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeSerializer(idRes, null, _typeProperty); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeSerializer buildTypeSerializer(SerializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeSerializer(idRes, null); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeSerializer(idRes, null, _typeProperty); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeSerializer(idRes, null); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeSerializer(idRes, null, _typeProperty); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
@Override [EOL] public TypeDeserializer buildTypeDeserializer(DeserializationConfig config, JavaType baseType, Collection<NamedType> subtypes) { [EOL]     if (_idType == JsonTypeInfo.Id.NONE) { [EOL]         return null; [EOL]     } [EOL]     TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true); [EOL]     switch(_includeAs) { [EOL]         case WRAPPER_ARRAY: [EOL]             return new AsArrayTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case PROPERTY: [EOL]             return new AsPropertyTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case WRAPPER_OBJECT: [EOL]             return new AsWrapperTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]         case EXTERNAL_PROPERTY: [EOL]             return new AsExternalTypeDeserializer(baseType, idRes, _typeProperty, _typeIdVisible, _defaultImpl); [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type serializer for inclusion type: " + _includeAs); [EOL] }
protected TypeIdResolver idResolver(MapperConfig<?> config, JavaType baseType, Collection<NamedType> subtypes, boolean forSer, boolean forDeser) { [EOL]     if (_customIdResolver != null) { [EOL]         return _customIdResolver; [EOL]     } [EOL]     if (_idType == null) { [EOL]         throw new IllegalStateException("Can not build, 'init()' not yet called"); [EOL]     } [EOL]     switch(_idType) { [EOL]         case CLASS: [EOL]             return new ClassNameIdResolver(baseType, config.getTypeFactory()); [EOL]         case MINIMAL_CLASS: [EOL]             return new MinimalClassNameIdResolver(baseType, config.getTypeFactory()); [EOL]         case NAME: [EOL]             return TypeNameIdResolver.construct(config, baseType, subtypes, forSer, forDeser); [EOL]         case NONE: [EOL]             return null; [EOL]         case CUSTOM: [EOL]     } [EOL]     throw new IllegalStateException("Do not know how to construct standard type id resolver for idType: " + _idType); [EOL] }
@Override [EOL] public void registerSubtypes(NamedType... types) { [EOL]     if (_registeredSubtypes == null) { [EOL]         _registeredSubtypes = new LinkedHashSet<NamedType>(); [EOL]     } [EOL]     for (NamedType type : types) { [EOL]         _registeredSubtypes.add(type); [EOL]     } [EOL] }
@Override [EOL] public void registerSubtypes(NamedType... types) { [EOL]     if (_registeredSubtypes == null) { [EOL]         _registeredSubtypes = new LinkedHashSet<NamedType>(); [EOL]     } [EOL]     for (NamedType type : types) { [EOL]         _registeredSubtypes.add(type); [EOL]     } [EOL] }
@Override [EOL] public void registerSubtypes(NamedType... types) { [EOL]     if (_registeredSubtypes == null) { [EOL]         _registeredSubtypes = new LinkedHashSet<NamedType>(); [EOL]     } [EOL]     for (NamedType type : types) { [EOL]         _registeredSubtypes.add(type); [EOL]     } [EOL] }
@Override [EOL] public void registerSubtypes(Class<?>... classes) { [EOL]     NamedType[] types = new NamedType[classes.length]; [EOL]     for (int i = 0, len = classes.length; i < len; ++i) { [EOL]         types[i] = new NamedType(classes[i]); [EOL]     } [EOL]     registerSubtypes(types); [EOL] }
@Override [EOL] public void registerSubtypes(Class<?>... classes) { [EOL]     NamedType[] types = new NamedType[classes.length]; [EOL]     for (int i = 0, len = classes.length; i < len; ++i) { [EOL]         types[i] = new NamedType(classes[i]); [EOL]     } [EOL]     registerSubtypes(types); [EOL] }
@Override [EOL] public void registerSubtypes(Class<?>... classes) { [EOL]     NamedType[] types = new NamedType[classes.length]; [EOL]     for (int i = 0, len = classes.length; i < len; ++i) { [EOL]         types[i] = new NamedType(classes[i]); [EOL]     } [EOL]     registerSubtypes(types); [EOL] }
@Override [EOL] public Collection<NamedType> collectAndResolveSubtypes(AnnotatedMember property, MapperConfig<?> config, AnnotationIntrospector ai, JavaType baseType) { [EOL]     Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass(); [EOL]     HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>(); [EOL]     if (_registeredSubtypes != null) { [EOL]         for (NamedType subtype : _registeredSubtypes) { [EOL]             if (rawBase.isAssignableFrom(subtype.getType())) { [EOL]                 AnnotatedClass curr = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config); [EOL]                 _collectAndResolve(curr, subtype, config, ai, collected); [EOL]             } [EOL]         } [EOL]     } [EOL]     Collection<NamedType> st = ai.findSubtypes(property); [EOL]     if (st != null) { [EOL]         for (NamedType nt : st) { [EOL]             AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(nt.getType(), ai, config); [EOL]             _collectAndResolve(ac, nt, config, ai, collected); [EOL]         } [EOL]     } [EOL]     NamedType rootType = new NamedType(rawBase, null); [EOL]     AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(rawBase, ai, config); [EOL]     _collectAndResolve(ac, rootType, config, ai, collected); [EOL]     return new ArrayList<NamedType>(collected.values()); [EOL] }
@Override [EOL] public Collection<NamedType> collectAndResolveSubtypes(AnnotatedMember property, MapperConfig<?> config, AnnotationIntrospector ai, JavaType baseType) { [EOL]     Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass(); [EOL]     HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>(); [EOL]     if (_registeredSubtypes != null) { [EOL]         for (NamedType subtype : _registeredSubtypes) { [EOL]             if (rawBase.isAssignableFrom(subtype.getType())) { [EOL]                 AnnotatedClass curr = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config); [EOL]                 _collectAndResolve(curr, subtype, config, ai, collected); [EOL]             } [EOL]         } [EOL]     } [EOL]     Collection<NamedType> st = ai.findSubtypes(property); [EOL]     if (st != null) { [EOL]         for (NamedType nt : st) { [EOL]             AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(nt.getType(), ai, config); [EOL]             _collectAndResolve(ac, nt, config, ai, collected); [EOL]         } [EOL]     } [EOL]     NamedType rootType = new NamedType(rawBase, null); [EOL]     AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(rawBase, ai, config); [EOL]     _collectAndResolve(ac, rootType, config, ai, collected); [EOL]     return new ArrayList<NamedType>(collected.values()); [EOL] }
@Override [EOL] public Collection<NamedType> collectAndResolveSubtypes(AnnotatedMember property, MapperConfig<?> config, AnnotationIntrospector ai, JavaType baseType) { [EOL]     Class<?> rawBase = (baseType == null) ? property.getRawType() : baseType.getRawClass(); [EOL]     HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>(); [EOL]     if (_registeredSubtypes != null) { [EOL]         for (NamedType subtype : _registeredSubtypes) { [EOL]             if (rawBase.isAssignableFrom(subtype.getType())) { [EOL]                 AnnotatedClass curr = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config); [EOL]                 _collectAndResolve(curr, subtype, config, ai, collected); [EOL]             } [EOL]         } [EOL]     } [EOL]     Collection<NamedType> st = ai.findSubtypes(property); [EOL]     if (st != null) { [EOL]         for (NamedType nt : st) { [EOL]             AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(nt.getType(), ai, config); [EOL]             _collectAndResolve(ac, nt, config, ai, collected); [EOL]         } [EOL]     } [EOL]     NamedType rootType = new NamedType(rawBase, null); [EOL]     AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(rawBase, ai, config); [EOL]     _collectAndResolve(ac, rootType, config, ai, collected); [EOL]     return new ArrayList<NamedType>(collected.values()); [EOL] }
protected void _collectAndResolve(AnnotatedClass annotatedType, NamedType namedType, MapperConfig<?> config, AnnotationIntrospector ai, HashMap<NamedType, NamedType> collectedSubtypes) { [EOL]     if (!namedType.hasName()) { [EOL]         String name = ai.findTypeName(annotatedType); [EOL]         if (name != null) { [EOL]             namedType = new NamedType(namedType.getType(), name); [EOL]         } [EOL]     } [EOL]     if (collectedSubtypes.containsKey(namedType)) { [EOL]         if (namedType.hasName()) { [EOL]             NamedType prev = collectedSubtypes.get(namedType); [EOL]             if (!prev.hasName()) { [EOL]                 collectedSubtypes.put(namedType, namedType); [EOL]             } [EOL]         } [EOL]         return; [EOL]     } [EOL]     collectedSubtypes.put(namedType, namedType); [EOL]     Collection<NamedType> st = ai.findSubtypes(annotatedType); [EOL]     if (st != null && !st.isEmpty()) { [EOL]         for (NamedType subtype : st) { [EOL]             AnnotatedClass subtypeClass = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config); [EOL]             if (!subtype.hasName()) { [EOL]                 subtype = new NamedType(subtype.getType(), ai.findTypeName(subtypeClass)); [EOL]             } [EOL]             _collectAndResolve(subtypeClass, subtype, config, ai, collectedSubtypes); [EOL]         } [EOL]     } [EOL] }
protected void _collectAndResolve(AnnotatedClass annotatedType, NamedType namedType, MapperConfig<?> config, AnnotationIntrospector ai, HashMap<NamedType, NamedType> collectedSubtypes) { [EOL]     if (!namedType.hasName()) { [EOL]         String name = ai.findTypeName(annotatedType); [EOL]         if (name != null) { [EOL]             namedType = new NamedType(namedType.getType(), name); [EOL]         } [EOL]     } [EOL]     if (collectedSubtypes.containsKey(namedType)) { [EOL]         if (namedType.hasName()) { [EOL]             NamedType prev = collectedSubtypes.get(namedType); [EOL]             if (!prev.hasName()) { [EOL]                 collectedSubtypes.put(namedType, namedType); [EOL]             } [EOL]         } [EOL]         return; [EOL]     } [EOL]     collectedSubtypes.put(namedType, namedType); [EOL]     Collection<NamedType> st = ai.findSubtypes(annotatedType); [EOL]     if (st != null && !st.isEmpty()) { [EOL]         for (NamedType subtype : st) { [EOL]             AnnotatedClass subtypeClass = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config); [EOL]             if (!subtype.hasName()) { [EOL]                 subtype = new NamedType(subtype.getType(), ai.findTypeName(subtypeClass)); [EOL]             } [EOL]             _collectAndResolve(subtypeClass, subtype, config, ai, collectedSubtypes); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value instanceof BigDecimal) { [EOL]         if (provider.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) { [EOL]             jgen.writeNumber(((BigDecimal) value).toPlainString()); [EOL]         } else { [EOL]             jgen.writeNumber((BigDecimal) value); [EOL]         } [EOL]     } else if (value instanceof BigInteger) { [EOL]         jgen.writeNumber((BigInteger) value); [EOL]     } else if (value instanceof Integer) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else if (value instanceof Long) { [EOL]         jgen.writeNumber(value.longValue()); [EOL]     } else if (value instanceof Double) { [EOL]         jgen.writeNumber(value.doubleValue()); [EOL]     } else if (value instanceof Float) { [EOL]         jgen.writeNumber(value.floatValue()); [EOL]     } else if ((value instanceof Byte) || (value instanceof Short)) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else { [EOL]         jgen.writeNumber(value.toString()); [EOL]     } [EOL] }
@Override [EOL] public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value instanceof BigDecimal) { [EOL]         if (provider.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) { [EOL]             jgen.writeNumber(((BigDecimal) value).toPlainString()); [EOL]         } else { [EOL]             jgen.writeNumber((BigDecimal) value); [EOL]         } [EOL]     } else if (value instanceof BigInteger) { [EOL]         jgen.writeNumber((BigInteger) value); [EOL]     } else if (value instanceof Integer) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else if (value instanceof Long) { [EOL]         jgen.writeNumber(value.longValue()); [EOL]     } else if (value instanceof Double) { [EOL]         jgen.writeNumber(value.doubleValue()); [EOL]     } else if (value instanceof Float) { [EOL]         jgen.writeNumber(value.floatValue()); [EOL]     } else if ((value instanceof Byte) || (value instanceof Short)) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else { [EOL]         jgen.writeNumber(value.toString()); [EOL]     } [EOL] }
@Override [EOL] public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value instanceof BigDecimal) { [EOL]         if (provider.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) { [EOL]             jgen.writeNumber(((BigDecimal) value).toPlainString()); [EOL]         } else { [EOL]             jgen.writeNumber((BigDecimal) value); [EOL]         } [EOL]     } else if (value instanceof BigInteger) { [EOL]         jgen.writeNumber((BigInteger) value); [EOL]     } else if (value instanceof Integer) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else if (value instanceof Long) { [EOL]         jgen.writeNumber(value.longValue()); [EOL]     } else if (value instanceof Double) { [EOL]         jgen.writeNumber(value.doubleValue()); [EOL]     } else if (value instanceof Float) { [EOL]         jgen.writeNumber(value.floatValue()); [EOL]     } else if ((value instanceof Byte) || (value instanceof Short)) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else { [EOL]         jgen.writeNumber(value.toString()); [EOL]     } [EOL] }
@Override [EOL] public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value instanceof BigDecimal) { [EOL]         if (provider.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) { [EOL]             jgen.writeNumber(((BigDecimal) value).toPlainString()); [EOL]         } else { [EOL]             jgen.writeNumber((BigDecimal) value); [EOL]         } [EOL]     } else if (value instanceof BigInteger) { [EOL]         jgen.writeNumber((BigInteger) value); [EOL]     } else if (value instanceof Integer) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else if (value instanceof Long) { [EOL]         jgen.writeNumber(value.longValue()); [EOL]     } else if (value instanceof Double) { [EOL]         jgen.writeNumber(value.doubleValue()); [EOL]     } else if (value instanceof Float) { [EOL]         jgen.writeNumber(value.floatValue()); [EOL]     } else if ((value instanceof Byte) || (value instanceof Short)) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else { [EOL]         jgen.writeNumber(value.toString()); [EOL]     } [EOL] }
@Override [EOL] public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value instanceof BigDecimal) { [EOL]         if (provider.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) { [EOL]             jgen.writeNumber(((BigDecimal) value).toPlainString()); [EOL]         } else { [EOL]             jgen.writeNumber((BigDecimal) value); [EOL]         } [EOL]     } else if (value instanceof BigInteger) { [EOL]         jgen.writeNumber((BigInteger) value); [EOL]     } else if (value instanceof Integer) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else if (value instanceof Long) { [EOL]         jgen.writeNumber(value.longValue()); [EOL]     } else if (value instanceof Double) { [EOL]         jgen.writeNumber(value.doubleValue()); [EOL]     } else if (value instanceof Float) { [EOL]         jgen.writeNumber(value.floatValue()); [EOL]     } else if ((value instanceof Byte) || (value instanceof Short)) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else { [EOL]         jgen.writeNumber(value.toString()); [EOL]     } [EOL] }
@Override [EOL] public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value instanceof BigDecimal) { [EOL]         if (provider.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) { [EOL]             jgen.writeNumber(((BigDecimal) value).toPlainString()); [EOL]         } else { [EOL]             jgen.writeNumber((BigDecimal) value); [EOL]         } [EOL]     } else if (value instanceof BigInteger) { [EOL]         jgen.writeNumber((BigInteger) value); [EOL]     } else if (value instanceof Integer) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else if (value instanceof Long) { [EOL]         jgen.writeNumber(value.longValue()); [EOL]     } else if (value instanceof Double) { [EOL]         jgen.writeNumber(value.doubleValue()); [EOL]     } else if (value instanceof Float) { [EOL]         jgen.writeNumber(value.floatValue()); [EOL]     } else if ((value instanceof Byte) || (value instanceof Short)) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else { [EOL]         jgen.writeNumber(value.toString()); [EOL]     } [EOL] }
@Override [EOL] public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value instanceof BigDecimal) { [EOL]         if (provider.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) { [EOL]             jgen.writeNumber(((BigDecimal) value).toPlainString()); [EOL]         } else { [EOL]             jgen.writeNumber((BigDecimal) value); [EOL]         } [EOL]     } else if (value instanceof BigInteger) { [EOL]         jgen.writeNumber((BigInteger) value); [EOL]     } else if (value instanceof Integer) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else if (value instanceof Long) { [EOL]         jgen.writeNumber(value.longValue()); [EOL]     } else if (value instanceof Double) { [EOL]         jgen.writeNumber(value.doubleValue()); [EOL]     } else if (value instanceof Float) { [EOL]         jgen.writeNumber(value.floatValue()); [EOL]     } else if ((value instanceof Byte) || (value instanceof Short)) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else { [EOL]         jgen.writeNumber(value.toString()); [EOL]     } [EOL] }
@Override [EOL] public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value instanceof BigDecimal) { [EOL]         if (provider.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) { [EOL]             jgen.writeNumber(((BigDecimal) value).toPlainString()); [EOL]         } else { [EOL]             jgen.writeNumber((BigDecimal) value); [EOL]         } [EOL]     } else if (value instanceof BigInteger) { [EOL]         jgen.writeNumber((BigInteger) value); [EOL]     } else if (value instanceof Integer) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else if (value instanceof Long) { [EOL]         jgen.writeNumber(value.longValue()); [EOL]     } else if (value instanceof Double) { [EOL]         jgen.writeNumber(value.doubleValue()); [EOL]     } else if (value instanceof Float) { [EOL]         jgen.writeNumber(value.floatValue()); [EOL]     } else if ((value instanceof Byte) || (value instanceof Short)) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else { [EOL]         jgen.writeNumber(value.toString()); [EOL]     } [EOL] }
@Override [EOL] public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value instanceof BigDecimal) { [EOL]         if (provider.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) { [EOL]             jgen.writeNumber(((BigDecimal) value).toPlainString()); [EOL]         } else { [EOL]             jgen.writeNumber((BigDecimal) value); [EOL]         } [EOL]     } else if (value instanceof BigInteger) { [EOL]         jgen.writeNumber((BigInteger) value); [EOL]     } else if (value instanceof Integer) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else if (value instanceof Long) { [EOL]         jgen.writeNumber(value.longValue()); [EOL]     } else if (value instanceof Double) { [EOL]         jgen.writeNumber(value.doubleValue()); [EOL]     } else if (value instanceof Float) { [EOL]         jgen.writeNumber(value.floatValue()); [EOL]     } else if ((value instanceof Byte) || (value instanceof Short)) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else { [EOL]         jgen.writeNumber(value.toString()); [EOL]     } [EOL] }
@Override [EOL] public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (value instanceof BigDecimal) { [EOL]         if (provider.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) { [EOL]             jgen.writeNumber(((BigDecimal) value).toPlainString()); [EOL]         } else { [EOL]             jgen.writeNumber((BigDecimal) value); [EOL]         } [EOL]     } else if (value instanceof BigInteger) { [EOL]         jgen.writeNumber((BigInteger) value); [EOL]     } else if (value instanceof Integer) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else if (value instanceof Long) { [EOL]         jgen.writeNumber(value.longValue()); [EOL]     } else if (value instanceof Double) { [EOL]         jgen.writeNumber(value.doubleValue()); [EOL]     } else if (value instanceof Float) { [EOL]         jgen.writeNumber(value.floatValue()); [EOL]     } else if ((value instanceof Byte) || (value instanceof Short)) { [EOL]         jgen.writeNumber(value.intValue()); [EOL]     } else { [EOL]         jgen.writeNumber(value.toString()); [EOL]     } [EOL] }
public UnwrappingBeanSerializer(BeanSerializerBase src, NameTransformer transformer) { [EOL]     super(src, transformer); [EOL]     _nameTransformer = transformer; [EOL] }
public UnwrappingBeanSerializer(BeanSerializerBase src, NameTransformer transformer) { [EOL]     super(src, transformer); [EOL]     _nameTransformer = transformer; [EOL] }
@Override [EOL] public boolean isUnwrappingSerializer() { [EOL]     return true; [EOL] }
@Override [EOL] public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_objectIdWriter != null) { [EOL]         _serializeWithObjectId(bean, jgen, provider, false); [EOL]         return; [EOL]     } [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL] }
@Override [EOL] public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_objectIdWriter != null) { [EOL]         _serializeWithObjectId(bean, jgen, provider, false); [EOL]         return; [EOL]     } [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL] }
@Override [EOL] public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_objectIdWriter != null) { [EOL]         _serializeWithObjectId(bean, jgen, provider, false); [EOL]         return; [EOL]     } [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] public StringArraySerializer(StringArraySerializer src, BeanProperty prop, JsonSerializer<?> ser) { [EOL]     super(src, prop); [EOL]     _elementSerializer = (JsonSerializer<Object>) ser; [EOL] }
@SuppressWarnings("unchecked") [EOL] public StringArraySerializer(StringArraySerializer src, BeanProperty prop, JsonSerializer<?> ser) { [EOL]     super(src, prop); [EOL]     _elementSerializer = (JsonSerializer<Object>) ser; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _elementSerializer) { [EOL]         return this; [EOL]     } [EOL]     return new StringArraySerializer(this, property, ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _elementSerializer) { [EOL]         return this; [EOL]     } [EOL]     return new StringArraySerializer(this, property, ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _elementSerializer) { [EOL]         return this; [EOL]     } [EOL]     return new StringArraySerializer(this, property, ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _elementSerializer) { [EOL]         return this; [EOL]     } [EOL]     return new StringArraySerializer(this, property, ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _elementSerializer) { [EOL]         return this; [EOL]     } [EOL]     return new StringArraySerializer(this, property, ser); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     if (property != null) { [EOL]         AnnotatedMember m = property.getMember(); [EOL]         if (m != null) { [EOL]             Object serDef = provider.getAnnotationIntrospector().findContentSerializer(m); [EOL]             if (serDef != null) { [EOL]                 ser = provider.serializerInstance(m, serDef); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = _elementSerializer; [EOL]     } [EOL]     ser = findConvertingContentSerializer(provider, property, ser); [EOL]     if (ser == null) { [EOL]         ser = provider.findValueSerializer(String.class, property); [EOL]     } else if (ser instanceof ContextualSerializer) { [EOL]         ser = ((ContextualSerializer) ser).createContextual(provider, property); [EOL]     } [EOL]     if (isDefaultSerializer(ser)) { [EOL]         ser = null; [EOL]     } [EOL]     if (ser == _elementSerializer) { [EOL]         return this; [EOL]     } [EOL]     return new StringArraySerializer(this, property, ser); [EOL] }
@Override [EOL] public void serializeContents(String[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsSlow(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         String str = value[i]; [EOL]         if (str == null) { [EOL]             jgen.writeNull(); [EOL]         } else { [EOL]             jgen.writeString(value[i]); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(String[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsSlow(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         String str = value[i]; [EOL]         if (str == null) { [EOL]             jgen.writeNull(); [EOL]         } else { [EOL]             jgen.writeString(value[i]); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(String[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsSlow(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         String str = value[i]; [EOL]         if (str == null) { [EOL]             jgen.writeNull(); [EOL]         } else { [EOL]             jgen.writeString(value[i]); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(String[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final int len = value.length; [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     if (_elementSerializer != null) { [EOL]         serializeContentsSlow(value, jgen, provider, _elementSerializer); [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < len; ++i) { [EOL]         String str = value[i]; [EOL]         if (str == null) { [EOL]             jgen.writeNull(); [EOL]         } else { [EOL]             jgen.writeString(value[i]); [EOL]         } [EOL]     } [EOL] }
private void serializeContentsSlow(String[] value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     for (int i = 0, len = value.length; i < len; ++i) { [EOL]         String str = value[i]; [EOL]         if (str == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]         } else { [EOL]             ser.serialize(value[i], jgen, provider); [EOL]         } [EOL]     } [EOL] }
private void serializeContentsSlow(String[] value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     for (int i = 0, len = value.length; i < len; ++i) { [EOL]         String str = value[i]; [EOL]         if (str == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]         } else { [EOL]             ser.serialize(value[i], jgen, provider); [EOL]         } [EOL]     } [EOL] }
public TextNode(String v) { [EOL]     _value = v; [EOL] }
public TextNode(String v) { [EOL]     _value = v; [EOL] }
public TextNode(String v) { [EOL]     _value = v; [EOL] }
public static TextNode valueOf(String v) { [EOL]     if (v == null) { [EOL]         return null; [EOL]     } [EOL]     if (v.length() == 0) { [EOL]         return EMPTY_STRING_NODE; [EOL]     } [EOL]     return new TextNode(v); [EOL] }
@Override [EOL] public JsonNodeType getNodeType() { [EOL]     return JsonNodeType.STRING; [EOL] }
@Override [EOL] public String textValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public String textValue() { [EOL]     return _value; [EOL] }
public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { [EOL]     @SuppressWarnings("resource") [EOL]     ByteArrayBuilder builder = new ByteArrayBuilder(100); [EOL]     final String str = _value; [EOL]     int ptr = 0; [EOL]     int len = str.length(); [EOL]     main_loop: while (ptr < len) { [EOL]         char ch; [EOL]         do { [EOL]             ch = str.charAt(ptr++); [EOL]             if (ptr >= len) { [EOL]                 break main_loop; [EOL]             } [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             _reportInvalidBase64(b64variant, ch, 0); [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (ptr >= len) { [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             _reportInvalidBase64(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (ptr >= len) { [EOL]             if (!b64variant.usesPadding()) { [EOL]                 decodedData >>= 4; [EOL]                 builder.append(decodedData); [EOL]                 break; [EOL]             } [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 _reportInvalidBase64(b64variant, ch, 2); [EOL]             } [EOL]             if (ptr >= len) { [EOL]                 _reportBase64EOF(); [EOL]             } [EOL]             ch = str.charAt(ptr++); [EOL]             if (!b64variant.usesPaddingChar(ch)) { [EOL]                 _reportInvalidBase64(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL]             } [EOL]             decodedData >>= 4; [EOL]             builder.append(decodedData); [EOL]             continue; [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (ptr >= len) { [EOL]             if (!b64variant.usesPadding()) { [EOL]                 decodedData >>= 2; [EOL]                 builder.appendTwoBytes(decodedData); [EOL]                 break; [EOL]             } [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 _reportInvalidBase64(b64variant, ch, 3); [EOL]             } [EOL]             decodedData >>= 2; [EOL]             builder.appendTwoBytes(decodedData); [EOL]         } else { [EOL]             decodedData = (decodedData << 6) | bits; [EOL]             builder.appendThreeBytes(decodedData); [EOL]         } [EOL]     } [EOL]     return builder.toByteArray(); [EOL] }
public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { [EOL]     @SuppressWarnings("resource") [EOL]     ByteArrayBuilder builder = new ByteArrayBuilder(100); [EOL]     final String str = _value; [EOL]     int ptr = 0; [EOL]     int len = str.length(); [EOL]     main_loop: while (ptr < len) { [EOL]         char ch; [EOL]         do { [EOL]             ch = str.charAt(ptr++); [EOL]             if (ptr >= len) { [EOL]                 break main_loop; [EOL]             } [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             _reportInvalidBase64(b64variant, ch, 0); [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (ptr >= len) { [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             _reportInvalidBase64(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (ptr >= len) { [EOL]             if (!b64variant.usesPadding()) { [EOL]                 decodedData >>= 4; [EOL]                 builder.append(decodedData); [EOL]                 break; [EOL]             } [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 _reportInvalidBase64(b64variant, ch, 2); [EOL]             } [EOL]             if (ptr >= len) { [EOL]                 _reportBase64EOF(); [EOL]             } [EOL]             ch = str.charAt(ptr++); [EOL]             if (!b64variant.usesPaddingChar(ch)) { [EOL]                 _reportInvalidBase64(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL]             } [EOL]             decodedData >>= 4; [EOL]             builder.append(decodedData); [EOL]             continue; [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (ptr >= len) { [EOL]             if (!b64variant.usesPadding()) { [EOL]                 decodedData >>= 2; [EOL]                 builder.appendTwoBytes(decodedData); [EOL]                 break; [EOL]             } [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 _reportInvalidBase64(b64variant, ch, 3); [EOL]             } [EOL]             decodedData >>= 2; [EOL]             builder.appendTwoBytes(decodedData); [EOL]         } else { [EOL]             decodedData = (decodedData << 6) | bits; [EOL]             builder.appendThreeBytes(decodedData); [EOL]         } [EOL]     } [EOL]     return builder.toByteArray(); [EOL] }
public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { [EOL]     @SuppressWarnings("resource") [EOL]     ByteArrayBuilder builder = new ByteArrayBuilder(100); [EOL]     final String str = _value; [EOL]     int ptr = 0; [EOL]     int len = str.length(); [EOL]     main_loop: while (ptr < len) { [EOL]         char ch; [EOL]         do { [EOL]             ch = str.charAt(ptr++); [EOL]             if (ptr >= len) { [EOL]                 break main_loop; [EOL]             } [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             _reportInvalidBase64(b64variant, ch, 0); [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (ptr >= len) { [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             _reportInvalidBase64(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (ptr >= len) { [EOL]             if (!b64variant.usesPadding()) { [EOL]                 decodedData >>= 4; [EOL]                 builder.append(decodedData); [EOL]                 break; [EOL]             } [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 _reportInvalidBase64(b64variant, ch, 2); [EOL]             } [EOL]             if (ptr >= len) { [EOL]                 _reportBase64EOF(); [EOL]             } [EOL]             ch = str.charAt(ptr++); [EOL]             if (!b64variant.usesPaddingChar(ch)) { [EOL]                 _reportInvalidBase64(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL]             } [EOL]             decodedData >>= 4; [EOL]             builder.append(decodedData); [EOL]             continue; [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (ptr >= len) { [EOL]             if (!b64variant.usesPadding()) { [EOL]                 decodedData >>= 2; [EOL]                 builder.appendTwoBytes(decodedData); [EOL]                 break; [EOL]             } [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 _reportInvalidBase64(b64variant, ch, 3); [EOL]             } [EOL]             decodedData >>= 2; [EOL]             builder.appendTwoBytes(decodedData); [EOL]         } else { [EOL]             decodedData = (decodedData << 6) | bits; [EOL]             builder.appendThreeBytes(decodedData); [EOL]         } [EOL]     } [EOL]     return builder.toByteArray(); [EOL] }
public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { [EOL]     @SuppressWarnings("resource") [EOL]     ByteArrayBuilder builder = new ByteArrayBuilder(100); [EOL]     final String str = _value; [EOL]     int ptr = 0; [EOL]     int len = str.length(); [EOL]     main_loop: while (ptr < len) { [EOL]         char ch; [EOL]         do { [EOL]             ch = str.charAt(ptr++); [EOL]             if (ptr >= len) { [EOL]                 break main_loop; [EOL]             } [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             _reportInvalidBase64(b64variant, ch, 0); [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (ptr >= len) { [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             _reportInvalidBase64(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (ptr >= len) { [EOL]             if (!b64variant.usesPadding()) { [EOL]                 decodedData >>= 4; [EOL]                 builder.append(decodedData); [EOL]                 break; [EOL]             } [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 _reportInvalidBase64(b64variant, ch, 2); [EOL]             } [EOL]             if (ptr >= len) { [EOL]                 _reportBase64EOF(); [EOL]             } [EOL]             ch = str.charAt(ptr++); [EOL]             if (!b64variant.usesPaddingChar(ch)) { [EOL]                 _reportInvalidBase64(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL]             } [EOL]             decodedData >>= 4; [EOL]             builder.append(decodedData); [EOL]             continue; [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (ptr >= len) { [EOL]             if (!b64variant.usesPadding()) { [EOL]                 decodedData >>= 2; [EOL]                 builder.appendTwoBytes(decodedData); [EOL]                 break; [EOL]             } [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 _reportInvalidBase64(b64variant, ch, 3); [EOL]             } [EOL]             decodedData >>= 2; [EOL]             builder.appendTwoBytes(decodedData); [EOL]         } else { [EOL]             decodedData = (decodedData << 6) | bits; [EOL]             builder.appendThreeBytes(decodedData); [EOL]         } [EOL]     } [EOL]     return builder.toByteArray(); [EOL] }
public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { [EOL]     @SuppressWarnings("resource") [EOL]     ByteArrayBuilder builder = new ByteArrayBuilder(100); [EOL]     final String str = _value; [EOL]     int ptr = 0; [EOL]     int len = str.length(); [EOL]     main_loop: while (ptr < len) { [EOL]         char ch; [EOL]         do { [EOL]             ch = str.charAt(ptr++); [EOL]             if (ptr >= len) { [EOL]                 break main_loop; [EOL]             } [EOL]         } while (ch <= INT_SPACE); [EOL]         int bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             _reportInvalidBase64(b64variant, ch, 0); [EOL]         } [EOL]         int decodedData = bits; [EOL]         if (ptr >= len) { [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             _reportInvalidBase64(b64variant, ch, 1); [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (ptr >= len) { [EOL]             if (!b64variant.usesPadding()) { [EOL]                 decodedData >>= 4; [EOL]                 builder.append(decodedData); [EOL]                 break; [EOL]             } [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 _reportInvalidBase64(b64variant, ch, 2); [EOL]             } [EOL]             if (ptr >= len) { [EOL]                 _reportBase64EOF(); [EOL]             } [EOL]             ch = str.charAt(ptr++); [EOL]             if (!b64variant.usesPaddingChar(ch)) { [EOL]                 _reportInvalidBase64(b64variant, ch, 3, "expected padding character '" + b64variant.getPaddingChar() + "'"); [EOL]             } [EOL]             decodedData >>= 4; [EOL]             builder.append(decodedData); [EOL]             continue; [EOL]         } [EOL]         decodedData = (decodedData << 6) | bits; [EOL]         if (ptr >= len) { [EOL]             if (!b64variant.usesPadding()) { [EOL]                 decodedData >>= 2; [EOL]                 builder.appendTwoBytes(decodedData); [EOL]                 break; [EOL]             } [EOL]             _reportBase64EOF(); [EOL]         } [EOL]         ch = str.charAt(ptr++); [EOL]         bits = b64variant.decodeBase64Char(ch); [EOL]         if (bits < 0) { [EOL]             if (bits != Base64Variant.BASE64_VALUE_PADDING) { [EOL]                 _reportInvalidBase64(b64variant, ch, 3); [EOL]             } [EOL]             decodedData >>= 2; [EOL]             builder.appendTwoBytes(decodedData); [EOL]         } else { [EOL]             decodedData = (decodedData << 6) | bits; [EOL]             builder.appendThreeBytes(decodedData); [EOL]         } [EOL]     } [EOL]     return builder.toByteArray(); [EOL] }
@Override [EOL] public String asText() { [EOL]     return _value; [EOL] }
@Override [EOL] public String asText() { [EOL]     return _value; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return ((TextNode) o)._value.equals(_value); [EOL] }
@Override [EOL] public Class<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING) { [EOL]         String className = jp.getText().trim(); [EOL]         try { [EOL]             return ctxt.findClass(className); [EOL]         } catch (Exception e) { [EOL]             throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e)); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, curr); [EOL] }
@Override [EOL] public Class<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING) { [EOL]         String className = jp.getText().trim(); [EOL]         try { [EOL]             return ctxt.findClass(className); [EOL]         } catch (Exception e) { [EOL]             throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e)); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, curr); [EOL] }
@Override [EOL] public Class<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING) { [EOL]         String className = jp.getText().trim(); [EOL]         try { [EOL]             return ctxt.findClass(className); [EOL]         } catch (Exception e) { [EOL]             throw ctxt.instantiationException(_valueClass, ClassUtil.getRootCause(e)); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, curr); [EOL] }
protected PrimitiveArrayBuilder() { [EOL] }
public T resetAndStart() { [EOL]     _reset(); [EOL]     return (_freeBuffer == null) ? _constructArray(INITIAL_CHUNK_SIZE) : _freeBuffer; [EOL] }
public T resetAndStart() { [EOL]     _reset(); [EOL]     return (_freeBuffer == null) ? _constructArray(INITIAL_CHUNK_SIZE) : _freeBuffer; [EOL] }
public T completeAndClearBuffer(T lastChunk, int lastChunkEntries) { [EOL]     int totalSize = lastChunkEntries + _bufferedEntryCount; [EOL]     T resultArray = _constructArray(totalSize); [EOL]     int ptr = 0; [EOL]     for (Node<T> n = _bufferHead; n != null; n = n.next()) { [EOL]         ptr = n.copyData(resultArray, ptr); [EOL]     } [EOL]     System.arraycopy(lastChunk, 0, resultArray, ptr, lastChunkEntries); [EOL]     ptr += lastChunkEntries; [EOL]     if (ptr != totalSize) { [EOL]         throw new IllegalStateException("Should have gotten " + totalSize + " entries, got " + ptr); [EOL]     } [EOL]     return resultArray; [EOL] }
public T completeAndClearBuffer(T lastChunk, int lastChunkEntries) { [EOL]     int totalSize = lastChunkEntries + _bufferedEntryCount; [EOL]     T resultArray = _constructArray(totalSize); [EOL]     int ptr = 0; [EOL]     for (Node<T> n = _bufferHead; n != null; n = n.next()) { [EOL]         ptr = n.copyData(resultArray, ptr); [EOL]     } [EOL]     System.arraycopy(lastChunk, 0, resultArray, ptr, lastChunkEntries); [EOL]     ptr += lastChunkEntries; [EOL]     if (ptr != totalSize) { [EOL]         throw new IllegalStateException("Should have gotten " + totalSize + " entries, got " + ptr); [EOL]     } [EOL]     return resultArray; [EOL] }
public T completeAndClearBuffer(T lastChunk, int lastChunkEntries) { [EOL]     int totalSize = lastChunkEntries + _bufferedEntryCount; [EOL]     T resultArray = _constructArray(totalSize); [EOL]     int ptr = 0; [EOL]     for (Node<T> n = _bufferHead; n != null; n = n.next()) { [EOL]         ptr = n.copyData(resultArray, ptr); [EOL]     } [EOL]     System.arraycopy(lastChunk, 0, resultArray, ptr, lastChunkEntries); [EOL]     ptr += lastChunkEntries; [EOL]     if (ptr != totalSize) { [EOL]         throw new IllegalStateException("Should have gotten " + totalSize + " entries, got " + ptr); [EOL]     } [EOL]     return resultArray; [EOL] }
protected void _reset() { [EOL]     if (_bufferTail != null) { [EOL]         _freeBuffer = _bufferTail.getData(); [EOL]     } [EOL]     _bufferHead = _bufferTail = null; [EOL]     _bufferedEntryCount = 0; [EOL] }
protected void _reset() { [EOL]     if (_bufferTail != null) { [EOL]         _freeBuffer = _bufferTail.getData(); [EOL]     } [EOL]     _bufferHead = _bufferTail = null; [EOL]     _bufferedEntryCount = 0; [EOL] }
@Override [EOL] public int containedTypeCount() { [EOL]     return 2; [EOL] }
public SimpleModule() { [EOL]     _name = "SimpleModule-" + System.identityHashCode(this); [EOL]     _version = Version.unknownVersion(); [EOL] }
public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser) { [EOL]     if (_serializers == null) { [EOL]         _serializers = new SimpleSerializers(); [EOL]     } [EOL]     _serializers.addSerializer(type, ser); [EOL]     return this; [EOL] }
public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser) { [EOL]     if (_serializers == null) { [EOL]         _serializers = new SimpleSerializers(); [EOL]     } [EOL]     _serializers.addSerializer(type, ser); [EOL]     return this; [EOL] }
public <T> SimpleModule addDeserializer(Class<T> type, JsonDeserializer<? extends T> deser) { [EOL]     if (_deserializers == null) { [EOL]         _deserializers = new SimpleDeserializers(); [EOL]     } [EOL]     _deserializers.addDeserializer(type, deser); [EOL]     return this; [EOL] }
public <T> SimpleModule addDeserializer(Class<T> type, JsonDeserializer<? extends T> deser) { [EOL]     if (_deserializers == null) { [EOL]         _deserializers = new SimpleDeserializers(); [EOL]     } [EOL]     _deserializers.addDeserializer(type, deser); [EOL]     return this; [EOL] }
public SimpleModule registerSubtypes(Class<?>... subtypes) { [EOL]     if (_subtypes == null) { [EOL]         _subtypes = new LinkedHashSet<NamedType>(Math.max(16, subtypes.length)); [EOL]     } [EOL]     for (Class<?> subtype : subtypes) { [EOL]         _subtypes.add(new NamedType(subtype)); [EOL]     } [EOL]     return this; [EOL] }
public SimpleModule registerSubtypes(Class<?>... subtypes) { [EOL]     if (_subtypes == null) { [EOL]         _subtypes = new LinkedHashSet<NamedType>(Math.max(16, subtypes.length)); [EOL]     } [EOL]     for (Class<?> subtype : subtypes) { [EOL]         _subtypes.add(new NamedType(subtype)); [EOL]     } [EOL]     return this; [EOL] }
public SimpleModule registerSubtypes(Class<?>... subtypes) { [EOL]     if (_subtypes == null) { [EOL]         _subtypes = new LinkedHashSet<NamedType>(Math.max(16, subtypes.length)); [EOL]     } [EOL]     for (Class<?> subtype : subtypes) { [EOL]         _subtypes.add(new NamedType(subtype)); [EOL]     } [EOL]     return this; [EOL] }
public SimpleModule registerSubtypes(Class<?>... subtypes) { [EOL]     if (_subtypes == null) { [EOL]         _subtypes = new LinkedHashSet<NamedType>(Math.max(16, subtypes.length)); [EOL]     } [EOL]     for (Class<?> subtype : subtypes) { [EOL]         _subtypes.add(new NamedType(subtype)); [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public void setupModule(SetupContext context) { [EOL]     if (_serializers != null) { [EOL]         context.addSerializers(_serializers); [EOL]     } [EOL]     if (_deserializers != null) { [EOL]         context.addDeserializers(_deserializers); [EOL]     } [EOL]     if (_keySerializers != null) { [EOL]         context.addKeySerializers(_keySerializers); [EOL]     } [EOL]     if (_keyDeserializers != null) { [EOL]         context.addKeyDeserializers(_keyDeserializers); [EOL]     } [EOL]     if (_abstractTypes != null) { [EOL]         context.addAbstractTypeResolver(_abstractTypes); [EOL]     } [EOL]     if (_valueInstantiators != null) { [EOL]         context.addValueInstantiators(_valueInstantiators); [EOL]     } [EOL]     if (_deserializerModifier != null) { [EOL]         context.addBeanDeserializerModifier(_deserializerModifier); [EOL]     } [EOL]     if (_serializerModifier != null) { [EOL]         context.addBeanSerializerModifier(_serializerModifier); [EOL]     } [EOL]     if (_subtypes != null && _subtypes.size() > 0) { [EOL]         context.registerSubtypes(_subtypes.toArray(new NamedType[_subtypes.size()])); [EOL]     } [EOL]     if (_mixins != null) { [EOL]         for (Map.Entry<Class<?>, Class<?>> entry : _mixins.entrySet()) { [EOL]             context.setMixInAnnotations(entry.getKey(), entry.getValue()); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void setupModule(SetupContext context) { [EOL]     if (_serializers != null) { [EOL]         context.addSerializers(_serializers); [EOL]     } [EOL]     if (_deserializers != null) { [EOL]         context.addDeserializers(_deserializers); [EOL]     } [EOL]     if (_keySerializers != null) { [EOL]         context.addKeySerializers(_keySerializers); [EOL]     } [EOL]     if (_keyDeserializers != null) { [EOL]         context.addKeyDeserializers(_keyDeserializers); [EOL]     } [EOL]     if (_abstractTypes != null) { [EOL]         context.addAbstractTypeResolver(_abstractTypes); [EOL]     } [EOL]     if (_valueInstantiators != null) { [EOL]         context.addValueInstantiators(_valueInstantiators); [EOL]     } [EOL]     if (_deserializerModifier != null) { [EOL]         context.addBeanDeserializerModifier(_deserializerModifier); [EOL]     } [EOL]     if (_serializerModifier != null) { [EOL]         context.addBeanSerializerModifier(_serializerModifier); [EOL]     } [EOL]     if (_subtypes != null && _subtypes.size() > 0) { [EOL]         context.registerSubtypes(_subtypes.toArray(new NamedType[_subtypes.size()])); [EOL]     } [EOL]     if (_mixins != null) { [EOL]         for (Map.Entry<Class<?>, Class<?>> entry : _mixins.entrySet()) { [EOL]             context.setMixInAnnotations(entry.getKey(), entry.getValue()); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void setupModule(SetupContext context) { [EOL]     if (_serializers != null) { [EOL]         context.addSerializers(_serializers); [EOL]     } [EOL]     if (_deserializers != null) { [EOL]         context.addDeserializers(_deserializers); [EOL]     } [EOL]     if (_keySerializers != null) { [EOL]         context.addKeySerializers(_keySerializers); [EOL]     } [EOL]     if (_keyDeserializers != null) { [EOL]         context.addKeyDeserializers(_keyDeserializers); [EOL]     } [EOL]     if (_abstractTypes != null) { [EOL]         context.addAbstractTypeResolver(_abstractTypes); [EOL]     } [EOL]     if (_valueInstantiators != null) { [EOL]         context.addValueInstantiators(_valueInstantiators); [EOL]     } [EOL]     if (_deserializerModifier != null) { [EOL]         context.addBeanDeserializerModifier(_deserializerModifier); [EOL]     } [EOL]     if (_serializerModifier != null) { [EOL]         context.addBeanSerializerModifier(_serializerModifier); [EOL]     } [EOL]     if (_subtypes != null && _subtypes.size() > 0) { [EOL]         context.registerSubtypes(_subtypes.toArray(new NamedType[_subtypes.size()])); [EOL]     } [EOL]     if (_mixins != null) { [EOL]         for (Map.Entry<Class<?>, Class<?>> entry : _mixins.entrySet()) { [EOL]             context.setMixInAnnotations(entry.getKey(), entry.getValue()); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] protected JavaType _narrow(Class<?> subclass) { [EOL]     return new SimpleType(subclass, _typeNames, _typeParameters, _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] protected JavaType _narrow(Class<?> subclass) { [EOL]     return new SimpleType(subclass, _typeNames, _typeParameters, _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public SimpleType withTypeHandler(Object h) { [EOL]     return new SimpleType(_class, _typeNames, _typeParameters, _valueHandler, h, _asStatic); [EOL] }
@Override [EOL] public SimpleType withTypeHandler(Object h) { [EOL]     return new SimpleType(_class, _typeNames, _typeParameters, _valueHandler, h, _asStatic); [EOL] }
@Override [EOL] protected String buildCanonicalName() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append(_class.getName()); [EOL]     if (_typeParameters != null && _typeParameters.length > 0) { [EOL]         sb.append('<'); [EOL]         boolean first = true; [EOL]         for (JavaType t : _typeParameters) { [EOL]             if (first) { [EOL]                 first = false; [EOL]             } else { [EOL]                 sb.append(','); [EOL]             } [EOL]             sb.append(t.toCanonical()); [EOL]         } [EOL]         sb.append('>'); [EOL]     } [EOL]     return sb.toString(); [EOL] }
@Override [EOL] protected String buildCanonicalName() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append(_class.getName()); [EOL]     if (_typeParameters != null && _typeParameters.length > 0) { [EOL]         sb.append('<'); [EOL]         boolean first = true; [EOL]         for (JavaType t : _typeParameters) { [EOL]             if (first) { [EOL]                 first = false; [EOL]             } else { [EOL]                 sb.append(','); [EOL]             } [EOL]             sb.append(t.toCanonical()); [EOL]         } [EOL]         sb.append('>'); [EOL]     } [EOL]     return sb.toString(); [EOL] }
@Override [EOL] public String containedTypeName(int index) { [EOL]     if (index < 0 || _typeNames == null || index >= _typeNames.length) { [EOL]         return null; [EOL]     } [EOL]     return _typeNames[index]; [EOL] }
@Override [EOL] public String containedTypeName(int index) { [EOL]     if (index < 0 || _typeNames == null || index >= _typeNames.length) { [EOL]         return null; [EOL]     } [EOL]     return _typeNames[index]; [EOL] }
@Override [EOL] public String containedTypeName(int index) { [EOL]     if (index < 0 || _typeNames == null || index >= _typeNames.length) { [EOL]         return null; [EOL]     } [EOL]     return _typeNames[index]; [EOL] }
@Override [EOL] public String containedTypeName(int index) { [EOL]     if (index < 0 || _typeNames == null || index >= _typeNames.length) { [EOL]         return null; [EOL]     } [EOL]     return _typeNames[index]; [EOL] }
@Override [EOL] public String toString() { [EOL]     StringBuilder sb = new StringBuilder(40); [EOL]     sb.append("[simple type, class ").append(buildCanonicalName()).append(']'); [EOL]     return sb.toString(); [EOL] }
public static Class<?> rawClass(Type t) { [EOL]     if (t instanceof Class<?>) { [EOL]         return (Class<?>) t; [EOL]     } [EOL]     return defaultInstance().constructType(t).getRawClass(); [EOL] }
public static Class<?> rawClass(Type t) { [EOL]     if (t instanceof Class<?>) { [EOL]         return (Class<?>) t; [EOL]     } [EOL]     return defaultInstance().constructType(t).getRawClass(); [EOL] }
public JavaType moreSpecificType(JavaType type1, JavaType type2) { [EOL]     if (type1 == null) { [EOL]         return type2; [EOL]     } [EOL]     if (type2 == null) { [EOL]         return type1; [EOL]     } [EOL]     Class<?> raw1 = type1.getRawClass(); [EOL]     Class<?> raw2 = type2.getRawClass(); [EOL]     if (raw1 == raw2) { [EOL]         return type1; [EOL]     } [EOL]     if (raw1.isAssignableFrom(raw2)) { [EOL]         return type2; [EOL]     } [EOL]     return type1; [EOL] }
public JavaType moreSpecificType(JavaType type1, JavaType type2) { [EOL]     if (type1 == null) { [EOL]         return type2; [EOL]     } [EOL]     if (type2 == null) { [EOL]         return type1; [EOL]     } [EOL]     Class<?> raw1 = type1.getRawClass(); [EOL]     Class<?> raw2 = type2.getRawClass(); [EOL]     if (raw1 == raw2) { [EOL]         return type1; [EOL]     } [EOL]     if (raw1.isAssignableFrom(raw2)) { [EOL]         return type2; [EOL]     } [EOL]     return type1; [EOL] }
public JavaType moreSpecificType(JavaType type1, JavaType type2) { [EOL]     if (type1 == null) { [EOL]         return type2; [EOL]     } [EOL]     if (type2 == null) { [EOL]         return type1; [EOL]     } [EOL]     Class<?> raw1 = type1.getRawClass(); [EOL]     Class<?> raw2 = type2.getRawClass(); [EOL]     if (raw1 == raw2) { [EOL]         return type1; [EOL]     } [EOL]     if (raw1.isAssignableFrom(raw2)) { [EOL]         return type2; [EOL]     } [EOL]     return type1; [EOL] }
public JavaType moreSpecificType(JavaType type1, JavaType type2) { [EOL]     if (type1 == null) { [EOL]         return type2; [EOL]     } [EOL]     if (type2 == null) { [EOL]         return type1; [EOL]     } [EOL]     Class<?> raw1 = type1.getRawClass(); [EOL]     Class<?> raw2 = type2.getRawClass(); [EOL]     if (raw1 == raw2) { [EOL]         return type1; [EOL]     } [EOL]     if (raw1.isAssignableFrom(raw2)) { [EOL]         return type2; [EOL]     } [EOL]     return type1; [EOL] }
public JavaType moreSpecificType(JavaType type1, JavaType type2) { [EOL]     if (type1 == null) { [EOL]         return type2; [EOL]     } [EOL]     if (type2 == null) { [EOL]         return type1; [EOL]     } [EOL]     Class<?> raw1 = type1.getRawClass(); [EOL]     Class<?> raw2 = type2.getRawClass(); [EOL]     if (raw1 == raw2) { [EOL]         return type1; [EOL]     } [EOL]     if (raw1.isAssignableFrom(raw2)) { [EOL]         return type2; [EOL]     } [EOL]     return type1; [EOL] }
protected JavaType _fromParamType(ParameterizedType type, TypeBindings context) { [EOL]     Class<?> rawType = (Class<?>) type.getRawType(); [EOL]     Type[] args = type.getActualTypeArguments(); [EOL]     int paramCount = (args == null) ? 0 : args.length; [EOL]     JavaType[] pt; [EOL]     if (paramCount == 0) { [EOL]         pt = NO_TYPES; [EOL]     } else { [EOL]         pt = new JavaType[paramCount]; [EOL]         for (int i = 0; i < paramCount; ++i) { [EOL]             pt[i] = _constructType(args[i], context); [EOL]         } [EOL]     } [EOL]     if (Map.class.isAssignableFrom(rawType)) { [EOL]         JavaType subtype = constructSimpleType(rawType, pt); [EOL]         JavaType[] mapParams = findTypeParameters(subtype, Map.class); [EOL]         if (mapParams.length != 2) { [EOL]             throw new IllegalArgumentException("Could not find 2 type parameters for Map class " + rawType.getName() + " (found " + mapParams.length + ")"); [EOL]         } [EOL]         return MapType.construct(rawType, mapParams[0], mapParams[1]); [EOL]     } [EOL]     if (Collection.class.isAssignableFrom(rawType)) { [EOL]         JavaType subtype = constructSimpleType(rawType, pt); [EOL]         JavaType[] collectionParams = findTypeParameters(subtype, Collection.class); [EOL]         if (collectionParams.length != 1) { [EOL]             throw new IllegalArgumentException("Could not find 1 type parameter for Collection class " + rawType.getName() + " (found " + collectionParams.length + ")"); [EOL]         } [EOL]         return CollectionType.construct(rawType, collectionParams[0]); [EOL]     } [EOL]     if (paramCount == 0) { [EOL]         return new SimpleType(rawType); [EOL]     } [EOL]     return constructSimpleType(rawType, pt); [EOL] }
@Override [EOL] public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } else if (t == JsonToken.START_ARRAY) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } else if (t != JsonToken.FIELD_NAME) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } [EOL]     TokenBuffer tb = null; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String name = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         if (_typePropertyName.equals(name)) { [EOL]             return _deserializeTypedForId(jp, ctxt, tb); [EOL]         } [EOL]         if (tb == null) { [EOL]             tb = new TokenBuffer(null); [EOL]         } [EOL]         tb.writeFieldName(name); [EOL]         tb.copyCurrentStructure(jp); [EOL]     } [EOL]     return _deserializeTypedUsingDefaultImpl(jp, ctxt, tb); [EOL] }
@Override [EOL] public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } else if (t == JsonToken.START_ARRAY) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } else if (t != JsonToken.FIELD_NAME) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } [EOL]     TokenBuffer tb = null; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String name = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         if (_typePropertyName.equals(name)) { [EOL]             return _deserializeTypedForId(jp, ctxt, tb); [EOL]         } [EOL]         if (tb == null) { [EOL]             tb = new TokenBuffer(null); [EOL]         } [EOL]         tb.writeFieldName(name); [EOL]         tb.copyCurrentStructure(jp); [EOL]     } [EOL]     return _deserializeTypedUsingDefaultImpl(jp, ctxt, tb); [EOL] }
@Override [EOL] public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } else if (t == JsonToken.START_ARRAY) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } else if (t != JsonToken.FIELD_NAME) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } [EOL]     TokenBuffer tb = null; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String name = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         if (_typePropertyName.equals(name)) { [EOL]             return _deserializeTypedForId(jp, ctxt, tb); [EOL]         } [EOL]         if (tb == null) { [EOL]             tb = new TokenBuffer(null); [EOL]         } [EOL]         tb.writeFieldName(name); [EOL]         tb.copyCurrentStructure(jp); [EOL]     } [EOL]     return _deserializeTypedUsingDefaultImpl(jp, ctxt, tb); [EOL] }
@Override [EOL] public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } else if (t == JsonToken.START_ARRAY) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } else if (t != JsonToken.FIELD_NAME) { [EOL]         return _deserializeTypedUsingDefaultImpl(jp, ctxt, null); [EOL]     } [EOL]     TokenBuffer tb = null; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String name = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         if (_typePropertyName.equals(name)) { [EOL]             return _deserializeTypedForId(jp, ctxt, tb); [EOL]         } [EOL]         if (tb == null) { [EOL]             tb = new TokenBuffer(null); [EOL]         } [EOL]         tb.writeFieldName(name); [EOL]         tb.copyCurrentStructure(jp); [EOL]     } [EOL]     return _deserializeTypedUsingDefaultImpl(jp, ctxt, tb); [EOL] }
@SuppressWarnings("resource") [EOL] protected final Object _deserializeTypedForId(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException, JsonProcessingException { [EOL]     String typeId = jp.getText(); [EOL]     JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId); [EOL]     if (_typeIdVisible) { [EOL]         if (tb == null) { [EOL]             tb = new TokenBuffer(null); [EOL]         } [EOL]         tb.writeFieldName(jp.getCurrentName()); [EOL]         tb.writeString(typeId); [EOL]     } [EOL]     if (tb != null) { [EOL]         jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp); [EOL]     } [EOL]     jp.nextToken(); [EOL]     return deser.deserialize(jp, ctxt); [EOL] }
@SuppressWarnings("resource") [EOL] protected final Object _deserializeTypedForId(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException, JsonProcessingException { [EOL]     String typeId = jp.getText(); [EOL]     JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId); [EOL]     if (_typeIdVisible) { [EOL]         if (tb == null) { [EOL]             tb = new TokenBuffer(null); [EOL]         } [EOL]         tb.writeFieldName(jp.getCurrentName()); [EOL]         tb.writeString(typeId); [EOL]     } [EOL]     if (tb != null) { [EOL]         jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp); [EOL]     } [EOL]     jp.nextToken(); [EOL]     return deser.deserialize(jp, ctxt); [EOL] }
@SuppressWarnings("resource") [EOL] protected final Object _deserializeTypedForId(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException, JsonProcessingException { [EOL]     String typeId = jp.getText(); [EOL]     JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId); [EOL]     if (_typeIdVisible) { [EOL]         if (tb == null) { [EOL]             tb = new TokenBuffer(null); [EOL]         } [EOL]         tb.writeFieldName(jp.getCurrentName()); [EOL]         tb.writeString(typeId); [EOL]     } [EOL]     if (tb != null) { [EOL]         jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp); [EOL]     } [EOL]     jp.nextToken(); [EOL]     return deser.deserialize(jp, ctxt); [EOL] }
protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException, JsonProcessingException { [EOL]     JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt); [EOL]     if (deser != null) { [EOL]         if (tb != null) { [EOL]             tb.writeEndObject(); [EOL]             jp = tb.asParser(jp); [EOL]             jp.nextToken(); [EOL]         } [EOL]         return deser.deserialize(jp, ctxt); [EOL]     } [EOL]     Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.START_ARRAY) { [EOL]         return super.deserializeTypedFromAny(jp, ctxt); [EOL]     } [EOL]     throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME, "missing property '" + _typePropertyName + "' that is to contain type id  (for class " + baseTypeName() + ")"); [EOL] }
protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException, JsonProcessingException { [EOL]     JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt); [EOL]     if (deser != null) { [EOL]         if (tb != null) { [EOL]             tb.writeEndObject(); [EOL]             jp = tb.asParser(jp); [EOL]             jp.nextToken(); [EOL]         } [EOL]         return deser.deserialize(jp, ctxt); [EOL]     } [EOL]     Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.START_ARRAY) { [EOL]         return super.deserializeTypedFromAny(jp, ctxt); [EOL]     } [EOL]     throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME, "missing property '" + _typePropertyName + "' that is to contain type id  (for class " + baseTypeName() + ")"); [EOL] }
protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException, JsonProcessingException { [EOL]     JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt); [EOL]     if (deser != null) { [EOL]         if (tb != null) { [EOL]             tb.writeEndObject(); [EOL]             jp = tb.asParser(jp); [EOL]             jp.nextToken(); [EOL]         } [EOL]         return deser.deserialize(jp, ctxt); [EOL]     } [EOL]     Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.START_ARRAY) { [EOL]         return super.deserializeTypedFromAny(jp, ctxt); [EOL]     } [EOL]     throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME, "missing property '" + _typePropertyName + "' that is to contain type id  (for class " + baseTypeName() + ")"); [EOL] }
protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp, DeserializationContext ctxt, TokenBuffer tb) throws IOException, JsonProcessingException { [EOL]     JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt); [EOL]     if (deser != null) { [EOL]         if (tb != null) { [EOL]             tb.writeEndObject(); [EOL]             jp = tb.asParser(jp); [EOL]             jp.nextToken(); [EOL]         } [EOL]         return deser.deserialize(jp, ctxt); [EOL]     } [EOL]     Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType); [EOL]     if (result != null) { [EOL]         return result; [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.START_ARRAY) { [EOL]         return super.deserializeTypedFromAny(jp, ctxt); [EOL]     } [EOL]     throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME, "missing property '" + _typePropertyName + "' that is to contain type id  (for class " + baseTypeName() + ")"); [EOL] }
@Override [EOL] public final SubtypeResolver getSubtypeResolver() { [EOL]     return _subtypeResolver; [EOL] }
@Override [EOL] public void close() throws IOException { [EOL]     _closed = true; [EOL] }
@Override [EOL] public void writeString(String text) throws IOException, JsonGenerationException { [EOL]     if (text == null) { [EOL]         writeNull(); [EOL]     } else { [EOL]         _append(JsonToken.VALUE_STRING, text); [EOL]     } [EOL] }
@Override [EOL] public void writeString(String text) throws IOException, JsonGenerationException { [EOL]     if (text == null) { [EOL]         writeNull(); [EOL]     } else { [EOL]         _append(JsonToken.VALUE_STRING, text); [EOL]     } [EOL] }
@Override [EOL] public void writeNumber(long l) throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.VALUE_NUMBER_INT, Long.valueOf(l)); [EOL] }
@Override [EOL] public void writeNumber(double d) throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); [EOL] }
@Override [EOL] public void writeNumber(double d) throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); [EOL] }
@Override [EOL] public void writeNumber(double d) throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); [EOL] }
@Override [EOL] public void writeNumber(double d) throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); [EOL] }
@Override [EOL] public void writeNumber(double d) throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); [EOL] }
@Override [EOL] public void writeNumber(double d) throws IOException, JsonGenerationException { [EOL]     _append(JsonToken.VALUE_NUMBER_FLOAT, Double.valueOf(d)); [EOL] }
@Override [EOL] public ObjectCodec getCodec() { [EOL]     return _codec; [EOL] }
@Override [EOL] public ObjectCodec getCodec() { [EOL]     return _codec; [EOL] }
@Override [EOL] public String getCurrentName() { [EOL]     return _parsingContext.getCurrentName(); [EOL] }
@Override [EOL] public String getCurrentName() { [EOL]     return _parsingContext.getCurrentName(); [EOL] }
@Override [EOL] public void overrideCurrentName(String name) { [EOL]     JsonReadContext ctxt = _parsingContext; [EOL]     if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]         ctxt = ctxt.getParent(); [EOL]     } [EOL]     ctxt.setCurrentName(name); [EOL] }
@Override [EOL] public void overrideCurrentName(String name) { [EOL]     JsonReadContext ctxt = _parsingContext; [EOL]     if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]         ctxt = ctxt.getParent(); [EOL]     } [EOL]     ctxt.setCurrentName(name); [EOL] }
@Override [EOL] public void overrideCurrentName(String name) { [EOL]     JsonReadContext ctxt = _parsingContext; [EOL]     if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]         ctxt = ctxt.getParent(); [EOL]     } [EOL]     ctxt.setCurrentName(name); [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { [EOL]         Object ob = _currentObject(); [EOL]         if (ob instanceof String) { [EOL]             return (String) ob; [EOL]         } [EOL]         return (ob == null) ? null : ob.toString(); [EOL]     } [EOL]     if (_currToken == null) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             Object ob = _currentObject(); [EOL]             return (ob == null) ? null : ob.toString(); [EOL]         default: [EOL]             return _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_currToken == JsonToken.VALUE_STRING || _currToken == JsonToken.FIELD_NAME) { [EOL]         Object ob = _currentObject(); [EOL]         if (ob instanceof String) { [EOL]             return (String) ob; [EOL]         } [EOL]         return (ob == null) ? null : ob.toString(); [EOL]     } [EOL]     if (_currToken == null) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             Object ob = _currentObject(); [EOL]             return (ob == null) ? null : ob.toString(); [EOL]         default: [EOL]             return _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public double getDoubleValue() throws IOException, JsonParseException { [EOL]     return getNumberValue().doubleValue(); [EOL] }
@Override [EOL] public double getDoubleValue() throws IOException, JsonParseException { [EOL]     return getNumberValue().doubleValue(); [EOL] }
@Override [EOL] public double getDoubleValue() throws IOException, JsonParseException { [EOL]     return getNumberValue().doubleValue(); [EOL] }
@Override [EOL] public double getDoubleValue() throws IOException, JsonParseException { [EOL]     return getNumberValue().doubleValue(); [EOL] }
@Override [EOL] public double getDoubleValue() throws IOException, JsonParseException { [EOL]     return getNumberValue().doubleValue(); [EOL] }
public JavaType narrowBy(Class<?> subclass) { [EOL]     if (subclass == _class) { [EOL]         return this; [EOL]     } [EOL]     _assertSubclass(subclass, _class); [EOL]     JavaType result = _narrow(subclass); [EOL]     if (_valueHandler != result.<Object>getValueHandler()) { [EOL]         result = result.withValueHandler(_valueHandler); [EOL]     } [EOL]     if (_typeHandler != result.<Object>getTypeHandler()) { [EOL]         result = result.withTypeHandler(_typeHandler); [EOL]     } [EOL]     return result; [EOL] }
public JavaType narrowBy(Class<?> subclass) { [EOL]     if (subclass == _class) { [EOL]         return this; [EOL]     } [EOL]     _assertSubclass(subclass, _class); [EOL]     JavaType result = _narrow(subclass); [EOL]     if (_valueHandler != result.<Object>getValueHandler()) { [EOL]         result = result.withValueHandler(_valueHandler); [EOL]     } [EOL]     if (_typeHandler != result.<Object>getTypeHandler()) { [EOL]         result = result.withTypeHandler(_typeHandler); [EOL]     } [EOL]     return result; [EOL] }
public JavaType narrowBy(Class<?> subclass) { [EOL]     if (subclass == _class) { [EOL]         return this; [EOL]     } [EOL]     _assertSubclass(subclass, _class); [EOL]     JavaType result = _narrow(subclass); [EOL]     if (_valueHandler != result.<Object>getValueHandler()) { [EOL]         result = result.withValueHandler(_valueHandler); [EOL]     } [EOL]     if (_typeHandler != result.<Object>getTypeHandler()) { [EOL]         result = result.withTypeHandler(_typeHandler); [EOL]     } [EOL]     return result; [EOL] }
public JavaType narrowBy(Class<?> subclass) { [EOL]     if (subclass == _class) { [EOL]         return this; [EOL]     } [EOL]     _assertSubclass(subclass, _class); [EOL]     JavaType result = _narrow(subclass); [EOL]     if (_valueHandler != result.<Object>getValueHandler()) { [EOL]         result = result.withValueHandler(_valueHandler); [EOL]     } [EOL]     if (_typeHandler != result.<Object>getTypeHandler()) { [EOL]         result = result.withTypeHandler(_typeHandler); [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public boolean isAbstract() { [EOL]     return Modifier.isAbstract(_class.getModifiers()); [EOL] }
@Override [EOL] public boolean isAbstract() { [EOL]     return Modifier.isAbstract(_class.getModifiers()); [EOL] }
@Override [EOL] public boolean isConcrete() { [EOL]     int mod = _class.getModifiers(); [EOL]     if ((mod & (Modifier.INTERFACE | Modifier.ABSTRACT)) == 0) { [EOL]         return true; [EOL]     } [EOL]     if (_class.isPrimitive()) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
@Override [EOL] public boolean isThrowable() { [EOL]     return Throwable.class.isAssignableFrom(_class); [EOL] }
@Override [EOL] public boolean isThrowable() { [EOL]     return Throwable.class.isAssignableFrom(_class); [EOL] }
@Override [EOL] public final void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException, JsonProcessingException { [EOL]     if (_value == null) { [EOL]         jg.writeNull(); [EOL]     } else { [EOL]         jg.writeObject(_value); [EOL]     } [EOL] }
@Override [EOL] public final void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException, JsonProcessingException { [EOL]     if (_value == null) { [EOL]         jg.writeNull(); [EOL]     } else { [EOL]         jg.writeObject(_value); [EOL]     } [EOL] }
@Override [EOL] public DateSerializer withFormat(boolean timestamp, DateFormat customFormat) { [EOL]     if (timestamp) { [EOL]         return new DateSerializer(true, null); [EOL]     } [EOL]     return new DateSerializer(false, customFormat); [EOL] }
@Override [EOL] public DateSerializer withFormat(boolean timestamp, DateFormat customFormat) { [EOL]     if (timestamp) { [EOL]         return new DateSerializer(true, null); [EOL]     } [EOL]     return new DateSerializer(false, customFormat); [EOL] }
@Override [EOL] protected long _timestamp(Date value) { [EOL]     return (value == null) ? 0L : value.getTime(); [EOL] }
@Override [EOL] protected long _timestamp(Date value) { [EOL]     return (value == null) ? 0L : value.getTime(); [EOL] }
@Override [EOL] public void serialize(Date value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_useTimestamp) { [EOL]         jgen.writeNumber(_timestamp(value)); [EOL]     } else if (_customFormat != null) { [EOL]         synchronized (_customFormat) { [EOL]             jgen.writeString(_customFormat.format(value)); [EOL]         } [EOL]     } else { [EOL]         provider.defaultSerializeDateValue(value, jgen); [EOL]     } [EOL] }
@Override [EOL] public void serialize(Date value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_useTimestamp) { [EOL]         jgen.writeNumber(_timestamp(value)); [EOL]     } else if (_customFormat != null) { [EOL]         synchronized (_customFormat) { [EOL]             jgen.writeString(_customFormat.format(value)); [EOL]         } [EOL]     } else { [EOL]         provider.defaultSerializeDateValue(value, jgen); [EOL]     } [EOL] }
@Override [EOL] public void serialize(Date value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_useTimestamp) { [EOL]         jgen.writeNumber(_timestamp(value)); [EOL]     } else if (_customFormat != null) { [EOL]         synchronized (_customFormat) { [EOL]             jgen.writeString(_customFormat.format(value)); [EOL]         } [EOL]     } else { [EOL]         provider.defaultSerializeDateValue(value, jgen); [EOL]     } [EOL] }
@Override [EOL] public JavaType getInputType(TypeFactory typeFactory) { [EOL]     JavaType[] types = typeFactory.findTypeParameters(getClass(), Converter.class); [EOL]     if (types == null || types.length < 2) { [EOL]         throw new IllegalStateException("Can not find OUT type parameter for Converter of type " + getClass().getName()); [EOL]     } [EOL]     return types[0]; [EOL] }
@Override [EOL] public JavaType getInputType(TypeFactory typeFactory) { [EOL]     JavaType[] types = typeFactory.findTypeParameters(getClass(), Converter.class); [EOL]     if (types == null || types.length < 2) { [EOL]         throw new IllegalStateException("Can not find OUT type parameter for Converter of type " + getClass().getName()); [EOL]     } [EOL]     return types[0]; [EOL] }
protected BaseJsonNode() { [EOL] }
@Override [EOL] public final JsonNode findPath(String fieldName) { [EOL]     JsonNode value = findValue(fieldName); [EOL]     if (value == null) { [EOL]         return MissingNode.getInstance(); [EOL]     } [EOL]     return value; [EOL] }
@Override [EOL] public final JsonNode findPath(String fieldName) { [EOL]     JsonNode value = findValue(fieldName); [EOL]     if (value == null) { [EOL]         return MissingNode.getInstance(); [EOL]     } [EOL]     return value; [EOL] }
public boolean useForType(JavaType t) { [EOL]     switch(_appliesFor) { [EOL]         case NON_CONCRETE_AND_ARRAYS: [EOL]             while (t.isArrayType()) { [EOL]                 t = t.getContentType(); [EOL]             } [EOL]         case OBJECT_AND_NON_CONCRETE: [EOL]             return (t.getRawClass() == Object.class) || !t.isConcrete(); [EOL]         case NON_FINAL: [EOL]             while (t.isArrayType()) { [EOL]                 t = t.getContentType(); [EOL]             } [EOL]             return !t.isFinal(); [EOL]         default: [EOL]             return (t.getRawClass() == Object.class); [EOL]     } [EOL] }
public boolean useForType(JavaType t) { [EOL]     switch(_appliesFor) { [EOL]         case NON_CONCRETE_AND_ARRAYS: [EOL]             while (t.isArrayType()) { [EOL]                 t = t.getContentType(); [EOL]             } [EOL]         case OBJECT_AND_NON_CONCRETE: [EOL]             return (t.getRawClass() == Object.class) || !t.isConcrete(); [EOL]         case NON_FINAL: [EOL]             while (t.isArrayType()) { [EOL]                 t = t.getContentType(); [EOL]             } [EOL]             return !t.isFinal(); [EOL]         default: [EOL]             return (t.getRawClass() == Object.class); [EOL]     } [EOL] }
public boolean useForType(JavaType t) { [EOL]     switch(_appliesFor) { [EOL]         case NON_CONCRETE_AND_ARRAYS: [EOL]             while (t.isArrayType()) { [EOL]                 t = t.getContentType(); [EOL]             } [EOL]         case OBJECT_AND_NON_CONCRETE: [EOL]             return (t.getRawClass() == Object.class) || !t.isConcrete(); [EOL]         case NON_FINAL: [EOL]             while (t.isArrayType()) { [EOL]                 t = t.getContentType(); [EOL]             } [EOL]             return !t.isFinal(); [EOL]         default: [EOL]             return (t.getRawClass() == Object.class); [EOL]     } [EOL] }
public boolean useForType(JavaType t) { [EOL]     switch(_appliesFor) { [EOL]         case NON_CONCRETE_AND_ARRAYS: [EOL]             while (t.isArrayType()) { [EOL]                 t = t.getContentType(); [EOL]             } [EOL]         case OBJECT_AND_NON_CONCRETE: [EOL]             return (t.getRawClass() == Object.class) || !t.isConcrete(); [EOL]         case NON_FINAL: [EOL]             while (t.isArrayType()) { [EOL]                 t = t.getContentType(); [EOL]             } [EOL]             return !t.isFinal(); [EOL]         default: [EOL]             return (t.getRawClass() == Object.class); [EOL]     } [EOL] }
@Override [EOL] public Version version() { [EOL]     return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION; [EOL] }
public ObjectMapper registerModule(Module module) { [EOL]     String name = module.getModuleName(); [EOL]     if (name == null) { [EOL]         throw new IllegalArgumentException("Module without defined name"); [EOL]     } [EOL]     Version version = module.version(); [EOL]     if (version == null) { [EOL]         throw new IllegalArgumentException("Module without defined version"); [EOL]     } [EOL]     final ObjectMapper mapper = this; [EOL]     module.setupModule(new Module.SetupContext() { [EOL]  [EOL]         @Override [EOL]         public Version getMapperVersion() { [EOL]             return version(); [EOL]         } [EOL]  [EOL]         @SuppressWarnings("unchecked") [EOL]         @Override [EOL]         public <C extends ObjectCodec> C getOwner() { [EOL]             return (C) mapper; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public TypeFactory getTypeFactory() { [EOL]             return _typeFactory; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(MapperFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(DeserializationFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(SerializationFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonFactory.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonParser.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonGenerator.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addDeserializers(Deserializers d) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addKeyDeserializers(KeyDeserializers d) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addSerializers(Serializers s) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addKeySerializers(Serializers s) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addBeanSerializerModifier(BeanSerializerModifier modifier) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addAbstractTypeResolver(AbstractTypeResolver resolver) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addTypeModifier(TypeModifier modifier) { [EOL]             TypeFactory f = mapper._typeFactory; [EOL]             f = f.withModifier(modifier); [EOL]             mapper.setTypeFactory(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addValueInstantiators(ValueInstantiators instantiators) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void setClassIntrospector(ClassIntrospector ci) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.with(ci); [EOL]             mapper._serializationConfig = mapper._serializationConfig.with(ci); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void insertAnnotationIntrospector(AnnotationIntrospector ai) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai); [EOL]             mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void appendAnnotationIntrospector(AnnotationIntrospector ai) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai); [EOL]             mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void registerSubtypes(Class<?>... subtypes) { [EOL]             mapper.registerSubtypes(subtypes); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void registerSubtypes(NamedType... subtypes) { [EOL]             mapper.registerSubtypes(subtypes); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) { [EOL]             mapper.addMixInAnnotations(target, mixinSource); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addDeserializationProblemHandler(DeserializationProblemHandler handler) { [EOL]             mapper.addHandler(handler); [EOL]         } [EOL]     }); [EOL]     return this; [EOL] }
public ObjectMapper registerModule(Module module) { [EOL]     String name = module.getModuleName(); [EOL]     if (name == null) { [EOL]         throw new IllegalArgumentException("Module without defined name"); [EOL]     } [EOL]     Version version = module.version(); [EOL]     if (version == null) { [EOL]         throw new IllegalArgumentException("Module without defined version"); [EOL]     } [EOL]     final ObjectMapper mapper = this; [EOL]     module.setupModule(new Module.SetupContext() { [EOL]  [EOL]         @Override [EOL]         public Version getMapperVersion() { [EOL]             return version(); [EOL]         } [EOL]  [EOL]         @SuppressWarnings("unchecked") [EOL]         @Override [EOL]         public <C extends ObjectCodec> C getOwner() { [EOL]             return (C) mapper; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public TypeFactory getTypeFactory() { [EOL]             return _typeFactory; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(MapperFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(DeserializationFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(SerializationFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonFactory.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonParser.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonGenerator.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addDeserializers(Deserializers d) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addKeyDeserializers(KeyDeserializers d) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addSerializers(Serializers s) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addKeySerializers(Serializers s) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addBeanSerializerModifier(BeanSerializerModifier modifier) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addAbstractTypeResolver(AbstractTypeResolver resolver) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addTypeModifier(TypeModifier modifier) { [EOL]             TypeFactory f = mapper._typeFactory; [EOL]             f = f.withModifier(modifier); [EOL]             mapper.setTypeFactory(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addValueInstantiators(ValueInstantiators instantiators) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void setClassIntrospector(ClassIntrospector ci) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.with(ci); [EOL]             mapper._serializationConfig = mapper._serializationConfig.with(ci); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void insertAnnotationIntrospector(AnnotationIntrospector ai) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai); [EOL]             mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void appendAnnotationIntrospector(AnnotationIntrospector ai) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai); [EOL]             mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void registerSubtypes(Class<?>... subtypes) { [EOL]             mapper.registerSubtypes(subtypes); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void registerSubtypes(NamedType... subtypes) { [EOL]             mapper.registerSubtypes(subtypes); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) { [EOL]             mapper.addMixInAnnotations(target, mixinSource); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addDeserializationProblemHandler(DeserializationProblemHandler handler) { [EOL]             mapper.addHandler(handler); [EOL]         } [EOL]     }); [EOL]     return this; [EOL] }
public ObjectMapper registerModule(Module module) { [EOL]     String name = module.getModuleName(); [EOL]     if (name == null) { [EOL]         throw new IllegalArgumentException("Module without defined name"); [EOL]     } [EOL]     Version version = module.version(); [EOL]     if (version == null) { [EOL]         throw new IllegalArgumentException("Module without defined version"); [EOL]     } [EOL]     final ObjectMapper mapper = this; [EOL]     module.setupModule(new Module.SetupContext() { [EOL]  [EOL]         @Override [EOL]         public Version getMapperVersion() { [EOL]             return version(); [EOL]         } [EOL]  [EOL]         @SuppressWarnings("unchecked") [EOL]         @Override [EOL]         public <C extends ObjectCodec> C getOwner() { [EOL]             return (C) mapper; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public TypeFactory getTypeFactory() { [EOL]             return _typeFactory; [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(MapperFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(DeserializationFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(SerializationFeature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonFactory.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonParser.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public boolean isEnabled(JsonGenerator.Feature f) { [EOL]             return mapper.isEnabled(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addDeserializers(Deserializers d) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addKeyDeserializers(KeyDeserializers d) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addSerializers(Serializers s) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addKeySerializers(Serializers s) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addBeanSerializerModifier(BeanSerializerModifier modifier) { [EOL]             mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addAbstractTypeResolver(AbstractTypeResolver resolver) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addTypeModifier(TypeModifier modifier) { [EOL]             TypeFactory f = mapper._typeFactory; [EOL]             f = f.withModifier(modifier); [EOL]             mapper.setTypeFactory(f); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addValueInstantiators(ValueInstantiators instantiators) { [EOL]             DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators); [EOL]             mapper._deserializationContext = mapper._deserializationContext.with(df); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void setClassIntrospector(ClassIntrospector ci) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.with(ci); [EOL]             mapper._serializationConfig = mapper._serializationConfig.with(ci); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void insertAnnotationIntrospector(AnnotationIntrospector ai) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai); [EOL]             mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void appendAnnotationIntrospector(AnnotationIntrospector ai) { [EOL]             mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai); [EOL]             mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void registerSubtypes(Class<?>... subtypes) { [EOL]             mapper.registerSubtypes(subtypes); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void registerSubtypes(NamedType... subtypes) { [EOL]             mapper.registerSubtypes(subtypes); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) { [EOL]             mapper.addMixInAnnotations(target, mixinSource); [EOL]         } [EOL]  [EOL]         @Override [EOL]         public void addDeserializationProblemHandler(DeserializationProblemHandler handler) { [EOL]             mapper.addHandler(handler); [EOL]         } [EOL]     }); [EOL]     return this; [EOL] }
public ObjectMapper setSerializerProvider(DefaultSerializerProvider p) { [EOL]     _serializerProvider = p; [EOL]     return this; [EOL] }
public ObjectMapper setSerializerProvider(DefaultSerializerProvider p) { [EOL]     _serializerProvider = p; [EOL]     return this; [EOL] }
public SerializerProvider getSerializerProvider() { [EOL]     return _serializerProvider; [EOL] }
public SubtypeResolver getSubtypeResolver() { [EOL]     return _subtypeResolver; [EOL] }
public void registerSubtypes(Class<?>... classes) { [EOL]     getSubtypeResolver().registerSubtypes(classes); [EOL] }
public void registerSubtypes(Class<?>... classes) { [EOL]     getSubtypeResolver().registerSubtypes(classes); [EOL] }
public void registerSubtypes(Class<?>... classes) { [EOL]     getSubtypeResolver().registerSubtypes(classes); [EOL] }
public void registerSubtypes(NamedType... types) { [EOL]     getSubtypeResolver().registerSubtypes(types); [EOL] }
public void registerSubtypes(NamedType... types) { [EOL]     getSubtypeResolver().registerSubtypes(types); [EOL] }
public void registerSubtypes(NamedType... types) { [EOL]     getSubtypeResolver().registerSubtypes(types); [EOL] }
public JavaType constructType(Type t) { [EOL]     return _typeFactory.constructType(t); [EOL] }
public JavaType constructType(Type t) { [EOL]     return _typeFactory.constructType(t); [EOL] }
public JavaType constructType(Type t) { [EOL]     return _typeFactory.constructType(t); [EOL] }
public ObjectMapper configure(JsonGenerator.Feature f, boolean state) { [EOL]     _jsonFactory.configure(f, state); [EOL]     return this; [EOL] }
public ObjectMapper configure(JsonGenerator.Feature f, boolean state) { [EOL]     _jsonFactory.configure(f, state); [EOL]     return this; [EOL] }
public ObjectMapper disable(SerializationFeature f) { [EOL]     _serializationConfig = _serializationConfig.without(f); [EOL]     return this; [EOL] }
public ObjectMapper disable(SerializationFeature f) { [EOL]     _serializationConfig = _serializationConfig.without(f); [EOL]     return this; [EOL] }
@Override [EOL] public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     SerializationConfig config = getSerializationConfig(); [EOL]     if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseableValue(jgen, value, config); [EOL]     } else { [EOL]         _serializerProvider(config).serializeValue(jgen, value); [EOL]         if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { [EOL]             jgen.flush(); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     SerializationConfig config = getSerializationConfig(); [EOL]     if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseableValue(jgen, value, config); [EOL]     } else { [EOL]         _serializerProvider(config).serializeValue(jgen, value); [EOL]         if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { [EOL]             jgen.flush(); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     SerializationConfig config = getSerializationConfig(); [EOL]     if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseableValue(jgen, value, config); [EOL]     } else { [EOL]         _serializerProvider(config).serializeValue(jgen, value); [EOL]         if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { [EOL]             jgen.flush(); [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     SerializationConfig config = getSerializationConfig(); [EOL]     if (config.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseableValue(jgen, value, config); [EOL]     } else { [EOL]         _serializerProvider(config).serializeValue(jgen, value); [EOL]         if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) { [EOL]             jgen.flush(); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] public <T> T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException { [EOL]     return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueTypeRef)); [EOL] }
@SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] public <T> T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException { [EOL]     return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueTypeRef)); [EOL] }
@SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] public <T> T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException { [EOL]     return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueTypeRef)); [EOL] }
@SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] public <T> T readValue(String content, TypeReference valueTypeRef) throws IOException, JsonParseException, JsonMappingException { [EOL]     return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueTypeRef)); [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T readValue(byte[] src, int offset, int len, JavaType valueType) throws IOException, JsonParseException, JsonMappingException { [EOL]     return (T) _readMapAndClose(_jsonFactory.createParser(src, offset, len), valueType); [EOL] }
public String writeValueAsString(Object value) throws JsonProcessingException { [EOL]     SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler()); [EOL]     try { [EOL]         _configAndWriteValue(_jsonFactory.createGenerator(sw), value); [EOL]     } catch (JsonProcessingException e) { [EOL]         throw e; [EOL]     } catch (IOException e) { [EOL]         throw JsonMappingException.fromUnexpectedIOE(e); [EOL]     } [EOL]     return sw.getAndClear(); [EOL] }
public String writeValueAsString(Object value) throws JsonProcessingException { [EOL]     SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler()); [EOL]     try { [EOL]         _configAndWriteValue(_jsonFactory.createGenerator(sw), value); [EOL]     } catch (JsonProcessingException e) { [EOL]         throw e; [EOL]     } catch (IOException e) { [EOL]         throw JsonMappingException.fromUnexpectedIOE(e); [EOL]     } [EOL]     return sw.getAndClear(); [EOL] }
public String writeValueAsString(Object value) throws JsonProcessingException { [EOL]     SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler()); [EOL]     try { [EOL]         _configAndWriteValue(_jsonFactory.createGenerator(sw), value); [EOL]     } catch (JsonProcessingException e) { [EOL]         throw e; [EOL]     } catch (IOException e) { [EOL]         throw JsonMappingException.fromUnexpectedIOE(e); [EOL]     } [EOL]     return sw.getAndClear(); [EOL] }
public ObjectWriter writer() { [EOL]     return new ObjectWriter(this, getSerializationConfig()); [EOL] }
public ObjectWriter writerWithType(Class<?> rootType) { [EOL]     return new ObjectWriter(this, getSerializationConfig(), ((rootType == null) ? null : _typeFactory.constructType(rootType)), null); [EOL] }
public ObjectWriter writerWithType(Class<?> rootType) { [EOL]     return new ObjectWriter(this, getSerializationConfig(), ((rootType == null) ? null : _typeFactory.constructType(rootType)), null); [EOL] }
public ObjectReader reader(FormatSchema schema) { [EOL]     _verifySchemaType(schema); [EOL]     return new ObjectReader(this, getDeserializationConfig(), null, null, schema, _injectableValues); [EOL] }
public ObjectReader reader(FormatSchema schema) { [EOL]     _verifySchemaType(schema); [EOL]     return new ObjectReader(this, getDeserializationConfig(), null, null, schema, _injectableValues); [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T convertValue(Object fromValue, TypeReference<?> toValueTypeRef) throws IllegalArgumentException { [EOL]     return (T) convertValue(fromValue, _typeFactory.constructType(toValueTypeRef)); [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T convertValue(Object fromValue, TypeReference<?> toValueTypeRef) throws IllegalArgumentException { [EOL]     return (T) convertValue(fromValue, _typeFactory.constructType(toValueTypeRef)); [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException { [EOL]     if (fromValue == null) [EOL]         return null; [EOL]     return (T) _convert(fromValue, toValueType); [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T convertValue(Object fromValue, JavaType toValueType) throws IllegalArgumentException { [EOL]     if (fromValue == null) [EOL]         return null; [EOL]     return (T) _convert(fromValue, toValueType); [EOL] }
protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     SerializationConfig cfg = getSerializationConfig(); [EOL]     if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _configAndWriteCloseable(jgen, value, cfg); [EOL]         return; [EOL]     } [EOL]     boolean closed = false; [EOL]     try { [EOL]         _serializerProvider(cfg).serializeValue(jgen, value); [EOL]         closed = true; [EOL]         jgen.close(); [EOL]     } finally { [EOL]         if (!closed) { [EOL]             try { [EOL]                 jgen.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     SerializationConfig cfg = getSerializationConfig(); [EOL]     if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _configAndWriteCloseable(jgen, value, cfg); [EOL]         return; [EOL]     } [EOL]     boolean closed = false; [EOL]     try { [EOL]         _serializerProvider(cfg).serializeValue(jgen, value); [EOL]         closed = true; [EOL]         jgen.close(); [EOL]     } finally { [EOL]         if (!closed) { [EOL]             try { [EOL]                 jgen.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     SerializationConfig cfg = getSerializationConfig(); [EOL]     if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _configAndWriteCloseable(jgen, value, cfg); [EOL]         return; [EOL]     } [EOL]     boolean closed = false; [EOL]     try { [EOL]         _serializerProvider(cfg).serializeValue(jgen, value); [EOL]         closed = true; [EOL]         jgen.close(); [EOL]     } finally { [EOL]         if (!closed) { [EOL]             try { [EOL]                 jgen.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     SerializationConfig cfg = getSerializationConfig(); [EOL]     if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) { [EOL]         jgen.useDefaultPrettyPrinter(); [EOL]     } [EOL]     if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _configAndWriteCloseable(jgen, value, cfg); [EOL]         return; [EOL]     } [EOL]     boolean closed = false; [EOL]     try { [EOL]         _serializerProvider(cfg).serializeValue(jgen, value); [EOL]         closed = true; [EOL]         jgen.close(); [EOL]     } finally { [EOL]         if (!closed) { [EOL]             try { [EOL]                 jgen.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _verifySchemaType(FormatSchema schema) { [EOL]     if (schema != null) { [EOL]         if (!_jsonFactory.canUseSchema(schema)) { [EOL]             throw new IllegalArgumentException("Can not use FormatSchema of type " + schema.getClass().getName() + " for format " + _jsonFactory.getFormatName()); [EOL]         } [EOL]     } [EOL] }
protected void _verifySchemaType(FormatSchema schema) { [EOL]     if (schema != null) { [EOL]         if (!_jsonFactory.canUseSchema(schema)) { [EOL]             throw new IllegalArgumentException("Can not use FormatSchema of type " + schema.getClass().getName() + " for format " + _jsonFactory.getFormatName()); [EOL]         } [EOL]     } [EOL] }
protected void _verifySchemaType(FormatSchema schema) { [EOL]     if (schema != null) { [EOL]         if (!_jsonFactory.canUseSchema(schema)) { [EOL]             throw new IllegalArgumentException("Can not use FormatSchema of type " + schema.getClass().getName() + " for format " + _jsonFactory.getFormatName()); [EOL]         } [EOL]     } [EOL] }
public boolean canInstantiate() { [EOL]     return canCreateUsingDefault() || canCreateUsingDelegate() || canCreateFromObjectWith() || canCreateFromString() || canCreateFromInt() || canCreateFromLong() || canCreateFromDouble() || canCreateFromBoolean(); [EOL] }
public boolean canInstantiate() { [EOL]     return canCreateUsingDefault() || canCreateUsingDelegate() || canCreateFromObjectWith() || canCreateFromString() || canCreateFromInt() || canCreateFromLong() || canCreateFromDouble() || canCreateFromBoolean(); [EOL] }
public boolean canInstantiate() { [EOL]     return canCreateUsingDefault() || canCreateUsingDelegate() || canCreateFromObjectWith() || canCreateFromString() || canCreateFromInt() || canCreateFromLong() || canCreateFromDouble() || canCreateFromBoolean(); [EOL] }
public boolean canInstantiate() { [EOL]     return canCreateUsingDefault() || canCreateUsingDelegate() || canCreateFromObjectWith() || canCreateFromString() || canCreateFromInt() || canCreateFromLong() || canCreateFromDouble() || canCreateFromBoolean(); [EOL] }
public static BooleanNode getTrue() { [EOL]     return TRUE; [EOL] }
public static BooleanNode valueOf(boolean b) { [EOL]     return b ? TRUE : FALSE; [EOL] }
public static BooleanNode valueOf(boolean b) { [EOL]     return b ? TRUE : FALSE; [EOL] }
@Override [EOL] public JsonNodeType getNodeType() { [EOL]     return JsonNodeType.BOOLEAN; [EOL] }
@Override [EOL] public JsonNodeType getNodeType() { [EOL]     return JsonNodeType.BOOLEAN; [EOL] }
@Override [EOL] public boolean booleanValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public boolean booleanValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public String asText() { [EOL]     return _value ? "true" : "false"; [EOL] }
@Override [EOL] public String asText() { [EOL]     return _value ? "true" : "false"; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return (_value == ((BooleanNode) o)._value); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return (_value == ((BooleanNode) o)._value); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return (_value == ((BooleanNode) o)._value); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return (_value == ((BooleanNode) o)._value); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return (_value == ((BooleanNode) o)._value); [EOL] }
protected NameTransformer() { [EOL] } protected NameTransformer(); public Chained(NameTransformer t1, NameTransformer t2); public String transform(String name); public String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public static NameTransformer simpleTransformer(final String prefix, final String suffix); public static NameTransformer chainedTransformer(NameTransformer t1, NameTransformer t2); public abstract String transform(String name); public abstract String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); NameTransformer NOP=Optional[new NameTransformer() {; ;     @Override;     public String transform(String name) {;         return name;;     }; ;     @Override;     public String reverse(String transformed) {;         // identity transformation is always reversible:;         return transformed;;     }; }
public static NameTransformer simpleTransformer(final String prefix, final String suffix) { [EOL]     boolean hasPrefix = (prefix != null) && (prefix.length() > 0); [EOL]     boolean hasSuffix = (suffix != null) && (suffix.length() > 0); [EOL]     if (hasPrefix) { [EOL]         if (hasSuffix) { [EOL]             return new NameTransformer() { [EOL]  [EOL]                 @Override [EOL]                 public String transform(String name) { [EOL]                     return prefix + name + suffix; [EOL]                 } [EOL]  [EOL]                 @Override [EOL]                 public String reverse(String transformed) { [EOL]                     if (transformed.startsWith(prefix)) { [EOL]                         String str = transformed.substring(prefix.length()); [EOL]                         if (str.endsWith(suffix)) { [EOL]                             return str.substring(0, str.length() - suffix.length()); [EOL]                         } [EOL]                     } [EOL]                     return null; [EOL]                 } [EOL]  [EOL]                 @Override [EOL]                 public String toString() { [EOL]                     return "[PreAndSuffixTransformer('" + prefix + "','" + suffix + "')]"; [EOL]                 } [EOL]             }; [EOL]         } [EOL]         return new NameTransformer() { [EOL]  [EOL]             @Override [EOL]             public String transform(String name) { [EOL]                 return prefix + name; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String reverse(String transformed) { [EOL]                 if (transformed.startsWith(prefix)) { [EOL]                     return transformed.substring(prefix.length()); [EOL]                 } [EOL]                 return null; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String toString() { [EOL]                 return "[PrefixTransformer('" + prefix + "')]"; [EOL]             } [EOL]         }; [EOL]     } [EOL]     if (hasSuffix) { [EOL]         return new NameTransformer() { [EOL]  [EOL]             @Override [EOL]             public String transform(String name) { [EOL]                 return name + suffix; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String reverse(String transformed) { [EOL]                 if (transformed.endsWith(suffix)) { [EOL]                     return transformed.substring(0, transformed.length() - suffix.length()); [EOL]                 } [EOL]                 return null; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String toString() { [EOL]                 return "[SuffixTransformer('" + suffix + "')]"; [EOL]             } [EOL]         }; [EOL]     } [EOL]     return NOP; [EOL] } protected NameTransformer(); public Chained(NameTransformer t1, NameTransformer t2); public String transform(String name); public String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public static NameTransformer simpleTransformer(final String prefix, final String suffix); public static NameTransformer chainedTransformer(NameTransformer t1, NameTransformer t2); public abstract String transform(String name); public abstract String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); NameTransformer NOP=Optional[new NameTransformer() {; ;     @Override;     public String transform(String name) {;         return name;;     }; ;     @Override;     public String reverse(String transformed) {;         // identity transformation is always reversible:;         return transformed;;     }; }
public static NameTransformer simpleTransformer(final String prefix, final String suffix) { [EOL]     boolean hasPrefix = (prefix != null) && (prefix.length() > 0); [EOL]     boolean hasSuffix = (suffix != null) && (suffix.length() > 0); [EOL]     if (hasPrefix) { [EOL]         if (hasSuffix) { [EOL]             return new NameTransformer() { [EOL]  [EOL]                 @Override [EOL]                 public String transform(String name) { [EOL]                     return prefix + name + suffix; [EOL]                 } [EOL]  [EOL]                 @Override [EOL]                 public String reverse(String transformed) { [EOL]                     if (transformed.startsWith(prefix)) { [EOL]                         String str = transformed.substring(prefix.length()); [EOL]                         if (str.endsWith(suffix)) { [EOL]                             return str.substring(0, str.length() - suffix.length()); [EOL]                         } [EOL]                     } [EOL]                     return null; [EOL]                 } [EOL]  [EOL]                 @Override [EOL]                 public String toString() { [EOL]                     return "[PreAndSuffixTransformer('" + prefix + "','" + suffix + "')]"; [EOL]                 } [EOL]             }; [EOL]         } [EOL]         return new NameTransformer() { [EOL]  [EOL]             @Override [EOL]             public String transform(String name) { [EOL]                 return prefix + name; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String reverse(String transformed) { [EOL]                 if (transformed.startsWith(prefix)) { [EOL]                     return transformed.substring(prefix.length()); [EOL]                 } [EOL]                 return null; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String toString() { [EOL]                 return "[PrefixTransformer('" + prefix + "')]"; [EOL]             } [EOL]         }; [EOL]     } [EOL]     if (hasSuffix) { [EOL]         return new NameTransformer() { [EOL]  [EOL]             @Override [EOL]             public String transform(String name) { [EOL]                 return name + suffix; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String reverse(String transformed) { [EOL]                 if (transformed.endsWith(suffix)) { [EOL]                     return transformed.substring(0, transformed.length() - suffix.length()); [EOL]                 } [EOL]                 return null; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String toString() { [EOL]                 return "[SuffixTransformer('" + suffix + "')]"; [EOL]             } [EOL]         }; [EOL]     } [EOL]     return NOP; [EOL] } protected NameTransformer(); public Chained(NameTransformer t1, NameTransformer t2); public String transform(String name); public String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public static NameTransformer simpleTransformer(final String prefix, final String suffix); public static NameTransformer chainedTransformer(NameTransformer t1, NameTransformer t2); public abstract String transform(String name); public abstract String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); NameTransformer NOP=Optional[new NameTransformer() {; ;     @Override;     public String transform(String name) {;         return name;;     }; ;     @Override;     public String reverse(String transformed) {;         // identity transformation is always reversible:;         return transformed;;     }; }
public static NameTransformer simpleTransformer(final String prefix, final String suffix) { [EOL]     boolean hasPrefix = (prefix != null) && (prefix.length() > 0); [EOL]     boolean hasSuffix = (suffix != null) && (suffix.length() > 0); [EOL]     if (hasPrefix) { [EOL]         if (hasSuffix) { [EOL]             return new NameTransformer() { [EOL]  [EOL]                 @Override [EOL]                 public String transform(String name) { [EOL]                     return prefix + name + suffix; [EOL]                 } [EOL]  [EOL]                 @Override [EOL]                 public String reverse(String transformed) { [EOL]                     if (transformed.startsWith(prefix)) { [EOL]                         String str = transformed.substring(prefix.length()); [EOL]                         if (str.endsWith(suffix)) { [EOL]                             return str.substring(0, str.length() - suffix.length()); [EOL]                         } [EOL]                     } [EOL]                     return null; [EOL]                 } [EOL]  [EOL]                 @Override [EOL]                 public String toString() { [EOL]                     return "[PreAndSuffixTransformer('" + prefix + "','" + suffix + "')]"; [EOL]                 } [EOL]             }; [EOL]         } [EOL]         return new NameTransformer() { [EOL]  [EOL]             @Override [EOL]             public String transform(String name) { [EOL]                 return prefix + name; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String reverse(String transformed) { [EOL]                 if (transformed.startsWith(prefix)) { [EOL]                     return transformed.substring(prefix.length()); [EOL]                 } [EOL]                 return null; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String toString() { [EOL]                 return "[PrefixTransformer('" + prefix + "')]"; [EOL]             } [EOL]         }; [EOL]     } [EOL]     if (hasSuffix) { [EOL]         return new NameTransformer() { [EOL]  [EOL]             @Override [EOL]             public String transform(String name) { [EOL]                 return name + suffix; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String reverse(String transformed) { [EOL]                 if (transformed.endsWith(suffix)) { [EOL]                     return transformed.substring(0, transformed.length() - suffix.length()); [EOL]                 } [EOL]                 return null; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String toString() { [EOL]                 return "[SuffixTransformer('" + suffix + "')]"; [EOL]             } [EOL]         }; [EOL]     } [EOL]     return NOP; [EOL] } protected NameTransformer(); public Chained(NameTransformer t1, NameTransformer t2); public String transform(String name); public String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public static NameTransformer simpleTransformer(final String prefix, final String suffix); public static NameTransformer chainedTransformer(NameTransformer t1, NameTransformer t2); public abstract String transform(String name); public abstract String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); NameTransformer NOP=Optional[new NameTransformer() {; ;     @Override;     public String transform(String name) {;         return name;;     }; ;     @Override;     public String reverse(String transformed) {;         // identity transformation is always reversible:;         return transformed;;     }; }
public static NameTransformer simpleTransformer(final String prefix, final String suffix) { [EOL]     boolean hasPrefix = (prefix != null) && (prefix.length() > 0); [EOL]     boolean hasSuffix = (suffix != null) && (suffix.length() > 0); [EOL]     if (hasPrefix) { [EOL]         if (hasSuffix) { [EOL]             return new NameTransformer() { [EOL]  [EOL]                 @Override [EOL]                 public String transform(String name) { [EOL]                     return prefix + name + suffix; [EOL]                 } [EOL]  [EOL]                 @Override [EOL]                 public String reverse(String transformed) { [EOL]                     if (transformed.startsWith(prefix)) { [EOL]                         String str = transformed.substring(prefix.length()); [EOL]                         if (str.endsWith(suffix)) { [EOL]                             return str.substring(0, str.length() - suffix.length()); [EOL]                         } [EOL]                     } [EOL]                     return null; [EOL]                 } [EOL]  [EOL]                 @Override [EOL]                 public String toString() { [EOL]                     return "[PreAndSuffixTransformer('" + prefix + "','" + suffix + "')]"; [EOL]                 } [EOL]             }; [EOL]         } [EOL]         return new NameTransformer() { [EOL]  [EOL]             @Override [EOL]             public String transform(String name) { [EOL]                 return prefix + name; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String reverse(String transformed) { [EOL]                 if (transformed.startsWith(prefix)) { [EOL]                     return transformed.substring(prefix.length()); [EOL]                 } [EOL]                 return null; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String toString() { [EOL]                 return "[PrefixTransformer('" + prefix + "')]"; [EOL]             } [EOL]         }; [EOL]     } [EOL]     if (hasSuffix) { [EOL]         return new NameTransformer() { [EOL]  [EOL]             @Override [EOL]             public String transform(String name) { [EOL]                 return name + suffix; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String reverse(String transformed) { [EOL]                 if (transformed.endsWith(suffix)) { [EOL]                     return transformed.substring(0, transformed.length() - suffix.length()); [EOL]                 } [EOL]                 return null; [EOL]             } [EOL]  [EOL]             @Override [EOL]             public String toString() { [EOL]                 return "[SuffixTransformer('" + suffix + "')]"; [EOL]             } [EOL]         }; [EOL]     } [EOL]     return NOP; [EOL] } protected NameTransformer(); public Chained(NameTransformer t1, NameTransformer t2); public String transform(String name); public String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public String transform(String name); public String reverse(String transformed); public String toString(); public static NameTransformer simpleTransformer(final String prefix, final String suffix); public static NameTransformer chainedTransformer(NameTransformer t1, NameTransformer t2); public abstract String transform(String name); public abstract String reverse(String transformed); public String transform(String name); public String reverse(String transformed); public String toString(); NameTransformer NOP=Optional[new NameTransformer() {; ;     @Override;     public String transform(String name) {;         return name;;     }; ;     @Override;     public String reverse(String transformed) {;         // identity transformation is always reversible:;         return transformed;;     }; }
public AsExternalTypeDeserializer(JavaType bt, TypeIdResolver idRes, String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl) { [EOL]     super(bt, idRes, typePropertyName, typeIdVisible, defaultImpl); [EOL] }
public AsExternalTypeDeserializer(JavaType bt, TypeIdResolver idRes, String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl) { [EOL]     super(bt, idRes, typePropertyName, typeIdVisible, defaultImpl); [EOL] }
public AsExternalTypeDeserializer(AsExternalTypeDeserializer src, BeanProperty property) { [EOL]     super(src, property); [EOL] }
public AsExternalTypeDeserializer(AsExternalTypeDeserializer src, BeanProperty property) { [EOL]     super(src, property); [EOL] }
@Override [EOL] public TypeDeserializer forProperty(BeanProperty prop) { [EOL]     if (prop == _property) { [EOL]         return this; [EOL]     } [EOL]     return new AsExternalTypeDeserializer(this, prop); [EOL] }
@Override [EOL] public TypeDeserializer forProperty(BeanProperty prop) { [EOL]     if (prop == _property) { [EOL]         return this; [EOL]     } [EOL]     return new AsExternalTypeDeserializer(this, prop); [EOL] }
@Override [EOL] public As getTypeInclusion() { [EOL]     return As.EXTERNAL_PROPERTY; [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_TRUE) { [EOL]         return true; [EOL]     } [EOL]     if (t == JsonToken.VALUE_FALSE) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return false; [EOL]     } [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (jp.getNumberType() == NumberType.INT) { [EOL]             return (jp.getIntValue() != 0); [EOL]         } [EOL]         return _parseBooleanFromNumber(jp, ctxt); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if ("true".equals(text)) { [EOL]             return true; [EOL]         } [EOL]         if ("false".equals(text) || text.length() == 0) { [EOL]             return Boolean.FALSE; [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "only \"true\" or \"false\" recognized"); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Short _parseShort(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getShortValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Short) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Short value"); [EOL]         } [EOL]         if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 16-bit value"); [EOL]         } [EOL]         return Short.valueOf((short) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Short) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Short _parseShort(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getShortValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Short) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Short value"); [EOL]         } [EOL]         if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 16-bit value"); [EOL]         } [EOL]         return Short.valueOf((short) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Short) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Short _parseShort(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getShortValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Short) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Short value"); [EOL]         } [EOL]         if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 16-bit value"); [EOL]         } [EOL]         return Short.valueOf((short) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Short) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Short _parseShort(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getShortValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Short) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Short value"); [EOL]         } [EOL]         if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 16-bit value"); [EOL]         } [EOL]         return Short.valueOf((short) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Short) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Short _parseShort(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getShortValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Short) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Short value"); [EOL]         } [EOL]         if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 16-bit value"); [EOL]         } [EOL]         return Short.valueOf((short) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Short) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Short _parseShort(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getShortValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Short) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Short value"); [EOL]         } [EOL]         if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 16-bit value"); [EOL]         } [EOL]         return Short.valueOf((short) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Short) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Short _parseShort(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getShortValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Short) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Short value"); [EOL]         } [EOL]         if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 16-bit value"); [EOL]         } [EOL]         return Short.valueOf((short) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Short) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected Short _parseShort(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getShortValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         int value; [EOL]         try { [EOL]             int len = text.length(); [EOL]             if (len == 0) { [EOL]                 return (Short) getEmptyValue(); [EOL]             } [EOL]             value = NumberInput.parseInt(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid Short value"); [EOL]         } [EOL]         if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "overflow, value can not be represented as 16-bit value"); [EOL]         } [EOL]         return Short.valueOf((short) value); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Short) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final short _parseShortPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     int value = _parseIntPrimitive(jp, ctxt); [EOL]     if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { [EOL]         throw ctxt.weirdStringException(String.valueOf(value), _valueClass, "overflow, value can not be represented as 16-bit value"); [EOL]     } [EOL]     return (short) value; [EOL] }
protected final short _parseShortPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     int value = _parseIntPrimitive(jp, ctxt); [EOL]     if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { [EOL]         throw ctxt.weirdStringException(String.valueOf(value), _valueClass, "overflow, value can not be represented as 16-bit value"); [EOL]     } [EOL]     return (short) value; [EOL] }
protected final short _parseShortPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     int value = _parseIntPrimitive(jp, ctxt); [EOL]     if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) { [EOL]         throw ctxt.weirdStringException(String.valueOf(value), _valueClass, "overflow, value can not be represented as 16-bit value"); [EOL]     } [EOL]     return (short) value; [EOL] }
protected final Long _parseLong(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getLongValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Long) getEmptyValue(); [EOL]         } [EOL]         try { [EOL]             return Long.valueOf(NumberInput.parseLong(text)); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Long value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Long) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final long _parseLongPrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getLongValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0L; [EOL]         } [EOL]         try { [EOL]             return NumberInput.parseLong(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid long value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0L; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getFloatValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return (Float) getEmptyValue(); [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Float.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Float.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Float.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return Float.parseFloat(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid Float value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return (Float) getNullValue(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final double _parseDoublePrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final double _parseDoublePrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final double _parseDoublePrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final double _parseDoublePrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final double _parseDoublePrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final double _parseDoublePrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final double _parseDoublePrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final double _parseDoublePrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected final double _parseDoublePrimitive(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         return jp.getDoubleValue(); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         if (text.length() == 0) { [EOL]             return 0.0; [EOL]         } [EOL]         switch(text.charAt(0)) { [EOL]             case 'I': [EOL]                 if ("Infinity".equals(text) || "INF".equals(text)) { [EOL]                     return Double.POSITIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]             case 'N': [EOL]                 if ("NaN".equals(text)) { [EOL]                     return Double.NaN; [EOL]                 } [EOL]                 break; [EOL]             case '-': [EOL]                 if ("-Infinity".equals(text) || "-INF".equals(text)) { [EOL]                     return Double.NEGATIVE_INFINITY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]         try { [EOL]             return parseDouble(text); [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid double value"); [EOL]     } [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return 0.0; [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
protected void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt, Object instanceOrClass, String propName) throws IOException, JsonProcessingException { [EOL]     if (instanceOrClass == null) { [EOL]         instanceOrClass = getValueClass(); [EOL]     } [EOL]     if (ctxt.handleUnknownProperty(jp, this, instanceOrClass, propName)) { [EOL]         return; [EOL]     } [EOL]     ctxt.reportUnknownProperty(instanceOrClass, propName, this); [EOL]     jp.skipChildren(); [EOL] }
protected void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt, Object instanceOrClass, String propName) throws IOException, JsonProcessingException { [EOL]     if (instanceOrClass == null) { [EOL]         instanceOrClass = getValueClass(); [EOL]     } [EOL]     if (ctxt.handleUnknownProperty(jp, this, instanceOrClass, propName)) { [EOL]         return; [EOL]     } [EOL]     ctxt.reportUnknownProperty(instanceOrClass, propName, this); [EOL]     jp.skipChildren(); [EOL] }
public IterableSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, BeanProperty property) { [EOL]     super(Iterable.class, elemType, staticTyping, vts, property, null); [EOL] }
public IterableSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, BeanProperty property) { [EOL]     super(Iterable.class, elemType, staticTyping, vts, property, null); [EOL] }
public IterableSerializer(IterableSerializer src, BeanProperty property, TypeSerializer vts, JsonSerializer<?> valueSerializer) { [EOL]     super(src, property, vts, valueSerializer); [EOL] }
public IterableSerializer(IterableSerializer src, BeanProperty property, TypeSerializer vts, JsonSerializer<?> valueSerializer) { [EOL]     super(src, property, vts, valueSerializer); [EOL] }
@Override [EOL] public IterableSerializer withResolved(BeanProperty property, TypeSerializer vts, JsonSerializer<?> elementSerializer) { [EOL]     return new IterableSerializer(this, property, vts, elementSerializer); [EOL] }
public AnyGetterWriter(BeanProperty property, AnnotatedMember accessor, MapSerializer serializer) { [EOL]     _accessor = accessor; [EOL]     _property = property; [EOL]     _serializer = serializer; [EOL] }
public void getAndSerialize(Object bean, JsonGenerator jgen, SerializerProvider provider) throws Exception { [EOL]     Object value = _accessor.getValue(bean); [EOL]     if (value == null) { [EOL]         return; [EOL]     } [EOL]     if (!(value instanceof Map<?, ?>)) { [EOL]         throw new JsonMappingException("Value returned by 'any-getter' (" + _accessor.getName() + "()) not java.util.Map but " + value.getClass().getName()); [EOL]     } [EOL]     _serializer.serializeFields((Map<?, ?>) value, jgen, provider); [EOL] }
public void getAndSerialize(Object bean, JsonGenerator jgen, SerializerProvider provider) throws Exception { [EOL]     Object value = _accessor.getValue(bean); [EOL]     if (value == null) { [EOL]         return; [EOL]     } [EOL]     if (!(value instanceof Map<?, ?>)) { [EOL]         throw new JsonMappingException("Value returned by 'any-getter' (" + _accessor.getName() + "()) not java.util.Map but " + value.getClass().getName()); [EOL]     } [EOL]     _serializer.serializeFields((Map<?, ?>) value, jgen, provider); [EOL] }
public void getAndSerialize(Object bean, JsonGenerator jgen, SerializerProvider provider) throws Exception { [EOL]     Object value = _accessor.getValue(bean); [EOL]     if (value == null) { [EOL]         return; [EOL]     } [EOL]     if (!(value instanceof Map<?, ?>)) { [EOL]         throw new JsonMappingException("Value returned by 'any-getter' (" + _accessor.getName() + "()) not java.util.Map but " + value.getClass().getName()); [EOL]     } [EOL]     _serializer.serializeFields((Map<?, ?>) value, jgen, provider); [EOL] }
public void resolve(SerializerProvider provider) throws JsonMappingException { [EOL]     _serializer = (MapSerializer) _serializer.createContextual(provider, _property); [EOL] }
public void resolve(SerializerProvider provider) throws JsonMappingException { [EOL]     _serializer = (MapSerializer) _serializer.createContextual(provider, _property); [EOL] }
protected NumericNode() { [EOL] }
@Override [EOL] public SerializationConfig with(ClassIntrospector ci) { [EOL]     return _withBase(_base.withClassIntrospector(ci)); [EOL] }
@Override [EOL] public SerializationConfig with(PropertyNamingStrategy pns) { [EOL]     return _withBase(_base.withPropertyNamingStrategy(pns)); [EOL] }
@Override [EOL] public SerializationConfig with(PropertyNamingStrategy pns) { [EOL]     return _withBase(_base.withPropertyNamingStrategy(pns)); [EOL] }
@Override [EOL] public SerializationConfig with(TimeZone tz) { [EOL]     return _withBase(_base.with(tz)); [EOL] }
@Override [EOL] public SerializationConfig with(TimeZone tz) { [EOL]     return _withBase(_base.with(tz)); [EOL] }
@Override [EOL] public String toString() { [EOL]     return "[SerializationConfig: flags=0x" + Integer.toHexString(_serFeatures) + "]"; [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == URI.class) { [EOL]         return URIDeserializer.instance; [EOL]     } [EOL]     if (rawType == URL.class) { [EOL]         return URLDeserializer.instance; [EOL]     } [EOL]     if (rawType == File.class) { [EOL]         return FileDeserializer.instance; [EOL]     } [EOL]     if (rawType == UUID.class) { [EOL]         return UUIDDeserializer.instance; [EOL]     } [EOL]     if (rawType == Currency.class) { [EOL]         return CurrencyDeserializer.instance; [EOL]     } [EOL]     if (rawType == Pattern.class) { [EOL]         return PatternDeserializer.instance; [EOL]     } [EOL]     if (rawType == Locale.class) { [EOL]         return LocaleDeserializer.instance; [EOL]     } [EOL]     if (rawType == InetAddress.class) { [EOL]         return InetAddressDeserializer.instance; [EOL]     } [EOL]     if (rawType == Charset.class) { [EOL]         return CharsetDeserializer.instance; [EOL]     } [EOL]     if (rawType == Class.class) { [EOL]         return ClassDeserializer.instance; [EOL]     } [EOL]     if (rawType == StackTraceElement.class) { [EOL]         return StackTraceElementDeserializer.instance; [EOL]     } [EOL]     if (rawType == AtomicBoolean.class) { [EOL]         return AtomicBooleanDeserializer.instance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public URLDeserializer() { [EOL]     super(URL.class); [EOL] }
@Override [EOL] protected URL _deserialize(String value, DeserializationContext ctxt) throws IOException { [EOL]     return new URL(value); [EOL] }
@Override [EOL] protected URL _deserialize(String value, DeserializationContext ctxt) throws IOException { [EOL]     return new URL(value); [EOL] }
public CharsetDeserializer() { [EOL]     super(Charset.class); [EOL] }
@Override [EOL] protected Charset _deserialize(String value, DeserializationContext ctxt) throws IOException { [EOL]     return Charset.forName(value); [EOL] }
@Override [EOL] protected Charset _deserialize(String value, DeserializationContext ctxt) throws IOException { [EOL]     return Charset.forName(value); [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             if (format.getShape().isNumeric()) { [EOL]                 return withFormat(true, null); [EOL]             } [EOL]             TimeZone tz = format.getTimeZone(); [EOL]             String pattern = format.getPattern(); [EOL]             if (pattern.length() > 0) { [EOL]                 Locale loc = format.getLocale(); [EOL]                 if (loc == null) { [EOL]                     loc = prov.getLocale(); [EOL]                 } [EOL]                 SimpleDateFormat df = new SimpleDateFormat(pattern, loc); [EOL]                 if (tz == null) { [EOL]                     tz = prov.getTimeZone(); [EOL]                 } [EOL]                 df.setTimeZone(tz); [EOL]                 return withFormat(false, df); [EOL]             } [EOL]             if (tz != null) { [EOL]                 DateFormat df = prov.getConfig().getDateFormat(); [EOL]                 if (df.getClass() == StdDateFormat.class) { [EOL]                     df = StdDateFormat.getISO8601Format(tz); [EOL]                 } else { [EOL]                     df = (DateFormat) df.clone(); [EOL]                     df.setTimeZone(tz); [EOL]                 } [EOL]                 return withFormat(false, df); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             if (format.getShape().isNumeric()) { [EOL]                 return withFormat(true, null); [EOL]             } [EOL]             TimeZone tz = format.getTimeZone(); [EOL]             String pattern = format.getPattern(); [EOL]             if (pattern.length() > 0) { [EOL]                 Locale loc = format.getLocale(); [EOL]                 if (loc == null) { [EOL]                     loc = prov.getLocale(); [EOL]                 } [EOL]                 SimpleDateFormat df = new SimpleDateFormat(pattern, loc); [EOL]                 if (tz == null) { [EOL]                     tz = prov.getTimeZone(); [EOL]                 } [EOL]                 df.setTimeZone(tz); [EOL]                 return withFormat(false, df); [EOL]             } [EOL]             if (tz != null) { [EOL]                 DateFormat df = prov.getConfig().getDateFormat(); [EOL]                 if (df.getClass() == StdDateFormat.class) { [EOL]                     df = StdDateFormat.getISO8601Format(tz); [EOL]                 } else { [EOL]                     df = (DateFormat) df.clone(); [EOL]                     df.setTimeZone(tz); [EOL]                 } [EOL]                 return withFormat(false, df); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             if (format.getShape().isNumeric()) { [EOL]                 return withFormat(true, null); [EOL]             } [EOL]             TimeZone tz = format.getTimeZone(); [EOL]             String pattern = format.getPattern(); [EOL]             if (pattern.length() > 0) { [EOL]                 Locale loc = format.getLocale(); [EOL]                 if (loc == null) { [EOL]                     loc = prov.getLocale(); [EOL]                 } [EOL]                 SimpleDateFormat df = new SimpleDateFormat(pattern, loc); [EOL]                 if (tz == null) { [EOL]                     tz = prov.getTimeZone(); [EOL]                 } [EOL]                 df.setTimeZone(tz); [EOL]                 return withFormat(false, df); [EOL]             } [EOL]             if (tz != null) { [EOL]                 DateFormat df = prov.getConfig().getDateFormat(); [EOL]                 if (df.getClass() == StdDateFormat.class) { [EOL]                     df = StdDateFormat.getISO8601Format(tz); [EOL]                 } else { [EOL]                     df = (DateFormat) df.clone(); [EOL]                     df.setTimeZone(tz); [EOL]                 } [EOL]                 return withFormat(false, df); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             if (format.getShape().isNumeric()) { [EOL]                 return withFormat(true, null); [EOL]             } [EOL]             TimeZone tz = format.getTimeZone(); [EOL]             String pattern = format.getPattern(); [EOL]             if (pattern.length() > 0) { [EOL]                 Locale loc = format.getLocale(); [EOL]                 if (loc == null) { [EOL]                     loc = prov.getLocale(); [EOL]                 } [EOL]                 SimpleDateFormat df = new SimpleDateFormat(pattern, loc); [EOL]                 if (tz == null) { [EOL]                     tz = prov.getTimeZone(); [EOL]                 } [EOL]                 df.setTimeZone(tz); [EOL]                 return withFormat(false, df); [EOL]             } [EOL]             if (tz != null) { [EOL]                 DateFormat df = prov.getConfig().getDateFormat(); [EOL]                 if (df.getClass() == StdDateFormat.class) { [EOL]                     df = StdDateFormat.getISO8601Format(tz); [EOL]                 } else { [EOL]                     df = (DateFormat) df.clone(); [EOL]                     df.setTimeZone(tz); [EOL]                 } [EOL]                 return withFormat(false, df); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             if (format.getShape().isNumeric()) { [EOL]                 return withFormat(true, null); [EOL]             } [EOL]             TimeZone tz = format.getTimeZone(); [EOL]             String pattern = format.getPattern(); [EOL]             if (pattern.length() > 0) { [EOL]                 Locale loc = format.getLocale(); [EOL]                 if (loc == null) { [EOL]                     loc = prov.getLocale(); [EOL]                 } [EOL]                 SimpleDateFormat df = new SimpleDateFormat(pattern, loc); [EOL]                 if (tz == null) { [EOL]                     tz = prov.getTimeZone(); [EOL]                 } [EOL]                 df.setTimeZone(tz); [EOL]                 return withFormat(false, df); [EOL]             } [EOL]             if (tz != null) { [EOL]                 DateFormat df = prov.getConfig().getDateFormat(); [EOL]                 if (df.getClass() == StdDateFormat.class) { [EOL]                     df = StdDateFormat.getISO8601Format(tz); [EOL]                 } else { [EOL]                     df = (DateFormat) df.clone(); [EOL]                     df.setTimeZone(tz); [EOL]                 } [EOL]                 return withFormat(false, df); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public <A extends Annotation> A getAnnotation(Class<A> acls) { [EOL]     return _annotated.getAnnotation(acls); [EOL] }
@Override [EOL] public <A extends Annotation> A getAnnotation(Class<A> acls) { [EOL]     return _annotated.getAnnotation(acls); [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     ExternalTypeHandler.Builder extTypes = null; [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]         for (SettableBeanProperty prop : _propertyBasedCreator.properties()) { [EOL]             if (prop.hasValueTypeDeserializer()) { [EOL]                 TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]                 if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                     if (extTypes == null) { [EOL]                         extTypes = new ExternalTypeHandler.Builder(); [EOL]                     } [EOL]                     extTypes.addExternal(prop, typeDeser); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     UnwrappedPropertyHandler unwrapped = null; [EOL]     for (SettableBeanProperty origProp : _beanProperties) { [EOL]         SettableBeanProperty prop = origProp; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop); [EOL]             if (deser == null) { [EOL]                 deser = findDeserializer(ctxt, prop.getType(), prop); [EOL]             } [EOL]             prop = prop.withValueDeserializer(deser); [EOL]         } else { [EOL]             JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]             if (deser instanceof ContextualDeserializer) { [EOL]                 JsonDeserializer<?> cd = ((ContextualDeserializer) deser).createContextual(ctxt, prop); [EOL]                 if (cd != deser) { [EOL]                     prop = prop.withValueDeserializer(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop = _resolveManagedReferenceProperty(ctxt, prop); [EOL]         SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop); [EOL]         if (u != null) { [EOL]             prop = u; [EOL]             if (unwrapped == null) { [EOL]                 unwrapped = new UnwrappedPropertyHandler(); [EOL]             } [EOL]             unwrapped.addProperty(prop); [EOL]             continue; [EOL]         } [EOL]         prop = _resolveInnerClassValuedProperty(ctxt, prop); [EOL]         if (prop != origProp) { [EOL]             _beanProperties.replace(prop); [EOL]         } [EOL]         if (prop.hasValueTypeDeserializer()) { [EOL]             TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]             if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                 if (extTypes == null) { [EOL]                     extTypes = new ExternalTypeHandler.Builder(); [EOL]                 } [EOL]                 extTypes.addExternal(prop, typeDeser); [EOL]                 _beanProperties.remove(prop); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anySetter != null && !_anySetter.hasValueDeserializer()) { [EOL]         _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty())); [EOL]     } [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _beanType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         BeanProperty.Std property = new BeanProperty.Std(null, delegateType, null, _classAnnotations, delegateCreator, false); [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     if (extTypes != null) { [EOL]         _externalTypeIdHandler = extTypes.build(); [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _unwrappedPropertyHandler = unwrapped; [EOL]     if (unwrapped != null) { [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation; [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     ExternalTypeHandler.Builder extTypes = null; [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]         for (SettableBeanProperty prop : _propertyBasedCreator.properties()) { [EOL]             if (prop.hasValueTypeDeserializer()) { [EOL]                 TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]                 if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                     if (extTypes == null) { [EOL]                         extTypes = new ExternalTypeHandler.Builder(); [EOL]                     } [EOL]                     extTypes.addExternal(prop, typeDeser); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     UnwrappedPropertyHandler unwrapped = null; [EOL]     for (SettableBeanProperty origProp : _beanProperties) { [EOL]         SettableBeanProperty prop = origProp; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop); [EOL]             if (deser == null) { [EOL]                 deser = findDeserializer(ctxt, prop.getType(), prop); [EOL]             } [EOL]             prop = prop.withValueDeserializer(deser); [EOL]         } else { [EOL]             JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]             if (deser instanceof ContextualDeserializer) { [EOL]                 JsonDeserializer<?> cd = ((ContextualDeserializer) deser).createContextual(ctxt, prop); [EOL]                 if (cd != deser) { [EOL]                     prop = prop.withValueDeserializer(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop = _resolveManagedReferenceProperty(ctxt, prop); [EOL]         SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop); [EOL]         if (u != null) { [EOL]             prop = u; [EOL]             if (unwrapped == null) { [EOL]                 unwrapped = new UnwrappedPropertyHandler(); [EOL]             } [EOL]             unwrapped.addProperty(prop); [EOL]             continue; [EOL]         } [EOL]         prop = _resolveInnerClassValuedProperty(ctxt, prop); [EOL]         if (prop != origProp) { [EOL]             _beanProperties.replace(prop); [EOL]         } [EOL]         if (prop.hasValueTypeDeserializer()) { [EOL]             TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]             if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                 if (extTypes == null) { [EOL]                     extTypes = new ExternalTypeHandler.Builder(); [EOL]                 } [EOL]                 extTypes.addExternal(prop, typeDeser); [EOL]                 _beanProperties.remove(prop); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anySetter != null && !_anySetter.hasValueDeserializer()) { [EOL]         _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty())); [EOL]     } [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _beanType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         BeanProperty.Std property = new BeanProperty.Std(null, delegateType, null, _classAnnotations, delegateCreator, false); [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     if (extTypes != null) { [EOL]         _externalTypeIdHandler = extTypes.build(); [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _unwrappedPropertyHandler = unwrapped; [EOL]     if (unwrapped != null) { [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation; [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     ExternalTypeHandler.Builder extTypes = null; [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]         for (SettableBeanProperty prop : _propertyBasedCreator.properties()) { [EOL]             if (prop.hasValueTypeDeserializer()) { [EOL]                 TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]                 if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                     if (extTypes == null) { [EOL]                         extTypes = new ExternalTypeHandler.Builder(); [EOL]                     } [EOL]                     extTypes.addExternal(prop, typeDeser); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     UnwrappedPropertyHandler unwrapped = null; [EOL]     for (SettableBeanProperty origProp : _beanProperties) { [EOL]         SettableBeanProperty prop = origProp; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop); [EOL]             if (deser == null) { [EOL]                 deser = findDeserializer(ctxt, prop.getType(), prop); [EOL]             } [EOL]             prop = prop.withValueDeserializer(deser); [EOL]         } else { [EOL]             JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]             if (deser instanceof ContextualDeserializer) { [EOL]                 JsonDeserializer<?> cd = ((ContextualDeserializer) deser).createContextual(ctxt, prop); [EOL]                 if (cd != deser) { [EOL]                     prop = prop.withValueDeserializer(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop = _resolveManagedReferenceProperty(ctxt, prop); [EOL]         SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop); [EOL]         if (u != null) { [EOL]             prop = u; [EOL]             if (unwrapped == null) { [EOL]                 unwrapped = new UnwrappedPropertyHandler(); [EOL]             } [EOL]             unwrapped.addProperty(prop); [EOL]             continue; [EOL]         } [EOL]         prop = _resolveInnerClassValuedProperty(ctxt, prop); [EOL]         if (prop != origProp) { [EOL]             _beanProperties.replace(prop); [EOL]         } [EOL]         if (prop.hasValueTypeDeserializer()) { [EOL]             TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]             if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                 if (extTypes == null) { [EOL]                     extTypes = new ExternalTypeHandler.Builder(); [EOL]                 } [EOL]                 extTypes.addExternal(prop, typeDeser); [EOL]                 _beanProperties.remove(prop); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anySetter != null && !_anySetter.hasValueDeserializer()) { [EOL]         _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty())); [EOL]     } [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _beanType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         BeanProperty.Std property = new BeanProperty.Std(null, delegateType, null, _classAnnotations, delegateCreator, false); [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     if (extTypes != null) { [EOL]         _externalTypeIdHandler = extTypes.build(); [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _unwrappedPropertyHandler = unwrapped; [EOL]     if (unwrapped != null) { [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation; [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     ExternalTypeHandler.Builder extTypes = null; [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]         for (SettableBeanProperty prop : _propertyBasedCreator.properties()) { [EOL]             if (prop.hasValueTypeDeserializer()) { [EOL]                 TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]                 if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                     if (extTypes == null) { [EOL]                         extTypes = new ExternalTypeHandler.Builder(); [EOL]                     } [EOL]                     extTypes.addExternal(prop, typeDeser); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     UnwrappedPropertyHandler unwrapped = null; [EOL]     for (SettableBeanProperty origProp : _beanProperties) { [EOL]         SettableBeanProperty prop = origProp; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop); [EOL]             if (deser == null) { [EOL]                 deser = findDeserializer(ctxt, prop.getType(), prop); [EOL]             } [EOL]             prop = prop.withValueDeserializer(deser); [EOL]         } else { [EOL]             JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]             if (deser instanceof ContextualDeserializer) { [EOL]                 JsonDeserializer<?> cd = ((ContextualDeserializer) deser).createContextual(ctxt, prop); [EOL]                 if (cd != deser) { [EOL]                     prop = prop.withValueDeserializer(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop = _resolveManagedReferenceProperty(ctxt, prop); [EOL]         SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop); [EOL]         if (u != null) { [EOL]             prop = u; [EOL]             if (unwrapped == null) { [EOL]                 unwrapped = new UnwrappedPropertyHandler(); [EOL]             } [EOL]             unwrapped.addProperty(prop); [EOL]             continue; [EOL]         } [EOL]         prop = _resolveInnerClassValuedProperty(ctxt, prop); [EOL]         if (prop != origProp) { [EOL]             _beanProperties.replace(prop); [EOL]         } [EOL]         if (prop.hasValueTypeDeserializer()) { [EOL]             TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]             if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                 if (extTypes == null) { [EOL]                     extTypes = new ExternalTypeHandler.Builder(); [EOL]                 } [EOL]                 extTypes.addExternal(prop, typeDeser); [EOL]                 _beanProperties.remove(prop); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anySetter != null && !_anySetter.hasValueDeserializer()) { [EOL]         _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty())); [EOL]     } [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _beanType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         BeanProperty.Std property = new BeanProperty.Std(null, delegateType, null, _classAnnotations, delegateCreator, false); [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     if (extTypes != null) { [EOL]         _externalTypeIdHandler = extTypes.build(); [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _unwrappedPropertyHandler = unwrapped; [EOL]     if (unwrapped != null) { [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation; [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     ExternalTypeHandler.Builder extTypes = null; [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]         for (SettableBeanProperty prop : _propertyBasedCreator.properties()) { [EOL]             if (prop.hasValueTypeDeserializer()) { [EOL]                 TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]                 if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                     if (extTypes == null) { [EOL]                         extTypes = new ExternalTypeHandler.Builder(); [EOL]                     } [EOL]                     extTypes.addExternal(prop, typeDeser); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     UnwrappedPropertyHandler unwrapped = null; [EOL]     for (SettableBeanProperty origProp : _beanProperties) { [EOL]         SettableBeanProperty prop = origProp; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop); [EOL]             if (deser == null) { [EOL]                 deser = findDeserializer(ctxt, prop.getType(), prop); [EOL]             } [EOL]             prop = prop.withValueDeserializer(deser); [EOL]         } else { [EOL]             JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]             if (deser instanceof ContextualDeserializer) { [EOL]                 JsonDeserializer<?> cd = ((ContextualDeserializer) deser).createContextual(ctxt, prop); [EOL]                 if (cd != deser) { [EOL]                     prop = prop.withValueDeserializer(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop = _resolveManagedReferenceProperty(ctxt, prop); [EOL]         SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop); [EOL]         if (u != null) { [EOL]             prop = u; [EOL]             if (unwrapped == null) { [EOL]                 unwrapped = new UnwrappedPropertyHandler(); [EOL]             } [EOL]             unwrapped.addProperty(prop); [EOL]             continue; [EOL]         } [EOL]         prop = _resolveInnerClassValuedProperty(ctxt, prop); [EOL]         if (prop != origProp) { [EOL]             _beanProperties.replace(prop); [EOL]         } [EOL]         if (prop.hasValueTypeDeserializer()) { [EOL]             TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]             if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                 if (extTypes == null) { [EOL]                     extTypes = new ExternalTypeHandler.Builder(); [EOL]                 } [EOL]                 extTypes.addExternal(prop, typeDeser); [EOL]                 _beanProperties.remove(prop); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anySetter != null && !_anySetter.hasValueDeserializer()) { [EOL]         _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty())); [EOL]     } [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _beanType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         BeanProperty.Std property = new BeanProperty.Std(null, delegateType, null, _classAnnotations, delegateCreator, false); [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     if (extTypes != null) { [EOL]         _externalTypeIdHandler = extTypes.build(); [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _unwrappedPropertyHandler = unwrapped; [EOL]     if (unwrapped != null) { [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation; [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     ExternalTypeHandler.Builder extTypes = null; [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]         for (SettableBeanProperty prop : _propertyBasedCreator.properties()) { [EOL]             if (prop.hasValueTypeDeserializer()) { [EOL]                 TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]                 if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                     if (extTypes == null) { [EOL]                         extTypes = new ExternalTypeHandler.Builder(); [EOL]                     } [EOL]                     extTypes.addExternal(prop, typeDeser); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     UnwrappedPropertyHandler unwrapped = null; [EOL]     for (SettableBeanProperty origProp : _beanProperties) { [EOL]         SettableBeanProperty prop = origProp; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop); [EOL]             if (deser == null) { [EOL]                 deser = findDeserializer(ctxt, prop.getType(), prop); [EOL]             } [EOL]             prop = prop.withValueDeserializer(deser); [EOL]         } else { [EOL]             JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]             if (deser instanceof ContextualDeserializer) { [EOL]                 JsonDeserializer<?> cd = ((ContextualDeserializer) deser).createContextual(ctxt, prop); [EOL]                 if (cd != deser) { [EOL]                     prop = prop.withValueDeserializer(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop = _resolveManagedReferenceProperty(ctxt, prop); [EOL]         SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop); [EOL]         if (u != null) { [EOL]             prop = u; [EOL]             if (unwrapped == null) { [EOL]                 unwrapped = new UnwrappedPropertyHandler(); [EOL]             } [EOL]             unwrapped.addProperty(prop); [EOL]             continue; [EOL]         } [EOL]         prop = _resolveInnerClassValuedProperty(ctxt, prop); [EOL]         if (prop != origProp) { [EOL]             _beanProperties.replace(prop); [EOL]         } [EOL]         if (prop.hasValueTypeDeserializer()) { [EOL]             TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]             if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                 if (extTypes == null) { [EOL]                     extTypes = new ExternalTypeHandler.Builder(); [EOL]                 } [EOL]                 extTypes.addExternal(prop, typeDeser); [EOL]                 _beanProperties.remove(prop); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anySetter != null && !_anySetter.hasValueDeserializer()) { [EOL]         _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty())); [EOL]     } [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _beanType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         BeanProperty.Std property = new BeanProperty.Std(null, delegateType, null, _classAnnotations, delegateCreator, false); [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     if (extTypes != null) { [EOL]         _externalTypeIdHandler = extTypes.build(); [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _unwrappedPropertyHandler = unwrapped; [EOL]     if (unwrapped != null) { [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation; [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     ExternalTypeHandler.Builder extTypes = null; [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]         for (SettableBeanProperty prop : _propertyBasedCreator.properties()) { [EOL]             if (prop.hasValueTypeDeserializer()) { [EOL]                 TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]                 if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                     if (extTypes == null) { [EOL]                         extTypes = new ExternalTypeHandler.Builder(); [EOL]                     } [EOL]                     extTypes.addExternal(prop, typeDeser); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     UnwrappedPropertyHandler unwrapped = null; [EOL]     for (SettableBeanProperty origProp : _beanProperties) { [EOL]         SettableBeanProperty prop = origProp; [EOL]         if (!prop.hasValueDeserializer()) { [EOL]             JsonDeserializer<?> deser = findConvertingDeserializer(ctxt, prop); [EOL]             if (deser == null) { [EOL]                 deser = findDeserializer(ctxt, prop.getType(), prop); [EOL]             } [EOL]             prop = prop.withValueDeserializer(deser); [EOL]         } else { [EOL]             JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]             if (deser instanceof ContextualDeserializer) { [EOL]                 JsonDeserializer<?> cd = ((ContextualDeserializer) deser).createContextual(ctxt, prop); [EOL]                 if (cd != deser) { [EOL]                     prop = prop.withValueDeserializer(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]         prop = _resolveManagedReferenceProperty(ctxt, prop); [EOL]         SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop); [EOL]         if (u != null) { [EOL]             prop = u; [EOL]             if (unwrapped == null) { [EOL]                 unwrapped = new UnwrappedPropertyHandler(); [EOL]             } [EOL]             unwrapped.addProperty(prop); [EOL]             continue; [EOL]         } [EOL]         prop = _resolveInnerClassValuedProperty(ctxt, prop); [EOL]         if (prop != origProp) { [EOL]             _beanProperties.replace(prop); [EOL]         } [EOL]         if (prop.hasValueTypeDeserializer()) { [EOL]             TypeDeserializer typeDeser = prop.getValueTypeDeserializer(); [EOL]             if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) { [EOL]                 if (extTypes == null) { [EOL]                     extTypes = new ExternalTypeHandler.Builder(); [EOL]                 } [EOL]                 extTypes.addExternal(prop, typeDeser); [EOL]                 _beanProperties.remove(prop); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_anySetter != null && !_anySetter.hasValueDeserializer()) { [EOL]         _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty())); [EOL]     } [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _beanType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator(); [EOL]         BeanProperty.Std property = new BeanProperty.Std(null, delegateType, null, _classAnnotations, delegateCreator, false); [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, property); [EOL]     } [EOL]     if (extTypes != null) { [EOL]         _externalTypeIdHandler = extTypes.build(); [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _unwrappedPropertyHandler = unwrapped; [EOL]     if (unwrapped != null) { [EOL]         _nonStandardCreation = true; [EOL]     } [EOL]     _vanillaProcessing = _vanillaProcessing && !_nonStandardCreation; [EOL] }
protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     String refName = prop.getManagedReferenceName(); [EOL]     if (refName == null) { [EOL]         return prop; [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = prop.getValueDeserializer(); [EOL]     SettableBeanProperty backProp = null; [EOL]     boolean isContainer = false; [EOL]     if (valueDeser instanceof BeanDeserializerBase) { [EOL]         backProp = ((BeanDeserializerBase) valueDeser).findBackReference(refName); [EOL]     } else if (valueDeser instanceof ContainerDeserializerBase<?>) { [EOL]         JsonDeserializer<?> contentDeser = ((ContainerDeserializerBase<?>) valueDeser).getContentDeserializer(); [EOL]         if (!(contentDeser instanceof BeanDeserializerBase)) { [EOL]             String deserName = (contentDeser == null) ? "NULL" : contentDeser.getClass().getName(); [EOL]             throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': value deserializer is of type ContainerDeserializerBase, but content type is not handled by a BeanDeserializer " + " (instead it's of type " + deserName + ")"); [EOL]         } [EOL]         backProp = ((BeanDeserializerBase) contentDeser).findBackReference(refName); [EOL]         isContainer = true; [EOL]     } else if (valueDeser instanceof AbstractDeserializer) { [EOL]         backProp = ((AbstractDeserializer) valueDeser).findBackReference(refName); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': type for value deserializer is not BeanDeserializer or ContainerDeserializerBase, but " + valueDeser.getClass().getName()); [EOL]     } [EOL]     if (backProp == null) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': no back reference property found from type " + prop.getType()); [EOL]     } [EOL]     JavaType referredType = _beanType; [EOL]     JavaType backRefType = backProp.getType(); [EOL]     if (!backRefType.getRawClass().isAssignableFrom(referredType.getRawClass())) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': back reference type (" + backRefType.getRawClass().getName() + ") not compatible with managed type (" + referredType.getRawClass().getName() + ")"); [EOL]     } [EOL]     return new ManagedReferenceProperty(prop, refName, backProp, _classAnnotations, isContainer); [EOL] }
protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     String refName = prop.getManagedReferenceName(); [EOL]     if (refName == null) { [EOL]         return prop; [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = prop.getValueDeserializer(); [EOL]     SettableBeanProperty backProp = null; [EOL]     boolean isContainer = false; [EOL]     if (valueDeser instanceof BeanDeserializerBase) { [EOL]         backProp = ((BeanDeserializerBase) valueDeser).findBackReference(refName); [EOL]     } else if (valueDeser instanceof ContainerDeserializerBase<?>) { [EOL]         JsonDeserializer<?> contentDeser = ((ContainerDeserializerBase<?>) valueDeser).getContentDeserializer(); [EOL]         if (!(contentDeser instanceof BeanDeserializerBase)) { [EOL]             String deserName = (contentDeser == null) ? "NULL" : contentDeser.getClass().getName(); [EOL]             throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': value deserializer is of type ContainerDeserializerBase, but content type is not handled by a BeanDeserializer " + " (instead it's of type " + deserName + ")"); [EOL]         } [EOL]         backProp = ((BeanDeserializerBase) contentDeser).findBackReference(refName); [EOL]         isContainer = true; [EOL]     } else if (valueDeser instanceof AbstractDeserializer) { [EOL]         backProp = ((AbstractDeserializer) valueDeser).findBackReference(refName); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': type for value deserializer is not BeanDeserializer or ContainerDeserializerBase, but " + valueDeser.getClass().getName()); [EOL]     } [EOL]     if (backProp == null) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': no back reference property found from type " + prop.getType()); [EOL]     } [EOL]     JavaType referredType = _beanType; [EOL]     JavaType backRefType = backProp.getType(); [EOL]     if (!backRefType.getRawClass().isAssignableFrom(referredType.getRawClass())) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': back reference type (" + backRefType.getRawClass().getName() + ") not compatible with managed type (" + referredType.getRawClass().getName() + ")"); [EOL]     } [EOL]     return new ManagedReferenceProperty(prop, refName, backProp, _classAnnotations, isContainer); [EOL] }
protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     String refName = prop.getManagedReferenceName(); [EOL]     if (refName == null) { [EOL]         return prop; [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = prop.getValueDeserializer(); [EOL]     SettableBeanProperty backProp = null; [EOL]     boolean isContainer = false; [EOL]     if (valueDeser instanceof BeanDeserializerBase) { [EOL]         backProp = ((BeanDeserializerBase) valueDeser).findBackReference(refName); [EOL]     } else if (valueDeser instanceof ContainerDeserializerBase<?>) { [EOL]         JsonDeserializer<?> contentDeser = ((ContainerDeserializerBase<?>) valueDeser).getContentDeserializer(); [EOL]         if (!(contentDeser instanceof BeanDeserializerBase)) { [EOL]             String deserName = (contentDeser == null) ? "NULL" : contentDeser.getClass().getName(); [EOL]             throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': value deserializer is of type ContainerDeserializerBase, but content type is not handled by a BeanDeserializer " + " (instead it's of type " + deserName + ")"); [EOL]         } [EOL]         backProp = ((BeanDeserializerBase) contentDeser).findBackReference(refName); [EOL]         isContainer = true; [EOL]     } else if (valueDeser instanceof AbstractDeserializer) { [EOL]         backProp = ((AbstractDeserializer) valueDeser).findBackReference(refName); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': type for value deserializer is not BeanDeserializer or ContainerDeserializerBase, but " + valueDeser.getClass().getName()); [EOL]     } [EOL]     if (backProp == null) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': no back reference property found from type " + prop.getType()); [EOL]     } [EOL]     JavaType referredType = _beanType; [EOL]     JavaType backRefType = backProp.getType(); [EOL]     if (!backRefType.getRawClass().isAssignableFrom(referredType.getRawClass())) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': back reference type (" + backRefType.getRawClass().getName() + ") not compatible with managed type (" + referredType.getRawClass().getName() + ")"); [EOL]     } [EOL]     return new ManagedReferenceProperty(prop, refName, backProp, _classAnnotations, isContainer); [EOL] }
protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     String refName = prop.getManagedReferenceName(); [EOL]     if (refName == null) { [EOL]         return prop; [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = prop.getValueDeserializer(); [EOL]     SettableBeanProperty backProp = null; [EOL]     boolean isContainer = false; [EOL]     if (valueDeser instanceof BeanDeserializerBase) { [EOL]         backProp = ((BeanDeserializerBase) valueDeser).findBackReference(refName); [EOL]     } else if (valueDeser instanceof ContainerDeserializerBase<?>) { [EOL]         JsonDeserializer<?> contentDeser = ((ContainerDeserializerBase<?>) valueDeser).getContentDeserializer(); [EOL]         if (!(contentDeser instanceof BeanDeserializerBase)) { [EOL]             String deserName = (contentDeser == null) ? "NULL" : contentDeser.getClass().getName(); [EOL]             throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': value deserializer is of type ContainerDeserializerBase, but content type is not handled by a BeanDeserializer " + " (instead it's of type " + deserName + ")"); [EOL]         } [EOL]         backProp = ((BeanDeserializerBase) contentDeser).findBackReference(refName); [EOL]         isContainer = true; [EOL]     } else if (valueDeser instanceof AbstractDeserializer) { [EOL]         backProp = ((AbstractDeserializer) valueDeser).findBackReference(refName); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': type for value deserializer is not BeanDeserializer or ContainerDeserializerBase, but " + valueDeser.getClass().getName()); [EOL]     } [EOL]     if (backProp == null) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': no back reference property found from type " + prop.getType()); [EOL]     } [EOL]     JavaType referredType = _beanType; [EOL]     JavaType backRefType = backProp.getType(); [EOL]     if (!backRefType.getRawClass().isAssignableFrom(referredType.getRawClass())) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': back reference type (" + backRefType.getRawClass().getName() + ") not compatible with managed type (" + referredType.getRawClass().getName() + ")"); [EOL]     } [EOL]     return new ManagedReferenceProperty(prop, refName, backProp, _classAnnotations, isContainer); [EOL] }
protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     String refName = prop.getManagedReferenceName(); [EOL]     if (refName == null) { [EOL]         return prop; [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = prop.getValueDeserializer(); [EOL]     SettableBeanProperty backProp = null; [EOL]     boolean isContainer = false; [EOL]     if (valueDeser instanceof BeanDeserializerBase) { [EOL]         backProp = ((BeanDeserializerBase) valueDeser).findBackReference(refName); [EOL]     } else if (valueDeser instanceof ContainerDeserializerBase<?>) { [EOL]         JsonDeserializer<?> contentDeser = ((ContainerDeserializerBase<?>) valueDeser).getContentDeserializer(); [EOL]         if (!(contentDeser instanceof BeanDeserializerBase)) { [EOL]             String deserName = (contentDeser == null) ? "NULL" : contentDeser.getClass().getName(); [EOL]             throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': value deserializer is of type ContainerDeserializerBase, but content type is not handled by a BeanDeserializer " + " (instead it's of type " + deserName + ")"); [EOL]         } [EOL]         backProp = ((BeanDeserializerBase) contentDeser).findBackReference(refName); [EOL]         isContainer = true; [EOL]     } else if (valueDeser instanceof AbstractDeserializer) { [EOL]         backProp = ((AbstractDeserializer) valueDeser).findBackReference(refName); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': type for value deserializer is not BeanDeserializer or ContainerDeserializerBase, but " + valueDeser.getClass().getName()); [EOL]     } [EOL]     if (backProp == null) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': no back reference property found from type " + prop.getType()); [EOL]     } [EOL]     JavaType referredType = _beanType; [EOL]     JavaType backRefType = backProp.getType(); [EOL]     if (!backRefType.getRawClass().isAssignableFrom(referredType.getRawClass())) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': back reference type (" + backRefType.getRawClass().getName() + ") not compatible with managed type (" + referredType.getRawClass().getName() + ")"); [EOL]     } [EOL]     return new ManagedReferenceProperty(prop, refName, backProp, _classAnnotations, isContainer); [EOL] }
protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     String refName = prop.getManagedReferenceName(); [EOL]     if (refName == null) { [EOL]         return prop; [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = prop.getValueDeserializer(); [EOL]     SettableBeanProperty backProp = null; [EOL]     boolean isContainer = false; [EOL]     if (valueDeser instanceof BeanDeserializerBase) { [EOL]         backProp = ((BeanDeserializerBase) valueDeser).findBackReference(refName); [EOL]     } else if (valueDeser instanceof ContainerDeserializerBase<?>) { [EOL]         JsonDeserializer<?> contentDeser = ((ContainerDeserializerBase<?>) valueDeser).getContentDeserializer(); [EOL]         if (!(contentDeser instanceof BeanDeserializerBase)) { [EOL]             String deserName = (contentDeser == null) ? "NULL" : contentDeser.getClass().getName(); [EOL]             throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': value deserializer is of type ContainerDeserializerBase, but content type is not handled by a BeanDeserializer " + " (instead it's of type " + deserName + ")"); [EOL]         } [EOL]         backProp = ((BeanDeserializerBase) contentDeser).findBackReference(refName); [EOL]         isContainer = true; [EOL]     } else if (valueDeser instanceof AbstractDeserializer) { [EOL]         backProp = ((AbstractDeserializer) valueDeser).findBackReference(refName); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': type for value deserializer is not BeanDeserializer or ContainerDeserializerBase, but " + valueDeser.getClass().getName()); [EOL]     } [EOL]     if (backProp == null) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': no back reference property found from type " + prop.getType()); [EOL]     } [EOL]     JavaType referredType = _beanType; [EOL]     JavaType backRefType = backProp.getType(); [EOL]     if (!backRefType.getRawClass().isAssignableFrom(referredType.getRawClass())) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': back reference type (" + backRefType.getRawClass().getName() + ") not compatible with managed type (" + referredType.getRawClass().getName() + ")"); [EOL]     } [EOL]     return new ManagedReferenceProperty(prop, refName, backProp, _classAnnotations, isContainer); [EOL] }
protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     String refName = prop.getManagedReferenceName(); [EOL]     if (refName == null) { [EOL]         return prop; [EOL]     } [EOL]     JsonDeserializer<?> valueDeser = prop.getValueDeserializer(); [EOL]     SettableBeanProperty backProp = null; [EOL]     boolean isContainer = false; [EOL]     if (valueDeser instanceof BeanDeserializerBase) { [EOL]         backProp = ((BeanDeserializerBase) valueDeser).findBackReference(refName); [EOL]     } else if (valueDeser instanceof ContainerDeserializerBase<?>) { [EOL]         JsonDeserializer<?> contentDeser = ((ContainerDeserializerBase<?>) valueDeser).getContentDeserializer(); [EOL]         if (!(contentDeser instanceof BeanDeserializerBase)) { [EOL]             String deserName = (contentDeser == null) ? "NULL" : contentDeser.getClass().getName(); [EOL]             throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': value deserializer is of type ContainerDeserializerBase, but content type is not handled by a BeanDeserializer " + " (instead it's of type " + deserName + ")"); [EOL]         } [EOL]         backProp = ((BeanDeserializerBase) contentDeser).findBackReference(refName); [EOL]         isContainer = true; [EOL]     } else if (valueDeser instanceof AbstractDeserializer) { [EOL]         backProp = ((AbstractDeserializer) valueDeser).findBackReference(refName); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': type for value deserializer is not BeanDeserializer or ContainerDeserializerBase, but " + valueDeser.getClass().getName()); [EOL]     } [EOL]     if (backProp == null) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': no back reference property found from type " + prop.getType()); [EOL]     } [EOL]     JavaType referredType = _beanType; [EOL]     JavaType backRefType = backProp.getType(); [EOL]     if (!backRefType.getRawClass().isAssignableFrom(referredType.getRawClass())) { [EOL]         throw new IllegalArgumentException("Can not handle managed/back reference '" + refName + "': back reference type (" + backRefType.getRawClass().getName() + ") not compatible with managed type (" + referredType.getRawClass().getName() + ")"); [EOL]     } [EOL]     return new ManagedReferenceProperty(prop, refName, backProp, _classAnnotations, isContainer); [EOL] }
protected SettableBeanProperty _resolveInnerClassValuedProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]     if (deser instanceof BeanDeserializerBase) { [EOL]         BeanDeserializerBase bd = (BeanDeserializerBase) deser; [EOL]         ValueInstantiator vi = bd.getValueInstantiator(); [EOL]         if (!vi.canCreateUsingDefault()) { [EOL]             Class<?> valueClass = prop.getType().getRawClass(); [EOL]             Class<?> enclosing = ClassUtil.getOuterClass(valueClass); [EOL]             if (enclosing != null && enclosing == _beanType.getRawClass()) { [EOL]                 for (Constructor<?> ctor : valueClass.getConstructors()) { [EOL]                     Class<?>[] paramTypes = ctor.getParameterTypes(); [EOL]                     if (paramTypes.length == 1 && paramTypes[0] == enclosing) { [EOL]                         if (ctxt.getConfig().canOverrideAccessModifiers()) { [EOL]                             ClassUtil.checkAndFixAccess(ctor); [EOL]                         } [EOL]                         return new InnerClassProperty(prop, ctor); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return prop; [EOL] }
protected SettableBeanProperty _resolveInnerClassValuedProperty(DeserializationContext ctxt, SettableBeanProperty prop) { [EOL]     JsonDeserializer<Object> deser = prop.getValueDeserializer(); [EOL]     if (deser instanceof BeanDeserializerBase) { [EOL]         BeanDeserializerBase bd = (BeanDeserializerBase) deser; [EOL]         ValueInstantiator vi = bd.getValueInstantiator(); [EOL]         if (!vi.canCreateUsingDefault()) { [EOL]             Class<?> valueClass = prop.getType().getRawClass(); [EOL]             Class<?> enclosing = ClassUtil.getOuterClass(valueClass); [EOL]             if (enclosing != null && enclosing == _beanType.getRawClass()) { [EOL]                 for (Constructor<?> ctor : valueClass.getConstructors()) { [EOL]                     Class<?>[] paramTypes = ctor.getParameterTypes(); [EOL]                     if (paramTypes.length == 1 && paramTypes[0] == enclosing) { [EOL]                         if (ctxt.getConfig().canOverrideAccessModifiers()) { [EOL]                             ClassUtil.checkAndFixAccess(ctor); [EOL]                         } [EOL]                         return new InnerClassProperty(prop, ctor); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return prop; [EOL] }
@Override [EOL] public Collection<Object> getKnownPropertyNames() { [EOL]     ArrayList<Object> names = new ArrayList<Object>(); [EOL]     for (SettableBeanProperty prop : _beanProperties) { [EOL]         names.add(prop.getName()); [EOL]     } [EOL]     return names; [EOL] }
@Override [EOL] public Collection<Object> getKnownPropertyNames() { [EOL]     ArrayList<Object> names = new ArrayList<Object>(); [EOL]     for (SettableBeanProperty prop : _beanProperties) { [EOL]         names.add(prop.getName()); [EOL]     } [EOL]     return names; [EOL] }
protected Object deserializeFromObjectUsingNonDefault(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     throw JsonMappingException.from(jp, "No suitable constructor found for type " + _beanType + ": can not instantiate from JSON object (need to add/enable type information?)"); [EOL] }
protected Object deserializeFromObjectUsingNonDefault(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     throw JsonMappingException.from(jp, "No suitable constructor found for type " + _beanType + ": can not instantiate from JSON object (need to add/enable type information?)"); [EOL] }
protected Object deserializeFromObjectUsingNonDefault(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     throw JsonMappingException.from(jp, "No suitable constructor found for type " + _beanType + ": can not instantiate from JSON object (need to add/enable type information?)"); [EOL] }
protected Object deserializeFromObjectUsingNonDefault(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_delegateDeserializer != null) { [EOL]         return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingPropertyBased(jp, ctxt); [EOL]     } [EOL]     if (_beanType.isAbstract()) { [EOL]         throw JsonMappingException.from(jp, "Can not instantiate abstract type " + _beanType + " (need to add/enable type information?)"); [EOL]     } [EOL]     throw JsonMappingException.from(jp, "No suitable constructor found for type " + _beanType + ": can not instantiate from JSON object (need to add/enable type information?)"); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public Object deserializeFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         return deserializeFromObjectId(jp, ctxt); [EOL]     } [EOL]     switch(jp.getNumberType()) { [EOL]         case INT: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromInt(ctxt, jp.getIntValue()); [EOL]         case LONG: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromLong(ctxt, jp.getLongValue()); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]         if (_injectables != null) { [EOL]             injectValues(ctxt, bean); [EOL]         } [EOL]         return bean; [EOL]     } [EOL]     throw ctxt.instantiationException(getBeanClass(), "no suitable creator method found to deserialize from JSON integer number"); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public Object deserializeFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         return deserializeFromObjectId(jp, ctxt); [EOL]     } [EOL]     switch(jp.getNumberType()) { [EOL]         case INT: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromInt(ctxt, jp.getIntValue()); [EOL]         case LONG: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromLong(ctxt, jp.getLongValue()); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]         if (_injectables != null) { [EOL]             injectValues(ctxt, bean); [EOL]         } [EOL]         return bean; [EOL]     } [EOL]     throw ctxt.instantiationException(getBeanClass(), "no suitable creator method found to deserialize from JSON integer number"); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public Object deserializeFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         return deserializeFromObjectId(jp, ctxt); [EOL]     } [EOL]     switch(jp.getNumberType()) { [EOL]         case INT: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromInt(ctxt, jp.getIntValue()); [EOL]         case LONG: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromLong(ctxt, jp.getLongValue()); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]         if (_injectables != null) { [EOL]             injectValues(ctxt, bean); [EOL]         } [EOL]         return bean; [EOL]     } [EOL]     throw ctxt.instantiationException(getBeanClass(), "no suitable creator method found to deserialize from JSON integer number"); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public Object deserializeFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         return deserializeFromObjectId(jp, ctxt); [EOL]     } [EOL]     switch(jp.getNumberType()) { [EOL]         case INT: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromInt(ctxt, jp.getIntValue()); [EOL]         case LONG: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromLong(ctxt, jp.getLongValue()); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]         if (_injectables != null) { [EOL]             injectValues(ctxt, bean); [EOL]         } [EOL]         return bean; [EOL]     } [EOL]     throw ctxt.instantiationException(getBeanClass(), "no suitable creator method found to deserialize from JSON integer number"); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public Object deserializeFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         return deserializeFromObjectId(jp, ctxt); [EOL]     } [EOL]     switch(jp.getNumberType()) { [EOL]         case INT: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromInt(ctxt, jp.getIntValue()); [EOL]         case LONG: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromLong(ctxt, jp.getLongValue()); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]         if (_injectables != null) { [EOL]             injectValues(ctxt, bean); [EOL]         } [EOL]         return bean; [EOL]     } [EOL]     throw ctxt.instantiationException(getBeanClass(), "no suitable creator method found to deserialize from JSON integer number"); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public Object deserializeFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         return deserializeFromObjectId(jp, ctxt); [EOL]     } [EOL]     switch(jp.getNumberType()) { [EOL]         case INT: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromInt(ctxt, jp.getIntValue()); [EOL]         case LONG: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromLong(ctxt, jp.getLongValue()); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]         if (_injectables != null) { [EOL]             injectValues(ctxt, bean); [EOL]         } [EOL]         return bean; [EOL]     } [EOL]     throw ctxt.instantiationException(getBeanClass(), "no suitable creator method found to deserialize from JSON integer number"); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] public Object deserializeFromNumber(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_objectIdReader != null) { [EOL]         return deserializeFromObjectId(jp, ctxt); [EOL]     } [EOL]     switch(jp.getNumberType()) { [EOL]         case INT: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromInt(ctxt, jp.getIntValue()); [EOL]         case LONG: [EOL]             if (_delegateDeserializer != null) { [EOL]                 if (!_valueInstantiator.canCreateFromInt()) { [EOL]                     Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]                     if (_injectables != null) { [EOL]                         injectValues(ctxt, bean); [EOL]                     } [EOL]                     return bean; [EOL]                 } [EOL]             } [EOL]             return _valueInstantiator.createFromLong(ctxt, jp.getLongValue()); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]         if (_injectables != null) { [EOL]             injectValues(ctxt, bean); [EOL]         } [EOL]         return bean; [EOL]     } [EOL]     throw ctxt.instantiationException(getBeanClass(), "no suitable creator method found to deserialize from JSON integer number"); [EOL] }
public static ViewMatcher construct(Class<?>[] views) { [EOL]     if (views == null) { [EOL]         return Empty.instance; [EOL]     } [EOL]     switch(views.length) { [EOL]         case 0: [EOL]             return Empty.instance; [EOL]         case 1: [EOL]             return new Single(views[0]); [EOL]     } [EOL]     return new Multi(views); [EOL] }
public static ViewMatcher construct(Class<?>[] views) { [EOL]     if (views == null) { [EOL]         return Empty.instance; [EOL]     } [EOL]     switch(views.length) { [EOL]         case 0: [EOL]             return Empty.instance; [EOL]         case 1: [EOL]             return new Single(views[0]); [EOL]     } [EOL]     return new Multi(views); [EOL] }
public static ViewMatcher construct(Class<?>[] views) { [EOL]     if (views == null) { [EOL]         return Empty.instance; [EOL]     } [EOL]     switch(views.length) { [EOL]         case 0: [EOL]             return Empty.instance; [EOL]         case 1: [EOL]             return new Single(views[0]); [EOL]     } [EOL]     return new Multi(views); [EOL] }
public static ViewMatcher construct(Class<?>[] views) { [EOL]     if (views == null) { [EOL]         return Empty.instance; [EOL]     } [EOL]     switch(views.length) { [EOL]         case 0: [EOL]             return Empty.instance; [EOL]         case 1: [EOL]             return new Single(views[0]); [EOL]     } [EOL]     return new Multi(views); [EOL] }
@Override [EOL] public boolean isVisibleForView(Class<?> activeView) { [EOL]     return false; [EOL] }
public Single(Class<?> v) { [EOL]     _view = v; [EOL] }
public Single(Class<?> v) { [EOL]     _view = v; [EOL] }
@Override [EOL] public boolean isVisibleForView(Class<?> activeView) { [EOL]     return (activeView == _view) || _view.isAssignableFrom(activeView); [EOL] }
protected JsonNodeDeserializer() { [EOL] }
public static JsonDeserializer<? extends JsonNode> getDeserializer(Class<?> nodeClass) { [EOL]     if (nodeClass == ObjectNode.class) { [EOL]         return ObjectDeserializer.getInstance(); [EOL]     } [EOL]     if (nodeClass == ArrayNode.class) { [EOL]         return ArrayDeserializer.getInstance(); [EOL]     } [EOL]     return instance; [EOL] }
public static JsonDeserializer<? extends JsonNode> getDeserializer(Class<?> nodeClass) { [EOL]     if (nodeClass == ObjectNode.class) { [EOL]         return ObjectDeserializer.getInstance(); [EOL]     } [EOL]     if (nodeClass == ArrayNode.class) { [EOL]         return ArrayDeserializer.getInstance(); [EOL]     } [EOL]     return instance; [EOL] }
public static JsonDeserializer<? extends JsonNode> getDeserializer(Class<?> nodeClass) { [EOL]     if (nodeClass == ObjectNode.class) { [EOL]         return ObjectDeserializer.getInstance(); [EOL]     } [EOL]     if (nodeClass == ArrayNode.class) { [EOL]         return ArrayDeserializer.getInstance(); [EOL]     } [EOL]     return instance; [EOL] }
@Override [EOL] public JsonNode deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, ctxt.getNodeFactory()); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, ctxt.getNodeFactory()); [EOL]         default: [EOL]             return deserializeAny(jp, ctxt, ctxt.getNodeFactory()); [EOL]     } [EOL] }
@Override [EOL] public JsonNode deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, ctxt.getNodeFactory()); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, ctxt.getNodeFactory()); [EOL]         default: [EOL]             return deserializeAny(jp, ctxt, ctxt.getNodeFactory()); [EOL]     } [EOL] }
@Override [EOL] public JsonNode deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, ctxt.getNodeFactory()); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, ctxt.getNodeFactory()); [EOL]         default: [EOL]             return deserializeAny(jp, ctxt, ctxt.getNodeFactory()); [EOL]     } [EOL] }
protected ObjectDeserializer() { [EOL] }
public static ObjectDeserializer getInstance() { [EOL]     return _instance; [EOL] }
@Override [EOL] public ObjectNode deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() == JsonToken.START_OBJECT) { [EOL]         jp.nextToken(); [EOL]         return deserializeObject(jp, ctxt, ctxt.getNodeFactory()); [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.FIELD_NAME) { [EOL]         return deserializeObject(jp, ctxt, ctxt.getNodeFactory()); [EOL]     } [EOL]     throw ctxt.mappingException(ObjectNode.class); [EOL] }
@Override [EOL] public ObjectNode deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() == JsonToken.START_OBJECT) { [EOL]         jp.nextToken(); [EOL]         return deserializeObject(jp, ctxt, ctxt.getNodeFactory()); [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.FIELD_NAME) { [EOL]         return deserializeObject(jp, ctxt, ctxt.getNodeFactory()); [EOL]     } [EOL]     throw ctxt.mappingException(ObjectNode.class); [EOL] }
@Override [EOL] public ObjectNode deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.getCurrentToken() == JsonToken.START_OBJECT) { [EOL]         jp.nextToken(); [EOL]         return deserializeObject(jp, ctxt, ctxt.getNodeFactory()); [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.FIELD_NAME) { [EOL]         return deserializeObject(jp, ctxt, ctxt.getNodeFactory()); [EOL]     } [EOL]     throw ctxt.mappingException(ObjectNode.class); [EOL] }
public BaseNodeDeserializer() { [EOL]     super(JsonNode.class); [EOL] }
protected final ObjectNode deserializeObject(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     ObjectNode node = nodeFactory.objectNode(); [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         JsonNode value; [EOL]         switch(jp.nextToken()) { [EOL]             case START_OBJECT: [EOL]                 value = deserializeObject(jp, ctxt, nodeFactory); [EOL]                 break; [EOL]             case START_ARRAY: [EOL]                 value = deserializeArray(jp, ctxt, nodeFactory); [EOL]                 break; [EOL]             case VALUE_STRING: [EOL]                 value = nodeFactory.textNode(jp.getText()); [EOL]                 break; [EOL]             default: [EOL]                 value = deserializeAny(jp, ctxt, nodeFactory); [EOL]         } [EOL]         JsonNode old = node.replace(fieldName, value); [EOL]         if (old != null) { [EOL]             _handleDuplicateField(fieldName, node, old, value); [EOL]         } [EOL]     } [EOL]     return node; [EOL] }
protected final ObjectNode deserializeObject(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     ObjectNode node = nodeFactory.objectNode(); [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         JsonNode value; [EOL]         switch(jp.nextToken()) { [EOL]             case START_OBJECT: [EOL]                 value = deserializeObject(jp, ctxt, nodeFactory); [EOL]                 break; [EOL]             case START_ARRAY: [EOL]                 value = deserializeArray(jp, ctxt, nodeFactory); [EOL]                 break; [EOL]             case VALUE_STRING: [EOL]                 value = nodeFactory.textNode(jp.getText()); [EOL]                 break; [EOL]             default: [EOL]                 value = deserializeAny(jp, ctxt, nodeFactory); [EOL]         } [EOL]         JsonNode old = node.replace(fieldName, value); [EOL]         if (old != null) { [EOL]             _handleDuplicateField(fieldName, node, old, value); [EOL]         } [EOL]     } [EOL]     return node; [EOL] }
protected final ObjectNode deserializeObject(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     ObjectNode node = nodeFactory.objectNode(); [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         JsonNode value; [EOL]         switch(jp.nextToken()) { [EOL]             case START_OBJECT: [EOL]                 value = deserializeObject(jp, ctxt, nodeFactory); [EOL]                 break; [EOL]             case START_ARRAY: [EOL]                 value = deserializeArray(jp, ctxt, nodeFactory); [EOL]                 break; [EOL]             case VALUE_STRING: [EOL]                 value = nodeFactory.textNode(jp.getText()); [EOL]                 break; [EOL]             default: [EOL]                 value = deserializeAny(jp, ctxt, nodeFactory); [EOL]         } [EOL]         JsonNode old = node.replace(fieldName, value); [EOL]         if (old != null) { [EOL]             _handleDuplicateField(fieldName, node, old, value); [EOL]         } [EOL]     } [EOL]     return node; [EOL] }
protected final ObjectNode deserializeObject(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     ObjectNode node = nodeFactory.objectNode(); [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         JsonNode value; [EOL]         switch(jp.nextToken()) { [EOL]             case START_OBJECT: [EOL]                 value = deserializeObject(jp, ctxt, nodeFactory); [EOL]                 break; [EOL]             case START_ARRAY: [EOL]                 value = deserializeArray(jp, ctxt, nodeFactory); [EOL]                 break; [EOL]             case VALUE_STRING: [EOL]                 value = nodeFactory.textNode(jp.getText()); [EOL]                 break; [EOL]             default: [EOL]                 value = deserializeAny(jp, ctxt, nodeFactory); [EOL]         } [EOL]         JsonNode old = node.replace(fieldName, value); [EOL]         if (old != null) { [EOL]             _handleDuplicateField(fieldName, node, old, value); [EOL]         } [EOL]     } [EOL]     return node; [EOL] }
protected final ArrayNode deserializeArray(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     ArrayNode node = nodeFactory.arrayNode(); [EOL]     while (true) { [EOL]         JsonToken t = jp.nextToken(); [EOL]         if (t == null) { [EOL]             throw ctxt.mappingException("Unexpected end-of-input when binding data into ArrayNode"); [EOL]         } [EOL]         switch(t) { [EOL]             case START_OBJECT: [EOL]                 node.add(deserializeObject(jp, ctxt, nodeFactory)); [EOL]                 break; [EOL]             case START_ARRAY: [EOL]                 node.add(deserializeArray(jp, ctxt, nodeFactory)); [EOL]                 break; [EOL]             case END_ARRAY: [EOL]                 return node; [EOL]             case VALUE_STRING: [EOL]                 node.add(nodeFactory.textNode(jp.getText())); [EOL]                 break; [EOL]             default: [EOL]                 node.add(deserializeAny(jp, ctxt, nodeFactory)); [EOL]                 break; [EOL]         } [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt, final JsonNodeFactory nodeFactory) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case START_ARRAY: [EOL]             return deserializeArray(jp, ctxt, nodeFactory); [EOL]         case FIELD_NAME: [EOL]             return deserializeObject(jp, ctxt, nodeFactory); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             { [EOL]                 Object ob = jp.getEmbeddedObject(); [EOL]                 if (ob == null) { [EOL]                     return nodeFactory.nullNode(); [EOL]                 } [EOL]                 Class<?> type = ob.getClass(); [EOL]                 if (type == byte[].class) { [EOL]                     return nodeFactory.binaryNode((byte[]) ob); [EOL]                 } [EOL]                 return nodeFactory.POJONode(ob); [EOL]             } [EOL]         case VALUE_STRING: [EOL]             return nodeFactory.textNode(jp.getText()); [EOL]         case VALUE_NUMBER_INT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_INTEGER || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                     return nodeFactory.numberNode(jp.getBigIntegerValue()); [EOL]                 } [EOL]                 if (nt == JsonParser.NumberType.INT) { [EOL]                     return nodeFactory.numberNode(jp.getIntValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getLongValue()); [EOL]             } [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             { [EOL]                 JsonParser.NumberType nt = jp.getNumberType(); [EOL]                 if (nt == JsonParser.NumberType.BIG_DECIMAL || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return nodeFactory.numberNode(jp.getDecimalValue()); [EOL]                 } [EOL]                 return nodeFactory.numberNode(jp.getDoubleValue()); [EOL]             } [EOL]         case VALUE_TRUE: [EOL]             return nodeFactory.booleanNode(true); [EOL]         case VALUE_FALSE: [EOL]             return nodeFactory.booleanNode(false); [EOL]         case VALUE_NULL: [EOL]             return nodeFactory.nullNode(); [EOL]         default: [EOL]             throw ctxt.mappingException(getValueClass()); [EOL]     } [EOL] }
protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final JavaType abstractType = beanDesc.getType(); [EOL]     for (AbstractTypeResolver r : _factoryConfig.abstractTypeResolvers()) { [EOL]         JavaType concrete = r.resolveAbstractType(ctxt.getConfig(), abstractType); [EOL]         if (concrete != null) { [EOL]             return concrete; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final JavaType abstractType = beanDesc.getType(); [EOL]     for (AbstractTypeResolver r : _factoryConfig.abstractTypeResolvers()) { [EOL]         JavaType concrete = r.resolveAbstractType(ctxt.getConfig(), abstractType); [EOL]         if (concrete != null) { [EOL]             return concrete; [EOL]         } [EOL]     } [EOL]     return null; [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
@SuppressWarnings("unchecked") [EOL] public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     ValueInstantiator valueInstantiator = findValueInstantiator(ctxt, beanDesc); [EOL]     BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc); [EOL]     builder.setValueInstantiator(valueInstantiator); [EOL]     addBeanProps(ctxt, beanDesc, builder); [EOL]     addObjectIdReader(ctxt, beanDesc, builder); [EOL]     addReferenceProperties(ctxt, beanDesc, builder); [EOL]     addInjectables(ctxt, beanDesc, builder); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             builder = mod.updateBuilder(config, beanDesc, builder); [EOL]         } [EOL]     } [EOL]     JsonDeserializer<?> deserializer; [EOL]     if (type.isAbstract() && !valueInstantiator.canInstantiate()) { [EOL]         deserializer = builder.buildAbstract(); [EOL]     } else { [EOL]         deserializer = builder.build(); [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deserializer = mod.modifyDeserializer(config, beanDesc, deserializer); [EOL]         } [EOL]     } [EOL]     return (JsonDeserializer<Object>) deserializer; [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
@SuppressWarnings("unchecked") [EOL] public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     ValueInstantiator valueInstantiator = findValueInstantiator(ctxt, beanDesc); [EOL]     BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc); [EOL]     builder.setValueInstantiator(valueInstantiator); [EOL]     addBeanProps(ctxt, beanDesc, builder); [EOL]     addObjectIdReader(ctxt, beanDesc, builder); [EOL]     addReferenceProperties(ctxt, beanDesc, builder); [EOL]     addInjectables(ctxt, beanDesc, builder); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             builder = mod.updateBuilder(config, beanDesc, builder); [EOL]         } [EOL]     } [EOL]     JsonDeserializer<?> deserializer; [EOL]     if (type.isAbstract() && !valueInstantiator.canInstantiate()) { [EOL]         deserializer = builder.buildAbstract(); [EOL]     } else { [EOL]         deserializer = builder.build(); [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deserializer = mod.modifyDeserializer(config, beanDesc, deserializer); [EOL]         } [EOL]     } [EOL]     return (JsonDeserializer<Object>) deserializer; [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
@SuppressWarnings("unchecked") [EOL] public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     ValueInstantiator valueInstantiator = findValueInstantiator(ctxt, beanDesc); [EOL]     BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc); [EOL]     builder.setValueInstantiator(valueInstantiator); [EOL]     addBeanProps(ctxt, beanDesc, builder); [EOL]     addObjectIdReader(ctxt, beanDesc, builder); [EOL]     addReferenceProperties(ctxt, beanDesc, builder); [EOL]     addInjectables(ctxt, beanDesc, builder); [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             builder = mod.updateBuilder(config, beanDesc, builder); [EOL]         } [EOL]     } [EOL]     JsonDeserializer<?> deserializer; [EOL]     if (type.isAbstract() && !valueInstantiator.canInstantiate()) { [EOL]         deserializer = builder.buildAbstract(); [EOL]     } else { [EOL]         deserializer = builder.build(); [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deserializer = mod.modifyDeserializer(config, beanDesc, deserializer); [EOL]         } [EOL]     } [EOL]     return (JsonDeserializer<Object>) deserializer; [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { [EOL]     final SettableBeanProperty[] creatorProps = builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig()); [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     boolean ignoreAny = false; [EOL]     { [EOL]         Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo()); [EOL]         if (B != null) { [EOL]             ignoreAny = B.booleanValue(); [EOL]             builder.setIgnoreUnknownProperties(ignoreAny); [EOL]         } [EOL]     } [EOL]     Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo())); [EOL]     for (String propName : ignored) { [EOL]         builder.addIgnorable(propName); [EOL]     } [EOL]     AnnotatedMethod anySetter = beanDesc.findAnySetter(); [EOL]     if (anySetter != null) { [EOL]         builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter)); [EOL]     } [EOL]     if (anySetter == null) { [EOL]         Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames(); [EOL]         if (ignored2 != null) { [EOL]             for (String propName : ignored2) { [EOL]                 builder.addIgnorable(propName); [EOL]             } [EOL]         } [EOL]     } [EOL]     final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS) && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS)); [EOL]     List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt, beanDesc, builder, beanDesc.findProperties(), ignored); [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs); [EOL]         } [EOL]     } [EOL]     for (BeanPropertyDefinition propDef : propDefs) { [EOL]         SettableBeanProperty prop = null; [EOL]         if (propDef.hasConstructorParameter()) { [EOL]             final String name = propDef.getName(); [EOL]             if (creatorProps != null) { [EOL]                 for (SettableBeanProperty cp : creatorProps) { [EOL]                     if (name.equals(cp.getName())) { [EOL]                         prop = cp; [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (prop == null) { [EOL]                 throw ctxt.mappingException("Could not find creator property with name '" + name + "' (in class " + beanDesc.getBeanClass().getName() + ")"); [EOL]             } [EOL]             builder.addCreatorProperty(prop); [EOL]             continue; [EOL]         } [EOL]         if (propDef.hasSetter()) { [EOL]             Type propertyType = propDef.getSetter().getGenericParameterType(0); [EOL]             prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType); [EOL]         } else if (propDef.hasField()) { [EOL]             Type propertyType = propDef.getField().getGenericType(); [EOL]             prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType); [EOL]         } else if (useGettersAsSetters && propDef.hasGetter()) { [EOL]             AnnotatedMethod getter = propDef.getGetter(); [EOL]             Class<?> rawPropertyType = getter.getRawType(); [EOL]             if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) { [EOL]                 prop = constructSetterlessProperty(ctxt, beanDesc, propDef); [EOL]             } [EOL]         } [EOL]         if (prop != null) { [EOL]             Class<?>[] views = propDef.findViews(); [EOL]             if (views == null) { [EOL]                 if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) { [EOL]                     views = NO_VIEWS; [EOL]                 } [EOL]             } [EOL]             prop.setViews(views); [EOL]             builder.addProperty(prop); [EOL]         } [EOL]     } [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException { [EOL]     ArrayList<BeanPropertyDefinition> result = new ArrayList<BeanPropertyDefinition>(Math.max(4, propDefsIn.size())); [EOL]     HashMap<Class<?>, Boolean> ignoredTypes = new HashMap<Class<?>, Boolean>(); [EOL]     for (BeanPropertyDefinition property : propDefsIn) { [EOL]         String name = property.getName(); [EOL]         if (ignored.contains(name)) { [EOL]             continue; [EOL]         } [EOL]         if (!property.hasConstructorParameter()) { [EOL]             Class<?> rawPropertyType = null; [EOL]             if (property.hasSetter()) { [EOL]                 rawPropertyType = property.getSetter().getRawParameterType(0); [EOL]             } else if (property.hasField()) { [EOL]                 rawPropertyType = property.getField().getRawType(); [EOL]             } [EOL]             if ((rawPropertyType != null) && (isIgnorableType(ctxt.getConfig(), beanDesc, rawPropertyType, ignoredTypes))) { [EOL]                 builder.addIgnorable(name); [EOL]                 continue; [EOL]             } [EOL]         } [EOL]         result.add(property); [EOL]     } [EOL]     return result; [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException { [EOL]     AnnotatedMember mutator = propDef.getMutator(); [EOL]     if (ctxt.canOverrideAccessModifiers()) { [EOL]         mutator.fixAccess(); [EOL]     } [EOL]     JavaType t0 = beanDesc.resolveType(jdkType); [EOL]     BeanProperty.Std property = new BeanProperty.Std(propDef.getName(), t0, propDef.getWrapperName(), beanDesc.getClassAnnotations(), mutator, propDef.isRequired()); [EOL]     JavaType type = resolveType(ctxt, beanDesc, t0, mutator); [EOL]     if (type != t0) { [EOL]         property = property.withType(type); [EOL]     } [EOL]     JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator); [EOL]     type = modifyTypeByAnnotation(ctxt, mutator, type); [EOL]     TypeDeserializer typeDeser = type.getTypeHandler(); [EOL]     SettableBeanProperty prop; [EOL]     if (mutator instanceof AnnotatedMethod) { [EOL]         prop = new MethodProperty(propDef, type, typeDeser, beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator); [EOL]     } else { [EOL]         prop = new FieldProperty(propDef, type, typeDeser, beanDesc.getClassAnnotations(), (AnnotatedField) mutator); [EOL]     } [EOL]     if (propDeser != null) { [EOL]         prop = prop.withValueDeserializer(propDeser); [EOL]     } [EOL]     AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType(); [EOL]     if (ref != null && ref.isManagedReference()) { [EOL]         prop.setManagedReferenceName(ref.getName()); [EOL]     } [EOL]     return prop; [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException { [EOL]     final AnnotatedMethod getter = propDef.getGetter(); [EOL]     if (ctxt.canOverrideAccessModifiers()) { [EOL]         getter.fixAccess(); [EOL]     } [EOL]     JavaType type = getter.getType(beanDesc.bindingsForBeanType()); [EOL]     JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, getter); [EOL]     type = modifyTypeByAnnotation(ctxt, getter, type); [EOL]     TypeDeserializer typeDeser = type.getTypeHandler(); [EOL]     SettableBeanProperty prop = new SetterlessProperty(propDef, type, typeDeser, beanDesc.getClassAnnotations(), getter); [EOL]     if (propDeser != null) { [EOL]         prop = prop.withValueDeserializer(propDeser); [EOL]     } [EOL]     return prop; [EOL] } public BeanDeserializerFactory(DeserializerFactoryConfig config); public DeserializerFactory withConfig(DeserializerFactoryConfig config); protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> createBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription beanDesc, Class<?> builderClass) throws JsonMappingException; protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JavaType materializeAbstractType(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected JsonDeserializer<Object> buildBuilderBasedDeserializer(DeserializationContext ctxt, JavaType valueType, BeanDescription builderDesc) throws JsonMappingException; protected void addObjectIdReader(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt, JavaType type, BeanDescription beanDesc) throws JsonMappingException; protected BeanDeserializerBuilder constructBeanDeserializerBuilder(DeserializationContext ctxt, BeanDescription beanDesc); protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder, List<BeanPropertyDefinition> propDefsIn, Set<String> ignored) throws JsonMappingException; protected void addReferenceProperties(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected void addInjectables(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException; protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt, BeanDescription beanDesc, AnnotatedMethod setter) throws JsonMappingException; protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef, Type jdkType) throws JsonMappingException; protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt, BeanDescription beanDesc, BeanPropertyDefinition propDef) throws JsonMappingException; protected boolean isPotentialBeanType(Class<?> type); protected boolean isIgnorableType(DeserializationConfig config, BeanDescription beanDesc, Class<?> type, Map<Class<?>, Boolean> ignoredTypes); long serialVersionUID=Optional[1]; Class<?>[] INIT_CAUSE_PARAMS=Optional[new Class<?>[] { Throwable.class }
public SimpleFilterProvider() { [EOL]     this(new HashMap<String, BeanPropertyFilter>()); [EOL] }
public SimpleFilterProvider(Map<String, BeanPropertyFilter> mapping) { [EOL]     _filtersById = mapping; [EOL] }
public SimpleFilterProvider(Map<String, BeanPropertyFilter> mapping) { [EOL]     _filtersById = mapping; [EOL] }
public SimpleFilterProvider(Map<String, BeanPropertyFilter> mapping) { [EOL]     _filtersById = mapping; [EOL] }
public SimpleFilterProvider addFilter(String id, BeanPropertyFilter filter) { [EOL]     _filtersById.put(id, filter); [EOL]     return this; [EOL] }
public SimpleFilterProvider addFilter(String id, BeanPropertyFilter filter) { [EOL]     _filtersById.put(id, filter); [EOL]     return this; [EOL] }
public SimpleFilterProvider addFilter(String id, BeanPropertyFilter filter) { [EOL]     _filtersById.put(id, filter); [EOL]     return this; [EOL] }
@Override [EOL] public BeanPropertyFilter findFilter(Object filterId) { [EOL]     BeanPropertyFilter f = _filtersById.get(filterId); [EOL]     if (f == null) { [EOL]         f = _defaultFilter; [EOL]         if (f == null && _cfgFailOnUnknownId) { [EOL]             throw new IllegalArgumentException("No filter configured with id '" + filterId + "' (type " + filterId.getClass().getName() + ")"); [EOL]         } [EOL]     } [EOL]     return f; [EOL] }
@Override [EOL] public BeanPropertyFilter findFilter(Object filterId) { [EOL]     BeanPropertyFilter f = _filtersById.get(filterId); [EOL]     if (f == null) { [EOL]         f = _defaultFilter; [EOL]         if (f == null && _cfgFailOnUnknownId) { [EOL]             throw new IllegalArgumentException("No filter configured with id '" + filterId + "' (type " + filterId.getClass().getName() + ")"); [EOL]         } [EOL]     } [EOL]     return f; [EOL] }
@Override [EOL] public BeanPropertyFilter findFilter(Object filterId) { [EOL]     BeanPropertyFilter f = _filtersById.get(filterId); [EOL]     if (f == null) { [EOL]         f = _defaultFilter; [EOL]         if (f == null && _cfgFailOnUnknownId) { [EOL]             throw new IllegalArgumentException("No filter configured with id '" + filterId + "' (type " + filterId.getClass().getName() + ")"); [EOL]         } [EOL]     } [EOL]     return f; [EOL] }
public Std withType(JavaType type) { [EOL]     return new Std(_name, type, _wrapperName, _contextAnnotations, _member, _isRequired); [EOL] }
@Override [EOL] public void serializeWithType(Object value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     typeSer.writeTypePrefixForScalar(value, jgen); [EOL]     serialize(value, jgen, provider); [EOL]     typeSer.writeTypeSuffixForScalar(value, jgen); [EOL] }
@Override [EOL] public void serializeWithType(Object value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     typeSer.writeTypePrefixForScalar(value, jgen); [EOL]     serialize(value, jgen, provider); [EOL]     typeSer.writeTypeSuffixForScalar(value, jgen); [EOL] }
public ObjectIdWriter withAlwaysAsId(boolean newState) { [EOL]     if (newState == alwaysAsId) { [EOL]         return this; [EOL]     } [EOL]     return new ObjectIdWriter(idType, propertyName, generator, serializer, newState); [EOL] }
public ObjectIdWriter withAlwaysAsId(boolean newState) { [EOL]     if (newState == alwaysAsId) { [EOL]         return this; [EOL]     } [EOL]     return new ObjectIdWriter(idType, propertyName, generator, serializer, newState); [EOL] }
public Map(PropertyValue next, Object value, Object key) { [EOL]     super(next, value); [EOL]     _key = key; [EOL] }
public Map(PropertyValue next, Object value, Object key) { [EOL]     super(next, value); [EOL]     _key = key; [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public void assign(Object bean) throws IOException, JsonProcessingException { [EOL]     ((java.util.Map<Object, Object>) bean).put(_key, value); [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public void assign(Object bean) throws IOException, JsonProcessingException { [EOL]     ((java.util.Map<Object, Object>) bean).put(_key, value); [EOL] }
protected BasicSerializerFactory(SerializerFactoryConfig config) { [EOL]     _factoryConfig = (config == null) ? new SerializerFactoryConfig() : config; [EOL] }
protected BasicSerializerFactory(SerializerFactoryConfig config) { [EOL]     _factoryConfig = (config == null) ? new SerializerFactoryConfig() : config; [EOL] }
@Override [EOL] public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) { [EOL]     return withConfig(_factoryConfig.withSerializerModifier(modifier)); [EOL] }
@Override [EOL] public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) { [EOL]     return withConfig(_factoryConfig.withSerializerModifier(modifier)); [EOL] }
protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (JsonSerializable.class.isAssignableFrom(raw)) { [EOL]         return SerializableSerializer.instance; [EOL]     } [EOL]     AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod(); [EOL]     if (valueMethod != null) { [EOL]         Method m = valueMethod.getAnnotated(); [EOL]         if (prov.canOverrideAccessModifiers()) { [EOL]             ClassUtil.checkAndFixAccess(m); [EOL]         } [EOL]         JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod); [EOL]         return new JsonValueSerializer(m, ser); [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (JsonSerializable.class.isAssignableFrom(raw)) { [EOL]         return SerializableSerializer.instance; [EOL]     } [EOL]     AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod(); [EOL]     if (valueMethod != null) { [EOL]         Method m = valueMethod.getAnnotated(); [EOL]         if (prov.canOverrideAccessModifiers()) { [EOL]             ClassUtil.checkAndFixAccess(m); [EOL]         } [EOL]         JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod); [EOL]         return new JsonValueSerializer(m, ser); [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByAnnotations(SerializerProvider prov, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (JsonSerializable.class.isAssignableFrom(raw)) { [EOL]         return SerializableSerializer.instance; [EOL]     } [EOL]     AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod(); [EOL]     if (valueMethod != null) { [EOL]         Method m = valueMethod.getAnnotated(); [EOL]         if (prov.canOverrideAccessModifiers()) { [EOL]             ClassUtil.checkAndFixAccess(m); [EOL]         } [EOL]         JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod); [EOL]         return new JsonValueSerializer(m, ser); [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (InetAddress.class.isAssignableFrom(raw)) { [EOL]         return InetAddressSerializer.instance; [EOL]     } [EOL]     if (TimeZone.class.isAssignableFrom(raw)) { [EOL]         return TimeZoneSerializer.instance; [EOL]     } [EOL]     if (java.nio.charset.Charset.class.isAssignableFrom(raw)) { [EOL]         return ToStringSerializer.instance; [EOL]     } [EOL]     JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     if (Number.class.isAssignableFrom(raw)) { [EOL]         return NumberSerializers.NumberSerializer.instance; [EOL]     } [EOL]     if (Enum.class.isAssignableFrom(raw)) { [EOL]         return buildEnumSerializer(prov.getConfig(), type, beanDesc); [EOL]     } [EOL]     if (Calendar.class.isAssignableFrom(raw)) { [EOL]         return CalendarSerializer.instance; [EOL]     } [EOL]     if (java.util.Date.class.isAssignableFrom(raw)) { [EOL]         return DateSerializer.instance; [EOL]     } [EOL]     return null; [EOL] }
protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]         if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]             return null; [EOL]         } [EOL]         Class<?> raw = type.getRawClass(); [EOL]         if (EnumSet.class.isAssignableFrom(raw)) { [EOL]             JavaType enumType = type.getContentType(); [EOL]             if (!enumType.isEnumType()) { [EOL]                 enumType = null; [EOL]             } [EOL]             ser = StdContainerSerializers.enumSetSerializer(enumType); [EOL]         } else { [EOL]             Class<?> elementRaw = type.getContentType().getRawClass(); [EOL]             if (isIndexedList(raw)) { [EOL]                 if (elementRaw == String.class) { [EOL]                     if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                         ser = IndexedStringListSerializer.instance; [EOL]                     } [EOL]                 } else { [EOL]                     ser = StdContainerSerializers.indexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]                 } [EOL]             } else if (elementRaw == String.class) { [EOL]                 if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                     ser = StringCollectionSerializer.instance; [EOL]                 } [EOL]             } [EOL]             if (ser == null) { [EOL]                 ser = StdContainerSerializers.collectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]         if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]             return null; [EOL]         } [EOL]         Class<?> raw = type.getRawClass(); [EOL]         if (EnumSet.class.isAssignableFrom(raw)) { [EOL]             JavaType enumType = type.getContentType(); [EOL]             if (!enumType.isEnumType()) { [EOL]                 enumType = null; [EOL]             } [EOL]             ser = StdContainerSerializers.enumSetSerializer(enumType); [EOL]         } else { [EOL]             Class<?> elementRaw = type.getContentType().getRawClass(); [EOL]             if (isIndexedList(raw)) { [EOL]                 if (elementRaw == String.class) { [EOL]                     if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                         ser = IndexedStringListSerializer.instance; [EOL]                     } [EOL]                 } else { [EOL]                     ser = StdContainerSerializers.indexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]                 } [EOL]             } else if (elementRaw == String.class) { [EOL]                 if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                     ser = StringCollectionSerializer.instance; [EOL]                 } [EOL]             } [EOL]             if (ser == null) { [EOL]                 ser = StdContainerSerializers.collectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]         if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]             return null; [EOL]         } [EOL]         Class<?> raw = type.getRawClass(); [EOL]         if (EnumSet.class.isAssignableFrom(raw)) { [EOL]             JavaType enumType = type.getContentType(); [EOL]             if (!enumType.isEnumType()) { [EOL]                 enumType = null; [EOL]             } [EOL]             ser = StdContainerSerializers.enumSetSerializer(enumType); [EOL]         } else { [EOL]             Class<?> elementRaw = type.getContentType().getRawClass(); [EOL]             if (isIndexedList(raw)) { [EOL]                 if (elementRaw == String.class) { [EOL]                     if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                         ser = IndexedStringListSerializer.instance; [EOL]                     } [EOL]                 } else { [EOL]                     ser = StdContainerSerializers.indexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]                 } [EOL]             } else if (elementRaw == String.class) { [EOL]                 if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                     ser = StringCollectionSerializer.instance; [EOL]                 } [EOL]             } [EOL]             if (ser == null) { [EOL]                 ser = StdContainerSerializers.collectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]         if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]             return null; [EOL]         } [EOL]         Class<?> raw = type.getRawClass(); [EOL]         if (EnumSet.class.isAssignableFrom(raw)) { [EOL]             JavaType enumType = type.getContentType(); [EOL]             if (!enumType.isEnumType()) { [EOL]                 enumType = null; [EOL]             } [EOL]             ser = StdContainerSerializers.enumSetSerializer(enumType); [EOL]         } else { [EOL]             Class<?> elementRaw = type.getContentType().getRawClass(); [EOL]             if (isIndexedList(raw)) { [EOL]                 if (elementRaw == String.class) { [EOL]                     if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                         ser = IndexedStringListSerializer.instance; [EOL]                     } [EOL]                 } else { [EOL]                     ser = StdContainerSerializers.indexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]                 } [EOL]             } else if (elementRaw == String.class) { [EOL]                 if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                     ser = StringCollectionSerializer.instance; [EOL]                 } [EOL]             } [EOL]             if (ser == null) { [EOL]                 ser = StdContainerSerializers.collectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]         if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]             return null; [EOL]         } [EOL]         Class<?> raw = type.getRawClass(); [EOL]         if (EnumSet.class.isAssignableFrom(raw)) { [EOL]             JavaType enumType = type.getContentType(); [EOL]             if (!enumType.isEnumType()) { [EOL]                 enumType = null; [EOL]             } [EOL]             ser = StdContainerSerializers.enumSetSerializer(enumType); [EOL]         } else { [EOL]             Class<?> elementRaw = type.getContentType().getRawClass(); [EOL]             if (isIndexedList(raw)) { [EOL]                 if (elementRaw == String.class) { [EOL]                     if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                         ser = IndexedStringListSerializer.instance; [EOL]                     } [EOL]                 } else { [EOL]                     ser = StdContainerSerializers.indexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]                 } [EOL]             } else if (elementRaw == String.class) { [EOL]                 if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                     ser = StringCollectionSerializer.instance; [EOL]                 } [EOL]             } [EOL]             if (ser == null) { [EOL]                 ser = StdContainerSerializers.collectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config, CollectionType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findCollectionSerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]         if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) { [EOL]             return null; [EOL]         } [EOL]         Class<?> raw = type.getRawClass(); [EOL]         if (EnumSet.class.isAssignableFrom(raw)) { [EOL]             JavaType enumType = type.getContentType(); [EOL]             if (!enumType.isEnumType()) { [EOL]                 enumType = null; [EOL]             } [EOL]             ser = StdContainerSerializers.enumSetSerializer(enumType); [EOL]         } else { [EOL]             Class<?> elementRaw = type.getContentType().getRawClass(); [EOL]             if (isIndexedList(raw)) { [EOL]                 if (elementRaw == String.class) { [EOL]                     if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                         ser = IndexedStringListSerializer.instance; [EOL]                     } [EOL]                 } else { [EOL]                     ser = StdContainerSerializers.indexedListSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]                 } [EOL]             } else if (elementRaw == String.class) { [EOL]                 if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]                     ser = StringCollectionSerializer.instance; [EOL]                 } [EOL]             } [EOL]             if (ser == null) { [EOL]                 ser = StdContainerSerializers.collectionSerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type, BeanDescription beanDesc, boolean staticTyping, JsonSerializer<Object> keySerializer, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findMapSerializer(config, type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         if (EnumMap.class.isAssignableFrom(type.getRawClass())) { [EOL]             JavaType keyType = type.getKeyType(); [EOL]             EnumValues enums = null; [EOL]             if (keyType.isEnumType()) { [EOL]                 @SuppressWarnings("unchecked") [EOL]                 Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass(); [EOL]                 enums = EnumValues.construct(enumClass, config.getAnnotationIntrospector()); [EOL]             } [EOL]             ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums, elementTypeSerializer, elementValueSerializer); [EOL]         } else { [EOL]             ser = MapSerializer.construct(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()), type, staticTyping, elementTypeSerializer, keySerializer, elementValueSerializer); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyMapSerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         Class<?> raw = type.getRawClass(); [EOL]         if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]             if (String[].class == raw) { [EOL]                 ser = StringArraySerializer.instance; [EOL]             } else { [EOL]                 ser = StdArraySerializers.findStandardImpl(raw); [EOL]             } [EOL]         } [EOL]         if (ser == null) { [EOL]             ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyArraySerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         Class<?> raw = type.getRawClass(); [EOL]         if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]             if (String[].class == raw) { [EOL]                 ser = StringArraySerializer.instance; [EOL]             } else { [EOL]                 ser = StdArraySerializers.findStandardImpl(raw); [EOL]             } [EOL]         } [EOL]         if (ser == null) { [EOL]             ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyArraySerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         Class<?> raw = type.getRawClass(); [EOL]         if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]             if (String[].class == raw) { [EOL]                 ser = StringArraySerializer.instance; [EOL]             } else { [EOL]                 ser = StdArraySerializers.findStandardImpl(raw); [EOL]             } [EOL]         } [EOL]         if (ser == null) { [EOL]             ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyArraySerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type, BeanDescription beanDesc, boolean staticTyping, TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = null; [EOL]     for (Serializers serializers : customSerializers()) { [EOL]         ser = serializers.findArraySerializer(config, type, beanDesc, elementTypeSerializer, elementValueSerializer); [EOL]         if (ser != null) { [EOL]             break; [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         Class<?> raw = type.getRawClass(); [EOL]         if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) { [EOL]             if (String[].class == raw) { [EOL]                 ser = StringArraySerializer.instance; [EOL]             } else { [EOL]                 ser = StdArraySerializers.findStandardImpl(raw); [EOL]             } [EOL]         } [EOL]         if (ser == null) { [EOL]             ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer, elementValueSerializer); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             ser = mod.modifyArraySerializer(config, type, beanDesc, ser); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     JavaType valueType = type.containedType(0); [EOL]     if (valueType == null) { [EOL]         valueType = TypeFactory.unknownType(); [EOL]     } [EOL]     TypeSerializer vts = createTypeSerializer(config, valueType); [EOL]     return StdContainerSerializers.iteratorSerializer(valueType, usesStaticTyping(config, beanDesc, vts), vts); [EOL] }
protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     JavaType valueType = type.containedType(0); [EOL]     if (valueType == null) { [EOL]         valueType = TypeFactory.unknownType(); [EOL]     } [EOL]     TypeSerializer vts = createTypeSerializer(config, valueType); [EOL]     return StdContainerSerializers.iteratorSerializer(valueType, usesStaticTyping(config, beanDesc, vts), vts); [EOL] }
protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     JavaType valueType = type.containedType(0); [EOL]     if (valueType == null) { [EOL]         valueType = TypeFactory.unknownType(); [EOL]     } [EOL]     TypeSerializer vts = createTypeSerializer(config, valueType); [EOL]     return StdContainerSerializers.iteratorSerializer(valueType, usesStaticTyping(config, beanDesc, vts), vts); [EOL] }
protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     JavaType valueType = type.containedType(0); [EOL]     if (valueType == null) { [EOL]         valueType = TypeFactory.unknownType(); [EOL]     } [EOL]     TypeSerializer vts = createTypeSerializer(config, valueType); [EOL]     return StdContainerSerializers.iteratorSerializer(valueType, usesStaticTyping(config, beanDesc, vts), vts); [EOL] }
public SettableAnyProperty(BeanProperty property, AnnotatedMethod setter, JavaType type, JsonDeserializer<Object> valueDeser) { [EOL]     this(property, setter.getAnnotated(), type, valueDeser); [EOL] }
public SettableAnyProperty(BeanProperty property, Method rawSetter, JavaType type, JsonDeserializer<Object> valueDeser) { [EOL]     _property = property; [EOL]     _type = type; [EOL]     _setter = rawSetter; [EOL]     _valueDeserializer = valueDeser; [EOL] }
public SettableAnyProperty withValueDeserializer(JsonDeserializer<Object> deser) { [EOL]     return new SettableAnyProperty(_property, _setter, _type, deser); [EOL] }
public SettableAnyProperty withValueDeserializer(JsonDeserializer<Object> deser) { [EOL]     return new SettableAnyProperty(_property, _setter, _type, deser); [EOL] }
public BeanProperty getProperty() { [EOL]     return _property; [EOL] }
public boolean hasValueDeserializer() { [EOL]     return (_valueDeserializer != null); [EOL] }
public boolean hasValueDeserializer() { [EOL]     return (_valueDeserializer != null); [EOL] }
public JavaType getType() { [EOL]     return _type; [EOL] }
public final void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance, String propName) throws IOException, JsonProcessingException { [EOL]     set(instance, propName, deserialize(jp, ctxt)); [EOL] }
public final void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance, String propName) throws IOException, JsonProcessingException { [EOL]     set(instance, propName, deserialize(jp, ctxt)); [EOL] }
public final void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance, String propName) throws IOException, JsonProcessingException { [EOL]     set(instance, propName, deserialize(jp, ctxt)); [EOL] }
public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return null; [EOL]     } [EOL]     return _valueDeserializer.deserialize(jp, ctxt); [EOL] }
public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         return null; [EOL]     } [EOL]     return _valueDeserializer.deserialize(jp, ctxt); [EOL] }
public final void set(Object instance, String propName, Object value) throws IOException { [EOL]     try { [EOL]         _setter.invoke(instance, propName, value); [EOL]     } catch (Exception e) { [EOL]         _throwAsIOE(e, propName, value); [EOL]     } [EOL] }
public final void set(Object instance, String propName, Object value) throws IOException { [EOL]     try { [EOL]         _setter.invoke(instance, propName, value); [EOL]     } catch (Exception e) { [EOL]         _throwAsIOE(e, propName, value); [EOL]     } [EOL] }
public final void set(Object instance, String propName, Object value) throws IOException { [EOL]     try { [EOL]         _setter.invoke(instance, propName, value); [EOL]     } catch (Exception e) { [EOL]         _throwAsIOE(e, propName, value); [EOL]     } [EOL] }
public static AnnotatedClass constructWithoutSuperTypes(Class<?> cls, AnnotationIntrospector aintr, MixInResolver mir) { [EOL]     return new AnnotatedClass(cls, Collections.<Class<?>>emptyList(), aintr, mir, null); [EOL] }
public static AnnotatedClass constructWithoutSuperTypes(Class<?> cls, AnnotationIntrospector aintr, MixInResolver mir) { [EOL]     return new AnnotatedClass(cls, Collections.<Class<?>>emptyList(), aintr, mir, null); [EOL] }
private void resolveCreators() { [EOL]     List<AnnotatedConstructor> constructors = null; [EOL]     Constructor<?>[] declaredCtors = _class.getDeclaredConstructors(); [EOL]     for (Constructor<?> ctor : declaredCtors) { [EOL]         if (ctor.getParameterTypes().length == 0) { [EOL]             _defaultConstructor = _constructConstructor(ctor, true); [EOL]         } else { [EOL]             if (constructors == null) { [EOL]                 constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length)); [EOL]             } [EOL]             constructors.add(_constructConstructor(ctor, false)); [EOL]         } [EOL]     } [EOL]     if (constructors == null) { [EOL]         _constructors = Collections.emptyList(); [EOL]     } else { [EOL]         _constructors = constructors; [EOL]     } [EOL]     if (_primaryMixIn != null) { [EOL]         if (_defaultConstructor != null || !_constructors.isEmpty()) { [EOL]             _addConstructorMixIns(_primaryMixIn); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (_defaultConstructor != null) { [EOL]             if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) { [EOL]                 _defaultConstructor = null; [EOL]             } [EOL]         } [EOL]         if (_constructors != null) { [EOL]             for (int i = _constructors.size(); --i >= 0; ) { [EOL]                 if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) { [EOL]                     _constructors.remove(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     List<AnnotatedMethod> creatorMethods = null; [EOL]     for (Method m : _class.getDeclaredMethods()) { [EOL]         if (!Modifier.isStatic(m.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         if (creatorMethods == null) { [EOL]             creatorMethods = new ArrayList<AnnotatedMethod>(8); [EOL]         } [EOL]         creatorMethods.add(_constructCreatorMethod(m)); [EOL]     } [EOL]     if (creatorMethods == null) { [EOL]         _creatorMethods = Collections.emptyList(); [EOL]     } else { [EOL]         _creatorMethods = creatorMethods; [EOL]         if (_primaryMixIn != null) { [EOL]             _addFactoryMixIns(_primaryMixIn); [EOL]         } [EOL]         if (_annotationIntrospector != null) { [EOL]             for (int i = _creatorMethods.size(); --i >= 0; ) { [EOL]                 if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) { [EOL]                     _creatorMethods.remove(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     _creatorsResolved = true; [EOL] }
private void resolveCreators() { [EOL]     List<AnnotatedConstructor> constructors = null; [EOL]     Constructor<?>[] declaredCtors = _class.getDeclaredConstructors(); [EOL]     for (Constructor<?> ctor : declaredCtors) { [EOL]         if (ctor.getParameterTypes().length == 0) { [EOL]             _defaultConstructor = _constructConstructor(ctor, true); [EOL]         } else { [EOL]             if (constructors == null) { [EOL]                 constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length)); [EOL]             } [EOL]             constructors.add(_constructConstructor(ctor, false)); [EOL]         } [EOL]     } [EOL]     if (constructors == null) { [EOL]         _constructors = Collections.emptyList(); [EOL]     } else { [EOL]         _constructors = constructors; [EOL]     } [EOL]     if (_primaryMixIn != null) { [EOL]         if (_defaultConstructor != null || !_constructors.isEmpty()) { [EOL]             _addConstructorMixIns(_primaryMixIn); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (_defaultConstructor != null) { [EOL]             if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) { [EOL]                 _defaultConstructor = null; [EOL]             } [EOL]         } [EOL]         if (_constructors != null) { [EOL]             for (int i = _constructors.size(); --i >= 0; ) { [EOL]                 if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) { [EOL]                     _constructors.remove(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     List<AnnotatedMethod> creatorMethods = null; [EOL]     for (Method m : _class.getDeclaredMethods()) { [EOL]         if (!Modifier.isStatic(m.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         if (creatorMethods == null) { [EOL]             creatorMethods = new ArrayList<AnnotatedMethod>(8); [EOL]         } [EOL]         creatorMethods.add(_constructCreatorMethod(m)); [EOL]     } [EOL]     if (creatorMethods == null) { [EOL]         _creatorMethods = Collections.emptyList(); [EOL]     } else { [EOL]         _creatorMethods = creatorMethods; [EOL]         if (_primaryMixIn != null) { [EOL]             _addFactoryMixIns(_primaryMixIn); [EOL]         } [EOL]         if (_annotationIntrospector != null) { [EOL]             for (int i = _creatorMethods.size(); --i >= 0; ) { [EOL]                 if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) { [EOL]                     _creatorMethods.remove(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     _creatorsResolved = true; [EOL] }
private void resolveCreators() { [EOL]     List<AnnotatedConstructor> constructors = null; [EOL]     Constructor<?>[] declaredCtors = _class.getDeclaredConstructors(); [EOL]     for (Constructor<?> ctor : declaredCtors) { [EOL]         if (ctor.getParameterTypes().length == 0) { [EOL]             _defaultConstructor = _constructConstructor(ctor, true); [EOL]         } else { [EOL]             if (constructors == null) { [EOL]                 constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length)); [EOL]             } [EOL]             constructors.add(_constructConstructor(ctor, false)); [EOL]         } [EOL]     } [EOL]     if (constructors == null) { [EOL]         _constructors = Collections.emptyList(); [EOL]     } else { [EOL]         _constructors = constructors; [EOL]     } [EOL]     if (_primaryMixIn != null) { [EOL]         if (_defaultConstructor != null || !_constructors.isEmpty()) { [EOL]             _addConstructorMixIns(_primaryMixIn); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (_defaultConstructor != null) { [EOL]             if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) { [EOL]                 _defaultConstructor = null; [EOL]             } [EOL]         } [EOL]         if (_constructors != null) { [EOL]             for (int i = _constructors.size(); --i >= 0; ) { [EOL]                 if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) { [EOL]                     _constructors.remove(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     List<AnnotatedMethod> creatorMethods = null; [EOL]     for (Method m : _class.getDeclaredMethods()) { [EOL]         if (!Modifier.isStatic(m.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         if (creatorMethods == null) { [EOL]             creatorMethods = new ArrayList<AnnotatedMethod>(8); [EOL]         } [EOL]         creatorMethods.add(_constructCreatorMethod(m)); [EOL]     } [EOL]     if (creatorMethods == null) { [EOL]         _creatorMethods = Collections.emptyList(); [EOL]     } else { [EOL]         _creatorMethods = creatorMethods; [EOL]         if (_primaryMixIn != null) { [EOL]             _addFactoryMixIns(_primaryMixIn); [EOL]         } [EOL]         if (_annotationIntrospector != null) { [EOL]             for (int i = _creatorMethods.size(); --i >= 0; ) { [EOL]                 if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) { [EOL]                     _creatorMethods.remove(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     _creatorsResolved = true; [EOL] }
private void resolveCreators() { [EOL]     List<AnnotatedConstructor> constructors = null; [EOL]     Constructor<?>[] declaredCtors = _class.getDeclaredConstructors(); [EOL]     for (Constructor<?> ctor : declaredCtors) { [EOL]         if (ctor.getParameterTypes().length == 0) { [EOL]             _defaultConstructor = _constructConstructor(ctor, true); [EOL]         } else { [EOL]             if (constructors == null) { [EOL]                 constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length)); [EOL]             } [EOL]             constructors.add(_constructConstructor(ctor, false)); [EOL]         } [EOL]     } [EOL]     if (constructors == null) { [EOL]         _constructors = Collections.emptyList(); [EOL]     } else { [EOL]         _constructors = constructors; [EOL]     } [EOL]     if (_primaryMixIn != null) { [EOL]         if (_defaultConstructor != null || !_constructors.isEmpty()) { [EOL]             _addConstructorMixIns(_primaryMixIn); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (_defaultConstructor != null) { [EOL]             if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) { [EOL]                 _defaultConstructor = null; [EOL]             } [EOL]         } [EOL]         if (_constructors != null) { [EOL]             for (int i = _constructors.size(); --i >= 0; ) { [EOL]                 if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) { [EOL]                     _constructors.remove(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     List<AnnotatedMethod> creatorMethods = null; [EOL]     for (Method m : _class.getDeclaredMethods()) { [EOL]         if (!Modifier.isStatic(m.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         if (creatorMethods == null) { [EOL]             creatorMethods = new ArrayList<AnnotatedMethod>(8); [EOL]         } [EOL]         creatorMethods.add(_constructCreatorMethod(m)); [EOL]     } [EOL]     if (creatorMethods == null) { [EOL]         _creatorMethods = Collections.emptyList(); [EOL]     } else { [EOL]         _creatorMethods = creatorMethods; [EOL]         if (_primaryMixIn != null) { [EOL]             _addFactoryMixIns(_primaryMixIn); [EOL]         } [EOL]         if (_annotationIntrospector != null) { [EOL]             for (int i = _creatorMethods.size(); --i >= 0; ) { [EOL]                 if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) { [EOL]                     _creatorMethods.remove(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     _creatorsResolved = true; [EOL] }
private void resolveCreators() { [EOL]     List<AnnotatedConstructor> constructors = null; [EOL]     Constructor<?>[] declaredCtors = _class.getDeclaredConstructors(); [EOL]     for (Constructor<?> ctor : declaredCtors) { [EOL]         if (ctor.getParameterTypes().length == 0) { [EOL]             _defaultConstructor = _constructConstructor(ctor, true); [EOL]         } else { [EOL]             if (constructors == null) { [EOL]                 constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length)); [EOL]             } [EOL]             constructors.add(_constructConstructor(ctor, false)); [EOL]         } [EOL]     } [EOL]     if (constructors == null) { [EOL]         _constructors = Collections.emptyList(); [EOL]     } else { [EOL]         _constructors = constructors; [EOL]     } [EOL]     if (_primaryMixIn != null) { [EOL]         if (_defaultConstructor != null || !_constructors.isEmpty()) { [EOL]             _addConstructorMixIns(_primaryMixIn); [EOL]         } [EOL]     } [EOL]     if (_annotationIntrospector != null) { [EOL]         if (_defaultConstructor != null) { [EOL]             if (_annotationIntrospector.hasIgnoreMarker(_defaultConstructor)) { [EOL]                 _defaultConstructor = null; [EOL]             } [EOL]         } [EOL]         if (_constructors != null) { [EOL]             for (int i = _constructors.size(); --i >= 0; ) { [EOL]                 if (_annotationIntrospector.hasIgnoreMarker(_constructors.get(i))) { [EOL]                     _constructors.remove(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     List<AnnotatedMethod> creatorMethods = null; [EOL]     for (Method m : _class.getDeclaredMethods()) { [EOL]         if (!Modifier.isStatic(m.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         if (creatorMethods == null) { [EOL]             creatorMethods = new ArrayList<AnnotatedMethod>(8); [EOL]         } [EOL]         creatorMethods.add(_constructCreatorMethod(m)); [EOL]     } [EOL]     if (creatorMethods == null) { [EOL]         _creatorMethods = Collections.emptyList(); [EOL]     } else { [EOL]         _creatorMethods = creatorMethods; [EOL]         if (_primaryMixIn != null) { [EOL]             _addFactoryMixIns(_primaryMixIn); [EOL]         } [EOL]         if (_annotationIntrospector != null) { [EOL]             for (int i = _creatorMethods.size(); --i >= 0; ) { [EOL]                 if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) { [EOL]                     _creatorMethods.remove(i); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     _creatorsResolved = true; [EOL] }
public String baseTypeName() { [EOL]     return _baseType.getRawClass().getName(); [EOL] }
public String baseTypeName() { [EOL]     return _baseType.getRawClass().getName(); [EOL] }
@Override [EOL] public JavaType resolveAbstractType(DeserializationConfig config, JavaType type) { [EOL]     return null; [EOL] }
public SqlDateSerializer() { [EOL]     super(java.sql.Date.class); [EOL] }
@Override [EOL] public void serialize(java.sql.Date value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeString(value.toString()); [EOL] }
@Override [EOL] public String idFromValueAndType(Object value, Class<?> type) { [EOL]     return _idFrom(value, type); [EOL] }
@Override [EOL] public String idFromValueAndType(Object value, Class<?> type) { [EOL]     return _idFrom(value, type); [EOL] }
@Override [EOL] public String idFromValueAndType(Object value, Class<?> type) { [EOL]     return _idFrom(value, type); [EOL] }
protected BeanPropertyWriter buildWriter(BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) { [EOL]     JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType); [EOL]     if (contentTypeSer != null) { [EOL]         if (serializationType == null) { [EOL]             serializationType = declaredType; [EOL]         } [EOL]         JavaType ct = serializationType.getContentType(); [EOL]         if (ct == null) { [EOL]             throw new IllegalStateException("Problem trying to create BeanPropertyWriter for property '" + propDef.getName() + "' (of type " + _beanDesc.getType() + "); serialization type " + serializationType + " has no content"); [EOL]         } [EOL]         serializationType = serializationType.withContentTypeHandler(contentTypeSer); [EOL]         ct = serializationType.getContentType(); [EOL]     } [EOL]     Object valueToSuppress = null; [EOL]     boolean suppressNulls = false; [EOL]     JsonInclude.Include methodProps = _annotationIntrospector.findSerializationInclusion(am, _outputProps); [EOL]     if (methodProps != null) { [EOL]         switch(methodProps) { [EOL]             case NON_DEFAULT: [EOL]                 valueToSuppress = getDefaultValue(propDef.getName(), am); [EOL]                 if (valueToSuppress == null) { [EOL]                     suppressNulls = true; [EOL]                 } else { [EOL]                     if (valueToSuppress.getClass().isArray()) { [EOL]                         valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case NON_EMPTY: [EOL]                 suppressNulls = true; [EOL]                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 break; [EOL]             case NON_NULL: [EOL]                 suppressNulls = true; [EOL]             case ALWAYS: [EOL]                 if (declaredType.isContainerType() && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) { [EOL]                     valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     BeanPropertyWriter bpw = new BeanPropertyWriter(propDef, am, _beanDesc.getClassAnnotations(), declaredType, ser, typeSer, serializationType, suppressNulls, valueToSuppress); [EOL]     NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am); [EOL]     if (unwrapper != null) { [EOL]         bpw = bpw.unwrappingWriter(unwrapper); [EOL]     } [EOL]     return bpw; [EOL] }
protected BeanPropertyWriter buildWriter(BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) { [EOL]     JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType); [EOL]     if (contentTypeSer != null) { [EOL]         if (serializationType == null) { [EOL]             serializationType = declaredType; [EOL]         } [EOL]         JavaType ct = serializationType.getContentType(); [EOL]         if (ct == null) { [EOL]             throw new IllegalStateException("Problem trying to create BeanPropertyWriter for property '" + propDef.getName() + "' (of type " + _beanDesc.getType() + "); serialization type " + serializationType + " has no content"); [EOL]         } [EOL]         serializationType = serializationType.withContentTypeHandler(contentTypeSer); [EOL]         ct = serializationType.getContentType(); [EOL]     } [EOL]     Object valueToSuppress = null; [EOL]     boolean suppressNulls = false; [EOL]     JsonInclude.Include methodProps = _annotationIntrospector.findSerializationInclusion(am, _outputProps); [EOL]     if (methodProps != null) { [EOL]         switch(methodProps) { [EOL]             case NON_DEFAULT: [EOL]                 valueToSuppress = getDefaultValue(propDef.getName(), am); [EOL]                 if (valueToSuppress == null) { [EOL]                     suppressNulls = true; [EOL]                 } else { [EOL]                     if (valueToSuppress.getClass().isArray()) { [EOL]                         valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case NON_EMPTY: [EOL]                 suppressNulls = true; [EOL]                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 break; [EOL]             case NON_NULL: [EOL]                 suppressNulls = true; [EOL]             case ALWAYS: [EOL]                 if (declaredType.isContainerType() && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) { [EOL]                     valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     BeanPropertyWriter bpw = new BeanPropertyWriter(propDef, am, _beanDesc.getClassAnnotations(), declaredType, ser, typeSer, serializationType, suppressNulls, valueToSuppress); [EOL]     NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am); [EOL]     if (unwrapper != null) { [EOL]         bpw = bpw.unwrappingWriter(unwrapper); [EOL]     } [EOL]     return bpw; [EOL] }
protected BeanPropertyWriter buildWriter(BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) { [EOL]     JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType); [EOL]     if (contentTypeSer != null) { [EOL]         if (serializationType == null) { [EOL]             serializationType = declaredType; [EOL]         } [EOL]         JavaType ct = serializationType.getContentType(); [EOL]         if (ct == null) { [EOL]             throw new IllegalStateException("Problem trying to create BeanPropertyWriter for property '" + propDef.getName() + "' (of type " + _beanDesc.getType() + "); serialization type " + serializationType + " has no content"); [EOL]         } [EOL]         serializationType = serializationType.withContentTypeHandler(contentTypeSer); [EOL]         ct = serializationType.getContentType(); [EOL]     } [EOL]     Object valueToSuppress = null; [EOL]     boolean suppressNulls = false; [EOL]     JsonInclude.Include methodProps = _annotationIntrospector.findSerializationInclusion(am, _outputProps); [EOL]     if (methodProps != null) { [EOL]         switch(methodProps) { [EOL]             case NON_DEFAULT: [EOL]                 valueToSuppress = getDefaultValue(propDef.getName(), am); [EOL]                 if (valueToSuppress == null) { [EOL]                     suppressNulls = true; [EOL]                 } else { [EOL]                     if (valueToSuppress.getClass().isArray()) { [EOL]                         valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case NON_EMPTY: [EOL]                 suppressNulls = true; [EOL]                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 break; [EOL]             case NON_NULL: [EOL]                 suppressNulls = true; [EOL]             case ALWAYS: [EOL]                 if (declaredType.isContainerType() && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) { [EOL]                     valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     BeanPropertyWriter bpw = new BeanPropertyWriter(propDef, am, _beanDesc.getClassAnnotations(), declaredType, ser, typeSer, serializationType, suppressNulls, valueToSuppress); [EOL]     NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am); [EOL]     if (unwrapper != null) { [EOL]         bpw = bpw.unwrappingWriter(unwrapper); [EOL]     } [EOL]     return bpw; [EOL] }
protected BeanPropertyWriter buildWriter(BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) { [EOL]     JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType); [EOL]     if (contentTypeSer != null) { [EOL]         if (serializationType == null) { [EOL]             serializationType = declaredType; [EOL]         } [EOL]         JavaType ct = serializationType.getContentType(); [EOL]         if (ct == null) { [EOL]             throw new IllegalStateException("Problem trying to create BeanPropertyWriter for property '" + propDef.getName() + "' (of type " + _beanDesc.getType() + "); serialization type " + serializationType + " has no content"); [EOL]         } [EOL]         serializationType = serializationType.withContentTypeHandler(contentTypeSer); [EOL]         ct = serializationType.getContentType(); [EOL]     } [EOL]     Object valueToSuppress = null; [EOL]     boolean suppressNulls = false; [EOL]     JsonInclude.Include methodProps = _annotationIntrospector.findSerializationInclusion(am, _outputProps); [EOL]     if (methodProps != null) { [EOL]         switch(methodProps) { [EOL]             case NON_DEFAULT: [EOL]                 valueToSuppress = getDefaultValue(propDef.getName(), am); [EOL]                 if (valueToSuppress == null) { [EOL]                     suppressNulls = true; [EOL]                 } else { [EOL]                     if (valueToSuppress.getClass().isArray()) { [EOL]                         valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case NON_EMPTY: [EOL]                 suppressNulls = true; [EOL]                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 break; [EOL]             case NON_NULL: [EOL]                 suppressNulls = true; [EOL]             case ALWAYS: [EOL]                 if (declaredType.isContainerType() && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) { [EOL]                     valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     BeanPropertyWriter bpw = new BeanPropertyWriter(propDef, am, _beanDesc.getClassAnnotations(), declaredType, ser, typeSer, serializationType, suppressNulls, valueToSuppress); [EOL]     NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am); [EOL]     if (unwrapper != null) { [EOL]         bpw = bpw.unwrappingWriter(unwrapper); [EOL]     } [EOL]     return bpw; [EOL] }
protected BeanPropertyWriter buildWriter(BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser, TypeSerializer typeSer, TypeSerializer contentTypeSer, AnnotatedMember am, boolean defaultUseStaticTyping) { [EOL]     JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType); [EOL]     if (contentTypeSer != null) { [EOL]         if (serializationType == null) { [EOL]             serializationType = declaredType; [EOL]         } [EOL]         JavaType ct = serializationType.getContentType(); [EOL]         if (ct == null) { [EOL]             throw new IllegalStateException("Problem trying to create BeanPropertyWriter for property '" + propDef.getName() + "' (of type " + _beanDesc.getType() + "); serialization type " + serializationType + " has no content"); [EOL]         } [EOL]         serializationType = serializationType.withContentTypeHandler(contentTypeSer); [EOL]         ct = serializationType.getContentType(); [EOL]     } [EOL]     Object valueToSuppress = null; [EOL]     boolean suppressNulls = false; [EOL]     JsonInclude.Include methodProps = _annotationIntrospector.findSerializationInclusion(am, _outputProps); [EOL]     if (methodProps != null) { [EOL]         switch(methodProps) { [EOL]             case NON_DEFAULT: [EOL]                 valueToSuppress = getDefaultValue(propDef.getName(), am); [EOL]                 if (valueToSuppress == null) { [EOL]                     suppressNulls = true; [EOL]                 } else { [EOL]                     if (valueToSuppress.getClass().isArray()) { [EOL]                         valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress); [EOL]                     } [EOL]                 } [EOL]                 break; [EOL]             case NON_EMPTY: [EOL]                 suppressNulls = true; [EOL]                 valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 break; [EOL]             case NON_NULL: [EOL]                 suppressNulls = true; [EOL]             case ALWAYS: [EOL]                 if (declaredType.isContainerType() && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) { [EOL]                     valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; [EOL]                 } [EOL]                 break; [EOL]         } [EOL]     } [EOL]     BeanPropertyWriter bpw = new BeanPropertyWriter(propDef, am, _beanDesc.getClassAnnotations(), declaredType, ser, typeSer, serializationType, suppressNulls, valueToSuppress); [EOL]     NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am); [EOL]     if (unwrapper != null) { [EOL]         bpw = bpw.unwrappingWriter(unwrapper); [EOL]     } [EOL]     return bpw; [EOL] }
public InnerClassProperty(SettableBeanProperty delegate, Constructor<?> ctor) { [EOL]     super(delegate); [EOL]     _delegate = delegate; [EOL]     _creator = ctor; [EOL] }
@Override [EOL] public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     Object value; [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         value = (_nullProvider == null) ? null : _nullProvider.nullValue(ctxt); [EOL]     } else if (_valueTypeDeserializer != null) { [EOL]         value = _valueDeserializer.deserializeWithType(jp, ctxt, _valueTypeDeserializer); [EOL]     } else { [EOL]         try { [EOL]             value = _creator.newInstance(bean); [EOL]         } catch (Exception e) { [EOL]             ClassUtil.unwrapAndThrowAsIAE(e, "Failed to instantiate class " + _creator.getDeclaringClass().getName() + ", problem: " + e.getMessage()); [EOL]             value = null; [EOL]         } [EOL]         _valueDeserializer.deserialize(jp, ctxt, value); [EOL]     } [EOL]     set(bean, value); [EOL] }
@Override [EOL] public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     Object value; [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         value = (_nullProvider == null) ? null : _nullProvider.nullValue(ctxt); [EOL]     } else if (_valueTypeDeserializer != null) { [EOL]         value = _valueDeserializer.deserializeWithType(jp, ctxt, _valueTypeDeserializer); [EOL]     } else { [EOL]         try { [EOL]             value = _creator.newInstance(bean); [EOL]         } catch (Exception e) { [EOL]             ClassUtil.unwrapAndThrowAsIAE(e, "Failed to instantiate class " + _creator.getDeclaringClass().getName() + ", problem: " + e.getMessage()); [EOL]             value = null; [EOL]         } [EOL]         _valueDeserializer.deserialize(jp, ctxt, value); [EOL]     } [EOL]     set(bean, value); [EOL] }
@Override [EOL] public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     Object value; [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         value = (_nullProvider == null) ? null : _nullProvider.nullValue(ctxt); [EOL]     } else if (_valueTypeDeserializer != null) { [EOL]         value = _valueDeserializer.deserializeWithType(jp, ctxt, _valueTypeDeserializer); [EOL]     } else { [EOL]         try { [EOL]             value = _creator.newInstance(bean); [EOL]         } catch (Exception e) { [EOL]             ClassUtil.unwrapAndThrowAsIAE(e, "Failed to instantiate class " + _creator.getDeclaringClass().getName() + ", problem: " + e.getMessage()); [EOL]             value = null; [EOL]         } [EOL]         _valueDeserializer.deserialize(jp, ctxt, value); [EOL]     } [EOL]     set(bean, value); [EOL] }
@Override [EOL] public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object bean) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     Object value; [EOL]     if (t == JsonToken.VALUE_NULL) { [EOL]         value = (_nullProvider == null) ? null : _nullProvider.nullValue(ctxt); [EOL]     } else if (_valueTypeDeserializer != null) { [EOL]         value = _valueDeserializer.deserializeWithType(jp, ctxt, _valueTypeDeserializer); [EOL]     } else { [EOL]         try { [EOL]             value = _creator.newInstance(bean); [EOL]         } catch (Exception e) { [EOL]             ClassUtil.unwrapAndThrowAsIAE(e, "Failed to instantiate class " + _creator.getDeclaringClass().getName() + ", problem: " + e.getMessage()); [EOL]             value = null; [EOL]         } [EOL]         _valueDeserializer.deserialize(jp, ctxt, value); [EOL]     } [EOL]     set(bean, value); [EOL] }
@Override [EOL] public final void set(Object instance, Object value) throws IOException { [EOL]     _delegate.set(instance, value); [EOL] }
@Override [EOL] public final void set(Object instance, Object value) throws IOException { [EOL]     _delegate.set(instance, value); [EOL] }
@JsonCreator [EOL] public JsonSchema(ObjectNode schema) { [EOL]     this.schema = schema; [EOL] }
@JsonCreator [EOL] public JsonSchema(ObjectNode schema) { [EOL]     this.schema = schema; [EOL] }
@JsonValue [EOL] public ObjectNode getSchemaNode() { [EOL]     return schema; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (!(o instanceof JsonSchema)) [EOL]         return false; [EOL]     JsonSchema other = (JsonSchema) o; [EOL]     if (schema == null) { [EOL]         return other.schema == null; [EOL]     } [EOL]     return schema.equals(other.schema); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (!(o instanceof JsonSchema)) [EOL]         return false; [EOL]     JsonSchema other = (JsonSchema) o; [EOL]     if (schema == null) { [EOL]         return other.schema == null; [EOL]     } [EOL]     return schema.equals(other.schema); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (!(o instanceof JsonSchema)) [EOL]         return false; [EOL]     JsonSchema other = (JsonSchema) o; [EOL]     if (schema == null) { [EOL]         return other.schema == null; [EOL]     } [EOL]     return schema.equals(other.schema); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (!(o instanceof JsonSchema)) [EOL]         return false; [EOL]     JsonSchema other = (JsonSchema) o; [EOL]     if (schema == null) { [EOL]         return other.schema == null; [EOL]     } [EOL]     return schema.equals(other.schema); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (!(o instanceof JsonSchema)) [EOL]         return false; [EOL]     JsonSchema other = (JsonSchema) o; [EOL]     if (schema == null) { [EOL]         return other.schema == null; [EOL]     } [EOL]     return schema.equals(other.schema); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (!(o instanceof JsonSchema)) [EOL]         return false; [EOL]     JsonSchema other = (JsonSchema) o; [EOL]     if (schema == null) { [EOL]         return other.schema == null; [EOL]     } [EOL]     return schema.equals(other.schema); [EOL] }
public static JsonNode getDefaultSchemaNode() { [EOL]     ObjectNode objectNode = JsonNodeFactory.instance.objectNode(); [EOL]     objectNode.put("type", "any"); [EOL]     return objectNode; [EOL] }
public BaseSettings withClassIntrospector(ClassIntrospector ci) { [EOL]     if (_classIntrospector == ci) { [EOL]         return this; [EOL]     } [EOL]     return new BaseSettings(ci, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone, _defaultBase64); [EOL] }
public BaseSettings withClassIntrospector(ClassIntrospector ci) { [EOL]     if (_classIntrospector == ci) { [EOL]         return this; [EOL]     } [EOL]     return new BaseSettings(ci, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone, _defaultBase64); [EOL] }
public BaseSettings with(TimeZone tz) { [EOL]     if (tz == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     DateFormat df = _dateFormat; [EOL]     if (df instanceof StdDateFormat) { [EOL]         df = ((StdDateFormat) df).withTimeZone(tz); [EOL]     } else { [EOL]         df = (DateFormat) df.clone(); [EOL]         df.setTimeZone(tz); [EOL]     } [EOL]     return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64); [EOL] }
public BaseSettings with(TimeZone tz) { [EOL]     if (tz == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     DateFormat df = _dateFormat; [EOL]     if (df instanceof StdDateFormat) { [EOL]         df = ((StdDateFormat) df).withTimeZone(tz); [EOL]     } else { [EOL]         df = (DateFormat) df.clone(); [EOL]         df.setTimeZone(tz); [EOL]     } [EOL]     return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64); [EOL] }
public BaseSettings with(TimeZone tz) { [EOL]     if (tz == null) { [EOL]         throw new IllegalArgumentException(); [EOL]     } [EOL]     DateFormat df = _dateFormat; [EOL]     if (df instanceof StdDateFormat) { [EOL]         df = ((StdDateFormat) df).withTimeZone(tz); [EOL]     } else { [EOL]         df = (DateFormat) df.clone(); [EOL]         df.setTimeZone(tz); [EOL]     } [EOL]     return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64); [EOL] }
public Locale getLocale() { [EOL]     return _locale; [EOL] }
public ShortBuilder getShortBuilder() { [EOL]     if (_shortBuilder == null) { [EOL]         _shortBuilder = new ShortBuilder(); [EOL]     } [EOL]     return _shortBuilder; [EOL] }
public ShortBuilder getShortBuilder() { [EOL]     if (_shortBuilder == null) { [EOL]         _shortBuilder = new ShortBuilder(); [EOL]     } [EOL]     return _shortBuilder; [EOL] }
public LongBuilder getLongBuilder() { [EOL]     if (_longBuilder == null) { [EOL]         _longBuilder = new LongBuilder(); [EOL]     } [EOL]     return _longBuilder; [EOL] }
public LongBuilder getLongBuilder() { [EOL]     if (_longBuilder == null) { [EOL]         _longBuilder = new LongBuilder(); [EOL]     } [EOL]     return _longBuilder; [EOL] }
public DoubleBuilder getDoubleBuilder() { [EOL]     if (_doubleBuilder == null) { [EOL]         _doubleBuilder = new DoubleBuilder(); [EOL]     } [EOL]     return _doubleBuilder; [EOL] }
public DoubleBuilder getDoubleBuilder() { [EOL]     if (_doubleBuilder == null) { [EOL]         _doubleBuilder = new DoubleBuilder(); [EOL]     } [EOL]     return _doubleBuilder; [EOL] }
public ShortBuilder() { [EOL] }
@Override [EOL] public final short[] _constructArray(int len) { [EOL]     return new short[len]; [EOL] }
@Override [EOL] public final short[] _constructArray(int len) { [EOL]     return new short[len]; [EOL] }
public LongBuilder() { [EOL] }
@Override [EOL] public final long[] _constructArray(int len) { [EOL]     return new long[len]; [EOL] }
@Override [EOL] public final long[] _constructArray(int len) { [EOL]     return new long[len]; [EOL] }
public DoubleBuilder() { [EOL] }
@Override [EOL] public final double[] _constructArray(int len) { [EOL]     return new double[len]; [EOL] }
public static Object getArrayComparator(final Object defaultValue) { [EOL]     final int length = Array.getLength(defaultValue); [EOL]     final Class<?> defaultValueType = defaultValue.getClass(); [EOL]     return new Object() { [EOL]  [EOL]         @Override [EOL]         public boolean equals(Object other) { [EOL]             if (other == this) [EOL]                 return true; [EOL]             if (other == null || other.getClass() != defaultValueType) { [EOL]                 return false; [EOL]             } [EOL]             if (Array.getLength(other) != length) [EOL]                 return false; [EOL]             for (int i = 0; i < length; ++i) { [EOL]                 Object value1 = Array.get(defaultValue, i); [EOL]                 Object value2 = Array.get(other, i); [EOL]                 if (value1 == value2) [EOL]                     continue; [EOL]                 if (value1 != null) { [EOL]                     if (!value1.equals(value2)) { [EOL]                         return false; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             return true; [EOL]         } [EOL]     }; [EOL] }
public static Object getArrayComparator(final Object defaultValue) { [EOL]     final int length = Array.getLength(defaultValue); [EOL]     final Class<?> defaultValueType = defaultValue.getClass(); [EOL]     return new Object() { [EOL]  [EOL]         @Override [EOL]         public boolean equals(Object other) { [EOL]             if (other == this) [EOL]                 return true; [EOL]             if (other == null || other.getClass() != defaultValueType) { [EOL]                 return false; [EOL]             } [EOL]             if (Array.getLength(other) != length) [EOL]                 return false; [EOL]             for (int i = 0; i < length; ++i) { [EOL]                 Object value1 = Array.get(defaultValue, i); [EOL]                 Object value2 = Array.get(other, i); [EOL]                 if (value1 == value2) [EOL]                     continue; [EOL]                 if (value1 != null) { [EOL]                     if (!value1.equals(value2)) { [EOL]                         return false; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             return true; [EOL]         } [EOL]     }; [EOL] }
public static Object getArrayComparator(final Object defaultValue) { [EOL]     final int length = Array.getLength(defaultValue); [EOL]     final Class<?> defaultValueType = defaultValue.getClass(); [EOL]     return new Object() { [EOL]  [EOL]         @Override [EOL]         public boolean equals(Object other) { [EOL]             if (other == this) [EOL]                 return true; [EOL]             if (other == null || other.getClass() != defaultValueType) { [EOL]                 return false; [EOL]             } [EOL]             if (Array.getLength(other) != length) [EOL]                 return false; [EOL]             for (int i = 0; i < length; ++i) { [EOL]                 Object value1 = Array.get(defaultValue, i); [EOL]                 Object value2 = Array.get(other, i); [EOL]                 if (value1 == value2) [EOL]                     continue; [EOL]                 if (value1 != null) { [EOL]                     if (!value1.equals(value2)) { [EOL]                         return false; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             return true; [EOL]         } [EOL]     }; [EOL] }
public static Object getArrayComparator(final Object defaultValue) { [EOL]     final int length = Array.getLength(defaultValue); [EOL]     final Class<?> defaultValueType = defaultValue.getClass(); [EOL]     return new Object() { [EOL]  [EOL]         @Override [EOL]         public boolean equals(Object other) { [EOL]             if (other == this) [EOL]                 return true; [EOL]             if (other == null || other.getClass() != defaultValueType) { [EOL]                 return false; [EOL]             } [EOL]             if (Array.getLength(other) != length) [EOL]                 return false; [EOL]             for (int i = 0; i < length; ++i) { [EOL]                 Object value1 = Array.get(defaultValue, i); [EOL]                 Object value2 = Array.get(other, i); [EOL]                 if (value1 == value2) [EOL]                     continue; [EOL]                 if (value1 != null) { [EOL]                     if (!value1.equals(value2)) { [EOL]                         return false; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             return true; [EOL]         } [EOL]     }; [EOL] }
public static Object getArrayComparator(final Object defaultValue) { [EOL]     final int length = Array.getLength(defaultValue); [EOL]     final Class<?> defaultValueType = defaultValue.getClass(); [EOL]     return new Object() { [EOL]  [EOL]         @Override [EOL]         public boolean equals(Object other) { [EOL]             if (other == this) [EOL]                 return true; [EOL]             if (other == null || other.getClass() != defaultValueType) { [EOL]                 return false; [EOL]             } [EOL]             if (Array.getLength(other) != length) [EOL]                 return false; [EOL]             for (int i = 0; i < length; ++i) { [EOL]                 Object value1 = Array.get(defaultValue, i); [EOL]                 Object value2 = Array.get(other, i); [EOL]                 if (value1 == value2) [EOL]                     continue; [EOL]                 if (value1 != null) { [EOL]                     if (!value1.equals(value2)) { [EOL]                         return false; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             return true; [EOL]         } [EOL]     }; [EOL] }
public static Object getArrayComparator(final Object defaultValue) { [EOL]     final int length = Array.getLength(defaultValue); [EOL]     final Class<?> defaultValueType = defaultValue.getClass(); [EOL]     return new Object() { [EOL]  [EOL]         @Override [EOL]         public boolean equals(Object other) { [EOL]             if (other == this) [EOL]                 return true; [EOL]             if (other == null || other.getClass() != defaultValueType) { [EOL]                 return false; [EOL]             } [EOL]             if (Array.getLength(other) != length) [EOL]                 return false; [EOL]             for (int i = 0; i < length; ++i) { [EOL]                 Object value1 = Array.get(defaultValue, i); [EOL]                 Object value2 = Array.get(other, i); [EOL]                 if (value1 == value2) [EOL]                     continue; [EOL]                 if (value1 != null) { [EOL]                     if (!value1.equals(value2)) { [EOL]                         return false; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             return true; [EOL]         } [EOL]     }; [EOL] }
public static Object getArrayComparator(final Object defaultValue) { [EOL]     final int length = Array.getLength(defaultValue); [EOL]     final Class<?> defaultValueType = defaultValue.getClass(); [EOL]     return new Object() { [EOL]  [EOL]         @Override [EOL]         public boolean equals(Object other) { [EOL]             if (other == this) [EOL]                 return true; [EOL]             if (other == null || other.getClass() != defaultValueType) { [EOL]                 return false; [EOL]             } [EOL]             if (Array.getLength(other) != length) [EOL]                 return false; [EOL]             for (int i = 0; i < length; ++i) { [EOL]                 Object value1 = Array.get(defaultValue, i); [EOL]                 Object value2 = Array.get(other, i); [EOL]                 if (value1 == value2) [EOL]                     continue; [EOL]                 if (value1 != null) { [EOL]                     if (!value1.equals(value2)) { [EOL]                         return false; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             return true; [EOL]         } [EOL]     }; [EOL] }
public static Object getArrayComparator(final Object defaultValue) { [EOL]     final int length = Array.getLength(defaultValue); [EOL]     final Class<?> defaultValueType = defaultValue.getClass(); [EOL]     return new Object() { [EOL]  [EOL]         @Override [EOL]         public boolean equals(Object other) { [EOL]             if (other == this) [EOL]                 return true; [EOL]             if (other == null || other.getClass() != defaultValueType) { [EOL]                 return false; [EOL]             } [EOL]             if (Array.getLength(other) != length) [EOL]                 return false; [EOL]             for (int i = 0; i < length; ++i) { [EOL]                 Object value1 = Array.get(defaultValue, i); [EOL]                 Object value2 = Array.get(other, i); [EOL]                 if (value1 == value2) [EOL]                     continue; [EOL]                 if (value1 != null) { [EOL]                     if (!value1.equals(value2)) { [EOL]                         return false; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             return true; [EOL]         } [EOL]     }; [EOL] }
public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver) { [EOL]     if (resolver == null) { [EOL]         throw new IllegalArgumentException("Can not pass null resolver"); [EOL]     } [EOL]     AbstractTypeResolver[] all = ArrayBuilders.insertInListNoDup(_abstractTypeResolvers, resolver); [EOL]     return new DeserializerFactoryConfig(_additionalDeserializers, _additionalKeyDeserializers, _modifiers, all, _valueInstantiators); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver) { [EOL]     if (resolver == null) { [EOL]         throw new IllegalArgumentException("Can not pass null resolver"); [EOL]     } [EOL]     AbstractTypeResolver[] all = ArrayBuilders.insertInListNoDup(_abstractTypeResolvers, resolver); [EOL]     return new DeserializerFactoryConfig(_additionalDeserializers, _additionalKeyDeserializers, _modifiers, all, _valueInstantiators); [EOL] } public DeserializerFactoryConfig(); protected DeserializerFactoryConfig(Deserializers[] allAdditionalDeserializers, KeyDeserializers[] allAdditionalKeyDeserializers, BeanDeserializerModifier[] modifiers, AbstractTypeResolver[] atr, ValueInstantiators[] vi); public DeserializerFactoryConfig withAdditionalDeserializers(Deserializers additional); public DeserializerFactoryConfig withAdditionalKeyDeserializers(KeyDeserializers additional); public DeserializerFactoryConfig withDeserializerModifier(BeanDeserializerModifier modifier); public DeserializerFactoryConfig withAbstractTypeResolver(AbstractTypeResolver resolver); public DeserializerFactoryConfig withValueInstantiators(ValueInstantiators instantiators); public boolean hasDeserializers(); public boolean hasKeyDeserializers(); public boolean hasDeserializerModifiers(); public boolean hasAbstractTypeResolvers(); public boolean hasValueInstantiators(); public Iterable<Deserializers> deserializers(); public Iterable<KeyDeserializers> keyDeserializers(); public Iterable<BeanDeserializerModifier> deserializerModifiers(); public Iterable<AbstractTypeResolver> abstractTypeResolvers(); public Iterable<ValueInstantiators> valueInstantiators(); long serialVersionUID=Optional[3683541151102256824L]; Deserializers[] NO_DESERIALIZERS=Optional[new Deserializers[0]]; BeanDeserializerModifier[] NO_MODIFIERS=Optional[new BeanDeserializerModifier[0]]; AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS=Optional[new AbstractTypeResolver[0]]; ValueInstantiators[] NO_VALUE_INSTANTIATORS=Optional[new ValueInstantiators[0]]; KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS=Optional[new KeyDeserializers[] { new StdKeyDeserializers() }
public UnwrappingBeanPropertyWriter(BeanPropertyWriter base, NameTransformer unwrapper) { [EOL]     super(base); [EOL]     _nameTransformer = unwrapper; [EOL] }
public UnwrappingBeanPropertyWriter(BeanPropertyWriter base, NameTransformer unwrapper) { [EOL]     super(base); [EOL]     _nameTransformer = unwrapper; [EOL] }
@Override [EOL] public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     if (!ser.isUnwrappingSerializer()) { [EOL]         jgen.writeFieldName(_name); [EOL]     } [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
@Override [EOL] public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     if (!ser.isUnwrappingSerializer()) { [EOL]         jgen.writeFieldName(_name); [EOL]     } [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
@Override [EOL] public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     if (!ser.isUnwrappingSerializer()) { [EOL]         jgen.writeFieldName(_name); [EOL]     } [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
@Override [EOL] public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     if (!ser.isUnwrappingSerializer()) { [EOL]         jgen.writeFieldName(_name); [EOL]     } [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
@Override [EOL] public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     if (!ser.isUnwrappingSerializer()) { [EOL]         jgen.writeFieldName(_name); [EOL]     } [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
@Override [EOL] public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception { [EOL]     Object value = get(bean); [EOL]     if (value == null) { [EOL]         return; [EOL]     } [EOL]     JsonSerializer<Object> ser = _serializer; [EOL]     if (ser == null) { [EOL]         Class<?> cls = value.getClass(); [EOL]         PropertySerializerMap map = _dynamicSerializers; [EOL]         ser = map.serializerFor(cls); [EOL]         if (ser == null) { [EOL]             ser = _findAndAddDynamic(map, cls, prov); [EOL]         } [EOL]     } [EOL]     if (_suppressableValue != null) { [EOL]         if (MARKER_FOR_EMPTY == _suppressableValue) { [EOL]             if (ser.isEmpty(value)) { [EOL]                 return; [EOL]             } [EOL]         } else if (_suppressableValue.equals(value)) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     if (value == bean) { [EOL]         _handleSelfReference(bean, ser); [EOL]     } [EOL]     if (!ser.isUnwrappingSerializer()) { [EOL]         jgen.writeFieldName(_name); [EOL]     } [EOL]     if (_typeSerializer == null) { [EOL]         ser.serialize(value, jgen, prov); [EOL]     } else { [EOL]         ser.serializeWithType(value, jgen, prov, _typeSerializer); [EOL]     } [EOL] }
@Override [EOL] public void assignSerializer(JsonSerializer<Object> ser) { [EOL]     super.assignSerializer(ser); [EOL]     if (_serializer != null) { [EOL]         NameTransformer t = _nameTransformer; [EOL]         if (_serializer.isUnwrappingSerializer()) { [EOL]             t = NameTransformer.chainedTransformer(t, ((UnwrappingBeanSerializer) _serializer)._nameTransformer); [EOL]         } [EOL]         _serializer = _serializer.unwrappingSerializer(t); [EOL]     } [EOL] }
@Override [EOL] public void assignSerializer(JsonSerializer<Object> ser) { [EOL]     super.assignSerializer(ser); [EOL]     if (_serializer != null) { [EOL]         NameTransformer t = _nameTransformer; [EOL]         if (_serializer.isUnwrappingSerializer()) { [EOL]             t = NameTransformer.chainedTransformer(t, ((UnwrappingBeanSerializer) _serializer)._nameTransformer); [EOL]         } [EOL]         _serializer = _serializer.unwrappingSerializer(t); [EOL]     } [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdWriter oiw = _objectIdWriter; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (accessor != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo == null) { [EOL]             if (oiw != null) { [EOL]                 objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo("", null, null)); [EOL]                 oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } else { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             ObjectIdGenerator<?> gen; [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType type = provider.constructType(implClass); [EOL]             JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 BeanPropertyWriter idProp = null; [EOL]                 for (int i = 0, len = _props.length; ; ++i) { [EOL]                     if (i == len) { [EOL]                         throw new IllegalArgumentException("Invalid Object Id definition for " + _handledType.getName() + ": can not find property with name '" + propName + "'"); [EOL]                     } [EOL]                     BeanPropertyWriter prop = _props[i]; [EOL]                     if (propName.equals(prop.getName())) { [EOL]                         idProp = prop; [EOL]                         if (i > 0) { [EOL]                             System.arraycopy(_props, 0, _props, 1, i); [EOL]                             _props[0] = idProp; [EOL]                             if (_filteredProps != null) { [EOL]                                 BeanPropertyWriter fp = _filteredProps[i]; [EOL]                                 System.arraycopy(_filteredProps, 0, _filteredProps, 1, i); [EOL]                                 _filteredProps[0] = fp; [EOL]                             } [EOL]                         } [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]                 oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]             } else { [EOL]                 gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]                 oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } [EOL]     } [EOL]     BeanSerializerBase contextual = this; [EOL]     if (oiw != null) { [EOL]         JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property); [EOL]         oiw = oiw.withSerializer(ser); [EOL]         if (oiw != _objectIdWriter) { [EOL]             contextual = contextual.withObjectIdWriter(oiw); [EOL]         } [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         contextual = contextual.withIgnorals(ignorals); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArraySerializer(); [EOL]     } [EOL]     return contextual; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdWriter oiw = _objectIdWriter; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (accessor != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo == null) { [EOL]             if (oiw != null) { [EOL]                 objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo("", null, null)); [EOL]                 oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } else { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             ObjectIdGenerator<?> gen; [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType type = provider.constructType(implClass); [EOL]             JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 BeanPropertyWriter idProp = null; [EOL]                 for (int i = 0, len = _props.length; ; ++i) { [EOL]                     if (i == len) { [EOL]                         throw new IllegalArgumentException("Invalid Object Id definition for " + _handledType.getName() + ": can not find property with name '" + propName + "'"); [EOL]                     } [EOL]                     BeanPropertyWriter prop = _props[i]; [EOL]                     if (propName.equals(prop.getName())) { [EOL]                         idProp = prop; [EOL]                         if (i > 0) { [EOL]                             System.arraycopy(_props, 0, _props, 1, i); [EOL]                             _props[0] = idProp; [EOL]                             if (_filteredProps != null) { [EOL]                                 BeanPropertyWriter fp = _filteredProps[i]; [EOL]                                 System.arraycopy(_filteredProps, 0, _filteredProps, 1, i); [EOL]                                 _filteredProps[0] = fp; [EOL]                             } [EOL]                         } [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]                 oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]             } else { [EOL]                 gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]                 oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } [EOL]     } [EOL]     BeanSerializerBase contextual = this; [EOL]     if (oiw != null) { [EOL]         JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property); [EOL]         oiw = oiw.withSerializer(ser); [EOL]         if (oiw != _objectIdWriter) { [EOL]             contextual = contextual.withObjectIdWriter(oiw); [EOL]         } [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         contextual = contextual.withIgnorals(ignorals); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArraySerializer(); [EOL]     } [EOL]     return contextual; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdWriter oiw = _objectIdWriter; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (accessor != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo == null) { [EOL]             if (oiw != null) { [EOL]                 objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo("", null, null)); [EOL]                 oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } else { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             ObjectIdGenerator<?> gen; [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType type = provider.constructType(implClass); [EOL]             JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 BeanPropertyWriter idProp = null; [EOL]                 for (int i = 0, len = _props.length; ; ++i) { [EOL]                     if (i == len) { [EOL]                         throw new IllegalArgumentException("Invalid Object Id definition for " + _handledType.getName() + ": can not find property with name '" + propName + "'"); [EOL]                     } [EOL]                     BeanPropertyWriter prop = _props[i]; [EOL]                     if (propName.equals(prop.getName())) { [EOL]                         idProp = prop; [EOL]                         if (i > 0) { [EOL]                             System.arraycopy(_props, 0, _props, 1, i); [EOL]                             _props[0] = idProp; [EOL]                             if (_filteredProps != null) { [EOL]                                 BeanPropertyWriter fp = _filteredProps[i]; [EOL]                                 System.arraycopy(_filteredProps, 0, _filteredProps, 1, i); [EOL]                                 _filteredProps[0] = fp; [EOL]                             } [EOL]                         } [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]                 oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]             } else { [EOL]                 gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]                 oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } [EOL]     } [EOL]     BeanSerializerBase contextual = this; [EOL]     if (oiw != null) { [EOL]         JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property); [EOL]         oiw = oiw.withSerializer(ser); [EOL]         if (oiw != _objectIdWriter) { [EOL]             contextual = contextual.withObjectIdWriter(oiw); [EOL]         } [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         contextual = contextual.withIgnorals(ignorals); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArraySerializer(); [EOL]     } [EOL]     return contextual; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdWriter oiw = _objectIdWriter; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (accessor != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo == null) { [EOL]             if (oiw != null) { [EOL]                 objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo("", null, null)); [EOL]                 oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } else { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             ObjectIdGenerator<?> gen; [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType type = provider.constructType(implClass); [EOL]             JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 BeanPropertyWriter idProp = null; [EOL]                 for (int i = 0, len = _props.length; ; ++i) { [EOL]                     if (i == len) { [EOL]                         throw new IllegalArgumentException("Invalid Object Id definition for " + _handledType.getName() + ": can not find property with name '" + propName + "'"); [EOL]                     } [EOL]                     BeanPropertyWriter prop = _props[i]; [EOL]                     if (propName.equals(prop.getName())) { [EOL]                         idProp = prop; [EOL]                         if (i > 0) { [EOL]                             System.arraycopy(_props, 0, _props, 1, i); [EOL]                             _props[0] = idProp; [EOL]                             if (_filteredProps != null) { [EOL]                                 BeanPropertyWriter fp = _filteredProps[i]; [EOL]                                 System.arraycopy(_filteredProps, 0, _filteredProps, 1, i); [EOL]                                 _filteredProps[0] = fp; [EOL]                             } [EOL]                         } [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]                 oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]             } else { [EOL]                 gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]                 oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } [EOL]     } [EOL]     BeanSerializerBase contextual = this; [EOL]     if (oiw != null) { [EOL]         JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property); [EOL]         oiw = oiw.withSerializer(ser); [EOL]         if (oiw != _objectIdWriter) { [EOL]             contextual = contextual.withObjectIdWriter(oiw); [EOL]         } [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         contextual = contextual.withIgnorals(ignorals); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArraySerializer(); [EOL]     } [EOL]     return contextual; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdWriter oiw = _objectIdWriter; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (accessor != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo == null) { [EOL]             if (oiw != null) { [EOL]                 objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo("", null, null)); [EOL]                 oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } else { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             ObjectIdGenerator<?> gen; [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType type = provider.constructType(implClass); [EOL]             JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 BeanPropertyWriter idProp = null; [EOL]                 for (int i = 0, len = _props.length; ; ++i) { [EOL]                     if (i == len) { [EOL]                         throw new IllegalArgumentException("Invalid Object Id definition for " + _handledType.getName() + ": can not find property with name '" + propName + "'"); [EOL]                     } [EOL]                     BeanPropertyWriter prop = _props[i]; [EOL]                     if (propName.equals(prop.getName())) { [EOL]                         idProp = prop; [EOL]                         if (i > 0) { [EOL]                             System.arraycopy(_props, 0, _props, 1, i); [EOL]                             _props[0] = idProp; [EOL]                             if (_filteredProps != null) { [EOL]                                 BeanPropertyWriter fp = _filteredProps[i]; [EOL]                                 System.arraycopy(_filteredProps, 0, _filteredProps, 1, i); [EOL]                                 _filteredProps[0] = fp; [EOL]                             } [EOL]                         } [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]                 oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]             } else { [EOL]                 gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]                 oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } [EOL]     } [EOL]     BeanSerializerBase contextual = this; [EOL]     if (oiw != null) { [EOL]         JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property); [EOL]         oiw = oiw.withSerializer(ser); [EOL]         if (oiw != _objectIdWriter) { [EOL]             contextual = contextual.withObjectIdWriter(oiw); [EOL]         } [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         contextual = contextual.withIgnorals(ignorals); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArraySerializer(); [EOL]     } [EOL]     return contextual; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property) throws JsonMappingException { [EOL]     ObjectIdWriter oiw = _objectIdWriter; [EOL]     String[] ignorals = null; [EOL]     final AnnotationIntrospector intr = provider.getAnnotationIntrospector(); [EOL]     final AnnotatedMember accessor = (property == null || intr == null) ? null : property.getMember(); [EOL]     if (accessor != null) { [EOL]         ignorals = intr.findPropertiesToIgnore(accessor); [EOL]         ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor); [EOL]         if (objectIdInfo == null) { [EOL]             if (oiw != null) { [EOL]                 objectIdInfo = intr.findObjectReferenceInfo(accessor, new ObjectIdInfo("", null, null)); [EOL]                 oiw = _objectIdWriter.withAlwaysAsId(objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } else { [EOL]             objectIdInfo = intr.findObjectReferenceInfo(accessor, objectIdInfo); [EOL]             ObjectIdGenerator<?> gen; [EOL]             Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]             JavaType type = provider.constructType(implClass); [EOL]             JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]             if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]                 String propName = objectIdInfo.getPropertyName(); [EOL]                 BeanPropertyWriter idProp = null; [EOL]                 for (int i = 0, len = _props.length; ; ++i) { [EOL]                     if (i == len) { [EOL]                         throw new IllegalArgumentException("Invalid Object Id definition for " + _handledType.getName() + ": can not find property with name '" + propName + "'"); [EOL]                     } [EOL]                     BeanPropertyWriter prop = _props[i]; [EOL]                     if (propName.equals(prop.getName())) { [EOL]                         idProp = prop; [EOL]                         if (i > 0) { [EOL]                             System.arraycopy(_props, 0, _props, 1, i); [EOL]                             _props[0] = idProp; [EOL]                             if (_filteredProps != null) { [EOL]                                 BeanPropertyWriter fp = _filteredProps[i]; [EOL]                                 System.arraycopy(_filteredProps, 0, _filteredProps, 1, i); [EOL]                                 _filteredProps[0] = fp; [EOL]                             } [EOL]                         } [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]                 idType = idProp.getType(); [EOL]                 gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]                 oiw = ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]             } else { [EOL]                 gen = provider.objectIdGeneratorInstance(accessor, objectIdInfo); [EOL]                 oiw = ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL]             } [EOL]         } [EOL]     } [EOL]     BeanSerializerBase contextual = this; [EOL]     if (oiw != null) { [EOL]         JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property); [EOL]         oiw = oiw.withSerializer(ser); [EOL]         if (oiw != _objectIdWriter) { [EOL]             contextual = contextual.withObjectIdWriter(oiw); [EOL]         } [EOL]     } [EOL]     if (ignorals != null && ignorals.length != 0) { [EOL]         contextual = contextual.withIgnorals(ignorals); [EOL]     } [EOL]     JsonFormat.Shape shape = null; [EOL]     if (accessor != null) { [EOL]         JsonFormat.Value format = intr.findFormat((Annotated) accessor); [EOL]         if (format != null) { [EOL]             shape = format.getShape(); [EOL]         } [EOL]     } [EOL]     if (shape == null) { [EOL]         shape = _serializationShape; [EOL]     } [EOL]     if (shape == JsonFormat.Shape.ARRAY) { [EOL]         contextual = contextual.asArraySerializer(); [EOL]     } [EOL]     return contextual; [EOL] }
@Override [EOL] public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     if (_objectIdWriter != null) { [EOL]         _serializeWithObjectId(bean, jgen, provider, typeSer); [EOL]         return; [EOL]     } [EOL]     String typeStr = (_typeId == null) ? null : _customTypeId(bean); [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypePrefixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypePrefixForObject(bean, jgen, typeStr); [EOL]     } [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypeSuffixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypeSuffixForObject(bean, jgen, typeStr); [EOL]     } [EOL] }
@Override [EOL] public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     if (_objectIdWriter != null) { [EOL]         _serializeWithObjectId(bean, jgen, provider, typeSer); [EOL]         return; [EOL]     } [EOL]     String typeStr = (_typeId == null) ? null : _customTypeId(bean); [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypePrefixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypePrefixForObject(bean, jgen, typeStr); [EOL]     } [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypeSuffixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypeSuffixForObject(bean, jgen, typeStr); [EOL]     } [EOL] }
@Override [EOL] public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     if (_objectIdWriter != null) { [EOL]         _serializeWithObjectId(bean, jgen, provider, typeSer); [EOL]         return; [EOL]     } [EOL]     String typeStr = (_typeId == null) ? null : _customTypeId(bean); [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypePrefixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypePrefixForObject(bean, jgen, typeStr); [EOL]     } [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypeSuffixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypeSuffixForObject(bean, jgen, typeStr); [EOL]     } [EOL] }
@Override [EOL] public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     if (_objectIdWriter != null) { [EOL]         _serializeWithObjectId(bean, jgen, provider, typeSer); [EOL]         return; [EOL]     } [EOL]     String typeStr = (_typeId == null) ? null : _customTypeId(bean); [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypePrefixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypePrefixForObject(bean, jgen, typeStr); [EOL]     } [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     if (typeStr == null) { [EOL]         typeSer.writeTypeSuffixForObject(bean, jgen); [EOL]     } else { [EOL]         typeSer.writeCustomTypeSuffixForObject(bean, jgen, typeStr); [EOL]     } [EOL] }
protected final void _serializeWithObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider, boolean startEndObject) throws IOException, JsonGenerationException { [EOL]     final ObjectIdWriter w = _objectIdWriter; [EOL]     WritableObjectId objectId = provider.findObjectId(bean, w.generator); [EOL]     if (objectId.writeAsId(jgen, provider, w)) { [EOL]         return; [EOL]     } [EOL]     Object id = objectId.generateId(bean); [EOL]     if (w.alwaysAsId) { [EOL]         w.serializer.serialize(id, jgen, provider); [EOL]         return; [EOL]     } [EOL]     if (startEndObject) { [EOL]         jgen.writeStartObject(); [EOL]     } [EOL]     objectId.writeAsField(jgen, provider, w); [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     if (startEndObject) { [EOL]         jgen.writeEndObject(); [EOL]     } [EOL] }
protected final void _serializeWithObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider, boolean startEndObject) throws IOException, JsonGenerationException { [EOL]     final ObjectIdWriter w = _objectIdWriter; [EOL]     WritableObjectId objectId = provider.findObjectId(bean, w.generator); [EOL]     if (objectId.writeAsId(jgen, provider, w)) { [EOL]         return; [EOL]     } [EOL]     Object id = objectId.generateId(bean); [EOL]     if (w.alwaysAsId) { [EOL]         w.serializer.serialize(id, jgen, provider); [EOL]         return; [EOL]     } [EOL]     if (startEndObject) { [EOL]         jgen.writeStartObject(); [EOL]     } [EOL]     objectId.writeAsField(jgen, provider, w); [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     if (startEndObject) { [EOL]         jgen.writeEndObject(); [EOL]     } [EOL] }
protected final void _serializeWithObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider, boolean startEndObject) throws IOException, JsonGenerationException { [EOL]     final ObjectIdWriter w = _objectIdWriter; [EOL]     WritableObjectId objectId = provider.findObjectId(bean, w.generator); [EOL]     if (objectId.writeAsId(jgen, provider, w)) { [EOL]         return; [EOL]     } [EOL]     Object id = objectId.generateId(bean); [EOL]     if (w.alwaysAsId) { [EOL]         w.serializer.serialize(id, jgen, provider); [EOL]         return; [EOL]     } [EOL]     if (startEndObject) { [EOL]         jgen.writeStartObject(); [EOL]     } [EOL]     objectId.writeAsField(jgen, provider, w); [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     if (startEndObject) { [EOL]         jgen.writeEndObject(); [EOL]     } [EOL] }
protected final void _serializeWithObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider, boolean startEndObject) throws IOException, JsonGenerationException { [EOL]     final ObjectIdWriter w = _objectIdWriter; [EOL]     WritableObjectId objectId = provider.findObjectId(bean, w.generator); [EOL]     if (objectId.writeAsId(jgen, provider, w)) { [EOL]         return; [EOL]     } [EOL]     Object id = objectId.generateId(bean); [EOL]     if (w.alwaysAsId) { [EOL]         w.serializer.serialize(id, jgen, provider); [EOL]         return; [EOL]     } [EOL]     if (startEndObject) { [EOL]         jgen.writeStartObject(); [EOL]     } [EOL]     objectId.writeAsField(jgen, provider, w); [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     if (startEndObject) { [EOL]         jgen.writeEndObject(); [EOL]     } [EOL] }
protected final void _serializeWithObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider, boolean startEndObject) throws IOException, JsonGenerationException { [EOL]     final ObjectIdWriter w = _objectIdWriter; [EOL]     WritableObjectId objectId = provider.findObjectId(bean, w.generator); [EOL]     if (objectId.writeAsId(jgen, provider, w)) { [EOL]         return; [EOL]     } [EOL]     Object id = objectId.generateId(bean); [EOL]     if (w.alwaysAsId) { [EOL]         w.serializer.serialize(id, jgen, provider); [EOL]         return; [EOL]     } [EOL]     if (startEndObject) { [EOL]         jgen.writeStartObject(); [EOL]     } [EOL]     objectId.writeAsField(jgen, provider, w); [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     if (startEndObject) { [EOL]         jgen.writeEndObject(); [EOL]     } [EOL] }
protected final void _serializeWithObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider, boolean startEndObject) throws IOException, JsonGenerationException { [EOL]     final ObjectIdWriter w = _objectIdWriter; [EOL]     WritableObjectId objectId = provider.findObjectId(bean, w.generator); [EOL]     if (objectId.writeAsId(jgen, provider, w)) { [EOL]         return; [EOL]     } [EOL]     Object id = objectId.generateId(bean); [EOL]     if (w.alwaysAsId) { [EOL]         w.serializer.serialize(id, jgen, provider); [EOL]         return; [EOL]     } [EOL]     if (startEndObject) { [EOL]         jgen.writeStartObject(); [EOL]     } [EOL]     objectId.writeAsField(jgen, provider, w); [EOL]     if (_propertyFilterId != null) { [EOL]         serializeFieldsFiltered(bean, jgen, provider); [EOL]     } else { [EOL]         serializeFields(bean, jgen, provider); [EOL]     } [EOL]     if (startEndObject) { [EOL]         jgen.writeEndObject(); [EOL]     } [EOL] }
protected void serializeFieldsFiltered(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final BeanPropertyWriter[] props; [EOL]     if (_filteredProps != null && provider.getActiveView() != null) { [EOL]         props = _filteredProps; [EOL]     } else { [EOL]         props = _props; [EOL]     } [EOL]     final BeanPropertyFilter filter = findFilter(provider); [EOL]     if (filter == null) { [EOL]         serializeFields(bean, jgen, provider); [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         for (final int len = props.length; i < len; ++i) { [EOL]             BeanPropertyWriter prop = props[i]; [EOL]             if (prop != null) { [EOL]                 filter.serializeAsField(bean, jgen, provider, prop); [EOL]             } [EOL]         } [EOL]         if (_anyGetterWriter != null) { [EOL]             _anyGetterWriter.getAndSerialize(bean, jgen, provider); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         wrapAndThrow(provider, e, bean, name); [EOL]     } catch (StackOverflowError e) { [EOL]         JsonMappingException mapE = new JsonMappingException("Infinite recursion (StackOverflowError)", e); [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         mapE.prependPath(new JsonMappingException.Reference(bean, name)); [EOL]         throw mapE; [EOL]     } [EOL] }
protected void serializeFieldsFiltered(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final BeanPropertyWriter[] props; [EOL]     if (_filteredProps != null && provider.getActiveView() != null) { [EOL]         props = _filteredProps; [EOL]     } else { [EOL]         props = _props; [EOL]     } [EOL]     final BeanPropertyFilter filter = findFilter(provider); [EOL]     if (filter == null) { [EOL]         serializeFields(bean, jgen, provider); [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         for (final int len = props.length; i < len; ++i) { [EOL]             BeanPropertyWriter prop = props[i]; [EOL]             if (prop != null) { [EOL]                 filter.serializeAsField(bean, jgen, provider, prop); [EOL]             } [EOL]         } [EOL]         if (_anyGetterWriter != null) { [EOL]             _anyGetterWriter.getAndSerialize(bean, jgen, provider); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         wrapAndThrow(provider, e, bean, name); [EOL]     } catch (StackOverflowError e) { [EOL]         JsonMappingException mapE = new JsonMappingException("Infinite recursion (StackOverflowError)", e); [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         mapE.prependPath(new JsonMappingException.Reference(bean, name)); [EOL]         throw mapE; [EOL]     } [EOL] }
protected void serializeFieldsFiltered(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final BeanPropertyWriter[] props; [EOL]     if (_filteredProps != null && provider.getActiveView() != null) { [EOL]         props = _filteredProps; [EOL]     } else { [EOL]         props = _props; [EOL]     } [EOL]     final BeanPropertyFilter filter = findFilter(provider); [EOL]     if (filter == null) { [EOL]         serializeFields(bean, jgen, provider); [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         for (final int len = props.length; i < len; ++i) { [EOL]             BeanPropertyWriter prop = props[i]; [EOL]             if (prop != null) { [EOL]                 filter.serializeAsField(bean, jgen, provider, prop); [EOL]             } [EOL]         } [EOL]         if (_anyGetterWriter != null) { [EOL]             _anyGetterWriter.getAndSerialize(bean, jgen, provider); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         wrapAndThrow(provider, e, bean, name); [EOL]     } catch (StackOverflowError e) { [EOL]         JsonMappingException mapE = new JsonMappingException("Infinite recursion (StackOverflowError)", e); [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         mapE.prependPath(new JsonMappingException.Reference(bean, name)); [EOL]         throw mapE; [EOL]     } [EOL] }
protected void serializeFieldsFiltered(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final BeanPropertyWriter[] props; [EOL]     if (_filteredProps != null && provider.getActiveView() != null) { [EOL]         props = _filteredProps; [EOL]     } else { [EOL]         props = _props; [EOL]     } [EOL]     final BeanPropertyFilter filter = findFilter(provider); [EOL]     if (filter == null) { [EOL]         serializeFields(bean, jgen, provider); [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         for (final int len = props.length; i < len; ++i) { [EOL]             BeanPropertyWriter prop = props[i]; [EOL]             if (prop != null) { [EOL]                 filter.serializeAsField(bean, jgen, provider, prop); [EOL]             } [EOL]         } [EOL]         if (_anyGetterWriter != null) { [EOL]             _anyGetterWriter.getAndSerialize(bean, jgen, provider); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         wrapAndThrow(provider, e, bean, name); [EOL]     } catch (StackOverflowError e) { [EOL]         JsonMappingException mapE = new JsonMappingException("Infinite recursion (StackOverflowError)", e); [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         mapE.prependPath(new JsonMappingException.Reference(bean, name)); [EOL]         throw mapE; [EOL]     } [EOL] }
protected void serializeFieldsFiltered(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final BeanPropertyWriter[] props; [EOL]     if (_filteredProps != null && provider.getActiveView() != null) { [EOL]         props = _filteredProps; [EOL]     } else { [EOL]         props = _props; [EOL]     } [EOL]     final BeanPropertyFilter filter = findFilter(provider); [EOL]     if (filter == null) { [EOL]         serializeFields(bean, jgen, provider); [EOL]         return; [EOL]     } [EOL]     int i = 0; [EOL]     try { [EOL]         for (final int len = props.length; i < len; ++i) { [EOL]             BeanPropertyWriter prop = props[i]; [EOL]             if (prop != null) { [EOL]                 filter.serializeAsField(bean, jgen, provider, prop); [EOL]             } [EOL]         } [EOL]         if (_anyGetterWriter != null) { [EOL]             _anyGetterWriter.getAndSerialize(bean, jgen, provider); [EOL]         } [EOL]     } catch (Exception e) { [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         wrapAndThrow(provider, e, bean, name); [EOL]     } catch (StackOverflowError e) { [EOL]         JsonMappingException mapE = new JsonMappingException("Infinite recursion (StackOverflowError)", e); [EOL]         String name = (i == props.length) ? "[anySetter]" : props[i].getName(); [EOL]         mapE.prependPath(new JsonMappingException.Reference(bean, name)); [EOL]         throw mapE; [EOL]     } [EOL] }
protected BeanPropertyFilter findFilter(SerializerProvider provider) throws JsonMappingException { [EOL]     final Object filterId = _propertyFilterId; [EOL]     FilterProvider filters = provider.getFilterProvider(); [EOL]     if (filters == null) { [EOL]         throw new JsonMappingException("Can not resolve BeanPropertyFilter with id '" + filterId + "'; no FilterProvider configured"); [EOL]     } [EOL]     BeanPropertyFilter filter = filters.findFilter(filterId); [EOL]     return filter; [EOL] }
protected BeanPropertyFilter findFilter(SerializerProvider provider) throws JsonMappingException { [EOL]     final Object filterId = _propertyFilterId; [EOL]     FilterProvider filters = provider.getFilterProvider(); [EOL]     if (filters == null) { [EOL]         throw new JsonMappingException("Can not resolve BeanPropertyFilter with id '" + filterId + "'; no FilterProvider configured"); [EOL]     } [EOL]     BeanPropertyFilter filter = filters.findFilter(filterId); [EOL]     return filter; [EOL] }
@Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException { [EOL]     ObjectNode o = createSchemaNode("object", true); [EOL]     JsonSerializableSchema ann = _handledType.getAnnotation(JsonSerializableSchema.class); [EOL]     if (ann != null) { [EOL]         String id = ann.id(); [EOL]         if (id != null && id.length() > 0) { [EOL]             o.put("id", id); [EOL]         } [EOL]     } [EOL]     ObjectNode propertiesNode = o.objectNode(); [EOL]     final BeanPropertyFilter filter; [EOL]     if (_propertyFilterId != null) { [EOL]         filter = findFilter(provider); [EOL]     } else { [EOL]         filter = null; [EOL]     } [EOL]     for (int i = 0; i < _props.length; i++) { [EOL]         BeanPropertyWriter prop = _props[i]; [EOL]         if (filter == null) { [EOL]             prop.depositSchemaProperty(propertiesNode, provider); [EOL]         } else { [EOL]             filter.depositSchemaProperty(prop, propertiesNode, provider); [EOL]         } [EOL]     } [EOL]     o.put("properties", propertiesNode); [EOL]     return o; [EOL] }
@Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException { [EOL]     ObjectNode o = createSchemaNode("object", true); [EOL]     JsonSerializableSchema ann = _handledType.getAnnotation(JsonSerializableSchema.class); [EOL]     if (ann != null) { [EOL]         String id = ann.id(); [EOL]         if (id != null && id.length() > 0) { [EOL]             o.put("id", id); [EOL]         } [EOL]     } [EOL]     ObjectNode propertiesNode = o.objectNode(); [EOL]     final BeanPropertyFilter filter; [EOL]     if (_propertyFilterId != null) { [EOL]         filter = findFilter(provider); [EOL]     } else { [EOL]         filter = null; [EOL]     } [EOL]     for (int i = 0; i < _props.length; i++) { [EOL]         BeanPropertyWriter prop = _props[i]; [EOL]         if (filter == null) { [EOL]             prop.depositSchemaProperty(propertiesNode, provider); [EOL]         } else { [EOL]             filter.depositSchemaProperty(prop, propertiesNode, provider); [EOL]         } [EOL]     } [EOL]     o.put("properties", propertiesNode); [EOL]     return o; [EOL] }
@Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException { [EOL]     ObjectNode o = createSchemaNode("object", true); [EOL]     JsonSerializableSchema ann = _handledType.getAnnotation(JsonSerializableSchema.class); [EOL]     if (ann != null) { [EOL]         String id = ann.id(); [EOL]         if (id != null && id.length() > 0) { [EOL]             o.put("id", id); [EOL]         } [EOL]     } [EOL]     ObjectNode propertiesNode = o.objectNode(); [EOL]     final BeanPropertyFilter filter; [EOL]     if (_propertyFilterId != null) { [EOL]         filter = findFilter(provider); [EOL]     } else { [EOL]         filter = null; [EOL]     } [EOL]     for (int i = 0; i < _props.length; i++) { [EOL]         BeanPropertyWriter prop = _props[i]; [EOL]         if (filter == null) { [EOL]             prop.depositSchemaProperty(propertiesNode, provider); [EOL]         } else { [EOL]             filter.depositSchemaProperty(prop, propertiesNode, provider); [EOL]         } [EOL]     } [EOL]     o.put("properties", propertiesNode); [EOL]     return o; [EOL] }
public List<BeanPropertyWriter> changeProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> beanProperties) { [EOL]     return beanProperties; [EOL] }
public List<BeanPropertyWriter> orderProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> beanProperties) { [EOL]     return beanProperties; [EOL] }
public List<BeanPropertyWriter> orderProperties(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyWriter> beanProperties) { [EOL]     return beanProperties; [EOL] }
protected POJOPropertiesCollector(MapperConfig<?> config, boolean forSerialization, JavaType type, AnnotatedClass classDef, String mutatorPrefix) { [EOL]     _config = config; [EOL]     _forSerialization = forSerialization; [EOL]     _type = type; [EOL]     _classDef = classDef; [EOL]     _mutatorPrefix = (mutatorPrefix == null) ? "set" : mutatorPrefix; [EOL]     _annotationIntrospector = config.isAnnotationProcessingEnabled() ? _config.getAnnotationIntrospector() : null; [EOL]     if (_annotationIntrospector == null) { [EOL]         _visibilityChecker = _config.getDefaultVisibilityChecker(); [EOL]     } else { [EOL]         _visibilityChecker = _annotationIntrospector.findAutoDetectVisibility(classDef, _config.getDefaultVisibilityChecker()); [EOL]     } [EOL] }
protected POJOPropertiesCollector(MapperConfig<?> config, boolean forSerialization, JavaType type, AnnotatedClass classDef, String mutatorPrefix) { [EOL]     _config = config; [EOL]     _forSerialization = forSerialization; [EOL]     _type = type; [EOL]     _classDef = classDef; [EOL]     _mutatorPrefix = (mutatorPrefix == null) ? "set" : mutatorPrefix; [EOL]     _annotationIntrospector = config.isAnnotationProcessingEnabled() ? _config.getAnnotationIntrospector() : null; [EOL]     if (_annotationIntrospector == null) { [EOL]         _visibilityChecker = _config.getDefaultVisibilityChecker(); [EOL]     } else { [EOL]         _visibilityChecker = _annotationIntrospector.findAutoDetectVisibility(classDef, _config.getDefaultVisibilityChecker()); [EOL]     } [EOL] }
protected POJOPropertiesCollector(MapperConfig<?> config, boolean forSerialization, JavaType type, AnnotatedClass classDef, String mutatorPrefix) { [EOL]     _config = config; [EOL]     _forSerialization = forSerialization; [EOL]     _type = type; [EOL]     _classDef = classDef; [EOL]     _mutatorPrefix = (mutatorPrefix == null) ? "set" : mutatorPrefix; [EOL]     _annotationIntrospector = config.isAnnotationProcessingEnabled() ? _config.getAnnotationIntrospector() : null; [EOL]     if (_annotationIntrospector == null) { [EOL]         _visibilityChecker = _config.getDefaultVisibilityChecker(); [EOL]     } else { [EOL]         _visibilityChecker = _annotationIntrospector.findAutoDetectVisibility(classDef, _config.getDefaultVisibilityChecker()); [EOL]     } [EOL] }
public AnnotatedMethod getJsonValueMethod() { [EOL]     if (_jsonValueGetters != null) { [EOL]         if (_jsonValueGetters.size() > 1) { [EOL]             reportProblem("Multiple value properties defined (" + _jsonValueGetters.get(0) + " vs " + _jsonValueGetters.get(1) + ")"); [EOL]         } [EOL]         return _jsonValueGetters.get(0); [EOL]     } [EOL]     return null; [EOL] }
public AnnotatedMethod getJsonValueMethod() { [EOL]     if (_jsonValueGetters != null) { [EOL]         if (_jsonValueGetters.size() > 1) { [EOL]             reportProblem("Multiple value properties defined (" + _jsonValueGetters.get(0) + " vs " + _jsonValueGetters.get(1) + ")"); [EOL]         } [EOL]         return _jsonValueGetters.get(0); [EOL]     } [EOL]     return null; [EOL] }
public AnnotatedMethod getJsonValueMethod() { [EOL]     if (_jsonValueGetters != null) { [EOL]         if (_jsonValueGetters.size() > 1) { [EOL]             reportProblem("Multiple value properties defined (" + _jsonValueGetters.get(0) + " vs " + _jsonValueGetters.get(1) + ")"); [EOL]         } [EOL]         return _jsonValueGetters.get(0); [EOL]     } [EOL]     return null; [EOL] }
public AnnotatedMethod getJsonValueMethod() { [EOL]     if (_jsonValueGetters != null) { [EOL]         if (_jsonValueGetters.size() > 1) { [EOL]             reportProblem("Multiple value properties defined (" + _jsonValueGetters.get(0) + " vs " + _jsonValueGetters.get(1) + ")"); [EOL]         } [EOL]         return _jsonValueGetters.get(0); [EOL]     } [EOL]     return null; [EOL] }
protected Map<String, POJOPropertyBuilder> getPropertyMap() { [EOL]     return _properties; [EOL] }
public POJOPropertiesCollector collect() { [EOL]     _properties.clear(); [EOL]     _addFields(); [EOL]     _addMethods(); [EOL]     _addCreators(); [EOL]     _addInjectables(); [EOL]     _removeUnwantedProperties(); [EOL]     _renameProperties(); [EOL]     PropertyNamingStrategy naming = _findNamingStrategy(); [EOL]     if (naming != null) { [EOL]         _renameUsing(naming); [EOL]     } [EOL]     for (POJOPropertyBuilder property : _properties.values()) { [EOL]         property.trimByVisibility(); [EOL]     } [EOL]     for (POJOPropertyBuilder property : _properties.values()) { [EOL]         property.mergeAnnotations(_forSerialization); [EOL]     } [EOL]     if (_config.isEnabled(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME)) { [EOL]         _renameWithWrappers(); [EOL]     } [EOL]     _sortProperties(); [EOL]     return this; [EOL] }
public POJOPropertiesCollector collect() { [EOL]     _properties.clear(); [EOL]     _addFields(); [EOL]     _addMethods(); [EOL]     _addCreators(); [EOL]     _addInjectables(); [EOL]     _removeUnwantedProperties(); [EOL]     _renameProperties(); [EOL]     PropertyNamingStrategy naming = _findNamingStrategy(); [EOL]     if (naming != null) { [EOL]         _renameUsing(naming); [EOL]     } [EOL]     for (POJOPropertyBuilder property : _properties.values()) { [EOL]         property.trimByVisibility(); [EOL]     } [EOL]     for (POJOPropertyBuilder property : _properties.values()) { [EOL]         property.mergeAnnotations(_forSerialization); [EOL]     } [EOL]     if (_config.isEnabled(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME)) { [EOL]         _renameWithWrappers(); [EOL]     } [EOL]     _sortProperties(); [EOL]     return this; [EOL] }
public POJOPropertiesCollector collect() { [EOL]     _properties.clear(); [EOL]     _addFields(); [EOL]     _addMethods(); [EOL]     _addCreators(); [EOL]     _addInjectables(); [EOL]     _removeUnwantedProperties(); [EOL]     _renameProperties(); [EOL]     PropertyNamingStrategy naming = _findNamingStrategy(); [EOL]     if (naming != null) { [EOL]         _renameUsing(naming); [EOL]     } [EOL]     for (POJOPropertyBuilder property : _properties.values()) { [EOL]         property.trimByVisibility(); [EOL]     } [EOL]     for (POJOPropertyBuilder property : _properties.values()) { [EOL]         property.mergeAnnotations(_forSerialization); [EOL]     } [EOL]     if (_config.isEnabled(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME)) { [EOL]         _renameWithWrappers(); [EOL]     } [EOL]     _sortProperties(); [EOL]     return this; [EOL] }
public POJOPropertiesCollector collect() { [EOL]     _properties.clear(); [EOL]     _addFields(); [EOL]     _addMethods(); [EOL]     _addCreators(); [EOL]     _addInjectables(); [EOL]     _removeUnwantedProperties(); [EOL]     _renameProperties(); [EOL]     PropertyNamingStrategy naming = _findNamingStrategy(); [EOL]     if (naming != null) { [EOL]         _renameUsing(naming); [EOL]     } [EOL]     for (POJOPropertyBuilder property : _properties.values()) { [EOL]         property.trimByVisibility(); [EOL]     } [EOL]     for (POJOPropertyBuilder property : _properties.values()) { [EOL]         property.mergeAnnotations(_forSerialization); [EOL]     } [EOL]     if (_config.isEnabled(MapperFeature.USE_WRAPPER_NAME_AS_PROPERTY_NAME)) { [EOL]         _renameWithWrappers(); [EOL]     } [EOL]     _sortProperties(); [EOL]     return this; [EOL] }
protected void _sortProperties() { [EOL]     AnnotationIntrospector intr = _annotationIntrospector; [EOL]     boolean sort; [EOL]     Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef); [EOL]     if (alpha == null) { [EOL]         sort = _config.shouldSortPropertiesAlphabetically(); [EOL]     } else { [EOL]         sort = alpha.booleanValue(); [EOL]     } [EOL]     String[] propertyOrder = (intr == null) ? null : intr.findSerializationPropertyOrder(_classDef); [EOL]     if (!sort && (_creatorProperties == null) && (propertyOrder == null)) { [EOL]         return; [EOL]     } [EOL]     int size = _properties.size(); [EOL]     Map<String, POJOPropertyBuilder> all; [EOL]     if (sort) { [EOL]         all = new TreeMap<String, POJOPropertyBuilder>(); [EOL]     } else { [EOL]         all = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     } [EOL]     for (POJOPropertyBuilder prop : _properties.values()) { [EOL]         all.put(prop.getName(), prop); [EOL]     } [EOL]     Map<String, POJOPropertyBuilder> ordered = new LinkedHashMap<String, POJOPropertyBuilder>(size + size); [EOL]     if (propertyOrder != null) { [EOL]         for (String name : propertyOrder) { [EOL]             POJOPropertyBuilder w = all.get(name); [EOL]             if (w == null) { [EOL]                 for (POJOPropertyBuilder prop : _properties.values()) { [EOL]                     if (name.equals(prop.getInternalName())) { [EOL]                         w = prop; [EOL]                         name = prop.getName(); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]             if (w != null) { [EOL]                 ordered.put(name, w); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (_creatorProperties != null) { [EOL]         for (POJOPropertyBuilder prop : _creatorProperties) { [EOL]             ordered.put(prop.getName(), prop); [EOL]         } [EOL]     } [EOL]     ordered.putAll(all); [EOL]     _properties.clear(); [EOL]     _properties.putAll(ordered); [EOL] }
protected void _addFields() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     final boolean pruneFinalFields = !_forSerialization && !_config.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS); [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         String implName = f.getName(); [EOL]         String explName; [EOL]         if (ai == null) { [EOL]             explName = null; [EOL]         } else if (_forSerialization) { [EOL]             PropertyName pn = ai.findNameForSerialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } else { [EOL]             PropertyName pn = ai.findNameForDeserialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } [EOL]         if ("".equals(explName)) { [EOL]             explName = implName; [EOL]         } [EOL]         boolean visible = (explName != null); [EOL]         if (!visible) { [EOL]             visible = _visibilityChecker.isFieldVisible(f); [EOL]         } [EOL]         boolean ignored = (ai != null) && ai.hasIgnoreMarker(f); [EOL]         if (pruneFinalFields && (explName == null) && !ignored && Modifier.isFinal(f.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         _property(implName).addField(f, explName, visible, ignored); [EOL]     } [EOL] }
protected void _addFields() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     final boolean pruneFinalFields = !_forSerialization && !_config.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS); [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         String implName = f.getName(); [EOL]         String explName; [EOL]         if (ai == null) { [EOL]             explName = null; [EOL]         } else if (_forSerialization) { [EOL]             PropertyName pn = ai.findNameForSerialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } else { [EOL]             PropertyName pn = ai.findNameForDeserialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } [EOL]         if ("".equals(explName)) { [EOL]             explName = implName; [EOL]         } [EOL]         boolean visible = (explName != null); [EOL]         if (!visible) { [EOL]             visible = _visibilityChecker.isFieldVisible(f); [EOL]         } [EOL]         boolean ignored = (ai != null) && ai.hasIgnoreMarker(f); [EOL]         if (pruneFinalFields && (explName == null) && !ignored && Modifier.isFinal(f.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         _property(implName).addField(f, explName, visible, ignored); [EOL]     } [EOL] }
protected void _addFields() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     final boolean pruneFinalFields = !_forSerialization && !_config.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS); [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         String implName = f.getName(); [EOL]         String explName; [EOL]         if (ai == null) { [EOL]             explName = null; [EOL]         } else if (_forSerialization) { [EOL]             PropertyName pn = ai.findNameForSerialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } else { [EOL]             PropertyName pn = ai.findNameForDeserialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } [EOL]         if ("".equals(explName)) { [EOL]             explName = implName; [EOL]         } [EOL]         boolean visible = (explName != null); [EOL]         if (!visible) { [EOL]             visible = _visibilityChecker.isFieldVisible(f); [EOL]         } [EOL]         boolean ignored = (ai != null) && ai.hasIgnoreMarker(f); [EOL]         if (pruneFinalFields && (explName == null) && !ignored && Modifier.isFinal(f.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         _property(implName).addField(f, explName, visible, ignored); [EOL]     } [EOL] }
protected void _addFields() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     final boolean pruneFinalFields = !_forSerialization && !_config.isEnabled(MapperFeature.ALLOW_FINAL_FIELDS_AS_MUTATORS); [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         String implName = f.getName(); [EOL]         String explName; [EOL]         if (ai == null) { [EOL]             explName = null; [EOL]         } else if (_forSerialization) { [EOL]             PropertyName pn = ai.findNameForSerialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } else { [EOL]             PropertyName pn = ai.findNameForDeserialization(f); [EOL]             explName = (pn == null) ? null : pn.getSimpleName(); [EOL]         } [EOL]         if ("".equals(explName)) { [EOL]             explName = implName; [EOL]         } [EOL]         boolean visible = (explName != null); [EOL]         if (!visible) { [EOL]             visible = _visibilityChecker.isFieldVisible(f); [EOL]         } [EOL]         boolean ignored = (ai != null) && ai.hasIgnoreMarker(f); [EOL]         if (pruneFinalFields && (explName == null) && !ignored && Modifier.isFinal(f.getModifiers())) { [EOL]             continue; [EOL]         } [EOL]         _property(implName).addField(f, explName, visible, ignored); [EOL]     } [EOL] }
protected void _addCreators() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     if (ai == null) { [EOL]         return; [EOL]     } [EOL]     for (AnnotatedConstructor ctor : _classDef.getConstructors()) { [EOL]         if (_creatorProperties == null) { [EOL]             _creatorProperties = new LinkedList<POJOPropertyBuilder>(); [EOL]         } [EOL]         for (int i = 0, len = ctor.getParameterCount(); i < len; ++i) { [EOL]             AnnotatedParameter param = ctor.getParameter(i); [EOL]             PropertyName pn = ai.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             if (name != null) { [EOL]                 POJOPropertyBuilder prop = _property(name); [EOL]                 prop.addCtor(param, name, true, false); [EOL]                 _creatorProperties.add(prop); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (AnnotatedMethod factory : _classDef.getStaticMethods()) { [EOL]         if (_creatorProperties == null) { [EOL]             _creatorProperties = new LinkedList<POJOPropertyBuilder>(); [EOL]         } [EOL]         for (int i = 0, len = factory.getParameterCount(); i < len; ++i) { [EOL]             AnnotatedParameter param = factory.getParameter(i); [EOL]             PropertyName pn = ai.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             if (name != null) { [EOL]                 POJOPropertyBuilder prop = _property(name); [EOL]                 prop.addCtor(param, name, true, false); [EOL]                 _creatorProperties.add(prop); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addCreators() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     if (ai == null) { [EOL]         return; [EOL]     } [EOL]     for (AnnotatedConstructor ctor : _classDef.getConstructors()) { [EOL]         if (_creatorProperties == null) { [EOL]             _creatorProperties = new LinkedList<POJOPropertyBuilder>(); [EOL]         } [EOL]         for (int i = 0, len = ctor.getParameterCount(); i < len; ++i) { [EOL]             AnnotatedParameter param = ctor.getParameter(i); [EOL]             PropertyName pn = ai.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             if (name != null) { [EOL]                 POJOPropertyBuilder prop = _property(name); [EOL]                 prop.addCtor(param, name, true, false); [EOL]                 _creatorProperties.add(prop); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (AnnotatedMethod factory : _classDef.getStaticMethods()) { [EOL]         if (_creatorProperties == null) { [EOL]             _creatorProperties = new LinkedList<POJOPropertyBuilder>(); [EOL]         } [EOL]         for (int i = 0, len = factory.getParameterCount(); i < len; ++i) { [EOL]             AnnotatedParameter param = factory.getParameter(i); [EOL]             PropertyName pn = ai.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             if (name != null) { [EOL]                 POJOPropertyBuilder prop = _property(name); [EOL]                 prop.addCtor(param, name, true, false); [EOL]                 _creatorProperties.add(prop); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addCreators() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     if (ai == null) { [EOL]         return; [EOL]     } [EOL]     for (AnnotatedConstructor ctor : _classDef.getConstructors()) { [EOL]         if (_creatorProperties == null) { [EOL]             _creatorProperties = new LinkedList<POJOPropertyBuilder>(); [EOL]         } [EOL]         for (int i = 0, len = ctor.getParameterCount(); i < len; ++i) { [EOL]             AnnotatedParameter param = ctor.getParameter(i); [EOL]             PropertyName pn = ai.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             if (name != null) { [EOL]                 POJOPropertyBuilder prop = _property(name); [EOL]                 prop.addCtor(param, name, true, false); [EOL]                 _creatorProperties.add(prop); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (AnnotatedMethod factory : _classDef.getStaticMethods()) { [EOL]         if (_creatorProperties == null) { [EOL]             _creatorProperties = new LinkedList<POJOPropertyBuilder>(); [EOL]         } [EOL]         for (int i = 0, len = factory.getParameterCount(); i < len; ++i) { [EOL]             AnnotatedParameter param = factory.getParameter(i); [EOL]             PropertyName pn = ai.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             if (name != null) { [EOL]                 POJOPropertyBuilder prop = _property(name); [EOL]                 prop.addCtor(param, name, true, false); [EOL]                 _creatorProperties.add(prop); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addCreators() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     if (ai == null) { [EOL]         return; [EOL]     } [EOL]     for (AnnotatedConstructor ctor : _classDef.getConstructors()) { [EOL]         if (_creatorProperties == null) { [EOL]             _creatorProperties = new LinkedList<POJOPropertyBuilder>(); [EOL]         } [EOL]         for (int i = 0, len = ctor.getParameterCount(); i < len; ++i) { [EOL]             AnnotatedParameter param = ctor.getParameter(i); [EOL]             PropertyName pn = ai.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             if (name != null) { [EOL]                 POJOPropertyBuilder prop = _property(name); [EOL]                 prop.addCtor(param, name, true, false); [EOL]                 _creatorProperties.add(prop); [EOL]             } [EOL]         } [EOL]     } [EOL]     for (AnnotatedMethod factory : _classDef.getStaticMethods()) { [EOL]         if (_creatorProperties == null) { [EOL]             _creatorProperties = new LinkedList<POJOPropertyBuilder>(); [EOL]         } [EOL]         for (int i = 0, len = factory.getParameterCount(); i < len; ++i) { [EOL]             AnnotatedParameter param = factory.getParameter(i); [EOL]             PropertyName pn = ai.findNameForDeserialization(param); [EOL]             String name = (pn == null) ? null : pn.getSimpleName(); [EOL]             if (name != null) { [EOL]                 POJOPropertyBuilder prop = _property(name); [EOL]                 prop.addCtor(param, name, true, false); [EOL]                 _creatorProperties.add(prop); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addMethods() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     for (AnnotatedMethod m : _classDef.memberMethods()) { [EOL]         int argCount = m.getParameterCount(); [EOL]         if (argCount == 0) { [EOL]             _addGetterMethod(m, ai); [EOL]         } else if (argCount == 1) { [EOL]             _addSetterMethod(m, ai); [EOL]         } else if (argCount == 2) { [EOL]             if (ai != null && ai.hasAnySetterAnnotation(m)) { [EOL]                 if (_anySetters == null) { [EOL]                     _anySetters = new LinkedList<AnnotatedMethod>(); [EOL]                 } [EOL]                 _anySetters.add(m); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addMethods() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     for (AnnotatedMethod m : _classDef.memberMethods()) { [EOL]         int argCount = m.getParameterCount(); [EOL]         if (argCount == 0) { [EOL]             _addGetterMethod(m, ai); [EOL]         } else if (argCount == 1) { [EOL]             _addSetterMethod(m, ai); [EOL]         } else if (argCount == 2) { [EOL]             if (ai != null && ai.hasAnySetterAnnotation(m)) { [EOL]                 if (_anySetters == null) { [EOL]                     _anySetters = new LinkedList<AnnotatedMethod>(); [EOL]                 } [EOL]                 _anySetters.add(m); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _addGetterMethod(AnnotatedMethod m, AnnotationIntrospector ai) { [EOL]     if (ai != null) { [EOL]         if (ai.hasAnyGetterAnnotation(m)) { [EOL]             if (_anyGetters == null) { [EOL]                 _anyGetters = new LinkedList<AnnotatedMember>(); [EOL]             } [EOL]             _anyGetters.add(m); [EOL]             return; [EOL]         } [EOL]         if (ai.hasAsValueAnnotation(m)) { [EOL]             if (_jsonValueGetters == null) { [EOL]                 _jsonValueGetters = new LinkedList<AnnotatedMethod>(); [EOL]             } [EOL]             _jsonValueGetters.add(m); [EOL]             return; [EOL]         } [EOL]     } [EOL]     String implName; [EOL]     boolean visible; [EOL]     PropertyName pn = (ai == null) ? null : ai.findNameForSerialization(m); [EOL]     String explName = (pn == null) ? null : pn.getSimpleName(); [EOL]     if (explName == null) { [EOL]         implName = BeanUtil.okNameForRegularGetter(m, m.getName()); [EOL]         if (implName == null) { [EOL]             implName = BeanUtil.okNameForIsGetter(m, m.getName()); [EOL]             if (implName == null) { [EOL]                 return; [EOL]             } [EOL]             visible = _visibilityChecker.isIsGetterVisible(m); [EOL]         } else { [EOL]             visible = _visibilityChecker.isGetterVisible(m); [EOL]         } [EOL]     } else { [EOL]         implName = BeanUtil.okNameForGetter(m); [EOL]         if (implName == null) { [EOL]             implName = m.getName(); [EOL]         } [EOL]         if (explName.length() == 0) { [EOL]             explName = implName; [EOL]         } [EOL]         visible = true; [EOL]     } [EOL]     boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m); [EOL]     _property(implName).addGetter(m, explName, visible, ignore); [EOL] }
protected void _addGetterMethod(AnnotatedMethod m, AnnotationIntrospector ai) { [EOL]     if (ai != null) { [EOL]         if (ai.hasAnyGetterAnnotation(m)) { [EOL]             if (_anyGetters == null) { [EOL]                 _anyGetters = new LinkedList<AnnotatedMember>(); [EOL]             } [EOL]             _anyGetters.add(m); [EOL]             return; [EOL]         } [EOL]         if (ai.hasAsValueAnnotation(m)) { [EOL]             if (_jsonValueGetters == null) { [EOL]                 _jsonValueGetters = new LinkedList<AnnotatedMethod>(); [EOL]             } [EOL]             _jsonValueGetters.add(m); [EOL]             return; [EOL]         } [EOL]     } [EOL]     String implName; [EOL]     boolean visible; [EOL]     PropertyName pn = (ai == null) ? null : ai.findNameForSerialization(m); [EOL]     String explName = (pn == null) ? null : pn.getSimpleName(); [EOL]     if (explName == null) { [EOL]         implName = BeanUtil.okNameForRegularGetter(m, m.getName()); [EOL]         if (implName == null) { [EOL]             implName = BeanUtil.okNameForIsGetter(m, m.getName()); [EOL]             if (implName == null) { [EOL]                 return; [EOL]             } [EOL]             visible = _visibilityChecker.isIsGetterVisible(m); [EOL]         } else { [EOL]             visible = _visibilityChecker.isGetterVisible(m); [EOL]         } [EOL]     } else { [EOL]         implName = BeanUtil.okNameForGetter(m); [EOL]         if (implName == null) { [EOL]             implName = m.getName(); [EOL]         } [EOL]         if (explName.length() == 0) { [EOL]             explName = implName; [EOL]         } [EOL]         visible = true; [EOL]     } [EOL]     boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m); [EOL]     _property(implName).addGetter(m, explName, visible, ignore); [EOL] }
protected void _addGetterMethod(AnnotatedMethod m, AnnotationIntrospector ai) { [EOL]     if (ai != null) { [EOL]         if (ai.hasAnyGetterAnnotation(m)) { [EOL]             if (_anyGetters == null) { [EOL]                 _anyGetters = new LinkedList<AnnotatedMember>(); [EOL]             } [EOL]             _anyGetters.add(m); [EOL]             return; [EOL]         } [EOL]         if (ai.hasAsValueAnnotation(m)) { [EOL]             if (_jsonValueGetters == null) { [EOL]                 _jsonValueGetters = new LinkedList<AnnotatedMethod>(); [EOL]             } [EOL]             _jsonValueGetters.add(m); [EOL]             return; [EOL]         } [EOL]     } [EOL]     String implName; [EOL]     boolean visible; [EOL]     PropertyName pn = (ai == null) ? null : ai.findNameForSerialization(m); [EOL]     String explName = (pn == null) ? null : pn.getSimpleName(); [EOL]     if (explName == null) { [EOL]         implName = BeanUtil.okNameForRegularGetter(m, m.getName()); [EOL]         if (implName == null) { [EOL]             implName = BeanUtil.okNameForIsGetter(m, m.getName()); [EOL]             if (implName == null) { [EOL]                 return; [EOL]             } [EOL]             visible = _visibilityChecker.isIsGetterVisible(m); [EOL]         } else { [EOL]             visible = _visibilityChecker.isGetterVisible(m); [EOL]         } [EOL]     } else { [EOL]         implName = BeanUtil.okNameForGetter(m); [EOL]         if (implName == null) { [EOL]             implName = m.getName(); [EOL]         } [EOL]         if (explName.length() == 0) { [EOL]             explName = implName; [EOL]         } [EOL]         visible = true; [EOL]     } [EOL]     boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m); [EOL]     _property(implName).addGetter(m, explName, visible, ignore); [EOL] }
protected void _addGetterMethod(AnnotatedMethod m, AnnotationIntrospector ai) { [EOL]     if (ai != null) { [EOL]         if (ai.hasAnyGetterAnnotation(m)) { [EOL]             if (_anyGetters == null) { [EOL]                 _anyGetters = new LinkedList<AnnotatedMember>(); [EOL]             } [EOL]             _anyGetters.add(m); [EOL]             return; [EOL]         } [EOL]         if (ai.hasAsValueAnnotation(m)) { [EOL]             if (_jsonValueGetters == null) { [EOL]                 _jsonValueGetters = new LinkedList<AnnotatedMethod>(); [EOL]             } [EOL]             _jsonValueGetters.add(m); [EOL]             return; [EOL]         } [EOL]     } [EOL]     String implName; [EOL]     boolean visible; [EOL]     PropertyName pn = (ai == null) ? null : ai.findNameForSerialization(m); [EOL]     String explName = (pn == null) ? null : pn.getSimpleName(); [EOL]     if (explName == null) { [EOL]         implName = BeanUtil.okNameForRegularGetter(m, m.getName()); [EOL]         if (implName == null) { [EOL]             implName = BeanUtil.okNameForIsGetter(m, m.getName()); [EOL]             if (implName == null) { [EOL]                 return; [EOL]             } [EOL]             visible = _visibilityChecker.isIsGetterVisible(m); [EOL]         } else { [EOL]             visible = _visibilityChecker.isGetterVisible(m); [EOL]         } [EOL]     } else { [EOL]         implName = BeanUtil.okNameForGetter(m); [EOL]         if (implName == null) { [EOL]             implName = m.getName(); [EOL]         } [EOL]         if (explName.length() == 0) { [EOL]             explName = implName; [EOL]         } [EOL]         visible = true; [EOL]     } [EOL]     boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m); [EOL]     _property(implName).addGetter(m, explName, visible, ignore); [EOL] }
protected void _addGetterMethod(AnnotatedMethod m, AnnotationIntrospector ai) { [EOL]     if (ai != null) { [EOL]         if (ai.hasAnyGetterAnnotation(m)) { [EOL]             if (_anyGetters == null) { [EOL]                 _anyGetters = new LinkedList<AnnotatedMember>(); [EOL]             } [EOL]             _anyGetters.add(m); [EOL]             return; [EOL]         } [EOL]         if (ai.hasAsValueAnnotation(m)) { [EOL]             if (_jsonValueGetters == null) { [EOL]                 _jsonValueGetters = new LinkedList<AnnotatedMethod>(); [EOL]             } [EOL]             _jsonValueGetters.add(m); [EOL]             return; [EOL]         } [EOL]     } [EOL]     String implName; [EOL]     boolean visible; [EOL]     PropertyName pn = (ai == null) ? null : ai.findNameForSerialization(m); [EOL]     String explName = (pn == null) ? null : pn.getSimpleName(); [EOL]     if (explName == null) { [EOL]         implName = BeanUtil.okNameForRegularGetter(m, m.getName()); [EOL]         if (implName == null) { [EOL]             implName = BeanUtil.okNameForIsGetter(m, m.getName()); [EOL]             if (implName == null) { [EOL]                 return; [EOL]             } [EOL]             visible = _visibilityChecker.isIsGetterVisible(m); [EOL]         } else { [EOL]             visible = _visibilityChecker.isGetterVisible(m); [EOL]         } [EOL]     } else { [EOL]         implName = BeanUtil.okNameForGetter(m); [EOL]         if (implName == null) { [EOL]             implName = m.getName(); [EOL]         } [EOL]         if (explName.length() == 0) { [EOL]             explName = implName; [EOL]         } [EOL]         visible = true; [EOL]     } [EOL]     boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m); [EOL]     _property(implName).addGetter(m, explName, visible, ignore); [EOL] }
protected void _addSetterMethod(AnnotatedMethod m, AnnotationIntrospector ai) { [EOL]     String implName; [EOL]     boolean visible; [EOL]     PropertyName pn = (ai == null) ? null : ai.findNameForDeserialization(m); [EOL]     String explName = (pn == null) ? null : pn.getSimpleName(); [EOL]     if (explName == null) { [EOL]         implName = BeanUtil.okNameForMutator(m, _mutatorPrefix); [EOL]         if (implName == null) { [EOL]             return; [EOL]         } [EOL]         visible = _visibilityChecker.isSetterVisible(m); [EOL]     } else { [EOL]         implName = BeanUtil.okNameForMutator(m, _mutatorPrefix); [EOL]         if (implName == null) { [EOL]             implName = m.getName(); [EOL]         } [EOL]         if (explName.length() == 0) { [EOL]             explName = implName; [EOL]         } [EOL]         visible = true; [EOL]     } [EOL]     boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m); [EOL]     _property(implName).addSetter(m, explName, visible, ignore); [EOL] }
protected void _addInjectables() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     if (ai == null) { [EOL]         return; [EOL]     } [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         _doAddInjectable(ai.findInjectableValueId(f), f); [EOL]     } [EOL]     for (AnnotatedMethod m : _classDef.memberMethods()) { [EOL]         if (m.getParameterCount() != 1) { [EOL]             continue; [EOL]         } [EOL]         _doAddInjectable(ai.findInjectableValueId(m), m); [EOL]     } [EOL] }
protected void _addInjectables() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     if (ai == null) { [EOL]         return; [EOL]     } [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         _doAddInjectable(ai.findInjectableValueId(f), f); [EOL]     } [EOL]     for (AnnotatedMethod m : _classDef.memberMethods()) { [EOL]         if (m.getParameterCount() != 1) { [EOL]             continue; [EOL]         } [EOL]         _doAddInjectable(ai.findInjectableValueId(m), m); [EOL]     } [EOL] }
protected void _addInjectables() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     if (ai == null) { [EOL]         return; [EOL]     } [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         _doAddInjectable(ai.findInjectableValueId(f), f); [EOL]     } [EOL]     for (AnnotatedMethod m : _classDef.memberMethods()) { [EOL]         if (m.getParameterCount() != 1) { [EOL]             continue; [EOL]         } [EOL]         _doAddInjectable(ai.findInjectableValueId(m), m); [EOL]     } [EOL] }
protected void _addInjectables() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     if (ai == null) { [EOL]         return; [EOL]     } [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         _doAddInjectable(ai.findInjectableValueId(f), f); [EOL]     } [EOL]     for (AnnotatedMethod m : _classDef.memberMethods()) { [EOL]         if (m.getParameterCount() != 1) { [EOL]             continue; [EOL]         } [EOL]         _doAddInjectable(ai.findInjectableValueId(m), m); [EOL]     } [EOL] }
protected void _addInjectables() { [EOL]     final AnnotationIntrospector ai = _annotationIntrospector; [EOL]     if (ai == null) { [EOL]         return; [EOL]     } [EOL]     for (AnnotatedField f : _classDef.fields()) { [EOL]         _doAddInjectable(ai.findInjectableValueId(f), f); [EOL]     } [EOL]     for (AnnotatedMethod m : _classDef.memberMethods()) { [EOL]         if (m.getParameterCount() != 1) { [EOL]             continue; [EOL]         } [EOL]         _doAddInjectable(ai.findInjectableValueId(m), m); [EOL]     } [EOL] }
protected void _doAddInjectable(Object id, AnnotatedMember m) { [EOL]     if (id == null) { [EOL]         return; [EOL]     } [EOL]     if (_injectables == null) { [EOL]         _injectables = new LinkedHashMap<Object, AnnotatedMember>(); [EOL]     } [EOL]     AnnotatedMember prev = _injectables.put(id, m); [EOL]     if (prev != null) { [EOL]         String type = (id == null) ? "[null]" : id.getClass().getName(); [EOL]         throw new IllegalArgumentException("Duplicate injectable value with id '" + String.valueOf(id) + "' (of type " + type + ")"); [EOL]     } [EOL] }
protected void _doAddInjectable(Object id, AnnotatedMember m) { [EOL]     if (id == null) { [EOL]         return; [EOL]     } [EOL]     if (_injectables == null) { [EOL]         _injectables = new LinkedHashMap<Object, AnnotatedMember>(); [EOL]     } [EOL]     AnnotatedMember prev = _injectables.put(id, m); [EOL]     if (prev != null) { [EOL]         String type = (id == null) ? "[null]" : id.getClass().getName(); [EOL]         throw new IllegalArgumentException("Duplicate injectable value with id '" + String.valueOf(id) + "' (of type " + type + ")"); [EOL]     } [EOL] }
protected void _doAddInjectable(Object id, AnnotatedMember m) { [EOL]     if (id == null) { [EOL]         return; [EOL]     } [EOL]     if (_injectables == null) { [EOL]         _injectables = new LinkedHashMap<Object, AnnotatedMember>(); [EOL]     } [EOL]     AnnotatedMember prev = _injectables.put(id, m); [EOL]     if (prev != null) { [EOL]         String type = (id == null) ? "[null]" : id.getClass().getName(); [EOL]         throw new IllegalArgumentException("Duplicate injectable value with id '" + String.valueOf(id) + "' (of type " + type + ")"); [EOL]     } [EOL] }
protected void _removeUnwantedProperties() { [EOL]     Iterator<Map.Entry<String, POJOPropertyBuilder>> it = _properties.entrySet().iterator(); [EOL]     final boolean forceNonVisibleRemoval = !_config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS); [EOL]     while (it.hasNext()) { [EOL]         Map.Entry<String, POJOPropertyBuilder> entry = it.next(); [EOL]         POJOPropertyBuilder prop = entry.getValue(); [EOL]         if (!prop.anyVisible()) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         if (prop.anyIgnorals()) { [EOL]             if (!prop.isExplicitlyIncluded()) { [EOL]                 it.remove(); [EOL]                 _addIgnored(prop.getName()); [EOL]                 continue; [EOL]             } [EOL]             prop.removeIgnored(); [EOL]             if (!_forSerialization && !prop.couldDeserialize()) { [EOL]                 _addIgnored(prop.getName()); [EOL]             } [EOL]         } [EOL]         prop.removeNonVisible(forceNonVisibleRemoval); [EOL]     } [EOL] }
protected void _removeUnwantedProperties() { [EOL]     Iterator<Map.Entry<String, POJOPropertyBuilder>> it = _properties.entrySet().iterator(); [EOL]     final boolean forceNonVisibleRemoval = !_config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS); [EOL]     while (it.hasNext()) { [EOL]         Map.Entry<String, POJOPropertyBuilder> entry = it.next(); [EOL]         POJOPropertyBuilder prop = entry.getValue(); [EOL]         if (!prop.anyVisible()) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         if (prop.anyIgnorals()) { [EOL]             if (!prop.isExplicitlyIncluded()) { [EOL]                 it.remove(); [EOL]                 _addIgnored(prop.getName()); [EOL]                 continue; [EOL]             } [EOL]             prop.removeIgnored(); [EOL]             if (!_forSerialization && !prop.couldDeserialize()) { [EOL]                 _addIgnored(prop.getName()); [EOL]             } [EOL]         } [EOL]         prop.removeNonVisible(forceNonVisibleRemoval); [EOL]     } [EOL] }
protected void _removeUnwantedProperties() { [EOL]     Iterator<Map.Entry<String, POJOPropertyBuilder>> it = _properties.entrySet().iterator(); [EOL]     final boolean forceNonVisibleRemoval = !_config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS); [EOL]     while (it.hasNext()) { [EOL]         Map.Entry<String, POJOPropertyBuilder> entry = it.next(); [EOL]         POJOPropertyBuilder prop = entry.getValue(); [EOL]         if (!prop.anyVisible()) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         if (prop.anyIgnorals()) { [EOL]             if (!prop.isExplicitlyIncluded()) { [EOL]                 it.remove(); [EOL]                 _addIgnored(prop.getName()); [EOL]                 continue; [EOL]             } [EOL]             prop.removeIgnored(); [EOL]             if (!_forSerialization && !prop.couldDeserialize()) { [EOL]                 _addIgnored(prop.getName()); [EOL]             } [EOL]         } [EOL]         prop.removeNonVisible(forceNonVisibleRemoval); [EOL]     } [EOL] }
protected void _removeUnwantedProperties() { [EOL]     Iterator<Map.Entry<String, POJOPropertyBuilder>> it = _properties.entrySet().iterator(); [EOL]     final boolean forceNonVisibleRemoval = !_config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS); [EOL]     while (it.hasNext()) { [EOL]         Map.Entry<String, POJOPropertyBuilder> entry = it.next(); [EOL]         POJOPropertyBuilder prop = entry.getValue(); [EOL]         if (!prop.anyVisible()) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         if (prop.anyIgnorals()) { [EOL]             if (!prop.isExplicitlyIncluded()) { [EOL]                 it.remove(); [EOL]                 _addIgnored(prop.getName()); [EOL]                 continue; [EOL]             } [EOL]             prop.removeIgnored(); [EOL]             if (!_forSerialization && !prop.couldDeserialize()) { [EOL]                 _addIgnored(prop.getName()); [EOL]             } [EOL]         } [EOL]         prop.removeNonVisible(forceNonVisibleRemoval); [EOL]     } [EOL] }
protected void _removeUnwantedProperties() { [EOL]     Iterator<Map.Entry<String, POJOPropertyBuilder>> it = _properties.entrySet().iterator(); [EOL]     final boolean forceNonVisibleRemoval = !_config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS); [EOL]     while (it.hasNext()) { [EOL]         Map.Entry<String, POJOPropertyBuilder> entry = it.next(); [EOL]         POJOPropertyBuilder prop = entry.getValue(); [EOL]         if (!prop.anyVisible()) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         if (prop.anyIgnorals()) { [EOL]             if (!prop.isExplicitlyIncluded()) { [EOL]                 it.remove(); [EOL]                 _addIgnored(prop.getName()); [EOL]                 continue; [EOL]             } [EOL]             prop.removeIgnored(); [EOL]             if (!_forSerialization && !prop.couldDeserialize()) { [EOL]                 _addIgnored(prop.getName()); [EOL]             } [EOL]         } [EOL]         prop.removeNonVisible(forceNonVisibleRemoval); [EOL]     } [EOL] }
protected void _renameProperties() { [EOL]     Iterator<Map.Entry<String, POJOPropertyBuilder>> it = _properties.entrySet().iterator(); [EOL]     LinkedList<POJOPropertyBuilder> renamed = null; [EOL]     while (it.hasNext()) { [EOL]         Map.Entry<String, POJOPropertyBuilder> entry = it.next(); [EOL]         POJOPropertyBuilder prop = entry.getValue(); [EOL]         String newName = prop.findNewName(); [EOL]         if (newName != null) { [EOL]             if (renamed == null) { [EOL]                 renamed = new LinkedList<POJOPropertyBuilder>(); [EOL]             } [EOL]             prop = prop.withName(newName); [EOL]             renamed.add(prop); [EOL]             it.remove(); [EOL]         } [EOL]     } [EOL]     if (renamed != null) { [EOL]         for (POJOPropertyBuilder prop : renamed) { [EOL]             String name = prop.getName(); [EOL]             POJOPropertyBuilder old = _properties.get(name); [EOL]             if (old == null) { [EOL]                 _properties.put(name, prop); [EOL]             } else { [EOL]                 old.addAll(prop); [EOL]             } [EOL]             if (_creatorProperties != null) { [EOL]                 for (int i = 0; i < _creatorProperties.size(); ++i) { [EOL]                     if (_creatorProperties.get(i).getInternalName() == prop.getInternalName()) { [EOL]                         _creatorProperties.set(i, prop); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _renameProperties() { [EOL]     Iterator<Map.Entry<String, POJOPropertyBuilder>> it = _properties.entrySet().iterator(); [EOL]     LinkedList<POJOPropertyBuilder> renamed = null; [EOL]     while (it.hasNext()) { [EOL]         Map.Entry<String, POJOPropertyBuilder> entry = it.next(); [EOL]         POJOPropertyBuilder prop = entry.getValue(); [EOL]         String newName = prop.findNewName(); [EOL]         if (newName != null) { [EOL]             if (renamed == null) { [EOL]                 renamed = new LinkedList<POJOPropertyBuilder>(); [EOL]             } [EOL]             prop = prop.withName(newName); [EOL]             renamed.add(prop); [EOL]             it.remove(); [EOL]         } [EOL]     } [EOL]     if (renamed != null) { [EOL]         for (POJOPropertyBuilder prop : renamed) { [EOL]             String name = prop.getName(); [EOL]             POJOPropertyBuilder old = _properties.get(name); [EOL]             if (old == null) { [EOL]                 _properties.put(name, prop); [EOL]             } else { [EOL]                 old.addAll(prop); [EOL]             } [EOL]             if (_creatorProperties != null) { [EOL]                 for (int i = 0; i < _creatorProperties.size(); ++i) { [EOL]                     if (_creatorProperties.get(i).getInternalName() == prop.getInternalName()) { [EOL]                         _creatorProperties.set(i, prop); [EOL]                         break; [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void _renameUsing(PropertyNamingStrategy naming) { [EOL]     POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]); [EOL]     _properties.clear(); [EOL]     for (POJOPropertyBuilder prop : props) { [EOL]         String name = prop.getName(); [EOL]         if (_forSerialization) { [EOL]             if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } [EOL]         } else { [EOL]             if (prop.hasSetter()) { [EOL]                 name = naming.nameForSetterMethod(_config, prop.getSetter(), name); [EOL]             } else if (prop.hasConstructorParameter()) { [EOL]                 name = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } else if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } [EOL]         } [EOL]         if (!name.equals(prop.getName())) { [EOL]             prop = prop.withName(name); [EOL]         } [EOL]         POJOPropertyBuilder old = _properties.get(name); [EOL]         if (old == null) { [EOL]             _properties.put(name, prop); [EOL]         } else { [EOL]             old.addAll(prop); [EOL]         } [EOL]     } [EOL] }
protected void _renameUsing(PropertyNamingStrategy naming) { [EOL]     POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]); [EOL]     _properties.clear(); [EOL]     for (POJOPropertyBuilder prop : props) { [EOL]         String name = prop.getName(); [EOL]         if (_forSerialization) { [EOL]             if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } [EOL]         } else { [EOL]             if (prop.hasSetter()) { [EOL]                 name = naming.nameForSetterMethod(_config, prop.getSetter(), name); [EOL]             } else if (prop.hasConstructorParameter()) { [EOL]                 name = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } else if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } [EOL]         } [EOL]         if (!name.equals(prop.getName())) { [EOL]             prop = prop.withName(name); [EOL]         } [EOL]         POJOPropertyBuilder old = _properties.get(name); [EOL]         if (old == null) { [EOL]             _properties.put(name, prop); [EOL]         } else { [EOL]             old.addAll(prop); [EOL]         } [EOL]     } [EOL] }
protected void _renameUsing(PropertyNamingStrategy naming) { [EOL]     POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]); [EOL]     _properties.clear(); [EOL]     for (POJOPropertyBuilder prop : props) { [EOL]         String name = prop.getName(); [EOL]         if (_forSerialization) { [EOL]             if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } [EOL]         } else { [EOL]             if (prop.hasSetter()) { [EOL]                 name = naming.nameForSetterMethod(_config, prop.getSetter(), name); [EOL]             } else if (prop.hasConstructorParameter()) { [EOL]                 name = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } else if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } [EOL]         } [EOL]         if (!name.equals(prop.getName())) { [EOL]             prop = prop.withName(name); [EOL]         } [EOL]         POJOPropertyBuilder old = _properties.get(name); [EOL]         if (old == null) { [EOL]             _properties.put(name, prop); [EOL]         } else { [EOL]             old.addAll(prop); [EOL]         } [EOL]     } [EOL] }
protected void _renameUsing(PropertyNamingStrategy naming) { [EOL]     POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]); [EOL]     _properties.clear(); [EOL]     for (POJOPropertyBuilder prop : props) { [EOL]         String name = prop.getName(); [EOL]         if (_forSerialization) { [EOL]             if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } [EOL]         } else { [EOL]             if (prop.hasSetter()) { [EOL]                 name = naming.nameForSetterMethod(_config, prop.getSetter(), name); [EOL]             } else if (prop.hasConstructorParameter()) { [EOL]                 name = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } else if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } [EOL]         } [EOL]         if (!name.equals(prop.getName())) { [EOL]             prop = prop.withName(name); [EOL]         } [EOL]         POJOPropertyBuilder old = _properties.get(name); [EOL]         if (old == null) { [EOL]             _properties.put(name, prop); [EOL]         } else { [EOL]             old.addAll(prop); [EOL]         } [EOL]     } [EOL] }
protected void _renameUsing(PropertyNamingStrategy naming) { [EOL]     POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]); [EOL]     _properties.clear(); [EOL]     for (POJOPropertyBuilder prop : props) { [EOL]         String name = prop.getName(); [EOL]         if (_forSerialization) { [EOL]             if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } [EOL]         } else { [EOL]             if (prop.hasSetter()) { [EOL]                 name = naming.nameForSetterMethod(_config, prop.getSetter(), name); [EOL]             } else if (prop.hasConstructorParameter()) { [EOL]                 name = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } else if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } [EOL]         } [EOL]         if (!name.equals(prop.getName())) { [EOL]             prop = prop.withName(name); [EOL]         } [EOL]         POJOPropertyBuilder old = _properties.get(name); [EOL]         if (old == null) { [EOL]             _properties.put(name, prop); [EOL]         } else { [EOL]             old.addAll(prop); [EOL]         } [EOL]     } [EOL] }
protected void _renameUsing(PropertyNamingStrategy naming) { [EOL]     POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]); [EOL]     _properties.clear(); [EOL]     for (POJOPropertyBuilder prop : props) { [EOL]         String name = prop.getName(); [EOL]         if (_forSerialization) { [EOL]             if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } [EOL]         } else { [EOL]             if (prop.hasSetter()) { [EOL]                 name = naming.nameForSetterMethod(_config, prop.getSetter(), name); [EOL]             } else if (prop.hasConstructorParameter()) { [EOL]                 name = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } else if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } [EOL]         } [EOL]         if (!name.equals(prop.getName())) { [EOL]             prop = prop.withName(name); [EOL]         } [EOL]         POJOPropertyBuilder old = _properties.get(name); [EOL]         if (old == null) { [EOL]             _properties.put(name, prop); [EOL]         } else { [EOL]             old.addAll(prop); [EOL]         } [EOL]     } [EOL] }
protected void _renameUsing(PropertyNamingStrategy naming) { [EOL]     POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]); [EOL]     _properties.clear(); [EOL]     for (POJOPropertyBuilder prop : props) { [EOL]         String name = prop.getName(); [EOL]         if (_forSerialization) { [EOL]             if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } [EOL]         } else { [EOL]             if (prop.hasSetter()) { [EOL]                 name = naming.nameForSetterMethod(_config, prop.getSetter(), name); [EOL]             } else if (prop.hasConstructorParameter()) { [EOL]                 name = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } else if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } [EOL]         } [EOL]         if (!name.equals(prop.getName())) { [EOL]             prop = prop.withName(name); [EOL]         } [EOL]         POJOPropertyBuilder old = _properties.get(name); [EOL]         if (old == null) { [EOL]             _properties.put(name, prop); [EOL]         } else { [EOL]             old.addAll(prop); [EOL]         } [EOL]     } [EOL] }
protected void _renameUsing(PropertyNamingStrategy naming) { [EOL]     POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]); [EOL]     _properties.clear(); [EOL]     for (POJOPropertyBuilder prop : props) { [EOL]         String name = prop.getName(); [EOL]         if (_forSerialization) { [EOL]             if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } [EOL]         } else { [EOL]             if (prop.hasSetter()) { [EOL]                 name = naming.nameForSetterMethod(_config, prop.getSetter(), name); [EOL]             } else if (prop.hasConstructorParameter()) { [EOL]                 name = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), name); [EOL]             } else if (prop.hasField()) { [EOL]                 name = naming.nameForField(_config, prop.getField(), name); [EOL]             } else if (prop.hasGetter()) { [EOL]                 name = naming.nameForGetterMethod(_config, prop.getGetter(), name); [EOL]             } [EOL]         } [EOL]         if (!name.equals(prop.getName())) { [EOL]             prop = prop.withName(name); [EOL]         } [EOL]         POJOPropertyBuilder old = _properties.get(name); [EOL]         if (old == null) { [EOL]             _properties.put(name, prop); [EOL]         } else { [EOL]             old.addAll(prop); [EOL]         } [EOL]     } [EOL] }
protected POJOPropertyBuilder _property(String implName) { [EOL]     POJOPropertyBuilder prop = _properties.get(implName); [EOL]     if (prop == null) { [EOL]         prop = new POJOPropertyBuilder(implName, _annotationIntrospector, _forSerialization); [EOL]         _properties.put(implName, prop); [EOL]     } [EOL]     return prop; [EOL] }
protected POJOPropertyBuilder _property(String implName) { [EOL]     POJOPropertyBuilder prop = _properties.get(implName); [EOL]     if (prop == null) { [EOL]         prop = new POJOPropertyBuilder(implName, _annotationIntrospector, _forSerialization); [EOL]         _properties.put(implName, prop); [EOL]     } [EOL]     return prop; [EOL] }
private PropertyNamingStrategy _findNamingStrategy() { [EOL]     Object namingDef = (_annotationIntrospector == null) ? null : _annotationIntrospector.findNamingStrategy(_classDef); [EOL]     if (namingDef == null) { [EOL]         return _config.getPropertyNamingStrategy(); [EOL]     } [EOL]     if (namingDef instanceof PropertyNamingStrategy) { [EOL]         return (PropertyNamingStrategy) namingDef; [EOL]     } [EOL]     if (!(namingDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned PropertyNamingStrategy definition of type " + namingDef.getClass().getName() + "; expected type PropertyNamingStrategy or Class<PropertyNamingStrategy> instead"); [EOL]     } [EOL]     Class<?> namingClass = (Class<?>) namingDef; [EOL]     if (!PropertyNamingStrategy.class.isAssignableFrom(namingClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + namingClass.getName() + "; expected Class<PropertyNamingStrategy>"); [EOL]     } [EOL]     HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]     if (hi != null) { [EOL]         PropertyNamingStrategy pns = hi.namingStrategyInstance(_config, _classDef, namingClass); [EOL]         if (pns != null) { [EOL]             return pns; [EOL]         } [EOL]     } [EOL]     return (PropertyNamingStrategy) ClassUtil.createInstance(namingClass, _config.canOverrideAccessModifiers()); [EOL] }
private PropertyNamingStrategy _findNamingStrategy() { [EOL]     Object namingDef = (_annotationIntrospector == null) ? null : _annotationIntrospector.findNamingStrategy(_classDef); [EOL]     if (namingDef == null) { [EOL]         return _config.getPropertyNamingStrategy(); [EOL]     } [EOL]     if (namingDef instanceof PropertyNamingStrategy) { [EOL]         return (PropertyNamingStrategy) namingDef; [EOL]     } [EOL]     if (!(namingDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned PropertyNamingStrategy definition of type " + namingDef.getClass().getName() + "; expected type PropertyNamingStrategy or Class<PropertyNamingStrategy> instead"); [EOL]     } [EOL]     Class<?> namingClass = (Class<?>) namingDef; [EOL]     if (!PropertyNamingStrategy.class.isAssignableFrom(namingClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + namingClass.getName() + "; expected Class<PropertyNamingStrategy>"); [EOL]     } [EOL]     HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]     if (hi != null) { [EOL]         PropertyNamingStrategy pns = hi.namingStrategyInstance(_config, _classDef, namingClass); [EOL]         if (pns != null) { [EOL]             return pns; [EOL]         } [EOL]     } [EOL]     return (PropertyNamingStrategy) ClassUtil.createInstance(namingClass, _config.canOverrideAccessModifiers()); [EOL] }
private PropertyNamingStrategy _findNamingStrategy() { [EOL]     Object namingDef = (_annotationIntrospector == null) ? null : _annotationIntrospector.findNamingStrategy(_classDef); [EOL]     if (namingDef == null) { [EOL]         return _config.getPropertyNamingStrategy(); [EOL]     } [EOL]     if (namingDef instanceof PropertyNamingStrategy) { [EOL]         return (PropertyNamingStrategy) namingDef; [EOL]     } [EOL]     if (!(namingDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned PropertyNamingStrategy definition of type " + namingDef.getClass().getName() + "; expected type PropertyNamingStrategy or Class<PropertyNamingStrategy> instead"); [EOL]     } [EOL]     Class<?> namingClass = (Class<?>) namingDef; [EOL]     if (!PropertyNamingStrategy.class.isAssignableFrom(namingClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + namingClass.getName() + "; expected Class<PropertyNamingStrategy>"); [EOL]     } [EOL]     HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]     if (hi != null) { [EOL]         PropertyNamingStrategy pns = hi.namingStrategyInstance(_config, _classDef, namingClass); [EOL]         if (pns != null) { [EOL]             return pns; [EOL]         } [EOL]     } [EOL]     return (PropertyNamingStrategy) ClassUtil.createInstance(namingClass, _config.canOverrideAccessModifiers()); [EOL] }
private PropertyNamingStrategy _findNamingStrategy() { [EOL]     Object namingDef = (_annotationIntrospector == null) ? null : _annotationIntrospector.findNamingStrategy(_classDef); [EOL]     if (namingDef == null) { [EOL]         return _config.getPropertyNamingStrategy(); [EOL]     } [EOL]     if (namingDef instanceof PropertyNamingStrategy) { [EOL]         return (PropertyNamingStrategy) namingDef; [EOL]     } [EOL]     if (!(namingDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned PropertyNamingStrategy definition of type " + namingDef.getClass().getName() + "; expected type PropertyNamingStrategy or Class<PropertyNamingStrategy> instead"); [EOL]     } [EOL]     Class<?> namingClass = (Class<?>) namingDef; [EOL]     if (!PropertyNamingStrategy.class.isAssignableFrom(namingClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + namingClass.getName() + "; expected Class<PropertyNamingStrategy>"); [EOL]     } [EOL]     HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]     if (hi != null) { [EOL]         PropertyNamingStrategy pns = hi.namingStrategyInstance(_config, _classDef, namingClass); [EOL]         if (pns != null) { [EOL]             return pns; [EOL]         } [EOL]     } [EOL]     return (PropertyNamingStrategy) ClassUtil.createInstance(namingClass, _config.canOverrideAccessModifiers()); [EOL] }
private PropertyNamingStrategy _findNamingStrategy() { [EOL]     Object namingDef = (_annotationIntrospector == null) ? null : _annotationIntrospector.findNamingStrategy(_classDef); [EOL]     if (namingDef == null) { [EOL]         return _config.getPropertyNamingStrategy(); [EOL]     } [EOL]     if (namingDef instanceof PropertyNamingStrategy) { [EOL]         return (PropertyNamingStrategy) namingDef; [EOL]     } [EOL]     if (!(namingDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned PropertyNamingStrategy definition of type " + namingDef.getClass().getName() + "; expected type PropertyNamingStrategy or Class<PropertyNamingStrategy> instead"); [EOL]     } [EOL]     Class<?> namingClass = (Class<?>) namingDef; [EOL]     if (!PropertyNamingStrategy.class.isAssignableFrom(namingClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + namingClass.getName() + "; expected Class<PropertyNamingStrategy>"); [EOL]     } [EOL]     HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]     if (hi != null) { [EOL]         PropertyNamingStrategy pns = hi.namingStrategyInstance(_config, _classDef, namingClass); [EOL]         if (pns != null) { [EOL]             return pns; [EOL]         } [EOL]     } [EOL]     return (PropertyNamingStrategy) ClassUtil.createInstance(namingClass, _config.canOverrideAccessModifiers()); [EOL] }
private PropertyNamingStrategy _findNamingStrategy() { [EOL]     Object namingDef = (_annotationIntrospector == null) ? null : _annotationIntrospector.findNamingStrategy(_classDef); [EOL]     if (namingDef == null) { [EOL]         return _config.getPropertyNamingStrategy(); [EOL]     } [EOL]     if (namingDef instanceof PropertyNamingStrategy) { [EOL]         return (PropertyNamingStrategy) namingDef; [EOL]     } [EOL]     if (!(namingDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned PropertyNamingStrategy definition of type " + namingDef.getClass().getName() + "; expected type PropertyNamingStrategy or Class<PropertyNamingStrategy> instead"); [EOL]     } [EOL]     Class<?> namingClass = (Class<?>) namingDef; [EOL]     if (!PropertyNamingStrategy.class.isAssignableFrom(namingClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + namingClass.getName() + "; expected Class<PropertyNamingStrategy>"); [EOL]     } [EOL]     HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]     if (hi != null) { [EOL]         PropertyNamingStrategy pns = hi.namingStrategyInstance(_config, _classDef, namingClass); [EOL]         if (pns != null) { [EOL]             return pns; [EOL]         } [EOL]     } [EOL]     return (PropertyNamingStrategy) ClassUtil.createInstance(namingClass, _config.canOverrideAccessModifiers()); [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case VALUE_STRING: [EOL]             if (_acceptString) { [EOL]                 return jp.getText(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             if (_acceptInt) { [EOL]                 return jp.getIntValue(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (_acceptDouble) { [EOL]                 return Double.valueOf(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             if (_acceptBoolean) { [EOL]                 return Boolean.TRUE; [EOL]             } [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             if (_acceptBoolean) { [EOL]                 return Boolean.FALSE; [EOL]             } [EOL]             break; [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case VALUE_STRING: [EOL]             if (_acceptString) { [EOL]                 return jp.getText(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             if (_acceptInt) { [EOL]                 return jp.getIntValue(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (_acceptDouble) { [EOL]                 return Double.valueOf(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             if (_acceptBoolean) { [EOL]                 return Boolean.TRUE; [EOL]             } [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             if (_acceptBoolean) { [EOL]                 return Boolean.FALSE; [EOL]             } [EOL]             break; [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case VALUE_STRING: [EOL]             if (_acceptString) { [EOL]                 return jp.getText(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             if (_acceptInt) { [EOL]                 return jp.getIntValue(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (_acceptDouble) { [EOL]                 return Double.valueOf(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             if (_acceptBoolean) { [EOL]                 return Boolean.TRUE; [EOL]             } [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             if (_acceptBoolean) { [EOL]                 return Boolean.FALSE; [EOL]             } [EOL]             break; [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case VALUE_STRING: [EOL]             if (_acceptString) { [EOL]                 return jp.getText(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             if (_acceptInt) { [EOL]                 return jp.getIntValue(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (_acceptDouble) { [EOL]                 return Double.valueOf(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             if (_acceptBoolean) { [EOL]                 return Boolean.TRUE; [EOL]             } [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             if (_acceptBoolean) { [EOL]                 return Boolean.FALSE; [EOL]             } [EOL]             break; [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case VALUE_STRING: [EOL]             if (_acceptString) { [EOL]                 return jp.getText(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             if (_acceptInt) { [EOL]                 return jp.getIntValue(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (_acceptDouble) { [EOL]                 return Double.valueOf(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             if (_acceptBoolean) { [EOL]                 return Boolean.TRUE; [EOL]             } [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             if (_acceptBoolean) { [EOL]                 return Boolean.FALSE; [EOL]             } [EOL]             break; [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings("incomplete-switch") [EOL] protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case VALUE_STRING: [EOL]             if (_acceptString) { [EOL]                 return jp.getText(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_INT: [EOL]             if (_acceptInt) { [EOL]                 return jp.getIntValue(); [EOL]             } [EOL]             break; [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (_acceptDouble) { [EOL]                 return Double.valueOf(jp.getDoubleValue()); [EOL]             } [EOL]             break; [EOL]         case VALUE_TRUE: [EOL]             if (_acceptBoolean) { [EOL]                 return Boolean.TRUE; [EOL]             } [EOL]             break; [EOL]         case VALUE_FALSE: [EOL]             if (_acceptBoolean) { [EOL]                 return Boolean.FALSE; [EOL]             } [EOL]             break; [EOL]     } [EOL]     return null; [EOL] }
protected ObjectReader(ObjectReader base, DeserializationConfig config) { [EOL]     _config = config; [EOL]     _context = base._context; [EOL]     _rootDeserializers = base._rootDeserializers; [EOL]     _jsonFactory = base._jsonFactory; [EOL]     _rootNames = base._rootNames; [EOL]     _valueType = base._valueType; [EOL]     _rootDeserializer = base._rootDeserializer; [EOL]     _valueToUpdate = base._valueToUpdate; [EOL]     _schema = base._schema; [EOL]     _injectableValues = base._injectableValues; [EOL]     _unwrapRoot = config.useRootWrapping(); [EOL]     _dataFormatReaders = base._dataFormatReaders; [EOL] }
public ObjectReader withHandler(DeserializationProblemHandler h) { [EOL]     return _with(_config.withHandler(h)); [EOL] }
public ObjectReader withHandler(DeserializationProblemHandler h) { [EOL]     return _with(_config.withHandler(h)); [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T readValue(Reader src) throws IOException, JsonProcessingException { [EOL]     if (_dataFormatReaders != null) { [EOL]         _reportUndetectableSource(src); [EOL]     } [EOL]     return (T) _bindAndClose(_jsonFactory.createParser(src), _valueToUpdate); [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T readValue(Reader src) throws IOException, JsonProcessingException { [EOL]     if (_dataFormatReaders != null) { [EOL]         _reportUndetectableSource(src); [EOL]     } [EOL]     return (T) _bindAndClose(_jsonFactory.createParser(src), _valueToUpdate); [EOL] }
protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException { [EOL]     if (_schema != null) { [EOL]         jp.setSchema(_schema); [EOL]     } [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             if (valueToUpdate == null) { [EOL]                 DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]                 result = _findRootDeserializer(ctxt, _valueType).getNullValue(); [EOL]             } else { [EOL]                 result = valueToUpdate; [EOL]             } [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = valueToUpdate; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType); [EOL]             if (_unwrapRoot) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser); [EOL]             } else { [EOL]                 if (valueToUpdate == null) { [EOL]                     result = deser.deserialize(jp, ctxt); [EOL]                 } else { [EOL]                     deser.deserialize(jp, ctxt, valueToUpdate); [EOL]                     result = valueToUpdate; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException { [EOL]     if (_schema != null) { [EOL]         jp.setSchema(_schema); [EOL]     } [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             if (valueToUpdate == null) { [EOL]                 DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]                 result = _findRootDeserializer(ctxt, _valueType).getNullValue(); [EOL]             } else { [EOL]                 result = valueToUpdate; [EOL]             } [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = valueToUpdate; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType); [EOL]             if (_unwrapRoot) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser); [EOL]             } else { [EOL]                 if (valueToUpdate == null) { [EOL]                     result = deser.deserialize(jp, ctxt); [EOL]                 } else { [EOL]                     deser.deserialize(jp, ctxt, valueToUpdate); [EOL]                     result = valueToUpdate; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException { [EOL]     if (_schema != null) { [EOL]         jp.setSchema(_schema); [EOL]     } [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             if (valueToUpdate == null) { [EOL]                 DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]                 result = _findRootDeserializer(ctxt, _valueType).getNullValue(); [EOL]             } else { [EOL]                 result = valueToUpdate; [EOL]             } [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = valueToUpdate; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType); [EOL]             if (_unwrapRoot) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser); [EOL]             } else { [EOL]                 if (valueToUpdate == null) { [EOL]                     result = deser.deserialize(jp, ctxt); [EOL]                 } else { [EOL]                     deser.deserialize(jp, ctxt, valueToUpdate); [EOL]                     result = valueToUpdate; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException { [EOL]     if (_schema != null) { [EOL]         jp.setSchema(_schema); [EOL]     } [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             if (valueToUpdate == null) { [EOL]                 DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]                 result = _findRootDeserializer(ctxt, _valueType).getNullValue(); [EOL]             } else { [EOL]                 result = valueToUpdate; [EOL]             } [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = valueToUpdate; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType); [EOL]             if (_unwrapRoot) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser); [EOL]             } else { [EOL]                 if (valueToUpdate == null) { [EOL]                     result = deser.deserialize(jp, ctxt); [EOL]                 } else { [EOL]                     deser.deserialize(jp, ctxt, valueToUpdate); [EOL]                     result = valueToUpdate; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException { [EOL]     if (_schema != null) { [EOL]         jp.setSchema(_schema); [EOL]     } [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             if (valueToUpdate == null) { [EOL]                 DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]                 result = _findRootDeserializer(ctxt, _valueType).getNullValue(); [EOL]             } else { [EOL]                 result = valueToUpdate; [EOL]             } [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = valueToUpdate; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType); [EOL]             if (_unwrapRoot) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser); [EOL]             } else { [EOL]                 if (valueToUpdate == null) { [EOL]                     result = deser.deserialize(jp, ctxt); [EOL]                 } else { [EOL]                     deser.deserialize(jp, ctxt, valueToUpdate); [EOL]                     result = valueToUpdate; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException { [EOL]     if (_schema != null) { [EOL]         jp.setSchema(_schema); [EOL]     } [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             if (valueToUpdate == null) { [EOL]                 DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]                 result = _findRootDeserializer(ctxt, _valueType).getNullValue(); [EOL]             } else { [EOL]                 result = valueToUpdate; [EOL]             } [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = valueToUpdate; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType); [EOL]             if (_unwrapRoot) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser); [EOL]             } else { [EOL]                 if (valueToUpdate == null) { [EOL]                     result = deser.deserialize(jp, ctxt); [EOL]                 } else { [EOL]                     deser.deserialize(jp, ctxt, valueToUpdate); [EOL]                     result = valueToUpdate; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException { [EOL]     if (_schema != null) { [EOL]         jp.setSchema(_schema); [EOL]     } [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             if (valueToUpdate == null) { [EOL]                 DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]                 result = _findRootDeserializer(ctxt, _valueType).getNullValue(); [EOL]             } else { [EOL]                 result = valueToUpdate; [EOL]             } [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = valueToUpdate; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType); [EOL]             if (_unwrapRoot) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser); [EOL]             } else { [EOL]                 if (valueToUpdate == null) { [EOL]                     result = deser.deserialize(jp, ctxt); [EOL]                 } else { [EOL]                     deser.deserialize(jp, ctxt, valueToUpdate); [EOL]                     result = valueToUpdate; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException, JsonParseException, JsonMappingException { [EOL]     if (_schema != null) { [EOL]         jp.setSchema(_schema); [EOL]     } [EOL]     try { [EOL]         Object result; [EOL]         JsonToken t = _initForReading(jp); [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             if (valueToUpdate == null) { [EOL]                 DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]                 result = _findRootDeserializer(ctxt, _valueType).getNullValue(); [EOL]             } else { [EOL]                 result = valueToUpdate; [EOL]             } [EOL]         } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) { [EOL]             result = valueToUpdate; [EOL]         } else { [EOL]             DeserializationContext ctxt = createDeserializationContext(jp, _config); [EOL]             JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType); [EOL]             if (_unwrapRoot) { [EOL]                 result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser); [EOL]             } else { [EOL]                 if (valueToUpdate == null) { [EOL]                     result = deser.deserialize(jp, ctxt); [EOL]                 } else { [EOL]                     deser.deserialize(jp, ctxt, valueToUpdate); [EOL]                     result = valueToUpdate; [EOL]                 } [EOL]             } [EOL]         } [EOL]         return result; [EOL]     } finally { [EOL]         try { [EOL]             jp.close(); [EOL]         } catch (IOException ioe) { [EOL]         } [EOL]     } [EOL] }
protected ObjectReader _with(DeserializationConfig newConfig) { [EOL]     if (newConfig == _config) { [EOL]         return this; [EOL]     } [EOL]     if (_dataFormatReaders != null) { [EOL]         return new ObjectReader(this, newConfig).withFormatDetection(_dataFormatReaders.with(newConfig)); [EOL]     } [EOL]     return new ObjectReader(this, newConfig); [EOL] }
protected ObjectReader _with(DeserializationConfig newConfig) { [EOL]     if (newConfig == _config) { [EOL]         return this; [EOL]     } [EOL]     if (_dataFormatReaders != null) { [EOL]         return new ObjectReader(this, newConfig).withFormatDetection(_dataFormatReaders.with(newConfig)); [EOL]     } [EOL]     return new ObjectReader(this, newConfig); [EOL] }
protected ObjectReader _with(DeserializationConfig newConfig) { [EOL]     if (newConfig == _config) { [EOL]         return this; [EOL]     } [EOL]     if (_dataFormatReaders != null) { [EOL]         return new ObjectReader(this, newConfig).withFormatDetection(_dataFormatReaders.with(newConfig)); [EOL]     } [EOL]     return new ObjectReader(this, newConfig); [EOL] }
@Override [EOL] public int containedTypeCount() { [EOL]     return 1; [EOL] }
@Override [EOL] protected String buildCanonicalName() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append(_class.getName()); [EOL]     if (_elementType != null) { [EOL]         sb.append('<'); [EOL]         sb.append(_elementType.toCanonical()); [EOL]         sb.append('>'); [EOL]     } [EOL]     return sb.toString(); [EOL] }
@Override [EOL] protected String buildCanonicalName() { [EOL]     StringBuilder sb = new StringBuilder(); [EOL]     sb.append(_class.getName()); [EOL]     if (_elementType != null) { [EOL]         sb.append('<'); [EOL]         sb.append(_elementType.toCanonical()); [EOL]         sb.append('>'); [EOL]     } [EOL]     return sb.toString(); [EOL] }
@Override [EOL] public void serialize(JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException { [EOL]     jgen.writeString(toCanonical()); [EOL] }
public ObjectWriter with(TimeZone tz) { [EOL]     SerializationConfig newConfig = _config.with(tz); [EOL]     return (newConfig == _config) ? this : new ObjectWriter(this, newConfig); [EOL] }
public ObjectWriter with(TimeZone tz) { [EOL]     SerializationConfig newConfig = _config.with(tz); [EOL]     return (newConfig == _config) ? this : new ObjectWriter(this, newConfig); [EOL] }
public byte[] writeValueAsBytes(Object value) throws JsonProcessingException { [EOL]     ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler()); [EOL]     try { [EOL]         _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value); [EOL]     } catch (JsonProcessingException e) { [EOL]         throw e; [EOL]     } catch (IOException e) { [EOL]         throw JsonMappingException.fromUnexpectedIOE(e); [EOL]     } [EOL]     byte[] result = bb.toByteArray(); [EOL]     bb.release(); [EOL]     return result; [EOL] }
public byte[] writeValueAsBytes(Object value) throws JsonProcessingException { [EOL]     ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler()); [EOL]     try { [EOL]         _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value); [EOL]     } catch (JsonProcessingException e) { [EOL]         throw e; [EOL]     } catch (IOException e) { [EOL]         throw JsonMappingException.fromUnexpectedIOE(e); [EOL]     } [EOL]     byte[] result = bb.toByteArray(); [EOL]     bb.release(); [EOL]     return result; [EOL] }
public byte[] writeValueAsBytes(Object value) throws JsonProcessingException { [EOL]     ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler()); [EOL]     try { [EOL]         _configAndWriteValue(_jsonFactory.createGenerator(bb, JsonEncoding.UTF8), value); [EOL]     } catch (JsonProcessingException e) { [EOL]         throw e; [EOL]     } catch (IOException e) { [EOL]         throw JsonMappingException.fromUnexpectedIOE(e); [EOL]     } [EOL]     byte[] result = bb.toByteArray(); [EOL]     bb.release(); [EOL]     return result; [EOL] }
protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configureJsonGenerator(jgen); [EOL]     if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseable(jgen, value, _config); [EOL]         return; [EOL]     } [EOL]     boolean closed = false; [EOL]     try { [EOL]         if (_rootType == null) { [EOL]             _serializerProvider(_config).serializeValue(jgen, value); [EOL]         } else { [EOL]             _serializerProvider(_config).serializeValue(jgen, value, _rootType, _rootSerializer); [EOL]         } [EOL]         closed = true; [EOL]         jgen.close(); [EOL]     } finally { [EOL]         if (!closed) { [EOL]             try { [EOL]                 jgen.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configureJsonGenerator(jgen); [EOL]     if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseable(jgen, value, _config); [EOL]         return; [EOL]     } [EOL]     boolean closed = false; [EOL]     try { [EOL]         if (_rootType == null) { [EOL]             _serializerProvider(_config).serializeValue(jgen, value); [EOL]         } else { [EOL]             _serializerProvider(_config).serializeValue(jgen, value, _rootType, _rootSerializer); [EOL]         } [EOL]         closed = true; [EOL]         jgen.close(); [EOL]     } finally { [EOL]         if (!closed) { [EOL]             try { [EOL]                 jgen.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configureJsonGenerator(jgen); [EOL]     if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseable(jgen, value, _config); [EOL]         return; [EOL]     } [EOL]     boolean closed = false; [EOL]     try { [EOL]         if (_rootType == null) { [EOL]             _serializerProvider(_config).serializeValue(jgen, value); [EOL]         } else { [EOL]             _serializerProvider(_config).serializeValue(jgen, value, _rootType, _rootSerializer); [EOL]         } [EOL]         closed = true; [EOL]         jgen.close(); [EOL]     } finally { [EOL]         if (!closed) { [EOL]             try { [EOL]                 jgen.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException, JsonGenerationException, JsonMappingException { [EOL]     _configureJsonGenerator(jgen); [EOL]     if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) { [EOL]         _writeCloseable(jgen, value, _config); [EOL]         return; [EOL]     } [EOL]     boolean closed = false; [EOL]     try { [EOL]         if (_rootType == null) { [EOL]             _serializerProvider(_config).serializeValue(jgen, value); [EOL]         } else { [EOL]             _serializerProvider(_config).serializeValue(jgen, value, _rootType, _rootSerializer); [EOL]         } [EOL]         closed = true; [EOL]         jgen.close(); [EOL]     } finally { [EOL]         if (!closed) { [EOL]             try { [EOL]                 jgen.close(); [EOL]             } catch (IOException ioe) { [EOL]             } [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public JsonNode findValue(String fieldName) { [EOL]     for (JsonNode node : _children) { [EOL]         JsonNode value = node.findValue(fieldName); [EOL]         if (value != null) { [EOL]             return value; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonNode findValue(String fieldName) { [EOL]     for (JsonNode node : _children) { [EOL]         JsonNode value = node.findValue(fieldName); [EOL]         if (value != null) { [EOL]             return value; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonNode findValue(String fieldName) { [EOL]     for (JsonNode node : _children) { [EOL]         JsonNode value = node.findValue(fieldName); [EOL]         if (value != null) { [EOL]             return value; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public ObjectNode findParent(String fieldName) { [EOL]     for (JsonNode node : _children) { [EOL]         JsonNode parent = node.findParent(fieldName); [EOL]         if (parent != null) { [EOL]             return (ObjectNode) parent; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public ObjectNode findParent(String fieldName) { [EOL]     for (JsonNode node : _children) { [EOL]         JsonNode parent = node.findParent(fieldName); [EOL]         if (parent != null) { [EOL]             return (ObjectNode) parent; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) { [EOL]         type = factory.mapAbstractType(config, type); [EOL]     } [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type); [EOL]     if (newType != type) { [EOL]         type = newType; [EOL]         beanDesc = config.introspect(newType); [EOL]     } [EOL]     Class<?> builder = beanDesc.findPOJOBuilder(); [EOL]     if (builder != null) { [EOL]         return (JsonDeserializer<Object>) factory.createBuilderBasedDeserializer(ctxt, type, beanDesc, builder); [EOL]     } [EOL]     Converter<Object, Object> conv = beanDesc.findDeserializationConverter(); [EOL]     if (conv == null) { [EOL]         return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc); [EOL]     } [EOL]     JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]     return new StdDelegatingDeserializer<Object>(conv, delegateType, _createDeserializer2(ctxt, factory, delegateType, beanDesc)); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) { [EOL]         type = factory.mapAbstractType(config, type); [EOL]     } [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type); [EOL]     if (newType != type) { [EOL]         type = newType; [EOL]         beanDesc = config.introspect(newType); [EOL]     } [EOL]     Class<?> builder = beanDesc.findPOJOBuilder(); [EOL]     if (builder != null) { [EOL]         return (JsonDeserializer<Object>) factory.createBuilderBasedDeserializer(ctxt, type, beanDesc, builder); [EOL]     } [EOL]     Converter<Object, Object> conv = beanDesc.findDeserializationConverter(); [EOL]     if (conv == null) { [EOL]         return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc); [EOL]     } [EOL]     JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]     return new StdDelegatingDeserializer<Object>(conv, delegateType, _createDeserializer2(ctxt, factory, delegateType, beanDesc)); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) { [EOL]         type = factory.mapAbstractType(config, type); [EOL]     } [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type); [EOL]     if (newType != type) { [EOL]         type = newType; [EOL]         beanDesc = config.introspect(newType); [EOL]     } [EOL]     Class<?> builder = beanDesc.findPOJOBuilder(); [EOL]     if (builder != null) { [EOL]         return (JsonDeserializer<Object>) factory.createBuilderBasedDeserializer(ctxt, type, beanDesc, builder); [EOL]     } [EOL]     Converter<Object, Object> conv = beanDesc.findDeserializationConverter(); [EOL]     if (conv == null) { [EOL]         return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc); [EOL]     } [EOL]     JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]     return new StdDelegatingDeserializer<Object>(conv, delegateType, _createDeserializer2(ctxt, factory, delegateType, beanDesc)); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt, DeserializerFactory factory, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) { [EOL]         type = factory.mapAbstractType(config, type); [EOL]     } [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (deser != null) { [EOL]         return deser; [EOL]     } [EOL]     JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type); [EOL]     if (newType != type) { [EOL]         type = newType; [EOL]         beanDesc = config.introspect(newType); [EOL]     } [EOL]     Class<?> builder = beanDesc.findPOJOBuilder(); [EOL]     if (builder != null) { [EOL]         return (JsonDeserializer<Object>) factory.createBuilderBasedDeserializer(ctxt, type, beanDesc, builder); [EOL]     } [EOL]     Converter<Object, Object> conv = beanDesc.findDeserializationConverter(); [EOL]     if (conv == null) { [EOL]         return (JsonDeserializer<Object>) _createDeserializer2(ctxt, factory, type, beanDesc); [EOL]     } [EOL]     JavaType delegateType = conv.getInputType(ctxt.getTypeFactory()); [EOL]     return new StdDelegatingDeserializer<Object>(conv, delegateType, _createDeserializer2(ctxt, factory, delegateType, beanDesc)); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
protected JsonDeserializer<?> _createDeserializer2(DeserializationContext ctxt, DeserializerFactory factory, JavaType type, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     if (type.isEnumType()) { [EOL]         return factory.createEnumDeserializer(ctxt, type, beanDesc); [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         if (type.isArrayType()) { [EOL]             return factory.createArrayDeserializer(ctxt, (ArrayType) type, beanDesc); [EOL]         } [EOL]         if (type.isMapLikeType()) { [EOL]             MapLikeType mlt = (MapLikeType) type; [EOL]             if (mlt.isTrueMapType()) { [EOL]                 return factory.createMapDeserializer(ctxt, (MapType) mlt, beanDesc); [EOL]             } [EOL]             return factory.createMapLikeDeserializer(ctxt, mlt, beanDesc); [EOL]         } [EOL]         if (type.isCollectionLikeType()) { [EOL]             JsonFormat.Value format = beanDesc.findExpectedFormat(null); [EOL]             if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) { [EOL]                 CollectionLikeType clt = (CollectionLikeType) type; [EOL]                 if (clt.isTrueCollectionType()) { [EOL]                     return factory.createCollectionDeserializer(ctxt, (CollectionType) clt, beanDesc); [EOL]                 } [EOL]                 return factory.createCollectionLikeDeserializer(ctxt, clt, beanDesc); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (JsonNode.class.isAssignableFrom(type.getRawClass())) { [EOL]         return factory.createTreeDeserializer(config, type, beanDesc); [EOL]     } [EOL]     return factory.createBeanDeserializer(ctxt, type, beanDesc); [EOL] }
private JavaType modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, JavaType type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             if (kdDef != null) { [EOL]                 KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]                 if (kd != null) { [EOL]                     type = ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                     keyType = type.getKeyType(); [EOL]                 } [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             if (cdDef != null) { [EOL]                 JsonDeserializer<?> cd = null; [EOL]                 if (cdDef instanceof JsonDeserializer<?>) { [EOL]                     cdDef = (JsonDeserializer<?>) cdDef; [EOL]                 } else { [EOL]                     Class<?> cdClass = _verifyAsClass(cdDef, "findContentDeserializer", JsonDeserializer.None.class); [EOL]                     if (cdClass != null) { [EOL]                         cd = ctxt.deserializerInstance(a, cdClass); [EOL]                     } [EOL]                 } [EOL]                 if (cd != null) { [EOL]                     type = type.withContentValueHandler(cd); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
private Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) { [EOL]     if (src == null) { [EOL]         return null; [EOL]     } [EOL]     if (!(src instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector." + methodName + "() returned value of type " + src.getClass().getName() + ": expected type JsonSerializer or Class<JsonSerializer> instead"); [EOL]     } [EOL]     Class<?> cls = (Class<?>) src; [EOL]     if (cls == noneClass || cls == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     return cls; [EOL] }
private Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) { [EOL]     if (src == null) { [EOL]         return null; [EOL]     } [EOL]     if (!(src instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector." + methodName + "() returned value of type " + src.getClass().getName() + ": expected type JsonSerializer or Class<JsonSerializer> instead"); [EOL]     } [EOL]     Class<?> cls = (Class<?>) src; [EOL]     if (cls == noneClass || cls == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     return cls; [EOL] }
private Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) { [EOL]     if (src == null) { [EOL]         return null; [EOL]     } [EOL]     if (!(src instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector." + methodName + "() returned value of type " + src.getClass().getName() + ": expected type JsonSerializer or Class<JsonSerializer> instead"); [EOL]     } [EOL]     Class<?> cls = (Class<?>) src; [EOL]     if (cls == noneClass || cls == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     return cls; [EOL] }
private Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) { [EOL]     if (src == null) { [EOL]         return null; [EOL]     } [EOL]     if (!(src instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector." + methodName + "() returned value of type " + src.getClass().getName() + ": expected type JsonSerializer or Class<JsonSerializer> instead"); [EOL]     } [EOL]     Class<?> cls = (Class<?>) src; [EOL]     if (cls == noneClass || cls == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     return cls; [EOL] }
private Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass) { [EOL]     if (src == null) { [EOL]         return null; [EOL]     } [EOL]     if (!(src instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector." + methodName + "() returned value of type " + src.getClass().getName() + ": expected type JsonSerializer or Class<JsonSerializer> instead"); [EOL]     } [EOL]     Class<?> cls = (Class<?>) src; [EOL]     if (cls == noneClass || cls == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     return cls; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected MappingIterator(JavaType type, JsonParser jp, DeserializationContext ctxt, JsonDeserializer<?> deser, boolean managedParser, Object valueToUpdate) { [EOL]     _type = type; [EOL]     _parser = jp; [EOL]     _context = ctxt; [EOL]     _deserializer = (JsonDeserializer<T>) deser; [EOL]     _closeParser = managedParser; [EOL]     if (valueToUpdate == null) { [EOL]         _updatedValue = null; [EOL]     } else { [EOL]         _updatedValue = (T) valueToUpdate; [EOL]     } [EOL]     if (managedParser && jp != null && jp.getCurrentToken() == JsonToken.START_ARRAY) { [EOL]         jp.clearCurrentToken(); [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] protected MappingIterator(JavaType type, JsonParser jp, DeserializationContext ctxt, JsonDeserializer<?> deser, boolean managedParser, Object valueToUpdate) { [EOL]     _type = type; [EOL]     _parser = jp; [EOL]     _context = ctxt; [EOL]     _deserializer = (JsonDeserializer<T>) deser; [EOL]     _closeParser = managedParser; [EOL]     if (valueToUpdate == null) { [EOL]         _updatedValue = null; [EOL]     } else { [EOL]         _updatedValue = (T) valueToUpdate; [EOL]     } [EOL]     if (managedParser && jp != null && jp.getCurrentToken() == JsonToken.START_ARRAY) { [EOL]         jp.clearCurrentToken(); [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] protected MappingIterator(JavaType type, JsonParser jp, DeserializationContext ctxt, JsonDeserializer<?> deser, boolean managedParser, Object valueToUpdate) { [EOL]     _type = type; [EOL]     _parser = jp; [EOL]     _context = ctxt; [EOL]     _deserializer = (JsonDeserializer<T>) deser; [EOL]     _closeParser = managedParser; [EOL]     if (valueToUpdate == null) { [EOL]         _updatedValue = null; [EOL]     } else { [EOL]         _updatedValue = (T) valueToUpdate; [EOL]     } [EOL]     if (managedParser && jp != null && jp.getCurrentToken() == JsonToken.START_ARRAY) { [EOL]         jp.clearCurrentToken(); [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] protected MappingIterator(JavaType type, JsonParser jp, DeserializationContext ctxt, JsonDeserializer<?> deser, boolean managedParser, Object valueToUpdate) { [EOL]     _type = type; [EOL]     _parser = jp; [EOL]     _context = ctxt; [EOL]     _deserializer = (JsonDeserializer<T>) deser; [EOL]     _closeParser = managedParser; [EOL]     if (valueToUpdate == null) { [EOL]         _updatedValue = null; [EOL]     } else { [EOL]         _updatedValue = (T) valueToUpdate; [EOL]     } [EOL]     if (managedParser && jp != null && jp.getCurrentToken() == JsonToken.START_ARRAY) { [EOL]         jp.clearCurrentToken(); [EOL]     } [EOL] }
@Override [EOL] public boolean hasNext() { [EOL]     try { [EOL]         return hasNextValue(); [EOL]     } catch (JsonMappingException e) { [EOL]         throw new RuntimeJsonMappingException(e.getMessage(), e); [EOL]     } catch (IOException e) { [EOL]         throw new RuntimeException(e.getMessage(), e); [EOL]     } [EOL] }
@Override [EOL] public boolean hasNext() { [EOL]     try { [EOL]         return hasNextValue(); [EOL]     } catch (JsonMappingException e) { [EOL]         throw new RuntimeJsonMappingException(e.getMessage(), e); [EOL]     } catch (IOException e) { [EOL]         throw new RuntimeException(e.getMessage(), e); [EOL]     } [EOL] }
@Override [EOL] public boolean hasNext() { [EOL]     try { [EOL]         return hasNextValue(); [EOL]     } catch (JsonMappingException e) { [EOL]         throw new RuntimeJsonMappingException(e.getMessage(), e); [EOL]     } catch (IOException e) { [EOL]         throw new RuntimeException(e.getMessage(), e); [EOL]     } [EOL] }
@Override [EOL] public T next() { [EOL]     try { [EOL]         return nextValue(); [EOL]     } catch (JsonMappingException e) { [EOL]         throw new RuntimeJsonMappingException(e.getMessage(), e); [EOL]     } catch (IOException e) { [EOL]         throw new RuntimeException(e.getMessage(), e); [EOL]     } [EOL] }
@Override [EOL] public T next() { [EOL]     try { [EOL]         return nextValue(); [EOL]     } catch (JsonMappingException e) { [EOL]         throw new RuntimeJsonMappingException(e.getMessage(), e); [EOL]     } catch (IOException e) { [EOL]         throw new RuntimeException(e.getMessage(), e); [EOL]     } [EOL] }
@Override [EOL] public T next() { [EOL]     try { [EOL]         return nextValue(); [EOL]     } catch (JsonMappingException e) { [EOL]         throw new RuntimeJsonMappingException(e.getMessage(), e); [EOL]     } catch (IOException e) { [EOL]         throw new RuntimeException(e.getMessage(), e); [EOL]     } [EOL] }
public boolean hasNextValue() throws IOException { [EOL]     if (_parser == null) { [EOL]         return false; [EOL]     } [EOL]     if (!_hasNextChecked) { [EOL]         JsonToken t = _parser.getCurrentToken(); [EOL]         _hasNextChecked = true; [EOL]         if (t == null) { [EOL]             t = _parser.nextToken(); [EOL]             if (t == null || t == JsonToken.END_ARRAY) { [EOL]                 JsonParser jp = _parser; [EOL]                 _parser = null; [EOL]                 if (_closeParser) { [EOL]                     jp.close(); [EOL]                 } [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean hasNextValue() throws IOException { [EOL]     if (_parser == null) { [EOL]         return false; [EOL]     } [EOL]     if (!_hasNextChecked) { [EOL]         JsonToken t = _parser.getCurrentToken(); [EOL]         _hasNextChecked = true; [EOL]         if (t == null) { [EOL]             t = _parser.nextToken(); [EOL]             if (t == null || t == JsonToken.END_ARRAY) { [EOL]                 JsonParser jp = _parser; [EOL]                 _parser = null; [EOL]                 if (_closeParser) { [EOL]                     jp.close(); [EOL]                 } [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean hasNextValue() throws IOException { [EOL]     if (_parser == null) { [EOL]         return false; [EOL]     } [EOL]     if (!_hasNextChecked) { [EOL]         JsonToken t = _parser.getCurrentToken(); [EOL]         _hasNextChecked = true; [EOL]         if (t == null) { [EOL]             t = _parser.nextToken(); [EOL]             if (t == null || t == JsonToken.END_ARRAY) { [EOL]                 JsonParser jp = _parser; [EOL]                 _parser = null; [EOL]                 if (_closeParser) { [EOL]                     jp.close(); [EOL]                 } [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean hasNextValue() throws IOException { [EOL]     if (_parser == null) { [EOL]         return false; [EOL]     } [EOL]     if (!_hasNextChecked) { [EOL]         JsonToken t = _parser.getCurrentToken(); [EOL]         _hasNextChecked = true; [EOL]         if (t == null) { [EOL]             t = _parser.nextToken(); [EOL]             if (t == null || t == JsonToken.END_ARRAY) { [EOL]                 JsonParser jp = _parser; [EOL]                 _parser = null; [EOL]                 if (_closeParser) { [EOL]                     jp.close(); [EOL]                 } [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean hasNextValue() throws IOException { [EOL]     if (_parser == null) { [EOL]         return false; [EOL]     } [EOL]     if (!_hasNextChecked) { [EOL]         JsonToken t = _parser.getCurrentToken(); [EOL]         _hasNextChecked = true; [EOL]         if (t == null) { [EOL]             t = _parser.nextToken(); [EOL]             if (t == null || t == JsonToken.END_ARRAY) { [EOL]                 JsonParser jp = _parser; [EOL]                 _parser = null; [EOL]                 if (_closeParser) { [EOL]                     jp.close(); [EOL]                 } [EOL]                 return false; [EOL]             } [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public T nextValue() throws IOException { [EOL]     if (!_hasNextChecked) { [EOL]         if (!hasNextValue()) { [EOL]             throw new NoSuchElementException(); [EOL]         } [EOL]     } [EOL]     if (_parser == null) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     _hasNextChecked = false; [EOL]     T result; [EOL]     if (_updatedValue == null) { [EOL]         result = _deserializer.deserialize(_parser, _context); [EOL]     } else { [EOL]         _deserializer.deserialize(_parser, _context, _updatedValue); [EOL]         result = _updatedValue; [EOL]     } [EOL]     _parser.clearCurrentToken(); [EOL]     return result; [EOL] }
public T nextValue() throws IOException { [EOL]     if (!_hasNextChecked) { [EOL]         if (!hasNextValue()) { [EOL]             throw new NoSuchElementException(); [EOL]         } [EOL]     } [EOL]     if (_parser == null) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     _hasNextChecked = false; [EOL]     T result; [EOL]     if (_updatedValue == null) { [EOL]         result = _deserializer.deserialize(_parser, _context); [EOL]     } else { [EOL]         _deserializer.deserialize(_parser, _context, _updatedValue); [EOL]         result = _updatedValue; [EOL]     } [EOL]     _parser.clearCurrentToken(); [EOL]     return result; [EOL] }
public T nextValue() throws IOException { [EOL]     if (!_hasNextChecked) { [EOL]         if (!hasNextValue()) { [EOL]             throw new NoSuchElementException(); [EOL]         } [EOL]     } [EOL]     if (_parser == null) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     _hasNextChecked = false; [EOL]     T result; [EOL]     if (_updatedValue == null) { [EOL]         result = _deserializer.deserialize(_parser, _context); [EOL]     } else { [EOL]         _deserializer.deserialize(_parser, _context, _updatedValue); [EOL]         result = _updatedValue; [EOL]     } [EOL]     _parser.clearCurrentToken(); [EOL]     return result; [EOL] }
public T nextValue() throws IOException { [EOL]     if (!_hasNextChecked) { [EOL]         if (!hasNextValue()) { [EOL]             throw new NoSuchElementException(); [EOL]         } [EOL]     } [EOL]     if (_parser == null) { [EOL]         throw new NoSuchElementException(); [EOL]     } [EOL]     _hasNextChecked = false; [EOL]     T result; [EOL]     if (_updatedValue == null) { [EOL]         result = _deserializer.deserialize(_parser, _context); [EOL]     } else { [EOL]         _deserializer.deserialize(_parser, _context, _updatedValue); [EOL]         result = _updatedValue; [EOL]     } [EOL]     _parser.clearCurrentToken(); [EOL]     return result; [EOL] }
@Override [EOL] public final void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException, JsonProcessingException { [EOL]     jg.writeBinary(provider.getConfig().getBase64Variant(), _data, 0, _data.length); [EOL] }
@Override [EOL] public final void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException, JsonProcessingException { [EOL]     jg.writeBinary(provider.getConfig().getBase64Variant(), _data, 0, _data.length); [EOL] }
public int initialCapacity() { [EOL]     return (_freeBuffer == null) ? 0 : _freeBuffer.length; [EOL] }
public int initialCapacity() { [EOL]     return (_freeBuffer == null) ? 0 : _freeBuffer.length; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     switch(jp.getCurrentToken()) { [EOL]         case START_OBJECT: [EOL]             return mapObject(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return mapArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]             return mapObject(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_STRING: [EOL]             return jp.getText(); [EOL]         case VALUE_NUMBER_INT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return jp.getBigIntegerValue(); [EOL]             } [EOL]             return jp.getNumberValue(); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                 return jp.getDecimalValue(); [EOL]             } [EOL]             return Double.valueOf(jp.getDoubleValue()); [EOL]         case VALUE_TRUE: [EOL]             return Boolean.TRUE; [EOL]         case VALUE_FALSE: [EOL]             return Boolean.FALSE; [EOL]         case VALUE_NULL: [EOL]             return null; [EOL]         case END_ARRAY: [EOL]         case END_OBJECT: [EOL]         default: [EOL]             throw ctxt.mappingException(Object.class); [EOL]     } [EOL] }
protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) { [EOL]         return mapArrayToArray(jp, ctxt); [EOL]     } [EOL]     if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]         return new ArrayList<Object>(4); [EOL]     } [EOL]     ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] values = buffer.resetAndStart(); [EOL]     int ptr = 0; [EOL]     int totalSize = 0; [EOL]     do { [EOL]         Object value = deserialize(jp, ctxt); [EOL]         ++totalSize; [EOL]         if (ptr >= values.length) { [EOL]             values = buffer.appendCompletedChunk(values); [EOL]             ptr = 0; [EOL]         } [EOL]         values[ptr++] = value; [EOL]     } while (jp.nextToken() != JsonToken.END_ARRAY); [EOL]     ArrayList<Object> result = new ArrayList<Object>(totalSize + (totalSize >> 3) + 1); [EOL]     buffer.completeAndClearBuffer(values, ptr, result); [EOL]     return result; [EOL] }
protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) { [EOL]         return mapArrayToArray(jp, ctxt); [EOL]     } [EOL]     if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]         return new ArrayList<Object>(4); [EOL]     } [EOL]     ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] values = buffer.resetAndStart(); [EOL]     int ptr = 0; [EOL]     int totalSize = 0; [EOL]     do { [EOL]         Object value = deserialize(jp, ctxt); [EOL]         ++totalSize; [EOL]         if (ptr >= values.length) { [EOL]             values = buffer.appendCompletedChunk(values); [EOL]             ptr = 0; [EOL]         } [EOL]         values[ptr++] = value; [EOL]     } while (jp.nextToken() != JsonToken.END_ARRAY); [EOL]     ArrayList<Object> result = new ArrayList<Object>(totalSize + (totalSize >> 3) + 1); [EOL]     buffer.completeAndClearBuffer(values, ptr, result); [EOL]     return result; [EOL] }
protected Object mapArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) { [EOL]         return mapArrayToArray(jp, ctxt); [EOL]     } [EOL]     if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]         return new ArrayList<Object>(4); [EOL]     } [EOL]     ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] values = buffer.resetAndStart(); [EOL]     int ptr = 0; [EOL]     int totalSize = 0; [EOL]     do { [EOL]         Object value = deserialize(jp, ctxt); [EOL]         ++totalSize; [EOL]         if (ptr >= values.length) { [EOL]             values = buffer.appendCompletedChunk(values); [EOL]             ptr = 0; [EOL]         } [EOL]         values[ptr++] = value; [EOL]     } while (jp.nextToken() != JsonToken.END_ARRAY); [EOL]     ArrayList<Object> result = new ArrayList<Object>(totalSize + (totalSize >> 3) + 1); [EOL]     buffer.completeAndClearBuffer(values, ptr, result); [EOL]     return result; [EOL] }
protected Object mapObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (t != JsonToken.FIELD_NAME) { [EOL]         return new LinkedHashMap<String, Object>(4); [EOL]     } [EOL]     String field1 = jp.getText(); [EOL]     jp.nextToken(); [EOL]     Object value1 = deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4); [EOL]         result.put(field1, value1); [EOL]         return result; [EOL]     } [EOL]     String field2 = jp.getText(); [EOL]     jp.nextToken(); [EOL]     Object value2 = deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4); [EOL]         result.put(field1, value1); [EOL]         result.put(field2, value2); [EOL]         return result; [EOL]     } [EOL]     LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(); [EOL]     result.put(field1, value1); [EOL]     result.put(field2, value2); [EOL]     do { [EOL]         String fieldName = jp.getText(); [EOL]         jp.nextToken(); [EOL]         result.put(fieldName, deserialize(jp, ctxt)); [EOL]     } while (jp.nextToken() != JsonToken.END_OBJECT); [EOL]     return result; [EOL] }
protected Object mapObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (t != JsonToken.FIELD_NAME) { [EOL]         return new LinkedHashMap<String, Object>(4); [EOL]     } [EOL]     String field1 = jp.getText(); [EOL]     jp.nextToken(); [EOL]     Object value1 = deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4); [EOL]         result.put(field1, value1); [EOL]         return result; [EOL]     } [EOL]     String field2 = jp.getText(); [EOL]     jp.nextToken(); [EOL]     Object value2 = deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4); [EOL]         result.put(field1, value1); [EOL]         result.put(field2, value2); [EOL]         return result; [EOL]     } [EOL]     LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(); [EOL]     result.put(field1, value1); [EOL]     result.put(field2, value2); [EOL]     do { [EOL]         String fieldName = jp.getText(); [EOL]         jp.nextToken(); [EOL]         result.put(fieldName, deserialize(jp, ctxt)); [EOL]     } while (jp.nextToken() != JsonToken.END_OBJECT); [EOL]     return result; [EOL] }
protected Object mapObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (t != JsonToken.FIELD_NAME) { [EOL]         return new LinkedHashMap<String, Object>(4); [EOL]     } [EOL]     String field1 = jp.getText(); [EOL]     jp.nextToken(); [EOL]     Object value1 = deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4); [EOL]         result.put(field1, value1); [EOL]         return result; [EOL]     } [EOL]     String field2 = jp.getText(); [EOL]     jp.nextToken(); [EOL]     Object value2 = deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4); [EOL]         result.put(field1, value1); [EOL]         result.put(field2, value2); [EOL]         return result; [EOL]     } [EOL]     LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(); [EOL]     result.put(field1, value1); [EOL]     result.put(field2, value2); [EOL]     do { [EOL]         String fieldName = jp.getText(); [EOL]         jp.nextToken(); [EOL]         result.put(fieldName, deserialize(jp, ctxt)); [EOL]     } while (jp.nextToken() != JsonToken.END_OBJECT); [EOL]     return result; [EOL] }
protected Object mapObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     if (t != JsonToken.FIELD_NAME) { [EOL]         return new LinkedHashMap<String, Object>(4); [EOL]     } [EOL]     String field1 = jp.getText(); [EOL]     jp.nextToken(); [EOL]     Object value1 = deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4); [EOL]         result.put(field1, value1); [EOL]         return result; [EOL]     } [EOL]     String field2 = jp.getText(); [EOL]     jp.nextToken(); [EOL]     Object value2 = deserialize(jp, ctxt); [EOL]     if (jp.nextToken() != JsonToken.FIELD_NAME) { [EOL]         LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4); [EOL]         result.put(field1, value1); [EOL]         result.put(field2, value2); [EOL]         return result; [EOL]     } [EOL]     LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(); [EOL]     result.put(field1, value1); [EOL]     result.put(field2, value2); [EOL]     do { [EOL]         String fieldName = jp.getText(); [EOL]         jp.nextToken(); [EOL]         result.put(fieldName, deserialize(jp, ctxt)); [EOL]     } while (jp.nextToken() != JsonToken.END_OBJECT); [EOL]     return result; [EOL] }
protected Object[] mapArrayToArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]         return NO_OBJECTS; [EOL]     } [EOL]     ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] values = buffer.resetAndStart(); [EOL]     int ptr = 0; [EOL]     do { [EOL]         Object value = deserialize(jp, ctxt); [EOL]         if (ptr >= values.length) { [EOL]             values = buffer.appendCompletedChunk(values); [EOL]             ptr = 0; [EOL]         } [EOL]         values[ptr++] = value; [EOL]     } while (jp.nextToken() != JsonToken.END_ARRAY); [EOL]     return buffer.completeAndClearBuffer(values, ptr); [EOL] }
protected Object[] mapArrayToArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]         return NO_OBJECTS; [EOL]     } [EOL]     ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] values = buffer.resetAndStart(); [EOL]     int ptr = 0; [EOL]     do { [EOL]         Object value = deserialize(jp, ctxt); [EOL]         if (ptr >= values.length) { [EOL]             values = buffer.appendCompletedChunk(values); [EOL]             ptr = 0; [EOL]         } [EOL]         values[ptr++] = value; [EOL]     } while (jp.nextToken() != JsonToken.END_ARRAY); [EOL]     return buffer.completeAndClearBuffer(values, ptr); [EOL] }
protected Object[] mapArrayToArray(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (jp.nextToken() == JsonToken.END_ARRAY) { [EOL]         return NO_OBJECTS; [EOL]     } [EOL]     ObjectBuffer buffer = ctxt.leaseObjectBuffer(); [EOL]     Object[] values = buffer.resetAndStart(); [EOL]     int ptr = 0; [EOL]     do { [EOL]         Object value = deserialize(jp, ctxt); [EOL]         if (ptr >= values.length) { [EOL]             values = buffer.appendCompletedChunk(values); [EOL]             ptr = 0; [EOL]         } [EOL]         values[ptr++] = value; [EOL]     } while (jp.nextToken() != JsonToken.END_ARRAY); [EOL]     return buffer.completeAndClearBuffer(values, ptr); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (!_classNames.contains(clsName)) { [EOL]         return null; [EOL]     } [EOL]     if (rawType == Calendar.class) { [EOL]         return CalendarDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.util.Date.class) { [EOL]         return DateDeserializer.instance; [EOL]     } [EOL]     if (rawType == java.sql.Date.class) { [EOL]         return SqlDateDeserializer.instance; [EOL]     } [EOL]     if (rawType == Timestamp.class) { [EOL]         return TimestampDeserializer.instance; [EOL]     } [EOL]     if (rawType == TimeZone.class) { [EOL]         return TimeZoneDeserializer.instance; [EOL]     } [EOL]     if (rawType == GregorianCalendar.class) { [EOL]         return CalendarDeserializer.gregorianInstance; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + clsName); [EOL] }
protected DateBasedDeserializer(DateBasedDeserializer<T> base, DateFormat format, String formatStr) { [EOL]     super(base._valueClass); [EOL]     _customFormat = format; [EOL]     _formatString = formatStr; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = ctxt.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             TimeZone tz = format.getTimeZone(); [EOL]             String pattern = format.getPattern(); [EOL]             if (pattern.length() > 0) { [EOL]                 Locale loc = format.getLocale(); [EOL]                 if (loc == null) { [EOL]                     loc = ctxt.getLocale(); [EOL]                 } [EOL]                 SimpleDateFormat df = new SimpleDateFormat(pattern, loc); [EOL]                 if (tz == null) { [EOL]                     tz = ctxt.getTimeZone(); [EOL]                 } [EOL]                 df.setTimeZone(tz); [EOL]                 return withDateFormat(df, pattern); [EOL]             } [EOL]             if (tz != null) { [EOL]                 DateFormat df = ctxt.getConfig().getDateFormat(); [EOL]                 if (df.getClass() == StdDateFormat.class) { [EOL]                     df = ((StdDateFormat) df).withTimeZone(tz); [EOL]                 } else { [EOL]                     df = (DateFormat) df.clone(); [EOL]                     df.setTimeZone(tz); [EOL]                 } [EOL]                 return withDateFormat(df, pattern); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = ctxt.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             TimeZone tz = format.getTimeZone(); [EOL]             String pattern = format.getPattern(); [EOL]             if (pattern.length() > 0) { [EOL]                 Locale loc = format.getLocale(); [EOL]                 if (loc == null) { [EOL]                     loc = ctxt.getLocale(); [EOL]                 } [EOL]                 SimpleDateFormat df = new SimpleDateFormat(pattern, loc); [EOL]                 if (tz == null) { [EOL]                     tz = ctxt.getTimeZone(); [EOL]                 } [EOL]                 df.setTimeZone(tz); [EOL]                 return withDateFormat(df, pattern); [EOL]             } [EOL]             if (tz != null) { [EOL]                 DateFormat df = ctxt.getConfig().getDateFormat(); [EOL]                 if (df.getClass() == StdDateFormat.class) { [EOL]                     df = ((StdDateFormat) df).withTimeZone(tz); [EOL]                 } else { [EOL]                     df = (DateFormat) df.clone(); [EOL]                     df.setTimeZone(tz); [EOL]                 } [EOL]                 return withDateFormat(df, pattern); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = ctxt.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             TimeZone tz = format.getTimeZone(); [EOL]             String pattern = format.getPattern(); [EOL]             if (pattern.length() > 0) { [EOL]                 Locale loc = format.getLocale(); [EOL]                 if (loc == null) { [EOL]                     loc = ctxt.getLocale(); [EOL]                 } [EOL]                 SimpleDateFormat df = new SimpleDateFormat(pattern, loc); [EOL]                 if (tz == null) { [EOL]                     tz = ctxt.getTimeZone(); [EOL]                 } [EOL]                 df.setTimeZone(tz); [EOL]                 return withDateFormat(df, pattern); [EOL]             } [EOL]             if (tz != null) { [EOL]                 DateFormat df = ctxt.getConfig().getDateFormat(); [EOL]                 if (df.getClass() == StdDateFormat.class) { [EOL]                     df = ((StdDateFormat) df).withTimeZone(tz); [EOL]                 } else { [EOL]                     df = (DateFormat) df.clone(); [EOL]                     df.setTimeZone(tz); [EOL]                 } [EOL]                 return withDateFormat(df, pattern); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = ctxt.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             TimeZone tz = format.getTimeZone(); [EOL]             String pattern = format.getPattern(); [EOL]             if (pattern.length() > 0) { [EOL]                 Locale loc = format.getLocale(); [EOL]                 if (loc == null) { [EOL]                     loc = ctxt.getLocale(); [EOL]                 } [EOL]                 SimpleDateFormat df = new SimpleDateFormat(pattern, loc); [EOL]                 if (tz == null) { [EOL]                     tz = ctxt.getTimeZone(); [EOL]                 } [EOL]                 df.setTimeZone(tz); [EOL]                 return withDateFormat(df, pattern); [EOL]             } [EOL]             if (tz != null) { [EOL]                 DateFormat df = ctxt.getConfig().getDateFormat(); [EOL]                 if (df.getClass() == StdDateFormat.class) { [EOL]                     df = ((StdDateFormat) df).withTimeZone(tz); [EOL]                 } else { [EOL]                     df = (DateFormat) df.clone(); [EOL]                     df.setTimeZone(tz); [EOL]                 } [EOL]                 return withDateFormat(df, pattern); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_customFormat != null && jp.getCurrentToken() == JsonToken.VALUE_STRING) { [EOL]         String str = jp.getText().trim(); [EOL]         if (str.length() == 0) { [EOL]             return (Date) getEmptyValue(); [EOL]         } [EOL]         synchronized (_customFormat) { [EOL]             try { [EOL]                 return _customFormat.parse(str); [EOL]             } catch (ParseException e) { [EOL]                 throw new IllegalArgumentException("Failed to parse Date value '" + str + "' (format: \"" + _formatString + "\"): " + e.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]     return super._parseDate(jp, ctxt); [EOL] }
@Override [EOL] protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_customFormat != null && jp.getCurrentToken() == JsonToken.VALUE_STRING) { [EOL]         String str = jp.getText().trim(); [EOL]         if (str.length() == 0) { [EOL]             return (Date) getEmptyValue(); [EOL]         } [EOL]         synchronized (_customFormat) { [EOL]             try { [EOL]                 return _customFormat.parse(str); [EOL]             } catch (ParseException e) { [EOL]                 throw new IllegalArgumentException("Failed to parse Date value '" + str + "' (format: \"" + _formatString + "\"): " + e.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]     return super._parseDate(jp, ctxt); [EOL] }
@Override [EOL] protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_customFormat != null && jp.getCurrentToken() == JsonToken.VALUE_STRING) { [EOL]         String str = jp.getText().trim(); [EOL]         if (str.length() == 0) { [EOL]             return (Date) getEmptyValue(); [EOL]         } [EOL]         synchronized (_customFormat) { [EOL]             try { [EOL]                 return _customFormat.parse(str); [EOL]             } catch (ParseException e) { [EOL]                 throw new IllegalArgumentException("Failed to parse Date value '" + str + "' (format: \"" + _formatString + "\"): " + e.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]     return super._parseDate(jp, ctxt); [EOL] }
@Override [EOL] protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_customFormat != null && jp.getCurrentToken() == JsonToken.VALUE_STRING) { [EOL]         String str = jp.getText().trim(); [EOL]         if (str.length() == 0) { [EOL]             return (Date) getEmptyValue(); [EOL]         } [EOL]         synchronized (_customFormat) { [EOL]             try { [EOL]                 return _customFormat.parse(str); [EOL]             } catch (ParseException e) { [EOL]                 throw new IllegalArgumentException("Failed to parse Date value '" + str + "' (format: \"" + _formatString + "\"): " + e.getMessage()); [EOL]             } [EOL]         } [EOL]     } [EOL]     return super._parseDate(jp, ctxt); [EOL] }
public DateDeserializer(DateDeserializer base, DateFormat df, String formatString) { [EOL]     super(base, df, formatString); [EOL] }
public DateDeserializer(DateDeserializer base, DateFormat df, String formatString) { [EOL]     super(base, df, formatString); [EOL] }
public DateDeserializer(DateDeserializer base, DateFormat df, String formatString) { [EOL]     super(base, df, formatString); [EOL] }
public DateDeserializer(DateDeserializer base, DateFormat df, String formatString) { [EOL]     super(base, df, formatString); [EOL] }
@Override [EOL] protected DateDeserializer withDateFormat(DateFormat df, String formatString) { [EOL]     return new DateDeserializer(this, df, formatString); [EOL] }
public TimestampDeserializer() { [EOL]     super(Timestamp.class); [EOL] }
@Override [EOL] public java.sql.Timestamp deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return new Timestamp(_parseDate(jp, ctxt).getTime()); [EOL] }
@Override [EOL] public java.sql.Timestamp deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     return new Timestamp(_parseDate(jp, ctxt).getTime()); [EOL] }
public TimeZoneDeserializer() { [EOL]     super(TimeZone.class); [EOL] }
@Override [EOL] protected TimeZone _deserialize(String value, DeserializationContext ctxt) throws IOException { [EOL]     return TimeZone.getTimeZone(value); [EOL] }
@Override [EOL] protected TimeZone _deserialize(String value, DeserializationContext ctxt) throws IOException { [EOL]     return TimeZone.getTimeZone(value); [EOL] }
protected String idFromValueAndType(Object value, Class<?> type) { [EOL]     return _idResolver.idFromValueAndType(value, type); [EOL] }
public TreeTraversingParser(JsonNode n, ObjectCodec codec) { [EOL]     super(0); [EOL]     _objectCodec = codec; [EOL]     if (n.isArray()) { [EOL]         _nextToken = JsonToken.START_ARRAY; [EOL]         _nodeCursor = new NodeCursor.Array(n, null); [EOL]     } else if (n.isObject()) { [EOL]         _nextToken = JsonToken.START_OBJECT; [EOL]         _nodeCursor = new NodeCursor.Object(n, null); [EOL]     } else { [EOL]         _nodeCursor = new NodeCursor.RootValue(n, null); [EOL]     } [EOL] }
public TreeTraversingParser(JsonNode n, ObjectCodec codec) { [EOL]     super(0); [EOL]     _objectCodec = codec; [EOL]     if (n.isArray()) { [EOL]         _nextToken = JsonToken.START_ARRAY; [EOL]         _nodeCursor = new NodeCursor.Array(n, null); [EOL]     } else if (n.isObject()) { [EOL]         _nextToken = JsonToken.START_OBJECT; [EOL]         _nodeCursor = new NodeCursor.Object(n, null); [EOL]     } else { [EOL]         _nodeCursor = new NodeCursor.RootValue(n, null); [EOL]     } [EOL] }
public TreeTraversingParser(JsonNode n, ObjectCodec codec) { [EOL]     super(0); [EOL]     _objectCodec = codec; [EOL]     if (n.isArray()) { [EOL]         _nextToken = JsonToken.START_ARRAY; [EOL]         _nodeCursor = new NodeCursor.Array(n, null); [EOL]     } else if (n.isObject()) { [EOL]         _nextToken = JsonToken.START_OBJECT; [EOL]         _nodeCursor = new NodeCursor.Object(n, null); [EOL]     } else { [EOL]         _nodeCursor = new NodeCursor.RootValue(n, null); [EOL]     } [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     if (_nextToken != null) { [EOL]         _currToken = _nextToken; [EOL]         _nextToken = null; [EOL]         return _currToken; [EOL]     } [EOL]     if (_startContainer) { [EOL]         _startContainer = false; [EOL]         if (!_nodeCursor.currentHasChildren()) { [EOL]             _currToken = (_currToken == JsonToken.START_OBJECT) ? JsonToken.END_OBJECT : JsonToken.END_ARRAY; [EOL]             return _currToken; [EOL]         } [EOL]         _nodeCursor = _nodeCursor.iterateChildren(); [EOL]         _currToken = _nodeCursor.nextToken(); [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     if (_nodeCursor == null) { [EOL]         _closed = true; [EOL]         return null; [EOL]     } [EOL]     _currToken = _nodeCursor.nextToken(); [EOL]     if (_currToken != null) { [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = _nodeCursor.endToken(); [EOL]     _nodeCursor = _nodeCursor.getParent(); [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     if (_nextToken != null) { [EOL]         _currToken = _nextToken; [EOL]         _nextToken = null; [EOL]         return _currToken; [EOL]     } [EOL]     if (_startContainer) { [EOL]         _startContainer = false; [EOL]         if (!_nodeCursor.currentHasChildren()) { [EOL]             _currToken = (_currToken == JsonToken.START_OBJECT) ? JsonToken.END_OBJECT : JsonToken.END_ARRAY; [EOL]             return _currToken; [EOL]         } [EOL]         _nodeCursor = _nodeCursor.iterateChildren(); [EOL]         _currToken = _nodeCursor.nextToken(); [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     if (_nodeCursor == null) { [EOL]         _closed = true; [EOL]         return null; [EOL]     } [EOL]     _currToken = _nodeCursor.nextToken(); [EOL]     if (_currToken != null) { [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = _nodeCursor.endToken(); [EOL]     _nodeCursor = _nodeCursor.getParent(); [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     if (_nextToken != null) { [EOL]         _currToken = _nextToken; [EOL]         _nextToken = null; [EOL]         return _currToken; [EOL]     } [EOL]     if (_startContainer) { [EOL]         _startContainer = false; [EOL]         if (!_nodeCursor.currentHasChildren()) { [EOL]             _currToken = (_currToken == JsonToken.START_OBJECT) ? JsonToken.END_OBJECT : JsonToken.END_ARRAY; [EOL]             return _currToken; [EOL]         } [EOL]         _nodeCursor = _nodeCursor.iterateChildren(); [EOL]         _currToken = _nodeCursor.nextToken(); [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     if (_nodeCursor == null) { [EOL]         _closed = true; [EOL]         return null; [EOL]     } [EOL]     _currToken = _nodeCursor.nextToken(); [EOL]     if (_currToken != null) { [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = _nodeCursor.endToken(); [EOL]     _nodeCursor = _nodeCursor.getParent(); [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     if (_nextToken != null) { [EOL]         _currToken = _nextToken; [EOL]         _nextToken = null; [EOL]         return _currToken; [EOL]     } [EOL]     if (_startContainer) { [EOL]         _startContainer = false; [EOL]         if (!_nodeCursor.currentHasChildren()) { [EOL]             _currToken = (_currToken == JsonToken.START_OBJECT) ? JsonToken.END_OBJECT : JsonToken.END_ARRAY; [EOL]             return _currToken; [EOL]         } [EOL]         _nodeCursor = _nodeCursor.iterateChildren(); [EOL]         _currToken = _nodeCursor.nextToken(); [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     if (_nodeCursor == null) { [EOL]         _closed = true; [EOL]         return null; [EOL]     } [EOL]     _currToken = _nodeCursor.nextToken(); [EOL]     if (_currToken != null) { [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = _nodeCursor.endToken(); [EOL]     _nodeCursor = _nodeCursor.getParent(); [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     if (_nextToken != null) { [EOL]         _currToken = _nextToken; [EOL]         _nextToken = null; [EOL]         return _currToken; [EOL]     } [EOL]     if (_startContainer) { [EOL]         _startContainer = false; [EOL]         if (!_nodeCursor.currentHasChildren()) { [EOL]             _currToken = (_currToken == JsonToken.START_OBJECT) ? JsonToken.END_OBJECT : JsonToken.END_ARRAY; [EOL]             return _currToken; [EOL]         } [EOL]         _nodeCursor = _nodeCursor.iterateChildren(); [EOL]         _currToken = _nodeCursor.nextToken(); [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     if (_nodeCursor == null) { [EOL]         _closed = true; [EOL]         return null; [EOL]     } [EOL]     _currToken = _nodeCursor.nextToken(); [EOL]     if (_currToken != null) { [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = _nodeCursor.endToken(); [EOL]     _nodeCursor = _nodeCursor.getParent(); [EOL]     return _currToken; [EOL] }
@Override [EOL] public JsonToken nextToken() throws IOException, JsonParseException { [EOL]     if (_nextToken != null) { [EOL]         _currToken = _nextToken; [EOL]         _nextToken = null; [EOL]         return _currToken; [EOL]     } [EOL]     if (_startContainer) { [EOL]         _startContainer = false; [EOL]         if (!_nodeCursor.currentHasChildren()) { [EOL]             _currToken = (_currToken == JsonToken.START_OBJECT) ? JsonToken.END_OBJECT : JsonToken.END_ARRAY; [EOL]             return _currToken; [EOL]         } [EOL]         _nodeCursor = _nodeCursor.iterateChildren(); [EOL]         _currToken = _nodeCursor.nextToken(); [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     if (_nodeCursor == null) { [EOL]         _closed = true; [EOL]         return null; [EOL]     } [EOL]     _currToken = _nodeCursor.nextToken(); [EOL]     if (_currToken != null) { [EOL]         if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) { [EOL]             _startContainer = true; [EOL]         } [EOL]         return _currToken; [EOL]     } [EOL]     _currToken = _nodeCursor.endToken(); [EOL]     _nodeCursor = _nodeCursor.getParent(); [EOL]     return _currToken; [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_closed) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case FIELD_NAME: [EOL]             return _nodeCursor.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]             return currentNode().textValue(); [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return String.valueOf(currentNode().numberValue()); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             JsonNode n = currentNode(); [EOL]             if (n != null && n.isBinary()) { [EOL]                 return n.asText(); [EOL]             } [EOL]         default: [EOL]             return (_currToken == null) ? null : _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_closed) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case FIELD_NAME: [EOL]             return _nodeCursor.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]             return currentNode().textValue(); [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return String.valueOf(currentNode().numberValue()); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             JsonNode n = currentNode(); [EOL]             if (n != null && n.isBinary()) { [EOL]                 return n.asText(); [EOL]             } [EOL]         default: [EOL]             return (_currToken == null) ? null : _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_closed) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case FIELD_NAME: [EOL]             return _nodeCursor.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]             return currentNode().textValue(); [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return String.valueOf(currentNode().numberValue()); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             JsonNode n = currentNode(); [EOL]             if (n != null && n.isBinary()) { [EOL]                 return n.asText(); [EOL]             } [EOL]         default: [EOL]             return (_currToken == null) ? null : _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_closed) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case FIELD_NAME: [EOL]             return _nodeCursor.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]             return currentNode().textValue(); [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return String.valueOf(currentNode().numberValue()); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             JsonNode n = currentNode(); [EOL]             if (n != null && n.isBinary()) { [EOL]                 return n.asText(); [EOL]             } [EOL]         default: [EOL]             return (_currToken == null) ? null : _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_closed) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case FIELD_NAME: [EOL]             return _nodeCursor.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]             return currentNode().textValue(); [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return String.valueOf(currentNode().numberValue()); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             JsonNode n = currentNode(); [EOL]             if (n != null && n.isBinary()) { [EOL]                 return n.asText(); [EOL]             } [EOL]         default: [EOL]             return (_currToken == null) ? null : _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_closed) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case FIELD_NAME: [EOL]             return _nodeCursor.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]             return currentNode().textValue(); [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return String.valueOf(currentNode().numberValue()); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             JsonNode n = currentNode(); [EOL]             if (n != null && n.isBinary()) { [EOL]                 return n.asText(); [EOL]             } [EOL]         default: [EOL]             return (_currToken == null) ? null : _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_closed) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case FIELD_NAME: [EOL]             return _nodeCursor.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]             return currentNode().textValue(); [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return String.valueOf(currentNode().numberValue()); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             JsonNode n = currentNode(); [EOL]             if (n != null && n.isBinary()) { [EOL]                 return n.asText(); [EOL]             } [EOL]         default: [EOL]             return (_currToken == null) ? null : _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_closed) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case FIELD_NAME: [EOL]             return _nodeCursor.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]             return currentNode().textValue(); [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return String.valueOf(currentNode().numberValue()); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             JsonNode n = currentNode(); [EOL]             if (n != null && n.isBinary()) { [EOL]                 return n.asText(); [EOL]             } [EOL]         default: [EOL]             return (_currToken == null) ? null : _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public String getText() { [EOL]     if (_closed) { [EOL]         return null; [EOL]     } [EOL]     switch(_currToken) { [EOL]         case FIELD_NAME: [EOL]             return _nodeCursor.getCurrentName(); [EOL]         case VALUE_STRING: [EOL]             return currentNode().textValue(); [EOL]         case VALUE_NUMBER_INT: [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return String.valueOf(currentNode().numberValue()); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             JsonNode n = currentNode(); [EOL]             if (n != null && n.isBinary()) { [EOL]                 return n.asText(); [EOL]             } [EOL]         default: [EOL]             return (_currToken == null) ? null : _currToken.asString(); [EOL]     } [EOL] }
@Override [EOL] public char[] getTextCharacters() throws IOException, JsonParseException { [EOL]     return getText().toCharArray(); [EOL] }
@Override [EOL] public int getTextLength() throws IOException, JsonParseException { [EOL]     return getText().length(); [EOL] }
@Override [EOL] public int getTextOffset() throws IOException, JsonParseException { [EOL]     return 0; [EOL] }
public TimeZoneSerializer() { [EOL]     super(TimeZone.class); [EOL] }
@Override [EOL] public void serializeWithType(TimeZone value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     typeSer.writeTypePrefixForScalar(value, jgen, TimeZone.class); [EOL]     serialize(value, jgen, provider); [EOL]     typeSer.writeTypeSuffixForScalar(value, jgen); [EOL] }
@Override [EOL] public void serializeWithType(TimeZone value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException { [EOL]     typeSer.writeTypePrefixForScalar(value, jgen, TimeZone.class); [EOL]     serialize(value, jgen, provider); [EOL]     typeSer.writeTypeSuffixForScalar(value, jgen); [EOL] }
protected BeanSerializerBuilder(BeanSerializerBuilder src) { [EOL]     _beanDesc = src._beanDesc; [EOL]     _properties = src._properties; [EOL]     _filteredProperties = src._filteredProperties; [EOL]     _anyGetter = src._anyGetter; [EOL]     _filterId = src._filterId; [EOL] }
public void setTypeId(AnnotatedMember idProp) { [EOL]     if (_typeId != null) { [EOL]         throw new IllegalArgumentException("Multiple type ids specified with " + _typeId + " and " + idProp); [EOL]     } [EOL]     _typeId = idProp; [EOL] }
public void setTypeId(AnnotatedMember idProp) { [EOL]     if (_typeId != null) { [EOL]         throw new IllegalArgumentException("Multiple type ids specified with " + _typeId + " and " + idProp); [EOL]     } [EOL]     _typeId = idProp; [EOL] }
public void setTypeId(AnnotatedMember idProp) { [EOL]     if (_typeId != null) { [EOL]         throw new IllegalArgumentException("Multiple type ids specified with " + _typeId + " and " + idProp); [EOL]     } [EOL]     _typeId = idProp; [EOL] }
@Override [EOL] public String nameForGetterMethod(MapperConfig<?> config, AnnotatedMethod method, String defaultName) { [EOL]     return translate(defaultName); [EOL] }
public static EnumValues constructFromToString(Class<Enum<?>> enumClass, AnnotationIntrospector intr) { [EOL]     Class<? extends Enum<?>> cls = ClassUtil.findEnumType(enumClass); [EOL]     Enum<?>[] values = cls.getEnumConstants(); [EOL]     if (values != null) { [EOL]         Map<Enum<?>, SerializedString> map = new HashMap<Enum<?>, SerializedString>(); [EOL]         for (Enum<?> en : values) { [EOL]             map.put(en, new SerializedString(en.toString())); [EOL]         } [EOL]         return new EnumValues(enumClass, map); [EOL]     } [EOL]     throw new IllegalArgumentException("Can not determine enum constants for Class " + enumClass.getName()); [EOL] }
public static EnumValues constructFromToString(Class<Enum<?>> enumClass, AnnotationIntrospector intr) { [EOL]     Class<? extends Enum<?>> cls = ClassUtil.findEnumType(enumClass); [EOL]     Enum<?>[] values = cls.getEnumConstants(); [EOL]     if (values != null) { [EOL]         Map<Enum<?>, SerializedString> map = new HashMap<Enum<?>, SerializedString>(); [EOL]         for (Enum<?> en : values) { [EOL]             map.put(en, new SerializedString(en.toString())); [EOL]         } [EOL]         return new EnumValues(enumClass, map); [EOL]     } [EOL]     throw new IllegalArgumentException("Can not determine enum constants for Class " + enumClass.getName()); [EOL] }
public BigIntegerNode(BigInteger v) { [EOL]     _value = v; [EOL] }
public BigIntegerNode(BigInteger v) { [EOL]     _value = v; [EOL] }
public BigIntegerNode(BigInteger v) { [EOL]     _value = v; [EOL] }
public BigIntegerNode(BigInteger v) { [EOL]     _value = v; [EOL] }
public static BigIntegerNode valueOf(BigInteger v) { [EOL]     return new BigIntegerNode(v); [EOL] }
public static BigIntegerNode valueOf(BigInteger v) { [EOL]     return new BigIntegerNode(v); [EOL] }
@Override [EOL] public JsonToken asToken() { [EOL]     return JsonToken.VALUE_NUMBER_INT; [EOL] }
@Override [EOL] public JsonParser.NumberType numberType() { [EOL]     return JsonParser.NumberType.BIG_INTEGER; [EOL] }
@Override [EOL] public boolean isIntegralNumber() { [EOL]     return true; [EOL] }
@Override [EOL] public boolean isBigInteger() { [EOL]     return true; [EOL] }
@Override [EOL] public boolean canConvertToInt() { [EOL]     return (_value.compareTo(MIN_INTEGER) >= 0) && (_value.compareTo(MAX_INTEGER) <= 0); [EOL] }
@Override [EOL] public boolean canConvertToInt() { [EOL]     return (_value.compareTo(MIN_INTEGER) >= 0) && (_value.compareTo(MAX_INTEGER) <= 0); [EOL] }
@Override [EOL] public boolean canConvertToInt() { [EOL]     return (_value.compareTo(MIN_INTEGER) >= 0) && (_value.compareTo(MAX_INTEGER) <= 0); [EOL] }
@Override [EOL] public boolean canConvertToInt() { [EOL]     return (_value.compareTo(MIN_INTEGER) >= 0) && (_value.compareTo(MAX_INTEGER) <= 0); [EOL] }
@Override [EOL] public boolean canConvertToInt() { [EOL]     return (_value.compareTo(MIN_INTEGER) >= 0) && (_value.compareTo(MAX_INTEGER) <= 0); [EOL] }
@Override [EOL] public boolean canConvertToLong() { [EOL]     return (_value.compareTo(MIN_LONG) >= 0) && (_value.compareTo(MAX_LONG) <= 0); [EOL] }
@Override [EOL] public boolean canConvertToLong() { [EOL]     return (_value.compareTo(MIN_LONG) >= 0) && (_value.compareTo(MAX_LONG) <= 0); [EOL] }
@Override [EOL] public boolean canConvertToLong() { [EOL]     return (_value.compareTo(MIN_LONG) >= 0) && (_value.compareTo(MAX_LONG) <= 0); [EOL] }
@Override [EOL] public boolean canConvertToLong() { [EOL]     return (_value.compareTo(MIN_LONG) >= 0) && (_value.compareTo(MAX_LONG) <= 0); [EOL] }
@Override [EOL] public Number numberValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public Number numberValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return _value.intValue(); [EOL] }
@Override [EOL] public int intValue() { [EOL]     return _value.intValue(); [EOL] }
@Override [EOL] public int intValue() { [EOL]     return _value.intValue(); [EOL] }
@Override [EOL] public long longValue() { [EOL]     return _value.longValue(); [EOL] }
@Override [EOL] public BigInteger bigIntegerValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public BigInteger bigIntegerValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return _value.doubleValue(); [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return _value.doubleValue(); [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return _value.doubleValue(); [EOL] }
@Override [EOL] public String asText() { [EOL]     return _value.toString(); [EOL] }
@Override [EOL] public String asText() { [EOL]     return _value.toString(); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return ((BigIntegerNode) o)._value.equals(_value); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return ((BigIntegerNode) o)._value.equals(_value); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return ((BigIntegerNode) o)._value.equals(_value); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return ((BigIntegerNode) o)._value.equals(_value); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return ((BigIntegerNode) o)._value.equals(_value); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return _value.hashCode(); [EOL] }
public BooleanNode booleanNode(boolean v) { [EOL]     return v ? BooleanNode.getTrue() : BooleanNode.getFalse(); [EOL] }
public BooleanNode booleanNode(boolean v) { [EOL]     return v ? BooleanNode.getTrue() : BooleanNode.getFalse(); [EOL] }
public NumericNode numberNode(int v) { [EOL]     return IntNode.valueOf(v); [EOL] }
public NumericNode numberNode(int v) { [EOL]     return IntNode.valueOf(v); [EOL] }
public NumericNode numberNode(int v) { [EOL]     return IntNode.valueOf(v); [EOL] }
public NumericNode numberNode(long v) { [EOL]     return LongNode.valueOf(v); [EOL] }
public NumericNode numberNode(long v) { [EOL]     return LongNode.valueOf(v); [EOL] }
public NumericNode numberNode(long v) { [EOL]     return LongNode.valueOf(v); [EOL] }
public NumericNode numberNode(BigInteger v) { [EOL]     return BigIntegerNode.valueOf(v); [EOL] }
public NumericNode numberNode(BigInteger v) { [EOL]     return BigIntegerNode.valueOf(v); [EOL] }
public NumericNode numberNode(BigInteger v) { [EOL]     return BigIntegerNode.valueOf(v); [EOL] }
public NumericNode numberNode(BigInteger v) { [EOL]     return BigIntegerNode.valueOf(v); [EOL] }
public NumericNode numberNode(double v) { [EOL]     return DoubleNode.valueOf(v); [EOL] }
public NumericNode numberNode(double v) { [EOL]     return DoubleNode.valueOf(v); [EOL] }
public NumericNode numberNode(double v) { [EOL]     return DoubleNode.valueOf(v); [EOL] }
public TextNode textNode(String text) { [EOL]     return TextNode.valueOf(text); [EOL] }
public TextNode textNode(String text) { [EOL]     return TextNode.valueOf(text); [EOL] }
public TextNode textNode(String text) { [EOL]     return TextNode.valueOf(text); [EOL] }
public ArrayNode arrayNode() { [EOL]     return new ArrayNode(this); [EOL] }
public ObjectNode objectNode() { [EOL]     return new ObjectNode(this); [EOL] }
@Override [EOL] public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver) { [EOL]     return withConfig(_factoryConfig.withAbstractTypeResolver(resolver)); [EOL] }
@Override [EOL] public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver) { [EOL]     return withConfig(_factoryConfig.withAbstractTypeResolver(resolver)); [EOL] }
@Override [EOL] public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException { [EOL]     while (true) { [EOL]         JavaType next = _mapAbstractType2(config, type); [EOL]         if (next == null) { [EOL]             return type; [EOL]         } [EOL]         Class<?> prevCls = type.getRawClass(); [EOL]         Class<?> nextCls = next.getRawClass(); [EOL]         if ((prevCls == nextCls) || !prevCls.isAssignableFrom(nextCls)) { [EOL]             throw new IllegalArgumentException("Invalid abstract type resolution from " + type + " to " + next + ": latter is not a subtype of former"); [EOL]         } [EOL]         type = next; [EOL]     } [EOL] }
@Override [EOL] public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException { [EOL]     while (true) { [EOL]         JavaType next = _mapAbstractType2(config, type); [EOL]         if (next == null) { [EOL]             return type; [EOL]         } [EOL]         Class<?> prevCls = type.getRawClass(); [EOL]         Class<?> nextCls = next.getRawClass(); [EOL]         if ((prevCls == nextCls) || !prevCls.isAssignableFrom(nextCls)) { [EOL]             throw new IllegalArgumentException("Invalid abstract type resolution from " + type + " to " + next + ": latter is not a subtype of former"); [EOL]         } [EOL]         type = next; [EOL]     } [EOL] }
@Override [EOL] public JavaType mapAbstractType(DeserializationConfig config, JavaType type) throws JsonMappingException { [EOL]     while (true) { [EOL]         JavaType next = _mapAbstractType2(config, type); [EOL]         if (next == null) { [EOL]             return type; [EOL]         } [EOL]         Class<?> prevCls = type.getRawClass(); [EOL]         Class<?> nextCls = next.getRawClass(); [EOL]         if ((prevCls == nextCls) || !prevCls.isAssignableFrom(nextCls)) { [EOL]             throw new IllegalArgumentException("Invalid abstract type resolution from " + type + " to " + next + ": latter is not a subtype of former"); [EOL]         } [EOL]         type = next; [EOL]     } [EOL] }
private JavaType _mapAbstractType2(DeserializationConfig config, JavaType type) throws JsonMappingException { [EOL]     Class<?> currClass = type.getRawClass(); [EOL]     if (_factoryConfig.hasAbstractTypeResolvers()) { [EOL]         for (AbstractTypeResolver resolver : _factoryConfig.abstractTypeResolvers()) { [EOL]             JavaType concrete = resolver.findTypeMapping(config, type); [EOL]             if (concrete != null && concrete.getRawClass() != currClass) { [EOL]                 return concrete; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private JavaType _mapAbstractType2(DeserializationConfig config, JavaType type) throws JsonMappingException { [EOL]     Class<?> currClass = type.getRawClass(); [EOL]     if (_factoryConfig.hasAbstractTypeResolvers()) { [EOL]         for (AbstractTypeResolver resolver : _factoryConfig.abstractTypeResolvers()) { [EOL]             JavaType concrete = resolver.findTypeMapping(config, type); [EOL]             if (concrete != null && concrete.getRawClass() != currClass) { [EOL]                 return concrete; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
private JavaType _mapAbstractType2(DeserializationConfig config, JavaType type) throws JsonMappingException { [EOL]     Class<?> currClass = type.getRawClass(); [EOL]     if (_factoryConfig.hasAbstractTypeResolvers()) { [EOL]         for (AbstractTypeResolver resolver : _factoryConfig.abstractTypeResolvers()) { [EOL]             JavaType concrete = resolver.findTypeMapping(config, type); [EOL]             if (concrete != null && concrete.getRawClass() != currClass) { [EOL]                 return concrete; [EOL]             } [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     ValueInstantiator instantiator = null; [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac); [EOL]     if (instDef != null) { [EOL]         instantiator = _valueInstantiatorInstance(config, ac, instDef); [EOL]     } [EOL]     if (instantiator == null) { [EOL]         instantiator = _findStdValueInstantiator(config, beanDesc); [EOL]         if (instantiator == null) { [EOL]             instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasValueInstantiators()) { [EOL]         for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) { [EOL]             instantiator = insts.findValueInstantiator(config, beanDesc, instantiator); [EOL]             if (instantiator == null) { [EOL]                 throw new JsonMappingException("Broken registered ValueInstantiators (of type " + insts.getClass().getName() + "): returned null ValueInstantiator"); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (instantiator.getIncompleteParameter() != null) { [EOL]         final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter(); [EOL]         final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner(); [EOL]         throw new IllegalArgumentException("Argument #" + nonAnnotatedParam.getIndex() + " of constructor " + ctor + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator"); [EOL]     } [EOL]     return instantiator; [EOL] }
@Override [EOL] public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     ValueInstantiator instantiator = null; [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac); [EOL]     if (instDef != null) { [EOL]         instantiator = _valueInstantiatorInstance(config, ac, instDef); [EOL]     } [EOL]     if (instantiator == null) { [EOL]         instantiator = _findStdValueInstantiator(config, beanDesc); [EOL]         if (instantiator == null) { [EOL]             instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasValueInstantiators()) { [EOL]         for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) { [EOL]             instantiator = insts.findValueInstantiator(config, beanDesc, instantiator); [EOL]             if (instantiator == null) { [EOL]                 throw new JsonMappingException("Broken registered ValueInstantiators (of type " + insts.getClass().getName() + "): returned null ValueInstantiator"); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (instantiator.getIncompleteParameter() != null) { [EOL]         final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter(); [EOL]         final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner(); [EOL]         throw new IllegalArgumentException("Argument #" + nonAnnotatedParam.getIndex() + " of constructor " + ctor + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator"); [EOL]     } [EOL]     return instantiator; [EOL] }
@Override [EOL] public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     ValueInstantiator instantiator = null; [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac); [EOL]     if (instDef != null) { [EOL]         instantiator = _valueInstantiatorInstance(config, ac, instDef); [EOL]     } [EOL]     if (instantiator == null) { [EOL]         instantiator = _findStdValueInstantiator(config, beanDesc); [EOL]         if (instantiator == null) { [EOL]             instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasValueInstantiators()) { [EOL]         for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) { [EOL]             instantiator = insts.findValueInstantiator(config, beanDesc, instantiator); [EOL]             if (instantiator == null) { [EOL]                 throw new JsonMappingException("Broken registered ValueInstantiators (of type " + insts.getClass().getName() + "): returned null ValueInstantiator"); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (instantiator.getIncompleteParameter() != null) { [EOL]         final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter(); [EOL]         final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner(); [EOL]         throw new IllegalArgumentException("Argument #" + nonAnnotatedParam.getIndex() + " of constructor " + ctor + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator"); [EOL]     } [EOL]     return instantiator; [EOL] }
@Override [EOL] public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     ValueInstantiator instantiator = null; [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac); [EOL]     if (instDef != null) { [EOL]         instantiator = _valueInstantiatorInstance(config, ac, instDef); [EOL]     } [EOL]     if (instantiator == null) { [EOL]         instantiator = _findStdValueInstantiator(config, beanDesc); [EOL]         if (instantiator == null) { [EOL]             instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasValueInstantiators()) { [EOL]         for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) { [EOL]             instantiator = insts.findValueInstantiator(config, beanDesc, instantiator); [EOL]             if (instantiator == null) { [EOL]                 throw new JsonMappingException("Broken registered ValueInstantiators (of type " + insts.getClass().getName() + "): returned null ValueInstantiator"); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (instantiator.getIncompleteParameter() != null) { [EOL]         final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter(); [EOL]         final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner(); [EOL]         throw new IllegalArgumentException("Argument #" + nonAnnotatedParam.getIndex() + " of constructor " + ctor + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator"); [EOL]     } [EOL]     return instantiator; [EOL] }
@Override [EOL] public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     ValueInstantiator instantiator = null; [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac); [EOL]     if (instDef != null) { [EOL]         instantiator = _valueInstantiatorInstance(config, ac, instDef); [EOL]     } [EOL]     if (instantiator == null) { [EOL]         instantiator = _findStdValueInstantiator(config, beanDesc); [EOL]         if (instantiator == null) { [EOL]             instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasValueInstantiators()) { [EOL]         for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) { [EOL]             instantiator = insts.findValueInstantiator(config, beanDesc, instantiator); [EOL]             if (instantiator == null) { [EOL]                 throw new JsonMappingException("Broken registered ValueInstantiators (of type " + insts.getClass().getName() + "): returned null ValueInstantiator"); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (instantiator.getIncompleteParameter() != null) { [EOL]         final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter(); [EOL]         final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner(); [EOL]         throw new IllegalArgumentException("Argument #" + nonAnnotatedParam.getIndex() + " of constructor " + ctor + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator"); [EOL]     } [EOL]     return instantiator; [EOL] }
@Override [EOL] public ValueInstantiator findValueInstantiator(DeserializationContext ctxt, BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     ValueInstantiator instantiator = null; [EOL]     AnnotatedClass ac = beanDesc.getClassInfo(); [EOL]     Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac); [EOL]     if (instDef != null) { [EOL]         instantiator = _valueInstantiatorInstance(config, ac, instDef); [EOL]     } [EOL]     if (instantiator == null) { [EOL]         instantiator = _findStdValueInstantiator(config, beanDesc); [EOL]         if (instantiator == null) { [EOL]             instantiator = _constructDefaultValueInstantiator(ctxt, beanDesc); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasValueInstantiators()) { [EOL]         for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) { [EOL]             instantiator = insts.findValueInstantiator(config, beanDesc, instantiator); [EOL]             if (instantiator == null) { [EOL]                 throw new JsonMappingException("Broken registered ValueInstantiators (of type " + insts.getClass().getName() + "): returned null ValueInstantiator"); [EOL]             } [EOL]         } [EOL]     } [EOL]     if (instantiator.getIncompleteParameter() != null) { [EOL]         final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter(); [EOL]         final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner(); [EOL]         throw new IllegalArgumentException("Argument #" + nonAnnotatedParam.getIndex() + " of constructor " + ctor + " has no property name annotation; must have name when multiple-paramater constructor annotated as Creator"); [EOL]     } [EOL]     return instantiator; [EOL] }
public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException { [EOL]     if (instDef == null) { [EOL]         return null; [EOL]     } [EOL]     ValueInstantiator inst; [EOL]     if (instDef instanceof ValueInstantiator) { [EOL]         return (ValueInstantiator) instDef; [EOL]     } [EOL]     if (!(instDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + instDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]     } [EOL]     Class<?> instClass = (Class<?>) instDef; [EOL]     if (instClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!ValueInstantiator.class.isAssignableFrom(instClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + instClass.getName() + "; expected Class<ValueInstantiator>"); [EOL]     } [EOL]     HandlerInstantiator hi = config.getHandlerInstantiator(); [EOL]     if (hi != null) { [EOL]         inst = hi.valueInstantiatorInstance(config, annotated, instClass); [EOL]         if (inst != null) { [EOL]             return inst; [EOL]         } [EOL]     } [EOL]     return (ValueInstantiator) ClassUtil.createInstance(instClass, config.canOverrideAccessModifiers()); [EOL] }
public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException { [EOL]     if (instDef == null) { [EOL]         return null; [EOL]     } [EOL]     ValueInstantiator inst; [EOL]     if (instDef instanceof ValueInstantiator) { [EOL]         return (ValueInstantiator) instDef; [EOL]     } [EOL]     if (!(instDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + instDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]     } [EOL]     Class<?> instClass = (Class<?>) instDef; [EOL]     if (instClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!ValueInstantiator.class.isAssignableFrom(instClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + instClass.getName() + "; expected Class<ValueInstantiator>"); [EOL]     } [EOL]     HandlerInstantiator hi = config.getHandlerInstantiator(); [EOL]     if (hi != null) { [EOL]         inst = hi.valueInstantiatorInstance(config, annotated, instClass); [EOL]         if (inst != null) { [EOL]             return inst; [EOL]         } [EOL]     } [EOL]     return (ValueInstantiator) ClassUtil.createInstance(instClass, config.canOverrideAccessModifiers()); [EOL] }
public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException { [EOL]     if (instDef == null) { [EOL]         return null; [EOL]     } [EOL]     ValueInstantiator inst; [EOL]     if (instDef instanceof ValueInstantiator) { [EOL]         return (ValueInstantiator) instDef; [EOL]     } [EOL]     if (!(instDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + instDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]     } [EOL]     Class<?> instClass = (Class<?>) instDef; [EOL]     if (instClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!ValueInstantiator.class.isAssignableFrom(instClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + instClass.getName() + "; expected Class<ValueInstantiator>"); [EOL]     } [EOL]     HandlerInstantiator hi = config.getHandlerInstantiator(); [EOL]     if (hi != null) { [EOL]         inst = hi.valueInstantiatorInstance(config, annotated, instClass); [EOL]         if (inst != null) { [EOL]             return inst; [EOL]         } [EOL]     } [EOL]     return (ValueInstantiator) ClassUtil.createInstance(instClass, config.canOverrideAccessModifiers()); [EOL] }
public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException { [EOL]     if (instDef == null) { [EOL]         return null; [EOL]     } [EOL]     ValueInstantiator inst; [EOL]     if (instDef instanceof ValueInstantiator) { [EOL]         return (ValueInstantiator) instDef; [EOL]     } [EOL]     if (!(instDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + instDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]     } [EOL]     Class<?> instClass = (Class<?>) instDef; [EOL]     if (instClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!ValueInstantiator.class.isAssignableFrom(instClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + instClass.getName() + "; expected Class<ValueInstantiator>"); [EOL]     } [EOL]     HandlerInstantiator hi = config.getHandlerInstantiator(); [EOL]     if (hi != null) { [EOL]         inst = hi.valueInstantiatorInstance(config, annotated, instClass); [EOL]         if (inst != null) { [EOL]             return inst; [EOL]         } [EOL]     } [EOL]     return (ValueInstantiator) ClassUtil.createInstance(instClass, config.canOverrideAccessModifiers()); [EOL] }
public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException { [EOL]     if (instDef == null) { [EOL]         return null; [EOL]     } [EOL]     ValueInstantiator inst; [EOL]     if (instDef instanceof ValueInstantiator) { [EOL]         return (ValueInstantiator) instDef; [EOL]     } [EOL]     if (!(instDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + instDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]     } [EOL]     Class<?> instClass = (Class<?>) instDef; [EOL]     if (instClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!ValueInstantiator.class.isAssignableFrom(instClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + instClass.getName() + "; expected Class<ValueInstantiator>"); [EOL]     } [EOL]     HandlerInstantiator hi = config.getHandlerInstantiator(); [EOL]     if (hi != null) { [EOL]         inst = hi.valueInstantiatorInstance(config, annotated, instClass); [EOL]         if (inst != null) { [EOL]             return inst; [EOL]         } [EOL]     } [EOL]     return (ValueInstantiator) ClassUtil.createInstance(instClass, config.canOverrideAccessModifiers()); [EOL] }
public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException { [EOL]     if (instDef == null) { [EOL]         return null; [EOL]     } [EOL]     ValueInstantiator inst; [EOL]     if (instDef instanceof ValueInstantiator) { [EOL]         return (ValueInstantiator) instDef; [EOL]     } [EOL]     if (!(instDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + instDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]     } [EOL]     Class<?> instClass = (Class<?>) instDef; [EOL]     if (instClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!ValueInstantiator.class.isAssignableFrom(instClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + instClass.getName() + "; expected Class<ValueInstantiator>"); [EOL]     } [EOL]     HandlerInstantiator hi = config.getHandlerInstantiator(); [EOL]     if (hi != null) { [EOL]         inst = hi.valueInstantiatorInstance(config, annotated, instClass); [EOL]         if (inst != null) { [EOL]             return inst; [EOL]         } [EOL]     } [EOL]     return (ValueInstantiator) ClassUtil.createInstance(instClass, config.canOverrideAccessModifiers()); [EOL] }
public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config, Annotated annotated, Object instDef) throws JsonMappingException { [EOL]     if (instDef == null) { [EOL]         return null; [EOL]     } [EOL]     ValueInstantiator inst; [EOL]     if (instDef instanceof ValueInstantiator) { [EOL]         return (ValueInstantiator) instDef; [EOL]     } [EOL]     if (!(instDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned key deserializer definition of type " + instDef.getClass().getName() + "; expected type KeyDeserializer or Class<KeyDeserializer> instead"); [EOL]     } [EOL]     Class<?> instClass = (Class<?>) instDef; [EOL]     if (instClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!ValueInstantiator.class.isAssignableFrom(instClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + instClass.getName() + "; expected Class<ValueInstantiator>"); [EOL]     } [EOL]     HandlerInstantiator hi = config.getHandlerInstantiator(); [EOL]     if (hi != null) { [EOL]         inst = hi.valueInstantiatorInstance(config, annotated, instClass); [EOL]         if (inst != null) { [EOL]             return inst; [EOL]         } [EOL]     } [EOL]     return (ValueInstantiator) ClassUtil.createInstance(instClass, config.canOverrideAccessModifiers()); [EOL] }
protected CreatorProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, String name, int index, AnnotatedParameter param, Object injectableValueId) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Boolean b = (intr == null) ? null : intr.hasRequiredMarker(param); [EOL]     boolean req = (b == null) ? false : b.booleanValue(); [EOL]     JavaType t0 = config.getTypeFactory().constructType(param.getParameterType(), beanDesc.bindingsForBeanType()); [EOL]     BeanProperty.Std property = new BeanProperty.Std(name, t0, intr.findWrapperName(param), beanDesc.getClassAnnotations(), param, req); [EOL]     JavaType type = resolveType(ctxt, beanDesc, t0, param); [EOL]     if (type != t0) { [EOL]         property = property.withType(type); [EOL]     } [EOL]     JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, param); [EOL]     type = modifyTypeByAnnotation(ctxt, param, type); [EOL]     TypeDeserializer typeDeser = (TypeDeserializer) type.getTypeHandler(); [EOL]     if (typeDeser == null) { [EOL]         typeDeser = findTypeDeserializer(config, type); [EOL]     } [EOL]     CreatorProperty prop = new CreatorProperty(name, type, property.getWrapperName(), typeDeser, beanDesc.getClassAnnotations(), param, index, injectableValueId, property.isRequired()); [EOL]     if (deser != null) { [EOL]         prop = prop.withValueDeserializer(deser); [EOL]     } [EOL]     return prop; [EOL] }
protected CreatorProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, String name, int index, AnnotatedParameter param, Object injectableValueId) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Boolean b = (intr == null) ? null : intr.hasRequiredMarker(param); [EOL]     boolean req = (b == null) ? false : b.booleanValue(); [EOL]     JavaType t0 = config.getTypeFactory().constructType(param.getParameterType(), beanDesc.bindingsForBeanType()); [EOL]     BeanProperty.Std property = new BeanProperty.Std(name, t0, intr.findWrapperName(param), beanDesc.getClassAnnotations(), param, req); [EOL]     JavaType type = resolveType(ctxt, beanDesc, t0, param); [EOL]     if (type != t0) { [EOL]         property = property.withType(type); [EOL]     } [EOL]     JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, param); [EOL]     type = modifyTypeByAnnotation(ctxt, param, type); [EOL]     TypeDeserializer typeDeser = (TypeDeserializer) type.getTypeHandler(); [EOL]     if (typeDeser == null) { [EOL]         typeDeser = findTypeDeserializer(config, type); [EOL]     } [EOL]     CreatorProperty prop = new CreatorProperty(name, type, property.getWrapperName(), typeDeser, beanDesc.getClassAnnotations(), param, index, injectableValueId, property.isRequired()); [EOL]     if (deser != null) { [EOL]         prop = prop.withValueDeserializer(deser); [EOL]     } [EOL]     return prop; [EOL] }
protected CreatorProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, String name, int index, AnnotatedParameter param, Object injectableValueId) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Boolean b = (intr == null) ? null : intr.hasRequiredMarker(param); [EOL]     boolean req = (b == null) ? false : b.booleanValue(); [EOL]     JavaType t0 = config.getTypeFactory().constructType(param.getParameterType(), beanDesc.bindingsForBeanType()); [EOL]     BeanProperty.Std property = new BeanProperty.Std(name, t0, intr.findWrapperName(param), beanDesc.getClassAnnotations(), param, req); [EOL]     JavaType type = resolveType(ctxt, beanDesc, t0, param); [EOL]     if (type != t0) { [EOL]         property = property.withType(type); [EOL]     } [EOL]     JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, param); [EOL]     type = modifyTypeByAnnotation(ctxt, param, type); [EOL]     TypeDeserializer typeDeser = (TypeDeserializer) type.getTypeHandler(); [EOL]     if (typeDeser == null) { [EOL]         typeDeser = findTypeDeserializer(config, type); [EOL]     } [EOL]     CreatorProperty prop = new CreatorProperty(name, type, property.getWrapperName(), typeDeser, beanDesc.getClassAnnotations(), param, index, injectableValueId, property.isRequired()); [EOL]     if (deser != null) { [EOL]         prop = prop.withValueDeserializer(deser); [EOL]     } [EOL]     return prop; [EOL] }
protected CreatorProperty constructCreatorProperty(DeserializationContext ctxt, BeanDescription beanDesc, String name, int index, AnnotatedParameter param, Object injectableValueId) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Boolean b = (intr == null) ? null : intr.hasRequiredMarker(param); [EOL]     boolean req = (b == null) ? false : b.booleanValue(); [EOL]     JavaType t0 = config.getTypeFactory().constructType(param.getParameterType(), beanDesc.bindingsForBeanType()); [EOL]     BeanProperty.Std property = new BeanProperty.Std(name, t0, intr.findWrapperName(param), beanDesc.getClassAnnotations(), param, req); [EOL]     JavaType type = resolveType(ctxt, beanDesc, t0, param); [EOL]     if (type != t0) { [EOL]         property = property.withType(type); [EOL]     } [EOL]     JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, param); [EOL]     type = modifyTypeByAnnotation(ctxt, param, type); [EOL]     TypeDeserializer typeDeser = (TypeDeserializer) type.getTypeHandler(); [EOL]     if (typeDeser == null) { [EOL]         typeDeser = findTypeDeserializer(config, type); [EOL]     } [EOL]     CreatorProperty prop = new CreatorProperty(name, type, property.getWrapperName(), typeDeser, beanDesc.getClassAnnotations(), param, index, injectableValueId, property.isRequired()); [EOL]     if (deser != null) { [EOL]         prop = prop.withValueDeserializer(deser); [EOL]     } [EOL]     return prop; [EOL] }
@Override [EOL] public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     JavaType elemType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = elemType.getValueHandler(); [EOL]     TypeDeserializer elemTypeDeser = elemType.getTypeHandler(); [EOL]     if (elemTypeDeser == null) { [EOL]         elemTypeDeser = findTypeDeserializer(config, elemType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomArrayDeserializer(type, config, beanDesc, elemTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         if (contentDeser == null) { [EOL]             Class<?> raw = elemType.getRawClass(); [EOL]             if (elemType.isPrimitive()) { [EOL]                 return PrimitiveArrayDeserializers.forType(raw); [EOL]             } else if (raw == String.class) { [EOL]                 return StringArrayDeserializer.instance; [EOL]             } [EOL]         } [EOL]         if (deser == null) { [EOL]             deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     JavaType elemType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = elemType.getValueHandler(); [EOL]     TypeDeserializer elemTypeDeser = elemType.getTypeHandler(); [EOL]     if (elemTypeDeser == null) { [EOL]         elemTypeDeser = findTypeDeserializer(config, elemType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomArrayDeserializer(type, config, beanDesc, elemTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         if (contentDeser == null) { [EOL]             Class<?> raw = elemType.getRawClass(); [EOL]             if (elemType.isPrimitive()) { [EOL]                 return PrimitiveArrayDeserializers.forType(raw); [EOL]             } else if (raw == String.class) { [EOL]                 return StringArrayDeserializer.instance; [EOL]             } [EOL]         } [EOL]         if (deser == null) { [EOL]             deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     JavaType elemType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = elemType.getValueHandler(); [EOL]     TypeDeserializer elemTypeDeser = elemType.getTypeHandler(); [EOL]     if (elemTypeDeser == null) { [EOL]         elemTypeDeser = findTypeDeserializer(config, elemType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomArrayDeserializer(type, config, beanDesc, elemTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         if (contentDeser == null) { [EOL]             Class<?> raw = elemType.getRawClass(); [EOL]             if (elemType.isPrimitive()) { [EOL]                 return PrimitiveArrayDeserializers.forType(raw); [EOL]             } else if (raw == String.class) { [EOL]                 return StringArrayDeserializer.instance; [EOL]             } [EOL]         } [EOL]         if (deser == null) { [EOL]             deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     JavaType elemType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = elemType.getValueHandler(); [EOL]     TypeDeserializer elemTypeDeser = elemType.getTypeHandler(); [EOL]     if (elemTypeDeser == null) { [EOL]         elemTypeDeser = findTypeDeserializer(config, elemType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomArrayDeserializer(type, config, beanDesc, elemTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         if (contentDeser == null) { [EOL]             Class<?> raw = elemType.getRawClass(); [EOL]             if (elemType.isPrimitive()) { [EOL]                 return PrimitiveArrayDeserializers.forType(raw); [EOL]             } else if (raw == String.class) { [EOL]                 return StringArrayDeserializer.instance; [EOL]             } [EOL]         } [EOL]         if (deser == null) { [EOL]             deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt, ArrayType type, final BeanDescription beanDesc) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     JavaType elemType = type.getContentType(); [EOL]     JsonDeserializer<Object> contentDeser = elemType.getValueHandler(); [EOL]     TypeDeserializer elemTypeDeser = elemType.getTypeHandler(); [EOL]     if (elemTypeDeser == null) { [EOL]         elemTypeDeser = findTypeDeserializer(config, elemType); [EOL]     } [EOL]     JsonDeserializer<?> deser = _findCustomArrayDeserializer(type, config, beanDesc, elemTypeDeser, contentDeser); [EOL]     if (deser == null) { [EOL]         if (contentDeser == null) { [EOL]             Class<?> raw = elemType.getRawClass(); [EOL]             if (elemType.isPrimitive()) { [EOL]                 return PrimitiveArrayDeserializers.forType(raw); [EOL]             } else if (raw == String.class) { [EOL]                 return StringArrayDeserializer.instance; [EOL]             } [EOL]         } [EOL]         if (deser == null) { [EOL]             deser = new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser); [EOL]         } [EOL]     } [EOL]     if (_factoryConfig.hasDeserializerModifiers()) { [EOL]         for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]             deser = mod.modifyArrayDeserializer(config, type, beanDesc, deser); [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findArrayDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findArrayDeserializer(type, config, beanDesc, elementTypeDeserializer, elementDeserializer); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findEnumDeserializer(type, config, beanDesc); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findEnumDeserializer(type, config, beanDesc); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, JavaType nodeType, BeanDescription beanDesc) throws JsonMappingException { [EOL]     @SuppressWarnings("unchecked") [EOL]     Class<? extends JsonNode> nodeClass = (Class<? extends JsonNode>) nodeType.getRawClass(); [EOL]     JsonDeserializer<?> custom = _findCustomTreeNodeDeserializer(nodeClass, config, beanDesc); [EOL]     if (custom != null) { [EOL]         return custom; [EOL]     } [EOL]     return JsonNodeDeserializer.getDeserializer(nodeClass); [EOL] }
@Override [EOL] public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, JavaType nodeType, BeanDescription beanDesc) throws JsonMappingException { [EOL]     @SuppressWarnings("unchecked") [EOL]     Class<? extends JsonNode> nodeClass = (Class<? extends JsonNode>) nodeType.getRawClass(); [EOL]     JsonDeserializer<?> custom = _findCustomTreeNodeDeserializer(nodeClass, config, beanDesc); [EOL]     if (custom != null) { [EOL]         return custom; [EOL]     } [EOL]     return JsonNodeDeserializer.getDeserializer(nodeClass); [EOL] }
protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     for (Deserializers d : _factoryConfig.deserializers()) { [EOL]         JsonDeserializer<?> deser = d.findTreeNodeDeserializer(type, config, beanDesc); [EOL]         if (deser != null) { [EOL]             return deser; [EOL]         } [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException { [EOL]     Class<?> cls = baseType.getRawClass(); [EOL]     BeanDescription bean = config.introspectClassAnnotations(cls); [EOL]     AnnotatedClass ac = bean.getClassInfo(); [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); [EOL]     Collection<NamedType> subtypes = null; [EOL]     if (b == null) { [EOL]         b = config.getDefaultTyper(baseType); [EOL]         if (b == null) { [EOL]             return null; [EOL]         } [EOL]     } else { [EOL]         subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(ac, config, ai); [EOL]     } [EOL]     if ((b.getDefaultImpl() == null) && baseType.isAbstract()) { [EOL]         JavaType defaultType = mapAbstractType(config, baseType); [EOL]         if (defaultType != null && defaultType.getRawClass() != baseType.getRawClass()) { [EOL]             b = b.defaultImpl(defaultType.getRawClass()); [EOL]         } [EOL]     } [EOL]     return b.buildTypeDeserializer(config, baseType, subtypes); [EOL] }
@Override [EOL] public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException { [EOL]     Class<?> cls = baseType.getRawClass(); [EOL]     BeanDescription bean = config.introspectClassAnnotations(cls); [EOL]     AnnotatedClass ac = bean.getClassInfo(); [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); [EOL]     Collection<NamedType> subtypes = null; [EOL]     if (b == null) { [EOL]         b = config.getDefaultTyper(baseType); [EOL]         if (b == null) { [EOL]             return null; [EOL]         } [EOL]     } else { [EOL]         subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(ac, config, ai); [EOL]     } [EOL]     if ((b.getDefaultImpl() == null) && baseType.isAbstract()) { [EOL]         JavaType defaultType = mapAbstractType(config, baseType); [EOL]         if (defaultType != null && defaultType.getRawClass() != baseType.getRawClass()) { [EOL]             b = b.defaultImpl(defaultType.getRawClass()); [EOL]         } [EOL]     } [EOL]     return b.buildTypeDeserializer(config, baseType, subtypes); [EOL] }
@Override [EOL] public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType) throws JsonMappingException { [EOL]     Class<?> cls = baseType.getRawClass(); [EOL]     BeanDescription bean = config.introspectClassAnnotations(cls); [EOL]     AnnotatedClass ac = bean.getClassInfo(); [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType); [EOL]     Collection<NamedType> subtypes = null; [EOL]     if (b == null) { [EOL]         b = config.getDefaultTyper(baseType); [EOL]         if (b == null) { [EOL]             return null; [EOL]         } [EOL]     } else { [EOL]         subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(ac, config, ai); [EOL]     } [EOL]     if ((b.getDefaultImpl() == null) && baseType.isAbstract()) { [EOL]         JavaType defaultType = mapAbstractType(config, baseType); [EOL]         if (defaultType != null && defaultType.getRawClass() != baseType.getRawClass()) { [EOL]             b = b.defaultImpl(defaultType.getRawClass()); [EOL]         } [EOL]     } [EOL]     return b.buildTypeDeserializer(config, baseType, subtypes); [EOL] }
@Override [EOL] public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     KeyDeserializer deser = null; [EOL]     if (_factoryConfig.hasKeyDeserializers()) { [EOL]         BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass()); [EOL]         for (KeyDeserializers d : _factoryConfig.keyDeserializers()) { [EOL]             deser = d.findKeyDeserializer(type, config, beanDesc); [EOL]             if (deser != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isEnumType()) { [EOL]             return _createEnumKeyDeserializer(ctxt, type); [EOL]         } [EOL]         deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type); [EOL]     } [EOL]     if (deser != null) { [EOL]         if (_factoryConfig.hasDeserializerModifiers()) { [EOL]             for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]                 deser = mod.modifyKeyDeserializer(config, type, deser); [EOL]             } [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     KeyDeserializer deser = null; [EOL]     if (_factoryConfig.hasKeyDeserializers()) { [EOL]         BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass()); [EOL]         for (KeyDeserializers d : _factoryConfig.keyDeserializers()) { [EOL]             deser = d.findKeyDeserializer(type, config, beanDesc); [EOL]             if (deser != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isEnumType()) { [EOL]             return _createEnumKeyDeserializer(ctxt, type); [EOL]         } [EOL]         deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type); [EOL]     } [EOL]     if (deser != null) { [EOL]         if (_factoryConfig.hasDeserializerModifiers()) { [EOL]             for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]                 deser = mod.modifyKeyDeserializer(config, type, deser); [EOL]             } [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     KeyDeserializer deser = null; [EOL]     if (_factoryConfig.hasKeyDeserializers()) { [EOL]         BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass()); [EOL]         for (KeyDeserializers d : _factoryConfig.keyDeserializers()) { [EOL]             deser = d.findKeyDeserializer(type, config, beanDesc); [EOL]             if (deser != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isEnumType()) { [EOL]             return _createEnumKeyDeserializer(ctxt, type); [EOL]         } [EOL]         deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type); [EOL]     } [EOL]     if (deser != null) { [EOL]         if (_factoryConfig.hasDeserializerModifiers()) { [EOL]             for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]                 deser = mod.modifyKeyDeserializer(config, type, deser); [EOL]             } [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
@Override [EOL] public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     KeyDeserializer deser = null; [EOL]     if (_factoryConfig.hasKeyDeserializers()) { [EOL]         BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass()); [EOL]         for (KeyDeserializers d : _factoryConfig.keyDeserializers()) { [EOL]             deser = d.findKeyDeserializer(type, config, beanDesc); [EOL]             if (deser != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (deser == null) { [EOL]         if (type.isEnumType()) { [EOL]             return _createEnumKeyDeserializer(ctxt, type); [EOL]         } [EOL]         deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type); [EOL]     } [EOL]     if (deser != null) { [EOL]         if (_factoryConfig.hasDeserializerModifiers()) { [EOL]             for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { [EOL]                 deser = mod.modifyKeyDeserializer(config, type, deser); [EOL]             } [EOL]         } [EOL]     } [EOL]     return deser; [EOL] }
private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<?> des = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (des != null) { [EOL]         return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des); [EOL]     } [EOL]     Class<?> enumClass = type.getRawClass(); [EOL]     JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc); [EOL]     if (custom != null) { [EOL]         return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des); [EOL]     } [EOL]     EnumResolver<?> enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod()); [EOL]     for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]         if (config.getAnnotationIntrospector().hasCreatorAnnotation(factory)) { [EOL]             int argCount = factory.getParameterCount(); [EOL]             if (argCount == 1) { [EOL]                 Class<?> returnType = factory.getRawReturnType(); [EOL]                 if (returnType.isAssignableFrom(enumClass)) { [EOL]                     if (factory.getGenericParameterType(0) != String.class) { [EOL]                         throw new IllegalArgumentException("Parameter #0 type for factory method (" + factory + ") not suitable, must be java.lang.String"); [EOL]                     } [EOL]                     if (config.canOverrideAccessModifiers()) { [EOL]                         ClassUtil.checkAndFixAccess(factory.getMember()); [EOL]                     } [EOL]                     return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory); [EOL]                 } [EOL]             } [EOL]             throw new IllegalArgumentException("Unsuitable method (" + factory + ") decorated with @JsonCreator (for Enum type " + enumClass.getName() + ")"); [EOL]         } [EOL]     } [EOL]     return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes); [EOL] }
private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<?> des = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (des != null) { [EOL]         return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des); [EOL]     } [EOL]     Class<?> enumClass = type.getRawClass(); [EOL]     JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc); [EOL]     if (custom != null) { [EOL]         return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des); [EOL]     } [EOL]     EnumResolver<?> enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod()); [EOL]     for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]         if (config.getAnnotationIntrospector().hasCreatorAnnotation(factory)) { [EOL]             int argCount = factory.getParameterCount(); [EOL]             if (argCount == 1) { [EOL]                 Class<?> returnType = factory.getRawReturnType(); [EOL]                 if (returnType.isAssignableFrom(enumClass)) { [EOL]                     if (factory.getGenericParameterType(0) != String.class) { [EOL]                         throw new IllegalArgumentException("Parameter #0 type for factory method (" + factory + ") not suitable, must be java.lang.String"); [EOL]                     } [EOL]                     if (config.canOverrideAccessModifiers()) { [EOL]                         ClassUtil.checkAndFixAccess(factory.getMember()); [EOL]                     } [EOL]                     return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory); [EOL]                 } [EOL]             } [EOL]             throw new IllegalArgumentException("Unsuitable method (" + factory + ") decorated with @JsonCreator (for Enum type " + enumClass.getName() + ")"); [EOL]         } [EOL]     } [EOL]     return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes); [EOL] }
private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<?> des = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (des != null) { [EOL]         return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des); [EOL]     } [EOL]     Class<?> enumClass = type.getRawClass(); [EOL]     JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc); [EOL]     if (custom != null) { [EOL]         return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des); [EOL]     } [EOL]     EnumResolver<?> enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod()); [EOL]     for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]         if (config.getAnnotationIntrospector().hasCreatorAnnotation(factory)) { [EOL]             int argCount = factory.getParameterCount(); [EOL]             if (argCount == 1) { [EOL]                 Class<?> returnType = factory.getRawReturnType(); [EOL]                 if (returnType.isAssignableFrom(enumClass)) { [EOL]                     if (factory.getGenericParameterType(0) != String.class) { [EOL]                         throw new IllegalArgumentException("Parameter #0 type for factory method (" + factory + ") not suitable, must be java.lang.String"); [EOL]                     } [EOL]                     if (config.canOverrideAccessModifiers()) { [EOL]                         ClassUtil.checkAndFixAccess(factory.getMember()); [EOL]                     } [EOL]                     return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory); [EOL]                 } [EOL]             } [EOL]             throw new IllegalArgumentException("Unsuitable method (" + factory + ") decorated with @JsonCreator (for Enum type " + enumClass.getName() + ")"); [EOL]         } [EOL]     } [EOL]     return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes); [EOL] }
private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<?> des = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (des != null) { [EOL]         return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des); [EOL]     } [EOL]     Class<?> enumClass = type.getRawClass(); [EOL]     JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc); [EOL]     if (custom != null) { [EOL]         return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des); [EOL]     } [EOL]     EnumResolver<?> enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod()); [EOL]     for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]         if (config.getAnnotationIntrospector().hasCreatorAnnotation(factory)) { [EOL]             int argCount = factory.getParameterCount(); [EOL]             if (argCount == 1) { [EOL]                 Class<?> returnType = factory.getRawReturnType(); [EOL]                 if (returnType.isAssignableFrom(enumClass)) { [EOL]                     if (factory.getGenericParameterType(0) != String.class) { [EOL]                         throw new IllegalArgumentException("Parameter #0 type for factory method (" + factory + ") not suitable, must be java.lang.String"); [EOL]                     } [EOL]                     if (config.canOverrideAccessModifiers()) { [EOL]                         ClassUtil.checkAndFixAccess(factory.getMember()); [EOL]                     } [EOL]                     return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory); [EOL]                 } [EOL]             } [EOL]             throw new IllegalArgumentException("Unsuitable method (" + factory + ") decorated with @JsonCreator (for Enum type " + enumClass.getName() + ")"); [EOL]         } [EOL]     } [EOL]     return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes); [EOL] }
private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<?> des = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (des != null) { [EOL]         return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des); [EOL]     } [EOL]     Class<?> enumClass = type.getRawClass(); [EOL]     JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc); [EOL]     if (custom != null) { [EOL]         return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des); [EOL]     } [EOL]     EnumResolver<?> enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod()); [EOL]     for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]         if (config.getAnnotationIntrospector().hasCreatorAnnotation(factory)) { [EOL]             int argCount = factory.getParameterCount(); [EOL]             if (argCount == 1) { [EOL]                 Class<?> returnType = factory.getRawReturnType(); [EOL]                 if (returnType.isAssignableFrom(enumClass)) { [EOL]                     if (factory.getGenericParameterType(0) != String.class) { [EOL]                         throw new IllegalArgumentException("Parameter #0 type for factory method (" + factory + ") not suitable, must be java.lang.String"); [EOL]                     } [EOL]                     if (config.canOverrideAccessModifiers()) { [EOL]                         ClassUtil.checkAndFixAccess(factory.getMember()); [EOL]                     } [EOL]                     return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory); [EOL]                 } [EOL]             } [EOL]             throw new IllegalArgumentException("Unsuitable method (" + factory + ") decorated with @JsonCreator (for Enum type " + enumClass.getName() + ")"); [EOL]         } [EOL]     } [EOL]     return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes); [EOL] }
private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt, JavaType type) throws JsonMappingException { [EOL]     final DeserializationConfig config = ctxt.getConfig(); [EOL]     BeanDescription beanDesc = config.introspect(type); [EOL]     JsonDeserializer<?> des = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo()); [EOL]     if (des != null) { [EOL]         return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des); [EOL]     } [EOL]     Class<?> enumClass = type.getRawClass(); [EOL]     JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc); [EOL]     if (custom != null) { [EOL]         return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des); [EOL]     } [EOL]     EnumResolver<?> enumRes = constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod()); [EOL]     for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) { [EOL]         if (config.getAnnotationIntrospector().hasCreatorAnnotation(factory)) { [EOL]             int argCount = factory.getParameterCount(); [EOL]             if (argCount == 1) { [EOL]                 Class<?> returnType = factory.getRawReturnType(); [EOL]                 if (returnType.isAssignableFrom(enumClass)) { [EOL]                     if (factory.getGenericParameterType(0) != String.class) { [EOL]                         throw new IllegalArgumentException("Parameter #0 type for factory method (" + factory + ") not suitable, must be java.lang.String"); [EOL]                     } [EOL]                     if (config.canOverrideAccessModifiers()) { [EOL]                         ClassUtil.checkAndFixAccess(factory.getMember()); [EOL]                     } [EOL]                     return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes, factory); [EOL]                 } [EOL]             } [EOL]             throw new IllegalArgumentException("Unsuitable method (" + factory + ") decorated with @JsonCreator (for Enum type " + enumClass.getName() + ")"); [EOL]         } [EOL]     } [EOL]     return StdKeyDeserializers.constructEnumKeyDeserializer(enumRes); [EOL] }
public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException { [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, annotated, baseType); [EOL]     if (b == null) { [EOL]         return findTypeDeserializer(config, baseType); [EOL]     } [EOL]     Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(annotated, config, ai, baseType); [EOL]     return b.buildTypeDeserializer(config, baseType, subtypes); [EOL] }
public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType, AnnotatedMember annotated) throws JsonMappingException { [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, annotated, baseType); [EOL]     if (b == null) { [EOL]         return findTypeDeserializer(config, baseType); [EOL]     } [EOL]     Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(annotated, config, ai, baseType); [EOL]     return b.buildTypeDeserializer(config, baseType, subtypes); [EOL] }
@SuppressWarnings({ "unchecked" }) [EOL] protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = (T) type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = (T) ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]             if (kd != null) { [EOL]                 type = (T) ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = (T) type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef); [EOL]             if (cd != null) { [EOL]                 type = (T) type.withContentValueHandler(cd); [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
@SuppressWarnings({ "unchecked" }) [EOL] protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = (T) type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = (T) ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]             if (kd != null) { [EOL]                 type = (T) ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = (T) type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef); [EOL]             if (cd != null) { [EOL]                 type = (T) type.withContentValueHandler(cd); [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
@SuppressWarnings({ "unchecked" }) [EOL] protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = (T) type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = (T) ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]             if (kd != null) { [EOL]                 type = (T) ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = (T) type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef); [EOL]             if (cd != null) { [EOL]                 type = (T) type.withContentValueHandler(cd); [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
@SuppressWarnings({ "unchecked" }) [EOL] protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = (T) type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = (T) ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]             if (kd != null) { [EOL]                 type = (T) ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = (T) type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef); [EOL]             if (cd != null) { [EOL]                 type = (T) type.withContentValueHandler(cd); [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
@SuppressWarnings({ "unchecked" }) [EOL] protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = (T) type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = (T) ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]             if (kd != null) { [EOL]                 type = (T) ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = (T) type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef); [EOL]             if (cd != null) { [EOL]                 type = (T) type.withContentValueHandler(cd); [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
@SuppressWarnings({ "unchecked" }) [EOL] protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt, Annotated a, T type) throws JsonMappingException { [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     Class<?> subclass = intr.findDeserializationType(a, type); [EOL]     if (subclass != null) { [EOL]         try { [EOL]             type = (T) type.narrowBy(subclass); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw new JsonMappingException("Failed to narrow type " + type + " with concrete-type annotation (value " + subclass.getName() + "), method '" + a.getName() + "': " + iae.getMessage(), null, iae); [EOL]         } [EOL]     } [EOL]     if (type.isContainerType()) { [EOL]         Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType()); [EOL]         if (keyClass != null) { [EOL]             if (!(type instanceof MapLikeType)) { [EOL]                 throw new JsonMappingException("Illegal key-type annotation: type " + type + " is not a Map(-like) type"); [EOL]             } [EOL]             try { [EOL]                 type = (T) ((MapLikeType) type).narrowKey(keyClass); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow key type " + type + " with key-type annotation (" + keyClass.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null && keyType.getValueHandler() == null) { [EOL]             Object kdDef = intr.findKeyDeserializer(a); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(a, kdDef); [EOL]             if (kd != null) { [EOL]                 type = (T) ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Class<?> cc = intr.findDeserializationContentType(a, type.getContentType()); [EOL]         if (cc != null) { [EOL]             try { [EOL]                 type = (T) type.narrowContentsBy(cc); [EOL]             } catch (IllegalArgumentException iae) { [EOL]                 throw new JsonMappingException("Failed to narrow content type " + type + " with content-type annotation (" + cc.getName() + "): " + iae.getMessage(), null, iae); [EOL]             } [EOL]         } [EOL]         JavaType contentType = type.getContentType(); [EOL]         if (contentType.getValueHandler() == null) { [EOL]             Object cdDef = intr.findContentDeserializer(a); [EOL]             JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef); [EOL]             if (cd != null) { [EOL]                 type = (T) type.withContentValueHandler(cd); [EOL]             } [EOL]         } [EOL]     } [EOL]     return type; [EOL] }
protected JavaType resolveType(DeserializationContext ctxt, BeanDescription beanDesc, JavaType type, AnnotatedMember member) throws JsonMappingException { [EOL]     if (type.isContainerType()) { [EOL]         AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]         JavaType keyType = type.getKeyType(); [EOL]         if (keyType != null) { [EOL]             Object kdDef = intr.findKeyDeserializer(member); [EOL]             KeyDeserializer kd = ctxt.keyDeserializerInstance(member, kdDef); [EOL]             if (kd != null) { [EOL]                 type = ((MapLikeType) type).withKeyValueHandler(kd); [EOL]                 keyType = type.getKeyType(); [EOL]             } [EOL]         } [EOL]         Object cdDef = intr.findContentDeserializer(member); [EOL]         JsonDeserializer<?> cd = ctxt.deserializerInstance(member, cdDef); [EOL]         if (cd != null) { [EOL]             type = type.withContentValueHandler(cd); [EOL]         } [EOL]         if (member instanceof AnnotatedMember) { [EOL]             TypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(ctxt.getConfig(), type, (AnnotatedMember) member); [EOL]             if (contentTypeDeser != null) { [EOL]                 type = type.withContentTypeHandler(contentTypeDeser); [EOL]             } [EOL]         } [EOL]     } [EOL]     TypeDeserializer valueTypeDeser; [EOL]     if (member instanceof AnnotatedMember) { [EOL]         valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(), type, (AnnotatedMember) member); [EOL]     } else { [EOL]         valueTypeDeser = findTypeDeserializer(ctxt.getConfig(), type); [EOL]     } [EOL]     if (valueTypeDeser != null) { [EOL]         type = type.withTypeHandler(valueTypeDeser); [EOL]     } [EOL]     return type; [EOL] }
public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final boolean wrap; [EOL]     if (value == null) { [EOL]         ser = getDefaultNullValueSerializer(); [EOL]         wrap = false; [EOL]     } else { [EOL]         if (rootType != null) { [EOL]             if (!rootType.getRawClass().isAssignableFrom(value.getClass())) { [EOL]                 _reportIncompatibleRootType(value, rootType); [EOL]             } [EOL]         } [EOL]         if (ser == null) { [EOL]             ser = findTypedValueSerializer(rootType, true, null); [EOL]         } [EOL]         wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE); [EOL]         if (wrap) { [EOL]             jgen.writeStartObject(); [EOL]             jgen.writeFieldName(_rootNames.findRootName(rootType, _config)); [EOL]         } [EOL]     } [EOL]     try { [EOL]         ser.serialize(value, jgen, this); [EOL]         if (wrap) { [EOL]             jgen.writeEndObject(); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         String msg = e.getMessage(); [EOL]         if (msg == null) { [EOL]             msg = "[no message for " + e.getClass().getName() + "]"; [EOL]         } [EOL]         throw new JsonMappingException(msg, e); [EOL]     } [EOL] }
public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final boolean wrap; [EOL]     if (value == null) { [EOL]         ser = getDefaultNullValueSerializer(); [EOL]         wrap = false; [EOL]     } else { [EOL]         if (rootType != null) { [EOL]             if (!rootType.getRawClass().isAssignableFrom(value.getClass())) { [EOL]                 _reportIncompatibleRootType(value, rootType); [EOL]             } [EOL]         } [EOL]         if (ser == null) { [EOL]             ser = findTypedValueSerializer(rootType, true, null); [EOL]         } [EOL]         wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE); [EOL]         if (wrap) { [EOL]             jgen.writeStartObject(); [EOL]             jgen.writeFieldName(_rootNames.findRootName(rootType, _config)); [EOL]         } [EOL]     } [EOL]     try { [EOL]         ser.serialize(value, jgen, this); [EOL]         if (wrap) { [EOL]             jgen.writeEndObject(); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         String msg = e.getMessage(); [EOL]         if (msg == null) { [EOL]             msg = "[no message for " + e.getClass().getName() + "]"; [EOL]         } [EOL]         throw new JsonMappingException(msg, e); [EOL]     } [EOL] }
public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final boolean wrap; [EOL]     if (value == null) { [EOL]         ser = getDefaultNullValueSerializer(); [EOL]         wrap = false; [EOL]     } else { [EOL]         if (rootType != null) { [EOL]             if (!rootType.getRawClass().isAssignableFrom(value.getClass())) { [EOL]                 _reportIncompatibleRootType(value, rootType); [EOL]             } [EOL]         } [EOL]         if (ser == null) { [EOL]             ser = findTypedValueSerializer(rootType, true, null); [EOL]         } [EOL]         wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE); [EOL]         if (wrap) { [EOL]             jgen.writeStartObject(); [EOL]             jgen.writeFieldName(_rootNames.findRootName(rootType, _config)); [EOL]         } [EOL]     } [EOL]     try { [EOL]         ser.serialize(value, jgen, this); [EOL]         if (wrap) { [EOL]             jgen.writeEndObject(); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         String msg = e.getMessage(); [EOL]         if (msg == null) { [EOL]             msg = "[no message for " + e.getClass().getName() + "]"; [EOL]         } [EOL]         throw new JsonMappingException(msg, e); [EOL]     } [EOL] }
public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final boolean wrap; [EOL]     if (value == null) { [EOL]         ser = getDefaultNullValueSerializer(); [EOL]         wrap = false; [EOL]     } else { [EOL]         if (rootType != null) { [EOL]             if (!rootType.getRawClass().isAssignableFrom(value.getClass())) { [EOL]                 _reportIncompatibleRootType(value, rootType); [EOL]             } [EOL]         } [EOL]         if (ser == null) { [EOL]             ser = findTypedValueSerializer(rootType, true, null); [EOL]         } [EOL]         wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE); [EOL]         if (wrap) { [EOL]             jgen.writeStartObject(); [EOL]             jgen.writeFieldName(_rootNames.findRootName(rootType, _config)); [EOL]         } [EOL]     } [EOL]     try { [EOL]         ser.serialize(value, jgen, this); [EOL]         if (wrap) { [EOL]             jgen.writeEndObject(); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw ioe; [EOL]     } catch (Exception e) { [EOL]         String msg = e.getMessage(); [EOL]         if (msg == null) { [EOL]             msg = "[no message for " + e.getClass().getName() + "]"; [EOL]         } [EOL]         throw new JsonMappingException(msg, e); [EOL]     } [EOL] }
@Override [EOL] public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         if (_vanillaProcessing) { [EOL]             return vanillaDeserialize(jp, ctxt, jp.nextToken()); [EOL]         } [EOL]         jp.nextToken(); [EOL]         if (_objectIdReader != null) { [EOL]             return deserializeWithObjectId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObject(jp, ctxt); [EOL]     } [EOL]     return _deserializeOther(jp, ctxt, t); [EOL] }
@Override [EOL] public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         if (_vanillaProcessing) { [EOL]             return vanillaDeserialize(jp, ctxt, jp.nextToken()); [EOL]         } [EOL]         jp.nextToken(); [EOL]         if (_objectIdReader != null) { [EOL]             return deserializeWithObjectId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObject(jp, ctxt); [EOL]     } [EOL]     return _deserializeOther(jp, ctxt, t); [EOL] }
@Override [EOL] public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         if (_vanillaProcessing) { [EOL]             return vanillaDeserialize(jp, ctxt, jp.nextToken()); [EOL]         } [EOL]         jp.nextToken(); [EOL]         if (_objectIdReader != null) { [EOL]             return deserializeWithObjectId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObject(jp, ctxt); [EOL]     } [EOL]     return _deserializeOther(jp, ctxt, t); [EOL] }
@Override [EOL] public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         if (_vanillaProcessing) { [EOL]             return vanillaDeserialize(jp, ctxt, jp.nextToken()); [EOL]         } [EOL]         jp.nextToken(); [EOL]         if (_objectIdReader != null) { [EOL]             return deserializeWithObjectId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObject(jp, ctxt); [EOL]     } [EOL]     return _deserializeOther(jp, ctxt, t); [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt, JsonToken t) throws IOException, JsonProcessingException { [EOL]     if (t == null) { [EOL]         return _missingToken(jp, ctxt); [EOL]     } [EOL]     switch(t) { [EOL]         case VALUE_STRING: [EOL]             return deserializeFromString(jp, ctxt); [EOL]         case VALUE_NUMBER_INT: [EOL]             return deserializeFromNumber(jp, ctxt); [EOL]         case VALUE_NUMBER_FLOAT: [EOL]             return deserializeFromDouble(jp, ctxt); [EOL]         case VALUE_EMBEDDED_OBJECT: [EOL]             return jp.getEmbeddedObject(); [EOL]         case VALUE_TRUE: [EOL]         case VALUE_FALSE: [EOL]             return deserializeFromBoolean(jp, ctxt); [EOL]         case START_ARRAY: [EOL]             return deserializeFromArray(jp, ctxt); [EOL]         case FIELD_NAME: [EOL]         case END_OBJECT: [EOL]             if (_vanillaProcessing) { [EOL]                 return vanillaDeserialize(jp, ctxt, t); [EOL]             } [EOL]             if (_objectIdReader != null) { [EOL]                 return deserializeWithObjectId(jp, ctxt); [EOL]             } [EOL]             return deserializeFromObject(jp, ctxt); [EOL]         default: [EOL]             throw ctxt.mappingException(getBeanClass()); [EOL]     } [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_nonStandardCreation) { [EOL]         if (_unwrappedPropertyHandler != null) { [EOL]             return deserializeWithUnwrapped(jp, ctxt); [EOL]         } [EOL]         if (_externalTypeIdHandler != null) { [EOL]             return deserializeWithExternalTypeId(jp, ctxt); [EOL]         } [EOL]         return deserializeFromObjectUsingNonDefault(jp, ctxt); [EOL]     } [EOL]     final Object bean = _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_injectables != null) { [EOL]         injectValues(ctxt, bean); [EOL]     } [EOL]     if (_needViewProcesing) { [EOL]         Class<?> view = ctxt.getActiveView(); [EOL]         if (view != null) { [EOL]             return deserializeWithView(jp, ctxt, bean, view); [EOL]         } [EOL]     } [EOL]     for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             try { [EOL]                 prop.deserializeAndSet(jp, ctxt, bean); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]         } else if (_anySetter != null) { [EOL]             try { [EOL]                 _anySetter.deserializeAndSet(jp, ctxt, bean, propName); [EOL]             } catch (Exception e) { [EOL]                 wrapAndThrow(e, bean, propName, ctxt); [EOL]             } [EOL]             continue; [EOL]         } else { [EOL]             handleUnknownProperty(jp, ctxt, bean, propName); [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
@Override [EOL] protected Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     final PropertyBasedCreator creator = _propertyBasedCreator; [EOL]     PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader); [EOL]     TokenBuffer unknown = null; [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); [EOL]         if (creatorProp != null) { [EOL]             Object value = creatorProp.deserialize(jp, ctxt); [EOL]             if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) { [EOL]                 jp.nextToken(); [EOL]                 Object bean; [EOL]                 try { [EOL]                     bean = creator.build(ctxt, buffer); [EOL]                 } catch (Exception e) { [EOL]                     wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); [EOL]                     bean = null; [EOL]                 } [EOL]                 if (bean.getClass() != _beanType.getRawClass()) { [EOL]                     return handlePolymorphic(jp, ctxt, bean, unknown); [EOL]                 } [EOL]                 if (unknown != null) { [EOL]                     bean = handleUnknownProperties(ctxt, bean, unknown); [EOL]                 } [EOL]                 return deserialize(jp, ctxt, bean); [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (buffer.readIdProperty(propName)) { [EOL]             continue; [EOL]         } [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             buffer.bufferProperty(prop, prop.deserialize(jp, ctxt)); [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt)); [EOL]             continue; [EOL]         } [EOL]         if (unknown == null) { [EOL]             unknown = new TokenBuffer(jp.getCodec()); [EOL]         } [EOL]         unknown.writeFieldName(propName); [EOL]         unknown.copyCurrentStructure(jp); [EOL]     } [EOL]     Object bean; [EOL]     try { [EOL]         bean = creator.build(ctxt, buffer); [EOL]     } catch (Exception e) { [EOL]         wrapInstantiationProblem(e, ctxt); [EOL]         bean = null; [EOL]     } [EOL]     if (unknown != null) { [EOL]         if (bean.getClass() != _beanType.getRawClass()) { [EOL]             return handlePolymorphic(null, ctxt, bean, unknown); [EOL]         } [EOL]         return handleUnknownProperties(ctxt, bean, unknown); [EOL]     } [EOL]     return bean; [EOL] }
@SuppressWarnings("resource") [EOL] protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     final ExternalTypeHandler ext = _externalTypeIdHandler.start(); [EOL]     final PropertyBasedCreator creator = _propertyBasedCreator; [EOL]     PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader); [EOL]     TokenBuffer tokens = new TokenBuffer(jp.getCodec()); [EOL]     tokens.writeStartObject(); [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         jp.nextToken(); [EOL]         SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); [EOL]         if (creatorProp != null) { [EOL]             if (ext.handlePropertyValue(jp, ctxt, propName, buffer)) { [EOL]                 ; [EOL]             } else { [EOL]                 Object value = creatorProp.deserialize(jp, ctxt); [EOL]                 if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) { [EOL]                     t = jp.nextToken(); [EOL]                     Object bean; [EOL]                     try { [EOL]                         bean = creator.build(ctxt, buffer); [EOL]                     } catch (Exception e) { [EOL]                         wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); [EOL]                         continue; [EOL]                     } [EOL]                     while (t == JsonToken.FIELD_NAME) { [EOL]                         jp.nextToken(); [EOL]                         tokens.copyCurrentStructure(jp); [EOL]                         t = jp.nextToken(); [EOL]                     } [EOL]                     if (bean.getClass() != _beanType.getRawClass()) { [EOL]                         throw ctxt.mappingException("Can not create polymorphic instances with unwrapped values"); [EOL]                     } [EOL]                     return ext.complete(jp, ctxt, bean); [EOL]                 } [EOL]             } [EOL]             continue; [EOL]         } [EOL]         if (buffer.readIdProperty(propName)) { [EOL]             continue; [EOL]         } [EOL]         SettableBeanProperty prop = _beanProperties.find(propName); [EOL]         if (prop != null) { [EOL]             buffer.bufferProperty(prop, prop.deserialize(jp, ctxt)); [EOL]             continue; [EOL]         } [EOL]         if (ext.handlePropertyValue(jp, ctxt, propName, null)) { [EOL]             continue; [EOL]         } [EOL]         if (_ignorableProps != null && _ignorableProps.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         if (_anySetter != null) { [EOL]             buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt)); [EOL]         } [EOL]     } [EOL]     try { [EOL]         return ext.complete(jp, ctxt, buffer, creator); [EOL]     } catch (Exception e) { [EOL]         wrapInstantiationProblem(e, ctxt); [EOL]         return null; [EOL]     } [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             Boolean serializeAsIndex = _isShapeWrittenUsingIndex(property.getType().getRawClass(), format, false); [EOL]             if (serializeAsIndex != _serializeAsIndex) { [EOL]                 return new EnumSerializer(_values, serializeAsIndex); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             Boolean serializeAsIndex = _isShapeWrittenUsingIndex(property.getType().getRawClass(), format, false); [EOL]             if (serializeAsIndex != _serializeAsIndex) { [EOL]                 return new EnumSerializer(_values, serializeAsIndex); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             Boolean serializeAsIndex = _isShapeWrittenUsingIndex(property.getType().getRawClass(), format, false); [EOL]             if (serializeAsIndex != _serializeAsIndex) { [EOL]                 return new EnumSerializer(_values, serializeAsIndex); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException { [EOL]     if (property != null) { [EOL]         JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat((Annotated) property.getMember()); [EOL]         if (format != null) { [EOL]             Boolean serializeAsIndex = _isShapeWrittenUsingIndex(property.getType().getRawClass(), format, false); [EOL]             if (serializeAsIndex != _serializeAsIndex) { [EOL]                 return new EnumSerializer(_values, serializeAsIndex); [EOL]             } [EOL]         } [EOL]     } [EOL]     return this; [EOL] }
@Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) { [EOL]     if (_serializeAsIndex(provider)) { [EOL]         return createSchemaNode("integer", true); [EOL]     } [EOL]     ObjectNode objectNode = createSchemaNode("string", true); [EOL]     if (typeHint != null) { [EOL]         JavaType type = provider.constructType(typeHint); [EOL]         if (type.isEnumType()) { [EOL]             ArrayNode enumNode = objectNode.putArray("enum"); [EOL]             for (SerializedString value : _values.values()) { [EOL]                 enumNode.add(value.getValue()); [EOL]             } [EOL]         } [EOL]     } [EOL]     return objectNode; [EOL] }
@Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) { [EOL]     if (_serializeAsIndex(provider)) { [EOL]         return createSchemaNode("integer", true); [EOL]     } [EOL]     ObjectNode objectNode = createSchemaNode("string", true); [EOL]     if (typeHint != null) { [EOL]         JavaType type = provider.constructType(typeHint); [EOL]         if (type.isEnumType()) { [EOL]             ArrayNode enumNode = objectNode.putArray("enum"); [EOL]             for (SerializedString value : _values.values()) { [EOL]                 enumNode.add(value.getValue()); [EOL]             } [EOL]         } [EOL]     } [EOL]     return objectNode; [EOL] }
@Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) { [EOL]     if (_serializeAsIndex(provider)) { [EOL]         return createSchemaNode("integer", true); [EOL]     } [EOL]     ObjectNode objectNode = createSchemaNode("string", true); [EOL]     if (typeHint != null) { [EOL]         JavaType type = provider.constructType(typeHint); [EOL]         if (type.isEnumType()) { [EOL]             ArrayNode enumNode = objectNode.putArray("enum"); [EOL]             for (SerializedString value : _values.values()) { [EOL]                 enumNode.add(value.getValue()); [EOL]             } [EOL]         } [EOL]     } [EOL]     return objectNode; [EOL] }
protected final boolean _serializeAsIndex(SerializerProvider provider) { [EOL]     if (_serializeAsIndex != null) { [EOL]         return _serializeAsIndex.booleanValue(); [EOL]     } [EOL]     return provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX); [EOL] }
protected final boolean _serializeAsIndex(SerializerProvider provider) { [EOL]     if (_serializeAsIndex != null) { [EOL]         return _serializeAsIndex.booleanValue(); [EOL]     } [EOL]     return provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX); [EOL] }
protected static Boolean _isShapeWrittenUsingIndex(Class<?> enumClass, JsonFormat.Value format, boolean fromClass) { [EOL]     JsonFormat.Shape shape = (format == null) ? null : format.getShape(); [EOL]     if (shape == null) { [EOL]         return null; [EOL]     } [EOL]     if (shape == Shape.ANY || shape == Shape.SCALAR) { [EOL]         return null; [EOL]     } [EOL]     if (shape == Shape.STRING) { [EOL]         return Boolean.FALSE; [EOL]     } [EOL]     if (shape.isNumeric()) { [EOL]         return Boolean.TRUE; [EOL]     } [EOL]     throw new IllegalArgumentException("Unsupported serialization shape (" + shape + ") for Enum " + enumClass.getName() + ", not supported as " + (fromClass ? "class" : "property") + " annotation"); [EOL] }
public void resetTyped(Class<?> cls) { [EOL]     _type = null; [EOL]     _class = cls; [EOL]     _isTyped = true; [EOL]     _hashCode = hash(cls, true); [EOL] }
public void resetTyped(JavaType type) { [EOL]     _type = type; [EOL]     _class = null; [EOL]     _isTyped = true; [EOL]     _hashCode = hash(type, true); [EOL] }
public void resetTyped(JavaType type) { [EOL]     _type = type; [EOL]     _class = null; [EOL]     _isTyped = true; [EOL]     _hashCode = hash(type, true); [EOL] }
public BeanPropertyMap renameAll(NameTransformer transformer) { [EOL]     if (transformer == null || (transformer == NameTransformer.NOP)) { [EOL]         return this; [EOL]     } [EOL]     Iterator<SettableBeanProperty> it = iterator(); [EOL]     ArrayList<SettableBeanProperty> newProps = new ArrayList<SettableBeanProperty>(); [EOL]     while (it.hasNext()) { [EOL]         SettableBeanProperty prop = it.next(); [EOL]         String newName = transformer.transform(prop.getName()); [EOL]         prop = prop.withName(newName); [EOL]         JsonDeserializer<?> deser = prop.getValueDeserializer(); [EOL]         if (deser != null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             JsonDeserializer<Object> newDeser = (JsonDeserializer<Object>) deser.unwrappingDeserializer(transformer); [EOL]             if (newDeser != deser) { [EOL]                 prop = prop.withValueDeserializer(newDeser); [EOL]             } [EOL]         } [EOL]         newProps.add(prop); [EOL]     } [EOL]     return new BeanPropertyMap(newProps); [EOL] }
public BeanPropertyMap renameAll(NameTransformer transformer) { [EOL]     if (transformer == null || (transformer == NameTransformer.NOP)) { [EOL]         return this; [EOL]     } [EOL]     Iterator<SettableBeanProperty> it = iterator(); [EOL]     ArrayList<SettableBeanProperty> newProps = new ArrayList<SettableBeanProperty>(); [EOL]     while (it.hasNext()) { [EOL]         SettableBeanProperty prop = it.next(); [EOL]         String newName = transformer.transform(prop.getName()); [EOL]         prop = prop.withName(newName); [EOL]         JsonDeserializer<?> deser = prop.getValueDeserializer(); [EOL]         if (deser != null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             JsonDeserializer<Object> newDeser = (JsonDeserializer<Object>) deser.unwrappingDeserializer(transformer); [EOL]             if (newDeser != deser) { [EOL]                 prop = prop.withValueDeserializer(newDeser); [EOL]             } [EOL]         } [EOL]         newProps.add(prop); [EOL]     } [EOL]     return new BeanPropertyMap(newProps); [EOL] }
public BeanPropertyMap renameAll(NameTransformer transformer) { [EOL]     if (transformer == null || (transformer == NameTransformer.NOP)) { [EOL]         return this; [EOL]     } [EOL]     Iterator<SettableBeanProperty> it = iterator(); [EOL]     ArrayList<SettableBeanProperty> newProps = new ArrayList<SettableBeanProperty>(); [EOL]     while (it.hasNext()) { [EOL]         SettableBeanProperty prop = it.next(); [EOL]         String newName = transformer.transform(prop.getName()); [EOL]         prop = prop.withName(newName); [EOL]         JsonDeserializer<?> deser = prop.getValueDeserializer(); [EOL]         if (deser != null) { [EOL]             @SuppressWarnings("unchecked") [EOL]             JsonDeserializer<Object> newDeser = (JsonDeserializer<Object>) deser.unwrappingDeserializer(transformer); [EOL]             if (newDeser != deser) { [EOL]                 prop = prop.withValueDeserializer(newDeser); [EOL]             } [EOL]         } [EOL]         newProps.add(prop); [EOL]     } [EOL]     return new BeanPropertyMap(newProps); [EOL] }
public void remove(SettableBeanProperty property) { [EOL]     String name = property.getName(); [EOL]     int index = name.hashCode() & (_buckets.length - 1); [EOL]     Bucket tail = null; [EOL]     boolean found = false; [EOL]     for (Bucket bucket = _buckets[index]; bucket != null; bucket = bucket.next) { [EOL]         if (!found && bucket.key.equals(name)) { [EOL]             found = true; [EOL]         } else { [EOL]             tail = new Bucket(tail, bucket.key, bucket.value, bucket.index); [EOL]         } [EOL]     } [EOL]     if (!found) { [EOL]         throw new NoSuchElementException("No entry '" + property + "' found, can't remove"); [EOL]     } [EOL]     _buckets[index] = tail; [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
public static JsonDeserializer<?> forType(Class<?> rawType) { [EOL]     if (rawType == Integer.TYPE) { [EOL]         return IntDeser.instance; [EOL]     } [EOL]     if (rawType == Long.TYPE) { [EOL]         return LongDeser.instance; [EOL]     } [EOL]     if (rawType == Byte.TYPE) { [EOL]         return new ByteDeser(); [EOL]     } [EOL]     if (rawType == Short.TYPE) { [EOL]         return new ShortDeser(); [EOL]     } [EOL]     if (rawType == Float.TYPE) { [EOL]         return new FloatDeser(); [EOL]     } [EOL]     if (rawType == Double.TYPE) { [EOL]         return new DoubleDeser(); [EOL]     } [EOL]     if (rawType == Boolean.TYPE) { [EOL]         return new BooleanDeser(); [EOL]     } [EOL]     if (rawType == Character.TYPE) { [EOL]         return new CharDeser(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     return typeDeserializer.deserializeTypedFromArray(jp, ctxt); [EOL] }
@Override [EOL] public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     return typeDeserializer.deserializeTypedFromArray(jp, ctxt); [EOL] }
public IntDeser() { [EOL]     super(int[].class); [EOL] }
@Override [EOL] public int[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.IntBuilder builder = ctxt.getArrayBuilders().getIntBuilder(); [EOL]     int[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         int value = _parseIntPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public int[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.IntBuilder builder = ctxt.getArrayBuilders().getIntBuilder(); [EOL]     int[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         int value = _parseIntPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public int[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.IntBuilder builder = ctxt.getArrayBuilders().getIntBuilder(); [EOL]     int[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         int value = _parseIntPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public int[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.IntBuilder builder = ctxt.getArrayBuilders().getIntBuilder(); [EOL]     int[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         int value = _parseIntPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public long[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.LongBuilder builder = ctxt.getArrayBuilders().getLongBuilder(); [EOL]     long[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         long value = _parseLongPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public long[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.LongBuilder builder = ctxt.getArrayBuilders().getLongBuilder(); [EOL]     long[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         long value = _parseLongPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public long[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.LongBuilder builder = ctxt.getArrayBuilders().getLongBuilder(); [EOL]     long[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         long value = _parseLongPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
@Override [EOL] public long[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         return handleNonArray(jp, ctxt); [EOL]     } [EOL]     ArrayBuilders.LongBuilder builder = ctxt.getArrayBuilders().getLongBuilder(); [EOL]     long[] chunk = builder.resetAndStart(); [EOL]     int ix = 0; [EOL]     while (jp.nextToken() != JsonToken.END_ARRAY) { [EOL]         long value = _parseLongPrimitive(jp, ctxt); [EOL]         if (ix >= chunk.length) { [EOL]             chunk = builder.appendCompletedChunk(chunk, ix); [EOL]             ix = 0; [EOL]         } [EOL]         chunk[ix++] = value; [EOL]     } [EOL]     return builder.completeAndClearBuffer(chunk, ix); [EOL] }
public PropertyValueBuffer(JsonParser jp, DeserializationContext ctxt, int paramCount, ObjectIdReader oir) { [EOL]     _parser = jp; [EOL]     _context = ctxt; [EOL]     _paramsNeeded = paramCount; [EOL]     _objectIdReader = oir; [EOL]     _creatorParameters = new Object[paramCount]; [EOL] }
protected final Object[] getParameters(Object[] defaults) { [EOL]     if (defaults != null) { [EOL]         for (int i = 0, len = _creatorParameters.length; i < len; ++i) { [EOL]             if (_creatorParameters[i] == null) { [EOL]                 Object value = defaults[i]; [EOL]                 if (value != null) { [EOL]                     _creatorParameters[i] = value; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _creatorParameters; [EOL] }
protected final Object[] getParameters(Object[] defaults) { [EOL]     if (defaults != null) { [EOL]         for (int i = 0, len = _creatorParameters.length; i < len; ++i) { [EOL]             if (_creatorParameters[i] == null) { [EOL]                 Object value = defaults[i]; [EOL]                 if (value != null) { [EOL]                     _creatorParameters[i] = value; [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     return _creatorParameters; [EOL] }
public boolean readIdProperty(String propName) throws IOException { [EOL]     if ((_objectIdReader != null) && propName.equals(_objectIdReader.propertyName)) { [EOL]         _idValue = _objectIdReader.deserializer.deserialize(_parser, _context); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public boolean readIdProperty(String propName) throws IOException { [EOL]     if ((_objectIdReader != null) && propName.equals(_objectIdReader.propertyName)) { [EOL]         _idValue = _objectIdReader.deserializer.deserialize(_parser, _context); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public boolean readIdProperty(String propName) throws IOException { [EOL]     if ((_objectIdReader != null) && propName.equals(_objectIdReader.propertyName)) { [EOL]         _idValue = _objectIdReader.deserializer.deserialize(_parser, _context); [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
public Object handleIdValue(final DeserializationContext ctxt, Object bean) throws IOException { [EOL]     if (_objectIdReader != null) { [EOL]         if (_idValue != null) { [EOL]             ReadableObjectId roid = ctxt.findObjectId(_idValue, _objectIdReader.generator); [EOL]             roid.bindItem(bean); [EOL]             SettableBeanProperty idProp = _objectIdReader.idProperty; [EOL]             if (idProp != null) { [EOL]                 return idProp.setAndReturn(bean, _idValue); [EOL]             } [EOL]         } else { [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
public Object handleIdValue(final DeserializationContext ctxt, Object bean) throws IOException { [EOL]     if (_objectIdReader != null) { [EOL]         if (_idValue != null) { [EOL]             ReadableObjectId roid = ctxt.findObjectId(_idValue, _objectIdReader.generator); [EOL]             roid.bindItem(bean); [EOL]             SettableBeanProperty idProp = _objectIdReader.idProperty; [EOL]             if (idProp != null) { [EOL]                 return idProp.setAndReturn(bean, _idValue); [EOL]             } [EOL]         } else { [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
public Object handleIdValue(final DeserializationContext ctxt, Object bean) throws IOException { [EOL]     if (_objectIdReader != null) { [EOL]         if (_idValue != null) { [EOL]             ReadableObjectId roid = ctxt.findObjectId(_idValue, _objectIdReader.generator); [EOL]             roid.bindItem(bean); [EOL]             SettableBeanProperty idProp = _objectIdReader.idProperty; [EOL]             if (idProp != null) { [EOL]                 return idProp.setAndReturn(bean, _idValue); [EOL]             } [EOL]         } else { [EOL]         } [EOL]     } [EOL]     return bean; [EOL] }
protected PropertyValue buffered() { [EOL]     return _buffered; [EOL] }
public boolean assignParameter(int index, Object value) { [EOL]     _creatorParameters[index] = value; [EOL]     return --_paramsNeeded <= 0; [EOL] }
public boolean assignParameter(int index, Object value) { [EOL]     _creatorParameters[index] = value; [EOL]     return --_paramsNeeded <= 0; [EOL] }
public boolean assignParameter(int index, Object value) { [EOL]     _creatorParameters[index] = value; [EOL]     return --_paramsNeeded <= 0; [EOL] }
public boolean assignParameter(int index, Object value) { [EOL]     _creatorParameters[index] = value; [EOL]     return --_paramsNeeded <= 0; [EOL] }
public boolean assignParameter(int index, Object value) { [EOL]     _creatorParameters[index] = value; [EOL]     return --_paramsNeeded <= 0; [EOL] }
public void bufferMapProperty(Object key, Object value) { [EOL]     _buffered = new PropertyValue.Map(_buffered, value, key); [EOL] }
public void bufferMapProperty(Object key, Object value) { [EOL]     _buffered = new PropertyValue.Map(_buffered, value, key); [EOL] }
public void bufferMapProperty(Object key, Object value) { [EOL]     _buffered = new PropertyValue.Map(_buffered, value, key); [EOL] }
public void bufferMapProperty(Object key, Object value) { [EOL]     _buffered = new PropertyValue.Map(_buffered, value, key); [EOL] }
public void serializeContentsUsing(List<?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Object elem = value.get(i); [EOL]         try { [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else if (typeSer == null) { [EOL]                 ser.serialize(elem, jgen, provider); [EOL]             } else { [EOL]                 ser.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } catch (Exception e) { [EOL]             wrapAndThrow(provider, e, value, i); [EOL]         } [EOL]     } [EOL] }
public void serializeContentsUsing(List<?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Object elem = value.get(i); [EOL]         try { [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else if (typeSer == null) { [EOL]                 ser.serialize(elem, jgen, provider); [EOL]             } else { [EOL]                 ser.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } catch (Exception e) { [EOL]             wrapAndThrow(provider, e, value, i); [EOL]         } [EOL]     } [EOL] }
public void serializeContentsUsing(List<?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Object elem = value.get(i); [EOL]         try { [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else if (typeSer == null) { [EOL]                 ser.serialize(elem, jgen, provider); [EOL]             } else { [EOL]                 ser.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } catch (Exception e) { [EOL]             wrapAndThrow(provider, e, value, i); [EOL]         } [EOL]     } [EOL] }
public void serializeContentsUsing(List<?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Object elem = value.get(i); [EOL]         try { [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else if (typeSer == null) { [EOL]                 ser.serialize(elem, jgen, provider); [EOL]             } else { [EOL]                 ser.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } catch (Exception e) { [EOL]             wrapAndThrow(provider, e, value, i); [EOL]         } [EOL]     } [EOL] }
public void serializeContentsUsing(List<?> value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser) throws IOException, JsonGenerationException { [EOL]     final int len = value.size(); [EOL]     if (len == 0) { [EOL]         return; [EOL]     } [EOL]     final TypeSerializer typeSer = _valueTypeSerializer; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         Object elem = value.get(i); [EOL]         try { [EOL]             if (elem == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else if (typeSer == null) { [EOL]                 ser.serialize(elem, jgen, provider); [EOL]             } else { [EOL]                 ser.serializeWithType(elem, jgen, provider, typeSer); [EOL]             } [EOL]         } catch (Exception e) { [EOL]             wrapAndThrow(provider, e, value, i); [EOL]         } [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] protected ObjectIdReader(JavaType t, String propName, ObjectIdGenerator<?> gen, JsonDeserializer<?> deser, SettableBeanProperty idProp) { [EOL]     idType = t; [EOL]     propertyName = propName; [EOL]     generator = gen; [EOL]     deserializer = (JsonDeserializer<Object>) deser; [EOL]     idProperty = idProp; [EOL] }
public static ObjectIdReader construct(JavaType idType, String propName, ObjectIdGenerator<?> generator, JsonDeserializer<?> deser, SettableBeanProperty idProp) { [EOL]     return new ObjectIdReader(idType, propName, generator, deser, idProp); [EOL] }
public static ObjectIdReader construct(JavaType idType, String propName, ObjectIdGenerator<?> generator, JsonDeserializer<?> deser, SettableBeanProperty idProp) { [EOL]     return new ObjectIdReader(idType, propName, generator, deser, idProp); [EOL] }
@Override [EOL] public AsArrayTypeSerializer forProperty(BeanProperty prop) { [EOL]     if (_property == prop) [EOL]         return this; [EOL]     return new AsArrayTypeSerializer(this._idResolver, prop); [EOL] }
@Override [EOL] public AsArrayTypeSerializer forProperty(BeanProperty prop) { [EOL]     if (_property == prop) [EOL]         return this; [EOL]     return new AsArrayTypeSerializer(this._idResolver, prop); [EOL] }
@Override [EOL] public void writeTypePrefixForScalar(Object value, JsonGenerator jgen, Class<?> type) throws IOException, JsonProcessingException { [EOL]     jgen.writeStartArray(); [EOL]     jgen.writeString(idFromValueAndType(value, type)); [EOL] }
@Override [EOL] public void writeTypePrefixForScalar(Object value, JsonGenerator jgen, Class<?> type) throws IOException, JsonProcessingException { [EOL]     jgen.writeStartArray(); [EOL]     jgen.writeString(idFromValueAndType(value, type)); [EOL] }
@Override [EOL] public void writeTypePrefixForScalar(Object value, JsonGenerator jgen, Class<?> type) throws IOException, JsonProcessingException { [EOL]     jgen.writeStartArray(); [EOL]     jgen.writeString(idFromValueAndType(value, type)); [EOL] }
protected ContainerNode(JsonNodeFactory nc) { [EOL]     _nodeFactory = nc; [EOL] }
public final ArrayNode arrayNode() { [EOL]     return _nodeFactory.arrayNode(); [EOL] }
public final ObjectNode objectNode() { [EOL]     return _nodeFactory.objectNode(); [EOL] }
@Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) { [EOL]     return createSchemaNode("string", true); [EOL] }
@Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) { [EOL]     return createSchemaNode("string", true); [EOL] }
@Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) { [EOL]     return createSchemaNode("string", true); [EOL] }
@Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) { [EOL]     return createSchemaNode("string", true); [EOL] }
public ObjectIdValueProperty(ObjectIdReader objectIdReader, boolean isRequired) { [EOL]     super(objectIdReader.propertyName, objectIdReader.idType, null, null, null, isRequired); [EOL]     _objectIdReader = objectIdReader; [EOL]     _valueDeserializer = objectIdReader.deserializer; [EOL] }
public ObjectIdValueProperty(ObjectIdReader objectIdReader, boolean isRequired) { [EOL]     super(objectIdReader.propertyName, objectIdReader.idType, null, null, null, isRequired); [EOL]     _objectIdReader = objectIdReader; [EOL]     _valueDeserializer = objectIdReader.deserializer; [EOL] }
@Override [EOL] public AnnotatedMember getMember() { [EOL]     return null; [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object intoValue) throws IOException, JsonProcessingException { [EOL]     return _deserializer.deserialize(jp, ctxt, intoValue); [EOL] }
@Override [EOL] public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object intoValue) throws IOException, JsonProcessingException { [EOL]     return _deserializer.deserialize(jp, ctxt, intoValue); [EOL] }
public CreatorProperty(String name, JavaType type, PropertyName wrapperName, TypeDeserializer typeDeser, Annotations contextAnnotations, AnnotatedParameter param, int index, Object injectableValueId, boolean isRequired) { [EOL]     super(name, type, wrapperName, typeDeser, contextAnnotations, isRequired); [EOL]     _annotated = param; [EOL]     _creatorIndex = index; [EOL]     _injectableValueId = injectableValueId; [EOL] }
public CreatorProperty(String name, JavaType type, PropertyName wrapperName, TypeDeserializer typeDeser, Annotations contextAnnotations, AnnotatedParameter param, int index, Object injectableValueId, boolean isRequired) { [EOL]     super(name, type, wrapperName, typeDeser, contextAnnotations, isRequired); [EOL]     _annotated = param; [EOL]     _creatorIndex = index; [EOL]     _injectableValueId = injectableValueId; [EOL] }
protected CreatorProperty(CreatorProperty src, JsonDeserializer<?> deser) { [EOL]     super(src, deser); [EOL]     _annotated = src._annotated; [EOL]     _creatorIndex = src._creatorIndex; [EOL]     _injectableValueId = src._injectableValueId; [EOL] }
protected CreatorProperty(CreatorProperty src, JsonDeserializer<?> deser) { [EOL]     super(src, deser); [EOL]     _annotated = src._annotated; [EOL]     _creatorIndex = src._creatorIndex; [EOL]     _injectableValueId = src._injectableValueId; [EOL] }
@Override [EOL] public CreatorProperty withValueDeserializer(JsonDeserializer<?> deser) { [EOL]     return new CreatorProperty(this, deser); [EOL] }
@Override [EOL] public CreatorProperty withValueDeserializer(JsonDeserializer<?> deser) { [EOL]     return new CreatorProperty(this, deser); [EOL] }
@Override [EOL] public <A extends Annotation> A getAnnotation(Class<A> acls) { [EOL]     if (_annotated == null) { [EOL]         return null; [EOL]     } [EOL]     return _annotated.getAnnotation(acls); [EOL] }
@Override [EOL] public <A extends Annotation> A getAnnotation(Class<A> acls) { [EOL]     if (_annotated == null) { [EOL]         return null; [EOL]     } [EOL]     return _annotated.getAnnotation(acls); [EOL] }
@Override [EOL] public int getCreatorIndex() { [EOL]     return _creatorIndex; [EOL] }
@Override [EOL] public Object getInjectableValueId() { [EOL]     return _injectableValueId; [EOL] }
@Override [EOL] public Object getInjectableValueId() { [EOL]     return _injectableValueId; [EOL] }
public NamedType(Class<?> c) { [EOL]     this(c, null); [EOL] }
public NamedType(Class<?> c) { [EOL]     this(c, null); [EOL] }
@SuppressWarnings("deprecation") [EOL] @Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException { [EOL]     ObjectNode o = createSchemaNode("array", true); [EOL]     if (typeHint != null) { [EOL]         JavaType javaType = provider.constructType(typeHint); [EOL]         if (javaType.isArrayType()) { [EOL]             Class<?> componentType = ((ArrayType) javaType).getContentType().getRawClass(); [EOL]             if (componentType == Object.class) { [EOL]                 o.put("items", com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode()); [EOL]             } else { [EOL]                 JsonSerializer<Object> ser = provider.findValueSerializer(componentType, _property); [EOL]                 JsonNode schemaNode = (ser instanceof SchemaAware) ? ((SchemaAware) ser).getSchema(provider, null) : com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); [EOL]                 o.put("items", schemaNode); [EOL]             } [EOL]         } [EOL]     } [EOL]     return o; [EOL] }
@SuppressWarnings("deprecation") [EOL] @Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException { [EOL]     ObjectNode o = createSchemaNode("array", true); [EOL]     if (typeHint != null) { [EOL]         JavaType javaType = provider.constructType(typeHint); [EOL]         if (javaType.isArrayType()) { [EOL]             Class<?> componentType = ((ArrayType) javaType).getContentType().getRawClass(); [EOL]             if (componentType == Object.class) { [EOL]                 o.put("items", com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode()); [EOL]             } else { [EOL]                 JsonSerializer<Object> ser = provider.findValueSerializer(componentType, _property); [EOL]                 JsonNode schemaNode = (ser instanceof SchemaAware) ? ((SchemaAware) ser).getSchema(provider, null) : com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); [EOL]                 o.put("items", schemaNode); [EOL]             } [EOL]         } [EOL]     } [EOL]     return o; [EOL] }
@SuppressWarnings("deprecation") [EOL] @Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException { [EOL]     ObjectNode o = createSchemaNode("array", true); [EOL]     if (typeHint != null) { [EOL]         JavaType javaType = provider.constructType(typeHint); [EOL]         if (javaType.isArrayType()) { [EOL]             Class<?> componentType = ((ArrayType) javaType).getContentType().getRawClass(); [EOL]             if (componentType == Object.class) { [EOL]                 o.put("items", com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode()); [EOL]             } else { [EOL]                 JsonSerializer<Object> ser = provider.findValueSerializer(componentType, _property); [EOL]                 JsonNode schemaNode = (ser instanceof SchemaAware) ? ((SchemaAware) ser).getSchema(provider, null) : com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); [EOL]                 o.put("items", schemaNode); [EOL]             } [EOL]         } [EOL]     } [EOL]     return o; [EOL] }
@SuppressWarnings("deprecation") [EOL] @Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException { [EOL]     ObjectNode o = createSchemaNode("array", true); [EOL]     if (typeHint != null) { [EOL]         JavaType javaType = provider.constructType(typeHint); [EOL]         if (javaType.isArrayType()) { [EOL]             Class<?> componentType = ((ArrayType) javaType).getContentType().getRawClass(); [EOL]             if (componentType == Object.class) { [EOL]                 o.put("items", com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode()); [EOL]             } else { [EOL]                 JsonSerializer<Object> ser = provider.findValueSerializer(componentType, _property); [EOL]                 JsonNode schemaNode = (ser instanceof SchemaAware) ? ((SchemaAware) ser).getSchema(provider, null) : com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); [EOL]                 o.put("items", schemaNode); [EOL]             } [EOL]         } [EOL]     } [EOL]     return o; [EOL] }
@SuppressWarnings("deprecation") [EOL] @Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException { [EOL]     ObjectNode o = createSchemaNode("array", true); [EOL]     if (typeHint != null) { [EOL]         JavaType javaType = provider.constructType(typeHint); [EOL]         if (javaType.isArrayType()) { [EOL]             Class<?> componentType = ((ArrayType) javaType).getContentType().getRawClass(); [EOL]             if (componentType == Object.class) { [EOL]                 o.put("items", com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode()); [EOL]             } else { [EOL]                 JsonSerializer<Object> ser = provider.findValueSerializer(componentType, _property); [EOL]                 JsonNode schemaNode = (ser instanceof SchemaAware) ? ((SchemaAware) ser).getSchema(provider, null) : com.fasterxml.jackson.databind.jsonschema.JsonSchema.getDefaultSchemaNode(); [EOL]                 o.put("items", schemaNode); [EOL]             } [EOL]         } [EOL]     } [EOL]     return o; [EOL] }
@Override [EOL] @SuppressWarnings("deprecation") [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException { [EOL]     ObjectNode objectNode = createObjectNode(); [EOL]     String schemaType = "any"; [EOL]     String objectProperties = null; [EOL]     String itemDefinition = null; [EOL]     if (typeHint != null) { [EOL]         Class<?> rawClass = TypeFactory.rawClass(typeHint); [EOL]         if (rawClass.isAnnotationPresent(JsonSerializableSchema.class)) { [EOL]             JsonSerializableSchema schemaInfo = rawClass.getAnnotation(JsonSerializableSchema.class); [EOL]             schemaType = schemaInfo.schemaType(); [EOL]             if (!JsonSerializableSchema.NO_VALUE.equals(schemaInfo.schemaObjectPropertiesDefinition())) { [EOL]                 objectProperties = schemaInfo.schemaObjectPropertiesDefinition(); [EOL]             } [EOL]             if (!JsonSerializableSchema.NO_VALUE.equals(schemaInfo.schemaItemDefinition())) { [EOL]                 itemDefinition = schemaInfo.schemaItemDefinition(); [EOL]             } [EOL]         } [EOL]     } [EOL]     objectNode.put("type", schemaType); [EOL]     if (objectProperties != null) { [EOL]         try { [EOL]             objectNode.put("properties", _getObjectMapper().readTree(objectProperties)); [EOL]         } catch (IOException e) { [EOL]             throw new JsonMappingException("Failed to parse @JsonSerializableSchema.schemaObjectPropertiesDefinition value"); [EOL]         } [EOL]     } [EOL]     if (itemDefinition != null) { [EOL]         try { [EOL]             objectNode.put("items", _getObjectMapper().readTree(itemDefinition)); [EOL]         } catch (IOException e) { [EOL]             throw new JsonMappingException("Failed to parse @JsonSerializableSchema.schemaItemDefinition value"); [EOL]         } [EOL]     } [EOL]     return objectNode; [EOL] }
@Override [EOL] @SuppressWarnings("deprecation") [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException { [EOL]     ObjectNode objectNode = createObjectNode(); [EOL]     String schemaType = "any"; [EOL]     String objectProperties = null; [EOL]     String itemDefinition = null; [EOL]     if (typeHint != null) { [EOL]         Class<?> rawClass = TypeFactory.rawClass(typeHint); [EOL]         if (rawClass.isAnnotationPresent(JsonSerializableSchema.class)) { [EOL]             JsonSerializableSchema schemaInfo = rawClass.getAnnotation(JsonSerializableSchema.class); [EOL]             schemaType = schemaInfo.schemaType(); [EOL]             if (!JsonSerializableSchema.NO_VALUE.equals(schemaInfo.schemaObjectPropertiesDefinition())) { [EOL]                 objectProperties = schemaInfo.schemaObjectPropertiesDefinition(); [EOL]             } [EOL]             if (!JsonSerializableSchema.NO_VALUE.equals(schemaInfo.schemaItemDefinition())) { [EOL]                 itemDefinition = schemaInfo.schemaItemDefinition(); [EOL]             } [EOL]         } [EOL]     } [EOL]     objectNode.put("type", schemaType); [EOL]     if (objectProperties != null) { [EOL]         try { [EOL]             objectNode.put("properties", _getObjectMapper().readTree(objectProperties)); [EOL]         } catch (IOException e) { [EOL]             throw new JsonMappingException("Failed to parse @JsonSerializableSchema.schemaObjectPropertiesDefinition value"); [EOL]         } [EOL]     } [EOL]     if (itemDefinition != null) { [EOL]         try { [EOL]             objectNode.put("items", _getObjectMapper().readTree(itemDefinition)); [EOL]         } catch (IOException e) { [EOL]             throw new JsonMappingException("Failed to parse @JsonSerializableSchema.schemaItemDefinition value"); [EOL]         } [EOL]     } [EOL]     return objectNode; [EOL] }
@Override [EOL] @SuppressWarnings("deprecation") [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException { [EOL]     ObjectNode objectNode = createObjectNode(); [EOL]     String schemaType = "any"; [EOL]     String objectProperties = null; [EOL]     String itemDefinition = null; [EOL]     if (typeHint != null) { [EOL]         Class<?> rawClass = TypeFactory.rawClass(typeHint); [EOL]         if (rawClass.isAnnotationPresent(JsonSerializableSchema.class)) { [EOL]             JsonSerializableSchema schemaInfo = rawClass.getAnnotation(JsonSerializableSchema.class); [EOL]             schemaType = schemaInfo.schemaType(); [EOL]             if (!JsonSerializableSchema.NO_VALUE.equals(schemaInfo.schemaObjectPropertiesDefinition())) { [EOL]                 objectProperties = schemaInfo.schemaObjectPropertiesDefinition(); [EOL]             } [EOL]             if (!JsonSerializableSchema.NO_VALUE.equals(schemaInfo.schemaItemDefinition())) { [EOL]                 itemDefinition = schemaInfo.schemaItemDefinition(); [EOL]             } [EOL]         } [EOL]     } [EOL]     objectNode.put("type", schemaType); [EOL]     if (objectProperties != null) { [EOL]         try { [EOL]             objectNode.put("properties", _getObjectMapper().readTree(objectProperties)); [EOL]         } catch (IOException e) { [EOL]             throw new JsonMappingException("Failed to parse @JsonSerializableSchema.schemaObjectPropertiesDefinition value"); [EOL]         } [EOL]     } [EOL]     if (itemDefinition != null) { [EOL]         try { [EOL]             objectNode.put("items", _getObjectMapper().readTree(itemDefinition)); [EOL]         } catch (IOException e) { [EOL]             throw new JsonMappingException("Failed to parse @JsonSerializableSchema.schemaItemDefinition value"); [EOL]         } [EOL]     } [EOL]     return objectNode; [EOL] }
@Override [EOL] @SuppressWarnings("deprecation") [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException { [EOL]     ObjectNode objectNode = createObjectNode(); [EOL]     String schemaType = "any"; [EOL]     String objectProperties = null; [EOL]     String itemDefinition = null; [EOL]     if (typeHint != null) { [EOL]         Class<?> rawClass = TypeFactory.rawClass(typeHint); [EOL]         if (rawClass.isAnnotationPresent(JsonSerializableSchema.class)) { [EOL]             JsonSerializableSchema schemaInfo = rawClass.getAnnotation(JsonSerializableSchema.class); [EOL]             schemaType = schemaInfo.schemaType(); [EOL]             if (!JsonSerializableSchema.NO_VALUE.equals(schemaInfo.schemaObjectPropertiesDefinition())) { [EOL]                 objectProperties = schemaInfo.schemaObjectPropertiesDefinition(); [EOL]             } [EOL]             if (!JsonSerializableSchema.NO_VALUE.equals(schemaInfo.schemaItemDefinition())) { [EOL]                 itemDefinition = schemaInfo.schemaItemDefinition(); [EOL]             } [EOL]         } [EOL]     } [EOL]     objectNode.put("type", schemaType); [EOL]     if (objectProperties != null) { [EOL]         try { [EOL]             objectNode.put("properties", _getObjectMapper().readTree(objectProperties)); [EOL]         } catch (IOException e) { [EOL]             throw new JsonMappingException("Failed to parse @JsonSerializableSchema.schemaObjectPropertiesDefinition value"); [EOL]         } [EOL]     } [EOL]     if (itemDefinition != null) { [EOL]         try { [EOL]             objectNode.put("items", _getObjectMapper().readTree(itemDefinition)); [EOL]         } catch (IOException e) { [EOL]             throw new JsonMappingException("Failed to parse @JsonSerializableSchema.schemaItemDefinition value"); [EOL]         } [EOL]     } [EOL]     return objectNode; [EOL] }
public ShortNode(short v) { [EOL]     _value = v; [EOL] }
public static ShortNode valueOf(short l) { [EOL]     return new ShortNode(l); [EOL] }
@Override [EOL] public JsonParser.NumberType numberType() { [EOL]     return JsonParser.NumberType.INT; [EOL] }
@Override [EOL] public boolean canConvertToInt() { [EOL]     return true; [EOL] }
@Override [EOL] public boolean canConvertToLong() { [EOL]     return true; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public int intValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public long longValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public double doubleValue() { [EOL]     return _value; [EOL] }
@Override [EOL] public BigDecimal decimalValue() { [EOL]     return BigDecimal.valueOf(_value); [EOL] }
@Override [EOL] public BigDecimal decimalValue() { [EOL]     return BigDecimal.valueOf(_value); [EOL] }
@Override [EOL] public BigDecimal decimalValue() { [EOL]     return BigDecimal.valueOf(_value); [EOL] }
@Override [EOL] public BigInteger bigIntegerValue() { [EOL]     return BigInteger.valueOf(_value); [EOL] }
@Override [EOL] public String asText() { [EOL]     return NumberOutput.toString(_value); [EOL] }
@Override [EOL] public String asText() { [EOL]     return NumberOutput.toString(_value); [EOL] }
@Override [EOL] public String asText() { [EOL]     return NumberOutput.toString(_value); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (o == this) [EOL]         return true; [EOL]     if (o == null) [EOL]         return false; [EOL]     if (o.getClass() != getClass()) { [EOL]         return false; [EOL]     } [EOL]     return ((ShortNode) o)._value == _value; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return _value; [EOL] }
public IteratorSerializer(IteratorSerializer src, BeanProperty property, TypeSerializer vts, JsonSerializer<?> valueSerializer) { [EOL]     super(src, property, vts, valueSerializer); [EOL] }
public IteratorSerializer(IteratorSerializer src, BeanProperty property, TypeSerializer vts, JsonSerializer<?> valueSerializer) { [EOL]     super(src, property, vts, valueSerializer); [EOL] }
@Override [EOL] public IteratorSerializer withResolved(BeanProperty property, TypeSerializer vts, JsonSerializer<?> elementSerializer) { [EOL]     return new IteratorSerializer(this, property, vts, elementSerializer); [EOL] }
public JsonSerializer<Object> typedValueSerializer(JavaType type) { [EOL]     if (_cacheKey == null) { [EOL]         _cacheKey = new TypeKey(type, true); [EOL]     } else { [EOL]         _cacheKey.resetTyped(type); [EOL]     } [EOL]     return _map.find(_cacheKey); [EOL] }
public JsonSerializer<Object> typedValueSerializer(JavaType type) { [EOL]     if (_cacheKey == null) { [EOL]         _cacheKey = new TypeKey(type, true); [EOL]     } else { [EOL]         _cacheKey.resetTyped(type); [EOL]     } [EOL]     return _map.find(_cacheKey); [EOL] }
public JsonSerializer<Object> typedValueSerializer(Class<?> cls) { [EOL]     if (_cacheKey == null) { [EOL]         _cacheKey = new TypeKey(cls, true); [EOL]     } else { [EOL]         _cacheKey.resetTyped(cls); [EOL]     } [EOL]     return _map.find(_cacheKey); [EOL] }
public JsonSerializer<Object> typedValueSerializer(Class<?> cls) { [EOL]     if (_cacheKey == null) { [EOL]         _cacheKey = new TypeKey(cls, true); [EOL]     } else { [EOL]         _cacheKey.resetTyped(cls); [EOL]     } [EOL]     return _map.find(_cacheKey); [EOL] }
protected BeanSerializerFactory(SerializerFactoryConfig config) { [EOL]     super(config); [EOL] }
@Override [EOL] public SerializerFactory withConfig(SerializerFactoryConfig config) { [EOL]     if (_factoryConfig == config) { [EOL]         return this; [EOL]     } [EOL]     if (getClass() != BeanSerializerFactory.class) { [EOL]         throw new IllegalStateException("Subtype of BeanSerializerFactory (" + getClass().getName() + ") has not properly overridden method 'withAdditionalSerializers': can not instantiate subtype with " + "additional serializer definitions"); [EOL]     } [EOL]     return new BeanSerializerFactory(config); [EOL] }
@Override [EOL] public SerializerFactory withConfig(SerializerFactoryConfig config) { [EOL]     if (_factoryConfig == config) { [EOL]         return this; [EOL]     } [EOL]     if (getClass() != BeanSerializerFactory.class) { [EOL]         throw new IllegalStateException("Subtype of BeanSerializerFactory (" + getClass().getName() + ") has not properly overridden method 'withAdditionalSerializers': can not instantiate subtype with " + "additional serializer definitions"); [EOL]     } [EOL]     return new BeanSerializerFactory(config); [EOL] }
@Override [EOL] public SerializerFactory withConfig(SerializerFactoryConfig config) { [EOL]     if (_factoryConfig == config) { [EOL]         return this; [EOL]     } [EOL]     if (getClass() != BeanSerializerFactory.class) { [EOL]         throw new IllegalStateException("Subtype of BeanSerializerFactory (" + getClass().getName() + ") has not properly overridden method 'withAdditionalSerializers': can not instantiate subtype with " + "additional serializer definitions"); [EOL]     } [EOL]     return new BeanSerializerFactory(config); [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException { [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     BeanDescription beanDesc = config.introspect(origType); [EOL]     JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo()); [EOL]     if (ser != null) { [EOL]         return (JsonSerializer<Object>) ser; [EOL]     } [EOL]     boolean staticTyping; [EOL]     JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType); [EOL]     if (type == origType) { [EOL]         staticTyping = false; [EOL]     } else { [EOL]         staticTyping = true; [EOL]         if (type.getRawClass() != origType.getRawClass()) { [EOL]             beanDesc = config.introspect(type); [EOL]         } [EOL]     } [EOL]     Converter<Object, Object> conv = beanDesc.findSerializationConverter(); [EOL]     if (conv == null) { [EOL]         return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping); [EOL]     } [EOL]     JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); [EOL]     return new StdDelegatingSerializer(conv, delegateType, _createSerializer2(prov, delegateType, beanDesc, true)); [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException { [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     BeanDescription beanDesc = config.introspect(origType); [EOL]     JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo()); [EOL]     if (ser != null) { [EOL]         return (JsonSerializer<Object>) ser; [EOL]     } [EOL]     boolean staticTyping; [EOL]     JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType); [EOL]     if (type == origType) { [EOL]         staticTyping = false; [EOL]     } else { [EOL]         staticTyping = true; [EOL]         if (type.getRawClass() != origType.getRawClass()) { [EOL]             beanDesc = config.introspect(type); [EOL]         } [EOL]     } [EOL]     Converter<Object, Object> conv = beanDesc.findSerializationConverter(); [EOL]     if (conv == null) { [EOL]         return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping); [EOL]     } [EOL]     JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); [EOL]     return new StdDelegatingSerializer(conv, delegateType, _createSerializer2(prov, delegateType, beanDesc, true)); [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public JsonSerializer<Object> createSerializer(SerializerProvider prov, JavaType origType) throws JsonMappingException { [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     BeanDescription beanDesc = config.introspect(origType); [EOL]     JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo()); [EOL]     if (ser != null) { [EOL]         return (JsonSerializer<Object>) ser; [EOL]     } [EOL]     boolean staticTyping; [EOL]     JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType); [EOL]     if (type == origType) { [EOL]         staticTyping = false; [EOL]     } else { [EOL]         staticTyping = true; [EOL]         if (type.getRawClass() != origType.getRawClass()) { [EOL]             beanDesc = config.introspect(type); [EOL]         } [EOL]     } [EOL]     Converter<Object, Object> conv = beanDesc.findSerializationConverter(); [EOL]     if (conv == null) { [EOL]         return (JsonSerializer<Object>) _createSerializer2(prov, type, beanDesc, staticTyping); [EOL]     } [EOL]     JavaType delegateType = conv.getOutputType(prov.getTypeFactory()); [EOL]     return new StdDelegatingSerializer(conv, delegateType, _createSerializer2(prov, delegateType, beanDesc, true)); [EOL] }
protected JsonSerializer<?> _createSerializer2(SerializerProvider prov, JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException { [EOL]     JsonSerializer<?> ser = findSerializerByAnnotations(prov, type, beanDesc); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     if (type.isContainerType()) { [EOL]         if (!staticTyping) { [EOL]             staticTyping = usesStaticTyping(config, beanDesc, null); [EOL]         } [EOL]         ser = buildContainerSerializer(prov, type, beanDesc, staticTyping); [EOL]         if (ser != null) { [EOL]             return ser; [EOL]         } [EOL]     } else { [EOL]         for (Serializers serializers : customSerializers()) { [EOL]             ser = serializers.findSerializer(config, type, beanDesc); [EOL]             if (ser != null) { [EOL]                 break; [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser == null) { [EOL]         ser = findSerializerByLookup(type, config, beanDesc, staticTyping); [EOL]         if (ser == null) { [EOL]             ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping); [EOL]             if (ser == null) { [EOL]                 ser = findBeanSerializer(prov, type, beanDesc); [EOL]                 if (ser == null) { [EOL]                     ser = findSerializerByAddonType(config, type, beanDesc, staticTyping); [EOL]                 } [EOL]             } [EOL]         } [EOL]     } [EOL]     if (ser != null) { [EOL]         if (_factoryConfig.hasSerializerModifiers()) { [EOL]             for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]                 ser = mod.modifySerializer(config, beanDesc, ser); [EOL]             } [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
public TypeSerializer findPropertyTypeSerializer(JavaType baseType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException { [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, accessor, baseType); [EOL]     if (b == null) { [EOL]         return createTypeSerializer(config, baseType); [EOL]     } [EOL]     Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(accessor, config, ai, baseType); [EOL]     return b.buildTypeSerializer(config, baseType, subtypes); [EOL] }
public TypeSerializer findPropertyTypeSerializer(JavaType baseType, SerializationConfig config, AnnotatedMember accessor) throws JsonMappingException { [EOL]     AnnotationIntrospector ai = config.getAnnotationIntrospector(); [EOL]     TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, accessor, baseType); [EOL]     if (b == null) { [EOL]         return createTypeSerializer(config, baseType); [EOL]     } [EOL]     Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(accessor, config, ai, baseType); [EOL]     return b.buildTypeSerializer(config, baseType, subtypes); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException { [EOL]     if (beanDesc.getBeanClass() == Object.class) { [EOL]         return prov.getUnknownTypeSerializer(Object.class); [EOL]     } [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc); [EOL]     builder.setConfig(config); [EOL]     List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder); [EOL]     if (props == null) { [EOL]         props = new ArrayList<BeanPropertyWriter>(); [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.changeProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     props = filterBeanProperties(config, beanDesc, props); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.orderProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props)); [EOL]     builder.setProperties(props); [EOL]     builder.setFilterId(findFilterId(config, beanDesc)); [EOL]     AnnotatedMember anyGetter = beanDesc.findAnyGetter(); [EOL]     if (anyGetter != null) { [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             anyGetter.fixAccess(); [EOL]         } [EOL]         JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType()); [EOL]         boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING); [EOL]         JavaType valueType = type.getContentType(); [EOL]         TypeSerializer typeSer = createTypeSerializer(config, valueType); [EOL]         MapSerializer mapSer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null); [EOL]         BeanProperty.Std anyProp = new BeanProperty.Std(anyGetter.getName(), valueType, null, beanDesc.getClassAnnotations(), anyGetter, false); [EOL]         builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, mapSer)); [EOL]     } [EOL]     processViews(config, builder); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             builder = mod.updateBuilder(config, beanDesc, builder); [EOL]         } [EOL]     } [EOL]     JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build(); [EOL]     if (ser == null) { [EOL]         if (beanDesc.hasKnownClassAnnotations()) { [EOL]             return builder.createDummy(); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException { [EOL]     if (beanDesc.getBeanClass() == Object.class) { [EOL]         return prov.getUnknownTypeSerializer(Object.class); [EOL]     } [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc); [EOL]     builder.setConfig(config); [EOL]     List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder); [EOL]     if (props == null) { [EOL]         props = new ArrayList<BeanPropertyWriter>(); [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.changeProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     props = filterBeanProperties(config, beanDesc, props); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.orderProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props)); [EOL]     builder.setProperties(props); [EOL]     builder.setFilterId(findFilterId(config, beanDesc)); [EOL]     AnnotatedMember anyGetter = beanDesc.findAnyGetter(); [EOL]     if (anyGetter != null) { [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             anyGetter.fixAccess(); [EOL]         } [EOL]         JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType()); [EOL]         boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING); [EOL]         JavaType valueType = type.getContentType(); [EOL]         TypeSerializer typeSer = createTypeSerializer(config, valueType); [EOL]         MapSerializer mapSer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null); [EOL]         BeanProperty.Std anyProp = new BeanProperty.Std(anyGetter.getName(), valueType, null, beanDesc.getClassAnnotations(), anyGetter, false); [EOL]         builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, mapSer)); [EOL]     } [EOL]     processViews(config, builder); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             builder = mod.updateBuilder(config, beanDesc, builder); [EOL]         } [EOL]     } [EOL]     JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build(); [EOL]     if (ser == null) { [EOL]         if (beanDesc.hasKnownClassAnnotations()) { [EOL]             return builder.createDummy(); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException { [EOL]     if (beanDesc.getBeanClass() == Object.class) { [EOL]         return prov.getUnknownTypeSerializer(Object.class); [EOL]     } [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc); [EOL]     builder.setConfig(config); [EOL]     List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder); [EOL]     if (props == null) { [EOL]         props = new ArrayList<BeanPropertyWriter>(); [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.changeProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     props = filterBeanProperties(config, beanDesc, props); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.orderProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props)); [EOL]     builder.setProperties(props); [EOL]     builder.setFilterId(findFilterId(config, beanDesc)); [EOL]     AnnotatedMember anyGetter = beanDesc.findAnyGetter(); [EOL]     if (anyGetter != null) { [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             anyGetter.fixAccess(); [EOL]         } [EOL]         JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType()); [EOL]         boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING); [EOL]         JavaType valueType = type.getContentType(); [EOL]         TypeSerializer typeSer = createTypeSerializer(config, valueType); [EOL]         MapSerializer mapSer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null); [EOL]         BeanProperty.Std anyProp = new BeanProperty.Std(anyGetter.getName(), valueType, null, beanDesc.getClassAnnotations(), anyGetter, false); [EOL]         builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, mapSer)); [EOL]     } [EOL]     processViews(config, builder); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             builder = mod.updateBuilder(config, beanDesc, builder); [EOL]         } [EOL]     } [EOL]     JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build(); [EOL]     if (ser == null) { [EOL]         if (beanDesc.hasKnownClassAnnotations()) { [EOL]             return builder.createDummy(); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected JsonSerializer<Object> constructBeanSerializer(SerializerProvider prov, BeanDescription beanDesc) throws JsonMappingException { [EOL]     if (beanDesc.getBeanClass() == Object.class) { [EOL]         return prov.getUnknownTypeSerializer(Object.class); [EOL]     } [EOL]     final SerializationConfig config = prov.getConfig(); [EOL]     BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc); [EOL]     builder.setConfig(config); [EOL]     List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder); [EOL]     if (props == null) { [EOL]         props = new ArrayList<BeanPropertyWriter>(); [EOL]     } [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.changeProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     props = filterBeanProperties(config, beanDesc, props); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             props = mod.orderProperties(config, beanDesc, props); [EOL]         } [EOL]     } [EOL]     builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc, props)); [EOL]     builder.setProperties(props); [EOL]     builder.setFilterId(findFilterId(config, beanDesc)); [EOL]     AnnotatedMember anyGetter = beanDesc.findAnyGetter(); [EOL]     if (anyGetter != null) { [EOL]         if (config.canOverrideAccessModifiers()) { [EOL]             anyGetter.fixAccess(); [EOL]         } [EOL]         JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType()); [EOL]         boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING); [EOL]         JavaType valueType = type.getContentType(); [EOL]         TypeSerializer typeSer = createTypeSerializer(config, valueType); [EOL]         MapSerializer mapSer = MapSerializer.construct(null, type, staticTyping, typeSer, null, null); [EOL]         BeanProperty.Std anyProp = new BeanProperty.Std(anyGetter.getName(), valueType, null, beanDesc.getClassAnnotations(), anyGetter, false); [EOL]         builder.setAnyGetter(new AnyGetterWriter(anyProp, anyGetter, mapSer)); [EOL]     } [EOL]     processViews(config, builder); [EOL]     if (_factoryConfig.hasSerializerModifiers()) { [EOL]         for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) { [EOL]             builder = mod.updateBuilder(config, beanDesc, builder); [EOL]         } [EOL]     } [EOL]     JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build(); [EOL]     if (ser == null) { [EOL]         if (beanDesc.hasKnownClassAnnotations()) { [EOL]             return builder.createDummy(); [EOL]         } [EOL]     } [EOL]     return ser; [EOL] }
protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov, BeanDescription beanDesc, List<BeanPropertyWriter> props) throws JsonMappingException { [EOL]     ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo(); [EOL]     if (objectIdInfo == null) { [EOL]         return null; [EOL]     } [EOL]     ObjectIdGenerator<?> gen; [EOL]     Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]     if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]         String propName = objectIdInfo.getPropertyName(); [EOL]         BeanPropertyWriter idProp = null; [EOL]         for (int i = 0, len = props.size(); ; ++i) { [EOL]             if (i == len) { [EOL]                 throw new IllegalArgumentException("Invalid Object Id definition for " + beanDesc.getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]             } [EOL]             BeanPropertyWriter prop = props.get(i); [EOL]             if (propName.equals(prop.getName())) { [EOL]                 idProp = prop; [EOL]                 if (i > 0) { [EOL]                     props.remove(i); [EOL]                     props.add(0, idProp); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         } [EOL]         JavaType idType = idProp.getType(); [EOL]         gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]         return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]     } [EOL]     JavaType type = prov.constructType(implClass); [EOL]     JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]     gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo); [EOL]     return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL] }
protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov, BeanDescription beanDesc, List<BeanPropertyWriter> props) throws JsonMappingException { [EOL]     ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo(); [EOL]     if (objectIdInfo == null) { [EOL]         return null; [EOL]     } [EOL]     ObjectIdGenerator<?> gen; [EOL]     Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]     if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]         String propName = objectIdInfo.getPropertyName(); [EOL]         BeanPropertyWriter idProp = null; [EOL]         for (int i = 0, len = props.size(); ; ++i) { [EOL]             if (i == len) { [EOL]                 throw new IllegalArgumentException("Invalid Object Id definition for " + beanDesc.getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]             } [EOL]             BeanPropertyWriter prop = props.get(i); [EOL]             if (propName.equals(prop.getName())) { [EOL]                 idProp = prop; [EOL]                 if (i > 0) { [EOL]                     props.remove(i); [EOL]                     props.add(0, idProp); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         } [EOL]         JavaType idType = idProp.getType(); [EOL]         gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]         return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]     } [EOL]     JavaType type = prov.constructType(implClass); [EOL]     JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]     gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo); [EOL]     return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL] }
protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov, BeanDescription beanDesc, List<BeanPropertyWriter> props) throws JsonMappingException { [EOL]     ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo(); [EOL]     if (objectIdInfo == null) { [EOL]         return null; [EOL]     } [EOL]     ObjectIdGenerator<?> gen; [EOL]     Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]     if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]         String propName = objectIdInfo.getPropertyName(); [EOL]         BeanPropertyWriter idProp = null; [EOL]         for (int i = 0, len = props.size(); ; ++i) { [EOL]             if (i == len) { [EOL]                 throw new IllegalArgumentException("Invalid Object Id definition for " + beanDesc.getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]             } [EOL]             BeanPropertyWriter prop = props.get(i); [EOL]             if (propName.equals(prop.getName())) { [EOL]                 idProp = prop; [EOL]                 if (i > 0) { [EOL]                     props.remove(i); [EOL]                     props.add(0, idProp); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         } [EOL]         JavaType idType = idProp.getType(); [EOL]         gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]         return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]     } [EOL]     JavaType type = prov.constructType(implClass); [EOL]     JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]     gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo); [EOL]     return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL] }
protected ObjectIdWriter constructObjectIdHandler(SerializerProvider prov, BeanDescription beanDesc, List<BeanPropertyWriter> props) throws JsonMappingException { [EOL]     ObjectIdInfo objectIdInfo = beanDesc.getObjectIdInfo(); [EOL]     if (objectIdInfo == null) { [EOL]         return null; [EOL]     } [EOL]     ObjectIdGenerator<?> gen; [EOL]     Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]     if (implClass == ObjectIdGenerators.PropertyGenerator.class) { [EOL]         String propName = objectIdInfo.getPropertyName(); [EOL]         BeanPropertyWriter idProp = null; [EOL]         for (int i = 0, len = props.size(); ; ++i) { [EOL]             if (i == len) { [EOL]                 throw new IllegalArgumentException("Invalid Object Id definition for " + beanDesc.getBeanClass().getName() + ": can not find property with name '" + propName + "'"); [EOL]             } [EOL]             BeanPropertyWriter prop = props.get(i); [EOL]             if (propName.equals(prop.getName())) { [EOL]                 idProp = prop; [EOL]                 if (i > 0) { [EOL]                     props.remove(i); [EOL]                     props.add(0, idProp); [EOL]                 } [EOL]                 break; [EOL]             } [EOL]         } [EOL]         JavaType idType = idProp.getType(); [EOL]         gen = new PropertyBasedObjectIdGenerator(objectIdInfo, idProp); [EOL]         return ObjectIdWriter.construct(idType, null, gen, objectIdInfo.getAlwaysAsId()); [EOL]     } [EOL]     JavaType type = prov.constructType(implClass); [EOL]     JavaType idType = prov.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0]; [EOL]     gen = prov.objectIdGeneratorInstance(beanDesc.getClassInfo(), objectIdInfo); [EOL]     return ObjectIdWriter.construct(idType, objectIdInfo.getPropertyName(), gen, objectIdInfo.getAlwaysAsId()); [EOL] }
protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties) { [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     HashMap<Class<?>, Boolean> ignores = new HashMap<Class<?>, Boolean>(); [EOL]     Iterator<BeanPropertyDefinition> it = properties.iterator(); [EOL]     while (it.hasNext()) { [EOL]         BeanPropertyDefinition property = it.next(); [EOL]         AnnotatedMember accessor = property.getAccessor(); [EOL]         if (accessor == null) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         Class<?> type = accessor.getRawType(); [EOL]         Boolean result = ignores.get(type); [EOL]         if (result == null) { [EOL]             BeanDescription desc = config.introspectClassAnnotations(type); [EOL]             AnnotatedClass ac = desc.getClassInfo(); [EOL]             result = intr.isIgnorableType(ac); [EOL]             if (result == null) { [EOL]                 result = Boolean.FALSE; [EOL]             } [EOL]             ignores.put(type, result); [EOL]         } [EOL]         if (result.booleanValue()) { [EOL]             it.remove(); [EOL]         } [EOL]     } [EOL] }
protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties) { [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     HashMap<Class<?>, Boolean> ignores = new HashMap<Class<?>, Boolean>(); [EOL]     Iterator<BeanPropertyDefinition> it = properties.iterator(); [EOL]     while (it.hasNext()) { [EOL]         BeanPropertyDefinition property = it.next(); [EOL]         AnnotatedMember accessor = property.getAccessor(); [EOL]         if (accessor == null) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         Class<?> type = accessor.getRawType(); [EOL]         Boolean result = ignores.get(type); [EOL]         if (result == null) { [EOL]             BeanDescription desc = config.introspectClassAnnotations(type); [EOL]             AnnotatedClass ac = desc.getClassInfo(); [EOL]             result = intr.isIgnorableType(ac); [EOL]             if (result == null) { [EOL]                 result = Boolean.FALSE; [EOL]             } [EOL]             ignores.put(type, result); [EOL]         } [EOL]         if (result.booleanValue()) { [EOL]             it.remove(); [EOL]         } [EOL]     } [EOL] }
protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties) { [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     HashMap<Class<?>, Boolean> ignores = new HashMap<Class<?>, Boolean>(); [EOL]     Iterator<BeanPropertyDefinition> it = properties.iterator(); [EOL]     while (it.hasNext()) { [EOL]         BeanPropertyDefinition property = it.next(); [EOL]         AnnotatedMember accessor = property.getAccessor(); [EOL]         if (accessor == null) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         Class<?> type = accessor.getRawType(); [EOL]         Boolean result = ignores.get(type); [EOL]         if (result == null) { [EOL]             BeanDescription desc = config.introspectClassAnnotations(type); [EOL]             AnnotatedClass ac = desc.getClassInfo(); [EOL]             result = intr.isIgnorableType(ac); [EOL]             if (result == null) { [EOL]                 result = Boolean.FALSE; [EOL]             } [EOL]             ignores.put(type, result); [EOL]         } [EOL]         if (result.booleanValue()) { [EOL]             it.remove(); [EOL]         } [EOL]     } [EOL] }
protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc, List<BeanPropertyDefinition> properties) { [EOL]     AnnotationIntrospector intr = config.getAnnotationIntrospector(); [EOL]     HashMap<Class<?>, Boolean> ignores = new HashMap<Class<?>, Boolean>(); [EOL]     Iterator<BeanPropertyDefinition> it = properties.iterator(); [EOL]     while (it.hasNext()) { [EOL]         BeanPropertyDefinition property = it.next(); [EOL]         AnnotatedMember accessor = property.getAccessor(); [EOL]         if (accessor == null) { [EOL]             it.remove(); [EOL]             continue; [EOL]         } [EOL]         Class<?> type = accessor.getRawType(); [EOL]         Boolean result = ignores.get(type); [EOL]         if (result == null) { [EOL]             BeanDescription desc = config.introspectClassAnnotations(type); [EOL]             AnnotatedClass ac = desc.getClassInfo(); [EOL]             result = intr.isIgnorableType(ac); [EOL]             if (result == null) { [EOL]                 result = Boolean.FALSE; [EOL]             } [EOL]             ignores.put(type, result); [EOL]         } [EOL]         if (result.booleanValue()) { [EOL]             it.remove(); [EOL]         } [EOL]     } [EOL] }
public ObjectIdGenerator<?> objectIdGeneratorInstance(Annotated annotated, ObjectIdInfo objectIdInfo) throws JsonMappingException { [EOL]     Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]     final MapperConfig<?> config = getConfig(); [EOL]     HandlerInstantiator hi = config.getHandlerInstantiator(); [EOL]     ObjectIdGenerator<?> gen = (hi == null) ? null : hi.objectIdGeneratorInstance(config, annotated, implClass); [EOL]     if (gen == null) { [EOL]         gen = (ObjectIdGenerator<?>) ClassUtil.createInstance(implClass, config.canOverrideAccessModifiers()); [EOL]     } [EOL]     return gen.forScope(objectIdInfo.getScope()); [EOL] }
public ObjectIdGenerator<?> objectIdGeneratorInstance(Annotated annotated, ObjectIdInfo objectIdInfo) throws JsonMappingException { [EOL]     Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]     final MapperConfig<?> config = getConfig(); [EOL]     HandlerInstantiator hi = config.getHandlerInstantiator(); [EOL]     ObjectIdGenerator<?> gen = (hi == null) ? null : hi.objectIdGeneratorInstance(config, annotated, implClass); [EOL]     if (gen == null) { [EOL]         gen = (ObjectIdGenerator<?>) ClassUtil.createInstance(implClass, config.canOverrideAccessModifiers()); [EOL]     } [EOL]     return gen.forScope(objectIdInfo.getScope()); [EOL] }
public ObjectIdGenerator<?> objectIdGeneratorInstance(Annotated annotated, ObjectIdInfo objectIdInfo) throws JsonMappingException { [EOL]     Class<?> implClass = objectIdInfo.getGeneratorType(); [EOL]     final MapperConfig<?> config = getConfig(); [EOL]     HandlerInstantiator hi = config.getHandlerInstantiator(); [EOL]     ObjectIdGenerator<?> gen = (hi == null) ? null : hi.objectIdGeneratorInstance(config, annotated, implClass); [EOL]     if (gen == null) { [EOL]         gen = (ObjectIdGenerator<?>) ClassUtil.createInstance(implClass, config.canOverrideAccessModifiers()); [EOL]     } [EOL]     return gen.forScope(objectIdInfo.getScope()); [EOL] }
@Override [EOL] public final Object call() throws Exception { [EOL]     return _constructor.newInstance(); [EOL] }
@Override [EOL] public final Object call() throws Exception { [EOL]     return _constructor.newInstance(); [EOL] }
public static ContainerSerializer<?> collectionSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { [EOL]     return new CollectionSerializer(elemType, staticTyping, vts, null, valueSerializer); [EOL] }
public static ContainerSerializer<?> collectionSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, JsonSerializer<Object> valueSerializer) { [EOL]     return new CollectionSerializer(elemType, staticTyping, vts, null, valueSerializer); [EOL] }
public static ContainerSerializer<?> iteratorSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts) { [EOL]     return new IteratorSerializer(elemType, staticTyping, vts, null); [EOL] }
public static ContainerSerializer<?> iteratorSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts) { [EOL]     return new IteratorSerializer(elemType, staticTyping, vts, null); [EOL] }
public static ContainerSerializer<?> iterableSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts) { [EOL]     return new IterableSerializer(elemType, staticTyping, vts, null); [EOL] }
public static ContainerSerializer<?> iterableSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts) { [EOL]     return new IterableSerializer(elemType, staticTyping, vts, null); [EOL] }
public static JsonSerializer<?> enumSetSerializer(JavaType enumType) { [EOL]     return new EnumSetSerializer(enumType, null); [EOL] }
public RawSerializer(Class<?> cls) { [EOL]     super(cls, false); [EOL] }
public RawSerializer(Class<?> cls) { [EOL]     super(cls, false); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType, String clsName) { [EOL]     if (rawType.isPrimitive()) { [EOL]         if (rawType == Integer.TYPE) { [EOL]             return IntegerDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Boolean.TYPE) { [EOL]             return BooleanDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Long.TYPE) { [EOL]             return LongDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Double.TYPE) { [EOL]             return DoubleDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Character.TYPE) { [EOL]             return CharacterDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Byte.TYPE) { [EOL]             return ByteDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Short.TYPE) { [EOL]             return ShortDeserializer.primitiveInstance; [EOL]         } [EOL]         if (rawType == Float.TYPE) { [EOL]             return FloatDeserializer.primitiveInstance; [EOL]         } [EOL]     } else if (_classNames.contains(clsName)) { [EOL]         if (rawType == Integer.class) { [EOL]             return IntegerDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Boolean.class) { [EOL]             return BooleanDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Long.class) { [EOL]             return LongDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Double.class) { [EOL]             return DoubleDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Character.class) { [EOL]             return CharacterDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Byte.class) { [EOL]             return ByteDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Short.class) { [EOL]             return ShortDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Float.class) { [EOL]             return FloatDeserializer.wrapperInstance; [EOL]         } [EOL]         if (rawType == Number.class) { [EOL]             return NumberDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigDecimal.class) { [EOL]             return BigDecimalDeserializer.instance; [EOL]         } [EOL]         if (rawType == BigInteger.class) { [EOL]             return BigIntegerDeserializer.instance; [EOL]         } [EOL]     } else { [EOL]         return null; [EOL]     } [EOL]     throw new IllegalArgumentException("Internal error: can't find deserializer for " + rawType.getName()); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.VALUE_NUMBER_INT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]             return jp.getBigIntegerValue(); [EOL]         } [EOL]         return jp.getNumberValue(); [EOL]     } else if (t == JsonToken.VALUE_NUMBER_FLOAT) { [EOL]         if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]             return jp.getDecimalValue(); [EOL]         } [EOL]         return Double.valueOf(jp.getDoubleValue()); [EOL]     } [EOL]     if (t == JsonToken.VALUE_STRING) { [EOL]         String text = jp.getText().trim(); [EOL]         try { [EOL]             if (text.indexOf('.') >= 0) { [EOL]                 if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) { [EOL]                     return new BigDecimal(text); [EOL]                 } [EOL]                 return new Double(text); [EOL]             } [EOL]             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) { [EOL]                 return new BigInteger(text); [EOL]             } [EOL]             long value = Long.parseLong(text); [EOL]             if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) { [EOL]                 return Integer.valueOf((int) value); [EOL]             } [EOL]             return Long.valueOf(value); [EOL]         } catch (IllegalArgumentException iae) { [EOL]             throw ctxt.weirdStringException(text, _valueClass, "not a valid number"); [EOL]         } [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass, t); [EOL] }
@Override [EOL] public final Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (key == null) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         Object result = _parse(key, ctxt); [EOL]         if (result != null) { [EOL]             return result; [EOL]         } [EOL]     } catch (Exception re) { [EOL]         throw ctxt.weirdKeyException(_keyClass, key, "not a valid representation: " + re.getMessage()); [EOL]     } [EOL]     if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]         return null; [EOL]     } [EOL]     throw ctxt.weirdKeyException(_keyClass, key, "not a valid representation"); [EOL] }
@Override [EOL] public final Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (key == null) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         Object result = _parse(key, ctxt); [EOL]         if (result != null) { [EOL]             return result; [EOL]         } [EOL]     } catch (Exception re) { [EOL]         throw ctxt.weirdKeyException(_keyClass, key, "not a valid representation: " + re.getMessage()); [EOL]     } [EOL]     if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]         return null; [EOL]     } [EOL]     throw ctxt.weirdKeyException(_keyClass, key, "not a valid representation"); [EOL] }
@Override [EOL] public final Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (key == null) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         Object result = _parse(key, ctxt); [EOL]         if (result != null) { [EOL]             return result; [EOL]         } [EOL]     } catch (Exception re) { [EOL]         throw ctxt.weirdKeyException(_keyClass, key, "not a valid representation: " + re.getMessage()); [EOL]     } [EOL]     if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]         return null; [EOL]     } [EOL]     throw ctxt.weirdKeyException(_keyClass, key, "not a valid representation"); [EOL] }
@Override [EOL] public final Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (key == null) { [EOL]         return null; [EOL]     } [EOL]     try { [EOL]         Object result = _parse(key, ctxt); [EOL]         if (result != null) { [EOL]             return result; [EOL]         } [EOL]     } catch (Exception re) { [EOL]         throw ctxt.weirdKeyException(_keyClass, key, "not a valid representation: " + re.getMessage()); [EOL]     } [EOL]     if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]         return null; [EOL]     } [EOL]     throw ctxt.weirdKeyException(_keyClass, key, "not a valid representation"); [EOL] }
protected int _parseInt(String key) throws IllegalArgumentException { [EOL]     return Integer.parseInt(key); [EOL] }
@Override [EOL] public String _parse(String key, DeserializationContext ctxt) throws JsonMappingException { [EOL]     return key; [EOL] }
IntKD() { [EOL]     super(Integer.class); [EOL] }
@Override [EOL] public Integer _parse(String key, DeserializationContext ctxt) throws JsonMappingException { [EOL]     return _parseInt(key); [EOL] }
@Override [EOL] public Object _parse(String key, DeserializationContext ctxt) throws JsonMappingException { [EOL]     if (_factory != null) { [EOL]         try { [EOL]             return _factory.call1(key); [EOL]         } catch (Exception e) { [EOL]             ClassUtil.unwrapAndThrowAsIAE(e); [EOL]         } [EOL]     } [EOL]     Enum<?> e = _resolver.findEnum(key); [EOL]     if (e == null && !ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]         throw ctxt.weirdKeyException(_keyClass, key, "not one of values for Enum class"); [EOL]     } [EOL]     return e; [EOL] }
@Override [EOL] public Object _parse(String key, DeserializationContext ctxt) throws JsonMappingException { [EOL]     if (_factory != null) { [EOL]         try { [EOL]             return _factory.call1(key); [EOL]         } catch (Exception e) { [EOL]             ClassUtil.unwrapAndThrowAsIAE(e); [EOL]         } [EOL]     } [EOL]     Enum<?> e = _resolver.findEnum(key); [EOL]     if (e == null && !ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]         throw ctxt.weirdKeyException(_keyClass, key, "not one of values for Enum class"); [EOL]     } [EOL]     return e; [EOL] }
@Override [EOL] public Object _parse(String key, DeserializationContext ctxt) throws JsonMappingException { [EOL]     if (_factory != null) { [EOL]         try { [EOL]             return _factory.call1(key); [EOL]         } catch (Exception e) { [EOL]             ClassUtil.unwrapAndThrowAsIAE(e); [EOL]         } [EOL]     } [EOL]     Enum<?> e = _resolver.findEnum(key); [EOL]     if (e == null && !ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]         throw ctxt.weirdKeyException(_keyClass, key, "not one of values for Enum class"); [EOL]     } [EOL]     return e; [EOL] }
@Override [EOL] public Object _parse(String key, DeserializationContext ctxt) throws JsonMappingException { [EOL]     if (_factory != null) { [EOL]         try { [EOL]             return _factory.call1(key); [EOL]         } catch (Exception e) { [EOL]             ClassUtil.unwrapAndThrowAsIAE(e); [EOL]         } [EOL]     } [EOL]     Enum<?> e = _resolver.findEnum(key); [EOL]     if (e == null && !ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]         throw ctxt.weirdKeyException(_keyClass, key, "not one of values for Enum class"); [EOL]     } [EOL]     return e; [EOL] }
@Override [EOL] public Object _parse(String key, DeserializationContext ctxt) throws JsonMappingException { [EOL]     if (_factory != null) { [EOL]         try { [EOL]             return _factory.call1(key); [EOL]         } catch (Exception e) { [EOL]             ClassUtil.unwrapAndThrowAsIAE(e); [EOL]         } [EOL]     } [EOL]     Enum<?> e = _resolver.findEnum(key); [EOL]     if (e == null && !ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) { [EOL]         throw ctxt.weirdKeyException(_keyClass, key, "not one of values for Enum class"); [EOL]     } [EOL]     return e; [EOL] }
protected DateKD() { [EOL]     super(java.util.Date.class); [EOL] }
@Override [EOL] public Object _parse(String key, DeserializationContext ctxt) throws IllegalArgumentException, JsonMappingException { [EOL]     return ctxt.parseDate(key); [EOL] }
@Override [EOL] public Object _parse(String key, DeserializationContext ctxt) throws IllegalArgumentException, JsonMappingException { [EOL]     return ctxt.parseDate(key); [EOL] }
protected CalendarKD() { [EOL]     super(java.util.Calendar.class); [EOL] }
@Override [EOL] public Object _parse(String key, DeserializationContext ctxt) throws IllegalArgumentException, JsonMappingException { [EOL]     java.util.Date date = ctxt.parseDate(key); [EOL]     return (date == null) ? null : ctxt.constructCalendar(date); [EOL] }
@Override [EOL] public Object _parse(String key, DeserializationContext ctxt) throws IllegalArgumentException, JsonMappingException { [EOL]     java.util.Date date = ctxt.parseDate(key); [EOL]     return (date == null) ? null : ctxt.constructCalendar(date); [EOL] }
protected UuidKD() { [EOL]     super(UUID.class); [EOL] }
@Override [EOL] public Object _parse(String key, DeserializationContext ctxt) throws IllegalArgumentException, JsonMappingException { [EOL]     return UUID.fromString(key); [EOL] }
public final NodeCursor iterateChildren() { [EOL]     JsonNode n = currentNode(); [EOL]     if (n == null) [EOL]         throw new IllegalStateException("No current node"); [EOL]     if (n.isArray()) { [EOL]         return new Array(n, this); [EOL]     } [EOL]     if (n.isObject()) { [EOL]         return new Object(n, this); [EOL]     } [EOL]     throw new IllegalStateException("Current node of type " + n.getClass().getName()); [EOL] }
public final NodeCursor iterateChildren() { [EOL]     JsonNode n = currentNode(); [EOL]     if (n == null) [EOL]         throw new IllegalStateException("No current node"); [EOL]     if (n.isArray()) { [EOL]         return new Array(n, this); [EOL]     } [EOL]     if (n.isObject()) { [EOL]         return new Object(n, this); [EOL]     } [EOL]     throw new IllegalStateException("Current node of type " + n.getClass().getName()); [EOL] }
public final NodeCursor iterateChildren() { [EOL]     JsonNode n = currentNode(); [EOL]     if (n == null) [EOL]         throw new IllegalStateException("No current node"); [EOL]     if (n.isArray()) { [EOL]         return new Array(n, this); [EOL]     } [EOL]     if (n.isObject()) { [EOL]         return new Object(n, this); [EOL]     } [EOL]     throw new IllegalStateException("Current node of type " + n.getClass().getName()); [EOL] }
public final NodeCursor iterateChildren() { [EOL]     JsonNode n = currentNode(); [EOL]     if (n == null) [EOL]         throw new IllegalStateException("No current node"); [EOL]     if (n.isArray()) { [EOL]         return new Array(n, this); [EOL]     } [EOL]     if (n.isObject()) { [EOL]         return new Object(n, this); [EOL]     } [EOL]     throw new IllegalStateException("Current node of type " + n.getClass().getName()); [EOL] }
public Array(JsonNode n, NodeCursor p) { [EOL]     super(JsonStreamContext.TYPE_ARRAY, p); [EOL]     _contents = n.elements(); [EOL] }
public Array(JsonNode n, NodeCursor p) { [EOL]     super(JsonStreamContext.TYPE_ARRAY, p); [EOL]     _contents = n.elements(); [EOL] }
public Array(JsonNode n, NodeCursor p) { [EOL]     super(JsonStreamContext.TYPE_ARRAY, p); [EOL]     _contents = n.elements(); [EOL] }
@Override [EOL] public JsonToken nextToken() { [EOL]     if (!_contents.hasNext()) { [EOL]         _currentNode = null; [EOL]         return null; [EOL]     } [EOL]     _currentNode = _contents.next(); [EOL]     return _currentNode.asToken(); [EOL] }
@Override [EOL] public JsonToken nextToken() { [EOL]     if (!_contents.hasNext()) { [EOL]         _currentNode = null; [EOL]         return null; [EOL]     } [EOL]     _currentNode = _contents.next(); [EOL]     return _currentNode.asToken(); [EOL] }
@Override [EOL] public JsonToken endToken() { [EOL]     return JsonToken.END_ARRAY; [EOL] }
@Override [EOL] public JsonNode currentNode() { [EOL]     return _currentNode; [EOL] }
@Override [EOL] public JsonSerializer<Object> serializerFor(Class<?> type) { [EOL]     if (type == _type) { [EOL]         return _serializer; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonSerializer<Object> serializerFor(Class<?> type) { [EOL]     if (type == _type) { [EOL]         return _serializer; [EOL]     } [EOL]     return null; [EOL] }
@SuppressWarnings("unchecked") [EOL] public EnumSetDeserializer(JavaType enumType, JsonDeserializer<?> deser) { [EOL]     super(EnumSet.class); [EOL]     _enumType = enumType; [EOL]     _enumClass = (Class<Enum>) enumType.getRawClass(); [EOL]     _enumDeserializer = (JsonDeserializer<Enum<?>>) deser; [EOL] }
@SuppressWarnings("unchecked") [EOL] public EnumSetDeserializer(JavaType enumType, JsonDeserializer<?> deser) { [EOL]     super(EnumSet.class); [EOL]     _enumType = enumType; [EOL]     _enumClass = (Class<Enum>) enumType.getRawClass(); [EOL]     _enumDeserializer = (JsonDeserializer<Enum<?>>) deser; [EOL] }
@SuppressWarnings("unchecked") [EOL] public EnumSetDeserializer(JavaType enumType, JsonDeserializer<?> deser) { [EOL]     super(EnumSet.class); [EOL]     _enumType = enumType; [EOL]     _enumClass = (Class<Enum>) enumType.getRawClass(); [EOL]     _enumDeserializer = (JsonDeserializer<Enum<?>>) deser; [EOL] }
public EnumSetDeserializer withDeserializer(JsonDeserializer<?> deser) { [EOL]     if (_enumDeserializer == deser) { [EOL]         return this; [EOL]     } [EOL]     return new EnumSetDeserializer(_enumType, deser); [EOL] }
public EnumSetDeserializer withDeserializer(JsonDeserializer<?> deser) { [EOL]     if (_enumDeserializer == deser) { [EOL]         return this; [EOL]     } [EOL]     return new EnumSetDeserializer(_enumType, deser); [EOL] }
@Override [EOL] public boolean isCachable() { [EOL]     return true; [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> deser = _enumDeserializer; [EOL]     if (deser == null) { [EOL]         deser = ctxt.findContextualValueDeserializer(_enumType, property); [EOL]     } else { [EOL]         if (deser instanceof ContextualDeserializer) { [EOL]             deser = ((ContextualDeserializer) deser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     return withDeserializer(deser); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> deser = _enumDeserializer; [EOL]     if (deser == null) { [EOL]         deser = ctxt.findContextualValueDeserializer(_enumType, property); [EOL]     } else { [EOL]         if (deser instanceof ContextualDeserializer) { [EOL]             deser = ((ContextualDeserializer) deser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     return withDeserializer(deser); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     JsonDeserializer<?> deser = _enumDeserializer; [EOL]     if (deser == null) { [EOL]         deser = ctxt.findContextualValueDeserializer(_enumType, property); [EOL]     } else { [EOL]         if (deser instanceof ContextualDeserializer) { [EOL]             deser = ((ContextualDeserializer) deser).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     return withDeserializer(deser); [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public EnumSet<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         throw ctxt.mappingException(EnumSet.class); [EOL]     } [EOL]     EnumSet result = constructSet(); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             throw ctxt.mappingException(_enumClass); [EOL]         } [EOL]         Enum<?> value = _enumDeserializer.deserialize(jp, ctxt); [EOL]         if (value != null) { [EOL]             result.add(value); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public EnumSet<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         throw ctxt.mappingException(EnumSet.class); [EOL]     } [EOL]     EnumSet result = constructSet(); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             throw ctxt.mappingException(_enumClass); [EOL]         } [EOL]         Enum<?> value = _enumDeserializer.deserialize(jp, ctxt); [EOL]         if (value != null) { [EOL]             result.add(value); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public EnumSet<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         throw ctxt.mappingException(EnumSet.class); [EOL]     } [EOL]     EnumSet result = constructSet(); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             throw ctxt.mappingException(_enumClass); [EOL]         } [EOL]         Enum<?> value = _enumDeserializer.deserialize(jp, ctxt); [EOL]         if (value != null) { [EOL]             result.add(value); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public EnumSet<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (!jp.isExpectedStartArrayToken()) { [EOL]         throw ctxt.mappingException(EnumSet.class); [EOL]     } [EOL]     EnumSet result = constructSet(); [EOL]     JsonToken t; [EOL]     while ((t = jp.nextToken()) != JsonToken.END_ARRAY) { [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             throw ctxt.mappingException(_enumClass); [EOL]         } [EOL]         Enum<?> value = _enumDeserializer.deserialize(jp, ctxt); [EOL]         if (value != null) { [EOL]             result.add(value); [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@SuppressWarnings("unchecked") [EOL] private EnumSet constructSet() { [EOL]     return EnumSet.noneOf(_enumClass); [EOL] }
public static KeyDeserializer constructEnumKeyDeserializer(EnumResolver<?> enumResolver) { [EOL]     return new StdKeyDeserializer.EnumKD(enumResolver, null); [EOL] }
public static KeyDeserializer constructEnumKeyDeserializer(EnumResolver<?> enumResolver) { [EOL]     return new StdKeyDeserializer.EnumKD(enumResolver, null); [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == String.class || raw == Object.class) { [EOL]         return StdKeyDeserializer.StringKD.forType(raw); [EOL]     } [EOL]     if (raw == UUID.class) { [EOL]         return new StdKeyDeserializer.UuidKD(); [EOL]     } [EOL]     if (raw.isPrimitive()) { [EOL]         raw = ClassUtil.wrapperType(raw); [EOL]     } [EOL]     if (raw == Integer.class) { [EOL]         return new StdKeyDeserializer.IntKD(); [EOL]     } [EOL]     if (raw == Long.class) { [EOL]         return new StdKeyDeserializer.LongKD(); [EOL]     } [EOL]     if (raw == Date.class) { [EOL]         return new StdKeyDeserializer.DateKD(); [EOL]     } [EOL]     if (raw == Calendar.class) { [EOL]         return new StdKeyDeserializer.CalendarKD(); [EOL]     } [EOL]     if (raw == Boolean.class) { [EOL]         return new StdKeyDeserializer.BoolKD(); [EOL]     } [EOL]     if (raw == Byte.class) { [EOL]         return new StdKeyDeserializer.ByteKD(); [EOL]     } [EOL]     if (raw == Character.class) { [EOL]         return new StdKeyDeserializer.CharKD(); [EOL]     } [EOL]     if (raw == Short.class) { [EOL]         return new StdKeyDeserializer.ShortKD(); [EOL]     } [EOL]     if (raw == Float.class) { [EOL]         return new StdKeyDeserializer.FloatKD(); [EOL]     } [EOL]     if (raw == Double.class) { [EOL]         return new StdKeyDeserializer.DoubleKD(); [EOL]     } [EOL]     if (raw == Locale.class) { [EOL]         return new StdKeyDeserializer.LocaleKD(); [EOL]     } [EOL]     return null; [EOL] }
public LinkedNode(T value, LinkedNode<T> next) { [EOL]     _value = value; [EOL]     _next = next; [EOL] }
public LinkedNode(T value, LinkedNode<T> next) { [EOL]     _value = value; [EOL]     _next = next; [EOL] }
public T value() { [EOL]     return _value; [EOL] }
public static <ST> boolean contains(LinkedNode<ST> node, ST value) { [EOL]     while (node != null) { [EOL]         if (node.value() == value) { [EOL]             return true; [EOL]         } [EOL]         node = node.next(); [EOL]     } [EOL]     return false; [EOL] }
public static <ST> boolean contains(LinkedNode<ST> node, ST value) { [EOL]     while (node != null) { [EOL]         if (node.value() == value) { [EOL]             return true; [EOL]         } [EOL]         node = node.next(); [EOL]     } [EOL]     return false; [EOL] }
public static <ST> boolean contains(LinkedNode<ST> node, ST value) { [EOL]     while (node != null) { [EOL]         if (node.value() == value) { [EOL]             return true; [EOL]         } [EOL]         node = node.next(); [EOL]     } [EOL]     return false; [EOL] }
public static <ST> boolean contains(LinkedNode<ST> node, ST value) { [EOL]     while (node != null) { [EOL]         if (node.value() == value) { [EOL]             return true; [EOL]         } [EOL]         node = node.next(); [EOL]     } [EOL]     return false; [EOL] }
private final void serializeContents(List<String> value, JsonGenerator jgen, SerializerProvider provider, int len) throws IOException, JsonGenerationException { [EOL]     int i = 0; [EOL]     try { [EOL]         for (; i < len; ++i) { [EOL]             String str = value.get(i); [EOL]             if (str == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 jgen.writeString(str); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
private final void serializeContents(List<String> value, JsonGenerator jgen, SerializerProvider provider, int len) throws IOException, JsonGenerationException { [EOL]     int i = 0; [EOL]     try { [EOL]         for (; i < len; ++i) { [EOL]             String str = value.get(i); [EOL]             if (str == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 jgen.writeString(str); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
private final void serializeContents(List<String> value, JsonGenerator jgen, SerializerProvider provider, int len) throws IOException, JsonGenerationException { [EOL]     int i = 0; [EOL]     try { [EOL]         for (; i < len; ++i) { [EOL]             String str = value.get(i); [EOL]             if (str == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 jgen.writeString(str); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
private final void serializeContents(List<String> value, JsonGenerator jgen, SerializerProvider provider, int len) throws IOException, JsonGenerationException { [EOL]     int i = 0; [EOL]     try { [EOL]         for (; i < len; ++i) { [EOL]             String str = value.get(i); [EOL]             if (str == null) { [EOL]                 provider.defaultSerializeNull(jgen); [EOL]             } else { [EOL]                 jgen.writeString(str); [EOL]             } [EOL]         } [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(provider, e, value, i); [EOL]     } [EOL] }
public AtomicLongSerializer() { [EOL]     super(AtomicLong.class, false); [EOL] }
@Override [EOL] public void serialize(AtomicLong value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     jgen.writeNumber(value.get()); [EOL] }
@Override [EOL] public JsonNodeType getNodeType() { [EOL]     return JsonNodeType.OBJECT; [EOL] }
@Override [EOL] public JsonNode path(String fieldName) { [EOL]     JsonNode n = _children.get(fieldName); [EOL]     if (n != null) { [EOL]         return n; [EOL]     } [EOL]     return MissingNode.getInstance(); [EOL] }
@Override [EOL] public JsonNode path(String fieldName) { [EOL]     JsonNode n = _children.get(fieldName); [EOL]     if (n != null) { [EOL]         return n; [EOL]     } [EOL]     return MissingNode.getInstance(); [EOL] }
@Override [EOL] public List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar) { [EOL]     for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { [EOL]         if (fieldName.equals(entry.getKey())) { [EOL]             if (foundSoFar == null) { [EOL]                 foundSoFar = new ArrayList<JsonNode>(); [EOL]             } [EOL]             foundSoFar.add(entry.getValue()); [EOL]         } else { [EOL]             foundSoFar = entry.getValue().findValues(fieldName, foundSoFar); [EOL]         } [EOL]     } [EOL]     return foundSoFar; [EOL] }
@Override [EOL] public List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar) { [EOL]     for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { [EOL]         if (fieldName.equals(entry.getKey())) { [EOL]             if (foundSoFar == null) { [EOL]                 foundSoFar = new ArrayList<JsonNode>(); [EOL]             } [EOL]             foundSoFar.add(entry.getValue()); [EOL]         } else { [EOL]             foundSoFar = entry.getValue().findValues(fieldName, foundSoFar); [EOL]         } [EOL]     } [EOL]     return foundSoFar; [EOL] }
@Override [EOL] public List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar) { [EOL]     for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { [EOL]         if (fieldName.equals(entry.getKey())) { [EOL]             if (foundSoFar == null) { [EOL]                 foundSoFar = new ArrayList<JsonNode>(); [EOL]             } [EOL]             foundSoFar.add(entry.getValue()); [EOL]         } else { [EOL]             foundSoFar = entry.getValue().findValues(fieldName, foundSoFar); [EOL]         } [EOL]     } [EOL]     return foundSoFar; [EOL] }
@Override [EOL] public List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar) { [EOL]     for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { [EOL]         if (fieldName.equals(entry.getKey())) { [EOL]             if (foundSoFar == null) { [EOL]                 foundSoFar = new ArrayList<JsonNode>(); [EOL]             } [EOL]             foundSoFar.add(entry.getValue()); [EOL]         } else { [EOL]             foundSoFar = entry.getValue().findValues(fieldName, foundSoFar); [EOL]         } [EOL]     } [EOL]     return foundSoFar; [EOL] }
@Override [EOL] public List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar) { [EOL]     for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { [EOL]         if (fieldName.equals(entry.getKey())) { [EOL]             if (foundSoFar == null) { [EOL]                 foundSoFar = new ArrayList<JsonNode>(); [EOL]             } [EOL]             foundSoFar.add(this); [EOL]         } else { [EOL]             foundSoFar = entry.getValue().findParents(fieldName, foundSoFar); [EOL]         } [EOL]     } [EOL]     return foundSoFar; [EOL] }
@Override [EOL] public List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar) { [EOL]     for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { [EOL]         if (fieldName.equals(entry.getKey())) { [EOL]             if (foundSoFar == null) { [EOL]                 foundSoFar = new ArrayList<JsonNode>(); [EOL]             } [EOL]             foundSoFar.add(this); [EOL]         } else { [EOL]             foundSoFar = entry.getValue().findParents(fieldName, foundSoFar); [EOL]         } [EOL]     } [EOL]     return foundSoFar; [EOL] }
@Override [EOL] public List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar) { [EOL]     for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { [EOL]         if (fieldName.equals(entry.getKey())) { [EOL]             if (foundSoFar == null) { [EOL]                 foundSoFar = new ArrayList<JsonNode>(); [EOL]             } [EOL]             foundSoFar.add(this); [EOL]         } else { [EOL]             foundSoFar = entry.getValue().findParents(fieldName, foundSoFar); [EOL]         } [EOL]     } [EOL]     return foundSoFar; [EOL] }
@Override [EOL] public List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar) { [EOL]     for (Map.Entry<String, JsonNode> entry : _children.entrySet()) { [EOL]         if (fieldName.equals(entry.getKey())) { [EOL]             if (foundSoFar == null) { [EOL]                 foundSoFar = new ArrayList<JsonNode>(); [EOL]             } [EOL]             foundSoFar.add(this); [EOL]         } else { [EOL]             foundSoFar = entry.getValue().findParents(fieldName, foundSoFar); [EOL]         } [EOL]     } [EOL]     return foundSoFar; [EOL] }
public JsonNode setAll(Map<String, JsonNode> properties) { [EOL]     for (Map.Entry<String, JsonNode> en : properties.entrySet()) { [EOL]         JsonNode n = en.getValue(); [EOL]         if (n == null) { [EOL]             n = nullNode(); [EOL]         } [EOL]         _children.put(en.getKey(), n); [EOL]     } [EOL]     return this; [EOL] }
public JsonNode setAll(Map<String, JsonNode> properties) { [EOL]     for (Map.Entry<String, JsonNode> en : properties.entrySet()) { [EOL]         JsonNode n = en.getValue(); [EOL]         if (n == null) { [EOL]             n = nullNode(); [EOL]         } [EOL]         _children.put(en.getKey(), n); [EOL]     } [EOL]     return this; [EOL] }
public JsonNode setAll(Map<String, JsonNode> properties) { [EOL]     for (Map.Entry<String, JsonNode> en : properties.entrySet()) { [EOL]         JsonNode n = en.getValue(); [EOL]         if (n == null) { [EOL]             n = nullNode(); [EOL]         } [EOL]         _children.put(en.getKey(), n); [EOL]     } [EOL]     return this; [EOL] }
public JsonNode setAll(ObjectNode other) { [EOL]     _children.putAll(other._children); [EOL]     return this; [EOL] }
public JsonNode setAll(ObjectNode other) { [EOL]     _children.putAll(other._children); [EOL]     return this; [EOL] }
public JsonNode replace(String fieldName, JsonNode value) { [EOL]     if (value == null) { [EOL]         value = nullNode(); [EOL]     } [EOL]     return _children.put(fieldName, value); [EOL] }
public JsonNode replace(String fieldName, JsonNode value) { [EOL]     if (value == null) { [EOL]         value = nullNode(); [EOL]     } [EOL]     return _children.put(fieldName, value); [EOL] }
public JsonNode put(String fieldName, JsonNode value) { [EOL]     if (value == null) { [EOL]         value = nullNode(); [EOL]     } [EOL]     return _children.put(fieldName, value); [EOL] }
public JsonNode put(String fieldName, JsonNode value) { [EOL]     if (value == null) { [EOL]         value = nullNode(); [EOL]     } [EOL]     return _children.put(fieldName, value); [EOL] }
public ArrayNode putArray(String fieldName) { [EOL]     ArrayNode n = arrayNode(); [EOL]     _children.put(fieldName, n); [EOL]     return n; [EOL] }
public ArrayNode putArray(String fieldName) { [EOL]     ArrayNode n = arrayNode(); [EOL]     _children.put(fieldName, n); [EOL]     return n; [EOL] }
public ObjectNode putObject(String fieldName) { [EOL]     ObjectNode n = objectNode(); [EOL]     _children.put(fieldName, n); [EOL]     return n; [EOL] }
public ObjectNode putObject(String fieldName) { [EOL]     ObjectNode n = objectNode(); [EOL]     _children.put(fieldName, n); [EOL]     return n; [EOL] }
protected Annotated() { [EOL] }
public final <A extends Annotation> boolean hasAnnotation(Class<A> acls) { [EOL]     return getAnnotation(acls) != null; [EOL] }
public final <A extends Annotation> boolean hasAnnotation(Class<A> acls) { [EOL]     return getAnnotation(acls) != null; [EOL] }
public static String okNameForRegularGetter(AnnotatedMethod am, String name) { [EOL]     if (name.startsWith("get")) { [EOL]         if ("getCallbacks".equals(name)) { [EOL]             if (isCglibGetCallbacks(am)) { [EOL]                 return null; [EOL]             } [EOL]         } else if ("getMetaClass".equals(name)) { [EOL]             if (isGroovyMetaClassGetter(am)) { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return manglePropertyName(name.substring(3)); [EOL]     } [EOL]     return null; [EOL] }
public static String okNameForRegularGetter(AnnotatedMethod am, String name) { [EOL]     if (name.startsWith("get")) { [EOL]         if ("getCallbacks".equals(name)) { [EOL]             if (isCglibGetCallbacks(am)) { [EOL]                 return null; [EOL]             } [EOL]         } else if ("getMetaClass".equals(name)) { [EOL]             if (isGroovyMetaClassGetter(am)) { [EOL]                 return null; [EOL]             } [EOL]         } [EOL]         return manglePropertyName(name.substring(3)); [EOL]     } [EOL]     return null; [EOL] }
protected static boolean isCglibGetCallbacks(AnnotatedMethod am) { [EOL]     Class<?> rt = am.getRawType(); [EOL]     if (rt == null || !rt.isArray()) { [EOL]         return false; [EOL]     } [EOL]     Class<?> compType = rt.getComponentType(); [EOL]     Package pkg = compType.getPackage(); [EOL]     if (pkg != null) { [EOL]         String pname = pkg.getName(); [EOL]         if (pname.startsWith("net.sf.cglib") || pname.startsWith("org.hibernate.repackage.cglib")) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
protected static boolean isCglibGetCallbacks(AnnotatedMethod am) { [EOL]     Class<?> rt = am.getRawType(); [EOL]     if (rt == null || !rt.isArray()) { [EOL]         return false; [EOL]     } [EOL]     Class<?> compType = rt.getComponentType(); [EOL]     Package pkg = compType.getPackage(); [EOL]     if (pkg != null) { [EOL]         String pname = pkg.getName(); [EOL]         if (pname.startsWith("net.sf.cglib") || pname.startsWith("org.hibernate.repackage.cglib")) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
protected static boolean isCglibGetCallbacks(AnnotatedMethod am) { [EOL]     Class<?> rt = am.getRawType(); [EOL]     if (rt == null || !rt.isArray()) { [EOL]         return false; [EOL]     } [EOL]     Class<?> compType = rt.getComponentType(); [EOL]     Package pkg = compType.getPackage(); [EOL]     if (pkg != null) { [EOL]         String pname = pkg.getName(); [EOL]         if (pname.startsWith("net.sf.cglib") || pname.startsWith("org.hibernate.repackage.cglib")) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
protected static boolean isCglibGetCallbacks(AnnotatedMethod am) { [EOL]     Class<?> rt = am.getRawType(); [EOL]     if (rt == null || !rt.isArray()) { [EOL]         return false; [EOL]     } [EOL]     Class<?> compType = rt.getComponentType(); [EOL]     Package pkg = compType.getPackage(); [EOL]     if (pkg != null) { [EOL]         String pname = pkg.getName(); [EOL]         if (pname.startsWith("net.sf.cglib") || pname.startsWith("org.hibernate.repackage.cglib")) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
protected static boolean isCglibGetCallbacks(AnnotatedMethod am) { [EOL]     Class<?> rt = am.getRawType(); [EOL]     if (rt == null || !rt.isArray()) { [EOL]         return false; [EOL]     } [EOL]     Class<?> compType = rt.getComponentType(); [EOL]     Package pkg = compType.getPackage(); [EOL]     if (pkg != null) { [EOL]         String pname = pkg.getName(); [EOL]         if (pname.startsWith("net.sf.cglib") || pname.startsWith("org.hibernate.repackage.cglib")) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] }
protected static boolean isGroovyMetaClassGetter(AnnotatedMethod am) { [EOL]     Class<?> rt = am.getRawType(); [EOL]     if (rt == null || rt.isArray()) { [EOL]         return false; [EOL]     } [EOL]     Package pkg = rt.getPackage(); [EOL]     if (pkg != null && pkg.getName().startsWith("groovy.lang")) { [EOL]         return true; [EOL]     } [EOL]     return false; [EOL] }
protected static String manglePropertyName(String basename) { [EOL]     int len = basename.length(); [EOL]     if (len == 0) { [EOL]         return null; [EOL]     } [EOL]     StringBuilder sb = null; [EOL]     for (int i = 0; i < len; ++i) { [EOL]         char upper = basename.charAt(i); [EOL]         char lower = Character.toLowerCase(upper); [EOL]         if (upper == lower) { [EOL]             break; [EOL]         } [EOL]         if (sb == null) { [EOL]             sb = new StringBuilder(basename); [EOL]         } [EOL]         sb.setCharAt(i, lower); [EOL]     } [EOL]     return (sb == null) ? basename : sb.toString(); [EOL] }
public IntNode(int v) { [EOL]     _value = v; [EOL] }
public static IntNode valueOf(int i) { [EOL]     if (i > MAX_CANONICAL || i < MIN_CANONICAL) [EOL]         return new IntNode(i); [EOL]     return CANONICALS[i - MIN_CANONICAL]; [EOL] }
public static IntNode valueOf(int i) { [EOL]     if (i > MAX_CANONICAL || i < MIN_CANONICAL) [EOL]         return new IntNode(i); [EOL]     return CANONICALS[i - MIN_CANONICAL]; [EOL] }
public static IntNode valueOf(int i) { [EOL]     if (i > MAX_CANONICAL || i < MIN_CANONICAL) [EOL]         return new IntNode(i); [EOL]     return CANONICALS[i - MIN_CANONICAL]; [EOL] }
public UnwrappedPropertyHandler() { [EOL] }
public void addProperty(SettableBeanProperty property) { [EOL]     _properties.add(property); [EOL] }
public void addProperty(SettableBeanProperty property) { [EOL]     _properties.add(property); [EOL] }
public Object processUnwrapped(JsonParser originalParser, DeserializationContext ctxt, Object bean, TokenBuffer buffered) throws IOException, JsonProcessingException { [EOL]     for (int i = 0, len = _properties.size(); i < len; ++i) { [EOL]         SettableBeanProperty prop = _properties.get(i); [EOL]         JsonParser jp = buffered.asParser(); [EOL]         jp.nextToken(); [EOL]         prop.deserializeAndSet(jp, ctxt, bean); [EOL]     } [EOL]     return bean; [EOL] }
public Object processUnwrapped(JsonParser originalParser, DeserializationContext ctxt, Object bean, TokenBuffer buffered) throws IOException, JsonProcessingException { [EOL]     for (int i = 0, len = _properties.size(); i < len; ++i) { [EOL]         SettableBeanProperty prop = _properties.get(i); [EOL]         JsonParser jp = buffered.asParser(); [EOL]         jp.nextToken(); [EOL]         prop.deserializeAndSet(jp, ctxt, bean); [EOL]     } [EOL]     return bean; [EOL] }
public SimpleDeserializers() { [EOL] }
public <T> void addDeserializer(Class<T> forClass, JsonDeserializer<? extends T> deser) { [EOL]     ClassKey key = new ClassKey(forClass); [EOL]     if (_classMappings == null) { [EOL]         _classMappings = new HashMap<ClassKey, JsonDeserializer<?>>(); [EOL]     } [EOL]     _classMappings.put(key, deser); [EOL] }
public <T> void addDeserializer(Class<T> forClass, JsonDeserializer<? extends T> deser) { [EOL]     ClassKey key = new ClassKey(forClass); [EOL]     if (_classMappings == null) { [EOL]         _classMappings = new HashMap<ClassKey, JsonDeserializer<?>>(); [EOL]     } [EOL]     _classMappings.put(key, deser); [EOL] }
@Override [EOL] public JsonDeserializer<?> findArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException { [EOL]     return (_classMappings == null) ? null : _classMappings.get(new ClassKey(type.getRawClass())); [EOL] }
@Override [EOL] public JsonDeserializer<?> findArrayDeserializer(ArrayType type, DeserializationConfig config, BeanDescription beanDesc, TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer) throws JsonMappingException { [EOL]     return (_classMappings == null) ? null : _classMappings.get(new ClassKey(type.getRawClass())); [EOL] }
@Override [EOL] public JsonDeserializer<?> findBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     return (_classMappings == null) ? null : _classMappings.get(new ClassKey(type.getRawClass())); [EOL] }
@Override [EOL] public JsonDeserializer<?> findBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     return (_classMappings == null) ? null : _classMappings.get(new ClassKey(type.getRawClass())); [EOL] }
@Override [EOL] public JsonDeserializer<?> findBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     return (_classMappings == null) ? null : _classMappings.get(new ClassKey(type.getRawClass())); [EOL] }
@Override [EOL] public JsonDeserializer<?> findEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     return (_classMappings == null) ? null : _classMappings.get(new ClassKey(type)); [EOL] }
@Override [EOL] public JsonDeserializer<?> findEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     return (_classMappings == null) ? null : _classMappings.get(new ClassKey(type)); [EOL] }
@Override [EOL] public JsonDeserializer<?> findEnumDeserializer(Class<?> type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException { [EOL]     return (_classMappings == null) ? null : _classMappings.get(new ClassKey(type)); [EOL] }
protected AnnotatedParameter replaceParameterAnnotations(int index, AnnotationMap ann) { [EOL]     _paramAnnotations[index] = ann; [EOL]     return getParameter(index); [EOL] }
protected AnnotatedParameter replaceParameterAnnotations(int index, AnnotationMap ann) { [EOL]     _paramAnnotations[index] = ann; [EOL]     return getParameter(index); [EOL] }
@Override [EOL] public Set<String> getIgnoredPropertyNames() { [EOL]     if (_ignoredPropertyNames == null) { [EOL]         return Collections.emptySet(); [EOL]     } [EOL]     return _ignoredPropertyNames; [EOL] }
@Override [EOL] public Set<String> getIgnoredPropertyNames() { [EOL]     if (_ignoredPropertyNames == null) { [EOL]         return Collections.emptySet(); [EOL]     } [EOL]     return _ignoredPropertyNames; [EOL] }
@Override [EOL] public Map<Object, AnnotatedMember> findInjectables() { [EOL]     return _injectables; [EOL] }
@Override [EOL] public Map<Object, AnnotatedMember> findInjectables() { [EOL]     return _injectables; [EOL] }
@Override [EOL] public Map<String, AnnotatedMember> findBackReferenceProperties() { [EOL]     HashMap<String, AnnotatedMember> result = null; [EOL]     for (BeanPropertyDefinition property : _properties) { [EOL]         AnnotatedMember am = property.getMutator(); [EOL]         if (am == null) { [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refDef = _annotationIntrospector.findReferenceType(am); [EOL]         if (refDef != null && refDef.isBackReference()) { [EOL]             if (result == null) { [EOL]                 result = new HashMap<String, AnnotatedMember>(); [EOL]             } [EOL]             String refName = refDef.getName(); [EOL]             if (result.put(refName, am) != null) { [EOL]                 throw new IllegalArgumentException("Multiple back-reference properties with name '" + refName + "'"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Map<String, AnnotatedMember> findBackReferenceProperties() { [EOL]     HashMap<String, AnnotatedMember> result = null; [EOL]     for (BeanPropertyDefinition property : _properties) { [EOL]         AnnotatedMember am = property.getMutator(); [EOL]         if (am == null) { [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refDef = _annotationIntrospector.findReferenceType(am); [EOL]         if (refDef != null && refDef.isBackReference()) { [EOL]             if (result == null) { [EOL]                 result = new HashMap<String, AnnotatedMember>(); [EOL]             } [EOL]             String refName = refDef.getName(); [EOL]             if (result.put(refName, am) != null) { [EOL]                 throw new IllegalArgumentException("Multiple back-reference properties with name '" + refName + "'"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@Override [EOL] public Map<String, AnnotatedMember> findBackReferenceProperties() { [EOL]     HashMap<String, AnnotatedMember> result = null; [EOL]     for (BeanPropertyDefinition property : _properties) { [EOL]         AnnotatedMember am = property.getMutator(); [EOL]         if (am == null) { [EOL]             continue; [EOL]         } [EOL]         AnnotationIntrospector.ReferenceProperty refDef = _annotationIntrospector.findReferenceType(am); [EOL]         if (refDef != null && refDef.isBackReference()) { [EOL]             if (result == null) { [EOL]                 result = new HashMap<String, AnnotatedMember>(); [EOL]             } [EOL]             String refName = refDef.getName(); [EOL]             if (result.put(refName, am) != null) { [EOL]                 throw new IllegalArgumentException("Multiple back-reference properties with name '" + refName + "'"); [EOL]             } [EOL]         } [EOL]     } [EOL]     return result; [EOL] }
@SuppressWarnings("unchecked") [EOL] public Converter<Object, Object> _createConverter(Object converterDef) { [EOL]     if (converterDef == null) { [EOL]         return null; [EOL]     } [EOL]     if (converterDef instanceof Converter<?, ?>) { [EOL]         return (Converter<Object, Object>) converterDef; [EOL]     } [EOL]     if (!(converterDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Converter definition of type " + converterDef.getClass().getName() + "; expected type Converter or Class<Converter> instead"); [EOL]     } [EOL]     Class<?> converterClass = (Class<?>) converterDef; [EOL]     if (converterClass == Converter.None.class || converterClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!Converter.class.isAssignableFrom(converterClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + converterClass.getName() + "; expected Class<Converter>"); [EOL]     } [EOL]     HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]     Converter<?, ?> conv = (hi == null) ? null : hi.converterInstance(_config, _classInfo, converterClass); [EOL]     if (conv == null) { [EOL]         conv = (Converter<?, ?>) ClassUtil.createInstance(converterClass, _config.canOverrideAccessModifiers()); [EOL]     } [EOL]     return (Converter<Object, Object>) conv; [EOL] }
@SuppressWarnings("unchecked") [EOL] public Converter<Object, Object> _createConverter(Object converterDef) { [EOL]     if (converterDef == null) { [EOL]         return null; [EOL]     } [EOL]     if (converterDef instanceof Converter<?, ?>) { [EOL]         return (Converter<Object, Object>) converterDef; [EOL]     } [EOL]     if (!(converterDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Converter definition of type " + converterDef.getClass().getName() + "; expected type Converter or Class<Converter> instead"); [EOL]     } [EOL]     Class<?> converterClass = (Class<?>) converterDef; [EOL]     if (converterClass == Converter.None.class || converterClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!Converter.class.isAssignableFrom(converterClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + converterClass.getName() + "; expected Class<Converter>"); [EOL]     } [EOL]     HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]     Converter<?, ?> conv = (hi == null) ? null : hi.converterInstance(_config, _classInfo, converterClass); [EOL]     if (conv == null) { [EOL]         conv = (Converter<?, ?>) ClassUtil.createInstance(converterClass, _config.canOverrideAccessModifiers()); [EOL]     } [EOL]     return (Converter<Object, Object>) conv; [EOL] }
@SuppressWarnings("unchecked") [EOL] public Converter<Object, Object> _createConverter(Object converterDef) { [EOL]     if (converterDef == null) { [EOL]         return null; [EOL]     } [EOL]     if (converterDef instanceof Converter<?, ?>) { [EOL]         return (Converter<Object, Object>) converterDef; [EOL]     } [EOL]     if (!(converterDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Converter definition of type " + converterDef.getClass().getName() + "; expected type Converter or Class<Converter> instead"); [EOL]     } [EOL]     Class<?> converterClass = (Class<?>) converterDef; [EOL]     if (converterClass == Converter.None.class || converterClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!Converter.class.isAssignableFrom(converterClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + converterClass.getName() + "; expected Class<Converter>"); [EOL]     } [EOL]     HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]     Converter<?, ?> conv = (hi == null) ? null : hi.converterInstance(_config, _classInfo, converterClass); [EOL]     if (conv == null) { [EOL]         conv = (Converter<?, ?>) ClassUtil.createInstance(converterClass, _config.canOverrideAccessModifiers()); [EOL]     } [EOL]     return (Converter<Object, Object>) conv; [EOL] }
@SuppressWarnings("unchecked") [EOL] public Converter<Object, Object> _createConverter(Object converterDef) { [EOL]     if (converterDef == null) { [EOL]         return null; [EOL]     } [EOL]     if (converterDef instanceof Converter<?, ?>) { [EOL]         return (Converter<Object, Object>) converterDef; [EOL]     } [EOL]     if (!(converterDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Converter definition of type " + converterDef.getClass().getName() + "; expected type Converter or Class<Converter> instead"); [EOL]     } [EOL]     Class<?> converterClass = (Class<?>) converterDef; [EOL]     if (converterClass == Converter.None.class || converterClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!Converter.class.isAssignableFrom(converterClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + converterClass.getName() + "; expected Class<Converter>"); [EOL]     } [EOL]     HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]     Converter<?, ?> conv = (hi == null) ? null : hi.converterInstance(_config, _classInfo, converterClass); [EOL]     if (conv == null) { [EOL]         conv = (Converter<?, ?>) ClassUtil.createInstance(converterClass, _config.canOverrideAccessModifiers()); [EOL]     } [EOL]     return (Converter<Object, Object>) conv; [EOL] }
@SuppressWarnings("unchecked") [EOL] public Converter<Object, Object> _createConverter(Object converterDef) { [EOL]     if (converterDef == null) { [EOL]         return null; [EOL]     } [EOL]     if (converterDef instanceof Converter<?, ?>) { [EOL]         return (Converter<Object, Object>) converterDef; [EOL]     } [EOL]     if (!(converterDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Converter definition of type " + converterDef.getClass().getName() + "; expected type Converter or Class<Converter> instead"); [EOL]     } [EOL]     Class<?> converterClass = (Class<?>) converterDef; [EOL]     if (converterClass == Converter.None.class || converterClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!Converter.class.isAssignableFrom(converterClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + converterClass.getName() + "; expected Class<Converter>"); [EOL]     } [EOL]     HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]     Converter<?, ?> conv = (hi == null) ? null : hi.converterInstance(_config, _classInfo, converterClass); [EOL]     if (conv == null) { [EOL]         conv = (Converter<?, ?>) ClassUtil.createInstance(converterClass, _config.canOverrideAccessModifiers()); [EOL]     } [EOL]     return (Converter<Object, Object>) conv; [EOL] }
@SuppressWarnings("unchecked") [EOL] public Converter<Object, Object> _createConverter(Object converterDef) { [EOL]     if (converterDef == null) { [EOL]         return null; [EOL]     } [EOL]     if (converterDef instanceof Converter<?, ?>) { [EOL]         return (Converter<Object, Object>) converterDef; [EOL]     } [EOL]     if (!(converterDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Converter definition of type " + converterDef.getClass().getName() + "; expected type Converter or Class<Converter> instead"); [EOL]     } [EOL]     Class<?> converterClass = (Class<?>) converterDef; [EOL]     if (converterClass == Converter.None.class || converterClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!Converter.class.isAssignableFrom(converterClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + converterClass.getName() + "; expected Class<Converter>"); [EOL]     } [EOL]     HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]     Converter<?, ?> conv = (hi == null) ? null : hi.converterInstance(_config, _classInfo, converterClass); [EOL]     if (conv == null) { [EOL]         conv = (Converter<?, ?>) ClassUtil.createInstance(converterClass, _config.canOverrideAccessModifiers()); [EOL]     } [EOL]     return (Converter<Object, Object>) conv; [EOL] }
@SuppressWarnings("unchecked") [EOL] public Converter<Object, Object> _createConverter(Object converterDef) { [EOL]     if (converterDef == null) { [EOL]         return null; [EOL]     } [EOL]     if (converterDef instanceof Converter<?, ?>) { [EOL]         return (Converter<Object, Object>) converterDef; [EOL]     } [EOL]     if (!(converterDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Converter definition of type " + converterDef.getClass().getName() + "; expected type Converter or Class<Converter> instead"); [EOL]     } [EOL]     Class<?> converterClass = (Class<?>) converterDef; [EOL]     if (converterClass == Converter.None.class || converterClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!Converter.class.isAssignableFrom(converterClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + converterClass.getName() + "; expected Class<Converter>"); [EOL]     } [EOL]     HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]     Converter<?, ?> conv = (hi == null) ? null : hi.converterInstance(_config, _classInfo, converterClass); [EOL]     if (conv == null) { [EOL]         conv = (Converter<?, ?>) ClassUtil.createInstance(converterClass, _config.canOverrideAccessModifiers()); [EOL]     } [EOL]     return (Converter<Object, Object>) conv; [EOL] }
@SuppressWarnings("unchecked") [EOL] public Converter<Object, Object> _createConverter(Object converterDef) { [EOL]     if (converterDef == null) { [EOL]         return null; [EOL]     } [EOL]     if (converterDef instanceof Converter<?, ?>) { [EOL]         return (Converter<Object, Object>) converterDef; [EOL]     } [EOL]     if (!(converterDef instanceof Class)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Converter definition of type " + converterDef.getClass().getName() + "; expected type Converter or Class<Converter> instead"); [EOL]     } [EOL]     Class<?> converterClass = (Class<?>) converterDef; [EOL]     if (converterClass == Converter.None.class || converterClass == NoClass.class) { [EOL]         return null; [EOL]     } [EOL]     if (!Converter.class.isAssignableFrom(converterClass)) { [EOL]         throw new IllegalStateException("AnnotationIntrospector returned Class " + converterClass.getName() + "; expected Class<Converter>"); [EOL]     } [EOL]     HandlerInstantiator hi = _config.getHandlerInstantiator(); [EOL]     Converter<?, ?> conv = (hi == null) ? null : hi.converterInstance(_config, _classInfo, converterClass); [EOL]     if (conv == null) { [EOL]         conv = (Converter<?, ?>) ClassUtil.createInstance(converterClass, _config.canOverrideAccessModifiers()); [EOL]     } [EOL]     return (Converter<Object, Object>) conv; [EOL] }
@Override [EOL] public String getValueTypeDesc() { [EOL]     return _valueTypeDesc; [EOL] }
@Override [EOL] public String getValueTypeDesc() { [EOL]     return _valueTypeDesc; [EOL] }
@Override [EOL] public boolean canCreateFromString() { [EOL]     return (_fromStringCreator != null); [EOL] }
@Override [EOL] public boolean canCreateFromString() { [EOL]     return (_fromStringCreator != null); [EOL] }
@Override [EOL] public boolean canCreateFromInt() { [EOL]     return (_fromIntCreator != null); [EOL] }
@Override [EOL] public boolean canCreateFromInt() { [EOL]     return (_fromIntCreator != null); [EOL] }
@Override [EOL] public boolean canCreateFromLong() { [EOL]     return (_fromLongCreator != null); [EOL] }
@Override [EOL] public boolean canCreateFromLong() { [EOL]     return (_fromLongCreator != null); [EOL] }
@Override [EOL] public boolean canCreateFromDouble() { [EOL]     return (_fromDoubleCreator != null); [EOL] }
@Override [EOL] public boolean canCreateFromDouble() { [EOL]     return (_fromDoubleCreator != null); [EOL] }
@Override [EOL] public boolean canCreateFromBoolean() { [EOL]     return (_fromBooleanCreator != null); [EOL] }
@Override [EOL] public boolean canCreateFromBoolean() { [EOL]     return (_fromBooleanCreator != null); [EOL] }
protected Object _createFromStringFallbacks(DeserializationContext ctxt, String value) throws IOException, JsonProcessingException { [EOL]     if (_fromBooleanCreator != null) { [EOL]         String str = value.trim(); [EOL]         if ("true".equals(str)) { [EOL]             return createFromBoolean(ctxt, true); [EOL]         } [EOL]         if ("false".equals(str)) { [EOL]             return createFromBoolean(ctxt, false); [EOL]         } [EOL]     } [EOL]     if (_cfgEmptyStringsAsObjects && value.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     throw new JsonMappingException("Can not instantiate value of type " + getValueTypeDesc() + " from String value; no single-String constructor/factory method"); [EOL] }
protected Object _createFromStringFallbacks(DeserializationContext ctxt, String value) throws IOException, JsonProcessingException { [EOL]     if (_fromBooleanCreator != null) { [EOL]         String str = value.trim(); [EOL]         if ("true".equals(str)) { [EOL]             return createFromBoolean(ctxt, true); [EOL]         } [EOL]         if ("false".equals(str)) { [EOL]             return createFromBoolean(ctxt, false); [EOL]         } [EOL]     } [EOL]     if (_cfgEmptyStringsAsObjects && value.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     throw new JsonMappingException("Can not instantiate value of type " + getValueTypeDesc() + " from String value; no single-String constructor/factory method"); [EOL] }
protected Object _createFromStringFallbacks(DeserializationContext ctxt, String value) throws IOException, JsonProcessingException { [EOL]     if (_fromBooleanCreator != null) { [EOL]         String str = value.trim(); [EOL]         if ("true".equals(str)) { [EOL]             return createFromBoolean(ctxt, true); [EOL]         } [EOL]         if ("false".equals(str)) { [EOL]             return createFromBoolean(ctxt, false); [EOL]         } [EOL]     } [EOL]     if (_cfgEmptyStringsAsObjects && value.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     throw new JsonMappingException("Can not instantiate value of type " + getValueTypeDesc() + " from String value; no single-String constructor/factory method"); [EOL] }
protected Object _createFromStringFallbacks(DeserializationContext ctxt, String value) throws IOException, JsonProcessingException { [EOL]     if (_fromBooleanCreator != null) { [EOL]         String str = value.trim(); [EOL]         if ("true".equals(str)) { [EOL]             return createFromBoolean(ctxt, true); [EOL]         } [EOL]         if ("false".equals(str)) { [EOL]             return createFromBoolean(ctxt, false); [EOL]         } [EOL]     } [EOL]     if (_cfgEmptyStringsAsObjects && value.length() == 0) { [EOL]         return null; [EOL]     } [EOL]     throw new JsonMappingException("Can not instantiate value of type " + getValueTypeDesc() + " from String value; no single-String constructor/factory method"); [EOL] }
@Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) { [EOL]     ObjectNode o = createSchemaNode("array", true); [EOL]     o.put("items", createSchemaNode("boolean")); [EOL]     return o; [EOL] }
@Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) { [EOL]     ObjectNode o = createSchemaNode("array", true); [EOL]     ObjectNode itemSchema = createSchemaNode("string"); [EOL]     o.put("items", itemSchema); [EOL]     return o; [EOL] }
@Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) { [EOL]     ObjectNode o = createSchemaNode("array", true); [EOL]     ObjectNode itemSchema = createSchemaNode("string"); [EOL]     itemSchema.put("type", "string"); [EOL]     o.put("items", itemSchema); [EOL]     return o; [EOL] }
@Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) { [EOL]     ObjectNode o = createSchemaNode("array", true); [EOL]     o.put("items", createSchemaNode("integer")); [EOL]     return o; [EOL] }
@Override [EOL] public void serializeContents(long[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_valueTypeSerializer != null) { [EOL]         for (int i = 0, len = value.length; i < len; ++i) { [EOL]             _valueTypeSerializer.writeTypePrefixForScalar(null, jgen, Long.TYPE); [EOL]             jgen.writeNumber(value[i]); [EOL]             _valueTypeSerializer.writeTypeSuffixForScalar(null, jgen); [EOL]         } [EOL]         return; [EOL]     } [EOL]     for (int i = 0, len = value.length; i < len; ++i) { [EOL]         jgen.writeNumber(value[i]); [EOL]     } [EOL] }
@Override [EOL] public void serializeContents(long[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_valueTypeSerializer != null) { [EOL]         for (int i = 0, len = value.length; i < len; ++i) { [EOL]             _valueTypeSerializer.writeTypePrefixForScalar(null, jgen, Long.TYPE); [EOL]             jgen.writeNumber(value[i]); [EOL]             _valueTypeSerializer.writeTypeSuffixForScalar(null, jgen); [EOL]         } [EOL]         return; [EOL]     } [EOL]     for (int i = 0, len = value.length; i < len; ++i) { [EOL]         jgen.writeNumber(value[i]); [EOL]     } [EOL] }
@Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) { [EOL]     ObjectNode o = createSchemaNode("array", true); [EOL]     o.put("items", createSchemaNode("number", true)); [EOL]     return o; [EOL] }
@Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) { [EOL]     ObjectNode o = createSchemaNode("array", true); [EOL]     o.put("items", createSchemaNode("number")); [EOL]     return o; [EOL] }
@Override [EOL] public MapType withContentValueHandler(Object h) { [EOL]     return new MapType(_class, _keyType, _valueType.withValueHandler(h), _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public MapType withContentValueHandler(Object h) { [EOL]     return new MapType(_class, _keyType, _valueType.withValueHandler(h), _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public MapType withKeyValueHandler(Object h) { [EOL]     return new MapType(_class, _keyType.withValueHandler(h), _valueType, _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public MapType withKeyValueHandler(Object h) { [EOL]     return new MapType(_class, _keyType.withValueHandler(h), _valueType, _valueHandler, _typeHandler, _asStatic); [EOL] }
@Override [EOL] public JsonDeserializer<?> findBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == QName.class) { [EOL]         return QNameDeserializer.instance; [EOL]     } [EOL]     if (raw == XMLGregorianCalendar.class) { [EOL]         return GregorianCalendarDeserializer.instance; [EOL]     } [EOL]     if (raw == Duration.class) { [EOL]         return DurationDeserializer.instance; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonDeserializer<?> findBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == QName.class) { [EOL]         return QNameDeserializer.instance; [EOL]     } [EOL]     if (raw == XMLGregorianCalendar.class) { [EOL]         return GregorianCalendarDeserializer.instance; [EOL]     } [EOL]     if (raw == Duration.class) { [EOL]         return DurationDeserializer.instance; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonDeserializer<?> findBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == QName.class) { [EOL]         return QNameDeserializer.instance; [EOL]     } [EOL]     if (raw == XMLGregorianCalendar.class) { [EOL]         return GregorianCalendarDeserializer.instance; [EOL]     } [EOL]     if (raw == Duration.class) { [EOL]         return DurationDeserializer.instance; [EOL]     } [EOL]     return null; [EOL] }
@Override [EOL] public JsonDeserializer<?> findBeanDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) { [EOL]     Class<?> raw = type.getRawClass(); [EOL]     if (raw == QName.class) { [EOL]         return QNameDeserializer.instance; [EOL]     } [EOL]     if (raw == XMLGregorianCalendar.class) { [EOL]         return GregorianCalendarDeserializer.instance; [EOL]     } [EOL]     if (raw == Duration.class) { [EOL]         return DurationDeserializer.instance; [EOL]     } [EOL]     return null; [EOL] }
public DurationDeserializer() { [EOL]     super(Duration.class); [EOL] }
public GregorianCalendarDeserializer() { [EOL]     super(XMLGregorianCalendar.class); [EOL] }
public QNameDeserializer() { [EOL]     super(QName.class); [EOL] }
@Override [EOL] protected QName _deserialize(String value, DeserializationContext ctxt) throws IllegalArgumentException { [EOL]     return QName.valueOf(value); [EOL] }
@Override [EOL] protected QName _deserialize(String value, DeserializationContext ctxt) throws IllegalArgumentException { [EOL]     return QName.valueOf(value); [EOL] }
public Class<?> getPropertyType() { [EOL]     if (_accessorMethod != null) { [EOL]         return _accessorMethod.getReturnType(); [EOL]     } [EOL]     return _field.getType(); [EOL] }
public Class<?> getPropertyType() { [EOL]     if (_accessorMethod != null) { [EOL]         return _accessorMethod.getReturnType(); [EOL]     } [EOL]     return _field.getType(); [EOL] }
@Override [EOL] public Object[] deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException, JsonProcessingException { [EOL]     return (Object[]) typeDeserializer.deserializeTypedFromArray(jp, ctxt); [EOL] }
public PropertyName findWrapperName(Annotated ann) { [EOL]     return null; [EOL] }
public String findEnumValue(Enum<?> value) { [EOL]     return value.name(); [EOL] }
protected FromStringDeserializer(Class<?> vc) { [EOL]     super(vc); [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public final T deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     String text = jp.getValueAsString(); [EOL]     if (text != null) { [EOL]         if (text.length() == 0 || (text = text.trim()).length() == 0) { [EOL]             return null; [EOL]         } [EOL]         try { [EOL]             T result = _deserialize(text, ctxt); [EOL]             if (result != null) { [EOL]                 return result; [EOL]             } [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid textual representation"); [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) { [EOL]             return null; [EOL]         } [EOL]         if (_valueClass.isAssignableFrom(ob.getClass())) { [EOL]             return (T) ob; [EOL]         } [EOL]         return _deserializeEmbedded(ob, ctxt); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass); [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public final T deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     String text = jp.getValueAsString(); [EOL]     if (text != null) { [EOL]         if (text.length() == 0 || (text = text.trim()).length() == 0) { [EOL]             return null; [EOL]         } [EOL]         try { [EOL]             T result = _deserialize(text, ctxt); [EOL]             if (result != null) { [EOL]                 return result; [EOL]             } [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid textual representation"); [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) { [EOL]             return null; [EOL]         } [EOL]         if (_valueClass.isAssignableFrom(ob.getClass())) { [EOL]             return (T) ob; [EOL]         } [EOL]         return _deserializeEmbedded(ob, ctxt); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass); [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public final T deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     String text = jp.getValueAsString(); [EOL]     if (text != null) { [EOL]         if (text.length() == 0 || (text = text.trim()).length() == 0) { [EOL]             return null; [EOL]         } [EOL]         try { [EOL]             T result = _deserialize(text, ctxt); [EOL]             if (result != null) { [EOL]                 return result; [EOL]             } [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid textual representation"); [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) { [EOL]             return null; [EOL]         } [EOL]         if (_valueClass.isAssignableFrom(ob.getClass())) { [EOL]             return (T) ob; [EOL]         } [EOL]         return _deserializeEmbedded(ob, ctxt); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass); [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public final T deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     String text = jp.getValueAsString(); [EOL]     if (text != null) { [EOL]         if (text.length() == 0 || (text = text.trim()).length() == 0) { [EOL]             return null; [EOL]         } [EOL]         try { [EOL]             T result = _deserialize(text, ctxt); [EOL]             if (result != null) { [EOL]                 return result; [EOL]             } [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid textual representation"); [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) { [EOL]             return null; [EOL]         } [EOL]         if (_valueClass.isAssignableFrom(ob.getClass())) { [EOL]             return (T) ob; [EOL]         } [EOL]         return _deserializeEmbedded(ob, ctxt); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass); [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public final T deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     String text = jp.getValueAsString(); [EOL]     if (text != null) { [EOL]         if (text.length() == 0 || (text = text.trim()).length() == 0) { [EOL]             return null; [EOL]         } [EOL]         try { [EOL]             T result = _deserialize(text, ctxt); [EOL]             if (result != null) { [EOL]                 return result; [EOL]             } [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid textual representation"); [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) { [EOL]             return null; [EOL]         } [EOL]         if (_valueClass.isAssignableFrom(ob.getClass())) { [EOL]             return (T) ob; [EOL]         } [EOL]         return _deserializeEmbedded(ob, ctxt); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass); [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public final T deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     String text = jp.getValueAsString(); [EOL]     if (text != null) { [EOL]         if (text.length() == 0 || (text = text.trim()).length() == 0) { [EOL]             return null; [EOL]         } [EOL]         try { [EOL]             T result = _deserialize(text, ctxt); [EOL]             if (result != null) { [EOL]                 return result; [EOL]             } [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid textual representation"); [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) { [EOL]             return null; [EOL]         } [EOL]         if (_valueClass.isAssignableFrom(ob.getClass())) { [EOL]             return (T) ob; [EOL]         } [EOL]         return _deserializeEmbedded(ob, ctxt); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass); [EOL] }
@SuppressWarnings("unchecked") [EOL] @Override [EOL] public final T deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     String text = jp.getValueAsString(); [EOL]     if (text != null) { [EOL]         if (text.length() == 0 || (text = text.trim()).length() == 0) { [EOL]             return null; [EOL]         } [EOL]         try { [EOL]             T result = _deserialize(text, ctxt); [EOL]             if (result != null) { [EOL]                 return result; [EOL]             } [EOL]         } catch (IllegalArgumentException iae) { [EOL]         } [EOL]         throw ctxt.weirdStringException(text, _valueClass, "not a valid textual representation"); [EOL]     } [EOL]     if (jp.getCurrentToken() == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         Object ob = jp.getEmbeddedObject(); [EOL]         if (ob == null) { [EOL]             return null; [EOL]         } [EOL]         if (_valueClass.isAssignableFrom(ob.getClass())) { [EOL]             return (T) ob; [EOL]         } [EOL]         return _deserializeEmbedded(ob, ctxt); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected MapSerializer(HashSet<String> ignoredEntries, JavaType keyType, JavaType valueType, boolean valueTypeIsStatic, TypeSerializer vts, JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer) { [EOL]     super(Map.class, false); [EOL]     _ignoredEntries = ignoredEntries; [EOL]     _keyType = keyType; [EOL]     _valueType = valueType; [EOL]     _valueTypeIsStatic = valueTypeIsStatic; [EOL]     _valueTypeSerializer = vts; [EOL]     _keySerializer = (JsonSerializer<Object>) keySerializer; [EOL]     _valueSerializer = (JsonSerializer<Object>) valueSerializer; [EOL]     _dynamicValueSerializers = PropertySerializerMap.emptyMap(); [EOL]     _property = null; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected MapSerializer(HashSet<String> ignoredEntries, JavaType keyType, JavaType valueType, boolean valueTypeIsStatic, TypeSerializer vts, JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer) { [EOL]     super(Map.class, false); [EOL]     _ignoredEntries = ignoredEntries; [EOL]     _keyType = keyType; [EOL]     _valueType = valueType; [EOL]     _valueTypeIsStatic = valueTypeIsStatic; [EOL]     _valueTypeSerializer = vts; [EOL]     _keySerializer = (JsonSerializer<Object>) keySerializer; [EOL]     _valueSerializer = (JsonSerializer<Object>) valueSerializer; [EOL]     _dynamicValueSerializers = PropertySerializerMap.emptyMap(); [EOL]     _property = null; [EOL] }
public static MapSerializer construct(String[] ignoredList, JavaType mapType, boolean staticValueType, TypeSerializer vts, JsonSerializer<Object> keySerializer, JsonSerializer<Object> valueSerializer) { [EOL]     HashSet<String> ignoredEntries = toSet(ignoredList); [EOL]     JavaType keyType, valueType; [EOL]     if (mapType == null) { [EOL]         keyType = valueType = UNSPECIFIED_TYPE; [EOL]     } else { [EOL]         keyType = mapType.getKeyType(); [EOL]         valueType = mapType.getContentType(); [EOL]     } [EOL]     if (!staticValueType) { [EOL]         staticValueType = (valueType != null && valueType.isFinal()); [EOL]     } [EOL]     return new MapSerializer(ignoredEntries, keyType, valueType, staticValueType, vts, keySerializer, valueSerializer); [EOL] }
public static MapSerializer construct(String[] ignoredList, JavaType mapType, boolean staticValueType, TypeSerializer vts, JsonSerializer<Object> keySerializer, JsonSerializer<Object> valueSerializer) { [EOL]     HashSet<String> ignoredEntries = toSet(ignoredList); [EOL]     JavaType keyType, valueType; [EOL]     if (mapType == null) { [EOL]         keyType = valueType = UNSPECIFIED_TYPE; [EOL]     } else { [EOL]         keyType = mapType.getKeyType(); [EOL]         valueType = mapType.getContentType(); [EOL]     } [EOL]     if (!staticValueType) { [EOL]         staticValueType = (valueType != null && valueType.isFinal()); [EOL]     } [EOL]     return new MapSerializer(ignoredEntries, keyType, valueType, staticValueType, vts, keySerializer, valueSerializer); [EOL] }
public static MapSerializer construct(String[] ignoredList, JavaType mapType, boolean staticValueType, TypeSerializer vts, JsonSerializer<Object> keySerializer, JsonSerializer<Object> valueSerializer) { [EOL]     HashSet<String> ignoredEntries = toSet(ignoredList); [EOL]     JavaType keyType, valueType; [EOL]     if (mapType == null) { [EOL]         keyType = valueType = UNSPECIFIED_TYPE; [EOL]     } else { [EOL]         keyType = mapType.getKeyType(); [EOL]         valueType = mapType.getContentType(); [EOL]     } [EOL]     if (!staticValueType) { [EOL]         staticValueType = (valueType != null && valueType.isFinal()); [EOL]     } [EOL]     return new MapSerializer(ignoredEntries, keyType, valueType, staticValueType, vts, keySerializer, valueSerializer); [EOL] }
private static HashSet<String> toSet(String[] ignoredEntries) { [EOL]     if (ignoredEntries == null || ignoredEntries.length == 0) { [EOL]         return null; [EOL]     } [EOL]     HashSet<String> result = new HashSet<String>(ignoredEntries.length); [EOL]     for (String prop : ignoredEntries) { [EOL]         result.add(prop); [EOL]     } [EOL]     return result; [EOL] }
private static HashSet<String> toSet(String[] ignoredEntries) { [EOL]     if (ignoredEntries == null || ignoredEntries.length == 0) { [EOL]         return null; [EOL]     } [EOL]     HashSet<String> result = new HashSet<String>(ignoredEntries.length); [EOL]     for (String prop : ignoredEntries) { [EOL]         result.add(prop); [EOL]     } [EOL]     return result; [EOL] }
private static HashSet<String> toSet(String[] ignoredEntries) { [EOL]     if (ignoredEntries == null || ignoredEntries.length == 0) { [EOL]         return null; [EOL]     } [EOL]     HashSet<String> result = new HashSet<String>(ignoredEntries.length); [EOL]     for (String prop : ignoredEntries) { [EOL]         result.add(prop); [EOL]     } [EOL]     return result; [EOL] }
public void serializeFields(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedFields(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final JsonSerializer<Object> keySerializer = _keySerializer; [EOL]     final HashSet<String> ignored = _ignoredEntries; [EOL]     final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES); [EOL]     PropertySerializerMap serializers = _dynamicValueSerializers; [EOL]     for (Map.Entry<?, ?> entry : value.entrySet()) { [EOL]         Object valueElem = entry.getValue(); [EOL]         Object keyElem = entry.getKey(); [EOL]         if (keyElem == null) { [EOL]             provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider); [EOL]         } else { [EOL]             if (skipNulls && valueElem == null) [EOL]                 continue; [EOL]             if (ignored != null && ignored.contains(keyElem)) [EOL]                 continue; [EOL]             keySerializer.serialize(keyElem, jgen, provider); [EOL]         } [EOL]         if (valueElem == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]         } else { [EOL]             Class<?> cc = valueElem.getClass(); [EOL]             JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]             if (serializer == null) { [EOL]                 if (_valueType.hasGenericTypes()) { [EOL]                     serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_valueType, cc), provider); [EOL]                 } else { [EOL]                     serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                 } [EOL]                 serializers = _dynamicValueSerializers; [EOL]             } [EOL]             try { [EOL]                 serializer.serialize(valueElem, jgen, provider); [EOL]             } catch (Exception e) { [EOL]                 String keyDesc = "" + keyElem; [EOL]                 wrapAndThrow(provider, e, value, keyDesc); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void serializeFields(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedFields(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final JsonSerializer<Object> keySerializer = _keySerializer; [EOL]     final HashSet<String> ignored = _ignoredEntries; [EOL]     final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES); [EOL]     PropertySerializerMap serializers = _dynamicValueSerializers; [EOL]     for (Map.Entry<?, ?> entry : value.entrySet()) { [EOL]         Object valueElem = entry.getValue(); [EOL]         Object keyElem = entry.getKey(); [EOL]         if (keyElem == null) { [EOL]             provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider); [EOL]         } else { [EOL]             if (skipNulls && valueElem == null) [EOL]                 continue; [EOL]             if (ignored != null && ignored.contains(keyElem)) [EOL]                 continue; [EOL]             keySerializer.serialize(keyElem, jgen, provider); [EOL]         } [EOL]         if (valueElem == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]         } else { [EOL]             Class<?> cc = valueElem.getClass(); [EOL]             JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]             if (serializer == null) { [EOL]                 if (_valueType.hasGenericTypes()) { [EOL]                     serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_valueType, cc), provider); [EOL]                 } else { [EOL]                     serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                 } [EOL]                 serializers = _dynamicValueSerializers; [EOL]             } [EOL]             try { [EOL]                 serializer.serialize(valueElem, jgen, provider); [EOL]             } catch (Exception e) { [EOL]                 String keyDesc = "" + keyElem; [EOL]                 wrapAndThrow(provider, e, value, keyDesc); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void serializeFields(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedFields(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final JsonSerializer<Object> keySerializer = _keySerializer; [EOL]     final HashSet<String> ignored = _ignoredEntries; [EOL]     final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES); [EOL]     PropertySerializerMap serializers = _dynamicValueSerializers; [EOL]     for (Map.Entry<?, ?> entry : value.entrySet()) { [EOL]         Object valueElem = entry.getValue(); [EOL]         Object keyElem = entry.getKey(); [EOL]         if (keyElem == null) { [EOL]             provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider); [EOL]         } else { [EOL]             if (skipNulls && valueElem == null) [EOL]                 continue; [EOL]             if (ignored != null && ignored.contains(keyElem)) [EOL]                 continue; [EOL]             keySerializer.serialize(keyElem, jgen, provider); [EOL]         } [EOL]         if (valueElem == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]         } else { [EOL]             Class<?> cc = valueElem.getClass(); [EOL]             JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]             if (serializer == null) { [EOL]                 if (_valueType.hasGenericTypes()) { [EOL]                     serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_valueType, cc), provider); [EOL]                 } else { [EOL]                     serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                 } [EOL]                 serializers = _dynamicValueSerializers; [EOL]             } [EOL]             try { [EOL]                 serializer.serialize(valueElem, jgen, provider); [EOL]             } catch (Exception e) { [EOL]                 String keyDesc = "" + keyElem; [EOL]                 wrapAndThrow(provider, e, value, keyDesc); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void serializeFields(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedFields(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final JsonSerializer<Object> keySerializer = _keySerializer; [EOL]     final HashSet<String> ignored = _ignoredEntries; [EOL]     final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES); [EOL]     PropertySerializerMap serializers = _dynamicValueSerializers; [EOL]     for (Map.Entry<?, ?> entry : value.entrySet()) { [EOL]         Object valueElem = entry.getValue(); [EOL]         Object keyElem = entry.getKey(); [EOL]         if (keyElem == null) { [EOL]             provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider); [EOL]         } else { [EOL]             if (skipNulls && valueElem == null) [EOL]                 continue; [EOL]             if (ignored != null && ignored.contains(keyElem)) [EOL]                 continue; [EOL]             keySerializer.serialize(keyElem, jgen, provider); [EOL]         } [EOL]         if (valueElem == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]         } else { [EOL]             Class<?> cc = valueElem.getClass(); [EOL]             JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]             if (serializer == null) { [EOL]                 if (_valueType.hasGenericTypes()) { [EOL]                     serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_valueType, cc), provider); [EOL]                 } else { [EOL]                     serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                 } [EOL]                 serializers = _dynamicValueSerializers; [EOL]             } [EOL]             try { [EOL]                 serializer.serialize(valueElem, jgen, provider); [EOL]             } catch (Exception e) { [EOL]                 String keyDesc = "" + keyElem; [EOL]                 wrapAndThrow(provider, e, value, keyDesc); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void serializeFields(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedFields(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final JsonSerializer<Object> keySerializer = _keySerializer; [EOL]     final HashSet<String> ignored = _ignoredEntries; [EOL]     final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES); [EOL]     PropertySerializerMap serializers = _dynamicValueSerializers; [EOL]     for (Map.Entry<?, ?> entry : value.entrySet()) { [EOL]         Object valueElem = entry.getValue(); [EOL]         Object keyElem = entry.getKey(); [EOL]         if (keyElem == null) { [EOL]             provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider); [EOL]         } else { [EOL]             if (skipNulls && valueElem == null) [EOL]                 continue; [EOL]             if (ignored != null && ignored.contains(keyElem)) [EOL]                 continue; [EOL]             keySerializer.serialize(keyElem, jgen, provider); [EOL]         } [EOL]         if (valueElem == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]         } else { [EOL]             Class<?> cc = valueElem.getClass(); [EOL]             JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]             if (serializer == null) { [EOL]                 if (_valueType.hasGenericTypes()) { [EOL]                     serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_valueType, cc), provider); [EOL]                 } else { [EOL]                     serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                 } [EOL]                 serializers = _dynamicValueSerializers; [EOL]             } [EOL]             try { [EOL]                 serializer.serialize(valueElem, jgen, provider); [EOL]             } catch (Exception e) { [EOL]                 String keyDesc = "" + keyElem; [EOL]                 wrapAndThrow(provider, e, value, keyDesc); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void serializeFields(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedFields(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final JsonSerializer<Object> keySerializer = _keySerializer; [EOL]     final HashSet<String> ignored = _ignoredEntries; [EOL]     final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES); [EOL]     PropertySerializerMap serializers = _dynamicValueSerializers; [EOL]     for (Map.Entry<?, ?> entry : value.entrySet()) { [EOL]         Object valueElem = entry.getValue(); [EOL]         Object keyElem = entry.getKey(); [EOL]         if (keyElem == null) { [EOL]             provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider); [EOL]         } else { [EOL]             if (skipNulls && valueElem == null) [EOL]                 continue; [EOL]             if (ignored != null && ignored.contains(keyElem)) [EOL]                 continue; [EOL]             keySerializer.serialize(keyElem, jgen, provider); [EOL]         } [EOL]         if (valueElem == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]         } else { [EOL]             Class<?> cc = valueElem.getClass(); [EOL]             JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]             if (serializer == null) { [EOL]                 if (_valueType.hasGenericTypes()) { [EOL]                     serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_valueType, cc), provider); [EOL]                 } else { [EOL]                     serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                 } [EOL]                 serializers = _dynamicValueSerializers; [EOL]             } [EOL]             try { [EOL]                 serializer.serialize(valueElem, jgen, provider); [EOL]             } catch (Exception e) { [EOL]                 String keyDesc = "" + keyElem; [EOL]                 wrapAndThrow(provider, e, value, keyDesc); [EOL]             } [EOL]         } [EOL]     } [EOL] }
public void serializeFields(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     if (_valueTypeSerializer != null) { [EOL]         serializeTypedFields(value, jgen, provider); [EOL]         return; [EOL]     } [EOL]     final JsonSerializer<Object> keySerializer = _keySerializer; [EOL]     final HashSet<String> ignored = _ignoredEntries; [EOL]     final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES); [EOL]     PropertySerializerMap serializers = _dynamicValueSerializers; [EOL]     for (Map.Entry<?, ?> entry : value.entrySet()) { [EOL]         Object valueElem = entry.getValue(); [EOL]         Object keyElem = entry.getKey(); [EOL]         if (keyElem == null) { [EOL]             provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider); [EOL]         } else { [EOL]             if (skipNulls && valueElem == null) [EOL]                 continue; [EOL]             if (ignored != null && ignored.contains(keyElem)) [EOL]                 continue; [EOL]             keySerializer.serialize(keyElem, jgen, provider); [EOL]         } [EOL]         if (valueElem == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]         } else { [EOL]             Class<?> cc = valueElem.getClass(); [EOL]             JsonSerializer<Object> serializer = serializers.serializerFor(cc); [EOL]             if (serializer == null) { [EOL]                 if (_valueType.hasGenericTypes()) { [EOL]                     serializer = _findAndAddDynamic(serializers, provider.constructSpecializedType(_valueType, cc), provider); [EOL]                 } else { [EOL]                     serializer = _findAndAddDynamic(serializers, cc, provider); [EOL]                 } [EOL]                 serializers = _dynamicValueSerializers; [EOL]             } [EOL]             try { [EOL]                 serializer.serialize(valueElem, jgen, provider); [EOL]             } catch (Exception e) { [EOL]                 String keyDesc = "" + keyElem; [EOL]                 wrapAndThrow(provider, e, value, keyDesc); [EOL]             } [EOL]         } [EOL]     } [EOL] }
protected void serializeTypedFields(Map<?, ?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException { [EOL]     final JsonSerializer<Object> keySerializer = _keySerializer; [EOL]     JsonSerializer<Object> prevValueSerializer = null; [EOL]     Class<?> prevValueClass = null; [EOL]     final HashSet<String> ignored = _ignoredEntries; [EOL]     final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES); [EOL]     for (Map.Entry<?, ?> entry : value.entrySet()) { [EOL]         Object valueElem = entry.getValue(); [EOL]         Object keyElem = entry.getKey(); [EOL]         if (keyElem == null) { [EOL]             provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider); [EOL]         } else { [EOL]             if (skipNulls && valueElem == null) [EOL]                 continue; [EOL]             if (ignored != null && ignored.contains(keyElem)) [EOL]                 continue; [EOL]             keySerializer.serialize(keyElem, jgen, provider); [EOL]         } [EOL]         if (valueElem == null) { [EOL]             provider.defaultSerializeNull(jgen); [EOL]         } else { [EOL]             Class<?> cc = valueElem.getClass(); [EOL]             JsonSerializer<Object> currSerializer; [EOL]             if (cc == prevValueClass) { [EOL]                 currSerializer = prevValueSerializer; [EOL]             } else { [EOL]                 currSerializer = provider.findValueSerializer(cc, _property); [EOL]                 prevValueSerializer = currSerializer; [EOL]                 prevValueClass = cc; [EOL]             } [EOL]             try { [EOL]                 currSerializer.serializeWithType(valueElem, jgen, provider, _valueTypeSerializer); [EOL]             } catch (Exception e) { [EOL]                 String keyDesc = "" + keyElem; [EOL]                 wrapAndThrow(provider, e, value, keyDesc); [EOL]             } [EOL]         } [EOL]     } [EOL] }
@Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) { [EOL]     ObjectNode o = createSchemaNode("object", true); [EOL]     return o; [EOL] }
@Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) { [EOL]     ObjectNode o = createSchemaNode("object", true); [EOL]     return o; [EOL] }
@Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) { [EOL]     ObjectNode o = createSchemaNode("object", true); [EOL]     return o; [EOL] }
@Override [EOL] public JsonNode getSchema(SerializerProvider provider, Type typeHint) { [EOL]     ObjectNode o = createSchemaNode("object", true); [EOL]     return o; [EOL] }
@SuppressWarnings("unchecked") [EOL] protected MapDeserializer withResolved(KeyDeserializer keyDeser, TypeDeserializer valueTypeDeser, JsonDeserializer<?> valueDeser, HashSet<String> ignorable) { [EOL]     if ((_keyDeserializer == keyDeser) && (_valueDeserializer == valueDeser) && (_valueTypeDeserializer == valueTypeDeser) && (_ignorableProperties == ignorable)) { [EOL]         return this; [EOL]     } [EOL]     return new MapDeserializer(this, keyDeser, (JsonDeserializer<Object>) valueDeser, valueTypeDeser, ignorable); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected MapDeserializer withResolved(KeyDeserializer keyDeser, TypeDeserializer valueTypeDeser, JsonDeserializer<?> valueDeser, HashSet<String> ignorable) { [EOL]     if ((_keyDeserializer == keyDeser) && (_valueDeserializer == valueDeser) && (_valueTypeDeserializer == valueTypeDeser) && (_ignorableProperties == ignorable)) { [EOL]         return this; [EOL]     } [EOL]     return new MapDeserializer(this, keyDeser, (JsonDeserializer<Object>) valueDeser, valueTypeDeser, ignorable); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected MapDeserializer withResolved(KeyDeserializer keyDeser, TypeDeserializer valueTypeDeser, JsonDeserializer<?> valueDeser, HashSet<String> ignorable) { [EOL]     if ((_keyDeserializer == keyDeser) && (_valueDeserializer == valueDeser) && (_valueTypeDeserializer == valueTypeDeser) && (_ignorableProperties == ignorable)) { [EOL]         return this; [EOL]     } [EOL]     return new MapDeserializer(this, keyDeser, (JsonDeserializer<Object>) valueDeser, valueTypeDeser, ignorable); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected MapDeserializer withResolved(KeyDeserializer keyDeser, TypeDeserializer valueTypeDeser, JsonDeserializer<?> valueDeser, HashSet<String> ignorable) { [EOL]     if ((_keyDeserializer == keyDeser) && (_valueDeserializer == valueDeser) && (_valueTypeDeserializer == valueTypeDeser) && (_ignorableProperties == ignorable)) { [EOL]         return this; [EOL]     } [EOL]     return new MapDeserializer(this, keyDeser, (JsonDeserializer<Object>) valueDeser, valueTypeDeser, ignorable); [EOL] }
@SuppressWarnings("unchecked") [EOL] protected MapDeserializer withResolved(KeyDeserializer keyDeser, TypeDeserializer valueTypeDeser, JsonDeserializer<?> valueDeser, HashSet<String> ignorable) { [EOL]     if ((_keyDeserializer == keyDeser) && (_valueDeserializer == valueDeser) && (_valueTypeDeserializer == valueTypeDeser) && (_ignorableProperties == ignorable)) { [EOL]         return this; [EOL]     } [EOL]     return new MapDeserializer(this, keyDeser, (JsonDeserializer<Object>) valueDeser, valueTypeDeser, ignorable); [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _mapType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, null); [EOL]     } [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]     } [EOL]     _standardStringKey = _isStdKeyDeser(_mapType, _keyDeserializer); [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _mapType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, null); [EOL]     } [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]     } [EOL]     _standardStringKey = _isStdKeyDeser(_mapType, _keyDeserializer); [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _mapType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, null); [EOL]     } [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]     } [EOL]     _standardStringKey = _isStdKeyDeser(_mapType, _keyDeserializer); [EOL] }
@Override [EOL] public void resolve(DeserializationContext ctxt) throws JsonMappingException { [EOL]     if (_valueInstantiator.canCreateUsingDelegate()) { [EOL]         JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig()); [EOL]         if (delegateType == null) { [EOL]             throw new IllegalArgumentException("Invalid delegate-creator definition for " + _mapType + ": value instantiator (" + _valueInstantiator.getClass().getName() + ") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'"); [EOL]         } [EOL]         _delegateDeserializer = findDeserializer(ctxt, delegateType, null); [EOL]     } [EOL]     if (_valueInstantiator.canCreateFromObjectWith()) { [EOL]         SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig()); [EOL]         _propertyBasedCreator = PropertyBasedCreator.construct(ctxt, _valueInstantiator, creatorProps); [EOL]     } [EOL]     _standardStringKey = _isStdKeyDeser(_mapType, _keyDeserializer); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     KeyDeserializer kd = _keyDeserializer; [EOL]     if (kd == null) { [EOL]         kd = ctxt.findKeyDeserializer(_mapType.getKeyType(), property); [EOL]     } else { [EOL]         if (kd instanceof ContextualKeyDeserializer) { [EOL]             kd = ((ContextualKeyDeserializer) kd).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     JsonDeserializer<?> vd = _valueDeserializer; [EOL]     vd = findConvertingContentDeserializer(ctxt, property, vd); [EOL]     if (vd == null) { [EOL]         vd = ctxt.findContextualValueDeserializer(_mapType.getContentType(), property); [EOL]     } else { [EOL]         if (vd instanceof ContextualDeserializer) { [EOL]             vd = ((ContextualDeserializer) vd).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer vtd = _valueTypeDeserializer; [EOL]     if (vtd != null) { [EOL]         vtd = vtd.forProperty(property); [EOL]     } [EOL]     HashSet<String> ignored = _ignorableProperties; [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(kd, vtd, vd, ignored); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     KeyDeserializer kd = _keyDeserializer; [EOL]     if (kd == null) { [EOL]         kd = ctxt.findKeyDeserializer(_mapType.getKeyType(), property); [EOL]     } else { [EOL]         if (kd instanceof ContextualKeyDeserializer) { [EOL]             kd = ((ContextualKeyDeserializer) kd).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     JsonDeserializer<?> vd = _valueDeserializer; [EOL]     vd = findConvertingContentDeserializer(ctxt, property, vd); [EOL]     if (vd == null) { [EOL]         vd = ctxt.findContextualValueDeserializer(_mapType.getContentType(), property); [EOL]     } else { [EOL]         if (vd instanceof ContextualDeserializer) { [EOL]             vd = ((ContextualDeserializer) vd).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer vtd = _valueTypeDeserializer; [EOL]     if (vtd != null) { [EOL]         vtd = vtd.forProperty(property); [EOL]     } [EOL]     HashSet<String> ignored = _ignorableProperties; [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(kd, vtd, vd, ignored); [EOL] }
@Override [EOL] public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException { [EOL]     KeyDeserializer kd = _keyDeserializer; [EOL]     if (kd == null) { [EOL]         kd = ctxt.findKeyDeserializer(_mapType.getKeyType(), property); [EOL]     } else { [EOL]         if (kd instanceof ContextualKeyDeserializer) { [EOL]             kd = ((ContextualKeyDeserializer) kd).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     JsonDeserializer<?> vd = _valueDeserializer; [EOL]     vd = findConvertingContentDeserializer(ctxt, property, vd); [EOL]     if (vd == null) { [EOL]         vd = ctxt.findContextualValueDeserializer(_mapType.getContentType(), property); [EOL]     } else { [EOL]         if (vd instanceof ContextualDeserializer) { [EOL]             vd = ((ContextualDeserializer) vd).createContextual(ctxt, property); [EOL]         } [EOL]     } [EOL]     TypeDeserializer vtd = _valueTypeDeserializer; [EOL]     if (vtd != null) { [EOL]         vtd = vtd.forProperty(property); [EOL]     } [EOL]     HashSet<String> ignored = _ignorableProperties; [EOL]     AnnotationIntrospector intr = ctxt.getAnnotationIntrospector(); [EOL]     if (intr != null && property != null) { [EOL]         String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember()); [EOL]         if (moreToIgnore != null) { [EOL]             ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored); [EOL]             for (String str : moreToIgnore) { [EOL]                 ignored.add(str); [EOL]             } [EOL]         } [EOL]     } [EOL]     return withResolved(kd, vtd, vd, ignored); [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingCreator(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Map<Object, Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (!_hasDefaultCreator) { [EOL]         throw ctxt.instantiationException(getMapClass(), "No default constructor found"); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) { [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             return (Map<Object, Object>) _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]         } [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     final Map<Object, Object> result = (Map<Object, Object>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingCreator(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Map<Object, Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (!_hasDefaultCreator) { [EOL]         throw ctxt.instantiationException(getMapClass(), "No default constructor found"); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) { [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             return (Map<Object, Object>) _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]         } [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     final Map<Object, Object> result = (Map<Object, Object>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingCreator(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Map<Object, Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (!_hasDefaultCreator) { [EOL]         throw ctxt.instantiationException(getMapClass(), "No default constructor found"); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) { [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             return (Map<Object, Object>) _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]         } [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     final Map<Object, Object> result = (Map<Object, Object>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingCreator(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Map<Object, Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (!_hasDefaultCreator) { [EOL]         throw ctxt.instantiationException(getMapClass(), "No default constructor found"); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) { [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             return (Map<Object, Object>) _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]         } [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     final Map<Object, Object> result = (Map<Object, Object>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingCreator(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Map<Object, Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (!_hasDefaultCreator) { [EOL]         throw ctxt.instantiationException(getMapClass(), "No default constructor found"); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) { [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             return (Map<Object, Object>) _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]         } [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     final Map<Object, Object> result = (Map<Object, Object>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingCreator(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Map<Object, Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (!_hasDefaultCreator) { [EOL]         throw ctxt.instantiationException(getMapClass(), "No default constructor found"); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) { [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             return (Map<Object, Object>) _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]         } [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     final Map<Object, Object> result = (Map<Object, Object>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
@Override [EOL] @SuppressWarnings("unchecked") [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     if (_propertyBasedCreator != null) { [EOL]         return _deserializeUsingCreator(jp, ctxt); [EOL]     } [EOL]     if (_delegateDeserializer != null) { [EOL]         return (Map<Object, Object>) _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt)); [EOL]     } [EOL]     if (!_hasDefaultCreator) { [EOL]         throw ctxt.instantiationException(getMapClass(), "No default constructor found"); [EOL]     } [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) { [EOL]         if (t == JsonToken.VALUE_STRING) { [EOL]             return (Map<Object, Object>) _valueInstantiator.createFromString(ctxt, jp.getText()); [EOL]         } [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     final Map<Object, Object> result = (Map<Object, Object>) _valueInstantiator.createUsingDefault(ctxt); [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
@Override [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME) { [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
@Override [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME) { [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
@Override [EOL] public Map<Object, Object> deserialize(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME) { [EOL]         throw ctxt.mappingException(getMapClass()); [EOL]     } [EOL]     if (_standardStringKey) { [EOL]         _readAndBindStringMap(jp, ctxt, result); [EOL]         return result; [EOL]     } [EOL]     _readAndBind(jp, ctxt, result); [EOL]     return result; [EOL] }
protected final void _readAndBind(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     final KeyDeserializer keyDes = _keyDeserializer; [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         Object key = keyDes.deserializeKey(fieldName, ctxt); [EOL]         t = jp.nextToken(); [EOL]         if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(key, value); [EOL]     } [EOL] }
protected final void _readAndBind(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     final KeyDeserializer keyDes = _keyDeserializer; [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         Object key = keyDes.deserializeKey(fieldName, ctxt); [EOL]         t = jp.nextToken(); [EOL]         if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(key, value); [EOL]     } [EOL] }
protected final void _readAndBind(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     final KeyDeserializer keyDes = _keyDeserializer; [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         Object key = keyDes.deserializeKey(fieldName, ctxt); [EOL]         t = jp.nextToken(); [EOL]         if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(key, value); [EOL]     } [EOL] }
protected final void _readAndBind(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     final KeyDeserializer keyDes = _keyDeserializer; [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         Object key = keyDes.deserializeKey(fieldName, ctxt); [EOL]         t = jp.nextToken(); [EOL]         if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(key, value); [EOL]     } [EOL] }
protected final void _readAndBindStringMap(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         t = jp.nextToken(); [EOL]         if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(fieldName, value); [EOL]     } [EOL] }
protected final void _readAndBindStringMap(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         t = jp.nextToken(); [EOL]         if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(fieldName, value); [EOL]     } [EOL] }
protected final void _readAndBindStringMap(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         t = jp.nextToken(); [EOL]         if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(fieldName, value); [EOL]     } [EOL] }
protected final void _readAndBindStringMap(JsonParser jp, DeserializationContext ctxt, Map<Object, Object> result) throws IOException, JsonProcessingException { [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String fieldName = jp.getCurrentName(); [EOL]         t = jp.nextToken(); [EOL]         if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         result.put(fieldName, value); [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] public Map<Object, Object> _deserializeUsingCreator(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     final PropertyBasedCreator creator = _propertyBasedCreator; [EOL]     PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, null); [EOL]     JsonToken t = jp.getCurrentToken(); [EOL]     if (t == JsonToken.START_OBJECT) { [EOL]         t = jp.nextToken(); [EOL]     } [EOL]     final JsonDeserializer<Object> valueDes = _valueDeserializer; [EOL]     final TypeDeserializer typeDeser = _valueTypeDeserializer; [EOL]     for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) { [EOL]         String propName = jp.getCurrentName(); [EOL]         t = jp.nextToken(); [EOL]         if (_ignorableProperties != null && _ignorableProperties.contains(propName)) { [EOL]             jp.skipChildren(); [EOL]             continue; [EOL]         } [EOL]         SettableBeanProperty prop = creator.findCreatorProperty(propName); [EOL]         if (prop != null) { [EOL]             Object value = prop.deserialize(jp, ctxt); [EOL]             if (buffer.assignParameter(prop.getCreatorIndex(), value)) { [EOL]                 jp.nextToken(); [EOL]                 Map<Object, Object> result; [EOL]                 try { [EOL]                     result = (Map<Object, Object>) creator.build(ctxt, buffer); [EOL]                 } catch (Exception e) { [EOL]                     wrapAndThrow(e, _mapType.getRawClass()); [EOL]                     return null; [EOL]                 } [EOL]                 _readAndBind(jp, ctxt, result); [EOL]                 return result; [EOL]             } [EOL]             continue; [EOL]         } [EOL]         String fieldName = jp.getCurrentName(); [EOL]         Object key = _keyDeserializer.deserializeKey(fieldName, ctxt); [EOL]         Object value; [EOL]         if (t == JsonToken.VALUE_NULL) { [EOL]             value = null; [EOL]         } else if (typeDeser == null) { [EOL]             value = valueDes.deserialize(jp, ctxt); [EOL]         } else { [EOL]             value = valueDes.deserializeWithType(jp, ctxt, typeDeser); [EOL]         } [EOL]         buffer.bufferMapProperty(key, value); [EOL]     } [EOL]     try { [EOL]         return (Map<Object, Object>) creator.build(ctxt, buffer); [EOL]     } catch (Exception e) { [EOL]         wrapAndThrow(e, _mapType.getRawClass()); [EOL]         return null; [EOL]     } [EOL] }
public JsonDeserializer<T> unwrappingDeserializer(NameTransformer unwrapper) { [EOL]     return this; [EOL] }
public JsonDeserializer<T> unwrappingDeserializer(NameTransformer unwrapper) { [EOL]     return this; [EOL] }
public static String format(Date date, boolean millis) { [EOL]     return format(date, millis, TIMEZONE_GMT); [EOL] }
public static String format(Date date, boolean millis) { [EOL]     return format(date, millis, TIMEZONE_GMT); [EOL] }
public static String format(Date date, boolean millis, TimeZone tz) { [EOL]     Calendar calendar = new GregorianCalendar(tz, Locale.US); [EOL]     calendar.setTime(date); [EOL]     int capacity = "yyyy-MM-ddThh:mm:ss".length(); [EOL]     capacity += millis ? ".sss".length() : 0; [EOL]     capacity += tz.getRawOffset() == 0 ? "Z".length() : "+hh:mm".length(); [EOL]     StringBuilder formatted = new StringBuilder(capacity); [EOL]     padInt(formatted, calendar.get(Calendar.YEAR), "yyyy".length()); [EOL]     formatted.append('-'); [EOL]     padInt(formatted, calendar.get(Calendar.MONTH) + 1, "MM".length()); [EOL]     formatted.append('-'); [EOL]     padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), "dd".length()); [EOL]     formatted.append('T'); [EOL]     padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), "hh".length()); [EOL]     formatted.append(':'); [EOL]     padInt(formatted, calendar.get(Calendar.MINUTE), "mm".length()); [EOL]     formatted.append(':'); [EOL]     padInt(formatted, calendar.get(Calendar.SECOND), "ss".length()); [EOL]     if (millis) { [EOL]         formatted.append('.'); [EOL]         padInt(formatted, calendar.get(Calendar.MILLISECOND), "sss".length()); [EOL]     } [EOL]     int offset = tz.getOffset(calendar.getTimeInMillis()); [EOL]     if (offset != 0) { [EOL]         int hours = Math.abs((offset / (60 * 1000)) / 60); [EOL]         int minutes = Math.abs((offset / (60 * 1000)) % 60); [EOL]         formatted.append(offset < 0 ? '-' : '+'); [EOL]         padInt(formatted, hours, "hh".length()); [EOL]         formatted.append(':'); [EOL]         padInt(formatted, minutes, "mm".length()); [EOL]     } else { [EOL]         formatted.append('Z'); [EOL]     } [EOL]     return formatted.toString(); [EOL] }
public static String format(Date date, boolean millis, TimeZone tz) { [EOL]     Calendar calendar = new GregorianCalendar(tz, Locale.US); [EOL]     calendar.setTime(date); [EOL]     int capacity = "yyyy-MM-ddThh:mm:ss".length(); [EOL]     capacity += millis ? ".sss".length() : 0; [EOL]     capacity += tz.getRawOffset() == 0 ? "Z".length() : "+hh:mm".length(); [EOL]     StringBuilder formatted = new StringBuilder(capacity); [EOL]     padInt(formatted, calendar.get(Calendar.YEAR), "yyyy".length()); [EOL]     formatted.append('-'); [EOL]     padInt(formatted, calendar.get(Calendar.MONTH) + 1, "MM".length()); [EOL]     formatted.append('-'); [EOL]     padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), "dd".length()); [EOL]     formatted.append('T'); [EOL]     padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), "hh".length()); [EOL]     formatted.append(':'); [EOL]     padInt(formatted, calendar.get(Calendar.MINUTE), "mm".length()); [EOL]     formatted.append(':'); [EOL]     padInt(formatted, calendar.get(Calendar.SECOND), "ss".length()); [EOL]     if (millis) { [EOL]         formatted.append('.'); [EOL]         padInt(formatted, calendar.get(Calendar.MILLISECOND), "sss".length()); [EOL]     } [EOL]     int offset = tz.getOffset(calendar.getTimeInMillis()); [EOL]     if (offset != 0) { [EOL]         int hours = Math.abs((offset / (60 * 1000)) / 60); [EOL]         int minutes = Math.abs((offset / (60 * 1000)) % 60); [EOL]         formatted.append(offset < 0 ? '-' : '+'); [EOL]         padInt(formatted, hours, "hh".length()); [EOL]         formatted.append(':'); [EOL]         padInt(formatted, minutes, "mm".length()); [EOL]     } else { [EOL]         formatted.append('Z'); [EOL]     } [EOL]     return formatted.toString(); [EOL] }
public static String format(Date date, boolean millis, TimeZone tz) { [EOL]     Calendar calendar = new GregorianCalendar(tz, Locale.US); [EOL]     calendar.setTime(date); [EOL]     int capacity = "yyyy-MM-ddThh:mm:ss".length(); [EOL]     capacity += millis ? ".sss".length() : 0; [EOL]     capacity += tz.getRawOffset() == 0 ? "Z".length() : "+hh:mm".length(); [EOL]     StringBuilder formatted = new StringBuilder(capacity); [EOL]     padInt(formatted, calendar.get(Calendar.YEAR), "yyyy".length()); [EOL]     formatted.append('-'); [EOL]     padInt(formatted, calendar.get(Calendar.MONTH) + 1, "MM".length()); [EOL]     formatted.append('-'); [EOL]     padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), "dd".length()); [EOL]     formatted.append('T'); [EOL]     padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), "hh".length()); [EOL]     formatted.append(':'); [EOL]     padInt(formatted, calendar.get(Calendar.MINUTE), "mm".length()); [EOL]     formatted.append(':'); [EOL]     padInt(formatted, calendar.get(Calendar.SECOND), "ss".length()); [EOL]     if (millis) { [EOL]         formatted.append('.'); [EOL]         padInt(formatted, calendar.get(Calendar.MILLISECOND), "sss".length()); [EOL]     } [EOL]     int offset = tz.getOffset(calendar.getTimeInMillis()); [EOL]     if (offset != 0) { [EOL]         int hours = Math.abs((offset / (60 * 1000)) / 60); [EOL]         int minutes = Math.abs((offset / (60 * 1000)) % 60); [EOL]         formatted.append(offset < 0 ? '-' : '+'); [EOL]         padInt(formatted, hours, "hh".length()); [EOL]         formatted.append(':'); [EOL]         padInt(formatted, minutes, "mm".length()); [EOL]     } else { [EOL]         formatted.append('Z'); [EOL]     } [EOL]     return formatted.toString(); [EOL] }
public static String format(Date date, boolean millis, TimeZone tz) { [EOL]     Calendar calendar = new GregorianCalendar(tz, Locale.US); [EOL]     calendar.setTime(date); [EOL]     int capacity = "yyyy-MM-ddThh:mm:ss".length(); [EOL]     capacity += millis ? ".sss".length() : 0; [EOL]     capacity += tz.getRawOffset() == 0 ? "Z".length() : "+hh:mm".length(); [EOL]     StringBuilder formatted = new StringBuilder(capacity); [EOL]     padInt(formatted, calendar.get(Calendar.YEAR), "yyyy".length()); [EOL]     formatted.append('-'); [EOL]     padInt(formatted, calendar.get(Calendar.MONTH) + 1, "MM".length()); [EOL]     formatted.append('-'); [EOL]     padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), "dd".length()); [EOL]     formatted.append('T'); [EOL]     padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), "hh".length()); [EOL]     formatted.append(':'); [EOL]     padInt(formatted, calendar.get(Calendar.MINUTE), "mm".length()); [EOL]     formatted.append(':'); [EOL]     padInt(formatted, calendar.get(Calendar.SECOND), "ss".length()); [EOL]     if (millis) { [EOL]         formatted.append('.'); [EOL]         padInt(formatted, calendar.get(Calendar.MILLISECOND), "sss".length()); [EOL]     } [EOL]     int offset = tz.getOffset(calendar.getTimeInMillis()); [EOL]     if (offset != 0) { [EOL]         int hours = Math.abs((offset / (60 * 1000)) / 60); [EOL]         int minutes = Math.abs((offset / (60 * 1000)) % 60); [EOL]         formatted.append(offset < 0 ? '-' : '+'); [EOL]         padInt(formatted, hours, "hh".length()); [EOL]         formatted.append(':'); [EOL]         padInt(formatted, minutes, "mm".length()); [EOL]     } else { [EOL]         formatted.append('Z'); [EOL]     } [EOL]     return formatted.toString(); [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType) { [EOL]     if (rawType == TokenBuffer.class) { [EOL]         return TokenBufferDeserializer.instance; [EOL]     } [EOL]     if (JavaType.class.isAssignableFrom(rawType)) { [EOL]         return JavaTypeDeserializer.instance; [EOL]     } [EOL]     return null; [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType) { [EOL]     if (rawType == TokenBuffer.class) { [EOL]         return TokenBufferDeserializer.instance; [EOL]     } [EOL]     if (JavaType.class.isAssignableFrom(rawType)) { [EOL]         return JavaTypeDeserializer.instance; [EOL]     } [EOL]     return null; [EOL] }
public static JsonDeserializer<?> find(Class<?> rawType) { [EOL]     if (rawType == TokenBuffer.class) { [EOL]         return TokenBufferDeserializer.instance; [EOL]     } [EOL]     if (JavaType.class.isAssignableFrom(rawType)) { [EOL]         return JavaTypeDeserializer.instance; [EOL]     } [EOL]     return null; [EOL] }
public JavaTypeDeserializer() { [EOL]     super(JavaType.class); [EOL] }
@Override [EOL] public JavaType deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING) { [EOL]         String str = jp.getText().trim(); [EOL]         if (str.length() == 0) { [EOL]             return getEmptyValue(); [EOL]         } [EOL]         return ctxt.getTypeFactory().constructFromCanonical(str); [EOL]     } [EOL]     if (curr == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         return (JavaType) jp.getEmbeddedObject(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass); [EOL] }
@Override [EOL] public JavaType deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING) { [EOL]         String str = jp.getText().trim(); [EOL]         if (str.length() == 0) { [EOL]             return getEmptyValue(); [EOL]         } [EOL]         return ctxt.getTypeFactory().constructFromCanonical(str); [EOL]     } [EOL]     if (curr == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         return (JavaType) jp.getEmbeddedObject(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass); [EOL] }
@Override [EOL] public JavaType deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING) { [EOL]         String str = jp.getText().trim(); [EOL]         if (str.length() == 0) { [EOL]             return getEmptyValue(); [EOL]         } [EOL]         return ctxt.getTypeFactory().constructFromCanonical(str); [EOL]     } [EOL]     if (curr == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         return (JavaType) jp.getEmbeddedObject(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass); [EOL] }
@Override [EOL] public JavaType deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException { [EOL]     JsonToken curr = jp.getCurrentToken(); [EOL]     if (curr == JsonToken.VALUE_STRING) { [EOL]         String str = jp.getText().trim(); [EOL]         if (str.length() == 0) { [EOL]             return getEmptyValue(); [EOL]         } [EOL]         return ctxt.getTypeFactory().constructFromCanonical(str); [EOL]     } [EOL]     if (curr == JsonToken.VALUE_EMBEDDED_OBJECT) { [EOL]         return (JavaType) jp.getEmbeddedObject(); [EOL]     } [EOL]     throw ctxt.mappingException(_valueClass); [EOL] }
public void setDefaultKeySerializer(JsonSerializer<Object> ks) { [EOL]     if (ks == null) { [EOL]         throw new IllegalArgumentException("Can not pass null JsonSerializer"); [EOL]     } [EOL]     _keySerializer = ks; [EOL] }
public void setDefaultKeySerializer(JsonSerializer<Object> ks) { [EOL]     if (ks == null) { [EOL]         throw new IllegalArgumentException("Can not pass null JsonSerializer"); [EOL]     } [EOL]     _keySerializer = ks; [EOL] }
public void setNullValueSerializer(JsonSerializer<Object> nvs) { [EOL]     if (nvs == null) { [EOL]         throw new IllegalArgumentException("Can not pass null JsonSerializer"); [EOL]     } [EOL]     _nullValueSerializer = nvs; [EOL] }
public void setNullValueSerializer(JsonSerializer<Object> nvs) { [EOL]     if (nvs == null) { [EOL]         throw new IllegalArgumentException("Can not pass null JsonSerializer"); [EOL]     } [EOL]     _nullValueSerializer = nvs; [EOL] }
public TimeZone getTimeZone() { [EOL]     return _config.getTimeZone(); [EOL] }
public JsonSerializer<Object> findTypedValueSerializer(Class<?> valueType, boolean cache, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = _serializerCache.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = findValueSerializer(valueType, property); [EOL]     TypeSerializer typeSer = _serializerFactory.createTypeSerializer(_config, _config.constructType(valueType)); [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]         ser = new TypeWrappedSerializer(typeSer, ser); [EOL]     } [EOL]     if (cache) { [EOL]         _serializerCache.addTypedSerializer(valueType, ser); [EOL]     } [EOL]     return ser; [EOL] }
public JsonSerializer<Object> findTypedValueSerializer(Class<?> valueType, boolean cache, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = _serializerCache.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = findValueSerializer(valueType, property); [EOL]     TypeSerializer typeSer = _serializerFactory.createTypeSerializer(_config, _config.constructType(valueType)); [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]         ser = new TypeWrappedSerializer(typeSer, ser); [EOL]     } [EOL]     if (cache) { [EOL]         _serializerCache.addTypedSerializer(valueType, ser); [EOL]     } [EOL]     return ser; [EOL] }
public JsonSerializer<Object> findTypedValueSerializer(Class<?> valueType, boolean cache, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = _serializerCache.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = findValueSerializer(valueType, property); [EOL]     TypeSerializer typeSer = _serializerFactory.createTypeSerializer(_config, _config.constructType(valueType)); [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]         ser = new TypeWrappedSerializer(typeSer, ser); [EOL]     } [EOL]     if (cache) { [EOL]         _serializerCache.addTypedSerializer(valueType, ser); [EOL]     } [EOL]     return ser; [EOL] }
public JsonSerializer<Object> findTypedValueSerializer(Class<?> valueType, boolean cache, BeanProperty property) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser = _knownSerializers.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = _serializerCache.typedValueSerializer(valueType); [EOL]     if (ser != null) { [EOL]         return ser; [EOL]     } [EOL]     ser = findValueSerializer(valueType, property); [EOL]     TypeSerializer typeSer = _serializerFactory.createTypeSerializer(_config, _config.constructType(valueType)); [EOL]     if (typeSer != null) { [EOL]         typeSer = typeSer.forProperty(property); [EOL]         ser = new TypeWrappedSerializer(typeSer, ser); [EOL]     } [EOL]     if (cache) { [EOL]         _serializerCache.addTypedSerializer(valueType, ser); [EOL]     } [EOL]     return ser; [EOL] }
public final void defaultSerializeNull(JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     getDefaultNullValueSerializer().serialize(null, jgen, this); [EOL] }
public final void defaultSerializeNull(JsonGenerator jgen) throws IOException, JsonProcessingException { [EOL]     getDefaultNullValueSerializer().serialize(null, jgen, this); [EOL] }
protected void _reportIncompatibleRootType(Object value, JavaType rootType) throws IOException, JsonProcessingException { [EOL]     if (rootType.isPrimitive()) { [EOL]         Class<?> wrapperType = ClassUtil.wrapperType(rootType.getRawClass()); [EOL]         if (wrapperType.isAssignableFrom(value.getClass())) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     throw new JsonMappingException("Incompatible types: declared root type (" + rootType + ") vs " + value.getClass().getName()); [EOL] }
protected void _reportIncompatibleRootType(Object value, JavaType rootType) throws IOException, JsonProcessingException { [EOL]     if (rootType.isPrimitive()) { [EOL]         Class<?> wrapperType = ClassUtil.wrapperType(rootType.getRawClass()); [EOL]         if (wrapperType.isAssignableFrom(value.getClass())) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     throw new JsonMappingException("Incompatible types: declared root type (" + rootType + ") vs " + value.getClass().getName()); [EOL] }
protected void _reportIncompatibleRootType(Object value, JavaType rootType) throws IOException, JsonProcessingException { [EOL]     if (rootType.isPrimitive()) { [EOL]         Class<?> wrapperType = ClassUtil.wrapperType(rootType.getRawClass()); [EOL]         if (wrapperType.isAssignableFrom(value.getClass())) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     throw new JsonMappingException("Incompatible types: declared root type (" + rootType + ") vs " + value.getClass().getName()); [EOL] }
protected JsonSerializer<Object> _createAndCacheUntypedSerializer(Class<?> type) throws JsonMappingException { [EOL]     JsonSerializer<Object> ser; [EOL]     try { [EOL]         ser = _createUntypedSerializer(_config.constructType(type)); [EOL]     } catch (IllegalArgumentException iae) { [EOL]         throw new JsonMappingException(iae.getMessage(), null, iae); [EOL]     } [EOL]     if (ser != null) { [EOL]         _serializerCache.addAndResolveNonTypedSerializer(type, ser, this); [EOL]     } [EOL]     return ser; [EOL] }
