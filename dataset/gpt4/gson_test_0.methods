JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors) { [EOL]     this.factory = factory; [EOL]     this.serializeNulls = serializeNulls; [EOL]     this.serializers = serializers; [EOL]     this.context = context; [EOL]     this.ancestors = ancestors; [EOL] }
JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context, MemoryRefStack ancestors) { [EOL]     this.factory = factory; [EOL]     this.serializeNulls = serializeNulls; [EOL]     this.serializers = serializers; [EOL]     this.context = context; [EOL]     this.ancestors = ancestors; [EOL] }
public void start(ObjectTypePair node) { [EOL]     if (node == null) { [EOL]         return; [EOL]     } [EOL]     if (ancestors.contains(node)) { [EOL]         throw new CircularReferenceException(node); [EOL]     } [EOL]     ancestors.push(node); [EOL] }
public void start(ObjectTypePair node) { [EOL]     if (node == null) { [EOL]         return; [EOL]     } [EOL]     if (ancestors.contains(node)) { [EOL]         throw new CircularReferenceException(node); [EOL]     } [EOL]     ancestors.push(node); [EOL] }
public void start(ObjectTypePair node) { [EOL]     if (node == null) { [EOL]         return; [EOL]     } [EOL]     if (ancestors.contains(node)) { [EOL]         throw new CircularReferenceException(node); [EOL]     } [EOL]     ancestors.push(node); [EOL] }
public void end(ObjectTypePair node) { [EOL]     if (node != null) { [EOL]         ancestors.pop(); [EOL]     } [EOL] }
public void visitArray(Object array, Type arrayType) { [EOL]     assignToRoot(new JsonArray()); [EOL]     int length = Array.getLength(array); [EOL]     TypeInfoArray fieldTypeInfo = TypeInfoFactory.getTypeInfoForArray(arrayType); [EOL]     Type componentType = fieldTypeInfo.getSecondLevelType(); [EOL]     for (int i = 0; i < length; ++i) { [EOL]         Object child = Array.get(array, i); [EOL]         Type childType = componentType; [EOL]         addAsArrayElement(new ObjectTypePair(child, childType, false)); [EOL]     } [EOL] }
public void visitArray(Object array, Type arrayType) { [EOL]     assignToRoot(new JsonArray()); [EOL]     int length = Array.getLength(array); [EOL]     TypeInfoArray fieldTypeInfo = TypeInfoFactory.getTypeInfoForArray(arrayType); [EOL]     Type componentType = fieldTypeInfo.getSecondLevelType(); [EOL]     for (int i = 0; i < length; ++i) { [EOL]         Object child = Array.get(array, i); [EOL]         Type childType = componentType; [EOL]         addAsArrayElement(new ObjectTypePair(child, childType, false)); [EOL]     } [EOL] }
private void addAsArrayElement(ObjectTypePair elementTypePair) { [EOL]     if (elementTypePair.getObject() == null) { [EOL]         root.getAsJsonArray().add(JsonNull.createJsonNull()); [EOL]     } else { [EOL]         JsonElement childElement = getJsonElementForChild(elementTypePair); [EOL]         root.getAsJsonArray().add(childElement); [EOL]     } [EOL] }
private void addAsArrayElement(ObjectTypePair elementTypePair) { [EOL]     if (elementTypePair.getObject() == null) { [EOL]         root.getAsJsonArray().add(JsonNull.createJsonNull()); [EOL]     } else { [EOL]         JsonElement childElement = getJsonElementForChild(elementTypePair); [EOL]         root.getAsJsonArray().add(childElement); [EOL]     } [EOL] }
private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair) { [EOL]     ObjectNavigator on = factory.create(fieldValueTypePair); [EOL]     JsonSerializationVisitor childVisitor = new JsonSerializationVisitor(factory, serializeNulls, serializers, context, ancestors); [EOL]     on.accept(childVisitor); [EOL]     return childVisitor.getJsonElement(); [EOL] }
private JsonElement getJsonElementForChild(ObjectTypePair fieldValueTypePair) { [EOL]     ObjectNavigator on = factory.create(fieldValueTypePair); [EOL]     JsonSerializationVisitor childVisitor = new JsonSerializationVisitor(factory, serializeNulls, serializers, context, ancestors); [EOL]     on.accept(childVisitor); [EOL]     return childVisitor.getJsonElement(); [EOL] }
public boolean visitUsingCustomHandler(ObjectTypePair objTypePair) { [EOL]     try { [EOL]         Object obj = objTypePair.getObject(); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 assignToRoot(JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         JsonElement element = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (element != null) { [EOL]             assignToRoot(element); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(null); [EOL]     } [EOL] }
public boolean visitUsingCustomHandler(ObjectTypePair objTypePair) { [EOL]     try { [EOL]         Object obj = objTypePair.getObject(); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 assignToRoot(JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         JsonElement element = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (element != null) { [EOL]             assignToRoot(element); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(null); [EOL]     } [EOL] }
public boolean visitUsingCustomHandler(ObjectTypePair objTypePair) { [EOL]     try { [EOL]         Object obj = objTypePair.getObject(); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 assignToRoot(JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         JsonElement element = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (element != null) { [EOL]             assignToRoot(element); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(null); [EOL]     } [EOL] }
public boolean visitUsingCustomHandler(ObjectTypePair objTypePair) { [EOL]     try { [EOL]         Object obj = objTypePair.getObject(); [EOL]         if (obj == null) { [EOL]             if (serializeNulls) { [EOL]                 assignToRoot(JsonNull.createJsonNull()); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         JsonElement element = findAndInvokeCustomSerializer(objTypePair); [EOL]         if (element != null) { [EOL]             assignToRoot(element); [EOL]             return true; [EOL]         } [EOL]         return false; [EOL]     } catch (CircularReferenceException e) { [EOL]         throw e.createDetailedException(null); [EOL]     } [EOL] }
@SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair) { [EOL]     Pair<JsonSerializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(serializers); [EOL]     if (pair == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer serializer = pair.first; [EOL]     objTypePair = pair.second; [EOL]     start(objTypePair); [EOL]     try { [EOL]         JsonElement element = serializer.serialize(objTypePair.getObject(), objTypePair.getType(), context); [EOL]         return element == null ? JsonNull.createJsonNull() : element; [EOL]     } finally { [EOL]         end(objTypePair); [EOL]     } [EOL] }
@SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair) { [EOL]     Pair<JsonSerializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(serializers); [EOL]     if (pair == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer serializer = pair.first; [EOL]     objTypePair = pair.second; [EOL]     start(objTypePair); [EOL]     try { [EOL]         JsonElement element = serializer.serialize(objTypePair.getObject(), objTypePair.getType(), context); [EOL]         return element == null ? JsonNull.createJsonNull() : element; [EOL]     } finally { [EOL]         end(objTypePair); [EOL]     } [EOL] }
@SuppressWarnings({ "unchecked", "rawtypes" }) [EOL] private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair) { [EOL]     Pair<JsonSerializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(serializers); [EOL]     if (pair == null) { [EOL]         return null; [EOL]     } [EOL]     JsonSerializer serializer = pair.first; [EOL]     objTypePair = pair.second; [EOL]     start(objTypePair); [EOL]     try { [EOL]         JsonElement element = serializer.serialize(objTypePair.getObject(), objTypePair.getType(), context); [EOL]         return element == null ? JsonNull.createJsonNull() : element; [EOL]     } finally { [EOL]         end(objTypePair); [EOL]     } [EOL] }
private void assignToRoot(JsonElement newRoot) { [EOL]     Preconditions.checkNotNull(newRoot); [EOL]     root = newRoot; [EOL] }
private void assignToRoot(JsonElement newRoot) { [EOL]     Preconditions.checkNotNull(newRoot); [EOL]     root = newRoot; [EOL] }
public JsonElement getJsonElement() { [EOL]     return root; [EOL] }
public void setIndent(String indent) { [EOL]     if (indent.length() == 0) { [EOL]         this.indent = null; [EOL]         this.separator = ":"; [EOL]     } else { [EOL]         this.indent = indent; [EOL]         this.separator = ": "; [EOL]     } [EOL] }
public void setIndent(String indent) { [EOL]     if (indent.length() == 0) { [EOL]         this.indent = null; [EOL]         this.separator = ":"; [EOL]     } else { [EOL]         this.indent = indent; [EOL]         this.separator = ": "; [EOL]     } [EOL] }
private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException { [EOL]     JsonScope context = peek(); [EOL]     if (context != nonempty && context != empty) { [EOL]         throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL]     stack.remove(stack.size() - 1); [EOL]     if (context == nonempty) { [EOL]         newline(); [EOL]     } [EOL]     out.write(closeBracket); [EOL]     return this; [EOL] }
private JsonWriter close(JsonScope empty, JsonScope nonempty, String closeBracket) throws IOException { [EOL]     JsonScope context = peek(); [EOL]     if (context != nonempty && context != empty) { [EOL]         throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL]     stack.remove(stack.size() - 1); [EOL]     if (context == nonempty) { [EOL]         newline(); [EOL]     } [EOL]     out.write(closeBracket); [EOL]     return this; [EOL] }
public JsonWriter name(String name) throws IOException { [EOL]     if (name == null) { [EOL]         throw new NullPointerException("name == null"); [EOL]     } [EOL]     beforeName(); [EOL]     string(name); [EOL]     return this; [EOL] }
public JsonWriter name(String name) throws IOException { [EOL]     if (name == null) { [EOL]         throw new NullPointerException("name == null"); [EOL]     } [EOL]     beforeName(); [EOL]     string(name); [EOL]     return this; [EOL] }
public JsonWriter value(String value) throws IOException { [EOL]     if (value == null) { [EOL]         return nullValue(); [EOL]     } [EOL]     beforeValue(false); [EOL]     string(value); [EOL]     return this; [EOL] }
public JsonWriter value(String value) throws IOException { [EOL]     if (value == null) { [EOL]         return nullValue(); [EOL]     } [EOL]     beforeValue(false); [EOL]     string(value); [EOL]     return this; [EOL] }
public JsonWriter value(double value) throws IOException { [EOL]     if (Double.isNaN(value) || Double.isInfinite(value)) { [EOL]         throw new IllegalArgumentException("Numeric values must be finite, but was " + value); [EOL]     } [EOL]     beforeValue(false); [EOL]     out.append(Double.toString(value)); [EOL]     return this; [EOL] }
public JsonWriter value(double value) throws IOException { [EOL]     if (Double.isNaN(value) || Double.isInfinite(value)) { [EOL]         throw new IllegalArgumentException("Numeric values must be finite, but was " + value); [EOL]     } [EOL]     beforeValue(false); [EOL]     out.append(Double.toString(value)); [EOL]     return this; [EOL] }
public JsonWriter value(double value) throws IOException { [EOL]     if (Double.isNaN(value) || Double.isInfinite(value)) { [EOL]         throw new IllegalArgumentException("Numeric values must be finite, but was " + value); [EOL]     } [EOL]     beforeValue(false); [EOL]     out.append(Double.toString(value)); [EOL]     return this; [EOL] }
public JsonWriter value(double value) throws IOException { [EOL]     if (Double.isNaN(value) || Double.isInfinite(value)) { [EOL]         throw new IllegalArgumentException("Numeric values must be finite, but was " + value); [EOL]     } [EOL]     beforeValue(false); [EOL]     out.append(Double.toString(value)); [EOL]     return this; [EOL] }
public void close() throws IOException { [EOL]     out.close(); [EOL]     if (peek() != JsonScope.NONEMPTY_DOCUMENT) { [EOL]         throw new IOException("Incomplete document"); [EOL]     } [EOL] }
public void close() throws IOException { [EOL]     out.close(); [EOL]     if (peek() != JsonScope.NONEMPTY_DOCUMENT) { [EOL]         throw new IOException("Incomplete document"); [EOL]     } [EOL] }
private void newline() throws IOException { [EOL]     if (indent == null) { [EOL]         return; [EOL]     } [EOL]     out.write("\n"); [EOL]     for (int i = 1; i < stack.size(); i++) { [EOL]         out.write(indent); [EOL]     } [EOL] }
private void newline() throws IOException { [EOL]     if (indent == null) { [EOL]         return; [EOL]     } [EOL]     out.write("\n"); [EOL]     for (int i = 1; i < stack.size(); i++) { [EOL]         out.write(indent); [EOL]     } [EOL] }
private void newline() throws IOException { [EOL]     if (indent == null) { [EOL]         return; [EOL]     } [EOL]     out.write("\n"); [EOL]     for (int i = 1; i < stack.size(); i++) { [EOL]         out.write(indent); [EOL]     } [EOL] }
private void beforeValue(boolean root) throws IOException { [EOL]     switch(peek()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (!lenient && !root) { [EOL]                 throw new IllegalStateException("JSON must start with an array or an object."); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             break; [EOL]         case EMPTY_ARRAY: [EOL]             replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]             newline(); [EOL]             break; [EOL]         case NONEMPTY_ARRAY: [EOL]             out.append(','); [EOL]             newline(); [EOL]             break; [EOL]         case DANGLING_NAME: [EOL]             out.append(separator); [EOL]             replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL]             break; [EOL]         case NONEMPTY_DOCUMENT: [EOL]             throw new IllegalStateException("JSON must have only one top-level value."); [EOL]         default: [EOL]             throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL] }
private void beforeValue(boolean root) throws IOException { [EOL]     switch(peek()) { [EOL]         case EMPTY_DOCUMENT: [EOL]             if (!lenient && !root) { [EOL]                 throw new IllegalStateException("JSON must start with an array or an object."); [EOL]             } [EOL]             replaceTop(JsonScope.NONEMPTY_DOCUMENT); [EOL]             break; [EOL]         case EMPTY_ARRAY: [EOL]             replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]             newline(); [EOL]             break; [EOL]         case NONEMPTY_ARRAY: [EOL]             out.append(','); [EOL]             newline(); [EOL]             break; [EOL]         case DANGLING_NAME: [EOL]             out.append(separator); [EOL]             replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL]             break; [EOL]         case NONEMPTY_DOCUMENT: [EOL]             throw new IllegalStateException("JSON must have only one top-level value."); [EOL]         default: [EOL]             throw new IllegalStateException("Nesting problem: " + stack); [EOL]     } [EOL] }
public boolean shouldSkipClass(Class<?> clazz) { [EOL]     return false; [EOL] }
public UpperCamelCaseSeparatorNamingPolicy(String separatorString) { [EOL]     super(new CamelCaseSeparatorNamingPolicy(separatorString), new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER)); [EOL] }
public UpperCamelCaseSeparatorNamingPolicy(String separatorString) { [EOL]     super(new CamelCaseSeparatorNamingPolicy(separatorString), new ModifyFirstLetterNamingPolicy(ModifyFirstLetterNamingPolicy.LetterModifier.UPPER)); [EOL] }
public Class<?> getComponentRawType() { [EOL]     return componentRawType; [EOL] }
Escaper(boolean escapeHtmlCharacters) { [EOL]     this.escapeHtmlCharacters = escapeHtmlCharacters; [EOL] }  Escaper(boolean escapeHtmlCharacters); public String escapeJsonString(CharSequence plainText); private void escapeJsonString(CharSequence plainText, StringBuffer out) throws IOException; private boolean mustEscapeCharInJsString(int codepoint); private static boolean isControlCharacter(int codePoint); private static void appendHexJavaScriptRepresentation(int codePoint, Appendable out) throws IOException; char[] HEX_CHARS=Optional[{ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }
Pair(FIRST first, SECOND second) { [EOL]     this.first = first; [EOL]     this.second = second; [EOL] }
Pair(FIRST first, SECOND second) { [EOL]     this.first = first; [EOL]     this.second = second; [EOL] }
public JsonToken peek() throws IOException { [EOL]     quickPeek(); [EOL]     if (token == null) { [EOL]         decodeLiteral(); [EOL]     } [EOL]     return token; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private void consumeNonExecutePrefix() throws IOException { [EOL]     nextNonWhitespace(); [EOL]     pos--; [EOL]     if (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) { [EOL]         return; [EOL]     } [EOL]     for (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) { [EOL]         if (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) { [EOL]             return; [EOL]         } [EOL]     } [EOL]     pos += NON_EXECUTE_PREFIX.length; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public String nextName() throws IOException { [EOL]     quickPeek(); [EOL]     if (token != JsonToken.NAME) { [EOL]         throw new IllegalStateException("Expected a name but was " + peek()); [EOL]     } [EOL]     String result = name; [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public String nextString() throws IOException { [EOL]     peek(); [EOL]     if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) { [EOL]         throw new IllegalStateException("Expected a string but was " + peek()); [EOL]     } [EOL]     String result = value; [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public String nextString() throws IOException { [EOL]     peek(); [EOL]     if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) { [EOL]         throw new IllegalStateException("Expected a string but was " + peek()); [EOL]     } [EOL]     String result = value; [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public String nextString() throws IOException { [EOL]     peek(); [EOL]     if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) { [EOL]         throw new IllegalStateException("Expected a string but was " + peek()); [EOL]     } [EOL]     String result = value; [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public String nextString() throws IOException { [EOL]     peek(); [EOL]     if (value == null || (token != JsonToken.STRING && token != JsonToken.NUMBER)) { [EOL]         throw new IllegalStateException("Expected a string but was " + peek()); [EOL]     } [EOL]     String result = value; [EOL]     advance(); [EOL]     return result; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public void skipValue() throws IOException { [EOL]     skipping = true; [EOL]     try { [EOL]         int count = 0; [EOL]         do { [EOL]             JsonToken token = advance(); [EOL]             if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) { [EOL]                 count++; [EOL]             } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) { [EOL]                 count--; [EOL]             } [EOL]         } while (count != 0); [EOL]     } finally { [EOL]         skipping = false; [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextInArray(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case ']': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             case ';': [EOL]                 checkLenient(); [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated array"); [EOL]         } [EOL]     } [EOL]     switch(nextNonWhitespace()) { [EOL]         case ']': [EOL]             if (firstElement) { [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             } [EOL]         case ';': [EOL]         case ',': [EOL]             checkLenient(); [EOL]             pos--; [EOL]             hasToken = true; [EOL]             value = "null"; [EOL]             return token = JsonToken.NULL; [EOL]         default: [EOL]             pos--; [EOL]             return nextValue(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextInArray(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case ']': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             case ';': [EOL]                 checkLenient(); [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated array"); [EOL]         } [EOL]     } [EOL]     switch(nextNonWhitespace()) { [EOL]         case ']': [EOL]             if (firstElement) { [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             } [EOL]         case ';': [EOL]         case ',': [EOL]             checkLenient(); [EOL]             pos--; [EOL]             hasToken = true; [EOL]             value = "null"; [EOL]             return token = JsonToken.NULL; [EOL]         default: [EOL]             pos--; [EOL]             return nextValue(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextInArray(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case ']': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             case ';': [EOL]                 checkLenient(); [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated array"); [EOL]         } [EOL]     } [EOL]     switch(nextNonWhitespace()) { [EOL]         case ']': [EOL]             if (firstElement) { [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             } [EOL]         case ';': [EOL]         case ',': [EOL]             checkLenient(); [EOL]             pos--; [EOL]             hasToken = true; [EOL]             value = "null"; [EOL]             return token = JsonToken.NULL; [EOL]         default: [EOL]             pos--; [EOL]             return nextValue(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextInArray(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case ']': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             case ';': [EOL]                 checkLenient(); [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated array"); [EOL]         } [EOL]     } [EOL]     switch(nextNonWhitespace()) { [EOL]         case ']': [EOL]             if (firstElement) { [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             } [EOL]         case ';': [EOL]         case ',': [EOL]             checkLenient(); [EOL]             pos--; [EOL]             hasToken = true; [EOL]             value = "null"; [EOL]             return token = JsonToken.NULL; [EOL]         default: [EOL]             pos--; [EOL]             return nextValue(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextInArray(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case ']': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             case ';': [EOL]                 checkLenient(); [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated array"); [EOL]         } [EOL]     } [EOL]     switch(nextNonWhitespace()) { [EOL]         case ']': [EOL]             if (firstElement) { [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             } [EOL]         case ';': [EOL]         case ',': [EOL]             checkLenient(); [EOL]             pos--; [EOL]             hasToken = true; [EOL]             value = "null"; [EOL]             return token = JsonToken.NULL; [EOL]         default: [EOL]             pos--; [EOL]             return nextValue(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextInArray(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case ']': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             case ';': [EOL]                 checkLenient(); [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated array"); [EOL]         } [EOL]     } [EOL]     switch(nextNonWhitespace()) { [EOL]         case ']': [EOL]             if (firstElement) { [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             } [EOL]         case ';': [EOL]         case ',': [EOL]             checkLenient(); [EOL]             pos--; [EOL]             hasToken = true; [EOL]             value = "null"; [EOL]             return token = JsonToken.NULL; [EOL]         default: [EOL]             pos--; [EOL]             return nextValue(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextInArray(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         replaceTop(JsonScope.NONEMPTY_ARRAY); [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case ']': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             case ';': [EOL]                 checkLenient(); [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated array"); [EOL]         } [EOL]     } [EOL]     switch(nextNonWhitespace()) { [EOL]         case ']': [EOL]             if (firstElement) { [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_ARRAY; [EOL]             } [EOL]         case ';': [EOL]         case ',': [EOL]             checkLenient(); [EOL]             pos--; [EOL]             hasToken = true; [EOL]             value = "null"; [EOL]             return token = JsonToken.NULL; [EOL]         default: [EOL]             pos--; [EOL]             return nextValue(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextInObject(boolean firstElement) throws IOException { [EOL]     if (firstElement) { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             default: [EOL]                 pos--; [EOL]         } [EOL]     } else { [EOL]         switch(nextNonWhitespace()) { [EOL]             case '}': [EOL]                 pop(); [EOL]                 hasToken = true; [EOL]                 return token = JsonToken.END_OBJECT; [EOL]             case ';': [EOL]             case ',': [EOL]                 break; [EOL]             default: [EOL]                 throw syntaxError("Unterminated object"); [EOL]         } [EOL]     } [EOL]     int quote = nextNonWhitespace(); [EOL]     switch(quote) { [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             name = nextString((char) quote); [EOL]             break; [EOL]         default: [EOL]             checkLenient(); [EOL]             pos--; [EOL]             name = nextLiteral(); [EOL]             if (name.length() == 0) { [EOL]                 throw syntaxError("Expected name"); [EOL]             } [EOL]     } [EOL]     replaceTop(JsonScope.DANGLING_NAME); [EOL]     hasToken = true; [EOL]     return token = JsonToken.NAME; [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken objectValue() throws IOException { [EOL]     switch(nextNonWhitespace()) { [EOL]         case ':': [EOL]             break; [EOL]         case '=': [EOL]             checkLenient(); [EOL]             if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') { [EOL]                 pos++; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw syntaxError("Expected ':'"); [EOL]     } [EOL]     replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL]     return nextValue(); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken objectValue() throws IOException { [EOL]     switch(nextNonWhitespace()) { [EOL]         case ':': [EOL]             break; [EOL]         case '=': [EOL]             checkLenient(); [EOL]             if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') { [EOL]                 pos++; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw syntaxError("Expected ':'"); [EOL]     } [EOL]     replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL]     return nextValue(); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken objectValue() throws IOException { [EOL]     switch(nextNonWhitespace()) { [EOL]         case ':': [EOL]             break; [EOL]         case '=': [EOL]             checkLenient(); [EOL]             if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') { [EOL]                 pos++; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw syntaxError("Expected ':'"); [EOL]     } [EOL]     replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL]     return nextValue(); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken objectValue() throws IOException { [EOL]     switch(nextNonWhitespace()) { [EOL]         case ':': [EOL]             break; [EOL]         case '=': [EOL]             checkLenient(); [EOL]             if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') { [EOL]                 pos++; [EOL]             } [EOL]             break; [EOL]         default: [EOL]             throw syntaxError("Expected ':'"); [EOL]     } [EOL]     replaceTop(JsonScope.NONEMPTY_OBJECT); [EOL]     return nextValue(); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextValue() throws IOException { [EOL]     int c = nextNonWhitespace(); [EOL]     switch(c) { [EOL]         case '{': [EOL]             push(JsonScope.EMPTY_OBJECT); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_OBJECT; [EOL]         case '[': [EOL]             push(JsonScope.EMPTY_ARRAY); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_ARRAY; [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             value = nextString((char) c); [EOL]             hasToken = true; [EOL]             return token = JsonToken.STRING; [EOL]         default: [EOL]             pos--; [EOL]             return readLiteral(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextValue() throws IOException { [EOL]     int c = nextNonWhitespace(); [EOL]     switch(c) { [EOL]         case '{': [EOL]             push(JsonScope.EMPTY_OBJECT); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_OBJECT; [EOL]         case '[': [EOL]             push(JsonScope.EMPTY_ARRAY); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_ARRAY; [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             value = nextString((char) c); [EOL]             hasToken = true; [EOL]             return token = JsonToken.STRING; [EOL]         default: [EOL]             pos--; [EOL]             return readLiteral(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextValue() throws IOException { [EOL]     int c = nextNonWhitespace(); [EOL]     switch(c) { [EOL]         case '{': [EOL]             push(JsonScope.EMPTY_OBJECT); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_OBJECT; [EOL]         case '[': [EOL]             push(JsonScope.EMPTY_ARRAY); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_ARRAY; [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             value = nextString((char) c); [EOL]             hasToken = true; [EOL]             return token = JsonToken.STRING; [EOL]         default: [EOL]             pos--; [EOL]             return readLiteral(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextValue() throws IOException { [EOL]     int c = nextNonWhitespace(); [EOL]     switch(c) { [EOL]         case '{': [EOL]             push(JsonScope.EMPTY_OBJECT); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_OBJECT; [EOL]         case '[': [EOL]             push(JsonScope.EMPTY_ARRAY); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_ARRAY; [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             value = nextString((char) c); [EOL]             hasToken = true; [EOL]             return token = JsonToken.STRING; [EOL]         default: [EOL]             pos--; [EOL]             return readLiteral(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private JsonToken nextValue() throws IOException { [EOL]     int c = nextNonWhitespace(); [EOL]     switch(c) { [EOL]         case '{': [EOL]             push(JsonScope.EMPTY_OBJECT); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_OBJECT; [EOL]         case '[': [EOL]             push(JsonScope.EMPTY_ARRAY); [EOL]             hasToken = true; [EOL]             return token = JsonToken.BEGIN_ARRAY; [EOL]         case '\'': [EOL]             checkLenient(); [EOL]         case '"': [EOL]             value = nextString((char) c); [EOL]             hasToken = true; [EOL]             return token = JsonToken.STRING; [EOL]         default: [EOL]             pos--; [EOL]             return readLiteral(); [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private int nextNonWhitespace() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         int c = buffer[pos++]; [EOL]         switch(c) { [EOL]             case '\t': [EOL]             case ' ': [EOL]             case '\n': [EOL]             case '\r': [EOL]                 continue; [EOL]             case '/': [EOL]                 if (pos == limit && !fillBuffer(1)) { [EOL]                     return c; [EOL]                 } [EOL]                 checkLenient(); [EOL]                 char peek = buffer[pos]; [EOL]                 switch(peek) { [EOL]                     case '*': [EOL]                         pos++; [EOL]                         if (!skipTo("*/")) { [EOL]                             throw syntaxError("Unterminated comment"); [EOL]                         } [EOL]                         pos += 2; [EOL]                         continue; [EOL]                     case '/': [EOL]                         pos++; [EOL]                         skipToEndOfLine(); [EOL]                         continue; [EOL]                     default: [EOL]                         return c; [EOL]                 } [EOL]             case '#': [EOL]                 checkLenient(); [EOL]                 skipToEndOfLine(); [EOL]                 continue; [EOL]             default: [EOL]                 return c; [EOL]         } [EOL]     } [EOL]     throw new EOFException("End of input"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private int nextNonWhitespace() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         int c = buffer[pos++]; [EOL]         switch(c) { [EOL]             case '\t': [EOL]             case ' ': [EOL]             case '\n': [EOL]             case '\r': [EOL]                 continue; [EOL]             case '/': [EOL]                 if (pos == limit && !fillBuffer(1)) { [EOL]                     return c; [EOL]                 } [EOL]                 checkLenient(); [EOL]                 char peek = buffer[pos]; [EOL]                 switch(peek) { [EOL]                     case '*': [EOL]                         pos++; [EOL]                         if (!skipTo("*/")) { [EOL]                             throw syntaxError("Unterminated comment"); [EOL]                         } [EOL]                         pos += 2; [EOL]                         continue; [EOL]                     case '/': [EOL]                         pos++; [EOL]                         skipToEndOfLine(); [EOL]                         continue; [EOL]                     default: [EOL]                         return c; [EOL]                 } [EOL]             case '#': [EOL]                 checkLenient(); [EOL]                 skipToEndOfLine(); [EOL]                 continue; [EOL]             default: [EOL]                 return c; [EOL]         } [EOL]     } [EOL]     throw new EOFException("End of input"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private int nextNonWhitespace() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         int c = buffer[pos++]; [EOL]         switch(c) { [EOL]             case '\t': [EOL]             case ' ': [EOL]             case '\n': [EOL]             case '\r': [EOL]                 continue; [EOL]             case '/': [EOL]                 if (pos == limit && !fillBuffer(1)) { [EOL]                     return c; [EOL]                 } [EOL]                 checkLenient(); [EOL]                 char peek = buffer[pos]; [EOL]                 switch(peek) { [EOL]                     case '*': [EOL]                         pos++; [EOL]                         if (!skipTo("*/")) { [EOL]                             throw syntaxError("Unterminated comment"); [EOL]                         } [EOL]                         pos += 2; [EOL]                         continue; [EOL]                     case '/': [EOL]                         pos++; [EOL]                         skipToEndOfLine(); [EOL]                         continue; [EOL]                     default: [EOL]                         return c; [EOL]                 } [EOL]             case '#': [EOL]                 checkLenient(); [EOL]                 skipToEndOfLine(); [EOL]                 continue; [EOL]             default: [EOL]                 return c; [EOL]         } [EOL]     } [EOL]     throw new EOFException("End of input"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private int nextNonWhitespace() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         int c = buffer[pos++]; [EOL]         switch(c) { [EOL]             case '\t': [EOL]             case ' ': [EOL]             case '\n': [EOL]             case '\r': [EOL]                 continue; [EOL]             case '/': [EOL]                 if (pos == limit && !fillBuffer(1)) { [EOL]                     return c; [EOL]                 } [EOL]                 checkLenient(); [EOL]                 char peek = buffer[pos]; [EOL]                 switch(peek) { [EOL]                     case '*': [EOL]                         pos++; [EOL]                         if (!skipTo("*/")) { [EOL]                             throw syntaxError("Unterminated comment"); [EOL]                         } [EOL]                         pos += 2; [EOL]                         continue; [EOL]                     case '/': [EOL]                         pos++; [EOL]                         skipToEndOfLine(); [EOL]                         continue; [EOL]                     default: [EOL]                         return c; [EOL]                 } [EOL]             case '#': [EOL]                 checkLenient(); [EOL]                 skipToEndOfLine(); [EOL]                 continue; [EOL]             default: [EOL]                 return c; [EOL]         } [EOL]     } [EOL]     throw new EOFException("End of input"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private int nextNonWhitespace() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         int c = buffer[pos++]; [EOL]         switch(c) { [EOL]             case '\t': [EOL]             case ' ': [EOL]             case '\n': [EOL]             case '\r': [EOL]                 continue; [EOL]             case '/': [EOL]                 if (pos == limit && !fillBuffer(1)) { [EOL]                     return c; [EOL]                 } [EOL]                 checkLenient(); [EOL]                 char peek = buffer[pos]; [EOL]                 switch(peek) { [EOL]                     case '*': [EOL]                         pos++; [EOL]                         if (!skipTo("*/")) { [EOL]                             throw syntaxError("Unterminated comment"); [EOL]                         } [EOL]                         pos += 2; [EOL]                         continue; [EOL]                     case '/': [EOL]                         pos++; [EOL]                         skipToEndOfLine(); [EOL]                         continue; [EOL]                     default: [EOL]                         return c; [EOL]                 } [EOL]             case '#': [EOL]                 checkLenient(); [EOL]                 skipToEndOfLine(); [EOL]                 continue; [EOL]             default: [EOL]                 return c; [EOL]         } [EOL]     } [EOL]     throw new EOFException("End of input"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private int nextNonWhitespace() throws IOException { [EOL]     while (pos < limit || fillBuffer(1)) { [EOL]         int c = buffer[pos++]; [EOL]         switch(c) { [EOL]             case '\t': [EOL]             case ' ': [EOL]             case '\n': [EOL]             case '\r': [EOL]                 continue; [EOL]             case '/': [EOL]                 if (pos == limit && !fillBuffer(1)) { [EOL]                     return c; [EOL]                 } [EOL]                 checkLenient(); [EOL]                 char peek = buffer[pos]; [EOL]                 switch(peek) { [EOL]                     case '*': [EOL]                         pos++; [EOL]                         if (!skipTo("*/")) { [EOL]                             throw syntaxError("Unterminated comment"); [EOL]                         } [EOL]                         pos += 2; [EOL]                         continue; [EOL]                     case '/': [EOL]                         pos++; [EOL]                         skipToEndOfLine(); [EOL]                         continue; [EOL]                     default: [EOL]                         return c; [EOL]                 } [EOL]             case '#': [EOL]                 checkLenient(); [EOL]                 skipToEndOfLine(); [EOL]                 continue; [EOL]             default: [EOL]                 return c; [EOL]         } [EOL]     } [EOL]     throw new EOFException("End of input"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private String nextString(char quote) throws IOException { [EOL]     StringBuilder builder = null; [EOL]     do { [EOL]         int start = pos; [EOL]         while (pos < limit) { [EOL]             int c = buffer[pos++]; [EOL]             if (c == quote) { [EOL]                 if (skipping) { [EOL]                     return "skipped!"; [EOL]                 } else if (builder == null) { [EOL]                     return new String(buffer, start, pos - start - 1); [EOL]                 } else { [EOL]                     builder.append(buffer, start, pos - start - 1); [EOL]                     return builder.toString(); [EOL]                 } [EOL]             } else if (c == '\\') { [EOL]                 if (builder == null) { [EOL]                     builder = new StringBuilder(); [EOL]                 } [EOL]                 builder.append(buffer, start, pos - start - 1); [EOL]                 builder.append(readEscapeCharacter()); [EOL]                 start = pos; [EOL]             } [EOL]         } [EOL]         if (builder == null) { [EOL]             builder = new StringBuilder(); [EOL]         } [EOL]         builder.append(buffer, start, pos - start); [EOL]     } while (fillBuffer(1)); [EOL]     throw syntaxError("Unterminated string"); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private String nextLiteral() throws IOException { [EOL]     StringBuilder builder = null; [EOL]     do { [EOL]         int start = pos; [EOL]         while (pos < limit) { [EOL]             int c = buffer[pos++]; [EOL]             switch(c) { [EOL]                 case '/': [EOL]                 case '\\': [EOL]                 case ';': [EOL]                 case '#': [EOL]                 case '=': [EOL]                     checkLenient(); [EOL]                 case '{': [EOL]                 case '}': [EOL]                 case '[': [EOL]                 case ']': [EOL]                 case ':': [EOL]                 case ',': [EOL]                 case ' ': [EOL]                 case '\t': [EOL]                 case '\f': [EOL]                 case '\r': [EOL]                 case '\n': [EOL]                     pos--; [EOL]                     if (skipping) { [EOL]                         return "skipped!"; [EOL]                     } else if (builder == null) { [EOL]                         return new String(buffer, start, pos - start); [EOL]                     } else { [EOL]                         builder.append(buffer, start, pos - start); [EOL]                         return builder.toString(); [EOL]                     } [EOL]             } [EOL]         } [EOL]         if (builder == null) { [EOL]             builder = new StringBuilder(); [EOL]         } [EOL]         builder.append(buffer, start, pos - start); [EOL]     } while (fillBuffer(1)); [EOL]     return builder.toString(); [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private char readEscapeCharacter() throws IOException { [EOL]     if (pos == limit && !fillBuffer(1)) { [EOL]         throw syntaxError("Unterminated escape sequence"); [EOL]     } [EOL]     char escaped = buffer[pos++]; [EOL]     switch(escaped) { [EOL]         case 'u': [EOL]             if (pos + 4 > limit && !fillBuffer(4)) { [EOL]                 throw syntaxError("Unterminated escape sequence"); [EOL]             } [EOL]             String hex = new String(buffer, pos, 4); [EOL]             pos += 4; [EOL]             return (char) Integer.parseInt(hex, 16); [EOL]         case 't': [EOL]             return '\t'; [EOL]         case 'b': [EOL]             return '\b'; [EOL]         case 'n': [EOL]             return '\n'; [EOL]         case 'r': [EOL]             return '\r'; [EOL]         case 'f': [EOL]             return '\f'; [EOL]         case '\'': [EOL]         case '"': [EOL]         case '\\': [EOL]         default: [EOL]             return escaped; [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
private void decodeLiteral() throws IOException { [EOL]     if (value.equalsIgnoreCase("null")) { [EOL]         token = JsonToken.NULL; [EOL]     } else if (value.equalsIgnoreCase("true") || value.equalsIgnoreCase("false")) { [EOL]         token = JsonToken.BOOLEAN; [EOL]     } else { [EOL]         try { [EOL]             Double.parseDouble(value); [EOL]             token = JsonToken.NUMBER; [EOL]         } catch (NumberFormatException ignored) { [EOL]             checkLenient(); [EOL]             token = JsonToken.STRING; [EOL]         } [EOL]     } [EOL] } public JsonReader(Reader in); public void setLenient(boolean lenient); public boolean isLenient(); public void beginArray() throws IOException; public void endArray() throws IOException; public void beginObject() throws IOException; public void endObject() throws IOException; private void expect(JsonToken expected) throws IOException; public boolean hasNext() throws IOException; public JsonToken peek() throws IOException; private JsonToken quickPeek() throws IOException; private void consumeNonExecutePrefix() throws IOException; private JsonToken advance() throws IOException; public String nextName() throws IOException; public String nextString() throws IOException; public boolean nextBoolean() throws IOException; public void nextNull() throws IOException; public double nextDouble() throws IOException; public long nextLong() throws IOException; public int nextInt() throws IOException; public void close() throws IOException; public void skipValue() throws IOException; private JsonScope peekStack(); private JsonScope pop(); private void push(JsonScope newTop); private void replaceTop(JsonScope newTop); private JsonToken nextInArray(boolean firstElement) throws IOException; private JsonToken nextInObject(boolean firstElement) throws IOException; private JsonToken objectValue() throws IOException; private JsonToken nextValue() throws IOException; private boolean fillBuffer(int minimum) throws IOException; private int nextNonWhitespace() throws IOException; private void checkLenient() throws IOException; private void skipToEndOfLine() throws IOException; private boolean skipTo(String toFind) throws IOException; private String nextString(char quote) throws IOException; private String nextLiteral() throws IOException; public String toString(); private char readEscapeCharacter() throws IOException; private JsonToken readLiteral() throws IOException; private void decodeLiteral() throws IOException; private IOException syntaxError(String message) throws IOException; private CharSequence getSnippet(); char[] NON_EXECUTE_PREFIX=Optional[")]}
public boolean shouldSkipClass(Class<?> clazz) { [EOL]     return isAnonymousOrLocal(clazz); [EOL] }
private boolean isAnonymousOrLocal(Class<?> clazz) { [EOL]     return !Enum.class.isAssignableFrom(clazz) && (clazz.isAnonymousClass() || clazz.isLocalClass()); [EOL] }
private boolean isAnonymousOrLocal(Class<?> clazz) { [EOL]     return !Enum.class.isAssignableFrom(clazz) && (clazz.isAnonymousClass() || clazz.isLocalClass()); [EOL] }
private boolean isAnonymousOrLocal(Class<?> clazz) { [EOL]     return !Enum.class.isAssignableFrom(clazz) && (clazz.isAnonymousClass() || clazz.isLocalClass()); [EOL] }
private boolean isAnonymousOrLocal(Class<?> clazz) { [EOL]     return !Enum.class.isAssignableFrom(clazz) && (clazz.isAnonymousClass() || clazz.isLocalClass()); [EOL] }
public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonObject jsonObject = json.getAsJsonObject(); [EOL]         String fName = getFieldName(f); [EOL]         JsonArray jsonChild = (JsonArray) jsonObject.get(fName); [EOL]         if (jsonChild != null) { [EOL]             Object array = visitChildAsArray(typeOfF, jsonChild); [EOL]             f.set(obj, array); [EOL]         } else { [EOL]             f.set(obj, null); [EOL]         } [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL] }
public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonObject jsonObject = json.getAsJsonObject(); [EOL]         String fName = getFieldName(f); [EOL]         JsonArray jsonChild = (JsonArray) jsonObject.get(fName); [EOL]         if (jsonChild != null) { [EOL]             Object array = visitChildAsArray(typeOfF, jsonChild); [EOL]             f.set(obj, array); [EOL]         } else { [EOL]             f.set(obj, null); [EOL]         } [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL] }
public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonObject jsonObject = json.getAsJsonObject(); [EOL]         String fName = getFieldName(f); [EOL]         JsonArray jsonChild = (JsonArray) jsonObject.get(fName); [EOL]         if (jsonChild != null) { [EOL]             Object array = visitChildAsArray(typeOfF, jsonChild); [EOL]             f.set(obj, array); [EOL]         } else { [EOL]             f.set(obj, null); [EOL]         } [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL] }
public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj) { [EOL]     try { [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonObject jsonObject = json.getAsJsonObject(); [EOL]         String fName = getFieldName(f); [EOL]         JsonArray jsonChild = (JsonArray) jsonObject.get(fName); [EOL]         if (jsonChild != null) { [EOL]             Object array = visitChildAsArray(typeOfF, jsonChild); [EOL]             f.set(obj, array); [EOL]         } else { [EOL]             f.set(obj, null); [EOL]         } [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(e); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         String fName = getFieldName(f); [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonElement child = json.getAsJsonObject().get(fName); [EOL]         TypeInfo typeInfo = new TypeInfo(declaredTypeOfField); [EOL]         if (child == null) { [EOL]             return true; [EOL]         } else if (child.isJsonNull()) { [EOL]             if (!typeInfo.isPrimitive()) { [EOL]                 f.set(parent, null); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(null, declaredTypeOfField, false); [EOL]         Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers); [EOL]         if (pair == null) { [EOL]             return false; [EOL]         } [EOL]         Object value = invokeCustomDeserializer(child, pair); [EOL]         if (value != null || !typeInfo.isPrimitive()) { [EOL]             f.set(parent, value); [EOL]         } [EOL]         return true; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         String fName = getFieldName(f); [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonElement child = json.getAsJsonObject().get(fName); [EOL]         TypeInfo typeInfo = new TypeInfo(declaredTypeOfField); [EOL]         if (child == null) { [EOL]             return true; [EOL]         } else if (child.isJsonNull()) { [EOL]             if (!typeInfo.isPrimitive()) { [EOL]                 f.set(parent, null); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(null, declaredTypeOfField, false); [EOL]         Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers); [EOL]         if (pair == null) { [EOL]             return false; [EOL]         } [EOL]         Object value = invokeCustomDeserializer(child, pair); [EOL]         if (value != null || !typeInfo.isPrimitive()) { [EOL]             f.set(parent, value); [EOL]         } [EOL]         return true; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         String fName = getFieldName(f); [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonElement child = json.getAsJsonObject().get(fName); [EOL]         TypeInfo typeInfo = new TypeInfo(declaredTypeOfField); [EOL]         if (child == null) { [EOL]             return true; [EOL]         } else if (child.isJsonNull()) { [EOL]             if (!typeInfo.isPrimitive()) { [EOL]                 f.set(parent, null); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(null, declaredTypeOfField, false); [EOL]         Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers); [EOL]         if (pair == null) { [EOL]             return false; [EOL]         } [EOL]         Object value = invokeCustomDeserializer(child, pair); [EOL]         if (value != null || !typeInfo.isPrimitive()) { [EOL]             f.set(parent, value); [EOL]         } [EOL]         return true; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         String fName = getFieldName(f); [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonElement child = json.getAsJsonObject().get(fName); [EOL]         TypeInfo typeInfo = new TypeInfo(declaredTypeOfField); [EOL]         if (child == null) { [EOL]             return true; [EOL]         } else if (child.isJsonNull()) { [EOL]             if (!typeInfo.isPrimitive()) { [EOL]                 f.set(parent, null); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(null, declaredTypeOfField, false); [EOL]         Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers); [EOL]         if (pair == null) { [EOL]             return false; [EOL]         } [EOL]         Object value = invokeCustomDeserializer(child, pair); [EOL]         if (value != null || !typeInfo.isPrimitive()) { [EOL]             f.set(parent, value); [EOL]         } [EOL]         return true; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } [EOL] }
public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type declaredTypeOfField, Object parent) { [EOL]     try { [EOL]         String fName = getFieldName(f); [EOL]         if (!json.isJsonObject()) { [EOL]             throw new JsonParseException("Expecting object found: " + json); [EOL]         } [EOL]         JsonElement child = json.getAsJsonObject().get(fName); [EOL]         TypeInfo typeInfo = new TypeInfo(declaredTypeOfField); [EOL]         if (child == null) { [EOL]             return true; [EOL]         } else if (child.isJsonNull()) { [EOL]             if (!typeInfo.isPrimitive()) { [EOL]                 f.set(parent, null); [EOL]             } [EOL]             return true; [EOL]         } [EOL]         ObjectTypePair objTypePair = new ObjectTypePair(null, declaredTypeOfField, false); [EOL]         Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers); [EOL]         if (pair == null) { [EOL]             return false; [EOL]         } [EOL]         Object value = invokeCustomDeserializer(child, pair); [EOL]         if (value != null || !typeInfo.isPrimitive()) { [EOL]             f.set(parent, value); [EOL]         } [EOL]         return true; [EOL]     } catch (IllegalAccessException e) { [EOL]         throw new RuntimeException(); [EOL]     } [EOL] }
public ObjectNavigatorFactory(ExclusionStrategy strategy, FieldNamingStrategy2 fieldNamingPolicy) { [EOL]     Preconditions.checkNotNull(fieldNamingPolicy); [EOL]     this.strategy = (strategy == null ? new NullExclusionStrategy() : strategy); [EOL]     this.fieldNamingPolicy = fieldNamingPolicy; [EOL] }
public ObjectNavigatorFactory(ExclusionStrategy strategy, FieldNamingStrategy2 fieldNamingPolicy) { [EOL]     Preconditions.checkNotNull(fieldNamingPolicy); [EOL]     this.strategy = (strategy == null ? new NullExclusionStrategy() : strategy); [EOL]     this.fieldNamingPolicy = fieldNamingPolicy; [EOL] }
public ObjectNavigatorFactory(ExclusionStrategy strategy, FieldNamingStrategy2 fieldNamingPolicy) { [EOL]     Preconditions.checkNotNull(fieldNamingPolicy); [EOL]     this.strategy = (strategy == null ? new NullExclusionStrategy() : strategy); [EOL]     this.fieldNamingPolicy = fieldNamingPolicy; [EOL] }
public ObjectNavigator create(ObjectTypePair objTypePair) { [EOL]     return new ObjectNavigator(objTypePair, strategy); [EOL] }
public ObjectNavigator create(ObjectTypePair objTypePair) { [EOL]     return new ObjectNavigator(objTypePair, strategy); [EOL] }
public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (!(json instanceof JsonPrimitive)) { [EOL]         throw new JsonParseException("The date should be a string value"); [EOL]     } [EOL]     try { [EOL]         synchronized (format) { [EOL]             return format.parse(json.getAsString()); [EOL]         } [EOL]     } catch (ParseException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (!(json instanceof JsonPrimitive)) { [EOL]         throw new JsonParseException("The date should be a string value"); [EOL]     } [EOL]     try { [EOL]         synchronized (format) { [EOL]             return format.parse(json.getAsString()); [EOL]         } [EOL]     } catch (ParseException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (!(json instanceof JsonPrimitive)) { [EOL]         throw new JsonParseException("The date should be a string value"); [EOL]     } [EOL]     try { [EOL]         synchronized (format) { [EOL]             return format.parse(json.getAsString()); [EOL]         } [EOL]     } catch (ParseException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     Date date = context.deserialize(json, Date.class); [EOL]     return new Timestamp(date.getTime()); [EOL] }
public Timestamp deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     Date date = context.deserialize(json, Date.class); [EOL]     return new Timestamp(date.getTime()); [EOL] }
public JsonElement serialize(GregorianCalendar src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     JsonObject obj = new JsonObject(); [EOL]     obj.addProperty(YEAR, src.get(Calendar.YEAR)); [EOL]     obj.addProperty(MONTH, src.get(Calendar.MONTH)); [EOL]     obj.addProperty(DAY_OF_MONTH, src.get(Calendar.DAY_OF_MONTH)); [EOL]     obj.addProperty(HOUR_OF_DAY, src.get(Calendar.HOUR_OF_DAY)); [EOL]     obj.addProperty(MINUTE, src.get(Calendar.MINUTE)); [EOL]     obj.addProperty(SECOND, src.get(Calendar.SECOND)); [EOL]     return obj; [EOL] }
public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src.name()); [EOL] }
public JsonElement serialize(T src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src.name()); [EOL] }
@SuppressWarnings("cast") [EOL] public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return (T) Enum.valueOf((Class<T>) classOfT, json.getAsString()); [EOL] }
@SuppressWarnings("cast") [EOL] public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return (T) Enum.valueOf((Class<T>) classOfT, json.getAsString()); [EOL] }
@SuppressWarnings("cast") [EOL] public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return (T) Enum.valueOf((Class<T>) classOfT, json.getAsString()); [EOL] }
@SuppressWarnings("cast") [EOL] public T deserialize(JsonElement json, Type classOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return (T) Enum.valueOf((Class<T>) classOfT, json.getAsString()); [EOL] }
public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     try { [EOL]         return new URL(json.getAsString()); [EOL]     } catch (MalformedURLException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
public URL deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     try { [EOL]         return new URL(json.getAsString()); [EOL]     } catch (MalformedURLException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src.toString()); [EOL] }
public JsonElement serialize(UUID src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src.toString()); [EOL] }
public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     String locale = json.getAsString(); [EOL]     StringTokenizer tokenizer = new StringTokenizer(locale, "_"); [EOL]     String language = null; [EOL]     String country = null; [EOL]     String variant = null; [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         language = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         country = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         variant = tokenizer.nextToken(); [EOL]     } [EOL]     if (country == null && variant == null) { [EOL]         return new Locale(language); [EOL]     } else if (variant == null) { [EOL]         return new Locale(language, country); [EOL]     } else { [EOL]         return new Locale(language, country, variant); [EOL]     } [EOL] }
public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     String locale = json.getAsString(); [EOL]     StringTokenizer tokenizer = new StringTokenizer(locale, "_"); [EOL]     String language = null; [EOL]     String country = null; [EOL]     String variant = null; [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         language = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         country = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         variant = tokenizer.nextToken(); [EOL]     } [EOL]     if (country == null && variant == null) { [EOL]         return new Locale(language); [EOL]     } else if (variant == null) { [EOL]         return new Locale(language, country); [EOL]     } else { [EOL]         return new Locale(language, country, variant); [EOL]     } [EOL] }
public Locale deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     String locale = json.getAsString(); [EOL]     StringTokenizer tokenizer = new StringTokenizer(locale, "_"); [EOL]     String language = null; [EOL]     String country = null; [EOL]     String variant = null; [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         language = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         country = tokenizer.nextToken(); [EOL]     } [EOL]     if (tokenizer.hasMoreElements()) { [EOL]         variant = tokenizer.nextToken(); [EOL]     } [EOL]     if (country == null && variant == null) { [EOL]         return new Locale(language); [EOL]     } else if (variant == null) { [EOL]         return new Locale(language, country); [EOL]     } else { [EOL]         return new Locale(language, country, variant); [EOL]     } [EOL] }
public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (src == null) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } [EOL]     JsonArray array = new JsonArray(); [EOL]     Type childGenericType = null; [EOL]     if (typeOfSrc instanceof ParameterizedType) { [EOL]         childGenericType = new TypeInfoCollection(typeOfSrc).getElementType(); [EOL]     } [EOL]     for (Object child : src) { [EOL]         if (child == null) { [EOL]             array.add(JsonNull.createJsonNull()); [EOL]         } else { [EOL]             Type childType = (childGenericType == null || childGenericType == Object.class) ? child.getClass() : childGenericType; [EOL]             JsonElement element = context.serialize(child, childType); [EOL]             array.add(element); [EOL]         } [EOL]     } [EOL]     return array; [EOL] }
public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (src == null) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } [EOL]     JsonArray array = new JsonArray(); [EOL]     Type childGenericType = null; [EOL]     if (typeOfSrc instanceof ParameterizedType) { [EOL]         childGenericType = new TypeInfoCollection(typeOfSrc).getElementType(); [EOL]     } [EOL]     for (Object child : src) { [EOL]         if (child == null) { [EOL]             array.add(JsonNull.createJsonNull()); [EOL]         } else { [EOL]             Type childType = (childGenericType == null || childGenericType == Object.class) ? child.getClass() : childGenericType; [EOL]             JsonElement element = context.serialize(child, childType); [EOL]             array.add(element); [EOL]         } [EOL]     } [EOL]     return array; [EOL] }
public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (src == null) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } [EOL]     JsonArray array = new JsonArray(); [EOL]     Type childGenericType = null; [EOL]     if (typeOfSrc instanceof ParameterizedType) { [EOL]         childGenericType = new TypeInfoCollection(typeOfSrc).getElementType(); [EOL]     } [EOL]     for (Object child : src) { [EOL]         if (child == null) { [EOL]             array.add(JsonNull.createJsonNull()); [EOL]         } else { [EOL]             Type childType = (childGenericType == null || childGenericType == Object.class) ? child.getClass() : childGenericType; [EOL]             JsonElement element = context.serialize(child, childType); [EOL]             array.add(element); [EOL]         } [EOL]     } [EOL]     return array; [EOL] }
public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (src == null) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } [EOL]     JsonArray array = new JsonArray(); [EOL]     Type childGenericType = null; [EOL]     if (typeOfSrc instanceof ParameterizedType) { [EOL]         childGenericType = new TypeInfoCollection(typeOfSrc).getElementType(); [EOL]     } [EOL]     for (Object child : src) { [EOL]         if (child == null) { [EOL]             array.add(JsonNull.createJsonNull()); [EOL]         } else { [EOL]             Type childType = (childGenericType == null || childGenericType == Object.class) ? child.getClass() : childGenericType; [EOL]             JsonElement element = context.serialize(child, childType); [EOL]             array.add(element); [EOL]         } [EOL]     } [EOL]     return array; [EOL] }
public JsonElement serialize(Collection src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     if (src == null) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } [EOL]     JsonArray array = new JsonArray(); [EOL]     Type childGenericType = null; [EOL]     if (typeOfSrc instanceof ParameterizedType) { [EOL]         childGenericType = new TypeInfoCollection(typeOfSrc).getElementType(); [EOL]     } [EOL]     for (Object child : src) { [EOL]         if (child == null) { [EOL]             array.add(JsonNull.createJsonNull()); [EOL]         } else { [EOL]             Type childType = (childGenericType == null || childGenericType == Object.class) ? child.getClass() : childGenericType; [EOL]             JsonElement element = context.serialize(child, childType); [EOL]             array.add(element); [EOL]         } [EOL]     } [EOL]     return array; [EOL] }
public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (json.isJsonNull()) { [EOL]         return null; [EOL]     } [EOL]     Collection collection = constructCollectionType(typeOfT, context); [EOL]     Type childType = new TypeInfoCollection(typeOfT).getElementType(); [EOL]     for (JsonElement childElement : json.getAsJsonArray()) { [EOL]         if (childElement == null || childElement.isJsonNull()) { [EOL]             collection.add(null); [EOL]         } else { [EOL]             Object value = context.deserialize(childElement, childType); [EOL]             collection.add(value); [EOL]         } [EOL]     } [EOL]     return collection; [EOL] }
public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (json.isJsonNull()) { [EOL]         return null; [EOL]     } [EOL]     Collection collection = constructCollectionType(typeOfT, context); [EOL]     Type childType = new TypeInfoCollection(typeOfT).getElementType(); [EOL]     for (JsonElement childElement : json.getAsJsonArray()) { [EOL]         if (childElement == null || childElement.isJsonNull()) { [EOL]             collection.add(null); [EOL]         } else { [EOL]             Object value = context.deserialize(childElement, childType); [EOL]             collection.add(value); [EOL]         } [EOL]     } [EOL]     return collection; [EOL] }
public Collection deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     if (json.isJsonNull()) { [EOL]         return null; [EOL]     } [EOL]     Collection collection = constructCollectionType(typeOfT, context); [EOL]     Type childType = new TypeInfoCollection(typeOfT).getElementType(); [EOL]     for (JsonElement childElement : json.getAsJsonArray()) { [EOL]         if (childElement == null || childElement.isJsonNull()) { [EOL]             collection.add(null); [EOL]         } else { [EOL]             Object value = context.deserialize(childElement, childType); [EOL]             collection.add(value); [EOL]         } [EOL]     } [EOL]     return collection; [EOL] }
private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context) { [EOL]     JsonDeserializationContextDefault contextImpl = (JsonDeserializationContextDefault) context; [EOL]     ObjectConstructor objectConstructor = contextImpl.getObjectConstructor(); [EOL]     return (Collection) objectConstructor.construct(collectionType); [EOL] }
private Collection constructCollectionType(Type collectionType, JsonDeserializationContext context) { [EOL]     JsonDeserializationContextDefault contextImpl = (JsonDeserializationContextDefault) context; [EOL]     ObjectConstructor objectConstructor = contextImpl.getObjectConstructor(); [EOL]     return (Collection) objectConstructor.construct(collectionType); [EOL] }
public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     JsonObject map = new JsonObject(); [EOL]     Type childGenericType = null; [EOL]     if (typeOfSrc instanceof ParameterizedType) { [EOL]         childGenericType = new TypeInfoMap(typeOfSrc).getValueType(); [EOL]     } [EOL]     for (Map.Entry entry : (Set<Map.Entry>) src.entrySet()) { [EOL]         Object value = entry.getValue(); [EOL]         JsonElement valueElement; [EOL]         if (value == null) { [EOL]             valueElement = JsonNull.createJsonNull(); [EOL]         } else { [EOL]             Type childType = (childGenericType == null) ? value.getClass() : childGenericType; [EOL]             valueElement = context.serialize(value, childType); [EOL]         } [EOL]         map.add(String.valueOf(entry.getKey()), valueElement); [EOL]     } [EOL]     return map; [EOL] }
public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     JsonObject map = new JsonObject(); [EOL]     Type childGenericType = null; [EOL]     if (typeOfSrc instanceof ParameterizedType) { [EOL]         childGenericType = new TypeInfoMap(typeOfSrc).getValueType(); [EOL]     } [EOL]     for (Map.Entry entry : (Set<Map.Entry>) src.entrySet()) { [EOL]         Object value = entry.getValue(); [EOL]         JsonElement valueElement; [EOL]         if (value == null) { [EOL]             valueElement = JsonNull.createJsonNull(); [EOL]         } else { [EOL]             Type childType = (childGenericType == null) ? value.getClass() : childGenericType; [EOL]             valueElement = context.serialize(value, childType); [EOL]         } [EOL]         map.add(String.valueOf(entry.getKey()), valueElement); [EOL]     } [EOL]     return map; [EOL] }
public JsonElement serialize(Map src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     JsonObject map = new JsonObject(); [EOL]     Type childGenericType = null; [EOL]     if (typeOfSrc instanceof ParameterizedType) { [EOL]         childGenericType = new TypeInfoMap(typeOfSrc).getValueType(); [EOL]     } [EOL]     for (Map.Entry entry : (Set<Map.Entry>) src.entrySet()) { [EOL]         Object value = entry.getValue(); [EOL]         JsonElement valueElement; [EOL]         if (value == null) { [EOL]             valueElement = JsonNull.createJsonNull(); [EOL]         } else { [EOL]             Type childType = (childGenericType == null) ? value.getClass() : childGenericType; [EOL]             valueElement = context.serialize(value, childType); [EOL]         } [EOL]         map.add(String.valueOf(entry.getKey()), valueElement); [EOL]     } [EOL]     return map; [EOL] }
public Map createInstance(Type type) { [EOL]     return new LinkedHashMap(); [EOL] }
public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src); [EOL] }
public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context) { [EOL]     return new JsonPrimitive(src); [EOL] }
public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsInt(); [EOL] }
public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsInt(); [EOL] }
public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsDouble(); [EOL] }
public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException { [EOL]     return json.getAsDouble(); [EOL] }
public TreeSet<?> createInstance(Type type) { [EOL]     return new TreeSet<Object>(); [EOL] }
public TreeSet<?> createInstance(Type type) { [EOL]     return new TreeSet<Object>(); [EOL] }
public HashSet<?> createInstance(Type type) { [EOL]     return new HashSet<Object>(); [EOL] }
public TypeInfoMap(Type mapType) { [EOL]     if (mapType instanceof Class<?> && Properties.class.isAssignableFrom((Class<?>) mapType)) { [EOL]         keyType = String.class; [EOL]         valueType = String.class; [EOL]     } else if (mapType instanceof ParameterizedType) { [EOL]         TypeInfo rawType = new TypeInfo(mapType); [EOL]         Preconditions.checkArgument(Map.class.isAssignableFrom(rawType.getRawClass())); [EOL]         ParameterizedType paramType = (ParameterizedType) mapType; [EOL]         keyType = paramType.getActualTypeArguments()[0]; [EOL]         valueType = paramType.getActualTypeArguments()[1]; [EOL]     } else { [EOL]         throw new IllegalArgumentException("Map objects need to be parameterized unless you use a custom serializer. " + "Use the com.google.gson.reflect.TypeToken to extract the ParameterizedType."); [EOL]     } [EOL] }
public TypeInfoMap(Type mapType) { [EOL]     if (mapType instanceof Class<?> && Properties.class.isAssignableFrom((Class<?>) mapType)) { [EOL]         keyType = String.class; [EOL]         valueType = String.class; [EOL]     } else if (mapType instanceof ParameterizedType) { [EOL]         TypeInfo rawType = new TypeInfo(mapType); [EOL]         Preconditions.checkArgument(Map.class.isAssignableFrom(rawType.getRawClass())); [EOL]         ParameterizedType paramType = (ParameterizedType) mapType; [EOL]         keyType = paramType.getActualTypeArguments()[0]; [EOL]         valueType = paramType.getActualTypeArguments()[1]; [EOL]     } else { [EOL]         throw new IllegalArgumentException("Map objects need to be parameterized unless you use a custom serializer. " + "Use the com.google.gson.reflect.TypeToken to extract the ParameterizedType."); [EOL]     } [EOL] }
public TypeInfoMap(Type mapType) { [EOL]     if (mapType instanceof Class<?> && Properties.class.isAssignableFrom((Class<?>) mapType)) { [EOL]         keyType = String.class; [EOL]         valueType = String.class; [EOL]     } else if (mapType instanceof ParameterizedType) { [EOL]         TypeInfo rawType = new TypeInfo(mapType); [EOL]         Preconditions.checkArgument(Map.class.isAssignableFrom(rawType.getRawClass())); [EOL]         ParameterizedType paramType = (ParameterizedType) mapType; [EOL]         keyType = paramType.getActualTypeArguments()[0]; [EOL]         valueType = paramType.getActualTypeArguments()[1]; [EOL]     } else { [EOL]         throw new IllegalArgumentException("Map objects need to be parameterized unless you use a custom serializer. " + "Use the com.google.gson.reflect.TypeToken to extract the ParameterizedType."); [EOL]     } [EOL] }
public Type getKeyType() { [EOL]     return keyType; [EOL] }
public Type getValueType() { [EOL]     return valueType; [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static JsonElement parse(JsonReader reader) throws JsonParseException { [EOL]     try { [EOL]         switch(reader.peek()) { [EOL]             case STRING: [EOL]                 return new JsonPrimitive(reader.nextString()); [EOL]             case NUMBER: [EOL]                 String number = reader.nextString(); [EOL]                 return new JsonPrimitive(JsonPrimitive.stringToNumber(number)); [EOL]             case BOOLEAN: [EOL]                 return new JsonPrimitive(reader.nextBoolean()); [EOL]             case NULL: [EOL]                 reader.nextNull(); [EOL]                 return JsonNull.createJsonNull(); [EOL]             case BEGIN_ARRAY: [EOL]                 JsonArray array = new JsonArray(); [EOL]                 reader.beginArray(); [EOL]                 while (reader.hasNext()) { [EOL]                     array.add(parse(reader)); [EOL]                 } [EOL]                 reader.endArray(); [EOL]                 return array; [EOL]             case BEGIN_OBJECT: [EOL]                 JsonObject object = new JsonObject(); [EOL]                 reader.beginObject(); [EOL]                 while (reader.hasNext()) { [EOL]                     object.add(reader.nextName(), parse(reader)); [EOL]                 } [EOL]                 reader.endObject(); [EOL]                 return object; [EOL]             case END_DOCUMENT: [EOL]             case NAME: [EOL]             case END_OBJECT: [EOL]             case END_ARRAY: [EOL]             default: [EOL]                 throw new IllegalArgumentException(); [EOL]         } [EOL]     } catch (EOFException e) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } catch (MalformedJsonException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } catch (IOException e) { [EOL]         throw new JsonIOException(e); [EOL]     } catch (NumberFormatException e) { [EOL]         throw new JsonSyntaxException(e); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static void write(JsonElement element, boolean serializeNulls, JsonWriter writer) throws IOException { [EOL]     if (element == null || element.isJsonNull()) { [EOL]         if (serializeNulls) { [EOL]             writer.nullValue(); [EOL]         } [EOL]     } else if (element.isJsonPrimitive()) { [EOL]         JsonPrimitive primitive = element.getAsJsonPrimitive(); [EOL]         if (primitive.isNumber()) { [EOL]             writer.value(primitive.getAsNumber()); [EOL]         } else if (primitive.isBoolean()) { [EOL]             writer.value(primitive.getAsBoolean()); [EOL]         } else { [EOL]             writer.value(primitive.getAsString()); [EOL]         } [EOL]     } else if (element.isJsonArray()) { [EOL]         writer.beginArray(); [EOL]         for (JsonElement e : element.getAsJsonArray()) { [EOL]             if (e.isJsonNull()) { [EOL]                 writer.nullValue(); [EOL]                 continue; [EOL]             } [EOL]             write(e, serializeNulls, writer); [EOL]         } [EOL]         writer.endArray(); [EOL]     } else if (element.isJsonObject()) { [EOL]         writer.beginObject(); [EOL]         for (Map.Entry<String, JsonElement> e : element.getAsJsonObject().entrySet()) { [EOL]             JsonElement value = e.getValue(); [EOL]             if (!serializeNulls && value.isJsonNull()) { [EOL]                 continue; [EOL]             } [EOL]             writer.name(e.getKey()); [EOL]             write(value, serializeNulls, writer); [EOL]         } [EOL]         writer.endObject(); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Couldn't write " + element.getClass()); [EOL]     } [EOL] }
static Writer writerForAppendable(Appendable appendable) { [EOL]     return appendable instanceof Writer ? (Writer) appendable : new AppendableWriter(appendable); [EOL] }
static Writer writerForAppendable(Appendable appendable) { [EOL]     return appendable instanceof Writer ? (Writer) appendable : new AppendableWriter(appendable); [EOL] }
public static void checkNotNull(Object obj) { [EOL]     checkArgument(obj != null); [EOL] }
public static void checkNotNull(Object obj) { [EOL]     checkArgument(obj != null); [EOL] }
@Override [EOL] public BigDecimal getAsBigDecimal() { [EOL]     if (elements.size() == 1) { [EOL]         return elements.get(0).getAsBigDecimal(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
@Override [EOL] public BigDecimal getAsBigDecimal() { [EOL]     if (elements.size() == 1) { [EOL]         return elements.get(0).getAsBigDecimal(); [EOL]     } [EOL]     throw new IllegalStateException(); [EOL] }
private FieldNamingPolicy(FieldNamingStrategy2 namingPolicy) { [EOL]     this.namingPolicy = namingPolicy; [EOL] }
FieldNamingStrategy2 getFieldNamingPolicy() { [EOL]     return namingPolicy; [EOL] }
public Type getRawType() { [EOL]     return rawType; [EOL] }
public Type[] getActualTypeArguments() { [EOL]     return actualTypeArguments; [EOL] }
public Type[] getActualTypeArguments() { [EOL]     return actualTypeArguments; [EOL] }
public Type[] getActualTypeArguments() { [EOL]     return actualTypeArguments; [EOL] }
public Type getOwnerType() { [EOL]     return owner; [EOL] }
public Type getOwnerType() { [EOL]     return owner; [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return Arrays.hashCode(actualTypeArguments) ^ (owner == null ? 0 : owner.hashCode()) ^ (rawType == null ? 0 : rawType.hashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return Arrays.hashCode(actualTypeArguments) ^ (owner == null ? 0 : owner.hashCode()) ^ (rawType == null ? 0 : rawType.hashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return Arrays.hashCode(actualTypeArguments) ^ (owner == null ? 0 : owner.hashCode()) ^ (rawType == null ? 0 : rawType.hashCode()); [EOL] }
@Override [EOL] public int hashCode() { [EOL]     return Arrays.hashCode(actualTypeArguments) ^ (owner == null ? 0 : owner.hashCode()) ^ (rawType == null ? 0 : rawType.hashCode()); [EOL] }
static Type getActualTypeForFirstTypeVariable(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return Object.class; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         return ((ParameterizedType) type).getActualTypeArguments()[0]; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         return getActualTypeForFirstTypeVariable(((GenericArrayType) type).getGenericComponentType()); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + type + "\' is not a Class, " + "ParameterizedType, or GenericArrayType. Can't extract class."); [EOL]     } [EOL] }
static Type getActualTypeForFirstTypeVariable(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return Object.class; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         return ((ParameterizedType) type).getActualTypeArguments()[0]; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         return getActualTypeForFirstTypeVariable(((GenericArrayType) type).getGenericComponentType()); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + type + "\' is not a Class, " + "ParameterizedType, or GenericArrayType. Can't extract class."); [EOL]     } [EOL] }
static Type getActualTypeForFirstTypeVariable(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return Object.class; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         return ((ParameterizedType) type).getActualTypeArguments()[0]; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         return getActualTypeForFirstTypeVariable(((GenericArrayType) type).getGenericComponentType()); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + type + "\' is not a Class, " + "ParameterizedType, or GenericArrayType. Can't extract class."); [EOL]     } [EOL] }
static Type getActualTypeForFirstTypeVariable(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return Object.class; [EOL]     } else if (type instanceof ParameterizedType) { [EOL]         return ((ParameterizedType) type).getActualTypeArguments()[0]; [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         return getActualTypeForFirstTypeVariable(((GenericArrayType) type).getGenericComponentType()); [EOL]     } else { [EOL]         throw new IllegalArgumentException("Type \'" + type + "\' is not a Class, " + "ParameterizedType, or GenericArrayType. Can't extract class."); [EOL]     } [EOL] }
static boolean isArray(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return ((Class<?>) type).isArray(); [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         return true; [EOL]     } else { [EOL]         return false; [EOL]     } [EOL] }
static boolean isArray(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return ((Class<?>) type).isArray(); [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         return true; [EOL]     } else { [EOL]         return false; [EOL]     } [EOL] }
static boolean isArray(Type type) { [EOL]     if (type instanceof Class<?>) { [EOL]         return ((Class<?>) type).isArray(); [EOL]     } else if (type instanceof GenericArrayType) { [EOL]         return true; [EOL]     } else { [EOL]         return false; [EOL]     } [EOL] }
public SerializedNameAnnotationInterceptingNamingPolicy(FieldNamingStrategy2 delegate) { [EOL]     this.delegate = delegate; [EOL] }
public SerializedNameAnnotationInterceptingNamingPolicy(FieldNamingStrategy2 delegate) { [EOL]     this.delegate = delegate; [EOL] }
public void toJson(Object src, Appendable writer) { [EOL]     try { [EOL]         if (src != null) { [EOL]             toJson(src, src.getClass(), writer); [EOL]         } else if (serializeNulls) { [EOL]             writeOutNullString(writer); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw new RuntimeException(ioe); [EOL]     } [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public void toJson(Object src, Appendable writer) { [EOL]     try { [EOL]         if (src != null) { [EOL]             toJson(src, src.getClass(), writer); [EOL]         } else if (serializeNulls) { [EOL]             writeOutNullString(writer); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw new RuntimeException(ioe); [EOL]     } [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public void toJson(Object src, Appendable writer) { [EOL]     try { [EOL]         if (src != null) { [EOL]             toJson(src, src.getClass(), writer); [EOL]         } else if (serializeNulls) { [EOL]             writeOutNullString(writer); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw new RuntimeException(ioe); [EOL]     } [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public void toJson(Object src, Appendable writer) { [EOL]     try { [EOL]         if (src != null) { [EOL]             toJson(src, src.getClass(), writer); [EOL]         } else if (serializeNulls) { [EOL]             writeOutNullString(writer); [EOL]         } [EOL]     } catch (IOException ioe) { [EOL]         throw new RuntimeException(ioe); [EOL]     } [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public void toJson(Object src, Type typeOfSrc, Appendable writer) { [EOL]     JsonElement jsonElement = toJsonTree(src, typeOfSrc); [EOL]     toJson(jsonElement, writer); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public void toJson(Object src, Type typeOfSrc, Appendable writer) { [EOL]     JsonElement jsonElement = toJsonTree(src, typeOfSrc); [EOL]     toJson(jsonElement, writer); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public void toJson(Object src, Type typeOfSrc, Appendable writer) { [EOL]     JsonElement jsonElement = toJsonTree(src, typeOfSrc); [EOL]     toJson(jsonElement, writer); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public String toJson(JsonElement jsonElement) { [EOL]     StringWriter writer = new StringWriter(); [EOL]     toJson(jsonElement, writer); [EOL]     return writer.toString(); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public String toJson(JsonElement jsonElement) { [EOL]     StringWriter writer = new StringWriter(); [EOL]     toJson(jsonElement, writer); [EOL]     return writer.toString(); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonParseException { [EOL]     Object object = fromJson(new JsonReader(json), classOfT); [EOL]     return Primitives.wrap(classOfT).cast(object); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonParseException { [EOL]     Object object = fromJson(new JsonReader(json), classOfT); [EOL]     return Primitives.wrap(classOfT).cast(object); [EOL] } public Gson();  Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy, FieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting); private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy); private static ExclusionStrategy createExclusionStrategy(double version); public JsonElement toJsonTree(Object src); public JsonElement toJsonTree(Object src, Type typeOfSrc); public String toJson(Object src); public String toJson(Object src, Type typeOfSrc); public void toJson(Object src, Appendable writer); public void toJson(Object src, Type typeOfSrc, Appendable writer); public void toJson(Object src, Type typeOfSrc, JsonWriter writer); public String toJson(JsonElement jsonElement); public void toJson(JsonElement jsonElement, Appendable writer); public void toJson(JsonElement jsonElement, JsonWriter writer); public T fromJson(String json, Class<T> classOfT) throws JsonParseException; public T fromJson(String json, Type typeOfT) throws JsonParseException; public T fromJson(Reader json, Class<T> classOfT) throws JsonParseException; public T fromJson(Reader json, Type typeOfT) throws JsonParseException; public T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException; public T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException; public T fromJson(JsonElement json, Type typeOfT) throws JsonParseException; private void writeOutNullString(Appendable writer) throws IOException; public String toString(); String NULL_STRING=Optional["null"]; boolean DEFAULT_JSON_NON_EXECUTABLE=Optional[false]; AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY=Optional[new AnonymousAndLocalClassExclusionStrategy()]; SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY=Optional[new SyntheticFieldExclusionStrategy(true)]; ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY=Optional[new ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC })]; FieldNamingStrategy2 DEFAULT_NAMING_POLICY=Optional[new SerializedNameAnnotationInterceptingNamingPolicy(new JavaFieldNamingPolicy())]; ExclusionStrategy DEFAULT_EXCLUSION_STRATEGY=Optional[createExclusionStrategy(VersionConstants.IGNORE_VERSIONS)]; String JSON_NON_EXECUTABLE_PREFIX=Optional[")]}
JsonSerializationContextDefault(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers) { [EOL]     this.factory = factory; [EOL]     this.serializeNulls = serializeNulls; [EOL]     this.serializers = serializers; [EOL]     this.ancestors = new MemoryRefStack(); [EOL] }
JsonSerializationContextDefault(ObjectNavigatorFactory factory, boolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers) { [EOL]     this.factory = factory; [EOL]     this.serializeNulls = serializeNulls; [EOL]     this.serializers = serializers; [EOL]     this.ancestors = new MemoryRefStack(); [EOL] }
public JsonElement serialize(Object src) { [EOL]     if (src == null) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } [EOL]     return serialize(src, src.getClass(), true); [EOL] }
public JsonElement serialize(Object src) { [EOL]     if (src == null) { [EOL]         return JsonNull.createJsonNull(); [EOL]     } [EOL]     return serialize(src, src.getClass(), true); [EOL] }
public JsonElement serialize(Object src, Type typeOfSrc) { [EOL]     return serialize(src, typeOfSrc, true); [EOL] }
public JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType) { [EOL]     ObjectNavigator on = factory.create(new ObjectTypePair(src, typeOfSrc, preserveType)); [EOL]     JsonSerializationVisitor visitor = new JsonSerializationVisitor(factory, serializeNulls, serializers, this, ancestors); [EOL]     on.accept(visitor); [EOL]     return visitor.getJsonElement(); [EOL] }
public JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType) { [EOL]     ObjectNavigator on = factory.create(new ObjectTypePair(src, typeOfSrc, preserveType)); [EOL]     JsonSerializationVisitor visitor = new JsonSerializationVisitor(factory, serializeNulls, serializers, this, ancestors); [EOL]     on.accept(visitor); [EOL]     return visitor.getJsonElement(); [EOL] }
public JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType) { [EOL]     ObjectNavigator on = factory.create(new ObjectTypePair(src, typeOfSrc, preserveType)); [EOL]     JsonSerializationVisitor visitor = new JsonSerializationVisitor(factory, serializeNulls, serializers, this, ancestors); [EOL]     on.accept(visitor); [EOL]     return visitor.getJsonElement(); [EOL] }
public JsonNull() { [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException { [EOL]     if (json == null || json.isJsonNull()) { [EOL]         return null; [EOL]     } else if (json.isJsonArray()) { [EOL]         return (T) fromJsonArray(typeOfT, json.getAsJsonArray(), this); [EOL]     } else if (json.isJsonObject()) { [EOL]         return (T) fromJsonObject(typeOfT, json.getAsJsonObject(), this); [EOL]     } else if (json.isJsonPrimitive()) { [EOL]         return (T) fromJsonPrimitive(typeOfT, json.getAsJsonPrimitive(), this); [EOL]     } else { [EOL]         throw new JsonParseException("Failed parsing JSON source: " + json + " to Json"); [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException { [EOL]     if (json == null || json.isJsonNull()) { [EOL]         return null; [EOL]     } else if (json.isJsonArray()) { [EOL]         return (T) fromJsonArray(typeOfT, json.getAsJsonArray(), this); [EOL]     } else if (json.isJsonObject()) { [EOL]         return (T) fromJsonObject(typeOfT, json.getAsJsonObject(), this); [EOL]     } else if (json.isJsonPrimitive()) { [EOL]         return (T) fromJsonPrimitive(typeOfT, json.getAsJsonPrimitive(), this); [EOL]     } else { [EOL]         throw new JsonParseException("Failed parsing JSON source: " + json + " to Json"); [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException { [EOL]     if (json == null || json.isJsonNull()) { [EOL]         return null; [EOL]     } else if (json.isJsonArray()) { [EOL]         return (T) fromJsonArray(typeOfT, json.getAsJsonArray(), this); [EOL]     } else if (json.isJsonObject()) { [EOL]         return (T) fromJsonObject(typeOfT, json.getAsJsonObject(), this); [EOL]     } else if (json.isJsonPrimitive()) { [EOL]         return (T) fromJsonPrimitive(typeOfT, json.getAsJsonPrimitive(), this); [EOL]     } else { [EOL]         throw new JsonParseException("Failed parsing JSON source: " + json + " to Json"); [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException { [EOL]     if (json == null || json.isJsonNull()) { [EOL]         return null; [EOL]     } else if (json.isJsonArray()) { [EOL]         return (T) fromJsonArray(typeOfT, json.getAsJsonArray(), this); [EOL]     } else if (json.isJsonObject()) { [EOL]         return (T) fromJsonObject(typeOfT, json.getAsJsonObject(), this); [EOL]     } else if (json.isJsonPrimitive()) { [EOL]         return (T) fromJsonPrimitive(typeOfT, json.getAsJsonPrimitive(), this); [EOL]     } else { [EOL]         throw new JsonParseException("Failed parsing JSON source: " + json + " to Json"); [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException { [EOL]     if (json == null || json.isJsonNull()) { [EOL]         return null; [EOL]     } else if (json.isJsonArray()) { [EOL]         return (T) fromJsonArray(typeOfT, json.getAsJsonArray(), this); [EOL]     } else if (json.isJsonObject()) { [EOL]         return (T) fromJsonObject(typeOfT, json.getAsJsonObject(), this); [EOL]     } else if (json.isJsonPrimitive()) { [EOL]         return (T) fromJsonPrimitive(typeOfT, json.getAsJsonPrimitive(), this); [EOL]     } else { [EOL]         throw new JsonParseException("Failed parsing JSON source: " + json + " to Json"); [EOL]     } [EOL] }
@SuppressWarnings("unchecked") [EOL] public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException { [EOL]     if (json == null || json.isJsonNull()) { [EOL]         return null; [EOL]     } else if (json.isJsonArray()) { [EOL]         return (T) fromJsonArray(typeOfT, json.getAsJsonArray(), this); [EOL]     } else if (json.isJsonObject()) { [EOL]         return (T) fromJsonObject(typeOfT, json.getAsJsonObject(), this); [EOL]     } else if (json.isJsonPrimitive()) { [EOL]         return (T) fromJsonPrimitive(typeOfT, json.getAsJsonPrimitive(), this); [EOL]     } else { [EOL]         throw new JsonParseException("Failed parsing JSON source: " + json + " to Json"); [EOL]     } [EOL] }
private <T> T fromJsonArray(Type arrayType, JsonArray jsonArray, JsonDeserializationContext context) throws JsonParseException { [EOL]     JsonArrayDeserializationVisitor<T> visitor = new JsonArrayDeserializationVisitor<T>(jsonArray, arrayType, navigatorFactory, objectConstructor, deserializers, context); [EOL]     ObjectNavigator on = navigatorFactory.create(new ObjectTypePair(null, arrayType, true)); [EOL]     on.accept(visitor); [EOL]     return visitor.getTarget(); [EOL] }
private <T> T fromJsonArray(Type arrayType, JsonArray jsonArray, JsonDeserializationContext context) throws JsonParseException { [EOL]     JsonArrayDeserializationVisitor<T> visitor = new JsonArrayDeserializationVisitor<T>(jsonArray, arrayType, navigatorFactory, objectConstructor, deserializers, context); [EOL]     ObjectNavigator on = navigatorFactory.create(new ObjectTypePair(null, arrayType, true)); [EOL]     on.accept(visitor); [EOL]     return visitor.getTarget(); [EOL] }
private <T> T fromJsonArray(Type arrayType, JsonArray jsonArray, JsonDeserializationContext context) throws JsonParseException { [EOL]     JsonArrayDeserializationVisitor<T> visitor = new JsonArrayDeserializationVisitor<T>(jsonArray, arrayType, navigatorFactory, objectConstructor, deserializers, context); [EOL]     ObjectNavigator on = navigatorFactory.create(new ObjectTypePair(null, arrayType, true)); [EOL]     on.accept(visitor); [EOL]     return visitor.getTarget(); [EOL] }
public Type getGenericComponentType() { [EOL]     return genericComponentType; [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (!(o instanceof GenericArrayType)) { [EOL]         return false; [EOL]     } [EOL]     GenericArrayType that = (GenericArrayType) o; [EOL]     Type thatComponentType = that.getGenericComponentType(); [EOL]     return genericComponentType == null ? thatComponentType == null : genericComponentType.equals(thatComponentType); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (!(o instanceof GenericArrayType)) { [EOL]         return false; [EOL]     } [EOL]     GenericArrayType that = (GenericArrayType) o; [EOL]     Type thatComponentType = that.getGenericComponentType(); [EOL]     return genericComponentType == null ? thatComponentType == null : genericComponentType.equals(thatComponentType); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (!(o instanceof GenericArrayType)) { [EOL]         return false; [EOL]     } [EOL]     GenericArrayType that = (GenericArrayType) o; [EOL]     Type thatComponentType = that.getGenericComponentType(); [EOL]     return genericComponentType == null ? thatComponentType == null : genericComponentType.equals(thatComponentType); [EOL] }
@Override [EOL] public boolean equals(Object o) { [EOL]     if (!(o instanceof GenericArrayType)) { [EOL]         return false; [EOL]     } [EOL]     GenericArrayType that = (GenericArrayType) o; [EOL]     Type thatComponentType = that.getGenericComponentType(); [EOL]     return genericComponentType == null ? thatComponentType == null : genericComponentType.equals(thatComponentType); [EOL] }
LruCache(int maxCapacity) { [EOL]     super(maxCapacity, 0.7F, true); [EOL]     this.maxCapacity = maxCapacity; [EOL] }
LruCache(int maxCapacity) { [EOL]     super(maxCapacity, 0.7F, true); [EOL]     this.maxCapacity = maxCapacity; [EOL] }
LruCache(int maxCapacity) { [EOL]     super(maxCapacity, 0.7F, true); [EOL]     this.maxCapacity = maxCapacity; [EOL] }
public void addElement(K key, V value) { [EOL]     put(key, value); [EOL] }
public void addElement(K key, V value) { [EOL]     put(key, value); [EOL] }
public void addElement(K key, V value) { [EOL]     put(key, value); [EOL] }
public V getElement(K key) { [EOL]     return get(key); [EOL] }
public int size() { [EOL]     return super.size(); [EOL] }
public int size() { [EOL]     return super.size(); [EOL] }
@Override [EOL] protected boolean removeEldestEntry(Map.Entry<K, V> entry) { [EOL]     return size() > maxCapacity; [EOL] }
@Override [EOL] protected boolean removeEldestEntry(Map.Entry<K, V> entry) { [EOL]     return size() > maxCapacity; [EOL] }
ObjectNavigator(ObjectTypePair objTypePair, ExclusionStrategy exclusionStrategy) { [EOL]     Preconditions.checkNotNull(exclusionStrategy); [EOL]     this.objTypePair = objTypePair; [EOL]     this.exclusionStrategy = exclusionStrategy; [EOL] }
ObjectNavigator(ObjectTypePair objTypePair, ExclusionStrategy exclusionStrategy) { [EOL]     Preconditions.checkNotNull(exclusionStrategy); [EOL]     this.objTypePair = objTypePair; [EOL]     this.exclusionStrategy = exclusionStrategy; [EOL] }
public void accept(Visitor visitor) { [EOL]     TypeInfo objTypeInfo = new TypeInfo(objTypePair.type); [EOL]     if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) { [EOL]         return; [EOL]     } [EOL]     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair); [EOL]     if (!visitedWithCustomHandler) { [EOL]         Object obj = objTypePair.getObject(); [EOL]         Object objectToVisit = (obj == null) ? visitor.getTarget() : obj; [EOL]         if (objectToVisit == null) { [EOL]             return; [EOL]         } [EOL]         objTypePair.setObject(objectToVisit); [EOL]         visitor.start(objTypePair); [EOL]         try { [EOL]             if (objTypeInfo.isArray()) { [EOL]                 visitor.visitArray(objectToVisit, objTypePair.type); [EOL]             } else if (objTypeInfo.getActualType() == Object.class && isPrimitiveOrString(objectToVisit)) { [EOL]                 visitor.visitPrimitive(objectToVisit); [EOL]                 objectToVisit = visitor.getTarget(); [EOL]             } else { [EOL]                 visitor.startVisitingObject(objectToVisit); [EOL]                 ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType(); [EOL]                 Class<?> topLevelClass = new TypeInfo(currObjTypePair.type).getRawClass(); [EOL]                 for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr = curr.getSuperclass()) { [EOL]                     if (!curr.isSynthetic()) { [EOL]                         navigateClassFields(objectToVisit, curr, visitor); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } finally { [EOL]             visitor.end(objTypePair); [EOL]         } [EOL]     } [EOL] }
public void accept(Visitor visitor) { [EOL]     TypeInfo objTypeInfo = new TypeInfo(objTypePair.type); [EOL]     if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) { [EOL]         return; [EOL]     } [EOL]     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair); [EOL]     if (!visitedWithCustomHandler) { [EOL]         Object obj = objTypePair.getObject(); [EOL]         Object objectToVisit = (obj == null) ? visitor.getTarget() : obj; [EOL]         if (objectToVisit == null) { [EOL]             return; [EOL]         } [EOL]         objTypePair.setObject(objectToVisit); [EOL]         visitor.start(objTypePair); [EOL]         try { [EOL]             if (objTypeInfo.isArray()) { [EOL]                 visitor.visitArray(objectToVisit, objTypePair.type); [EOL]             } else if (objTypeInfo.getActualType() == Object.class && isPrimitiveOrString(objectToVisit)) { [EOL]                 visitor.visitPrimitive(objectToVisit); [EOL]                 objectToVisit = visitor.getTarget(); [EOL]             } else { [EOL]                 visitor.startVisitingObject(objectToVisit); [EOL]                 ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType(); [EOL]                 Class<?> topLevelClass = new TypeInfo(currObjTypePair.type).getRawClass(); [EOL]                 for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr = curr.getSuperclass()) { [EOL]                     if (!curr.isSynthetic()) { [EOL]                         navigateClassFields(objectToVisit, curr, visitor); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } finally { [EOL]             visitor.end(objTypePair); [EOL]         } [EOL]     } [EOL] }
public void accept(Visitor visitor) { [EOL]     TypeInfo objTypeInfo = new TypeInfo(objTypePair.type); [EOL]     if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) { [EOL]         return; [EOL]     } [EOL]     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair); [EOL]     if (!visitedWithCustomHandler) { [EOL]         Object obj = objTypePair.getObject(); [EOL]         Object objectToVisit = (obj == null) ? visitor.getTarget() : obj; [EOL]         if (objectToVisit == null) { [EOL]             return; [EOL]         } [EOL]         objTypePair.setObject(objectToVisit); [EOL]         visitor.start(objTypePair); [EOL]         try { [EOL]             if (objTypeInfo.isArray()) { [EOL]                 visitor.visitArray(objectToVisit, objTypePair.type); [EOL]             } else if (objTypeInfo.getActualType() == Object.class && isPrimitiveOrString(objectToVisit)) { [EOL]                 visitor.visitPrimitive(objectToVisit); [EOL]                 objectToVisit = visitor.getTarget(); [EOL]             } else { [EOL]                 visitor.startVisitingObject(objectToVisit); [EOL]                 ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType(); [EOL]                 Class<?> topLevelClass = new TypeInfo(currObjTypePair.type).getRawClass(); [EOL]                 for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr = curr.getSuperclass()) { [EOL]                     if (!curr.isSynthetic()) { [EOL]                         navigateClassFields(objectToVisit, curr, visitor); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } finally { [EOL]             visitor.end(objTypePair); [EOL]         } [EOL]     } [EOL] }
public void accept(Visitor visitor) { [EOL]     TypeInfo objTypeInfo = new TypeInfo(objTypePair.type); [EOL]     if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) { [EOL]         return; [EOL]     } [EOL]     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair); [EOL]     if (!visitedWithCustomHandler) { [EOL]         Object obj = objTypePair.getObject(); [EOL]         Object objectToVisit = (obj == null) ? visitor.getTarget() : obj; [EOL]         if (objectToVisit == null) { [EOL]             return; [EOL]         } [EOL]         objTypePair.setObject(objectToVisit); [EOL]         visitor.start(objTypePair); [EOL]         try { [EOL]             if (objTypeInfo.isArray()) { [EOL]                 visitor.visitArray(objectToVisit, objTypePair.type); [EOL]             } else if (objTypeInfo.getActualType() == Object.class && isPrimitiveOrString(objectToVisit)) { [EOL]                 visitor.visitPrimitive(objectToVisit); [EOL]                 objectToVisit = visitor.getTarget(); [EOL]             } else { [EOL]                 visitor.startVisitingObject(objectToVisit); [EOL]                 ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType(); [EOL]                 Class<?> topLevelClass = new TypeInfo(currObjTypePair.type).getRawClass(); [EOL]                 for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr = curr.getSuperclass()) { [EOL]                     if (!curr.isSynthetic()) { [EOL]                         navigateClassFields(objectToVisit, curr, visitor); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } finally { [EOL]             visitor.end(objTypePair); [EOL]         } [EOL]     } [EOL] }
public void accept(Visitor visitor) { [EOL]     TypeInfo objTypeInfo = new TypeInfo(objTypePair.type); [EOL]     if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) { [EOL]         return; [EOL]     } [EOL]     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair); [EOL]     if (!visitedWithCustomHandler) { [EOL]         Object obj = objTypePair.getObject(); [EOL]         Object objectToVisit = (obj == null) ? visitor.getTarget() : obj; [EOL]         if (objectToVisit == null) { [EOL]             return; [EOL]         } [EOL]         objTypePair.setObject(objectToVisit); [EOL]         visitor.start(objTypePair); [EOL]         try { [EOL]             if (objTypeInfo.isArray()) { [EOL]                 visitor.visitArray(objectToVisit, objTypePair.type); [EOL]             } else if (objTypeInfo.getActualType() == Object.class && isPrimitiveOrString(objectToVisit)) { [EOL]                 visitor.visitPrimitive(objectToVisit); [EOL]                 objectToVisit = visitor.getTarget(); [EOL]             } else { [EOL]                 visitor.startVisitingObject(objectToVisit); [EOL]                 ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType(); [EOL]                 Class<?> topLevelClass = new TypeInfo(currObjTypePair.type).getRawClass(); [EOL]                 for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr = curr.getSuperclass()) { [EOL]                     if (!curr.isSynthetic()) { [EOL]                         navigateClassFields(objectToVisit, curr, visitor); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } finally { [EOL]             visitor.end(objTypePair); [EOL]         } [EOL]     } [EOL] }
public void accept(Visitor visitor) { [EOL]     TypeInfo objTypeInfo = new TypeInfo(objTypePair.type); [EOL]     if (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) { [EOL]         return; [EOL]     } [EOL]     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair); [EOL]     if (!visitedWithCustomHandler) { [EOL]         Object obj = objTypePair.getObject(); [EOL]         Object objectToVisit = (obj == null) ? visitor.getTarget() : obj; [EOL]         if (objectToVisit == null) { [EOL]             return; [EOL]         } [EOL]         objTypePair.setObject(objectToVisit); [EOL]         visitor.start(objTypePair); [EOL]         try { [EOL]             if (objTypeInfo.isArray()) { [EOL]                 visitor.visitArray(objectToVisit, objTypePair.type); [EOL]             } else if (objTypeInfo.getActualType() == Object.class && isPrimitiveOrString(objectToVisit)) { [EOL]                 visitor.visitPrimitive(objectToVisit); [EOL]                 objectToVisit = visitor.getTarget(); [EOL]             } else { [EOL]                 visitor.startVisitingObject(objectToVisit); [EOL]                 ObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType(); [EOL]                 Class<?> topLevelClass = new TypeInfo(currObjTypePair.type).getRawClass(); [EOL]                 for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr = curr.getSuperclass()) { [EOL]                     if (!curr.isSynthetic()) { [EOL]                         navigateClassFields(objectToVisit, curr, visitor); [EOL]                     } [EOL]                 } [EOL]             } [EOL]         } finally { [EOL]             visitor.end(objTypePair); [EOL]         } [EOL]     } [EOL] }
public GsonBuilder generateNonExecutableJson() { [EOL]     this.generateNonExecutableJson = true; [EOL]     return this; [EOL] }
public GsonBuilder setLongSerializationPolicy(LongSerializationPolicy serializationPolicy) { [EOL]     this.longSerializationPolicy = serializationPolicy; [EOL]     return this; [EOL] }
public GsonBuilder setLongSerializationPolicy(LongSerializationPolicy serializationPolicy) { [EOL]     this.longSerializationPolicy = serializationPolicy; [EOL]     return this; [EOL] }
public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention) { [EOL]     return setFieldNamingStrategy(namingConvention.getFieldNamingPolicy()); [EOL] }
public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention) { [EOL]     return setFieldNamingStrategy(namingConvention.getFieldNamingPolicy()); [EOL] }
public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention) { [EOL]     return setFieldNamingStrategy(namingConvention.getFieldNamingPolicy()); [EOL] }
public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention) { [EOL]     return setFieldNamingStrategy(namingConvention.getFieldNamingPolicy()); [EOL] }
public GsonBuilder setFieldNamingPolicy(FieldNamingPolicy namingConvention) { [EOL]     return setFieldNamingStrategy(namingConvention.getFieldNamingPolicy()); [EOL] }
public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy) { [EOL]     return setFieldNamingStrategy(new FieldNamingStrategy2Adapter(fieldNamingStrategy)); [EOL] }
public GsonBuilder setFieldNamingStrategy(FieldNamingStrategy fieldNamingStrategy) { [EOL]     return setFieldNamingStrategy(new FieldNamingStrategy2Adapter(fieldNamingStrategy)); [EOL] }
GsonBuilder setFieldNamingStrategy(FieldNamingStrategy2 fieldNamingStrategy) { [EOL]     this.fieldNamingPolicy = new SerializedNameAnnotationInterceptingNamingPolicy(fieldNamingStrategy); [EOL]     return this; [EOL] }
GsonBuilder setFieldNamingStrategy(FieldNamingStrategy2 fieldNamingStrategy) { [EOL]     this.fieldNamingPolicy = new SerializedNameAnnotationInterceptingNamingPolicy(fieldNamingStrategy); [EOL]     return this; [EOL] }
private boolean isValidSince(Since annotation) { [EOL]     if (annotation != null) { [EOL]         double annotationVersion = annotation.value(); [EOL]         if (annotationVersion > version) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
private boolean isValidSince(Since annotation) { [EOL]     if (annotation != null) { [EOL]         double annotationVersion = annotation.value(); [EOL]         if (annotationVersion > version) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
private boolean isValidSince(Since annotation) { [EOL]     if (annotation != null) { [EOL]         double annotationVersion = annotation.value(); [EOL]         if (annotationVersion > version) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
private boolean isValidSince(Since annotation) { [EOL]     if (annotation != null) { [EOL]         double annotationVersion = annotation.value(); [EOL]         if (annotationVersion > version) { [EOL]             return false; [EOL]         } [EOL]     } [EOL]     return true; [EOL] }
public boolean hasModifier(int modifier) { [EOL]     return (modifiers & modifier) != 0; [EOL] }
public boolean hasModifier(int modifier) { [EOL]     return (modifiers & modifier) != 0; [EOL] }
public boolean hasModifier(int modifier) { [EOL]     return (modifiers & modifier) != 0; [EOL] }
public boolean hasModifier(int modifier) { [EOL]     return (modifiers & modifier) != 0; [EOL] }
public JsonPrimitive(String string) { [EOL]     setValue(string); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonPrimitive(String string) { [EOL]     setValue(string); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonPrimitive(String string) { [EOL]     setValue(string); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonPrimitive(String string) { [EOL]     setValue(string); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonPrimitive(String string) { [EOL]     setValue(string); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonPrimitive(String string) { [EOL]     setValue(string); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonPrimitive(String string) { [EOL]     setValue(string); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public JsonPrimitive(String string) { [EOL]     setValue(string); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public boolean isNumber() { [EOL]     return value instanceof Number; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public boolean isNumber() { [EOL]     return value instanceof Number; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public boolean isNumber() { [EOL]     return value instanceof Number; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
public boolean isNumber() { [EOL]     return value instanceof Number; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
static Number stringToNumber(String value) { [EOL]     try { [EOL]         long longValue = Long.parseLong(value); [EOL]         if (longValue >= Integer.MIN_VALUE && longValue <= Integer.MAX_VALUE) { [EOL]             return (int) longValue; [EOL]         } [EOL]         return longValue; [EOL]     } catch (NumberFormatException ignored) { [EOL]     } [EOL]     try { [EOL]         return new BigDecimal(value); [EOL]     } catch (NumberFormatException ignored) { [EOL]         return Double.parseDouble(value); [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
static Number stringToNumber(String value) { [EOL]     try { [EOL]         long longValue = Long.parseLong(value); [EOL]         if (longValue >= Integer.MIN_VALUE && longValue <= Integer.MAX_VALUE) { [EOL]             return (int) longValue; [EOL]         } [EOL]         return longValue; [EOL]     } catch (NumberFormatException ignored) { [EOL]     } [EOL]     try { [EOL]         return new BigDecimal(value); [EOL]     } catch (NumberFormatException ignored) { [EOL]         return Double.parseDouble(value); [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
static Number stringToNumber(String value) { [EOL]     try { [EOL]         long longValue = Long.parseLong(value); [EOL]         if (longValue >= Integer.MIN_VALUE && longValue <= Integer.MAX_VALUE) { [EOL]             return (int) longValue; [EOL]         } [EOL]         return longValue; [EOL]     } catch (NumberFormatException ignored) { [EOL]     } [EOL]     try { [EOL]         return new BigDecimal(value); [EOL]     } catch (NumberFormatException ignored) { [EOL]         return Double.parseDouble(value); [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
static Number stringToNumber(String value) { [EOL]     try { [EOL]         long longValue = Long.parseLong(value); [EOL]         if (longValue >= Integer.MIN_VALUE && longValue <= Integer.MAX_VALUE) { [EOL]             return (int) longValue; [EOL]         } [EOL]         return longValue; [EOL]     } catch (NumberFormatException ignored) { [EOL]     } [EOL]     try { [EOL]         return new BigDecimal(value); [EOL]     } catch (NumberFormatException ignored) { [EOL]         return Double.parseDouble(value); [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public String getAsString() { [EOL]     if (isNumber()) { [EOL]         return getAsNumber().toString(); [EOL]     } else if (isBoolean()) { [EOL]         return getAsBooleanWrapper().toString(); [EOL]     } else { [EOL]         return (String) value; [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public String getAsString() { [EOL]     if (isNumber()) { [EOL]         return getAsNumber().toString(); [EOL]     } else if (isBoolean()) { [EOL]         return getAsBooleanWrapper().toString(); [EOL]     } else { [EOL]         return (String) value; [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public String getAsString() { [EOL]     if (isNumber()) { [EOL]         return getAsNumber().toString(); [EOL]     } else if (isBoolean()) { [EOL]         return getAsBooleanWrapper().toString(); [EOL]     } else { [EOL]         return (String) value; [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public String getAsString() { [EOL]     if (isNumber()) { [EOL]         return getAsNumber().toString(); [EOL]     } else if (isBoolean()) { [EOL]         return getAsBooleanWrapper().toString(); [EOL]     } else { [EOL]         return (String) value; [EOL]     } [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public double getAsDouble() { [EOL]     return isNumber() ? getAsNumber().doubleValue() : Double.parseDouble(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public double getAsDouble() { [EOL]     return isNumber() ? getAsNumber().doubleValue() : Double.parseDouble(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public double getAsDouble() { [EOL]     return isNumber() ? getAsNumber().doubleValue() : Double.parseDouble(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public double getAsDouble() { [EOL]     return isNumber() ? getAsNumber().doubleValue() : Double.parseDouble(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public BigDecimal getAsBigDecimal() { [EOL]     return value instanceof BigDecimal ? (BigDecimal) value : new BigDecimal(value.toString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public BigDecimal getAsBigDecimal() { [EOL]     return value instanceof BigDecimal ? (BigDecimal) value : new BigDecimal(value.toString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public BigDecimal getAsBigDecimal() { [EOL]     return value instanceof BigDecimal ? (BigDecimal) value : new BigDecimal(value.toString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public BigDecimal getAsBigDecimal() { [EOL]     return value instanceof BigDecimal ? (BigDecimal) value : new BigDecimal(value.toString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public BigDecimal getAsBigDecimal() { [EOL]     return value instanceof BigDecimal ? (BigDecimal) value : new BigDecimal(value.toString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public int getAsInt() { [EOL]     return isNumber() ? getAsNumber().intValue() : Integer.parseInt(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public int getAsInt() { [EOL]     return isNumber() ? getAsNumber().intValue() : Integer.parseInt(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public int getAsInt() { [EOL]     return isNumber() ? getAsNumber().intValue() : Integer.parseInt(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] public int getAsInt() { [EOL]     return isNumber() ? getAsNumber().intValue() : Integer.parseInt(getAsString()); [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] Object getAsObject() { [EOL]     if (value instanceof BigInteger) { [EOL]         BigInteger big = (BigInteger) value; [EOL]         if (big.compareTo(INTEGER_MAX) < 0) { [EOL]             return big.intValue(); [EOL]         } else if (big.compareTo(LONG_MAX) < 0) { [EOL]             return big.longValue(); [EOL]         } [EOL]     } [EOL]     return value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] Object getAsObject() { [EOL]     if (value instanceof BigInteger) { [EOL]         BigInteger big = (BigInteger) value; [EOL]         if (big.compareTo(INTEGER_MAX) < 0) { [EOL]             return big.intValue(); [EOL]         } else if (big.compareTo(LONG_MAX) < 0) { [EOL]             return big.longValue(); [EOL]         } [EOL]     } [EOL]     return value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] Object getAsObject() { [EOL]     if (value instanceof BigInteger) { [EOL]         BigInteger big = (BigInteger) value; [EOL]         if (big.compareTo(INTEGER_MAX) < 0) { [EOL]             return big.intValue(); [EOL]         } else if (big.compareTo(LONG_MAX) < 0) { [EOL]             return big.longValue(); [EOL]         } [EOL]     } [EOL]     return value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] Object getAsObject() { [EOL]     if (value instanceof BigInteger) { [EOL]         BigInteger big = (BigInteger) value; [EOL]         if (big.compareTo(INTEGER_MAX) < 0) { [EOL]             return big.intValue(); [EOL]         } else if (big.compareTo(LONG_MAX) < 0) { [EOL]             return big.longValue(); [EOL]         } [EOL]     } [EOL]     return value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] Object getAsObject() { [EOL]     if (value instanceof BigInteger) { [EOL]         BigInteger big = (BigInteger) value; [EOL]         if (big.compareTo(INTEGER_MAX) < 0) { [EOL]             return big.intValue(); [EOL]         } else if (big.compareTo(LONG_MAX) < 0) { [EOL]             return big.longValue(); [EOL]         } [EOL]     } [EOL]     return value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
@Override [EOL] Object getAsObject() { [EOL]     if (value instanceof BigInteger) { [EOL]         BigInteger big = (BigInteger) value; [EOL]         if (big.compareTo(INTEGER_MAX) < 0) { [EOL]             return big.intValue(); [EOL]         } else if (big.compareTo(LONG_MAX) < 0) { [EOL]             return big.longValue(); [EOL]         } [EOL]     } [EOL]     return value; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
private static boolean isPrimitiveOrString(Object target) { [EOL]     if (target instanceof String) { [EOL]         return true; [EOL]     } [EOL]     Class<?> classOfPrimitive = target.getClass(); [EOL]     for (Class<?> standardPrimitive : PRIMITIVE_TYPES) { [EOL]         if (standardPrimitive.isAssignableFrom(classOfPrimitive)) { [EOL]             return true; [EOL]         } [EOL]     } [EOL]     return false; [EOL] } public JsonPrimitive(Boolean bool); public JsonPrimitive(Number number); public JsonPrimitive(String string); public JsonPrimitive(Character c);  JsonPrimitive(Object primitive);  void setValue(Object primitive); public boolean isBoolean();  Boolean getAsBooleanWrapper(); public boolean getAsBoolean(); public boolean isNumber(); public Number getAsNumber();  static Number stringToNumber(String value); public boolean isString(); public String getAsString(); public double getAsDouble(); public BigDecimal getAsBigDecimal(); public BigInteger getAsBigInteger(); public float getAsFloat(); public long getAsLong(); public short getAsShort(); public int getAsInt(); public byte getAsByte(); public char getAsCharacter();  Object getAsObject(); protected void toString(Appendable sb, Escaper escaper) throws IOException; private static boolean isPrimitiveOrString(Object target); public int hashCode(); public boolean equals(Object obj); private static boolean isIntegral(JsonPrimitive primitive); private static boolean isFloatingPoint(JsonPrimitive primitive); Class<?>[] PRIMITIVE_TYPES=Optional[{ int.class, long.class, short.class, float.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class, Short.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class }
private LongSerializationPolicy(Strategy strategy) { [EOL]     this.strategy = strategy; [EOL] }
public JsonElement serialize(Long value) { [EOL]     return new JsonPrimitive(value); [EOL] }
public JsonElement serialize(Long value) { [EOL]     return new JsonPrimitive(value); [EOL] }
public boolean isJsonArray() { [EOL]     return this instanceof JsonArray; [EOL] }
public boolean isJsonArray() { [EOL]     return this instanceof JsonArray; [EOL] }
public boolean isJsonObject() { [EOL]     return this instanceof JsonObject; [EOL] }
public boolean isJsonObject() { [EOL]     return this instanceof JsonObject; [EOL] }
public boolean isJsonPrimitive() { [EOL]     return this instanceof JsonPrimitive; [EOL] }
public boolean isJsonPrimitive() { [EOL]     return this instanceof JsonPrimitive; [EOL] }
public boolean isJsonPrimitive() { [EOL]     return this instanceof JsonPrimitive; [EOL] }
public boolean isJsonPrimitive() { [EOL]     return this instanceof JsonPrimitive; [EOL] }
public boolean isJsonNull() { [EOL]     return this instanceof JsonNull; [EOL] }
public boolean isJsonNull() { [EOL]     return this instanceof JsonNull; [EOL] }
public JsonArray getAsJsonArray() { [EOL]     if (isJsonArray()) { [EOL]         return (JsonArray) this; [EOL]     } [EOL]     throw new IllegalStateException("This is not a JSON Array."); [EOL] }
public JsonArray getAsJsonArray() { [EOL]     if (isJsonArray()) { [EOL]         return (JsonArray) this; [EOL]     } [EOL]     throw new IllegalStateException("This is not a JSON Array."); [EOL] }
public JsonPrimitive getAsJsonPrimitive() { [EOL]     if (isJsonPrimitive()) { [EOL]         return (JsonPrimitive) this; [EOL]     } [EOL]     throw new IllegalStateException("This is not a JSON Primitive."); [EOL] }
ObjectTypePair(Object obj, Type type, boolean preserveType) { [EOL]     this.obj = obj; [EOL]     this.type = type; [EOL]     this.preserveType = preserveType; [EOL] }
ObjectTypePair(Object obj, Type type, boolean preserveType) { [EOL]     this.obj = obj; [EOL]     this.type = type; [EOL]     this.preserveType = preserveType; [EOL] }
Object getObject() { [EOL]     return obj; [EOL] }
Object getObject() { [EOL]     return obj; [EOL] }
Type getType() { [EOL]     return type; [EOL] }
@Override [EOL] public String toString() { [EOL]     return String.format("preserveType: %b, type: %s, obj: %s", preserveType, type, obj); [EOL] }
@Override [EOL] public String toString() { [EOL]     return String.format("preserveType: %b, type: %s, obj: %s", preserveType, type, obj); [EOL] }
@Override [EOL] public String toString() { [EOL]     return String.format("preserveType: %b, type: %s, obj: %s", preserveType, type, obj); [EOL] }
@Override [EOL] public String toString() { [EOL]     return String.format("preserveType: %b, type: %s, obj: %s", preserveType, type, obj); [EOL] }
<HANDLER> Pair<HANDLER, ObjectTypePair> getMatchingHandler(ParameterizedTypeHandlerMap<HANDLER> handlers) { [EOL]     HANDLER handler = null; [EOL]     if (!preserveType && obj != null) { [EOL]         ObjectTypePair moreSpecificType = toMoreSpecificType(); [EOL]         handler = handlers.getHandlerFor(moreSpecificType.type); [EOL]         if (handler != null) { [EOL]             return new Pair<HANDLER, ObjectTypePair>(handler, moreSpecificType); [EOL]         } [EOL]     } [EOL]     handler = handlers.getHandlerFor(type); [EOL]     return handler == null ? null : new Pair<HANDLER, ObjectTypePair>(handler, this); [EOL] }
<HANDLER> Pair<HANDLER, ObjectTypePair> getMatchingHandler(ParameterizedTypeHandlerMap<HANDLER> handlers) { [EOL]     HANDLER handler = null; [EOL]     if (!preserveType && obj != null) { [EOL]         ObjectTypePair moreSpecificType = toMoreSpecificType(); [EOL]         handler = handlers.getHandlerFor(moreSpecificType.type); [EOL]         if (handler != null) { [EOL]             return new Pair<HANDLER, ObjectTypePair>(handler, moreSpecificType); [EOL]         } [EOL]     } [EOL]     handler = handlers.getHandlerFor(type); [EOL]     return handler == null ? null : new Pair<HANDLER, ObjectTypePair>(handler, this); [EOL] }
<HANDLER> Pair<HANDLER, ObjectTypePair> getMatchingHandler(ParameterizedTypeHandlerMap<HANDLER> handlers) { [EOL]     HANDLER handler = null; [EOL]     if (!preserveType && obj != null) { [EOL]         ObjectTypePair moreSpecificType = toMoreSpecificType(); [EOL]         handler = handlers.getHandlerFor(moreSpecificType.type); [EOL]         if (handler != null) { [EOL]             return new Pair<HANDLER, ObjectTypePair>(handler, moreSpecificType); [EOL]         } [EOL]     } [EOL]     handler = handlers.getHandlerFor(type); [EOL]     return handler == null ? null : new Pair<HANDLER, ObjectTypePair>(handler, this); [EOL] }
<HANDLER> Pair<HANDLER, ObjectTypePair> getMatchingHandler(ParameterizedTypeHandlerMap<HANDLER> handlers) { [EOL]     HANDLER handler = null; [EOL]     if (!preserveType && obj != null) { [EOL]         ObjectTypePair moreSpecificType = toMoreSpecificType(); [EOL]         handler = handlers.getHandlerFor(moreSpecificType.type); [EOL]         if (handler != null) { [EOL]             return new Pair<HANDLER, ObjectTypePair>(handler, moreSpecificType); [EOL]         } [EOL]     } [EOL]     handler = handlers.getHandlerFor(type); [EOL]     return handler == null ? null : new Pair<HANDLER, ObjectTypePair>(handler, this); [EOL] }
public void addProperty(String property, String value) { [EOL]     add(property, createJsonElement(value)); [EOL] }
public void addProperty(String property, String value) { [EOL]     add(property, createJsonElement(value)); [EOL] }
public void addProperty(String property, Character value) { [EOL]     add(property, createJsonElement(value)); [EOL] }
public void addProperty(String property, Character value) { [EOL]     add(property, createJsonElement(value)); [EOL] }
public void addProperty(String property, Character value) { [EOL]     add(property, createJsonElement(value)); [EOL] }
@Override [EOL] protected void toString(Appendable sb, Escaper escaper) throws IOException { [EOL]     sb.append('{'); [EOL]     boolean first = true; [EOL]     for (Map.Entry<String, JsonElement> entry : members.entrySet()) { [EOL]         if (first) { [EOL]             first = false; [EOL]         } else { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append('\"'); [EOL]         sb.append(escaper.escapeJsonString(entry.getKey())); [EOL]         sb.append("\":"); [EOL]         entry.getValue().toString(sb, escaper); [EOL]     } [EOL]     sb.append('}'); [EOL] }
@Override [EOL] protected void toString(Appendable sb, Escaper escaper) throws IOException { [EOL]     sb.append('{'); [EOL]     boolean first = true; [EOL]     for (Map.Entry<String, JsonElement> entry : members.entrySet()) { [EOL]         if (first) { [EOL]             first = false; [EOL]         } else { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append('\"'); [EOL]         sb.append(escaper.escapeJsonString(entry.getKey())); [EOL]         sb.append("\":"); [EOL]         entry.getValue().toString(sb, escaper); [EOL]     } [EOL]     sb.append('}'); [EOL] }
@Override [EOL] protected void toString(Appendable sb, Escaper escaper) throws IOException { [EOL]     sb.append('{'); [EOL]     boolean first = true; [EOL]     for (Map.Entry<String, JsonElement> entry : members.entrySet()) { [EOL]         if (first) { [EOL]             first = false; [EOL]         } else { [EOL]             sb.append(','); [EOL]         } [EOL]         sb.append('\"'); [EOL]         sb.append(escaper.escapeJsonString(entry.getKey())); [EOL]         sb.append("\":"); [EOL]         entry.getValue().toString(sb, escaper); [EOL]     } [EOL]     sb.append('}'); [EOL] }
